/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bech32/index.js":
/*!**************************************!*\
  !*** ./node_modules/bech32/index.js ***!
  \**************************************/
        /***/ ((module) => {

            "use strict";
            eval("\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmVjaDMyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2JlY2gzMi9pbmRleC5qcz9iZjJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xudmFyIEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJ1xuXG4vLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbnZhciBBTFBIQUJFVF9NQVAgPSB7fVxuZm9yICh2YXIgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdCh6KVxuXG4gIGlmIChBTFBIQUJFVF9NQVBbeF0gIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKVxuICBBTFBIQUJFVF9NQVBbeF0gPSB6XG59XG5cbmZ1bmN0aW9uIHBvbHltb2RTdGVwIChwcmUpIHtcbiAgdmFyIGIgPSBwcmUgPj4gMjVcbiAgcmV0dXJuICgocHJlICYgMHgxRkZGRkZGKSA8PCA1KSBeXG4gICAgKC0oKGIgPj4gMCkgJiAxKSAmIDB4M2I2YTU3YjIpIF5cbiAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgKC0oKGIgPj4gMykgJiAxKSAmIDB4M2Q0MjMzZGQpIF5cbiAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMylcbn1cblxuZnVuY3Rpb24gcHJlZml4Q2hrIChwcmVmaXgpIHtcbiAgdmFyIGNoayA9IDFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KSByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknXG5cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKGMgPj4gNSlcbiAgfVxuICBjaGsgPSBwb2x5bW9kU3RlcChjaGspXG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7ICsraSkge1xuICAgIHZhciB2ID0gcHJlZml4LmNoYXJDb2RlQXQoaSlcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKVxuICB9XG4gIHJldHVybiBjaGtcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuICBMSU1JVCA9IExJTUlUIHx8IDkwXG4gIGlmICgocHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGgpID4gTElNSVQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0JylcblxuICBwcmVmaXggPSBwcmVmaXgudG9Mb3dlckNhc2UoKVxuXG4gIC8vIGRldGVybWluZSBjaGsgbW9kXG4gIHZhciBjaGsgPSBwcmVmaXhDaGsocHJlZml4KVxuICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihjaGspXG5cbiAgdmFyIHJlc3VsdCA9IHByZWZpeCArICcxJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHggPSB3b3Jkc1tpXVxuICAgIGlmICgoeCA+PiA1KSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpXG5cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4geFxuICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQoeClcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspXG4gIH1cbiAgY2hrIF49IDFcblxuICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgdmFyIHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZlxuICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodilcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gX19kZWNvZGUgKHN0ciwgTElNSVQpIHtcbiAgTElNSVQgPSBMSU1JVCB8fCA5MFxuICBpZiAoc3RyLmxlbmd0aCA8IDgpIHJldHVybiBzdHIgKyAnIHRvbyBzaG9ydCdcbiAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVCkgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCdcblxuICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gIHZhciBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKClcbiAgdmFyIHVwcGVyZWQgPSBzdHIudG9VcHBlckNhc2UoKVxuICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZCkgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyXG4gIHN0ciA9IGxvd2VyZWRcblxuICB2YXIgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKVxuICBpZiAoc3BsaXQgPT09IC0xKSByZXR1cm4gJ05vIHNlcGFyYXRvciBjaGFyYWN0ZXIgZm9yICcgKyBzdHJcbiAgaWYgKHNwbGl0ID09PSAwKSByZXR1cm4gJ01pc3NpbmcgcHJlZml4IGZvciAnICsgc3RyXG5cbiAgdmFyIHByZWZpeCA9IHN0ci5zbGljZSgwLCBzcGxpdClcbiAgdmFyIHdvcmRDaGFycyA9IHN0ci5zbGljZShzcGxpdCArIDEpXG4gIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNikgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCdcblxuICB2YXIgY2hrID0gcHJlZml4Q2hrKHByZWZpeClcbiAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKSByZXR1cm4gY2hrXG5cbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHdvcmRDaGFycy5jaGFyQXQoaSlcbiAgICB2YXIgdiA9IEFMUEhBQkVUX01BUFtjXVxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGNcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdlxuXG4gICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cbiAgICBpZiAoaSArIDYgPj0gd29yZENoYXJzLmxlbmd0aCkgY29udGludWVcbiAgICB3b3Jkcy5wdXNoKHYpXG4gIH1cblxuICBpZiAoY2hrICE9PSAxKSByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHJcbiAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIHdvcmRzOiB3b3JkcyB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoKSB7XG4gIHZhciByZXMgPSBfX2RlY29kZS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JykgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZWNvZGUgKHN0cikge1xuICB2YXIgcmVzID0gX19kZWNvZGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpIHJldHVybiByZXNcblxuICB0aHJvdyBuZXcgRXJyb3IocmVzKVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0IChkYXRhLCBpbkJpdHMsIG91dEJpdHMsIHBhZCkge1xuICB2YXIgdmFsdWUgPSAwXG4gIHZhciBiaXRzID0gMFxuICB2YXIgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMVxuXG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gaW5CaXRzXG5cbiAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG4gICAgICBiaXRzIC09IG91dEJpdHNcbiAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA+PiBiaXRzKSAmIG1heFYpXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhZCkge1xuICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJpdHMgPj0gaW5CaXRzKSByZXR1cm4gJ0V4Y2VzcyBwYWRkaW5nJ1xuICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKSByZXR1cm4gJ05vbi16ZXJvIHBhZGRpbmcnXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvV29yZHNVbnNhZmUgKGJ5dGVzKSB7XG4gIHZhciByZXMgPSBjb252ZXJ0KGJ5dGVzLCA4LCA1LCB0cnVlKVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHRvV29yZHMgKGJ5dGVzKSB7XG4gIHZhciByZXMgPSBjb252ZXJ0KGJ5dGVzLCA4LCA1LCB0cnVlKVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSByZXR1cm4gcmVzXG5cbiAgdGhyb3cgbmV3IEVycm9yKHJlcylcbn1cblxuZnVuY3Rpb24gZnJvbVdvcmRzVW5zYWZlICh3b3Jkcykge1xuICB2YXIgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZnJvbVdvcmRzICh3b3Jkcykge1xuICB2YXIgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblxuICB0aHJvdyBuZXcgRXJyb3IocmVzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGU6IGVuY29kZSxcbiAgdG9Xb3Jkc1Vuc2FmZTogdG9Xb3Jkc1Vuc2FmZSxcbiAgdG9Xb3JkczogdG9Xb3JkcyxcbiAgZnJvbVdvcmRzVW5zYWZlOiBmcm9tV29yZHNVbnNhZmUsXG4gIGZyb21Xb3JkczogZnJvbVdvcmRzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bech32/index.js\n");

            /***/
        }),

        /***/ "./node_modules/bn.js/lib/bn.js":
        /*!**************************************!*\
          !*** ./node_modules/bn.js/lib/bn.js ***!
          \**************************************/
        /***/ (function (module, __unused_webpack_exports, __webpack_require__) {

            eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"?8131\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87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QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxNQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcz8zOTlmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbbnVtYmVyICYgMHgzZmZmZmZmXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICcwJyAtICc5J1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHtcbiAgICAgIHJldHVybiBjIC0gNDg7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgfSBlbHNlIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIGNoYXJhY3RlciBpbiAnICsgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgYiA9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgYiA9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gYztcbiAgICAgIH1cbiAgICAgIGFzc2VydChjID49IDAgJiYgYiA8IG11bCwgJ0ludmFsaWQgY2hhcmFjdGVyJyk7XG4gICAgICByICs9IGI7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1vdmUgKGRlc3QsIHNyYykge1xuICAgIGRlc3Qud29yZHMgPSBzcmMud29yZHM7XG4gICAgZGVzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSBzcmMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSBzcmMucmVkO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gX21vdmUgKGRlc3QpIHtcbiAgICBtb3ZlKGRlc3QsIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIENoZWNrIFN5bWJvbC5mb3IgYmVjYXVzZSBub3QgZXZlcnl3aGVyZSB3aGVyZSBTeW1ib2wgZGVmaW5lZFxuICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgQk4ucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gaW5zcGVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kcm4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICB9O1xuXG4gIGlmIChCdWZmZXIpIHtcbiAgICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZSAoQXJyYXlUeXBlLCBzaXplKSB7XG4gICAgaWYgKEFycmF5VHlwZS5hbGxvY1Vuc2FmZSkge1xuICAgICAgcmV0dXJuIEFycmF5VHlwZS5hbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc2l6ZSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdmFyIHJlcyA9IGFsbG9jYXRlKEFycmF5VHlwZSwgcmVxTGVuZ3RoKTtcbiAgICB2YXIgcG9zdGZpeCA9IGVuZGlhbiA9PT0gJ2xlJyA/ICdMRScgOiAnQkUnO1xuICAgIHRoaXNbJ190b0FycmF5TGlrZScgKyBwb3N0Zml4XShyZXMsIGJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlTEUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUJFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSByZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gPj4+IHdiaXQpICYgMHgwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICAvLyBUZW1wb3JhcnkgZGlzYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL2lzc3Vlcy8yMTFcbiAgICAvLyB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgLy8gcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gICAgcmV0dXJuIGJpZ011bFRvKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5fc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuX3N0cmlwKCk7XG4gICAgfVxuICAgIGEuX3N0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IChyMiA9PT0gMSAmJiBjbXAgPT09IDApKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uIG1vZHJuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IC1hY2MgOiBhY2M7XG4gIH07XG5cbiAgLy8gV0FSTklORzogREVQUkVDQVRFRFxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLm1vZHJuKG51bSk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICBtb3ZlKGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bn.js/lib/bn.js\n");

            /***/
        }),

        /***/ "./node_modules/events/events.js":
        /*!***************************************!*\
          !*** ./node_modules/events/events.js ***!
          \***************************************/
        /***/ ((module) => {

            "use strict";
            eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELFlBQVk7QUFDMUU7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mYWExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var hash = exports;\n\nhash.utils = __webpack_require__(/*! ./hash/utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nhash.common = __webpack_require__(/*! ./hash/common */ \"./node_modules/hash.js/lib/hash/common.js\");\nhash.sha = __webpack_require__(/*! ./hash/sha */ \"./node_modules/hash.js/lib/hash/sha.js\");\nhash.ripemd = __webpack_require__(/*! ./hash/ripemd */ \"./node_modules/hash.js/lib/hash/ripemd.js\");\nhash.hmac = __webpack_require__(/*! ./hash/hmac */ \"./node_modules/hash.js/lib/hash/hmac.js\");\n\n// Proxy hash functions to the main object\nhash.sha1 = hash.sha.sha1;\nhash.sha256 = hash.sha.sha256;\nhash.sha224 = hash.sha.sha224;\nhash.sha384 = hash.sha.sha384;\nhash.sha512 = hash.sha.sha512;\nhash.ripemd160 = hash.ripemd.ripemd160;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsOERBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGdFQUFlO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQywwREFBWTtBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0VBQWU7QUFDckMsWUFBWSxtQkFBTyxDQUFDLDREQUFhOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2guanM/N2Q5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction BlockHash() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\nexports.BlockHash = BlockHash;\n\nBlockHash.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils.toArray(msg, enc);\n  if (!this.pending)\n    this.pending = msg;\n  else\n    this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length;\n\n  // Enough data, try updating\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending;\n\n    // Process pending data in blocks\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0)\n      this.pending = null;\n\n    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n    for (var i = 0; i < msg.length; i += this._delta32)\n      this._update(msg, i, i + this._delta32);\n  }\n\n  return this;\n};\n\nBlockHash.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  assert(this.pending === null);\n\n  return this._digest(enc);\n};\n\nBlockHash.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - ((len + this.padLength) % bytes);\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n  for (var i = 1; i < k; i++)\n    res[i] = 0;\n\n  // Append length\n  len <<= 3;\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n  }\n\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHlEQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyx3RUFBcUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcz9lZGM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/common.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Hmac(hash, key, enc) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hash, key, enc);\n  this.Hash = hash;\n  this.blockSize = hash.blockSize / 8;\n  this.outSize = hash.outSize / 8;\n  this.inner = null;\n  this.outer = null;\n\n  this._init(utils.toArray(key, enc));\n}\nmodule.exports = Hmac;\n\nHmac.prototype._init = function init(key) {\n  // Shorten key, if needed\n  if (key.length > this.blockSize)\n    key = new this.Hash().update(key).digest();\n  assert(key.length <= this.blockSize);\n\n  // Add padding to key\n  for (var i = key.length; i < this.blockSize; i++)\n    key.push(0);\n\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x36;\n  this.inner = new this.Hash().update(key);\n\n  // 0x36 ^ 0x5c = 0x6a\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x6a;\n  this.outer = new this.Hash().update(key);\n};\n\nHmac.prototype.update = function update(msg, enc) {\n  this.inner.update(msg, enc);\n  return this;\n};\n\nHmac.prototype.digest = function digest(enc) {\n  this.outer.update(this.inner.digest());\n  return this.outer.digest(enc);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx5REFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsd0VBQXFCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQzs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzPzIxMzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4MzY7XG4gIHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cbiAgLy8gMHgzNiBeIDB4NWMgPSAweDZhXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4NmE7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG59O1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG4gIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/hmac.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_3 = utils.sum32_3;\nvar sum32_4 = utils.sum32_4;\nvar BlockHash = common.BlockHash;\n\nfunction RIPEMD160() {\n  if (!(this instanceof RIPEMD160))\n    return new RIPEMD160();\n\n  BlockHash.call(this);\n\n  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n  this.endian = 'little';\n}\nutils.inherits(RIPEMD160, BlockHash);\nexports.ripemd160 = RIPEMD160;\n\nRIPEMD160.blockSize = 512;\nRIPEMD160.outSize = 160;\nRIPEMD160.hmacStrength = 192;\nRIPEMD160.padLength = 64;\n\nRIPEMD160.prototype._update = function update(msg, start) {\n  var A = this.h[0];\n  var B = this.h[1];\n  var C = this.h[2];\n  var D = this.h[3];\n  var E = this.h[4];\n  var Ah = A;\n  var Bh = B;\n  var Ch = C;\n  var Dh = D;\n  var Eh = E;\n  for (var j = 0; j < 80; j++) {\n    var T = sum32(\n      rotl32(\n        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n        s[j]),\n      E);\n    A = E;\n    E = D;\n    D = rotl32(C, 10);\n    C = B;\n    B = T;\n    T = sum32(\n      rotl32(\n        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n        sh[j]),\n      Eh);\n    Ah = Eh;\n    Eh = Dh;\n    Dh = rotl32(Ch, 10);\n    Ch = Bh;\n    Bh = T;\n  }\n  T = sum32_3(this.h[1], C, Dh);\n  this.h[1] = sum32_3(this.h[2], D, Eh);\n  this.h[2] = sum32_3(this.h[3], E, Ah);\n  this.h[3] = sum32_3(this.h[4], A, Bh);\n  this.h[4] = sum32_3(this.h[0], B, Ch);\n  this.h[0] = T;\n};\n\nRIPEMD160.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'little');\n  else\n    return utils.split32(this.h, 'little');\n};\n\nfunction f(j, x, y, z) {\n  if (j <= 15)\n    return x ^ y ^ z;\n  else if (j <= 31)\n    return (x & y) | ((~x) & z);\n  else if (j <= 47)\n    return (x | (~y)) ^ z;\n  else if (j <= 63)\n    return (x & z) | (y & (~z));\n  else\n    return x ^ (y | (~z));\n}\n\nfunction K(j) {\n  if (j <= 15)\n    return 0x00000000;\n  else if (j <= 31)\n    return 0x5a827999;\n  else if (j <= 47)\n    return 0x6ed9eba1;\n  else if (j <= 63)\n    return 0x8f1bbcdc;\n  else\n    return 0xa953fd4e;\n}\n\nfunction Kh(j) {\n  if (j <= 15)\n    return 0x50a28be6;\n  else if (j <= 31)\n    return 0x5c4dd124;\n  else if (j <= 47)\n    return 0x6d703ef3;\n  else if (j <= 63)\n    return 0x7a6d76e9;\n  else\n    return 0x00000000;\n}\n\nvar r = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\n\nvar rh = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\n\nvar s = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\n\nvar sh = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHlEQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywyREFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcz9iYjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG5mdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG59XG51dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuUklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcblJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIEEgPSB0aGlzLmhbMF07XG4gIHZhciBCID0gdGhpcy5oWzFdO1xuICB2YXIgQyA9IHRoaXMuaFsyXTtcbiAgdmFyIEQgPSB0aGlzLmhbM107XG4gIHZhciBFID0gdGhpcy5oWzRdO1xuICB2YXIgQWggPSBBO1xuICB2YXIgQmggPSBCO1xuICB2YXIgQ2ggPSBDO1xuICB2YXIgRGggPSBEO1xuICB2YXIgRWggPSBFO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICB2YXIgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgc1tqXSksXG4gICAgICBFKTtcbiAgICBBID0gRTtcbiAgICBFID0gRDtcbiAgICBEID0gcm90bDMyKEMsIDEwKTtcbiAgICBDID0gQjtcbiAgICBCID0gVDtcbiAgICBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG4gICAgICAgIHNoW2pdKSxcbiAgICAgIEVoKTtcbiAgICBBaCA9IEVoO1xuICAgIEVoID0gRGg7XG4gICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICBDaCA9IEJoO1xuICAgIEJoID0gVDtcbiAgfVxuICBUID0gc3VtMzJfMyh0aGlzLmhbMV0sIEMsIERoKTtcbiAgdGhpcy5oWzFdID0gc3VtMzJfMyh0aGlzLmhbMl0sIEQsIEVoKTtcbiAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgdGhpcy5oWzNdID0gc3VtMzJfMyh0aGlzLmhbNF0sIEEsIEJoKTtcbiAgdGhpcy5oWzRdID0gc3VtMzJfMyh0aGlzLmhbMF0sIEIsIENoKTtcbiAgdGhpcy5oWzBdID0gVDtcbn07XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcbn07XG5cbmZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4geCBeIHkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICBlbHNlXG4gICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xufVxuXG5mdW5jdGlvbiBLKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmVkOWViYTE7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4OGYxYmJjZGM7XG4gIGVsc2VcbiAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcbn1cblxuZnVuY3Rpb24gS2goaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHg1MGEyOGJlNjtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YzRkZDEyNDtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZDcwM2VmMztcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg3YTZkNzZlOTtcbiAgZWxzZVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xufVxuXG52YXIgciA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXTtcblxudmFyIHJoID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dO1xuXG52YXIgcyA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl07XG5cbnZhciBzaCA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/ripemd.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.sha1 = __webpack_require__(/*! ./sha/1 */ \"./node_modules/hash.js/lib/hash/sha/1.js\");\nexports.sha224 = __webpack_require__(/*! ./sha/224 */ \"./node_modules/hash.js/lib/hash/sha/224.js\");\nexports.sha256 = __webpack_require__(/*! ./sha/256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\nexports.sha384 = __webpack_require__(/*! ./sha/384 */ \"./node_modules/hash.js/lib/hash/sha/384.js\");\nexports.sha512 = __webpack_require__(/*! ./sha/512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkZBQWlDO0FBQ2pDLG1HQUFxQztBQUNyQyxtR0FBcUM7QUFDckMsbUdBQXFDO0FBQ3JDLG1HQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLmpzPzU5MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYS8xJyk7XG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhLzIyNCcpO1xuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYS8yNTYnKTtcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEvMzg0Jyk7XG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhLzUxMicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_5 = utils.sum32_5;\nvar ft_1 = shaCommon.ft_1;\nvar BlockHash = common.BlockHash;\n\nvar sha1_K = [\n  0x5A827999, 0x6ED9EBA1,\n  0x8F1BBCDC, 0xCA62C1D6\n];\n\nfunction SHA1() {\n  if (!(this instanceof SHA1))\n    return new SHA1();\n\n  BlockHash.call(this);\n  this.h = [\n    0x67452301, 0xefcdab89, 0x98badcfe,\n    0x10325476, 0xc3d2e1f0 ];\n  this.W = new Array(80);\n}\n\nutils.inherits(SHA1, BlockHash);\nmodule.exports = SHA1;\n\nSHA1.blockSize = 512;\nSHA1.outSize = 160;\nSHA1.hmacStrength = 80;\nSHA1.padLength = 64;\n\nSHA1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n\n  for(; i < W.length; i++)\n    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n\n  for (i = 0; i < W.length; i++) {\n    var s = ~~(i / 20);\n    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n    e = d;\n    d = c;\n    c = rotl32(b, 30);\n    b = a;\n    a = t;\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n};\n\nSHA1.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDREQUFXO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLFFBQVEsY0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8xLmpzPzEzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/1.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar SHA256 = __webpack_require__(/*! ./256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\n\nfunction SHA224() {\n  if (!(this instanceof SHA224))\n    return new SHA224();\n\n  SHA256.call(this);\n  this.h = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];\n}\nutils.inherits(SHA224, SHA256);\nmodule.exports = SHA224;\n\nSHA224.blockSize = 512;\nSHA224.outSize = 224;\nSHA224.hmacStrength = 192;\nSHA224.padLength = 64;\n\nSHA224.prototype._digest = function digest(enc) {\n  // Just truncate output\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 7), 'big');\n  else\n    return utils.split32(this.h.slice(0, 7), 'big');\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjI0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMseURBQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzIyNC5qcz8wN2YyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBTSEEyNTYgPSByZXF1aXJlKCcuLzI1NicpO1xuXG5mdW5jdGlvbiBTSEEyMjQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyMjQpKVxuICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cbiAgU0hBMjU2LmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTIyNCwgU0hBMjU2KTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjI0O1xuXG5TSEEyMjQuYmxvY2tTaXplID0gNTEyO1xuU0hBMjI0Lm91dFNpemUgPSAyMjQ7XG5TSEEyMjQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjI0LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyMjQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIC8vIEp1c3QgdHJ1bmNhdGUgb3V0cHV0XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/224.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar sum32 = utils.sum32;\nvar sum32_4 = utils.sum32_4;\nvar sum32_5 = utils.sum32_5;\nvar ch32 = shaCommon.ch32;\nvar maj32 = shaCommon.maj32;\nvar s0_256 = shaCommon.s0_256;\nvar s1_256 = shaCommon.s1_256;\nvar g0_256 = shaCommon.g0_256;\nvar g1_256 = shaCommon.g1_256;\n\nvar BlockHash = common.BlockHash;\n\nvar sha256_K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfunction SHA256() {\n  if (!(this instanceof SHA256))\n    return new SHA256();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n  ];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\nutils.inherits(SHA256, BlockHash);\nmodule.exports = SHA256;\n\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\n\nSHA256.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i++)\n    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n\n  assert(this.k.length === W.length);\n  for (i = 0; i < W.length; i++) {\n    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n    var T2 = sum32(s0_256(a), maj32(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32(T1, T2);\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n  this.h[5] = sum32(this.h[5], f);\n  this.h[6] = sum32(this.h[6], g);\n  this.h[7] = sum32(this.h[7], h);\n};\n\nSHA256.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjU2LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsNERBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsK0RBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHdFQUFxQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLFNBQVMsY0FBYztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzI1Ni5qcz82ZWVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgY2gzMiA9IHNoYUNvbW1vbi5jaDMyO1xudmFyIG1hajMyID0gc2hhQ29tbW9uLm1hajMyO1xudmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG52YXIgczFfMjU2ID0gc2hhQ29tbW9uLnMxXzI1NjtcbnZhciBnMF8yNTYgPSBzaGFDb21tb24uZzBfMjU2O1xudmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuICBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/256.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\n\nvar SHA512 = __webpack_require__(/*! ./512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n\nfunction SHA384() {\n  if (!(this instanceof SHA384))\n    return new SHA384();\n\n  SHA512.call(this);\n  this.h = [\n    0xcbbb9d5d, 0xc1059ed8,\n    0x629a292a, 0x367cd507,\n    0x9159015a, 0x3070dd17,\n    0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31,\n    0x8eb44a87, 0x68581511,\n    0xdb0c2e0d, 0x64f98fa7,\n    0x47b5481d, 0xbefa4fa4 ];\n}\nutils.inherits(SHA384, SHA512);\nmodule.exports = SHA384;\n\nSHA384.blockSize = 1024;\nSHA384.outSize = 384;\nSHA384.hmacStrength = 192;\nSHA384.padLength = 128;\n\nSHA384.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 12), 'big');\n  else\n    return utils.split32(this.h.slice(0, 12), 'big');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTs7QUFFOUIsYUFBYSxtQkFBTyxDQUFDLHlEQUFPOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzPzhiOTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi81MTInKTtcblxuZnVuY3Rpb24gU0hBMzg0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG4gIFNIQTUxMi5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCxcbiAgICAweDYyOWEyOTJhLCAweDM2N2NkNTA3LFxuICAgIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsXG4gICAgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLFxuICAgIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsXG4gICAgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyxcbiAgICAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEzODQsIFNIQTUxMik7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTM4NDtcblxuU0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEEzODQub3V0U2l6ZSA9IDM4NDtcblNIQTM4NC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEEzODQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/384.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar rotr64_hi = utils.rotr64_hi;\nvar rotr64_lo = utils.rotr64_lo;\nvar shr64_hi = utils.shr64_hi;\nvar shr64_lo = utils.shr64_lo;\nvar sum64 = utils.sum64;\nvar sum64_hi = utils.sum64_hi;\nvar sum64_lo = utils.sum64_lo;\nvar sum64_4_hi = utils.sum64_4_hi;\nvar sum64_4_lo = utils.sum64_4_lo;\nvar sum64_5_hi = utils.sum64_5_hi;\nvar sum64_5_lo = utils.sum64_5_lo;\n\nvar BlockHash = common.BlockHash;\n\nvar sha512_K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction SHA512() {\n  if (!(this instanceof SHA512))\n    return new SHA512();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xf3bcc908,\n    0xbb67ae85, 0x84caa73b,\n    0x3c6ef372, 0xfe94f82b,\n    0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1,\n    0x9b05688c, 0x2b3e6c1f,\n    0x1f83d9ab, 0xfb41bd6b,\n    0x5be0cd19, 0x137e2179 ];\n  this.k = sha512_K;\n  this.W = new Array(160);\n}\nutils.inherits(SHA512, BlockHash);\nmodule.exports = SHA512;\n\nSHA512.blockSize = 1024;\nSHA512.outSize = 512;\nSHA512.hmacStrength = 192;\nSHA512.padLength = 128;\n\nSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n  var W = this.W;\n\n  // 32 x 32bit words\n  for (var i = 0; i < 32; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i += 2) {\n    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n    var c1_hi = W[i - 14];  // i - 7\n    var c1_lo = W[i - 13];\n    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n    var c3_hi = W[i - 32];  // i - 16\n    var c3_lo = W[i - 31];\n\n    W[i] = sum64_4_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n    W[i + 1] = sum64_4_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n  }\n};\n\nSHA512.prototype._update = function _update(msg, start) {\n  this._prepareBlock(msg, start);\n\n  var W = this.W;\n\n  var ah = this.h[0];\n  var al = this.h[1];\n  var bh = this.h[2];\n  var bl = this.h[3];\n  var ch = this.h[4];\n  var cl = this.h[5];\n  var dh = this.h[6];\n  var dl = this.h[7];\n  var eh = this.h[8];\n  var el = this.h[9];\n  var fh = this.h[10];\n  var fl = this.h[11];\n  var gh = this.h[12];\n  var gl = this.h[13];\n  var hh = this.h[14];\n  var hl = this.h[15];\n\n  assert(this.k.length === W.length);\n  for (var i = 0; i < W.length; i += 2) {\n    var c0_hi = hh;\n    var c0_lo = hl;\n    var c1_hi = s1_512_hi(eh, el);\n    var c1_lo = s1_512_lo(eh, el);\n    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n    var c3_hi = this.k[i];\n    var c3_lo = this.k[i + 1];\n    var c4_hi = W[i];\n    var c4_lo = W[i + 1];\n\n    var T1_hi = sum64_5_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n    var T1_lo = sum64_5_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n\n    c0_hi = s0_512_hi(ah, al);\n    c0_lo = s0_512_lo(ah, al);\n    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n\n    hh = gh;\n    hl = gl;\n\n    gh = fh;\n    gl = fl;\n\n    fh = eh;\n    fl = el;\n\n    eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n    el = sum64_lo(dl, dl, T1_hi, T1_lo);\n\n    dh = ch;\n    dl = cl;\n\n    ch = bh;\n    cl = bl;\n\n    bh = ah;\n    bl = al;\n\n    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n  }\n\n  sum64(this.h, 0, ah, al);\n  sum64(this.h, 2, bh, bl);\n  sum64(this.h, 4, ch, cl);\n  sum64(this.h, 6, dh, dl);\n  sum64(this.h, 8, eh, el);\n  sum64(this.h, 10, fh, fl);\n  sum64(this.h, 12, gh, gl);\n  sum64(this.h, 14, hh, hl);\n};\n\nSHA512.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction ch64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ ((~xh) & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ ((~xl) & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 28);\n  var c1_hi = rotr64_hi(xl, xh, 2);  // 34\n  var c2_hi = rotr64_hi(xl, xh, 7);  // 39\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 28);\n  var c1_lo = rotr64_lo(xl, xh, 2);  // 34\n  var c2_lo = rotr64_lo(xl, xh, 7);  // 39\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 14);\n  var c1_hi = rotr64_hi(xh, xl, 18);\n  var c2_hi = rotr64_hi(xl, xh, 9);  // 41\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 14);\n  var c1_lo = rotr64_lo(xh, xl, 18);\n  var c2_lo = rotr64_lo(xl, xh, 9);  // 41\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 1);\n  var c1_hi = rotr64_hi(xh, xl, 8);\n  var c2_hi = shr64_hi(xh, xl, 7);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 1);\n  var c1_lo = rotr64_lo(xh, xl, 8);\n  var c2_lo = shr64_lo(xh, xl, 7);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 19);\n  var c1_hi = rotr64_hi(xl, xh, 29);  // 61\n  var c2_hi = shr64_hi(xh, xl, 6);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 19);\n  var c1_lo = rotr64_lo(xl, xh, 29);  // 61\n  var c2_lo = shr64_lo(xh, xl, 6);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvNTEyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsNERBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLHdFQUFxQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxTQUFTLGNBQWM7QUFDdkIsZ0RBQWdEO0FBQ2hEO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzUxMi5qcz9iNTI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/512.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar rotr32 = utils.rotr32;\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0)\n    return ch32(x, y, z);\n  if (s === 1 || s === 3)\n    return p32(x, y, z);\n  if (s === 2)\n    return maj32(x, y, z);\n}\nexports.ft_1 = ft_1;\n\nfunction ch32(x, y, z) {\n  return (x & y) ^ ((~x) & z);\n}\nexports.ch32 = ch32;\n\nfunction maj32(x, y, z) {\n  return (x & y) ^ (x & z) ^ (y & z);\n}\nexports.maj32 = maj32;\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\nexports.p32 = p32;\n\nfunction s0_256(x) {\n  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\nexports.s0_256 = s0_256;\n\nfunction s1_256(x) {\n  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\nexports.s1_256 = s1_256;\n\nfunction g0_256(x) {\n  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\nexports.g0_256 = g0_256;\n\nfunction g1_256(x) {\n  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\nexports.g1_256 = g1_256;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzP2FhNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cbmV4cG9ydHMuZnRfMSA9IGZ0XzE7XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5leHBvcnRzLmNoMzIgPSBjaDMyO1xuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5leHBvcnRzLm1hajMyID0gbWFqMzI7XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5leHBvcnRzLnAzMiA9IHAzMjtcblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuZXhwb3J0cy5zMF8yNTYgPSBzMF8yNTY7XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cbmV4cG9ydHMuczFfMjU2ID0gczFfMjU2O1xuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cbmV4cG9ydHMuZzBfMjU2ID0gZzBfMjU2O1xuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuZXhwb3J0cy5nMV8yNTYgPSBnMV8yNTY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/common.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports.inherits = inherits;\n\nfunction isSurrogatePair(msg, i) {\n  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n    return false;\n  }\n  if (i < 0 || i + 1 >= msg.length) {\n    return false;\n  }\n  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n}\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg === 'string') {\n    if (!enc) {\n      // Inspired by stringToUtf8ByteArray() in closure-library by Google\n      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n      // Apache License 2.0\n      // https://github.com/google/closure-library/blob/master/LICENSE\n      var p = 0;\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n        if (c < 128) {\n          res[p++] = c;\n        } else if (c < 2048) {\n          res[p++] = (c >> 6) | 192;\n          res[p++] = (c & 63) | 128;\n        } else if (isSurrogatePair(msg, i)) {\n          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n          res[p++] = (c >> 18) | 240;\n          res[p++] = ((c >> 12) & 63) | 128;\n          res[p++] = ((c >> 6) & 63) | 128;\n          res[p++] = (c & 63) | 128;\n        } else {\n          res[p++] = (c >> 12) | 224;\n          res[p++] = ((c >> 6) & 63) | 128;\n          res[p++] = (c & 63) | 128;\n        }\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n      for (i = 0; i < msg.length; i += 2)\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n  } else {\n    for (i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n  }\n  return res;\n}\nexports.toArray = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nexports.toHex = toHex;\n\nfunction htonl(w) {\n  var res = (w >>> 24) |\n            ((w >>> 8) & 0xff00) |\n            ((w << 8) & 0xff0000) |\n            ((w & 0xff) << 24);\n  return res >>> 0;\n}\nexports.htonl = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little')\n      w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n  return res;\n}\nexports.toHex32 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nexports.zero2 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7)\n    return '0' + word;\n  else if (word.length === 6)\n    return '00' + word;\n  else if (word.length === 5)\n    return '000' + word;\n  else if (word.length === 4)\n    return '0000' + word;\n  else if (word.length === 3)\n    return '00000' + word;\n  else if (word.length === 2)\n    return '000000' + word;\n  else if (word.length === 1)\n    return '0000000' + word;\n  else\n    return word;\n}\nexports.zero8 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  assert(len % 4 === 0);\n  var res = new Array(len / 4);\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big')\n      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n    else\n      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n    res[i] = w >>> 0;\n  }\n  return res;\n}\nexports.join32 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = (m >>> 16) & 0xff;\n      res[k + 2] = (m >>> 8) & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = (m >>> 16) & 0xff;\n      res[k + 1] = (m >>> 8) & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n  return res;\n}\nexports.split32 = split32;\n\nfunction rotr32(w, b) {\n  return (w >>> b) | (w << (32 - b));\n}\nexports.rotr32 = rotr32;\n\nfunction rotl32(w, b) {\n  return (w << b) | (w >>> (32 - b));\n}\nexports.rotl32 = rotl32;\n\nfunction sum32(a, b) {\n  return (a + b) >>> 0;\n}\nexports.sum32 = sum32;\n\nfunction sum32_3(a, b, c) {\n  return (a + b + c) >>> 0;\n}\nexports.sum32_3 = sum32_3;\n\nfunction sum32_4(a, b, c, d) {\n  return (a + b + c + d) >>> 0;\n}\nexports.sum32_4 = sum32_4;\n\nfunction sum32_5(a, b, c, d, e) {\n  return (a + b + c + d + e) >>> 0;\n}\nexports.sum32_5 = sum32_5;\n\nfunction sum64(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\nexports.sum64 = sum64;\n\nfunction sum64_hi(ah, al, bh, bl) {\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n}\nexports.sum64_hi = sum64_hi;\n\nfunction sum64_lo(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n}\nexports.sum64_lo = sum64_lo;\n\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n}\nexports.sum64_4_hi = sum64_4_hi;\n\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n}\nexports.sum64_4_lo = sum64_4_lo;\n\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = (lo + el) >>> 0;\n  carry += lo < el ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n}\nexports.sum64_5_hi = sum64_5_hi;\n\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n\n  return lo >>> 0;\n}\nexports.sum64_5_lo = sum64_5_lo;\n\nfunction rotr64_hi(ah, al, num) {\n  var r = (al << (32 - num)) | (ah >>> num);\n  return r >>> 0;\n}\nexports.rotr64_hi = rotr64_hi;\n\nfunction rotr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.rotr64_lo = rotr64_lo;\n\nfunction shr64_hi(ah, al, num) {\n  return ah >>> num;\n}\nexports.shr64_hi = shr64_hi;\n\nfunction shr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.shr64_lo = shr64_lo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0VBQXFCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcz9jM2MwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKG1zZywgaSkge1xuICBpZiAoKG1zZy5jaGFyQ29kZUF0KGkpICYgMHhGQzAwKSAhPT0gMHhEODAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpIDwgMCB8fCBpICsgMSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAobXNnLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFlbmMpIHtcbiAgICAgIC8vIEluc3BpcmVkIGJ5IHN0cmluZ1RvVXRmOEJ5dGVBcnJheSgpIGluIGNsb3N1cmUtbGlicmFyeSBieSBHb29nbGVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvODU5OGQ4NzI0MmFmNTlhYWMyMzMyNzA3NDJjODk4NGUyYjJiZGJlMC9jbG9zdXJlL2dvb2cvY3J5cHQvY3J5cHQuanMjTDExNy1MMTQzXG4gICAgICAvLyBBcGFjaGUgTGljZW5zZSAyLjBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3Vycm9nYXRlUGFpcihtc2csIGkpKSB7XG4gICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzRkYpIDw8IDEwKSArIChtc2cuY2hhckNvZGVBdCgrK2kpICYgMHgwM0ZGKTtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG5leHBvcnRzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXgzMiA9IHRvSGV4MzI7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuam9pbjMyID0gam9pbjMyO1xuXG5mdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciBtID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgICByZXNba10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RsMzIgPSByb3RsMzI7XG5cbmZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcbiAgcmV0dXJuIChhICsgYikgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNCA9IHN1bTMyXzQ7XG5cbmZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcbiAgdmFyIGJoID0gYnVmW3Bvc107XG4gIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcbiAgYnVmW3BvcyArIDFdID0gbG87XG59XG5leHBvcnRzLnN1bTY0ID0gc3VtNjQ7XG5cbmZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2hpID0gc3VtNjRfNF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcblxuZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufVxuZXhwb3J0cy5zaHI2NF9oaSA9IHNocjY0X2hpO1xuXG5mdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/utils.js\n");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz8zZmI1Il0sInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/js-sha3/src/sha3.js":
/*!******************************************!*\
  !*** ./node_modules/js-sha3/src/sha3.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA3_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = __webpack_require__.g;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && \"object\" === 'object' && module.exports;\n  var AMD =  true && __webpack_require__.amdO;\n  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n  var PADDING = [6, 1536, 393216, 100663296];\n  var SHIFT = [0, 8, 16, 24];\n  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\n    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\n    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\n    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\n    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n  var BITS = [224, 256, 384, 512];\n  var SHAKE_BITS = [128, 256];\n  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n  var CSHAKE_BYTEPAD = {\n    '128': 168,\n    '256': 136\n  };\n\n  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (bits, padding, outputType) {\n    return function (message) {\n      return new Keccak(bits, padding, bits).update(message)[outputType]();\n    };\n  };\n\n  var createShakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits) {\n      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n    };\n  };\n\n  var createCshakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits, n, s) {\n      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n    };\n  };\n\n  var createKmacOutputMethod = function (bits, padding, outputType) {\n    return function (key, message, outputBits, s) {\n      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n    };\n  };\n\n  var createOutputMethods = function (method, createMethod, bits, padding) {\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createMethod(bits, padding, type);\n    }\n    return method;\n  };\n\n  var createMethod = function (bits, padding) {\n    var method = createOutputMethod(bits, padding, 'hex');\n    method.create = function () {\n      return new Keccak(bits, padding, bits);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    return createOutputMethods(method, createOutputMethod, bits, padding);\n  };\n\n  var createShakeMethod = function (bits, padding) {\n    var method = createShakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits) {\n      return new Keccak(bits, padding, outputBits);\n    };\n    method.update = function (message, outputBits) {\n      return method.create(outputBits).update(message);\n    };\n    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n  };\n\n  var createCshakeMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createCshakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits, n, s) {\n      if (!n && !s) {\n        return methods['shake' + bits].create(outputBits);\n      } else {\n        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n      }\n    };\n    method.update = function (message, outputBits, n, s) {\n      return method.create(outputBits, n, s).update(message);\n    };\n    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n  };\n\n  var createKmacMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createKmacOutputMethod(bits, padding, 'hex');\n    method.create = function (key, outputBits, s) {\n      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n    };\n    method.update = function (key, message, outputBits, s) {\n      return method.create(key, outputBits, s).update(message);\n    };\n    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n  };\n\n  var algorithms = [\n    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n  ];\n\n  var methods = {}, methodNames = [];\n\n  for (var i = 0; i < algorithms.length; ++i) {\n    var algorithm = algorithms[i];\n    var bits = algorithm.bits;\n    for (var j = 0; j < bits.length; ++j) {\n      var methodName = algorithm.name + '_' + bits[j];\n      methodNames.push(methodName);\n      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n      if (algorithm.name !== 'sha3') {\n        var newMethodName = algorithm.name + bits[j];\n        methodNames.push(newMethodName);\n        methods[newMethodName] = methods[methodName];\n      }\n    }\n  }\n\n  function Keccak(bits, padding, outputBits) {\n    this.blocks = [];\n    this.s = [];\n    this.padding = padding;\n    this.outputBits = outputBits;\n    this.reset = true;\n    this.finalized = false;\n    this.block = 0;\n    this.start = 0;\n    this.blockCount = (1600 - (bits << 1)) >> 5;\n    this.byteCount = this.blockCount << 2;\n    this.outputBlocks = outputBits >> 5;\n    this.extraBytes = (outputBits & 31) >> 3;\n\n    for (var i = 0; i < 50; ++i) {\n      this.s[i] = 0;\n    }\n  }\n\n  Keccak.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,\n      blockCount = this.blockCount, index = 0, s = this.s, i, code;\n\n    while (index < length) {\n      if (this.reset) {\n        this.reset = false;\n        blocks[0] = this.block;\n        for (i = 1; i < blockCount + 1; ++i) {\n          blocks[i] = 0;\n        }\n      }\n      if (notString) {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      if (i >= byteCount) {\n        this.start = i - byteCount;\n        this.block = blocks[blockCount];\n        for (i = 0; i < blockCount; ++i) {\n          s[i] ^= blocks[i];\n        }\n        f(s);\n        this.reset = true;\n      } else {\n        this.start = i;\n      }\n    }\n    return this;\n  };\n\n  Keccak.prototype.encode = function (x, right) {\n    var o = x & 255, n = 1;\n    var bytes = [o];\n    x = x >> 8;\n    o = x & 255;\n    while (o > 0) {\n      bytes.unshift(o);\n      x = x >> 8;\n      o = x & 255;\n      ++n;\n    }\n    if (right) {\n      bytes.push(n);\n    } else {\n      bytes.unshift(n);\n    }\n    this.update(bytes);\n    return bytes.length;\n  };\n\n  Keccak.prototype.encodeString = function (str) {\n    var notString, type = typeof str;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (str === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n          str = new Uint8Array(str);\n        } else if (!Array.isArray(str)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var bytes = 0, length = str.length;\n    if (notString) {\n      bytes = length;\n    } else {\n      for (var i = 0; i < str.length; ++i) {\n        var code = str.charCodeAt(i);\n        if (code < 0x80) {\n          bytes += 1;\n        } else if (code < 0x800) {\n          bytes += 2;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes += 3;\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));\n          bytes += 4;\n        }\n      }\n    }\n    bytes += this.encode(bytes * 8);\n    this.update(str);\n    return bytes;\n  };\n\n  Keccak.prototype.bytepad = function (strs, w) {\n    var bytes = this.encode(w);\n    for (var i = 0; i < strs.length; ++i) {\n      bytes += this.encodeString(strs[i]);\n    }\n    var paddingBytes = w - bytes % w;\n    var zeros = [];\n    zeros.length = paddingBytes;\n    this.update(zeros);\n    return this;\n  };\n\n  Keccak.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n    blocks[i >> 2] |= this.padding[i & 3];\n    if (this.lastByteIndex === this.byteCount) {\n      blocks[0] = blocks[blockCount];\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n    blocks[blockCount - 1] |= 0x80000000;\n    for (i = 0; i < blockCount; ++i) {\n      s[i] ^= blocks[i];\n    }\n    f(s);\n  };\n\n  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var hex = '', block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        block = s[i];\n        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\n          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\n          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\n          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n        i = 0;\n      }\n    }\n    if (extraBytes) {\n      block = s[i];\n      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\n      if (extraBytes > 1) {\n        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\n      }\n      if (extraBytes > 2) {\n        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\n      }\n    }\n    return hex;\n  };\n\n  Keccak.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var bytes = this.outputBits >> 3;\n    var buffer;\n    if (extraBytes) {\n      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\n    } else {\n      buffer = new ArrayBuffer(bytes);\n    }\n    var array = new Uint32Array(buffer);\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        array[j] = s[i];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      array[i] = s[i];\n      buffer = buffer.slice(0, bytes);\n    }\n    return buffer;\n  };\n\n  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n  Keccak.prototype.digest = Keccak.prototype.array = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var array = [], offset, block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        offset = j << 2;\n        block = s[i];\n        array[offset] = block & 0xFF;\n        array[offset + 1] = (block >> 8) & 0xFF;\n        array[offset + 2] = (block >> 16) & 0xFF;\n        array[offset + 3] = (block >> 24) & 0xFF;\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      offset = j << 2;\n      block = s[i];\n      array[offset] = block & 0xFF;\n      if (extraBytes > 1) {\n        array[offset + 1] = (block >> 8) & 0xFF;\n      }\n      if (extraBytes > 2) {\n        array[offset + 2] = (block >> 16) & 0xFF;\n      }\n    }\n    return array;\n  };\n\n  function Kmac(bits, padding, outputBits) {\n    Keccak.call(this, bits, padding, outputBits);\n  }\n\n  Kmac.prototype = new Keccak();\n\n  Kmac.prototype.finalize = function () {\n    this.encode(this.outputBits, true);\n    return Keccak.prototype.finalize.call(this);\n  };\n\n  var f = function (s) {\n    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\n      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\n      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n    for (n = 0; n < 48; n += 2) {\n      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\n      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\n      s[0] ^= h;\n      s[1] ^= l;\n      s[10] ^= h;\n      s[11] ^= l;\n      s[20] ^= h;\n      s[21] ^= l;\n      s[30] ^= h;\n      s[31] ^= l;\n      s[40] ^= h;\n      s[41] ^= l;\n      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\n      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\n      s[2] ^= h;\n      s[3] ^= l;\n      s[12] ^= h;\n      s[13] ^= l;\n      s[22] ^= h;\n      s[23] ^= l;\n      s[32] ^= h;\n      s[33] ^= l;\n      s[42] ^= h;\n      s[43] ^= l;\n      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\n      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\n      s[4] ^= h;\n      s[5] ^= l;\n      s[14] ^= h;\n      s[15] ^= l;\n      s[24] ^= h;\n      s[25] ^= l;\n      s[34] ^= h;\n      s[35] ^= l;\n      s[44] ^= h;\n      s[45] ^= l;\n      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\n      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\n      s[6] ^= h;\n      s[7] ^= l;\n      s[16] ^= h;\n      s[17] ^= l;\n      s[26] ^= h;\n      s[27] ^= l;\n      s[36] ^= h;\n      s[37] ^= l;\n      s[46] ^= h;\n      s[47] ^= l;\n      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\n      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\n      s[8] ^= h;\n      s[9] ^= l;\n      s[18] ^= h;\n      s[19] ^= l;\n      s[28] ^= h;\n      s[29] ^= l;\n      s[38] ^= h;\n      s[39] ^= l;\n      s[48] ^= h;\n      s[49] ^= l;\n\n      b0 = s[0];\n      b1 = s[1];\n      b32 = (s[11] << 4) | (s[10] >>> 28);\n      b33 = (s[10] << 4) | (s[11] >>> 28);\n      b14 = (s[20] << 3) | (s[21] >>> 29);\n      b15 = (s[21] << 3) | (s[20] >>> 29);\n      b46 = (s[31] << 9) | (s[30] >>> 23);\n      b47 = (s[30] << 9) | (s[31] >>> 23);\n      b28 = (s[40] << 18) | (s[41] >>> 14);\n      b29 = (s[41] << 18) | (s[40] >>> 14);\n      b20 = (s[2] << 1) | (s[3] >>> 31);\n      b21 = (s[3] << 1) | (s[2] >>> 31);\n      b2 = (s[13] << 12) | (s[12] >>> 20);\n      b3 = (s[12] << 12) | (s[13] >>> 20);\n      b34 = (s[22] << 10) | (s[23] >>> 22);\n      b35 = (s[23] << 10) | (s[22] >>> 22);\n      b16 = (s[33] << 13) | (s[32] >>> 19);\n      b17 = (s[32] << 13) | (s[33] >>> 19);\n      b48 = (s[42] << 2) | (s[43] >>> 30);\n      b49 = (s[43] << 2) | (s[42] >>> 30);\n      b40 = (s[5] << 30) | (s[4] >>> 2);\n      b41 = (s[4] << 30) | (s[5] >>> 2);\n      b22 = (s[14] << 6) | (s[15] >>> 26);\n      b23 = (s[15] << 6) | (s[14] >>> 26);\n      b4 = (s[25] << 11) | (s[24] >>> 21);\n      b5 = (s[24] << 11) | (s[25] >>> 21);\n      b36 = (s[34] << 15) | (s[35] >>> 17);\n      b37 = (s[35] << 15) | (s[34] >>> 17);\n      b18 = (s[45] << 29) | (s[44] >>> 3);\n      b19 = (s[44] << 29) | (s[45] >>> 3);\n      b10 = (s[6] << 28) | (s[7] >>> 4);\n      b11 = (s[7] << 28) | (s[6] >>> 4);\n      b42 = (s[17] << 23) | (s[16] >>> 9);\n      b43 = (s[16] << 23) | (s[17] >>> 9);\n      b24 = (s[26] << 25) | (s[27] >>> 7);\n      b25 = (s[27] << 25) | (s[26] >>> 7);\n      b6 = (s[36] << 21) | (s[37] >>> 11);\n      b7 = (s[37] << 21) | (s[36] >>> 11);\n      b38 = (s[47] << 24) | (s[46] >>> 8);\n      b39 = (s[46] << 24) | (s[47] >>> 8);\n      b30 = (s[8] << 27) | (s[9] >>> 5);\n      b31 = (s[9] << 27) | (s[8] >>> 5);\n      b12 = (s[18] << 20) | (s[19] >>> 12);\n      b13 = (s[19] << 20) | (s[18] >>> 12);\n      b44 = (s[29] << 7) | (s[28] >>> 25);\n      b45 = (s[28] << 7) | (s[29] >>> 25);\n      b26 = (s[38] << 8) | (s[39] >>> 24);\n      b27 = (s[39] << 8) | (s[38] >>> 24);\n      b8 = (s[48] << 14) | (s[49] >>> 18);\n      b9 = (s[49] << 14) | (s[48] >>> 18);\n\n      s[0] = b0 ^ (~b2 & b4);\n      s[1] = b1 ^ (~b3 & b5);\n      s[10] = b10 ^ (~b12 & b14);\n      s[11] = b11 ^ (~b13 & b15);\n      s[20] = b20 ^ (~b22 & b24);\n      s[21] = b21 ^ (~b23 & b25);\n      s[30] = b30 ^ (~b32 & b34);\n      s[31] = b31 ^ (~b33 & b35);\n      s[40] = b40 ^ (~b42 & b44);\n      s[41] = b41 ^ (~b43 & b45);\n      s[2] = b2 ^ (~b4 & b6);\n      s[3] = b3 ^ (~b5 & b7);\n      s[12] = b12 ^ (~b14 & b16);\n      s[13] = b13 ^ (~b15 & b17);\n      s[22] = b22 ^ (~b24 & b26);\n      s[23] = b23 ^ (~b25 & b27);\n      s[32] = b32 ^ (~b34 & b36);\n      s[33] = b33 ^ (~b35 & b37);\n      s[42] = b42 ^ (~b44 & b46);\n      s[43] = b43 ^ (~b45 & b47);\n      s[4] = b4 ^ (~b6 & b8);\n      s[5] = b5 ^ (~b7 & b9);\n      s[14] = b14 ^ (~b16 & b18);\n      s[15] = b15 ^ (~b17 & b19);\n      s[24] = b24 ^ (~b26 & b28);\n      s[25] = b25 ^ (~b27 & b29);\n      s[34] = b34 ^ (~b36 & b38);\n      s[35] = b35 ^ (~b37 & b39);\n      s[44] = b44 ^ (~b46 & b48);\n      s[45] = b45 ^ (~b47 & b49);\n      s[6] = b6 ^ (~b8 & b0);\n      s[7] = b7 ^ (~b9 & b1);\n      s[16] = b16 ^ (~b18 & b10);\n      s[17] = b17 ^ (~b19 & b11);\n      s[26] = b26 ^ (~b28 & b20);\n      s[27] = b27 ^ (~b29 & b21);\n      s[36] = b36 ^ (~b38 & b30);\n      s[37] = b37 ^ (~b39 & b31);\n      s[46] = b46 ^ (~b48 & b40);\n      s[47] = b47 ^ (~b49 & b41);\n      s[8] = b8 ^ (~b0 & b2);\n      s[9] = b9 ^ (~b1 & b3);\n      s[18] = b18 ^ (~b10 & b12);\n      s[19] = b19 ^ (~b11 & b13);\n      s[28] = b28 ^ (~b20 & b22);\n      s[29] = b29 ^ (~b21 & b23);\n      s[38] = b38 ^ (~b30 & b32);\n      s[39] = b39 ^ (~b31 & b33);\n      s[48] = b48 ^ (~b40 & b42);\n      s[49] = b49 ^ (~b41 & b43);\n\n      s[0] ^= RC[n];\n      s[1] ^= RC[n + 1];\n    }\n  };\n\n  if (COMMON_JS) {\n    module.exports = methods;\n  } else {\n    for (i = 0; i < methodNames.length; ++i) {\n      root[methodNames[i]] = methods[methodNames[i]];\n    }\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return methods;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFNO0FBQ2pCLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0RBQWdELFFBQWE7QUFDN0QsWUFBWSxLQUE0QixJQUFJLHdCQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGlGQUFpRjtBQUN2RixNQUFNLHdFQUF3RTtBQUM5RSxNQUFNLDBGQUEwRjtBQUNoRyxNQUFNLDZGQUE2RjtBQUNuRyxNQUFNO0FBQ047O0FBRUEsa0JBQWtCOztBQUVsQixrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBLFFBQVE7QUFDUiw2QkFBNkIsaUNBQWlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQ0FBb0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQ0FBb0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0NBQW9DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUNBQU87QUFDYjtBQUNBLE9BQU87QUFBQSxrR0FBQztBQUNSO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcz8xYzU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAqXG4gKiBAdmVyc2lvbiAwLjguMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJTlBVVF9FUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgRklOQUxJWkVfRVJST1IgPSAnZmluYWxpemUgYWxyZWFkeSBjYWxsZWQnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTNfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICBpZiAoTk9ERV9KUykge1xuICAgIHJvb3QgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoV0VCX1dPUktFUikge1xuICAgIHJvb3QgPSBzZWxmO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19TSEEzX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgU0hBS0VfUEFERElORyA9IFszMSwgNzkzNiwgMjAzMTYxNiwgNTIwMDkzNjk2XTtcbiAgdmFyIENTSEFLRV9QQURESU5HID0gWzQsIDEwMjQsIDI2MjE0NCwgNjcxMDg4NjRdO1xuICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XG4gIHZhciBTSElGVCA9IFswLCA4LCAxNiwgMjRdO1xuICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcbiAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXG4gICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXG4gICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xuICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xuICB2YXIgU0hBS0VfQklUUyA9IFsxMjgsIDI1Nl07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknLCAnZGlnZXN0J107XG4gIHZhciBDU0hBS0VfQllURVBBRCA9IHtcbiAgICAnMTI4JzogMTY4LFxuICAgICcyNTYnOiAxMzZcbiAgfTtcblxuICBpZiAocm9vdC5KU19TSEEzX05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmJ1ZmZlciAmJiBvYmouYnVmZmVyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2NzaGFrZScgKyBiaXRzXS51cGRhdGUobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2ttYWMnICsgYml0c10udXBkYXRlKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZCwgY3JlYXRlTWV0aG9kLCBiaXRzLCBwYWRkaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlTWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlU2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICBpZiAoIW4gJiYgIXMpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHNbJ3NoYWtlJyArIGJpdHNdLmNyZWF0ZShvdXRwdXRCaXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoW24sIHNdLCB3KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cywgbiwgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdO1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG5ldyBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoWydLTUFDJywgc10sIHcpLmJ5dGVwYWQoW2tleV0sIHcpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSwgb3V0cHV0Qml0cywgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtcyA9IFtcbiAgICB7IG5hbWU6ICdrZWNjYWsnLCBwYWRkaW5nOiBLRUNDQUtfUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGEzJywgcGFkZGluZzogUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdjc2hha2UnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVDc2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdrbWFjJywgcGFkZGluZzogQ1NIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlS21hY01ldGhvZCB9XG4gIF07XG5cbiAgdmFyIG1ldGhvZHMgPSB7fSwgbWV0aG9kTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTtcbiAgICB2YXIgYml0cyA9IGFsZ29yaXRobS5iaXRzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYml0cy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07XG4gICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSwgYWxnb3JpdGhtLnBhZGRpbmcpO1xuICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSAnc2hhMycpIHtcbiAgICAgICAgdmFyIG5ld01ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArIGJpdHNbal07XG4gICAgICAgIG1ldGhvZE5hbWVzLnB1c2gobmV3TWV0aG9kTmFtZSk7XG4gICAgICAgIG1ldGhvZHNbbmV3TWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICB0aGlzLnMgPSBbXTtcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XG4gICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJsb2NrID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gdGhpcy5ibG9ja0NvdW50IDw8IDI7XG4gICAgdGhpcy5vdXRwdXRCbG9ja3MgPSBvdXRwdXRCaXRzID4+IDU7XG4gICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xuICAgICAgdGhpcy5zW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRklOQUxJWkVfRVJST1IpO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsXG4gICAgICBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBpbmRleCA9IDAsIHMgPSB0aGlzLnMsIGksIGNvZGU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLnJlc2V0KSB7XG4gICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgZihzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoeCwgcmlnaHQpIHtcbiAgICB2YXIgbyA9IHggJiAyNTUsIG4gPSAxO1xuICAgIHZhciBieXRlcyA9IFtvXTtcbiAgICB4ID0geCA+PiA4O1xuICAgIG8gPSB4ICYgMjU1O1xuICAgIHdoaWxlIChvID4gMCkge1xuICAgICAgYnl0ZXMudW5zaGlmdChvKTtcbiAgICAgIHggPSB4ID4+IDg7XG4gICAgICBvID0geCAmIDI1NTtcbiAgICAgICsrbjtcbiAgICB9XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICBieXRlcy5wdXNoKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG4pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzLmxlbmd0aDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIHN0cjtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHN0ciA9IG5ldyBVaW50OEFycmF5KHN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc3RyKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgIGJ5dGVzID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlcyArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpKTtcbiAgICAgICAgICBieXRlcyArPSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7XG4gICAgdGhpcy51cGRhdGUoc3RyKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5ieXRlcGFkID0gZnVuY3Rpb24gKHN0cnMsIHcpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmVuY29kZSh3KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlU3RyaW5nKHN0cnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZ0J5dGVzID0gdyAtIGJ5dGVzICUgdztcbiAgICB2YXIgemVyb3MgPSBbXTtcbiAgICB6ZXJvcy5sZW5ndGggPSBwYWRkaW5nQnl0ZXM7XG4gICAgdGhpcy51cGRhdGUoemVyb3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gdGhpcy5wYWRkaW5nW2kgJiAzXTtcbiAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuICAgIH1cbiAgICBmKHMpO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGhleCA9ICcnLCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAyNCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgICBpID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXTtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5vdXRwdXRCaXRzID4+IDM7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKChvdXRwdXRCbG9ja3MgKyAxKSA8PCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICAgIGFycmF5W2pdID0gc1tpXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5kaWdlc3QgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSAoYmxvY2sgPj4gMjQpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xuICAgIEtlY2Nhay5jYWxsKHRoaXMsIGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuICB9XG5cbiAgS21hYy5wcm90b3R5cGUgPSBuZXcgS2VjY2FrKCk7XG5cbiAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCB0cnVlKTtcbiAgICByZXR1cm4gS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHZhciBmID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXG4gICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXG4gICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXG4gICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XG4gICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcbiAgICAgIGMwID0gc1swXSBeIHNbMTBdIF4gc1syMF0gXiBzWzMwXSBeIHNbNDBdO1xuICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XG4gICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcbiAgICAgIGMzID0gc1szXSBeIHNbMTNdIF4gc1syM10gXiBzWzMzXSBeIHNbNDNdO1xuICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XG4gICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcbiAgICAgIGM2ID0gc1s2XSBeIHNbMTZdIF4gc1syNl0gXiBzWzM2XSBeIHNbNDZdO1xuICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XG4gICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcbiAgICAgIGM5ID0gc1s5XSBeIHNbMTldIF4gc1syOV0gXiBzWzM5XSBeIHNbNDldO1xuXG4gICAgICBoID0gYzggXiAoKGMyIDw8IDEpIHwgKGMzID4+PiAzMSkpO1xuICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcbiAgICAgIHNbMF0gXj0gaDtcbiAgICAgIHNbMV0gXj0gbDtcbiAgICAgIHNbMTBdIF49IGg7XG4gICAgICBzWzExXSBePSBsO1xuICAgICAgc1syMF0gXj0gaDtcbiAgICAgIHNbMjFdIF49IGw7XG4gICAgICBzWzMwXSBePSBoO1xuICAgICAgc1szMV0gXj0gbDtcbiAgICAgIHNbNDBdIF49IGg7XG4gICAgICBzWzQxXSBePSBsO1xuICAgICAgaCA9IGMwIF4gKChjNCA8PCAxKSB8IChjNSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XG4gICAgICBzWzJdIF49IGg7XG4gICAgICBzWzNdIF49IGw7XG4gICAgICBzWzEyXSBePSBoO1xuICAgICAgc1sxM10gXj0gbDtcbiAgICAgIHNbMjJdIF49IGg7XG4gICAgICBzWzIzXSBePSBsO1xuICAgICAgc1szMl0gXj0gaDtcbiAgICAgIHNbMzNdIF49IGw7XG4gICAgICBzWzQyXSBePSBoO1xuICAgICAgc1s0M10gXj0gbDtcbiAgICAgIGggPSBjMiBeICgoYzYgPDwgMSkgfCAoYzcgPj4+IDMxKSk7XG4gICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xuICAgICAgc1s0XSBePSBoO1xuICAgICAgc1s1XSBePSBsO1xuICAgICAgc1sxNF0gXj0gaDtcbiAgICAgIHNbMTVdIF49IGw7XG4gICAgICBzWzI0XSBePSBoO1xuICAgICAgc1syNV0gXj0gbDtcbiAgICAgIHNbMzRdIF49IGg7XG4gICAgICBzWzM1XSBePSBsO1xuICAgICAgc1s0NF0gXj0gaDtcbiAgICAgIHNbNDVdIF49IGw7XG4gICAgICBoID0gYzQgXiAoKGM4IDw8IDEpIHwgKGM5ID4+PiAzMSkpO1xuICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcbiAgICAgIHNbNl0gXj0gaDtcbiAgICAgIHNbN10gXj0gbDtcbiAgICAgIHNbMTZdIF49IGg7XG4gICAgICBzWzE3XSBePSBsO1xuICAgICAgc1syNl0gXj0gaDtcbiAgICAgIHNbMjddIF49IGw7XG4gICAgICBzWzM2XSBePSBoO1xuICAgICAgc1szN10gXj0gbDtcbiAgICAgIHNbNDZdIF49IGg7XG4gICAgICBzWzQ3XSBePSBsO1xuICAgICAgaCA9IGM2IF4gKChjMCA8PCAxKSB8IChjMSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XG4gICAgICBzWzhdIF49IGg7XG4gICAgICBzWzldIF49IGw7XG4gICAgICBzWzE4XSBePSBoO1xuICAgICAgc1sxOV0gXj0gbDtcbiAgICAgIHNbMjhdIF49IGg7XG4gICAgICBzWzI5XSBePSBsO1xuICAgICAgc1szOF0gXj0gaDtcbiAgICAgIHNbMzldIF49IGw7XG4gICAgICBzWzQ4XSBePSBoO1xuICAgICAgc1s0OV0gXj0gbDtcblxuICAgICAgYjAgPSBzWzBdO1xuICAgICAgYjEgPSBzWzFdO1xuICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XG4gICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcbiAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xuICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XG4gICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcbiAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xuICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xuICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xuICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xuICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xuICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XG4gICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcbiAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcbiAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcbiAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcbiAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcbiAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xuICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XG4gICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XG4gICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XG4gICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcbiAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xuICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XG4gICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcbiAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcbiAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcbiAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xuICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XG4gICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XG4gICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XG4gICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcbiAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xuICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XG4gICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcbiAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xuICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XG4gICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcbiAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xuICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xuICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xuICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xuICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xuICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XG4gICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcbiAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xuICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XG4gICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcbiAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xuXG4gICAgICBzWzBdID0gYjAgXiAofmIyICYgYjQpO1xuICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcbiAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xuICAgICAgc1sxMV0gPSBiMTEgXiAofmIxMyAmIGIxNSk7XG4gICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcbiAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xuICAgICAgc1szMF0gPSBiMzAgXiAofmIzMiAmIGIzNCk7XG4gICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcbiAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xuICAgICAgc1s0MV0gPSBiNDEgXiAofmI0MyAmIGI0NSk7XG4gICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xuICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcbiAgICAgIHNbMTJdID0gYjEyIF4gKH5iMTQgJiBiMTYpO1xuICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XG4gICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcbiAgICAgIHNbMjNdID0gYjIzIF4gKH5iMjUgJiBiMjcpO1xuICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XG4gICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcbiAgICAgIHNbNDJdID0gYjQyIF4gKH5iNDQgJiBiNDYpO1xuICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XG4gICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xuICAgICAgc1s1XSA9IGI1IF4gKH5iNyAmIGI5KTtcbiAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xuICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XG4gICAgICBzWzI0XSA9IGIyNCBeICh+YjI2ICYgYjI4KTtcbiAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xuICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XG4gICAgICBzWzM1XSA9IGIzNSBeICh+YjM3ICYgYjM5KTtcbiAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xuICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XG4gICAgICBzWzZdID0gYjYgXiAofmI4ICYgYjApO1xuICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcbiAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xuICAgICAgc1sxN10gPSBiMTcgXiAofmIxOSAmIGIxMSk7XG4gICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcbiAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xuICAgICAgc1szNl0gPSBiMzYgXiAofmIzOCAmIGIzMCk7XG4gICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcbiAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xuICAgICAgc1s0N10gPSBiNDcgXiAofmI0OSAmIGI0MSk7XG4gICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xuICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcbiAgICAgIHNbMThdID0gYjE4IF4gKH5iMTAgJiBiMTIpO1xuICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XG4gICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcbiAgICAgIHNbMjldID0gYjI5IF4gKH5iMjEgJiBiMjMpO1xuICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XG4gICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcbiAgICAgIHNbNDhdID0gYjQ4IF4gKH5iNDAgJiBiNDIpO1xuICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XG5cbiAgICAgIHNbMF0gXj0gUkNbbl07XG4gICAgICBzWzFdIF49IFJDW24gKyAxXTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJvb3RbbWV0aG9kTmFtZXNbaV1dID0gbWV0aG9kc1ttZXRob2ROYW1lc1tpXV07XG4gICAgfVxuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/js-sha3/src/sha3.js\n");

/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanM/ZGEzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/minimalistic-assert/index.js\n");

/***/ }),

/***/ "./src/main.ts":
        /*!***********************************!*\
          !*** ./src/main.ts + 256 modules ***!
          \***********************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

            "use strict";
            eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"App\": () => (/* binding */ App),\n  \"default\": () => (/* binding */ App)\n});\n\n;// CONCATENATED MODULE: ./src/networks/Network.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass Network {\r\n    constructor() {\r\n        this.ServerUrl = \"\";\r\n        this.AppId = \"\";\r\n        this.ChainId = 0;\r\n        this.Name = \"\";\r\n        this.ChainName = '';\r\n        this.NativeCurrencyName = \"\";\r\n        this.NativeSymbol = \"\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = '';\r\n        this.BlockExplorer = '';\r\n        this.TestNetwork = true;\r\n        this.FaucetUrl = '';\r\n        this.BuyUrl = '';\r\n    }\r\n    get ChainIdHex() {\r\n        return '0x' + this.ChainId.toString(16);\r\n    }\r\n    addNetworkToWallet() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const web3 = yield AuthenticateService.enableWeb3();\r\n            if (!web3 || !web3.provider.request)\r\n                return;\r\n            web3.provider.request({\r\n                method: 'wallet_addEthereumChain',\r\n                params: [{\r\n                        chainId: '0x' + this.ChainId.toString(16),\r\n                        chainName: this.ChainName,\r\n                        nativeCurrency: {\r\n                            name: this.NativeCurrencyName,\r\n                            symbol: this.NativeSymbol,\r\n                            decimals: this.NativeDecimal\r\n                        },\r\n                        rpcUrls: [this.RpcUrl],\r\n                        blockExplorerUrls: [this.BlockExplorer]\r\n                    }]\r\n            }).catch((error) => {\r\n                console.log(error);\r\n            });\r\n        });\r\n    }\r\n    hasEnoughNativeTokens() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let blockchainService = new BlockchainService();\r\n            let balanceNative = yield blockchainService.getNativeBalance();\r\n            const balance = parseFloat(balanceNative);\r\n            if (balance < 0.005) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    ;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/TestNetwork.ts\n\r\nclass TestNetwork extends Network {\r\n    constructor() {\r\n        super();\r\n        this.ServerUrl = \"https://cloud-testnet.onrender.com\";\r\n        this.TestNetwork = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/localhost-network.ts\n\r\n//localhost\r\nclass localhostNetwork extends TestNetwork {\r\n    constructor() {\r\n        super();\r\n        this.ChainId = 31337;\r\n        this.Name = \"localhost\";\r\n        this.ChainName = 'localhost test';\r\n        this.NativeCurrencyName = \"Ethereum\";\r\n        this.NativeSymbol = \"ETH\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = 'http://127.0.0.1:8545/';\r\n        this.BlockExplorer = 'https://rinkeby.etherscan.io';\r\n        this.ServerUrl = \"http://localhost:10000\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/mumbai-network.ts\n\r\nclass mumbaiNetwork extends TestNetwork {\r\n    constructor() {\r\n        super();\r\n        this.ChainId = 80001;\r\n        this.Name = \"mumbai\";\r\n        this.ChainName = 'Polygon Mumbai';\r\n        this.NativeCurrencyName = \"Matic\";\r\n        this.NativeSymbol = \"MATIC\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = 'https://polygon-mumbai.g.alchemy.com/v2/FILTBk8FT9RzcRVxkMXIg7Ipl8JCNdK2';\r\n        this.BlockExplorer = 'https://mumbai.polygonscan.com/';\r\n        this.FaucetUrl = 'https://faucet.polygon.technology/';\r\n        this.BuyUrl = 'https://www.moonpay.com/buy/matic';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/util/CookieHelper.ts\nclass CookieHelper {\r\n    constructor(doc) {\r\n        this.document = (doc) ? doc : document;\r\n    }\r\n    setCookie(name, value) {\r\n        let date = new Date();\r\n        this.deleteCookie(name);\r\n        this.document.cookie = name + \"=\" + value + \"; expires=Mon, 2 Dec \" + (date.getFullYear() + 1) + \" 12:00:00 UTC;path=/;SameSite=Strict;\";\r\n    }\r\n    getCookieValue(name) {\r\n        var _a;\r\n        return ((_a = this.document.cookie.match('(^|;)\\\\s*' + name + '\\\\s*=\\\\s*([^;]+)')) === null || _a === void 0 ? void 0 : _a.pop()) || '';\r\n    }\r\n    setCookieProvider(providerName) {\r\n        this.setCookie(\"provider\", providerName);\r\n    }\r\n    deleteCookie(name) {\r\n        this.document.cookie = name + \"=0; expires=Mon, 2 Dec 2020 12:00:00 UTC;path=/\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/MainNetwork.ts\n\r\nclass MainNetwork extends Network {\r\n    constructor() {\r\n        super();\r\n        this.ServerUrl = \"https://cloud-mainnet.onrender.com\";\r\n        this.TestNetwork = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/polygon-network.ts\n\r\nclass polygonNetwork extends MainNetwork {\r\n    constructor() {\r\n        super();\r\n        this.ChainId = 137;\r\n        this.Name = \"polygon\";\r\n        this.ChainName = 'Polygon Mainnet';\r\n        this.NativeCurrencyName = \"Matic\";\r\n        this.NativeSymbol = \"MATIC\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = 'https://polygon-rpc.com/';\r\n        this.BlockExplorer = 'https://polygonscan.com/';\r\n        this.FaucetUrl = 'https://faucet.polygon.technology/';\r\n        this.BuyUrl = 'https://www.moonpay.com/buy/matic';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/NetworkType.ts\nvar NetworkType;\r\n(function (NetworkType) {\r\n    NetworkType[NetworkType[\"Mainnet\"] = 0] = \"Mainnet\";\r\n    NetworkType[NetworkType[\"Testnet\"] = 1] = \"Testnet\";\r\n})(NetworkType || (NetworkType = {}));\r\n\n;// CONCATENATED MODULE: ./src/networks/NetworkInfo.ts\n\r\n\r\n\r\n\r\n\r\nconst networkInfos = [localhostNetwork, mumbaiNetwork, polygonNetwork];\r\nclass NetworkInfo {\r\n    constructor() {\r\n    }\r\n    static getInstance() {\r\n        if (NetworkInfo.instance)\r\n            return NetworkInfo.instance;\r\n        NetworkInfo.instance = this.getNetworkInfo();\r\n        return NetworkInfo.instance;\r\n    }\r\n    static loadNetwork(networkName) {\r\n        NetworkInfo.instance = this.getNetworkInfo(networkName);\r\n    }\r\n    static setNetworkByChainId(chainId) {\r\n        let network = this.getNetworkInfoByChainId(chainId);\r\n        if (network) {\r\n            NetworkInfo.instance = network;\r\n            let cookieHelper = new CookieHelper(document);\r\n            cookieHelper.setCookie('network', network.Name);\r\n        }\r\n    }\r\n    static getNetworks(networkType) {\r\n        let networks = new Array();\r\n        let isLocalhost = window.location.host.indexOf('localhost') != -1;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (!isLocalhost && tmp.Name == \"localhost\")\r\n                return;\r\n            if (networkType === undefined) {\r\n                networks.push(tmp);\r\n            }\r\n            else {\r\n                if (networkType == NetworkType.Mainnet && !tmp.TestNetwork) {\r\n                    networks.push(tmp);\r\n                }\r\n                else if (networkType == NetworkType.Testnet && tmp.TestNetwork) {\r\n                    networks.push(tmp);\r\n                }\r\n            }\r\n        });\r\n        return networks;\r\n    }\r\n    static getNetworkInfoByChainId(chainId) {\r\n        let networkInfo;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (tmp.ChainId == chainId) {\r\n                networkInfo = tmp;\r\n            }\r\n        });\r\n        return networkInfo;\r\n    }\r\n    static getNetworkInfo(networkName) {\r\n        let cookieHelper = new CookieHelper(document);\r\n        if (!networkName)\r\n            networkName = cookieHelper.getCookieValue('network');\r\n        if (!networkName)\r\n            networkName = 'polygon';\r\n        let isLocal = (window.location.host.indexOf('localhost') != -1);\r\n        // @ts-ignore\r\n        if (isLocal && !networkName && window.ethereum && window.ethereum.chainId) {\r\n            // @ts-ignore\r\n            let chainId = (window.ethereum.chainId) ? window.ethereum.chainId : 31337;\r\n            let networkInfo = this.getNetworkNameByChainIdHex(chainId);\r\n            if (networkInfo) {\r\n                return networkInfo;\r\n            }\r\n        }\r\n        let networkInfo = null;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (tmp.Name == networkName) {\r\n                networkInfo = tmp;\r\n            }\r\n        });\r\n        if (networkInfo)\r\n            return networkInfo;\r\n        console.error(\"Network '\" + networkName + \"' could not be found. Defaulting to Polygon network.\");\r\n        return new polygonNetwork();\r\n    }\r\n    static getNetworkNameByChainIdHex(chainIdHex) {\r\n        let networkInfo = undefined;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (tmp.ChainIdHex == chainIdHex) {\r\n                networkInfo = tmp;\r\n            }\r\n        });\r\n        return networkInfo;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/SwitchNetwork.html\n// Module\nvar code = \"<div id=\\\"switchNetworkInfo\\\">\\r\\n    You can choose any of these networks.\\r\\n    <div>\\r\\n        <h3>Mainnet - real money & stocks</h3>\\r\\n        {{#each mainNetworks}}\\r\\n        <button href=\\\"\\\" class=\\\"setNetwork\\\"\\r\\n                data-chainid=\\\"{{ChainId}}\\\">{{ChainName}}\\r\\n        </button>\\r\\n        {{/each}}\\r\\n    </div>\\r\\n    <div>\\r\\n        <h3>Testnet - fake money & stocks</h3>\\r\\n        {{#each testNetworks}}\\r\\n        <button href=\\\"\\\" class=\\\"setNetwork\\\"\\r\\n                data-chainid=\\\"{{ChainId}}\\\">{{ChainName}}\\r\\n        </button>\\r\\n        {{/each}}\\r\\n    </div>\\r\\n</div>\\r\\n<div id=\\\"jsSwitchNetworkNotWorking\\\" class=\\\"d-none\\\">\\r\\n    It seem as we can't add the network automatically for your, so you need to add it your self.\\r\\n    This is the information you need to add the network. You will need to figure out where to\\r\\n    add new network for your wallet, as it difference between wallets.\\r\\n    <form>\\r\\n        <label>ChainId:\\r\\n            <input id=\\\"switchChainId\\\"/>\\r\\n        </label>\\r\\n        <label>Chain name\\r\\n            <input id=\\\"switchChainName\\\"/>\\r\\n        </label>\\r\\n        <label>Currency name\\r\\n            <input id=\\\"switchCurrencyName\\\"/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Symbol\\r\\n            <input id=\\\"switchSymbol\\\"/>\\r\\n        </label>\\r\\n        <label>Decimal\\r\\n            <input id=\\\"switchDecimal\\\"/>\\r\\n        </label>\\r\\n        <label>Rpc Url\\r\\n            <input id=\\\"switchRpcUrl\\\"/>\\r\\n        </label>\\r\\n    </form>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const SwitchNetwork = (code);\n;// CONCATENATED MODULE: ./src/html/modal/Modal.html\n// Module\nvar Modal_code = \"<dialog id=\\\"liminal_market_modal_div\\\" data-title=\\\"{{{title}}}\\\">\\r\\n    <article>\\r\\n        <header>\\r\\n            <span>{{title}}</span>\\r\\n            <a href=\\\"#close\\\" aria-label=\\\"Close\\\" class=\\\"close\\\" id=\\\"liminal_market_modal_close\\\"></a>\\r\\n        </header>\\r\\n        {{{content}}}\\r\\n    </article>\\r\\n\\r\\n</dialog>\";\n// Exports\n/* harmony default export */ const modal_Modal = (Modal_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Modal.ts\n\r\nclass Modal {\r\n    constructor() {\r\n        this.modalId = 'liminal_market_modal_div';\r\n    }\r\n    hideModal() {\r\n        let modalDiv = document.getElementById(this.modalId);\r\n        modalDiv === null || modalDiv === void 0 ? void 0 : modalDiv.removeAttribute('open');\r\n        if (this.onHide) {\r\n            this.onHide();\r\n        }\r\n    }\r\n    showModal(title, content, reuseModalIfSameTitle = false, onHide, hideOnOutsideClick = true) {\r\n        var _a;\r\n        let modalDiv = document.getElementById(this.modalId);\r\n        if (modalDiv) {\r\n            let modalTitle = modalDiv.dataset.title;\r\n            if (reuseModalIfSameTitle && modalTitle && modalTitle === title) {\r\n                modalDiv.setAttribute('open', '');\r\n                return false;\r\n            }\r\n        }\r\n        let template = Handlebars.compile(modal_Modal);\r\n        let obj = {\r\n            title: title, content: content\r\n        };\r\n        let html = template(obj);\r\n        if (modalDiv) {\r\n            document.body.removeChild(modalDiv);\r\n        }\r\n        document.body.insertAdjacentHTML('beforeend', html);\r\n        modalDiv = document.getElementById(this.modalId);\r\n        modalDiv.setAttribute('open', '');\r\n        if (hideOnOutsideClick) {\r\n            modalDiv.addEventListener('mousedown', (evt) => {\r\n                if (evt.target && evt.target.id === 'liminal_market_modal_div') {\r\n                    this.hideModal();\r\n                }\r\n            });\r\n        }\r\n        let liminal_market_modal_close = document.getElementById('liminal_market_modal_close');\r\n        if (liminal_market_modal_close)\r\n            liminal_market_modal_close.style.display = 'block';\r\n        (_a = document.getElementById('liminal_market_modal_close')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            this.hideModal();\r\n        });\r\n        this.onHide = onHide;\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/broker/Security.ts\nclass Security {\r\n    constructor() {\r\n        this.Class = \"\";\r\n        this.Exchange = \"\";\r\n        this.Symbol = \"\";\r\n        this.Name = \"\";\r\n        this.Status = \"\";\r\n        this.Tradable = false;\r\n        this.Fractionable = false;\r\n        this.Logo = \"\";\r\n        this.Favorite = 0;\r\n        this.LogoPath = \"/img/logos/\";\r\n        this.LogoPath = \"/img/logos/\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/BaseService.ts\nvar BaseService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass BaseService {\r\n    constructor() {\r\n    }\r\n    get(path, data, options) {\r\n        return BaseService_awaiter(this, void 0, void 0, function* () {\r\n            let url = '';\r\n            let method = 'GET';\r\n            if (!options || !options.relativeUrl) {\r\n                url = App.Network.ServerUrl;\r\n            }\r\n            let params = new URLSearchParams(data);\r\n            if (!params.has('chainId')) {\r\n                params.set('chainId', App.Network.ChainId.toString());\r\n            }\r\n            if (!params.has('address')) {\r\n                params.set('address', App.User.address);\r\n            }\r\n            let response = yield fetch(this.getUrl(url, path) + '?' + params.toString(), {\r\n                method: method,\r\n                headers: { 'Authentication': 'Bearer: ' + App.User.token, 'Content-Type': 'application/json' }\r\n            });\r\n            let obj = yield response.json();\r\n            return (obj.result) ? obj.result : undefined;\r\n        });\r\n    }\r\n    post(path, data) {\r\n        return BaseService_awaiter(this, void 0, void 0, function* () {\r\n            if (!data) {\r\n                data = {};\r\n            }\r\n            data.chainId = (data.chainId) ? data.chainId : App.Network.ChainId;\r\n            data.address = (data.address) ? data.address : App.User.address;\r\n            console.log(this.getUrl(App.Network.ServerUrl, path));\r\n            let response = yield fetch(this.getUrl(App.Network.ServerUrl, path), {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Authentication': 'Bearer: ' + App.User.token,\r\n                    'Content-Type': 'application/json;charset=UTF-8'\r\n                },\r\n                body: JSON.stringify(data),\r\n            });\r\n            let obj = yield response.json();\r\n            if (obj.success)\r\n                return obj.result;\r\n            throw new Error(obj.error);\r\n        });\r\n    }\r\n    getUrl(ServerUrl, path) {\r\n        if (path.startsWith('/'))\r\n            return ServerUrl + path;\r\n        return ServerUrl + '/' + path;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/broker/SecuritiesService.ts\nvar SecuritiesService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass SecuritiesService extends BaseService {\r\n    constructor() {\r\n        super();\r\n        this.securities = new Map();\r\n        this.symbols = [\"MSFT\", \"AAPL\", \"AMZN\", \"TSLA\", \"GOOGL\", \"GOOG\", \"GME\", \"META\", \"NVDA\", \"BRK.B\", \"JPM\", \"HD\", \"JNJ\", \"UNH\", \"PG\", \"BAC\", \"V\", \"ADBE\", \"NFLX\", \"CRM\", \"PFE\", \"DIS\", \"MA\", \"XOM\", \"TMO\", \"COST\"];\r\n        this.securities = new Map();\r\n        this.page = 1;\r\n    }\r\n    static getInstance() {\r\n        return SecuritiesService_awaiter(this, void 0, void 0, function* () {\r\n            if (!SecuritiesService.instance) {\r\n                SecuritiesService.instance = new SecuritiesService();\r\n                SecuritiesService.instance.securities = yield SecuritiesService.instance.getSecurities();\r\n            }\r\n            return SecuritiesService.instance;\r\n        });\r\n    }\r\n    getSecurities() {\r\n        return SecuritiesService_awaiter(this, void 0, void 0, function* () {\r\n            if (this.securities.size != 0)\r\n                return this.securities;\r\n            const results = yield (yield fetch('/securities/securities.json')).json();\r\n            for (let i = 0; i < results.length; i++) {\r\n                this.securities.set(results[i].Symbol, Object.assign(new Security, results[i]));\r\n            }\r\n            this.securitiesArray = Array.from(this.securities);\r\n            return this.securities;\r\n        });\r\n    }\r\n    getSecurityBySymbol(symbol) {\r\n        return SecuritiesService_awaiter(this, void 0, void 0, function* () {\r\n            let securities = yield this.getSecurities();\r\n            let security = securities.get(symbol);\r\n            return (security) ? security : new Security();\r\n        });\r\n    }\r\n    getTopSecurities() {\r\n        return SecuritiesService_awaiter(this, void 0, void 0, function* () {\r\n            let securities = yield this.getSecurities();\r\n            let topSecurities = new Array();\r\n            for (const symbol of this.symbols) {\r\n                let security = securities.get(symbol);\r\n                if (security) {\r\n                    topSecurities.push(security);\r\n                }\r\n            }\r\n            return topSecurities;\r\n        });\r\n    }\r\n    getPaginatingSecurities(page) {\r\n        return SecuritiesService_awaiter(this, void 0, void 0, function* () {\r\n            if (page == 0)\r\n                return this.getTopSecurities();\r\n            let securitiesOnPage = new Array();\r\n            let i = page * this.symbols.length;\r\n            let pageCount = i + 10;\r\n            for (; i < pageCount && i < this.securitiesArray.length; i++) {\r\n                securitiesOnPage.push(this.securitiesArray[i][1]);\r\n            }\r\n            return securitiesOnPage;\r\n        });\r\n    }\r\n    find(search) {\r\n        return SecuritiesService_awaiter(this, void 0, void 0, function* () {\r\n            let results = new Array();\r\n            search = search.toLocaleLowerCase();\r\n            this.securities.forEach(function (security) {\r\n                if (security.Symbol.toLowerCase().indexOf(search) != -1 ||\r\n                    security.Name.toLowerCase().indexOf(search) != -1) {\r\n                    results.push(security);\r\n                }\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/util/LoadingHelper.ts\nclass LoadingHelper {\r\n    static setLoading(element) {\r\n        if (LoadingHelper.lastElement) {\r\n            LoadingHelper.lastElement.removeAttribute('aria-busy');\r\n        }\r\n        if (!element)\r\n            return;\r\n        element.setAttribute('aria-busy', 'true');\r\n        LoadingHelper.lastElement = element;\r\n    }\r\n    static removeLoading() {\r\n        if (this.lastElement) {\r\n            this.lastElement.removeAttribute('aria-busy');\r\n        }\r\n    }\r\n}\r\nLoadingHelper.lastElement = undefined;\r\n\n;// CONCATENATED MODULE: ./src/util/WalletHelper.ts\nvar WalletHelper_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass WalletHelper {\r\n    constructor() {\r\n    }\r\n    getAUsdAsset() {\r\n        return {\r\n            Logo: '../ausd.png'\r\n        };\r\n    }\r\n    addTokenToWallet(address, symbol, fallbackTimeout) {\r\n        return WalletHelper_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            const asset = (symbol == 'aUSD') ? this.getAUsdAsset() : yield securitiesService.getSecurityBySymbol(symbol);\r\n            let connector = yield AuthenticateService.enableWeb3();\r\n            if (!connector || !connector.provider || !connector.provider.request) {\r\n                fallbackTimeout();\r\n                return;\r\n            }\r\n            let timeout = (WalletHelper.addTokenFallbackLoaded === undefined) ? 2 * 1000 : 200;\r\n            setTimeout(() => {\r\n                if (WalletHelper.addTokenFallbackLoaded !== false) {\r\n                    WalletHelper.addTokenFallbackLoaded = true;\r\n                    if (fallbackTimeout)\r\n                        fallbackTimeout();\r\n                }\r\n            }, timeout);\r\n            const wasAdded = yield connector.provider.request({\r\n                method: 'wallet_watchAsset',\r\n                params: [{\r\n                        type: 'ERC20',\r\n                        options: {\r\n                            address: address,\r\n                            symbol: symbol,\r\n                            decimals: 18,\r\n                            image: 'https://app.liminal.market/img/logos/' + asset.Logo,\r\n                        },\r\n                    }]\r\n            }).then((result) => {\r\n                WalletHelper.addTokenFallbackLoaded = false;\r\n                return true;\r\n            }).catch((error) => {\r\n                console.log(error);\r\n                return false;\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n            return wasAdded;\r\n        });\r\n    }\r\n    ;\r\n    static isWebview() {\r\n        let ua = navigator.userAgent;\r\n        // if it says it's a webview, let's go with that\r\n        let rules = ['WebView',\r\n            // iOS webview will be the same as safari but missing \"Safari\"\r\n            '(iPhone|iPod|iPad)(?!.*Safari)',\r\n            // Android Lollipop and Above: webview will be the same as native but it will contain \"wv\"\r\n            // Android KitKat to lollipop webview will put {version}.0.0.0\r\n            'Android.*(wv|.0.0.0)',\r\n            // old chrome android webview agent\r\n            'Linux; U; Android',\r\n            'SDK'\r\n        ];\r\n        let webviewRegExp = new RegExp('(' + rules.join('|') + ')', 'ig');\r\n        return !!ua.match(webviewRegExp);\r\n    }\r\n    isMagic() {\r\n        return WalletHelper_awaiter(this, void 0, void 0, function* () {\r\n            const walletInfo = App.User.providerInfo;\r\n            const walletType = walletInfo.walletType;\r\n            return (walletType === \"magic\");\r\n        });\r\n    }\r\n    switchNetwork(network) {\r\n        return WalletHelper_awaiter(this, void 0, void 0, function* () {\r\n            NetworkInfo.setNetworkByChainId(network.ChainId);\r\n            return true;\r\n        });\r\n    }\r\n    static hideMagicWallet() {\r\n        let magicIframe = document.querySelector('.magic-iframe');\r\n        if (magicIframe && magicIframe.style.display == 'block')\r\n            magicIframe.style.display = 'none';\r\n    }\r\n}\r\nWalletHelper.addTokenFallbackLoaded = undefined;\r\n\n;// CONCATENATED MODULE: ./src/errors/GeneralError.ts\nclass GeneralError extends Error {\r\n    constructor(e) {\r\n        super();\r\n        this.code = 0;\r\n        this.stack = \"\";\r\n        if (!e.message) {\r\n            this.message = e.toString();\r\n        }\r\n        else if (e.message.data) {\r\n            this.code = e.message.data.code;\r\n            this.message = e.message.data.message;\r\n            this.error = e;\r\n            this.headers = e.message.headers;\r\n            this.stack = e.stack;\r\n        }\r\n        else if (typeof (e.data) == 'object') {\r\n            this.code = e.data.code;\r\n            this.message = e.data.message;\r\n            this.stack = e.stack;\r\n        }\r\n        else if (e.message) {\r\n            this.message = e.message;\r\n        }\r\n        else {\r\n            this.message = e.toString();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/SwitchNetworkModal.ts\nvar SwitchNetworkModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SwitchNetworkModal {\r\n    constructor() {\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(SwitchNetwork);\r\n        let testNetworks = NetworkInfo.getNetworks(NetworkType.Testnet);\r\n        let mainNetworks = NetworkInfo.getNetworks(NetworkType.Mainnet);\r\n        let content = template({ testNetworks, mainNetworks });\r\n        let modal = new Modal();\r\n        modal.showModal('Switch network', content, false);\r\n        let setNetworkLinks = document.querySelectorAll('.setNetwork');\r\n        setNetworkLinks.forEach(setNetworkLink => {\r\n            setNetworkLink.addEventListener('click', (evt) => SwitchNetworkModal_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                let dataset = evt.target.dataset;\r\n                this.selectedNetwork = NetworkInfo.getNetworkInfoByChainId(parseInt(dataset.chainid));\r\n                if (!this.selectedNetwork)\r\n                    throw new GeneralError('Could not find chainId:' + dataset.chainid);\r\n                let walletHelper = new WalletHelper();\r\n                let successAddingNetwork = yield walletHelper.switchNetwork(this.selectedNetwork)\r\n                    .catch((error) => {\r\n                    let jsSwitchNetworkNotWorking = document.getElementById('jsSwitchNetworkNotWorking');\r\n                    if (!jsSwitchNetworkNotWorking)\r\n                        throw error;\r\n                    jsSwitchNetworkNotWorking.classList.remove('d-none');\r\n                    let switchNetworkInfo = document.getElementById('switchNetworkInfo');\r\n                    switchNetworkInfo.classList.add('d-none');\r\n                    document.getElementById('switchChainId').value = dataset.chainid + ' or it might be: ' + '0x' + parseInt(dataset.chainid).toString(16);\r\n                    document.getElementById('switchChainName').value = this.selectedNetwork.Name;\r\n                    document.getElementById('switchCurrencyName').value = this.selectedNetwork.NativeCurrencyName;\r\n                    document.getElementById('switchSymbol').value = this.selectedNetwork.NativeSymbol;\r\n                    document.getElementById('switchDecimal').value = this.selectedNetwork.NativeDecimal.toString();\r\n                    document.getElementById('switchRpcUrl').value = this.selectedNetwork.RpcUrl;\r\n                });\r\n                if (successAddingNetwork) {\r\n                    modal.hideModal();\r\n                    let authenticationService = new AuthenticateService();\r\n                    yield authenticationService.logOut();\r\n                    location.reload();\r\n                }\r\n            }));\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/logger/lib.esm/_version.js\nconst version = \"logger/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/logger/lib.esm/index.js\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/properties/lib.esm/_version.js\nconst _version_version = \"properties/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/properties/lib.esm/index.js\n\nvar lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst logger = new Logger(_version_version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nfunction resolveProperties(object) {\n    return lib_esm_awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nfunction checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nfunction shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nclass Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/_version.js\nconst lib_esm_version_version = \"providers/5.7.2\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\nconst abstract_signer_lib_esm_version_version = \"abstract-signer/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-signer/lib.esm/index.js\n\nvar abstract_signer_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst lib_esm_logger = new Logger(abstract_signer_lib_esm_version_version);\nconst allowedTransactionKeys = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n;\n;\nclass Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        lib_esm_logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"call\");\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                lib_esm_logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = shallowCopy(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        }\n        else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    lib_esm_logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to) => abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.resolveName(to);\n                    if (address == null) {\n                        lib_esm_logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error) => { });\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                lib_esm_logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            }\n            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                lib_esm_logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            }\n            else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            }\n            else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        }\n                        else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    }\n                    else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            lib_esm_logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    }\n                    else {\n                        // getFeeData has failed us.\n                        lib_esm_logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                }\n                else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return lib_esm_logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            }\n            else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results) => {\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        lib_esm_logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield resolveProperties(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            lib_esm_logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: (operation || \"_checkProvider\")\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nclass VoidSigner extends Signer {\n    constructor(address, provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(() => {\n            lib_esm_logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n}\n//# sourceMappingURL=index.js.map\n// EXTERNAL MODULE: ./node_modules/bn.js/lib/bn.js\nvar bn = __webpack_require__(\"./node_modules/bn.js/lib/bn.js\");\nvar bn_default = /*#__PURE__*/__webpack_require__.n(bn);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bytes/lib.esm/_version.js\nconst bytes_lib_esm_version_version = \"bytes/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bytes/lib.esm/index.js\n\n\n\nconst bytes_lib_esm_logger = new Logger(bytes_lib_esm_version_version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        bytes_lib_esm_logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0\" + hex;\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                bytes_lib_esm_logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return bytes_lib_esm_logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        bytes_lib_esm_logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        bytes_lib_esm_logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                bytes_lib_esm_logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return bytes_lib_esm_logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        bytes_lib_esm_logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        bytes_lib_esm_logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        bytes_lib_esm_logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        bytes_lib_esm_logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            bytes_lib_esm_logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                bytes_lib_esm_logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    bytes_lib_esm_logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bignumber/lib.esm/_version.js\nconst bignumber_lib_esm_version_version = \"bignumber/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nvar BN = (bn_default()).BN;\n\n\n\nconst bignumber_logger = new Logger(bignumber_lib_esm_version_version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof (value) === \"bigint\") ||\n        isBytes(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nclass BigNumber {\n    constructor(constructorGuard, hex) {\n        if (constructorGuard !== _constructorGuard) {\n            bignumber_logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return bignumber_logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    bignumber_logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                bignumber_logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                bignumber_logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return bignumber_logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return bignumber_logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            bignumber_logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return bignumber_logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\n// value should have no prefix\nfunction _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\n//# sourceMappingURL=bignumber.js.map\n// EXTERNAL MODULE: ./node_modules/js-sha3/src/sha3.js\nvar sha3 = __webpack_require__(\"./node_modules/js-sha3/src/sha3.js\");\nvar sha3_default = /*#__PURE__*/__webpack_require__.n(sha3);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/keccak256/lib.esm/index.js\n\n\n\nfunction keccak256(data) {\n    return '0x' + sha3_default().keccak_256(arrayify(data));\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/rlp/lib.esm/_version.js\nconst rlp_lib_esm_version_version = \"rlp/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/rlp/lib.esm/index.js\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nconst rlp_lib_esm_logger = new Logger(rlp_lib_esm_version_version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!isBytesLike(object)) {\n        rlp_lib_esm_logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call(arrayify(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            rlp_lib_esm_logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        rlp_lib_esm_logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            rlp_lib_esm_logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            rlp_lib_esm_logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\nfunction decode(data) {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        rlp_lib_esm_logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/address/lib.esm/_version.js\nconst address_lib_esm_version_version = \"address/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/address/lib.esm/index.js\n\n\n\n\n\n\n\nconst address_lib_esm_logger = new Logger(address_lib_esm_version_version);\nfunction getChecksumAddress(address) {\n    if (!isHexString(address, 20)) {\n        address_lib_esm_logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = arrayify(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    let result = null;\n    if (typeof (address) !== \"string\") {\n        address_lib_esm_logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            address_lib_esm_logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            address_lib_esm_logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        address_lib_esm_logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nfunction getIcapAddress(address) {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        address_lib_esm_logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));\n}\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if (hexDataLength(salt) !== 32) {\n        address_lib_esm_logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        address_lib_esm_logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/_version.js\nconst hash_lib_esm_version_version = \"hash/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/strings/lib.esm/_version.js\nconst strings_lib_esm_version_version = \"strings/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/strings/lib.esm/utf8.js\n\n\n\n\nconst utf8_logger = new Logger(strings_lib_esm_version_version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return utf8_logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = arrayify(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        utf8_logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return arrayify(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/id.js\n\n\nfunction id(text) {\n    return keccak256(toUtf8Bytes(text));\n}\n//# sourceMappingURL=id.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/typed-data.js\nvar typed_data_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst typed_data_logger = new Logger(hash_lib_esm_version_version);\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            typed_data_logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return typed_data_logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return typed_data_logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return typed_data_logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                typed_data_logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    typed_data_logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                typed_data_logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    typed_data_logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nclass TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    typed_data_logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    typed_data_logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    typed_data_logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            typed_data_logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            typed_data_logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                typed_data_logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    typed_data_logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return typed_data_logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            typed_data_logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                typed_data_logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return typed_data_logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                typed_data_logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return typed_data_awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            typed_data_logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            typed_data_logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return typed_data_logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n//# sourceMappingURL=typed-data.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/constants/lib.esm/bignumbers.js\n\nconst bignumbers_NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));\nconst bignumbers_Zero = ( /*#__PURE__*/BigNumber.from(0));\nconst bignumbers_One = ( /*#__PURE__*/BigNumber.from(1));\nconst Two = ( /*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther = ( /*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst bignumbers_MaxUint256 = ( /*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nconst MinInt256 = ( /*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256 = ( /*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\n//# sourceMappingURL=bignumbers.js.map\n// EXTERNAL MODULE: ./node_modules/hash.js/lib/hash.js\nvar hash = __webpack_require__(\"./node_modules/hash.js/lib/hash.js\");\nvar hash_default = /*#__PURE__*/__webpack_require__.n(hash);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t\tpath: basedir,\n\t\texports: {},\n\t\trequire: function (path, base) {\n\t\t\treturn commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n\t\t}\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction getDefaultExportFromNamespaceIfPresent (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;\n}\n\nfunction getDefaultExportFromNamespaceIfNotNamed (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;\n}\n\nfunction getAugmentedNamespace(n) {\n\tif (n.__esModule) return n;\n\tvar a = Object.defineProperty({}, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar minimalisticAssert = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\nvar utils_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n});\n\nvar utils_1$1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\n\n\n\nutils.assert = minimalisticAssert;\nutils.toArray = utils_1.toArray;\nutils.zero2 = utils_1.zero2;\nutils.toHex = utils_1.toHex;\nutils.encode = utils_1.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new (bn_default())(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n});\n\n'use strict';\n\n\n\nvar getNAF = utils_1$1.getNAF;\nvar getJSF = utils_1$1.getJSF;\nvar assert$1 = utils_1$1.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new (bn_default())(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? bn_default().red(conf.prime) : bn_default().mont(this.p);\n\n  // Useful for many curves\n  this.zero = new (bn_default())(0).toRed(this.red);\n  this.one = new (bn_default())(1).toRed(this.red);\n  this.two = new (bn_default())(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new (bn_default())(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nvar base = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert$1(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert$1(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils_1$1.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert$1(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils_1$1.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\nvar inherits_browser = createCommonjsModule(function (module) {\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n});\n\n'use strict';\n\n\n\n\n\n\nvar assert$2 = utils_1$1.assert;\n\nfunction ShortCurve(conf) {\n  base.call(this, 'short', conf);\n\n  this.a = new (bn_default())(conf.a, 16).toRed(this.red);\n  this.b = new (bn_default())(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits_browser(ShortCurve, base);\nvar short_1 = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new (bn_default())(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new (bn_default())(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new (bn_default())(vec.a, 16),\n        b: new (bn_default())(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : bn_default().mont(num);\n  var tinv = new (bn_default())(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new (bn_default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new (bn_default())(1);\n  var y1 = new (bn_default())(0);\n  var x2 = new (bn_default())(0);\n  var y2 = new (bn_default())(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new (bn_default())(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new (bn_default())(x, 16);\n    this.y = new (bn_default())(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits_browser(Point, base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new (bn_default())(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new (bn_default())(0);\n  } else {\n    this.x = new (bn_default())(x, 16);\n    this.y = new (bn_default())(y, 16);\n    this.z = new (bn_default())(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits_browser(JPoint, base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new (bn_default())(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nvar curve_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curve = exports;\n\ncurve.base = base;\ncurve.short = short_1;\ncurve.mont = /*RicMoo:ethers:require(./mont)*/(null);\ncurve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);\n});\n\nvar curves_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curves = exports;\n\n\n\n\n\nvar assert = utils_1$1.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve_1.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve_1.edwards(options);\n  else\n    this.curve = new curve_1.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: (hash_default()).sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: (hash_default()).sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: (hash_default()).sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n});\n\n'use strict';\n\n\n\n\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nvar hmacDrbg = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new (hash_default()).hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils_1.toArray(entropy, entropyEnc);\n  add = utils_1.toArray(add, addEnc);\n\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils_1.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils_1.encode(res, enc);\n};\n\n'use strict';\n\n\n\nvar assert$3 = utils_1$1.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nvar key = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new (bn_default())(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert$3(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert$3(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert$3(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n'use strict';\n\n\n\n\nvar assert$4 = utils_1$1.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert$4(options.r && options.s, 'Signature without r or s');\n  this.r = new (bn_default())(options.r, 16);\n  this.s = new (bn_default())(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nvar signature = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils_1$1.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new (bn_default())(r);\n  this.s = new (bn_default())(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils_1$1.encode(res, enc);\n};\n\n'use strict';\n\n\n\n\n\nvar rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nvar assert$5 = utils_1$1.assert;\n\n\n\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),\n      'Unknown curve ' + options);\n\n    options = curves_1[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves_1.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nvar ec = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new key(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return key.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return key.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new (bn_default())(2));\n  for (;;) {\n    var priv = new (bn_default())(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new (bn_default())(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new (bn_default())(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new (bn_default())(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n  msg = this._truncateToN(new (bn_default())(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature$1 = new signature(signature$1, 'hex');\n\n  // Perform primitive values validation\n  var r = signature$1.r;\n  var s = signature$1.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n  assert$5((3 & j) === j, 'The recovery param is more than two bits');\n  signature$1 = new signature(signature$1, enc);\n\n  var n = this.n;\n  var e = new (bn_default())(msg);\n  var r = signature$1.r;\n  var s = signature$1.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature$1.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n  signature$1 = new signature(signature$1, enc);\n  if (signature$1.recoveryParam !== null)\n    return signature$1.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature$1, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\nvar elliptic_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = /*RicMoo:ethers*/{ version: \"6.5.4\" }.version;\nelliptic.utils = utils_1$1;\nelliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nelliptic.curve = curve_1;\nelliptic.curves = curves_1;\n\n// Protocols\nelliptic.ec = ec;\nelliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);\n});\n\nvar EC$1 = elliptic_1.ec;\n\n\n//# sourceMappingURL=elliptic.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/signing-key/lib.esm/_version.js\nconst signing_key_lib_esm_version_version = \"signing-key/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/signing-key/lib.esm/index.js\n\n\n\n\n\n\nconst signing_key_lib_esm_logger = new Logger(signing_key_lib_esm_version_version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC$1(\"secp256k1\");\n    }\n    return _curve;\n}\nclass SigningKey {\n    constructor(privateKey) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        if (hexDataLength(this.privateKey) !== 32) {\n            signing_key_lib_esm_logger.throwArgumentError(\"invalid private key\", \"privateKey\", \"[[ REDACTED ]]\");\n        }\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 = getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            signing_key_lib_esm_logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nfunction recoverPublicKey(digest, signature) {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nfunction computePublicKey(key, compressed) {\n    const bytes = arrayify(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return signing_key_lib_esm_logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/transactions/lib.esm/_version.js\nconst transactions_lib_esm_version_version = \"transactions/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/transactions/lib.esm/index.js\n\n\n\n\n\n\n\n\n\n\n\nconst transactions_lib_esm_logger = new Logger(transactions_lib_esm_version_version);\nvar TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return bignumbers_Zero;\n    }\n    return BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst lib_esm_allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nfunction computeAddress(key) {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nfunction recoverAddress(digest, signature) {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                transactions_lib_esm_logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    transactions_lib_esm_logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            transactions_lib_esm_logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x02\", encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x01\", encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    checkProperties(transaction, lib_esm_allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = arrayify(hexlify(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            transactions_lib_esm_logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                transactions_lib_esm_logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push(hexlify(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            transactions_lib_esm_logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            transactions_lib_esm_logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        transactions_lib_esm_logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n    return encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            transactions_lib_esm_logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return transactions_lib_esm_logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) { }\n}\nfunction _parseEip1559(payload) {\n    const transaction = decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        // @TODO: What makes snese to do? The v is too big\n        return tx;\n    }\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = keccak256(encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) { }\n        tx.hash = keccak256(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    const payload = arrayify(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return transactions_lib_esm_logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/base64/lib.esm/base64.js\n\n\nfunction base64_decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nfunction base64_encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/web/lib.esm/_version.js\nconst web_lib_esm_version_version = \"web/5.7.1\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/web/lib.esm/geturl.js\n\nvar geturl_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction getUrl(href, options) {\n    return geturl_awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n            body: (options.body || undefined),\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        if (options.fetchOptions != null) {\n            const opts = options.fetchOptions;\n            if (opts.mode) {\n                request.mode = (opts.mode);\n            }\n            if (opts.cache) {\n                request.cache = (opts.cache);\n            }\n            if (opts.credentials) {\n                request.credentials = (opts.credentials);\n            }\n            if (opts.redirect) {\n                request.redirect = (opts.redirect);\n            }\n            if (opts.referrer) {\n                request.referrer = opts.referrer;\n            }\n        }\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key) => {\n                headers[key.toLowerCase()] = value;\n            });\n        }\n        else {\n            ((response.headers).keys)().forEach((key) => {\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: arrayify(new Uint8Array(body)),\n        };\n    });\n}\n//# sourceMappingURL=geturl.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/web/lib.esm/index.js\n\nvar web_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst web_lib_esm_logger = new Logger(web_lib_esm_version_version);\n\nfunction staller(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return hexlify(value);\n    }\n    return value;\n}\nfunction unpercent(value) {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    web_lib_esm_logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    const throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    web_lib_esm_logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = ((typeof (connection) === \"object\") ? !!(connection.errorPassThrough) : false);\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            web_lib_esm_logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                web_lib_esm_logger.throwError(\"basic authentication requires a secure https url\", Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64_encode(toUtf8Bytes(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\") },\n                body: (dataMatch[2] ? base64_decode(dataMatch[3]) : unpercent(dataMatch[3]))\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            web_lib_esm_logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(web_lib_esm_logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return web_lib_esm_awaiter(this, void 0, void 0, function* () {\n            for (let attempt = 0; attempt < attemptLimit; attempt++) {\n                let response = null;\n                try {\n                    response = yield getUrl(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        }\n                        else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                }\n                                else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        web_lib_esm_logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                }\n                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    web_lib_esm_logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    }\n                    catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        web_lib_esm_logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return web_lib_esm_logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nfunction fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response) => {\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            }\n            catch (error) {\n                web_lib_esm_logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n        // Create a connection with the content-type set for JSON\n        const updated = (typeof (connection) === \"string\") ? ({ url: connection }) : shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = shallowCopy(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\nconst abstract_provider_lib_esm_version_version = \"abstract-provider/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\n\nvar abstract_provider_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst abstract_provider_lib_esm_logger = new Logger(abstract_provider_lib_esm_version_version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nclass ForkEvent extends Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nclass BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry) {\n        if (!isHexString(blockHash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\nclass TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!isHexString(hash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nclass TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!isHexString(beforeHash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nclass Provider {\n    constructor() {\n        abstract_provider_lib_esm_logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return abstract_provider_lib_esm_awaiter(this, void 0, void 0, function* () {\n            const { block, gasPrice } = yield resolveProperties({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error) => {\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/basex/lib.esm/index.js\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n\nclass BaseX {\n    constructor(alphabet) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n        defineReadOnly(this, \"_alphabetMap\", {});\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = arrayify(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return arrayify(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/constants/lib.esm/hashes.js\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function (arr, depth) {\n        forEach.call(arr, function (val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            }\n            else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nfunction decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [0, 1]; // first symbol has frequency 1\n    for (let i = 1; i < symbol_count; i++) {\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = (read_buffer << 8) | bytes[pos++];\n            read_width = 8;\n        }\n        return (read_buffer >> --read_width) & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for (let i = 0; i < N; i++)\n        register = (register << 1) | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while (true) {\n        let value = Math.floor((((register - low + 1) * total) - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while (end - start > 1) { // binary search\n            let mid = (start + end) >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n        }\n        if (start == 0)\n            break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while (((a ^ b) & HALF) == 0) {\n            register = (register << 1) & MASK | read_bit();\n            a = (a << 1) & MASK;\n            b = (b << 1) & MASK | 1;\n        }\n        while (a & ~b & QRTR) {\n            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n            a = (a << 1) ^ HALF;\n            b = ((b ^ HALF) << 1) | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map(x => {\n        switch (x - offset) {\n            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 1: return offset + bytes[pos_payload++];\n            default: return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nfunction read_payload(v) {\n    let pos = 0;\n    return () => v[pos++];\n}\nfunction read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nfunction signed(i) {\n    return (i & 1) ? (~i >> 1) : (i >> 1);\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for (let i = 0; i < n; i++)\n        v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = -1; i < n; i++)\n        v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = 0; i < n; i++)\n        v[i] = x += signed(next());\n    return v;\n}\nfunction read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nfunction read_mapped_map(next) {\n    let ret = [];\n    while (true) {\n        let w = next();\n        if (w == 0)\n            break;\n        ret.push(read_linear_table(w, next));\n    }\n    while (true) {\n        let w = next() - 1;\n        if (w < 0)\n            break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nfunction read_zero_terminated_array(next) {\n    let v = [];\n    while (true) {\n        let i = next();\n        if (i == 0)\n            break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i) => {\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j) => {\n            let j_dy = j * dy;\n            return [x + j * dx, ys.map(y => y + j_dy)];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map(v => [v[0], v.slice(1)]);\n}\nfunction read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b) => a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while (true) {\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0)\n                break;\n            branches.push({ set: new Set(keys), node: read() });\n        }\n        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = (temp / 3) | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return { branches, valid, fe0f, save, check };\n    }\n}\n//# sourceMappingURL=decoder.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\n\nfunction getData() {\n    return read_compressed_payload(base64_decode('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'));\n}\n//# sourceMappingURL=include.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js\n/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n\n\nconst r = getData();\n\n// @TODO: This should be lazily loaded\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return toUtf8CodePoints(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter(cp => cp != 0xFE0F);\n}\nfunction ens_normalize_post_check(name) {\n    for (let label of name.split('.')) {\n        let cps = explode_cp(label);\n        try {\n            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        }\n        catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nfunction ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while (input.length) {\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize('NFC');\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten)\n        eaten.length = 0; // clear input buffer (if needed)\n    while (pos) {\n        let cp = cps[--pos];\n        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node)\n            break;\n        if (node.save) { // remember\n            saved = cp;\n        }\n        else if (node.check) { // check exclusion\n            if (cp === saved)\n                break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F)\n                pos--; // consume optional FE0F\n        }\n        if (node.valid) { // this is a valid emoji (so far)\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2)\n                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten)\n                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n//# sourceMappingURL=lib.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/namehash.js\n\n\n\n\n\nconst namehash_logger = new Logger(hash_lib_esm_version_version);\n\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nfunction ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\nfunction isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nfunction namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        namehash_logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n    return hexlify(result);\n}\nfunction dnsEncode(name) {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/networks/lib.esm/_version.js\nconst networks_lib_esm_version_version = \"networks/5.7.1\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/networks/lib.esm/index.js\n\n\n\nconst networks_lib_esm_logger = new Logger(networks_lib_esm_version_version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\"];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\"ropsten\"];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nfunction getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            networks_lib_esm_logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        networks_lib_esm_logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/sha2/lib.esm/types.js\nvar SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n;\n//# sourceMappingURL=types.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/sha2/lib.esm/_version.js\nconst sha2_lib_esm_version_version = \"sha2/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/sha2/lib.esm/sha2.js\n\n\n//const _ripemd160 = _hash.ripemd160;\n\n\n\n\nconst sha2_logger = new Logger(sha2_lib_esm_version_version);\nfunction ripemd160(data) {\n    return \"0x\" + (hash_default().ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\nfunction sha256(data) {\n    return \"0x\" + (hash_default().sha256().update(arrayify(data)).digest(\"hex\"));\n}\nfunction sha512(data) {\n    return \"0x\" + (hash_default().sha512().update(arrayify(data)).digest(\"hex\"));\n}\nfunction computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithm[algorithm]) {\n        sha2_logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash_default().hmac((hash_default())[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map\n// EXTERNAL MODULE: ./node_modules/bech32/index.js\nvar bech32 = __webpack_require__(\"./node_modules/bech32/index.js\");\nvar bech32_default = /*#__PURE__*/__webpack_require__.n(bech32);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/constants/lib.esm/addresses.js\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/formatter.js\n\n\n\n\n\n\n\n\n\nconst formatter_logger = new Logger(lib_esm_version_version);\nclass Formatter {\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return formatter_logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return formatter_logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parse(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        formatter_logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    formatter_logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                formatter_logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nfunction isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nfunction isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/base-provider.js\n\nvar base_provider_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst base_provider_logger = new Logger(lib_esm_version_version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        base_provider_logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        base_provider_logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nclass base_provider_Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        base_provider_logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = arrayify(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return hexConcat(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = hexConcat([\"0x9061b923\", encodeBytes([dnsEncode(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((arrayify(result).length % 32) === 4) {\n                    base_provider_logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            base_provider_logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32_default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32_default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                base_provider_logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === (34 * 2)) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                    const hash = base64_encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                    return \"sia:/\\/\" + hash;\n                }\n            }\n            return base_provider_logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                base_provider_logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    base_provider_logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return base_provider_logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return base_provider_logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                base_provider_logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", base_provider_logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // This is the first filter for this event, so we want to\n                            // restrict events to events that happened no earlier than now\n                            if (event._lastBlockNumber === -2) {\n                                event._lastBlockNumber = blockNumber - 1;\n                            }\n                            // Filter from the last *known* event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild, since it is quite\n                            // likely there just haven't been any events to move the lastBlockNumber.\n                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            if (minFromBlock > filter.fromBlock) {\n                                filter.fromBlock = minFromBlock;\n                            }\n                            if (filter.fromBlock < 0) {\n                                filter.fromBlock = 0;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            return base_provider_logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = base_provider_logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => base_provider_awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => base_provider_awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(base_provider_logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(base_provider_logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            base_provider_logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => base_provider_awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                base_provider_logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                base_provider_logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n                try {\n                    const data = hexDataSlice(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = hexDataSlice(data, 0, 32);\n                    if (!BigNumber.from(sender).eq(txSender)) {\n                        base_provider_logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = hexDataSlice(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            base_provider_logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                        base_provider_logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = hexDataSlice(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        base_provider_logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                base_provider_logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                base_provider_logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    base_provider_logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => base_provider_awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => base_provider_awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => base_provider_awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    base_provider_logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                base_provider_logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + namehash(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                base_provider_logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + namehash(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + namehash(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return base_provider_logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new base_provider_Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n\nvar json_rpc_provider_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst json_rpc_provider_logger = new Logger(lib_esm_version_version);\n\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        json_rpc_provider_logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            json_rpc_provider_logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        json_rpc_provider_logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        json_rpc_provider_logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        json_rpc_provider_logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        json_rpc_provider_logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        json_rpc_provider_logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst json_rpc_provider_constructorGuard = {};\nclass JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        super();\n        if (constructorGuard !== json_rpc_provider_constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            json_rpc_provider_logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return json_rpc_provider_logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(json_rpc_provider_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                json_rpc_provider_logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    json_rpc_provider_logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    json_rpc_provider_logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    json_rpc_provider_logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return json_rpc_provider_logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    json_rpc_provider_logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    json_rpc_provider_logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    json_rpc_provider_logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: { domain: populated.domain, types, value: populated.value }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst json_rpc_provider_allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return json_rpc_provider_logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return json_rpc_provider_logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(json_rpc_provider_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                json_rpc_provider_logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(json_rpc_provider_allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/web3-provider.js\n\n\n\n\nconst web3_provider_logger = new Logger(lib_esm_version_version);\n\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nclass Web3Provider extends JsonRpcProvider {\n    constructor(provider, network) {\n        if (provider == null) {\n            web3_provider_logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                web3_provider_logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n//# sourceMappingURL=web3-provider.js.map\n// EXTERNAL MODULE: ./node_modules/events/events.js\nvar events = __webpack_require__(\"./node_modules/events/events.js\");\nvar events_default = /*#__PURE__*/__webpack_require__.n(events);\n;// CONCATENATED MODULE: ./src/wallet/events.ts\n// Events being emitted by an eip-1193 provider\r\n// See https://eips.ethereum.org/EIPS/eip-1193#events\r\nconst EthereumEvents = Object.freeze({\r\n    CONNECT: 'connect',\r\n    DISCONNECT: 'disconnect',\r\n    CHAIN_CHANGED: 'chainChanged',\r\n    ACCOUNTS_CHANGED: 'accountsChanged',\r\n});\r\n// Events emitted by the connectors,\r\n// The InternalWeb3Provider of Moralis will listen to these\r\nconst ConnectorEvents = Object.freeze({\r\n    CONNECT: 'connect',\r\n    DISCONNECT: 'disconnect',\r\n    CHAIN_CHANGED: 'chainChanged',\r\n    ACCOUNT_CHANGED: 'accountChanged',\r\n});\r\n\n;// CONCATENATED MODULE: ./src/wallet/AbstractWeb3Connector.ts\nvar AbstractWeb3Connector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * Abstract connector to connect EIP-1193 providers to Moralis\r\n *\r\n * It should implement at least:\r\n * - activate()\r\n * - Emit ConnectorEvent.CHAIN_CHANGED when the chain has changed (if possible)\r\n * - Emit ConnectorEvent.ACCOUNT_CHANGED when the account has changed (if possible)\r\n * - type: a name to identify\r\n * - network: the network type that is used (eg. 'evm')\r\n */\r\nclass AbstractWeb3Connector extends (events_default()) {\r\n    constructor() {\r\n        super();\r\n        this.type = 'abstract';\r\n        this.network = 'evm';\r\n        this.account = null;\r\n        this.chainId = null;\r\n        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);\r\n        this.handleChainChanged = this.handleChainChanged.bind(this);\r\n        this.handleConnect = this.handleConnect.bind(this);\r\n        this.handleDisconnect = this.handleDisconnect.bind(this);\r\n    }\r\n    subscribeToEvents(provider) {\r\n        if (provider && provider.on) {\r\n            provider.on(EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);\r\n            provider.on(EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);\r\n            provider.on(EthereumEvents.CONNECT, this.handleConnect);\r\n            provider.on(EthereumEvents.DISCONNECT, this.handleDisconnect);\r\n        }\r\n    }\r\n    unsubscribeToEvents(provider) {\r\n        if (provider && provider.removeListener) {\r\n            provider.removeListener(EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);\r\n            provider.removeListener(EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);\r\n            provider.removeListener(EthereumEvents.CONNECT, this.handleConnect);\r\n            provider.removeListener(EthereumEvents.DISCONNECT, this.handleDisconnect);\r\n        }\r\n    }\r\n    /**\r\n     * Activates the provider.\r\n     * Should returns an object with:\r\n     * - provider: A valid EIP-1193 provider\r\n     * - chainId(optional): the chainId that has been connected to (in hex format)\r\n     * - account(optional): the address that is connected to the provider\r\n     */\r\n    activate() {\r\n        return AbstractWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            throw new Error('Not implemented: activate()');\r\n        });\r\n    }\r\n    /**\r\n     * Updates account and emit event, on EIP-1193 accountsChanged events\r\n     */\r\n    handleAccountsChanged(accounts) {\r\n        const account = accounts && accounts[0] ? accounts[0].toLowerCase() : null;\r\n        this.account = account;\r\n        this.emit(ConnectorEvents.ACCOUNT_CHANGED, account);\r\n    }\r\n    /**\r\n     * Updates chainId and emit event, on EIP-1193 accountsChanged events\r\n     */\r\n    handleChainChanged(chainId) {\r\n        const newChainId = chainId;\r\n        this.chainId = newChainId;\r\n        this.emit(ConnectorEvents.CHAIN_CHANGED, newChainId);\r\n    }\r\n    handleConnect(connectInfo) {\r\n        this.emit(ConnectorEvents.CONNECT, connectInfo);\r\n    }\r\n    handleDisconnect(error) {\r\n        this.emit(ConnectorEvents.DISCONNECT, error);\r\n    }\r\n    /**\r\n     * Cleans all active listners, connections and stale references\r\n     */\r\n    deactivate() {\r\n        return AbstractWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            this.unsubscribeToEvents(this.provider);\r\n            this.account = null;\r\n            this.chainId = null;\r\n        });\r\n    }\r\n}\r\n/* harmony default export */ const wallet_AbstractWeb3Connector = (AbstractWeb3Connector);\r\n\n;// CONCATENATED MODULE: ./node_modules/@magic-sdk/types/dist/es/index.mjs\nvar a=(n=>(n.MissingApiKey=\"MISSING_API_KEY\",n.ModalNotReady=\"MODAL_NOT_READY\",n.MalformedResponse=\"MALFORMED_RESPONSE\",n.InvalidArgument=\"INVALID_ARGUMENT\",n.ExtensionNotInitialized=\"EXTENSION_NOT_INITIALIZED\",n.IncompatibleExtensions=\"INCOMPATIBLE_EXTENSIONS\",n))(a||{}),m=(_=>(_.SyncWeb3Method=\"SYNC_WEB3_METHOD\",_.DuplicateIframe=\"DUPLICATE_IFRAME\",_.ReactNativeEndpointConfiguration=\"REACT_NATIVE_ENDPOINT_CONFIGURATION\",_.DeprecationNotice=\"DEPRECATION_NOTICE\",_))(m||{}),p=(e=>(e[e.ParseError=-32700]=\"ParseError\",e[e.InvalidRequest=-32600]=\"InvalidRequest\",e[e.MethodNotFound=-32601]=\"MethodNotFound\",e[e.InvalidParams=-32602]=\"InvalidParams\",e[e.InternalError=-32603]=\"InternalError\",e[e.MagicLinkFailedVerification=-1e4]=\"MagicLinkFailedVerification\",e[e.MagicLinkExpired=-10001]=\"MagicLinkExpired\",e[e.MagicLinkRateLimited=-10002]=\"MagicLinkRateLimited\",e[e.MagicLinkInvalidRedirectURL=-10006]=\"MagicLinkInvalidRedirectURL\",e[e.UserAlreadyLoggedIn=-10003]=\"UserAlreadyLoggedIn\",e[e.UpdateEmailFailed=-10004]=\"UpdateEmailFailed\",e[e.UserRequestEditEmail=-10005]=\"UserRequestEditEmail\",e[e.InactiveRecipient=-10010]=\"InactiveRecipient\",e[e.AccessDeniedToUser=-10011]=\"AccessDeniedToUser\",e))(p||{});var u=(t=>(t.LoginWithSms=\"magic_auth_login_with_sms\",t.LoginWithEmailOTP=\"magic_auth_login_with_email_otp\",t.LoginWithMagicLink=\"magic_auth_login_with_magic_link\",t.LoginWithCredential=\"magic_auth_login_with_credential\",t.GetIdToken=\"magic_auth_get_id_token\",t.GenerateIdToken=\"magic_auth_generate_id_token\",t.GetMetadata=\"magic_auth_get_metadata\",t.IsLoggedIn=\"magic_auth_is_logged_in\",t.Logout=\"magic_auth_logout\",t.UpdateEmail=\"magic_auth_update_email\",t.UserSettings=\"magic_auth_settings\",t.UserSettingsTestMode=\"magic_auth_settings_testing_mode\",t.LoginWithSmsTestMode=\"magic_auth_login_with_sms_testing_mode\",t.LoginWithEmailOTPTestMode=\"magic_auth_login_with_email_otp_testing_mode\",t.LoginWithMagicLinkTestMode=\"magic_login_with_magic_link_testing_mode\",t.LoginWithCredentialTestMode=\"magic_auth_login_with_credential_testing_mode\",t.GetIdTokenTestMode=\"magic_auth_get_id_token_testing_mode\",t.GenerateIdTokenTestMode=\"magic_auth_generate_id_token_testing_mode\",t.GetMetadataTestMode=\"magic_auth_get_metadata_testing_mode\",t.IsLoggedInTestMode=\"magic_auth_is_logged_in_testing_mode\",t.LogoutTestMode=\"magic_auth_logout_testing_mode\",t.UpdateEmailTestMode=\"magic_auth_update_email_testing_mode\",t.IntermediaryEvent=\"magic_intermediary_event\",t))(u||{});var g=(i=>(i.MAGIC_HANDLE_RESPONSE=\"MAGIC_HANDLE_RESPONSE\",i.MAGIC_OVERLAY_READY=\"MAGIC_OVERLAY_READY\",i.MAGIC_SHOW_OVERLAY=\"MAGIC_SHOW_OVERLAY\",i.MAGIC_HIDE_OVERLAY=\"MAGIC_HIDE_OVERLAY\",i.MAGIC_HANDLE_EVENT=\"MAGIC_HANDLE_EVENT\",i))(g||{}),o=(s=>(s.MAGIC_HANDLE_REQUEST=\"MAGIC_HANDLE_REQUEST\",s))(o||{});var l=(s=>(s.Harmony=\"HARMONY\",s))(l||{});\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@magic-sdk/provider/dist/es/index.mjs\nvar yt=Object.create;var U=Object.defineProperty,Rt=Object.defineProperties,Tt=Object.getOwnPropertyDescriptor,vt=Object.getOwnPropertyDescriptors,xt=Object.getOwnPropertyNames,$e=Object.getOwnPropertySymbols,It=Object.getPrototypeOf,Me=Object.prototype.hasOwnProperty,Pt=Object.prototype.propertyIsEnumerable;var Ne=(t,e,n)=>e in t?U(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,z=(t,e)=>{for(var n in e||(e={}))Me.call(e,n)&&Ne(t,n,e[n]);if($e)for(var n of $e(e))Pt.call(e,n)&&Ne(t,n,e[n]);return t},we=(t,e)=>Rt(t,vt(e)),bt=t=>U(t,\"__esModule\",{value:!0});var $t=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Mt=(t,e)=>{for(var n in e)U(t,n,{get:e[n],enumerable:!0})},Nt=(t,e,n,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of xt(e))!Me.call(t,s)&&(n||s!==\"default\")&&U(t,s,{get:()=>e[s],enumerable:!(r=Tt(e,s))||r.enumerable});return t},wt=(t,e)=>Nt(bt(U(t!=null?yt(It(t)):{},\"default\",!e&&t&&t.__esModule?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var I=(t,e,n)=>new Promise((r,s)=>{var o=c=>{try{i(n.next(c))}catch(p){s(p)}},a=c=>{try{i(n.throw(c))}catch(p){s(p)}},i=c=>c.done?r(c.value):Promise.resolve(c.value).then(o,a);i((n=n.apply(t,e)).next())});var nt=$t((gr,fe)=>{\"use strict\";var bn=Object.prototype.hasOwnProperty,T=\"~\";function B(){}Object.create&&(B.prototype=Object.create(null),new B().__proto__||(T=!1));function $n(t,e,n){this.fn=t,this.context=e,this.once=n||!1}function tt(t,e,n,r,s){if(typeof n!=\"function\")throw new TypeError(\"The listener must be a function\");var o=new $n(n,r||t,s),a=T?T+e:e;return t._events[a]?t._events[a].fn?t._events[a]=[t._events[a],o]:t._events[a].push(o):(t._events[a]=o,t._eventsCount++),t}function oe(t,e){--t._eventsCount===0?t._events=new B:delete t._events[e]}function y(){this._events=new B,this._eventsCount=0}y.prototype.eventNames=function(){var e=[],n,r;if(this._eventsCount===0)return e;for(r in n=this._events)bn.call(n,r)&&e.push(T?r.slice(1):r);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(n)):e};y.prototype.listeners=function(e){var n=T?T+e:e,r=this._events[n];if(!r)return[];if(r.fn)return[r.fn];for(var s=0,o=r.length,a=new Array(o);s<o;s++)a[s]=r[s].fn;return a};y.prototype.listenerCount=function(e){var n=T?T+e:e,r=this._events[n];return r?r.fn?1:r.length:0};y.prototype.emit=function(e,n,r,s,o,a){var i=T?T+e:e;if(!this._events[i])return!1;var c=this._events[i],p=arguments.length,l,u;if(c.fn){switch(c.once&&this.removeListener(e,c.fn,void 0,!0),p){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,n),!0;case 3:return c.fn.call(c.context,n,r),!0;case 4:return c.fn.call(c.context,n,r,s),!0;case 5:return c.fn.call(c.context,n,r,s,o),!0;case 6:return c.fn.call(c.context,n,r,s,o,a),!0}for(u=1,l=new Array(p-1);u<p;u++)l[u-1]=arguments[u];c.fn.apply(c.context,l)}else{var v=c.length,M;for(u=0;u<v;u++)switch(c[u].once&&this.removeListener(e,c[u].fn,void 0,!0),p){case 1:c[u].fn.call(c[u].context);break;case 2:c[u].fn.call(c[u].context,n);break;case 3:c[u].fn.call(c[u].context,n,r);break;case 4:c[u].fn.call(c[u].context,n,r,s);break;default:if(!l)for(M=1,l=new Array(p-1);M<p;M++)l[M-1]=arguments[M];c[u].fn.apply(c[u].context,l)}}return!0};y.prototype.on=function(e,n,r){return tt(this,e,n,r,!1)};y.prototype.once=function(e,n,r){return tt(this,e,n,r,!0)};y.prototype.removeListener=function(e,n,r,s){var o=T?T+e:e;if(!this._events[o])return this;if(!n)return oe(this,o),this;var a=this._events[o];if(a.fn)a.fn===n&&(!s||a.once)&&(!r||a.context===r)&&oe(this,o);else{for(var i=0,c=[],p=a.length;i<p;i++)(a[i].fn!==n||s&&!a[i].once||r&&a[i].context!==r)&&c.push(a[i]);c.length?this._events[o]=c.length===1?c[0]:c:oe(this,o)}return this};y.prototype.removeAllListeners=function(e){var n;return e?(n=T?T+e:e,this._events[n]&&oe(this,n)):(this._events=new B,this._eventsCount=0),this};y.prototype.off=y.prototype.removeListener;y.prototype.addListener=y.prototype.on;y.prefixed=T;y.EventEmitter=y;typeof fe!=\"undefined\"&&(fe.exports=y)});function At(t){let e={exports:{}};return t(e,e.exports),e.exports}var Lt=Number.MAX_SAFE_INTEGER||9007199254740991;var me={SEMVER_SPEC_VERSION:\"2.0.0\",MAX_LENGTH:256,MAX_SAFE_INTEGER:Lt,MAX_SAFE_COMPONENT_LENGTH:16},St=typeof process==\"object\"&&process.env&&process.env.NODE_DEBUG&&/\\bsemver\\b/i.test(process.env.NODE_DEBUG)?(...t)=>console.error(\"SEMVER\",...t):()=>{},d=St,K=At(function(t,e){let{MAX_SAFE_COMPONENT_LENGTH:n}=me,r=(e=t.exports={}).re=[],s=e.src=[],o=e.t={},a=0,i=(c,p,l)=>{let u=a++;d(u,p),o[c]=u,s[u]=p,r[u]=new RegExp(p,l?\"g\":void 0)};i(\"NUMERICIDENTIFIER\",\"0|[1-9]\\\\d*\"),i(\"NUMERICIDENTIFIERLOOSE\",\"[0-9]+\"),i(\"NONNUMERICIDENTIFIER\",\"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\"),i(\"MAINVERSION\",`(${s[o.NUMERICIDENTIFIER]})\\\\.(${s[o.NUMERICIDENTIFIER]})\\\\.(${s[o.NUMERICIDENTIFIER]})`),i(\"MAINVERSIONLOOSE\",`(${s[o.NUMERICIDENTIFIERLOOSE]})\\\\.(${s[o.NUMERICIDENTIFIERLOOSE]})\\\\.(${s[o.NUMERICIDENTIFIERLOOSE]})`),i(\"PRERELEASEIDENTIFIER\",`(?:${s[o.NUMERICIDENTIFIER]}|${s[o.NONNUMERICIDENTIFIER]})`),i(\"PRERELEASEIDENTIFIERLOOSE\",`(?:${s[o.NUMERICIDENTIFIERLOOSE]}|${s[o.NONNUMERICIDENTIFIER]})`),i(\"PRERELEASE\",`(?:-(${s[o.PRERELEASEIDENTIFIER]}(?:\\\\.${s[o.PRERELEASEIDENTIFIER]})*))`),i(\"PRERELEASELOOSE\",`(?:-?(${s[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${s[o.PRERELEASEIDENTIFIERLOOSE]})*))`),i(\"BUILDIDENTIFIER\",\"[0-9A-Za-z-]+\"),i(\"BUILD\",`(?:\\\\+(${s[o.BUILDIDENTIFIER]}(?:\\\\.${s[o.BUILDIDENTIFIER]})*))`),i(\"FULLPLAIN\",`v?${s[o.MAINVERSION]}${s[o.PRERELEASE]}?${s[o.BUILD]}?`),i(\"FULL\",`^${s[o.FULLPLAIN]}$`),i(\"LOOSEPLAIN\",`[v=\\\\s]*${s[o.MAINVERSIONLOOSE]}${s[o.PRERELEASELOOSE]}?${s[o.BUILD]}?`),i(\"LOOSE\",`^${s[o.LOOSEPLAIN]}$`),i(\"GTLT\",\"((?:<|>)?=?)\"),i(\"XRANGEIDENTIFIERLOOSE\",`${s[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`),i(\"XRANGEIDENTIFIER\",`${s[o.NUMERICIDENTIFIER]}|x|X|\\\\*`),i(\"XRANGEPLAIN\",`[v=\\\\s]*(${s[o.XRANGEIDENTIFIER]})(?:\\\\.(${s[o.XRANGEIDENTIFIER]})(?:\\\\.(${s[o.XRANGEIDENTIFIER]})(?:${s[o.PRERELEASE]})?${s[o.BUILD]}?)?)?`),i(\"XRANGEPLAINLOOSE\",`[v=\\\\s]*(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:${s[o.PRERELEASELOOSE]})?${s[o.BUILD]}?)?)?`),i(\"XRANGE\",`^${s[o.GTLT]}\\\\s*${s[o.XRANGEPLAIN]}$`),i(\"XRANGELOOSE\",`^${s[o.GTLT]}\\\\s*${s[o.XRANGEPLAINLOOSE]}$`),i(\"COERCE\",`(^|[^\\\\d])(\\\\d{1,${n}})(?:\\\\.(\\\\d{1,${n}}))?(?:\\\\.(\\\\d{1,${n}}))?(?:$|[^\\\\d])`),i(\"COERCERTL\",s[o.COERCE],!0),i(\"LONETILDE\",\"(?:~>?)\"),i(\"TILDETRIM\",`(\\\\s*)${s[o.LONETILDE]}\\\\s+`,!0),e.tildeTrimReplace=\"$1~\",i(\"TILDE\",`^${s[o.LONETILDE]}${s[o.XRANGEPLAIN]}$`),i(\"TILDELOOSE\",`^${s[o.LONETILDE]}${s[o.XRANGEPLAINLOOSE]}$`),i(\"LONECARET\",\"(?:\\\\^)\"),i(\"CARETTRIM\",`(\\\\s*)${s[o.LONECARET]}\\\\s+`,!0),e.caretTrimReplace=\"$1^\",i(\"CARET\",`^${s[o.LONECARET]}${s[o.XRANGEPLAIN]}$`),i(\"CARETLOOSE\",`^${s[o.LONECARET]}${s[o.XRANGEPLAINLOOSE]}$`),i(\"COMPARATORLOOSE\",`^${s[o.GTLT]}\\\\s*(${s[o.LOOSEPLAIN]})$|^$`),i(\"COMPARATOR\",`^${s[o.GTLT]}\\\\s*(${s[o.FULLPLAIN]})$|^$`),i(\"COMPARATORTRIM\",`(\\\\s*)${s[o.GTLT]}\\\\s*(${s[o.LOOSEPLAIN]}|${s[o.XRANGEPLAIN]})`,!0),e.comparatorTrimReplace=\"$1$2$3\",i(\"HYPHENRANGE\",`^\\\\s*(${s[o.XRANGEPLAIN]})\\\\s+-\\\\s+(${s[o.XRANGEPLAIN]})\\\\s*$`),i(\"HYPHENRANGELOOSE\",`^\\\\s*(${s[o.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${s[o.XRANGEPLAINLOOSE]})\\\\s*$`),i(\"STAR\",\"(<|>)?=?\\\\s*\\\\*\"),i(\"GTE0\",\"^\\\\s*>=\\\\s*0.0.0\\\\s*$\"),i(\"GTE0PRE\",\"^\\\\s*>=\\\\s*0.0.0-0\\\\s*$\")}),Ae=/^[0-9]+$/,Le=(t,e)=>{let n=Ae.test(t),r=Ae.test(e);return n&&r&&(t=+t,e=+e),t===e?0:n&&!r?-1:r&&!n?1:t<e?-1:1},Ot=(t,e)=>Le(e,t),Ct={compareIdentifiers:Le,rcompareIdentifiers:Ot},{MAX_LENGTH:Se,MAX_SAFE_INTEGER:Y}=me,{re:Oe,t:Ce}=K,{compareIdentifiers:F}=Ct,h=class{constructor(e,n){if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),e instanceof h){if(e.loose===!!n.loose&&e.includePrerelease===!!n.includePrerelease)return e;e=e.version}else if(typeof e!=\"string\")throw new TypeError(`Invalid Version: ${e}`);if(e.length>Se)throw new TypeError(`version is longer than ${Se} characters`);d(\"SemVer\",e,n),this.options=n,this.loose=!!n.loose,this.includePrerelease=!!n.includePrerelease;let r=e.trim().match(n.loose?Oe[Ce.LOOSE]:Oe[Ce.FULL]);if(!r)throw new TypeError(`Invalid Version: ${e}`);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>Y||this.major<0)throw new TypeError(\"Invalid major version\");if(this.minor>Y||this.minor<0)throw new TypeError(\"Invalid minor version\");if(this.patch>Y||this.patch<0)throw new TypeError(\"Invalid patch version\");r[4]?this.prerelease=r[4].split(\".\").map(s=>{if(/^[0-9]+$/.test(s)){let o=+s;if(o>=0&&o<Y)return o}return s}):this.prerelease=[],this.build=r[5]?r[5].split(\".\"):[],this.format()}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(\".\")}`),this.version}toString(){return this.version}compare(e){if(d(\"SemVer.compare\",this.version,this.options,e),!(e instanceof h)){if(typeof e==\"string\"&&e===this.version)return 0;e=new h(e,this.options)}return e.version===this.version?0:this.compareMain(e)||this.comparePre(e)}compareMain(e){return e instanceof h||(e=new h(e,this.options)),F(this.major,e.major)||F(this.minor,e.minor)||F(this.patch,e.patch)}comparePre(e){if(e instanceof h||(e=new h(e,this.options)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;let n=0;do{let r=this.prerelease[n],s=e.prerelease[n];if(d(\"prerelease compare\",n,r,s),r===void 0&&s===void 0)return 0;if(s===void 0)return 1;if(r===void 0)return-1;if(r!==s)return F(r,s)}while(++n)}compareBuild(e){e instanceof h||(e=new h(e,this.options));let n=0;do{let r=this.build[n],s=e.build[n];if(d(\"prerelease compare\",n,r,s),r===void 0&&s===void 0)return 0;if(s===void 0)return 1;if(r===void 0)return-1;if(r!==s)return F(r,s)}while(++n)}inc(e,n){switch(e){case\"premajor\":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc(\"pre\",n);break;case\"preminor\":this.prerelease.length=0,this.patch=0,this.minor++,this.inc(\"pre\",n);break;case\"prepatch\":this.prerelease.length=0,this.inc(\"patch\",n),this.inc(\"pre\",n);break;case\"prerelease\":this.prerelease.length===0&&this.inc(\"patch\",n),this.inc(\"pre\",n);break;case\"major\":this.minor===0&&this.patch===0&&this.prerelease.length!==0||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case\"minor\":this.patch===0&&this.prerelease.length!==0||this.minor++,this.patch=0,this.prerelease=[];break;case\"patch\":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case\"pre\":if(this.prerelease.length===0)this.prerelease=[0];else{let r=this.prerelease.length;for(;--r>=0;)typeof this.prerelease[r]==\"number\"&&(this.prerelease[r]++,r=-2);r===-1&&this.prerelease.push(0)}n&&(this.prerelease[0]===n?isNaN(this.prerelease[1])&&(this.prerelease=[n,0]):this.prerelease=[n,0]);break;default:throw new Error(`invalid increment argument: ${e}`)}return this.format(),this.raw=this.version,this}},_t=(t,e,n)=>new h(t,n).compare(new h(e,n)),k=_t,Dt=(t,e,n)=>k(t,e,n)===0,kt=Dt,Jt=(t,e,n)=>k(t,e,n)!==0,qt=Jt,Gt=(t,e,n)=>k(t,e,n)>0,Ut=Gt,Kt=(t,e,n)=>k(t,e,n)>=0,Ft=Kt,jt=(t,e,n)=>k(t,e,n)<0,Wt=jt,Xt=(t,e,n)=>k(t,e,n)<=0,Bt=Xt,Ht=(t,e,n,r)=>{switch(e){case\"===\":return typeof t==\"object\"&&(t=t.version),typeof n==\"object\"&&(n=n.version),t===n;case\"!==\":return typeof t==\"object\"&&(t=t.version),typeof n==\"object\"&&(n=n.version),t!==n;case\"\":case\"=\":case\"==\":return kt(t,n,r);case\"!=\":return qt(t,n,r);case\">\":return Ut(t,n,r);case\">=\":return Ft(t,n,r);case\"<\":return Wt(t,n,r);case\"<=\":return Bt(t,n,r);default:throw new TypeError(`Invalid operator: ${e}`)}},Ee=Ht,j=Symbol(\"SemVer ANY\"),O=class{static get ANY(){return j}constructor(e,n){if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),e instanceof O){if(e.loose===!!n.loose)return e;e=e.value}d(\"comparator\",e,n),this.options=n,this.loose=!!n.loose,this.parse(e),this.semver===j?this.value=\"\":this.value=this.operator+this.semver.version,d(\"comp\",this)}parse(e){let n=this.options.loose?_e[De.COMPARATORLOOSE]:_e[De.COMPARATOR],r=e.match(n);if(!r)throw new TypeError(`Invalid comparator: ${e}`);this.operator=r[1]!==void 0?r[1]:\"\",this.operator===\"=\"&&(this.operator=\"\"),r[2]?this.semver=new h(r[2],this.options.loose):this.semver=j}toString(){return this.value}test(e){if(d(\"Comparator.test\",e,this.options.loose),this.semver===j||e===j)return!0;if(typeof e==\"string\")try{e=new h(e,this.options)}catch(n){return!1}return Ee(e,this.operator,this.semver,this.options)}intersects(e,n){if(!(e instanceof O))throw new TypeError(\"a Comparator is required\");if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),this.operator===\"\")return this.value===\"\"||new N(e.value,n).test(this.value);if(e.operator===\"\")return e.value===\"\"||new N(this.value,n).test(e.semver);let r=!(this.operator!==\">=\"&&this.operator!==\">\"||e.operator!==\">=\"&&e.operator!==\">\"),s=!(this.operator!==\"<=\"&&this.operator!==\"<\"||e.operator!==\"<=\"&&e.operator!==\"<\"),o=this.semver.version===e.semver.version,a=!(this.operator!==\">=\"&&this.operator!==\"<=\"||e.operator!==\">=\"&&e.operator!==\"<=\"),i=Ee(this.semver,\"<\",e.semver,n)&&(this.operator===\">=\"||this.operator===\">\")&&(e.operator===\"<=\"||e.operator===\"<\"),c=Ee(this.semver,\">\",e.semver,n)&&(this.operator===\"<=\"||this.operator===\"<\")&&(e.operator===\">=\"||e.operator===\">\");return r||s||o&&a||i||c}},{re:_e,t:De}=K,N=class{constructor(e,n){if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),e instanceof N)return e.loose===!!n.loose&&e.includePrerelease===!!n.includePrerelease?e:new N(e.raw,n);if(e instanceof O)return this.raw=e.value,this.set=[[e]],this.format(),this;if(this.options=n,this.loose=!!n.loose,this.includePrerelease=!!n.includePrerelease,this.raw=e,this.set=e.split(/\\s*\\|\\|\\s*/).map(r=>this.parseRange(r.trim())).filter(r=>r.length),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${e}`);this.format()}format(){return this.range=this.set.map(e=>e.join(\" \").trim()).join(\"||\").trim(),this.range}toString(){return this.range}parseRange(e){let{loose:n}=this.options;e=e.trim();let r=n?es_g[f.HYPHENRANGELOOSE]:es_g[f.HYPHENRANGE];e=e.replace(r,cn(this.options.includePrerelease)),d(\"hyphen replace\",e),e=e.replace(es_g[f.COMPARATORTRIM],Vt),d(\"comparator trim\",e,es_g[f.COMPARATORTRIM]),e=(e=(e=e.replace(es_g[f.TILDETRIM],zt)).replace(es_g[f.CARETTRIM],Yt)).split(/\\s+/).join(\" \");let s=n?es_g[f.COMPARATORLOOSE]:es_g[f.COMPARATOR];return e.split(\" \").map(o=>Zt(o,this.options)).join(\" \").split(/\\s+/).map(o=>an(o,this.options)).filter(this.options.loose?o=>!!o.match(s):()=>!0).map(o=>new O(o,this.options))}intersects(e,n){if(!(e instanceof N))throw new TypeError(\"a Range is required\");return this.set.some(r=>ke(r,n)&&e.set.some(s=>ke(s,n)&&r.every(o=>s.every(a=>o.intersects(a,n)))))}test(e){if(!e)return!1;if(typeof e==\"string\")try{e=new h(e,this.options)}catch(n){return!1}for(let n=0;n<this.set.length;n++)if(ln(this.set[n],e,this.options))return!0;return!1}},{re:es_g,t:f,comparatorTrimReplace:Vt,tildeTrimReplace:zt,caretTrimReplace:Yt}=K,ke=(t,e)=>{let n=!0,r=t.slice(),s=r.pop();for(;n&&r.length;)n=r.every(o=>s.intersects(o,e)),s=r.pop();return n},Zt=(t,e)=>(d(\"comp\",t,e),t=tn(t,e),d(\"caret\",t),t=Qt(t,e),d(\"tildes\",t),t=rn(t,e),d(\"xrange\",t),t=on(t,e),d(\"stars\",t),t),R=t=>!t||t.toLowerCase()===\"x\"||t===\"*\",Qt=(t,e)=>t.trim().split(/\\s+/).map(n=>en(n,e)).join(\" \"),en=(t,e)=>{let n=e.loose?es_g[f.TILDELOOSE]:es_g[f.TILDE];return t.replace(n,(r,s,o,a,i)=>{let c;return d(\"tilde\",t,r,s,o,a,i),R(s)?c=\"\":R(o)?c=`>=${s}.0.0 <${+s+1}.0.0-0`:R(a)?c=`>=${s}.${o}.0 <${s}.${+o+1}.0-0`:i?(d(\"replaceTilde pr\",i),c=`>=${s}.${o}.${a}-${i} <${s}.${+o+1}.0-0`):c=`>=${s}.${o}.${a} <${s}.${+o+1}.0-0`,d(\"tilde return\",c),c})},tn=(t,e)=>t.trim().split(/\\s+/).map(n=>nn(n,e)).join(\" \"),nn=(t,e)=>{d(\"caret\",t,e);let n=e.loose?es_g[f.CARETLOOSE]:es_g[f.CARET],r=e.includePrerelease?\"-0\":\"\";return t.replace(n,(s,o,a,i,c)=>{let p;return d(\"caret\",t,s,o,a,i,c),R(o)?p=\"\":R(a)?p=`>=${o}.0.0${r} <${+o+1}.0.0-0`:R(i)?p=o===\"0\"?`>=${o}.${a}.0${r} <${o}.${+a+1}.0-0`:`>=${o}.${a}.0${r} <${+o+1}.0.0-0`:c?(d(\"replaceCaret pr\",c),p=o===\"0\"?a===\"0\"?`>=${o}.${a}.${i}-${c} <${o}.${a}.${+i+1}-0`:`>=${o}.${a}.${i}-${c} <${o}.${+a+1}.0-0`:`>=${o}.${a}.${i}-${c} <${+o+1}.0.0-0`):(d(\"no pr\"),p=o===\"0\"?a===\"0\"?`>=${o}.${a}.${i}${r} <${o}.${a}.${+i+1}-0`:`>=${o}.${a}.${i}${r} <${o}.${+a+1}.0-0`:`>=${o}.${a}.${i} <${+o+1}.0.0-0`),d(\"caret return\",p),p})},rn=(t,e)=>(d(\"replaceXRanges\",t,e),t.split(/\\s+/).map(n=>sn(n,e)).join(\" \")),sn=(t,e)=>{t=t.trim();let n=e.loose?es_g[f.XRANGELOOSE]:es_g[f.XRANGE];return t.replace(n,(r,s,o,a,i,c)=>{d(\"xRange\",t,r,s,o,a,i,c);let p=R(o),l=p||R(a),u=l||R(i),v=u;return s===\"=\"&&v&&(s=\"\"),c=e.includePrerelease?\"-0\":\"\",p?r=s===\">\"||s===\"<\"?\"<0.0.0-0\":\"*\":s&&v?(l&&(a=0),i=0,s===\">\"?(s=\">=\",l?(o=+o+1,a=0,i=0):(a=+a+1,i=0)):s===\"<=\"&&(s=\"<\",l?o=+o+1:a=+a+1),s===\"<\"&&(c=\"-0\"),r=`${s+o}.${a}.${i}${c}`):l?r=`>=${o}.0.0${c} <${+o+1}.0.0-0`:u&&(r=`>=${o}.${a}.0${c} <${o}.${+a+1}.0-0`),d(\"xRange return\",r),r})},on=(t,e)=>(d(\"replaceStars\",t,e),t.trim().replace(es_g[f.STAR],\"\")),an=(t,e)=>(d(\"replaceGTE0\",t,e),t.trim().replace(es_g[e.includePrerelease?f.GTE0PRE:f.GTE0],\"\")),cn=t=>(e,n,r,s,o,a,i,c,p,l,u,v,M)=>`${n=R(r)?\"\":R(s)?`>=${r}.0.0${t?\"-0\":\"\"}`:R(o)?`>=${r}.${s}.0${t?\"-0\":\"\"}`:a?`>=${n}`:`>=${n}${t?\"-0\":\"\"}`} ${c=R(p)?\"\":R(l)?`<${+p+1}.0.0-0`:R(u)?`<${p}.${+l+1}.0-0`:v?`<=${p}.${l}.${u}-${v}`:t?`<${p}.${l}.${+u+1}-0`:`<=${c}`}`.trim(),ln=(t,e,n)=>{for(let r=0;r<t.length;r++)if(!t[r].test(e))return!1;if(e.prerelease.length&&!n.includePrerelease){for(let r=0;r<t.length;r++)if(d(t[r].semver),t[r].semver!==O.ANY&&t[r].semver.prerelease.length>0){let s=t[r].semver;if(s.major===e.major&&s.minor===e.minor&&s.patch===e.patch)return!0}return!1}return!0},Je=(t,e,n)=>{try{e=new N(e,n)}catch(r){return!1}return e.test(t)};var{MAX_LENGTH:pn}=me,{re:qe,t:Ge}=K,un=(t,e)=>{if(e&&typeof e==\"object\"||(e={loose:!!e,includePrerelease:!1}),t instanceof h)return t;if(typeof t!=\"string\"||t.length>pn||!(e.loose?qe[Ge.LOOSE]:qe[Ge.FULL]).test(t))return null;try{return new h(t,e)}catch(n){return null}},dn=un,{re:Z,t:Q}=K,Ue=(t,e)=>{if(t instanceof h)return t;if(typeof t==\"number\"&&(t=String(t)),typeof t!=\"string\")return null;let n=null;if((e=e||{}).rtl){let r;for(;(r=Z[Q.COERCERTL].exec(t))&&(!n||n.index+n[0].length!==t.length);)n&&r.index+r[0].length===n.index+n[0].length||(n=r),Z[Q.COERCERTL].lastIndex=r.index+r[1].length+r[2].length;Z[Q.COERCERTL].lastIndex=-1}else n=t.match(Z[Q.COERCE]);return n===null?null:dn(`${n[2]}.${n[3]||\"0\"}.${n[4]||\"0\"}`,e)};function mn(t){return String.fromCharCode(parseInt(t.slice(1),16))}function En(t){return`%${`00${t.charCodeAt(0).toString(16)}`.slice(-2)}`}function hn(t){return btoa(encodeURIComponent(t).replace(/%[0-9A-F]{2}/g,mn))}function fn(t){return decodeURIComponent(Array.from(atob(t),En).join(\"\"))}function ee(t){return hn(JSON.stringify(t))}function Ke(t){return JSON.parse(fn(t))}function b(t){return typeof t==\"undefined\"}function Rn(t){return t===null}function te(t){return Rn(t)||b(t)}function tr(t){return te(t)?!1:!b(t.jsonrpc)&&!b(t.id)&&!b(t.method)&&!b(t.params)}function Fe(t){return te(t)?!1:!b(t.jsonrpc)&&!b(t.id)&&(!b(t.result)||!b(t.error))}function nr(t){return te(t)?!1:typeof t==\"string\"&&Object.values(u).includes(t)}function je(t){return te(t)?!1:typeof t==\"number\"&&Object.values(p).includes(t)}function ne(t){if(!t)return!0;for(let e in t)if(Object.hasOwnProperty.call(t,e))return!1;return!0}var es_m={};function Tn(t,e){return Object.assign(es_m,e),t}var We={\"magic-sdk\":\"magic-sdk\",\"@magic-sdk/react-native-bare\":\"magic-sdk-rn-bare\",\"@magic-sdk/react-native-expo\":\"magic-sdk-rn-expo\"};var $=class extends Error{constructor(e,n){super(`Magic SDK Error: [${e}] ${n}`);this.code=e;this.rawMessage=n;this.__proto__=Error;Object.setPrototypeOf(this,$.prototype)}},w=class extends Error{constructor(e){super();this.__proto__=Error;let n=Number(e==null?void 0:e.code);this.rawMessage=(e==null?void 0:e.message)||\"Internal error\",this.code=je(n)?n:p.InternalError,this.message=`Magic RPC Error: [${this.code}] ${this.rawMessage}`,Object.setPrototypeOf(this,w.prototype)}},W=class{constructor(e,n){this.code=e;this.rawMessage=n;this.message=`Magic SDK Warning: [${e}] ${n}`}log(){console.warn(this.message)}},X=class extends Error{constructor(e,n,r,s){super(`Magic Extension Error (${e.name}): [${n}] ${r}`);this.code=n;this.rawMessage=r;this.data=s;this.__proto__=Error;Object.setPrototypeOf(this,X.prototype)}},se=class{constructor(e,n,r){this.code=n;this.rawMessage=r;this.message=`Magic Extension Warning (${e.name}): [${n}] ${r}`}log(){console.warn(this.message)}};function Xe(){return new $(a.MissingApiKey,\"Please provide an API key that you acquired from the Magic developer dashboard.\")}function lr(){return new $(a.ModalNotReady,\"Modal is not ready.\")}function Be(){return new $(a.MalformedResponse,\"Response from the Magic iframe is malformed.\")}function He(t){return new $(a.ExtensionNotInitialized,`Extensions must be initialized with a Magic SDK instance before \\`Extension.${t}\\` can be accessed. Do not invoke \\`Extension.${t}\\` inside an extension constructor.`)}function Ve(t){let e=`Some extensions are incompatible with \\`${es_m.sdkName}@${es_m.version}\\`:`;return t.filter(n=>typeof n.compat!=\"undefined\"&&n.compat!==null).forEach(n=>{let r=n.compat[es_m.sdkName];typeof r==\"string\"?e+=`\n  - Extension \\`${n.name}\\` supports version(s) \\`${r}\\``:r||(e+=`\n  - Extension \\`${n.name}\\` does not support ${es_m.platform} environments.`)}),new $(a.IncompatibleExtensions,e)}function ze(t){let e=n=>{let r=n+1,s=r%10,o=r%100;return s===1&&o!==11?`${r}st`:s===2&&o!==12?`${r}nd`:s===3&&o!==13?`${r}rd`:`${r}th`};return new $(a.InvalidArgument,`Invalid ${e(t.argument)} argument given to \\`${t.procedure}\\`.\n  Expected: \\`${t.expected}\\`\n  Received: \\`${t.received}\\``)}function pr(){return new W(m.DuplicateIframe,\"Duplicate iframes found.\")}function Ye(){return new W(m.SyncWeb3Method,\"Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.\")}function Ze(){return new W(m.ReactNativeEndpointConfiguration,`CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \\`endpoint\\` parameter SHOULD NOT be provided. The Magic \\`<iframe>\\` is automatically wrapped by a WebView pointed at \\`${es_m.defaultEndpoint}\\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`)}function ur(t){let{method:e,removalVersions:n,useInstead:r}=t,s=n[es_m.sdkName],o=r?` Use \\`${r}\\` instead.`:\"\",a=`\\`${e}\\` will be removed from \\`${es_m.sdkName}\\` in version \\`${s}\\`.${o}`;return new W(m.DeprecationNotice,a)}function*xn(){let t=0;for(;;)t<Number.MAX_SAFE_INTEGER?yield++t:t=0}var In=xn();function he(){return In.next().value}var Qe=Symbol(\"Payload pre-processed by Magic SDK\");function et(t){return Object.defineProperty(t,Qe,{value:!0,enumerable:!1}),t}function Pn(t){return!!t[Qe]}function C(t){var e,n,r;return Pn(t)||(t.jsonrpc=(e=t.jsonrpc)!=null?e:\"2.0\",t.id=he(),t.method=(n=t.method)!=null?n:\"noop\",t.params=(r=t.params)!=null?r:[],et(t)),t}function E(t,e=[]){return et({params:e,method:t,jsonrpc:\"2.0\",id:he()})}var _=class{constructor(e){e instanceof _?(this._jsonrpc=e.payload.jsonrpc,this._id=e.payload.id,this._result=e.payload.result,this._error=e.payload.error):Fe(e)?(this._jsonrpc=e.jsonrpc,this._id=e.id,this._result=e.result,this._error=e.error):(this._jsonrpc=e.jsonrpc,this._id=e.id,this._result=void 0,this._error=void 0)}applyError(e){return this._error=e,this}applyResult(e){return this._result=e,this}get hasError(){return typeof this._error!=\"undefined\"&&this._error!==null}get hasResult(){return typeof this._result!=\"undefined\"}get payload(){return{jsonrpc:this._jsonrpc,id:this._id,result:this._result,error:this._error}}};var rt=wt(nt()),st=class extends rt.default{};function ie(){let t=new st;return{emitter:t,createChainingEmitterMethod:(r,s)=>(...o)=>(t[r].apply(t,o),s),createBoundEmitterMethod:r=>(...s)=>t[r].apply(t,s)}}var ot=Symbol(\"isPromiEvent\");function it(t){return!!t[ot]}function ae(t){let e=ge(t),{createBoundEmitterMethod:n,createChainingEmitterMethod:r}=ie(),s=Symbol(\"Promise.then\"),o=Symbol(\"Promise.catch\"),a=Symbol(\"Promise.finally\"),i=(l,u)=>(...v)=>{let M=u[l].apply(u,v);return c(M)},c=l=>Object.assign(l,{[ot]:!0,[s]:l[s]||l.then,[o]:l[o]||l.catch,[a]:l[a]||l.finally,then:i(s,l),catch:i(o,l),finally:i(a,l),on:r(\"on\",l),once:r(\"once\",l),addListener:r(\"addListener\",l),off:r(\"off\",l),removeListener:r(\"removeListener\",l),removeAllListeners:r(\"removeAllListeners\",l),emit:n(\"emit\"),eventNames:n(\"eventNames\"),listeners:n(\"listeners\"),listenerCount:n(\"listenerCount\")}),p=c(e.then(l=>(p.emit(\"done\",l),p.emit(\"settled\"),l),l=>{throw p.emit(\"error\",l),p.emit(\"settled\"),l}));return p}function ge(t){return new Promise((e,n)=>{let r=t(e,n);Promise.resolve(r).catch(n)})}var P=class{constructor(e){this.sdk=e}get overlay(){return this.sdk.overlay}request(e){let n=this.overlay.post(o.MAGIC_HANDLE_REQUEST,C(e)),r=ae((o,a)=>{n.then(i=>{if(s(),i.hasError)a(new w(i.payload.error));else if(i.hasResult)o(i.payload.result);else throw Be()}).catch(i=>{s(),a(i)})}),s=this.overlay.on(g.MAGIC_HANDLE_EVENT,o=>{var i;let{response:a}=o.data;if(a.id===e.id&&((i=a.result)==null?void 0:i.event)){let{event:c,params:p=[]}=a.result;r.emit(c,...p)}});return r}createIntermediaryEvent(e,n){return s=>{let o=E(u.IntermediaryEvent,[{payloadId:n,eventType:e,args:s}]);this.request(o)}}};var ye=class extends P{loginWithMagicLink(e){let{email:n,showUI:r=!0,redirectURI:s}=e,o=E(this.sdk.testMode?u.LoginWithMagicLinkTestMode:u.LoginWithMagicLink,[{email:n,showUI:r,redirectURI:s}]);return this.request(o)}loginWithSMS(e){let{phoneNumber:n}=e,r=E(this.sdk.testMode?u.LoginWithSmsTestMode:u.LoginWithSms,[{phoneNumber:n,showUI:!0}]);return this.request(r)}loginWithEmailOTP(e){let{email:n}=e,r=E(this.sdk.testMode?u.LoginWithEmailOTPTestMode:u.LoginWithEmailOTP,[{email:n,showUI:!0}]);return this.request(r)}loginWithCredential(e){let n=e!=null?e:\"\";if(!e&&es_m.platform===\"web\"){n=window.location.search;let s=window.location.origin+window.location.pathname;window.history.replaceState(null,\"\",s)}let r=E(this.sdk.testMode?u.LoginWithCredentialTestMode:u.LoginWithCredential,[n]);return this.request(r)}};var H={};Mt(H,{clear:()=>An,getItem:()=>D,iterate:()=>Cn,key:()=>Sn,keys:()=>On,length:()=>Ln,removeItem:()=>le,setItem:()=>q});var ce;function L(t){return(...e)=>I(this,null,function*(){return ce||(ce=yield es_m.configureStorage()),yield ce.ready(),ce[t](...e)})}var D=L(\"getItem\"),q=L(\"setItem\"),le=L(\"removeItem\"),An=L(\"clear\"),Ln=L(\"length\"),Sn=L(\"key\"),On=L(\"keys\"),Cn=L(\"iterate\");function at(){let t=window.crypto.getRandomValues(new Uint8Array(16));t[6]=t[6]&15|64,t[8]=t[8]&191|128;let e=\"\";return e+=t[0].toString(16),e+=t[1].toString(16),e+=t[2].toString(16),e+=t[3].toString(16),e+=\"-\",e+=t[4].toString(16),e+=t[5].toString(16),e+=\"-\",e+=t[6].toString(16),e+=t[7].toString(16),e+=\"-\",e+=t[8].toString(16),e+=t[9].toString(16),e+=\"-\",e+=t[10].toString(16),e+=t[11].toString(16),e+=t[12].toString(16),e+=t[13].toString(16),e+=t[14].toString(16),e+=t[15].toString(16),e}var Re=\"STORE_KEY_PRIVATE_KEY\",pe=\"STORE_KEY_PUBLIC_JWK\",Te=\"ECDSA\",ct=\"P-256\",_n={name:Te,namedCurve:ct},Dn={name:Te,namedCurve:ct};function lt(){le(pe),le(Re)}function pt(){return I(this,null,function*(){let t=yield kn();if(!t){console.info(\"unable to create public key or webcrypto is unsupported\");return}let{subtle:e}=window.crypto,n=yield D(Re);if(!n||!e){console.info(\"unable to find private key or webcrypto unsupported\");return}let r={iat:Math.floor(new Date().getTime()/1e3),jti:at()},s={typ:\"dpop+jwt\",alg:\"ES256\",jwk:t},o={protected:ut(JSON.stringify(s)),claims:ut(JSON.stringify(r))},a=Gn(`${o.protected}.${o.claims}`),i={name:Te,hash:{name:\"SHA-256\"}},c=Kn(new Uint8Array(yield e.sign(i,n,a)));return`${o.protected}.${o.claims}.${c}`})}function kn(){return I(this,null,function*(){if(!qn()){console.info(\"webcrypto is not supported\");return}return(yield D(pe))||(yield Jn()),D(pe)})}function Jn(){return I(this,null,function*(){let t=null,{subtle:e}=window.crypto,n=yield e.generateKey(_n,!0,[\"sign\"]),r=yield e.exportKey(\"jwk\",n.privateKey);t=yield e.exportKey(\"jwk\",n.publicKey);let s=yield e.importKey(\"jwk\",r,Dn,!1,[\"sign\"]);yield q(Re,s),yield q(pe,t)})}function qn(){let t=typeof window!=\"undefined\"&&!!window.crypto,e=t&&!!window.crypto.subtle;return t&&e}function ut(t){return dt(Un(t))}function Gn(t){return new TextEncoder().encode(t)}function dt(t){return btoa(t).replace(/\\+/g,\"-\").replace(/\\//g,\"_\").replace(/=+/g,\"\")}function Un(t){return encodeURIComponent(t).replace(/%([0-9A-F]{2})/g,(n,r)=>String.fromCharCode(parseInt(r,16)))}function Kn(t){let e=\"\";return t.forEach(n=>{e+=String.fromCharCode(n)}),dt(e)}var ve=class extends P{getIdToken(e){let n=E(this.sdk.testMode?u.GetIdTokenTestMode:u.GetIdToken,[e]);return this.request(n)}generateIdToken(e){let n=E(this.sdk.testMode?u.GenerateIdTokenTestMode:u.GenerateIdToken,[e]);return this.request(n)}getMetadata(){let e=E(this.sdk.testMode?u.GetMetadataTestMode:u.GetMetadata);return this.request(e)}updateEmail(e){let{email:n,showUI:r=!0}=e,s=E(this.sdk.testMode?u.UpdateEmailTestMode:u.UpdateEmail,[{email:n,showUI:r}]);return this.request(s)}isLoggedIn(){let e=E(this.sdk.testMode?u.IsLoggedInTestMode:u.IsLoggedIn);return this.request(e)}logout(){lt();let e=E(this.sdk.testMode?u.LogoutTestMode:u.Logout);return this.request(e)}showSettings(){let e=E(this.sdk.testMode?u.UserSettingsTestMode:u.UserSettings);return this.request(e)}};var{createBoundEmitterMethod:ue,createChainingEmitterMethod:G}=ie(),xe=class extends P{constructor(){super(...arguments);this.isMagic=!0;this.on=G(\"on\",this);this.once=G(\"once\",this);this.addListener=G(\"addListener\",this);this.off=G(\"off\",this);this.removeListener=G(\"removeListener\",this);this.removeAllListeners=G(\"removeAllListeners\",this);this.emit=ue(\"emit\");this.eventNames=ue(\"eventNames\");this.listeners=ue(\"listeners\");this.listenerCount=ue(\"listenerCount\")}sendAsync(e,n){if(!n)throw ze({procedure:\"Magic.rpcProvider.sendAsync\",argument:1,expected:\"function\",received:n===null?\"null\":typeof n});if(Array.isArray(e))this.overlay.post(o.MAGIC_HANDLE_REQUEST,e.map(r=>{let s=C(r);return this.prefixPayloadMethodForTestMode(s),s})).then(r=>{n(null,r.map(s=>we(z({},s.payload),{error:s.hasError?new w(s.payload.error):null})))});else{let r=C(e);this.prefixPayloadMethodForTestMode(r),this.overlay.post(o.MAGIC_HANDLE_REQUEST,r).then(s=>{n(s.hasError?new w(s.payload.error):null,s.payload)})}}send(e,n){if(typeof e==\"string\"){let s=E(e,Array.isArray(n)?n:[]);return this.request(s)}if(Array.isArray(e)||!!n){this.sendAsync(e,n);return}let r=Ye();return r.log(),new _(e).applyError({code:-32603,message:r.rawMessage}).payload}enable(){let e=E(\"eth_accounts\");return this.request(e)}request(e){return this.prefixPayloadMethodForTestMode(e),super.request(e)}prefixPayloadMethodForTestMode(e){let n=\"testMode/eth/\";this.sdk.testMode&&(e.method=`${n}${e.method}`)}};function Ie(t,e){return e?new URL(t,e):new URL(t)}var Et=[\"request\",\"overlay\",\"sdk\"];function Fn(t){let e=Object.getPrototypeOf(t),n=[e];for(;e!==P.prototype;)e=Object.getPrototypeOf(e),n.push(e);return n}var Pe=class extends P{constructor(){super(void 0);this.__sdk_access_field_descriptors__=new Map;this.__is_initialized__=!1;this.utils={createPromiEvent:ae,isPromiEvent:it,encodeJSON:ee,decodeJSON:Ke,createJsonRpcRequestPayload:E,standardizeJsonRpcRequestPayload:C,storage:H};let e=[this,...Fn(this)];Et.forEach(n=>{let r=e.map(i=>Object.getOwnPropertyDescriptor(i,n)),s=r.findIndex(i=>!!i),o=s>0,a=r[s];a&&(this.__sdk_access_field_descriptors__.set(n,{descriptor:a,isPrototypeField:o}),Object.defineProperty(this,n,{configurable:!0,get:()=>{throw He(n)}}))})}init(e){this.__is_initialized__||(Et.forEach(n=>{if(this.__sdk_access_field_descriptors__.has(n)){let{descriptor:r,isPrototypeField:s}=this.__sdk_access_field_descriptors__.get(n);s?delete this[n]:Object.defineProperty(this,n,r)}}),this.sdk=e,this.__is_initialized__=!0)}createDeprecationWarning(e){let{method:n,removalVersion:r,useInstead:s}=e,o=s?` Use \\`${s}\\` instead.`:\"\",a=`\\`${n}\\` will be removed from this Extension in version \\`${r}\\`.${o}`;return new se(this,\"DEPRECATION_NOTICE\",a)}createWarning(e,n){return new se(this,e,n)}createError(e,n,r){return new X(this,e,n,r)}},ht=class extends Pe{},S=class extends Pe{};S.Internal=ht,S.Anonymous=\"anonymous extension\";function ft(t){return t.compat&&t.compat[es_m.sdkName]!=null?typeof t.compat[es_m.sdkName]==\"string\"?Je(Ue(es_m.version),t.compat[es_m.sdkName]):!!t.compat[es_m.sdkName]:!0}function jn(t){var s;let e=(s=t==null?void 0:t.extensions)!=null?s:[],n={},r=[];if(Array.isArray(e)?e.forEach(o=>{ft(o)?(o.init(this),(o.name||o.name!==S.Anonymous)&&(this[o.name]=o),o instanceof S.Internal&&(ne(o.config)||(n[o.name]=o.config))):r.push(o)}):Object.keys(e).forEach(o=>{if(ft(e[o])){e[o].init(this);let a=e[o];this[o]=a,a instanceof S.Internal&&(ne(a.config)||(n[e[o].name]=a.config))}else r.push(e[o])}),r.length)throw Ve(r);return n}var V=class{constructor(e,n){this.apiKey=e;var a;if(!e)throw Xe();es_m.platform===\"react-native\"&&(n==null?void 0:n.endpoint)&&Ze().log();let{defaultEndpoint:r,version:s}=es_m;this.testMode=!!(n==null?void 0:n.testMode),this.endpoint=Ie((a=n==null?void 0:n.endpoint)!=null?a:r).origin,this.auth=new ye(this),this.user=new ve(this),this.rpcProvider=new xe(this);let o=jn.call(this,n);this.parameters=ee(z({API_KEY:this.apiKey,DOMAIN_ORIGIN:window.location?window.location.origin:\"\",ETH_NETWORK:n==null?void 0:n.network,host:Ie(this.endpoint).host,sdk:We[es_m.sdkName],version:s,ext:ne(o)?void 0:o,locale:(n==null?void 0:n.locale)||\"en_US\"},es_m.bundleId?{bundleId:es_m.bundleId}:{}))}get overlay(){if(!V.__overlays__.has(this.parameters)){let e=new es_m.ViewController(this.endpoint,this.parameters);e.init(),V.__overlays__.set(this.parameters,e)}return V.__overlays__.get(this.parameters)}preload(){return I(this,null,function*(){yield this.overlay.ready})}},be=V;be.__overlays__=new Map;function Wn(t,e){return e&&Array.isArray(t)?t.find(n=>n.id===e):t}function Xn(t,e){var s;let n=(s=e.data.response)==null?void 0:s.id,r=Wn(t,n);if(n&&r){let o=new _(r).applyResult(e.data.response.result).applyError(e.data.response.error);return{id:n,response:o}}return{}}function Bn(t,e){return I(this,null,function*(){let n=yield D(\"rt\"),r;if(es_m.platform===\"web\")try{r=yield pt()}catch(s){console.error(\"webcrypto error\",s)}return r?n?{msgType:t,payload:e,jwt:r,rt:n}:{msgType:t,payload:e,jwt:r}:{msgType:t,payload:e}})}function Hn(t){return I(this,null,function*(){!t.data.rt||(yield q(\"rt\",t.data.rt))})}var gt=class{constructor(e,n){this.endpoint=e;this.parameters=n;this.messageHandlers=new Set;this.ready=this.waitForReady(),this.listen()}post(e,n){return I(this,null,function*(){return ge(r=>I(this,null,function*(){yield this.ready;let s=[],o=Array.isArray(n)?n.map(p=>p.id):[],a=yield Bn(`${e}-${this.parameters}`,n);yield this._post(a);let i=p=>l=>{let{id:u,response:v}=Xn(n,l);Hn(l),u&&v&&Array.isArray(n)&&o.includes(u)?(s.push(v),s.length===n.length&&(p(),r(s))):u&&v&&!Array.isArray(n)&&u===n.id&&(p(),r(v))},c=this.on(g.MAGIC_HANDLE_RESPONSE,i(()=>c()))}))})}on(e,n){let r=n.bind(window),s=o=>{o.data.msgType===`${e}-${this.parameters}`&&r(o)};return this.messageHandlers.add(s),()=>this.messageHandlers.delete(s)}waitForReady(){return new Promise(e=>{this.on(g.MAGIC_OVERLAY_READY,()=>e())})}listen(){this.on(g.MAGIC_HIDE_OVERLAY,()=>{this.hideOverlay()}),this.on(g.MAGIC_SHOW_OVERLAY,()=>{this.showOverlay()})}};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@magic-sdk/commons/dist/es/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/magic-sdk/dist/es/index.mjs\nvar Zr=Object.create;var es_De=Object.defineProperty;var qr=Object.getOwnPropertyDescriptor;var kr=Object.getOwnPropertyNames;var es_et=Object.getPrototypeOf,es_rt=Object.prototype.hasOwnProperty;var tt=p=>es_De(p,\"__esModule\",{value:!0});var es_ve=(p=>typeof require!=\"undefined\"?require:typeof Proxy!=\"undefined\"?new Proxy(p,{get:(g,O)=>(typeof require!=\"undefined\"?require:g)[O]}):p)(function(p){if(typeof require!=\"undefined\")return require.apply(this,arguments);throw new Error('Dynamic require of \"'+p+'\" is not supported')});var es_$e=(p,g)=>()=>(g||p((g={exports:{}}).exports,g),g.exports);var es_nt=(p,g,O,L)=>{if(g&&typeof g==\"object\"||typeof g==\"function\")for(let M of kr(g))!es_rt.call(p,M)&&(O||M!==\"default\")&&es_De(p,M,{get:()=>g[M],enumerable:!(L=qr(g,M))||L.enumerable});return p},es_Ze=(p,g)=>es_nt(tt(es_De(p!=null?Zr(es_et(p)):{},\"default\",!g&&p&&p.__esModule?{get:()=>p.default,enumerable:!0}:{value:p,enumerable:!0})),p);var es_se=(p,g,O)=>new Promise((L,M)=>{var Q=S=>{try{Y(O.next(S))}catch(P){M(P)}},C=S=>{try{Y(O.throw(S))}catch(P){M(P)}},Y=S=>S.done?L(S.value):Promise.resolve(S.value).then(Q,C);Y((O=O.apply(p,g)).next())});var es_ke=es_$e((qe,Ne)=>{(function(p){if(typeof qe==\"object\"&&typeof Ne!=\"undefined\")Ne.exports=p();else if(typeof define==\"function\"&&define.amd)define([],p);else{var g;typeof window!=\"undefined\"?g=window:typeof global!=\"undefined\"?g=global:typeof self!=\"undefined\"?g=self:g=this,g.localforage=p()}})(function(){var p,g,O;return function L(M,Q,C){function Y(K,Z){if(!Q[K]){if(!M[K]){var m=typeof es_ve==\"function\"&&es_ve;if(!Z&&m)return m(K,!0);if(S)return S(K,!0);var w=new Error(\"Cannot find module '\"+K+\"'\");throw w.code=\"MODULE_NOT_FOUND\",w}var N=Q[K]={exports:{}};M[K][0].call(N.exports,function(z){var q=M[K][1][z];return Y(q||z)},N,N.exports,L,M,Q,C)}return Q[K].exports}for(var S=typeof es_ve==\"function\"&&es_ve,P=0;P<C.length;P++)Y(C[P]);return Y}({1:[function(L,M,Q){(function(C){\"use strict\";var Y=C.MutationObserver||C.WebKitMutationObserver,S;if(Y){var P=0,K=new Y(z),Z=C.document.createTextNode(\"\");K.observe(Z,{characterData:!0}),S=function(){Z.data=P=++P%2}}else if(!C.setImmediate&&typeof C.MessageChannel!=\"undefined\"){var m=new C.MessageChannel;m.port1.onmessage=z,S=function(){m.port2.postMessage(0)}}else\"document\"in C&&\"onreadystatechange\"in C.document.createElement(\"script\")?S=function(){var F=C.document.createElement(\"script\");F.onreadystatechange=function(){z(),F.onreadystatechange=null,F.parentNode.removeChild(F),F=null},C.document.documentElement.appendChild(F)}:S=function(){setTimeout(z,0)};var w,N=[];function z(){w=!0;for(var F,k,U=N.length;U;){for(k=N,N=[],F=-1;++F<U;)k[F]();U=N.length}w=!1}M.exports=q;function q(F){N.push(F)===1&&!w&&S()}}).call(this,typeof global!=\"undefined\"?global:typeof self!=\"undefined\"?self:typeof window!=\"undefined\"?window:{})},{}],2:[function(L,M,Q){\"use strict\";var C=L(1);function Y(){}var S={},P=[\"REJECTED\"],K=[\"FULFILLED\"],Z=[\"PENDING\"];M.exports=m;function m(h){if(typeof h!=\"function\")throw new TypeError(\"resolver must be a function\");this.state=Z,this.queue=[],this.outcome=void 0,h!==Y&&q(this,h)}m.prototype.catch=function(h){return this.then(null,h)},m.prototype.then=function(h,R){if(typeof h!=\"function\"&&this.state===K||typeof R!=\"function\"&&this.state===P)return this;var I=new this.constructor(Y);if(this.state!==Z){var B=this.state===K?h:R;N(I,B,this.outcome)}else this.queue.push(new w(I,h,R));return I};function w(h,R,I){this.promise=h,typeof R==\"function\"&&(this.onFulfilled=R,this.callFulfilled=this.otherCallFulfilled),typeof I==\"function\"&&(this.onRejected=I,this.callRejected=this.otherCallRejected)}w.prototype.callFulfilled=function(h){S.resolve(this.promise,h)},w.prototype.otherCallFulfilled=function(h){N(this.promise,this.onFulfilled,h)},w.prototype.callRejected=function(h){S.reject(this.promise,h)},w.prototype.otherCallRejected=function(h){N(this.promise,this.onRejected,h)};function N(h,R,I){C(function(){var B;try{B=R(I)}catch(H){return S.reject(h,H)}B===h?S.reject(h,new TypeError(\"Cannot resolve promise with itself\")):S.resolve(h,B)})}S.resolve=function(h,R){var I=F(z,R);if(I.status===\"error\")return S.reject(h,I.value);var B=I.value;if(B)q(h,B);else{h.state=K,h.outcome=R;for(var H=-1,j=h.queue.length;++H<j;)h.queue[H].callFulfilled(R)}return h},S.reject=function(h,R){h.state=P,h.outcome=R;for(var I=-1,B=h.queue.length;++I<B;)h.queue[I].callRejected(R);return h};function z(h){var R=h&&h.then;if(h&&(typeof h==\"object\"||typeof h==\"function\")&&typeof R==\"function\")return function(){R.apply(h,arguments)}}function q(h,R){var I=!1;function B($){I||(I=!0,S.reject(h,$))}function H($){I||(I=!0,S.resolve(h,$))}function j(){R(H,B)}var J=F(j);J.status===\"error\"&&B(J.value)}function F(h,R){var I={};try{I.value=h(R),I.status=\"success\"}catch(B){I.status=\"error\",I.value=B}return I}m.resolve=k;function k(h){return h instanceof this?h:S.resolve(new this(Y),h)}m.reject=U;function U(h){var R=new this(Y);return S.reject(R,h)}m.all=ae;function ae(h){var R=this;if(Object.prototype.toString.call(h)!==\"[object Array]\")return this.reject(new TypeError(\"must be an array\"));var I=h.length,B=!1;if(!I)return this.resolve([]);for(var H=new Array(I),j=0,J=-1,$=new this(Y);++J<I;)ee(h[J],J);return $;function ee(oe,a){R.resolve(oe).then(s,function(v){B||(B=!0,S.reject($,v))});function s(v){H[a]=v,++j===I&&!B&&(B=!0,S.resolve($,H))}}}m.race=re;function re(h){var R=this;if(Object.prototype.toString.call(h)!==\"[object Array]\")return this.reject(new TypeError(\"must be an array\"));var I=h.length,B=!1;if(!I)return this.resolve([]);for(var H=-1,j=new this(Y);++H<I;)J(h[H]);return j;function J($){R.resolve($).then(function(ee){B||(B=!0,S.resolve(j,ee))},function(ee){B||(B=!0,S.reject(j,ee))})}}},{\"1\":1}],3:[function(L,M,Q){(function(C){\"use strict\";typeof C.Promise!=\"function\"&&(C.Promise=L(2))}).call(this,typeof global!=\"undefined\"?global:typeof self!=\"undefined\"?self:typeof window!=\"undefined\"?window:{})},{\"2\":2}],4:[function(L,M,Q){\"use strict\";var C=typeof Symbol==\"function\"&&typeof Symbol.iterator==\"symbol\"?function(e){return typeof e}:function(e){return e&&typeof Symbol==\"function\"&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e};function Y(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function S(){try{if(typeof indexedDB!=\"undefined\")return indexedDB;if(typeof webkitIndexedDB!=\"undefined\")return webkitIndexedDB;if(typeof mozIndexedDB!=\"undefined\")return mozIndexedDB;if(typeof OIndexedDB!=\"undefined\")return OIndexedDB;if(typeof msIndexedDB!=\"undefined\")return msIndexedDB}catch{return}}var P=S();function K(){try{if(!P||!P.open)return!1;var e=typeof openDatabase!=\"undefined\"&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),t=typeof fetch==\"function\"&&fetch.toString().indexOf(\"[native code\")!==-1;return(!e||t)&&typeof indexedDB!=\"undefined\"&&typeof IDBKeyRange!=\"undefined\"}catch{return!1}}function Z(e,t){e=e||[],t=t||{};try{return new Blob(e,t)}catch(n){if(n.name!==\"TypeError\")throw n;for(var r=typeof BlobBuilder!=\"undefined\"?BlobBuilder:typeof MSBlobBuilder!=\"undefined\"?MSBlobBuilder:typeof MozBlobBuilder!=\"undefined\"?MozBlobBuilder:WebKitBlobBuilder,o=new r,i=0;i<e.length;i+=1)o.append(e[i]);return o.getBlob(t.type)}}typeof Promise==\"undefined\"&&L(3);var m=Promise;function w(e,t){t&&e.then(function(r){t(null,r)},function(r){t(r)})}function N(e,t,r){typeof t==\"function\"&&e.then(t),typeof r==\"function\"&&e.catch(r)}function z(e){return typeof e!=\"string\"&&(console.warn(e+\" used as a key, but it is not a string.\"),e=String(e)),e}function q(){if(arguments.length&&typeof arguments[arguments.length-1]==\"function\")return arguments[arguments.length-1]}var F=\"local-forage-detect-blob-support\",k=void 0,U={},ae=Object.prototype.toString,re=\"readonly\",h=\"readwrite\";function R(e){for(var t=e.length,r=new ArrayBuffer(t),o=new Uint8Array(r),i=0;i<t;i++)o[i]=e.charCodeAt(i);return r}function I(e){return new m(function(t){var r=e.transaction(F,h),o=Z([\"\"]);r.objectStore(F).put(o,\"key\"),r.onabort=function(i){i.preventDefault(),i.stopPropagation(),t(!1)},r.oncomplete=function(){var i=navigator.userAgent.match(/Chrome\\/(\\d+)/),n=navigator.userAgent.match(/Edge\\//);t(n||!i||parseInt(i[1],10)>=43)}}).catch(function(){return!1})}function B(e){return typeof k==\"boolean\"?m.resolve(k):I(e).then(function(t){return k=t,k})}function H(e){var t=U[e.name],r={};r.promise=new m(function(o,i){r.resolve=o,r.reject=i}),t.deferredOperations.push(r),t.dbReady?t.dbReady=t.dbReady.then(function(){return r.promise}):t.dbReady=r.promise}function j(e){var t=U[e.name],r=t.deferredOperations.pop();if(r)return r.resolve(),r.promise}function J(e,t){var r=U[e.name],o=r.deferredOperations.pop();if(o)return o.reject(t),o.promise}function $(e,t){return new m(function(r,o){if(U[e.name]=U[e.name]||G(),e.db)if(t)H(e),e.db.close();else return r(e.db);var i=[e.name];t&&i.push(e.version);var n=P.open.apply(P,i);t&&(n.onupgradeneeded=function(f){var u=n.result;try{u.createObjectStore(e.storeName),f.oldVersion<=1&&u.createObjectStore(F)}catch(c){if(c.name===\"ConstraintError\")console.warn('The database \"'+e.name+'\" has been upgraded from version '+f.oldVersion+\" to version \"+f.newVersion+', but the storage \"'+e.storeName+'\" already exists.');else throw c}}),n.onerror=function(f){f.preventDefault(),o(n.error)},n.onsuccess=function(){r(n.result),j(e)}})}function ee(e){return $(e,!1)}function oe(e){return $(e,!0)}function a(e,t){if(!e.db)return!0;var r=!e.db.objectStoreNames.contains(e.storeName),o=e.version<e.db.version,i=e.version>e.db.version;if(o&&(e.version!==t&&console.warn('The database \"'+e.name+`\" can't be downgraded from version `+e.db.version+\" to version \"+e.version+\".\"),e.version=e.db.version),i||r){if(r){var n=e.db.version+1;n>e.version&&(e.version=n)}return!0}return!1}function s(e){return new m(function(t,r){var o=new FileReader;o.onerror=r,o.onloadend=function(i){var n=btoa(i.target.result||\"\");t({__local_forage_encoded_blob:!0,data:n,type:e.type})},o.readAsBinaryString(e)})}function v(e){var t=R(atob(e.data));return Z([t],{type:e.type})}function b(e){return e&&e.__local_forage_encoded_blob}function _(e){var t=this,r=t._initReady().then(function(){var o=U[t._dbInfo.name];if(o&&o.dbReady)return o.dbReady});return N(r,e,e),r}function E(e){H(e);for(var t=U[e.name],r=t.forages,o=0;o<r.length;o++){var i=r[o];i._dbInfo.db&&(i._dbInfo.db.close(),i._dbInfo.db=null)}return e.db=null,ee(e).then(function(n){return e.db=n,a(e)?oe(e):n}).then(function(n){e.db=t.db=n;for(var f=0;f<r.length;f++)r[f]._dbInfo.db=n}).catch(function(n){throw J(e,n),n})}function D(e,t,r,o){o===void 0&&(o=1);try{var i=e.db.transaction(e.storeName,t);r(null,i)}catch(n){if(o>0&&(!e.db||n.name===\"InvalidStateError\"||n.name===\"NotFoundError\"))return m.resolve().then(function(){if(!e.db||n.name===\"NotFoundError\"&&!e.db.objectStoreNames.contains(e.storeName)&&e.version<=e.db.version)return e.db&&(e.version=e.db.version+1),oe(e)}).then(function(){return E(e).then(function(){D(e,t,r,o-1)})}).catch(r);r(n)}}function G(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function fe(e){var t=this,r={db:null};if(e)for(var o in e)r[o]=e[o];var i=U[r.name];i||(i=G(),U[r.name]=i),i.forages.push(t),t._initReady||(t._initReady=t.ready,t.ready=_);var n=[];function f(){return m.resolve()}for(var u=0;u<i.forages.length;u++){var c=i.forages[u];c!==t&&n.push(c._initReady().catch(f))}var l=i.forages.slice(0);return m.all(n).then(function(){return r.db=i.db,ee(r)}).then(function(d){return r.db=d,a(r,t._defaultConfig.version)?oe(r):d}).then(function(d){r.db=i.db=d,t._dbInfo=r;for(var y=0;y<l.length;y++){var A=l[y];A!==t&&(A._dbInfo.db=r.db,A._dbInfo.version=r.version)}})}function ie(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){D(r._dbInfo,re,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=c.get(e);l.onsuccess=function(){var d=l.result;d===void 0&&(d=null),b(d)&&(d=v(d)),i(d)},l.onerror=function(){n(l.error)}}catch(d){n(d)}})}).catch(n)});return w(o,t),o}function ce(e,t){var r=this,o=new m(function(i,n){r.ready().then(function(){D(r._dbInfo,re,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=c.openCursor(),d=1;l.onsuccess=function(){var y=l.result;if(y){var A=y.value;b(A)&&(A=v(A));var T=e(A,y.key,d++);T!==void 0?i(T):y.continue()}else i()},l.onerror=function(){n(l.error)}}catch(y){n(y)}})}).catch(n)});return w(o,t),o}function nr(e,t,r){var o=this;e=z(e);var i=new m(function(n,f){var u;o.ready().then(function(){return u=o._dbInfo,ae.call(t)===\"[object Blob]\"?B(u.db).then(function(c){return c?t:s(t)}):t}).then(function(c){D(o._dbInfo,h,function(l,d){if(l)return f(l);try{var y=d.objectStore(o._dbInfo.storeName);c===null&&(c=void 0);var A=y.put(c,e);d.oncomplete=function(){c===void 0&&(c=null),n(c)},d.onabort=d.onerror=function(){var T=A.error?A.error:A.transaction.error;f(T)}}catch(T){f(T)}})}).catch(f)});return w(i,r),i}function or(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){D(r._dbInfo,h,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=c.delete(e);u.oncomplete=function(){i()},u.onerror=function(){n(l.error)},u.onabort=function(){var d=l.error?l.error:l.transaction.error;n(d)}}catch(d){n(d)}})}).catch(n)});return w(o,t),o}function ir(e){var t=this,r=new m(function(o,i){t.ready().then(function(){D(t._dbInfo,h,function(n,f){if(n)return i(n);try{var u=f.objectStore(t._dbInfo.storeName),c=u.clear();f.oncomplete=function(){o()},f.onabort=f.onerror=function(){var l=c.error?c.error:c.transaction.error;i(l)}}catch(l){i(l)}})}).catch(i)});return w(r,e),r}function ar(e){var t=this,r=new m(function(o,i){t.ready().then(function(){D(t._dbInfo,re,function(n,f){if(n)return i(n);try{var u=f.objectStore(t._dbInfo.storeName),c=u.count();c.onsuccess=function(){o(c.result)},c.onerror=function(){i(c.error)}}catch(l){i(l)}})}).catch(i)});return w(r,e),r}function fr(e,t){var r=this,o=new m(function(i,n){if(e<0){i(null);return}r.ready().then(function(){D(r._dbInfo,re,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=!1,d=c.openKeyCursor();d.onsuccess=function(){var y=d.result;if(!y){i(null);return}e===0||l?i(y.key):(l=!0,y.advance(e))},d.onerror=function(){n(d.error)}}catch(y){n(y)}})}).catch(n)});return w(o,t),o}function ur(e){var t=this,r=new m(function(o,i){t.ready().then(function(){D(t._dbInfo,re,function(n,f){if(n)return i(n);try{var u=f.objectStore(t._dbInfo.storeName),c=u.openKeyCursor(),l=[];c.onsuccess=function(){var d=c.result;if(!d){o(l);return}l.push(d.key),d.continue()},c.onerror=function(){i(c.error)}}catch(d){i(d)}})}).catch(i)});return w(r,e),r}function sr(e,t){t=q.apply(this,arguments);var r=this.config();e=typeof e!=\"function\"&&e||{},e.name||(e.name=e.name||r.name,e.storeName=e.storeName||r.storeName);var o=this,i;if(!e.name)i=m.reject(\"Invalid arguments\");else{var n=e.name===r.name&&o._dbInfo.db,f=n?m.resolve(o._dbInfo.db):ee(e).then(function(u){var c=U[e.name],l=c.forages;c.db=u;for(var d=0;d<l.length;d++)l[d]._dbInfo.db=u;return u});e.storeName?i=f.then(function(u){if(!!u.objectStoreNames.contains(e.storeName)){var c=u.version+1;H(e);var l=U[e.name],d=l.forages;u.close();for(var y=0;y<d.length;y++){var A=d[y];A._dbInfo.db=null,A._dbInfo.version=c}var T=new m(function(x,V){var W=P.open(e.name,c);W.onerror=function(X){var de=W.result;de.close(),V(X)},W.onupgradeneeded=function(){var X=W.result;X.deleteObjectStore(e.storeName)},W.onsuccess=function(){var X=W.result;X.close(),x(X)}});return T.then(function(x){l.db=x;for(var V=0;V<d.length;V++){var W=d[V];W._dbInfo.db=x,j(W._dbInfo)}}).catch(function(x){throw(J(e,x)||m.resolve()).catch(function(){}),x})}}):i=f.then(function(u){H(e);var c=U[e.name],l=c.forages;u.close();for(var d=0;d<l.length;d++){var y=l[d];y._dbInfo.db=null}var A=new m(function(T,x){var V=P.deleteDatabase(e.name);V.onerror=V.onblocked=function(W){var X=V.result;X&&X.close(),x(W)},V.onsuccess=function(){var W=V.result;W&&W.close(),T(W)}});return A.then(function(T){c.db=T;for(var x=0;x<l.length;x++){var V=l[x];j(V._dbInfo)}}).catch(function(T){throw(J(e,T)||m.resolve()).catch(function(){}),T})})}return w(i,t),i}var cr={_driver:\"asyncStorage\",_initStorage:fe,_support:K(),iterate:ce,getItem:ie,setItem:nr,removeItem:or,clear:ir,length:ar,key:fr,keys:ur,dropInstance:sr};function lr(){return typeof openDatabase==\"function\"}var te=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",dr=\"~~local_forage_type~\",xe=/^~~local_forage_type~([^~]+)~/,he=\"__lfsc__:\",ge=he.length,be=\"arbf\",_e=\"blob\",Oe=\"si08\",Ce=\"ui08\",Le=\"uic8\",Pe=\"si16\",Me=\"si32\",Fe=\"ur16\",Ue=\"ui32\",Ye=\"fl32\",ze=\"fl64\",We=ge+be.length,Ke=Object.prototype.toString;function He(e){var t=e.length*.75,r=e.length,o,i=0,n,f,u,c;e[e.length-1]===\"=\"&&(t--,e[e.length-2]===\"=\"&&t--);var l=new ArrayBuffer(t),d=new Uint8Array(l);for(o=0;o<r;o+=4)n=te.indexOf(e[o]),f=te.indexOf(e[o+1]),u=te.indexOf(e[o+2]),c=te.indexOf(e[o+3]),d[i++]=n<<2|f>>4,d[i++]=(f&15)<<4|u>>2,d[i++]=(u&3)<<6|c&63;return l}function we(e){var t=new Uint8Array(e),r=\"\",o;for(o=0;o<t.length;o+=3)r+=te[t[o]>>2],r+=te[(t[o]&3)<<4|t[o+1]>>4],r+=te[(t[o+1]&15)<<2|t[o+2]>>6],r+=te[t[o+2]&63];return t.length%3===2?r=r.substring(0,r.length-1)+\"=\":t.length%3===1&&(r=r.substring(0,r.length-2)+\"==\"),r}function vr(e,t){var r=\"\";if(e&&(r=Ke.call(e)),e&&(r===\"[object ArrayBuffer]\"||e.buffer&&Ke.call(e.buffer)===\"[object ArrayBuffer]\")){var o,i=he;e instanceof ArrayBuffer?(o=e,i+=be):(o=e.buffer,r===\"[object Int8Array]\"?i+=Oe:r===\"[object Uint8Array]\"?i+=Ce:r===\"[object Uint8ClampedArray]\"?i+=Le:r===\"[object Int16Array]\"?i+=Pe:r===\"[object Uint16Array]\"?i+=Fe:r===\"[object Int32Array]\"?i+=Me:r===\"[object Uint32Array]\"?i+=Ue:r===\"[object Float32Array]\"?i+=Ye:r===\"[object Float64Array]\"?i+=ze:t(new Error(\"Failed to get type for BinaryArray\"))),t(i+we(o))}else if(r===\"[object Blob]\"){var n=new FileReader;n.onload=function(){var f=dr+e.type+\"~\"+we(this.result);t(he+_e+f)},n.readAsArrayBuffer(e)}else try{t(JSON.stringify(e))}catch(f){console.error(\"Couldn't convert value into a JSON string: \",e),t(null,f)}}function hr(e){if(e.substring(0,ge)!==he)return JSON.parse(e);var t=e.substring(We),r=e.substring(ge,We),o;if(r===_e&&xe.test(t)){var i=t.match(xe);o=i[1],t=t.substring(i[0].length)}var n=He(t);switch(r){case be:return n;case _e:return Z([n],{type:o});case Oe:return new Int8Array(n);case Ce:return new Uint8Array(n);case Le:return new Uint8ClampedArray(n);case Pe:return new Int16Array(n);case Fe:return new Uint16Array(n);case Me:return new Int32Array(n);case Ue:return new Uint32Array(n);case Ye:return new Float32Array(n);case ze:return new Float64Array(n);default:throw new Error(\"Unkown type: \"+r)}}var Ee={serialize:vr,deserialize:hr,stringToBuffer:He,bufferToString:we};function Ve(e,t,r,o){e.executeSql(\"CREATE TABLE IF NOT EXISTS \"+t.storeName+\" (id INTEGER PRIMARY KEY, key unique, value)\",[],r,o)}function mr(e){var t=this,r={db:null};if(e)for(var o in e)r[o]=typeof e[o]!=\"string\"?e[o].toString():e[o];var i=new m(function(n,f){try{r.db=openDatabase(r.name,String(r.version),r.description,r.size)}catch(u){return f(u)}r.db.transaction(function(u){Ve(u,r,function(){t._dbInfo=r,n()},function(c,l){f(l)})},f)});return r.serializer=Ee,i}function ne(e,t,r,o,i,n){e.executeSql(r,o,i,function(f,u){u.code===u.SYNTAX_ERR?f.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name = ?\",[t.storeName],function(c,l){l.rows.length?n(c,u):Ve(c,t,function(){c.executeSql(r,o,i,n)},n)},n):n(f,u)},n)}function yr(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"SELECT * FROM \"+f.storeName+\" WHERE key = ? LIMIT 1\",[e],function(c,l){var d=l.rows.length?l.rows.item(0).value:null;d&&(d=f.serializer.deserialize(d)),i(d)},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function pr(e,t){var r=this,o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"SELECT * FROM \"+f.storeName,[],function(c,l){for(var d=l.rows,y=d.length,A=0;A<y;A++){var T=d.item(A),x=T.value;if(x&&(x=f.serializer.deserialize(x)),x=e(x,T.key,A+1),x!==void 0){i(x);return}}i()},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function Ge(e,t,r,o){var i=this;e=z(e);var n=new m(function(f,u){i.ready().then(function(){t===void 0&&(t=null);var c=t,l=i._dbInfo;l.serializer.serialize(t,function(d,y){y?u(y):l.db.transaction(function(A){ne(A,l,\"INSERT OR REPLACE INTO \"+l.storeName+\" (key, value) VALUES (?, ?)\",[e,d],function(){f(c)},function(T,x){u(x)})},function(A){if(A.code===A.QUOTA_ERR){if(o>0){f(Ge.apply(i,[e,c,r,o-1]));return}u(A)}})})}).catch(u)});return w(n,r),n}function gr(e,t,r){return Ge.apply(this,[e,t,r,1])}function br(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"DELETE FROM \"+f.storeName+\" WHERE key = ?\",[e],function(){i()},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function _r(e){var t=this,r=new m(function(o,i){t.ready().then(function(){var n=t._dbInfo;n.db.transaction(function(f){ne(f,n,\"DELETE FROM \"+n.storeName,[],function(){o()},function(u,c){i(c)})})}).catch(i)});return w(r,e),r}function wr(e){var t=this,r=new m(function(o,i){t.ready().then(function(){var n=t._dbInfo;n.db.transaction(function(f){ne(f,n,\"SELECT COUNT(key) as c FROM \"+n.storeName,[],function(u,c){var l=c.rows.item(0).c;o(l)},function(u,c){i(c)})})}).catch(i)});return w(r,e),r}function Er(e,t){var r=this,o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"SELECT key FROM \"+f.storeName+\" WHERE id = ? LIMIT 1\",[e+1],function(c,l){var d=l.rows.length?l.rows.item(0).key:null;i(d)},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function Ir(e){var t=this,r=new m(function(o,i){t.ready().then(function(){var n=t._dbInfo;n.db.transaction(function(f){ne(f,n,\"SELECT key FROM \"+n.storeName,[],function(u,c){for(var l=[],d=0;d<c.rows.length;d++)l.push(c.rows.item(d).key);o(l)},function(u,c){i(c)})})}).catch(i)});return w(r,e),r}function Sr(e){return new m(function(t,r){e.transaction(function(o){o.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\",[],function(i,n){for(var f=[],u=0;u<n.rows.length;u++)f.push(n.rows.item(u).name);t({db:e,storeNames:f})},function(i,n){r(n)})},function(o){r(o)})})}function Ar(e,t){t=q.apply(this,arguments);var r=this.config();e=typeof e!=\"function\"&&e||{},e.name||(e.name=e.name||r.name,e.storeName=e.storeName||r.storeName);var o=this,i;return e.name?i=new m(function(n){var f;e.name===r.name?f=o._dbInfo.db:f=openDatabase(e.name,\"\",\"\",0),e.storeName?n({db:f,storeNames:[e.storeName]}):n(Sr(f))}).then(function(n){return new m(function(f,u){n.db.transaction(function(c){function l(T){return new m(function(x,V){c.executeSql(\"DROP TABLE IF EXISTS \"+T,[],function(){x()},function(W,X){V(X)})})}for(var d=[],y=0,A=n.storeNames.length;y<A;y++)d.push(l(n.storeNames[y]));m.all(d).then(function(){f()}).catch(function(T){u(T)})},function(c){u(c)})})}):i=m.reject(\"Invalid arguments\"),w(i,t),i}var Rr={_driver:\"webSQLStorage\",_initStorage:mr,_support:lr(),iterate:pr,getItem:yr,setItem:gr,removeItem:br,clear:_r,length:wr,key:Er,keys:Ir,dropInstance:Ar};function Dr(){try{return typeof localStorage!=\"undefined\"&&\"setItem\"in localStorage&&!!localStorage.setItem}catch{return!1}}function je(e,t){var r=e.name+\"/\";return e.storeName!==t.storeName&&(r+=e.storeName+\"/\"),r}function Nr(){var e=\"_localforage_support_test\";try{return localStorage.setItem(e,!0),localStorage.removeItem(e),!1}catch{return!0}}function Tr(){return!Nr()||localStorage.length>0}function Br(e){var t=this,r={};if(e)for(var o in e)r[o]=e[o];return r.keyPrefix=je(e,t._defaultConfig),Tr()?(t._dbInfo=r,r.serializer=Ee,m.resolve()):m.reject()}function xr(e){var t=this,r=t.ready().then(function(){for(var o=t._dbInfo.keyPrefix,i=localStorage.length-1;i>=0;i--){var n=localStorage.key(i);n.indexOf(o)===0&&localStorage.removeItem(n)}});return w(r,e),r}function Or(e,t){var r=this;e=z(e);var o=r.ready().then(function(){var i=r._dbInfo,n=localStorage.getItem(i.keyPrefix+e);return n&&(n=i.serializer.deserialize(n)),n});return w(o,t),o}function Cr(e,t){var r=this,o=r.ready().then(function(){for(var i=r._dbInfo,n=i.keyPrefix,f=n.length,u=localStorage.length,c=1,l=0;l<u;l++){var d=localStorage.key(l);if(d.indexOf(n)===0){var y=localStorage.getItem(d);if(y&&(y=i.serializer.deserialize(y)),y=e(y,d.substring(f),c++),y!==void 0)return y}}});return w(o,t),o}function Lr(e,t){var r=this,o=r.ready().then(function(){var i=r._dbInfo,n;try{n=localStorage.key(e)}catch{n=null}return n&&(n=n.substring(i.keyPrefix.length)),n});return w(o,t),o}function Pr(e){var t=this,r=t.ready().then(function(){for(var o=t._dbInfo,i=localStorage.length,n=[],f=0;f<i;f++){var u=localStorage.key(f);u.indexOf(o.keyPrefix)===0&&n.push(u.substring(o.keyPrefix.length))}return n});return w(r,e),r}function Mr(e){var t=this,r=t.keys().then(function(o){return o.length});return w(r,e),r}function Fr(e,t){var r=this;e=z(e);var o=r.ready().then(function(){var i=r._dbInfo;localStorage.removeItem(i.keyPrefix+e)});return w(o,t),o}function Ur(e,t,r){var o=this;e=z(e);var i=o.ready().then(function(){t===void 0&&(t=null);var n=t;return new m(function(f,u){var c=o._dbInfo;c.serializer.serialize(t,function(l,d){if(d)u(d);else try{localStorage.setItem(c.keyPrefix+e,l),f(n)}catch(y){(y.name===\"QuotaExceededError\"||y.name===\"NS_ERROR_DOM_QUOTA_REACHED\")&&u(y),u(y)}})})});return w(i,r),i}function Yr(e,t){if(t=q.apply(this,arguments),e=typeof e!=\"function\"&&e||{},!e.name){var r=this.config();e.name=e.name||r.name,e.storeName=e.storeName||r.storeName}var o=this,i;return e.name?i=new m(function(n){e.storeName?n(je(e,o._defaultConfig)):n(e.name+\"/\")}).then(function(n){for(var f=localStorage.length-1;f>=0;f--){var u=localStorage.key(f);u.indexOf(n)===0&&localStorage.removeItem(u)}}):i=m.reject(\"Invalid arguments\"),w(i,t),i}var zr={_driver:\"localStorageWrapper\",_initStorage:Br,_support:Dr(),iterate:Cr,getItem:Or,setItem:Ur,removeItem:Fr,clear:xr,length:Mr,key:Lr,keys:Pr,dropInstance:Yr},Wr=function(t,r){return t===r||typeof t==\"number\"&&typeof r==\"number\"&&isNaN(t)&&isNaN(r)},Kr=function(t,r){for(var o=t.length,i=0;i<o;){if(Wr(t[i],r))return!0;i++}return!1},Xe=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"},le={},Qe={},ue={INDEXEDDB:cr,WEBSQL:Rr,LOCALSTORAGE:zr},Hr=[ue.INDEXEDDB._driver,ue.WEBSQL._driver,ue.LOCALSTORAGE._driver],me=[\"dropInstance\"],Ie=[\"clear\",\"getItem\",\"iterate\",\"key\",\"keys\",\"length\",\"removeItem\",\"setItem\"].concat(me),Vr={description:\"\",driver:Hr.slice(),name:\"localforage\",size:4980736,storeName:\"keyvaluepairs\",version:1};function Gr(e,t){e[t]=function(){var r=arguments;return e.ready().then(function(){return e[t].apply(e,r)})}}function Se(){for(var e=1;e<arguments.length;e++){var t=arguments[e];if(t)for(var r in t)t.hasOwnProperty(r)&&(Xe(t[r])?arguments[0][r]=t[r].slice():arguments[0][r]=t[r])}return arguments[0]}var jr=function(){function e(t){Y(this,e);for(var r in ue)if(ue.hasOwnProperty(r)){var o=ue[r],i=o._driver;this[r]=i,le[i]||this.defineDriver(o)}this._defaultConfig=Se({},Vr),this._config=Se({},this._defaultConfig,t),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return e.prototype.config=function(r){if((typeof r==\"undefined\"?\"undefined\":C(r))===\"object\"){if(this._ready)return new Error(\"Can't call config() after localforage has been used.\");for(var o in r){if(o===\"storeName\"&&(r[o]=r[o].replace(/\\W/g,\"_\")),o===\"version\"&&typeof r[o]!=\"number\")return new Error(\"Database version must be a number.\");this._config[o]=r[o]}return\"driver\"in r&&r.driver?this.setDriver(this._config.driver):!0}else return typeof r==\"string\"?this._config[r]:this._config},e.prototype.defineDriver=function(r,o,i){var n=new m(function(f,u){try{var c=r._driver,l=new Error(\"Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver\");if(!r._driver){u(l);return}for(var d=Ie.concat(\"_initStorage\"),y=0,A=d.length;y<A;y++){var T=d[y],x=!Kr(me,T);if((x||r[T])&&typeof r[T]!=\"function\"){u(l);return}}var V=function(){for(var de=function(Jr){return function(){var $r=new Error(\"Method \"+Jr+\" is not implemented by the current driver\"),Je=m.reject($r);return w(Je,arguments[arguments.length-1]),Je}},Ae=0,Qr=me.length;Ae<Qr;Ae++){var Re=me[Ae];r[Re]||(r[Re]=de(Re))}};V();var W=function(de){le[c]&&console.info(\"Redefining LocalForage driver: \"+c),le[c]=r,Qe[c]=de,f()};\"_support\"in r?r._support&&typeof r._support==\"function\"?r._support().then(W,u):W(!!r._support):W(!0)}catch(X){u(X)}});return N(n,o,i),n},e.prototype.driver=function(){return this._driver||null},e.prototype.getDriver=function(r,o,i){var n=le[r]?m.resolve(le[r]):m.reject(new Error(\"Driver not found.\"));return N(n,o,i),n},e.prototype.getSerializer=function(r){var o=m.resolve(Ee);return N(o,r),o},e.prototype.ready=function(r){var o=this,i=o._driverSet.then(function(){return o._ready===null&&(o._ready=o._initDriver()),o._ready});return N(i,r,r),i},e.prototype.setDriver=function(r,o,i){var n=this;Xe(r)||(r=[r]);var f=this._getSupportedDrivers(r);function u(){n._config.driver=n.driver()}function c(y){return n._extend(y),u(),n._ready=n._initStorage(n._config),n._ready}function l(y){return function(){var A=0;function T(){for(;A<y.length;){var x=y[A];return A++,n._dbInfo=null,n._ready=null,n.getDriver(x).then(c).catch(T)}u();var V=new Error(\"No available storage method found.\");return n._driverSet=m.reject(V),n._driverSet}return T()}}var d=this._driverSet!==null?this._driverSet.catch(function(){return m.resolve()}):m.resolve();return this._driverSet=d.then(function(){var y=f[0];return n._dbInfo=null,n._ready=null,n.getDriver(y).then(function(A){n._driver=A._driver,u(),n._wrapLibraryMethodsWithReady(),n._initDriver=l(f)})}).catch(function(){u();var y=new Error(\"No available storage method found.\");return n._driverSet=m.reject(y),n._driverSet}),N(this._driverSet,o,i),this._driverSet},e.prototype.supports=function(r){return!!Qe[r]},e.prototype._extend=function(r){Se(this,r)},e.prototype._getSupportedDrivers=function(r){for(var o=[],i=0,n=r.length;i<n;i++){var f=r[i];this.supports(f)&&o.push(f)}return o},e.prototype._wrapLibraryMethodsWithReady=function(){for(var r=0,o=Ie.length;r<o;r++)Gr(this,Ie[r])},e.prototype.createInstance=function(r){return new e(r)},e}(),Xr=new jr;M.exports=Xr},{\"3\":3}]},{},[4])(4)})});var rr=es_$e((ye,er)=>{(function(p,g){typeof ye==\"object\"&&typeof er!=\"undefined\"?g(ye):typeof define==\"function\"&&define.amd?define(\"localforage-driver-memory\",[\"exports\"],g):g(p.LocalforageDriverMemory={})})(typeof self!=\"undefined\"?self:ye,function(p){\"use strict\";var g=\"localforage-driver-memory\";function O(a){var s=typeof Symbol==\"function\"&&a[Symbol.iterator],v=0;return s?s.call(a):{next:function(){return a&&v>=a.length&&(a=void 0),{value:a&&a[v++],done:!a}}}}function L(a,s){a=a||[],s=s||{};try{return new Blob(a,s)}catch(E){if(E.name!==\"TypeError\")throw E;for(var v=typeof BlobBuilder!=\"undefined\"?BlobBuilder:typeof MSBlobBuilder!=\"undefined\"?MSBlobBuilder:typeof MozBlobBuilder!=\"undefined\"?MozBlobBuilder:WebKitBlobBuilder,b=new v,_=0;_<a.length;_+=1)b.append(a[_]);return b.getBlob(s.type)}}var M=/^~~local_forage_type~([^~]+)~/,Q=\"__lfsc__:\".length,C=Q+\"arbf\".length,Y=Object.prototype.toString;function S(a){var s=a.length*.75,v=a.length;a[a.length-1]===\"=\"&&(s--,a[a.length-2]===\"=\"&&s--);for(var b=new ArrayBuffer(s),_=new Uint8Array(b),E=0,D=0;E<v;E+=4){var G=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E]),fe=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E+1]),ie=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E+2]),ce=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E+3]);_[D++]=G<<2|fe>>4,_[D++]=(fe&15)<<4|ie>>2,_[D++]=(ie&3)<<6|ce&63}return b}function P(a){for(var s=new Uint8Array(a),v=\"\",b=0;b<s.length;b+=3)v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[s[b]>>2],v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[(s[b]&3)<<4|s[b+1]>>4],v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[(s[b+1]&15)<<2|s[b+2]>>6],v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[s[b+2]&63];return s.length%3===2?v=v.substring(0,v.length-1)+\"=\":s.length%3===1&&(v=v.substring(0,v.length-2)+\"==\"),v}function K(a,s){var v=\"\";if(a&&(v=Y.call(a)),a&&(v===\"[object ArrayBuffer]\"||a.buffer&&Y.call(a.buffer)===\"[object ArrayBuffer]\")){var b=void 0,_=\"__lfsc__:\";a instanceof ArrayBuffer?(b=a,_+=\"arbf\"):(b=a.buffer,v===\"[object Int8Array]\"?_+=\"si08\":v===\"[object Uint8Array]\"?_+=\"ui08\":v===\"[object Uint8ClampedArray]\"?_+=\"uic8\":v===\"[object Int16Array]\"?_+=\"si16\":v===\"[object Uint16Array]\"?_+=\"ur16\":v===\"[object Int32Array]\"?_+=\"si32\":v===\"[object Uint32Array]\"?_+=\"ui32\":v===\"[object Float32Array]\"?_+=\"fl32\":v===\"[object Float64Array]\"?_+=\"fl64\":s(new Error(\"Failed to get type for BinaryArray\"))),s(_+P(b))}else if(v===\"[object Blob]\"){var E=new FileReader;E.onload=function(){var D=\"~~local_forage_type~\"+a.type+\"~\"+P(this.result);s(\"__lfsc__:blob\"+D)},E.readAsArrayBuffer(a)}else try{s(JSON.stringify(a))}catch(D){console.error(\"Couldn't convert value into a JSON string: \",a),s(null,D)}}function Z(a){if(a.substring(0,Q)!==\"__lfsc__:\")return JSON.parse(a);var s=a.substring(C),v=a.substring(Q,C),b;if(v===\"blob\"&&M.test(s)){var _=s.match(M);b=_[1],s=s.substring(_[0].length)}var E=S(s);switch(v){case\"arbf\":return E;case\"blob\":return L([E],{type:b});case\"si08\":return new Int8Array(E);case\"ui08\":return new Uint8Array(E);case\"uic8\":return new Uint8ClampedArray(E);case\"si16\":return new Int16Array(E);case\"ur16\":return new Uint16Array(E);case\"si32\":return new Int32Array(E);case\"ui32\":return new Uint32Array(E);case\"fl32\":return new Float32Array(E);case\"fl64\":return new Float64Array(E);default:throw new Error(\"Unkown type: \"+v)}}function m(a){var s,v;if(a===null||typeof a!=\"object\"||\"isActiveClone\"in a)return a;var b=a instanceof Date?new Date(a):a.constructor();try{for(var _=O(Object.keys(a)),E=_.next();!E.done;E=_.next()){var D=E.value;Object.prototype.hasOwnProperty.call(a,D)&&(a.isActiveClone=null,b[D]=m(a[D]),delete a.isActiveClone)}}catch(G){s={error:G}}finally{try{E&&!E.done&&(v=_.return)&&v.call(_)}finally{if(s)throw s.error}}return b}function w(a,s){return(a.name||s.name)+\"/\"+(a.storeName||s.storeName)+\"/\"}function N(a,s){s&&a.then(function(v){s(null,v)},function(v){s(v)})}function z(){for(var a=[],s=0;s<arguments.length;s++)a[s]=arguments[s];if(arguments.length&&typeof arguments[arguments.length-1]==\"function\")return arguments[arguments.length-1]}function q(a,s){var v=this;if(s=z.apply(this,arguments),a=typeof a!=\"function\"&&a||{},!a.name){var b=this.config();a.name=a.name||b.name,a.storeName=a.storeName||b.storeName}var _;return a.name?_=new Promise(function(E){a.storeName?E(w(a,v._defaultConfig)):E(a.name+\"/\")}):_=Promise.reject(\"Invalid arguments\"),{promise:_,callback:s}}function F(a){return typeof a!=\"string\"&&(console.warn(a+\" used as a key, but it is not a string.\"),a=String(a)),a}var k={bufferToString:P,deserialize:Z,serialize:K,stringToBuffer:S},U={},ae=function(){function a(s){this.kp=s,this.data={}}return a.resolve=function(s){return U[s]||(U[s]=new a(s)),U[s]},a.prototype.clear=function(){this.data={}},a.prototype.drop=function(){this.clear(),delete U[this.kp]},a.prototype.get=function(s){return this.data[s]},a.prototype.key=function(s){return this.keys()[s]},a.prototype.keys=function(){return Object.keys(this.data)},a.prototype.rm=function(s){delete this.data[s]},a.prototype.set=function(s,v){this.data[s]=v},a}();function re(a){var s=a?m(a):{},v=w(s,this._defaultConfig),b=ae.resolve(v);return this._dbInfo=s,this._dbInfo.serializer=k,this._dbInfo.keyPrefix=v,this._dbInfo.mStore=b,Promise.resolve()}function h(a){var s=this,v=this.ready().then(function(){s._dbInfo.mStore.clear()});return N(v,a),v}function R(a,s){var v=q.apply(this,arguments),b=v.promise,_=v.callback,E=b.then(function(D){ae.resolve(D).drop()});return N(E,_),b}function I(a,s){var v=this;a=F(a);var b=this.ready().then(function(){var _=v._dbInfo.mStore.get(a);return _==null?null:v._dbInfo.serializer.deserialize(_)});return N(b,s),b}function B(a,s){var v=this,b=this.ready().then(function(){for(var _=v._dbInfo.mStore,E=_.keys(),D=0;D<E.length;D++){var G=_.get(E[D]);if(G&&(G=v._dbInfo.serializer.deserialize(G)),G=a(G,E[D],D+1),G!==void 0)return G}});return N(b,s),b}function H(a,s){var v=this,b=this.ready().then(function(){var _;try{_=v._dbInfo.mStore.key(a),_===void 0&&(_=null)}catch{_=null}return _});return N(b,s),b}function j(a){var s=this,v=this.ready().then(function(){return s._dbInfo.mStore.keys()});return N(v,a),v}function J(a){var s=this.keys().then(function(v){return v.length});return N(s,a),s}function $(a,s){var v=this;a=F(a);var b=this.ready().then(function(){v._dbInfo.mStore.rm(a)});return N(b,s),b}function ee(a,s,v){var b=this;a=F(a);var _=this.ready().then(function(){s===void 0&&(s=null);var E=s;return new Promise(function(D,G){b._dbInfo.serializer.serialize(s,function(fe,ie){if(ie)G(ie);else try{b._dbInfo.mStore.set(a,fe),D(E)}catch(ce){G(ce)}})})});return N(_,v),_}var oe=!0;p._support=oe,p._driver=g,p._initStorage=re,p.clear=h,p.dropInstance=R,p.getItem=I,p.iterate=B,p.key=H,p.keys=j,p.length=J,p.removeItem=$,p.setItem=ee,Object.defineProperty(p,\"__esModule\",{value:!0})})});var es_pe=es_Ze(es_ke()),es_Be=es_Ze(rr());var es_ft={display:\"none\",position:\"fixed\",top:\"0\",right:\"0\",width:\"100%\",height:\"100%\",borderRadius:\"0\",border:\"none\",zIndex:\"2147483647\"};function es_ut(p){for(let[g,O]of Object.entries(es_ft))p.style[g]=O}function es_st(p){let g=[].slice.call(document.querySelectorAll(\".magic-iframe\"));return Boolean(g.find(O=>O.src.includes(p)))}var es_Te=class extends gt{constructor(){super(...arguments);this.activeElement=null}init(){this.test=\"hello\",this.iframe=new Promise(g=>{let O=()=>{if(es_st(encodeURIComponent(this.parameters)))pr().log();else{let L=document.createElement(\"iframe\");L.classList.add(\"magic-iframe\"),L.dataset.magicIframeLabel=Ie(this.endpoint).host,L.title=\"Secure Modal\",L.src=Ie(`/send?params=${encodeURIComponent(this.parameters)}`,this.endpoint).href,es_ut(L),document.body.appendChild(L),g(L)}};[\"loaded\",\"interactive\",\"complete\"].includes(document.readyState)?O():window.addEventListener(\"load\",O,!1)}),window.addEventListener(\"message\",g=>{var O;if(g.origin===this.endpoint&&g.data&&g.data.msgType&&this.messageHandlers.size){g.data.response=(O=g.data.response)!=null?O:{};for(let L of this.messageHandlers.values())L(g)}})}showOverlay(){return es_se(this,null,function*(){let g=yield this.iframe;g.style.display=\"block\",this.activeElement=document.activeElement,g.focus()})}hideOverlay(){return es_se(this,null,function*(){var O;let g=yield this.iframe;g.style.display=\"none\",((O=this.activeElement)==null?void 0:O.focus)&&this.activeElement.focus(),this.activeElement=null})}_post(g){return es_se(this,null,function*(){let O=yield this.iframe;if(O&&O.contentWindow)O.contentWindow.postMessage(g,this.endpoint);else throw lr()})}};var es_t=Tn(be,{platform:\"web\",sdkName:\"magic-sdk\",version:\"11.0.0\",defaultEndpoint:\"https://auth.magic.link/\",ViewController:es_Te,configureStorage:()=>es_se(void 0,null,function*(){let p=es_pe.default.createInstance({name:\"MagicAuthLocalStorageDB\",storeName:\"MagicAuthLocalStorage\"});return yield p.defineDriver(es_Be),yield p.setDriver([es_pe.default.INDEXEDDB,es_pe.default.LOCALSTORAGE,es_Be._driver]),p})});\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@magic-ext/connect/dist/es/index.mjs\nvar s=(t=>(t.GetWalletInfo=\"mc_get_wallet_info\",t.ShowWallet=\"mc_wallet\",t.RequestUserInfo=\"mc_request_user_info\",t.Disconnect=\"mc_disconnect\",t))(s||{});var es_l=class extends S.Internal{constructor(){super(...arguments);this.name=\"connect\";this.config={mc:!0}}getWalletInfo(){let e=this.utils.createJsonRpcRequestPayload(\"mc_get_wallet_info\");return this.request(e)}showWallet(){let e=this.utils.createJsonRpcRequestPayload(\"mc_wallet\");return this.request(e)}requestUserInfo(e){let n=this.utils.createJsonRpcRequestPayload(\"mc_request_user_info\",e?[e]:[]);return this.request(n)}disconnect(){let e=this.utils.createJsonRpcRequestPayload(\"mc_disconnect\");return this.request(e)}};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./src/wallet/MagicWeb3Connector.ts\nvar MagicWeb3Connector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/* global window */\r\n\r\n\r\n\r\n\r\n\r\nclass MagicWeb3Connector extends wallet_AbstractWeb3Connector {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'MagicLink';\r\n        this.ether = null;\r\n        this.deactivate = () => MagicWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            this.unsubscribeToEvents(this.provider);\r\n            if (this.magic) {\r\n                yield this.magic.connect.disconnect().catch((e) => {\r\n                    console.error('error to disconnect:', e);\r\n                });\r\n            }\r\n            this.account = null;\r\n            this.chainId = null;\r\n            this.provider = null;\r\n        });\r\n    }\r\n    activate() {\r\n        return MagicWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = App.Network;\r\n            let network = { rpcUrl: networkInfo.RpcUrl, chainId: networkInfo.ChainId };\r\n            this.magic = new es_t('pk_live_EA9DDC458FE21B24', {\r\n                extensions: [new es_l()],\r\n                network: network\r\n            });\r\n            this.ether = new Web3Provider(this.magic.rpcProvider);\r\n            let accounts = yield this.ether.listAccounts();\r\n            // Assign Constants\r\n            this.account = accounts[0];\r\n            this.provider = this.ether.provider;\r\n            this.chainId = networkInfo.ChainId;\r\n            this.subscribeToEvents(this.provider);\r\n            return {\r\n                provider: this.provider,\r\n                account: this.account,\r\n                chainId: this.chainId,\r\n                ether: this.ether,\r\n                magic: this.magic,\r\n                signer: this.ether.getSigner()\r\n            };\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/enums/WalletType.ts\nvar WalletType;\r\n(function (WalletType) {\r\n    WalletType[\"Metamask\"] = \"metamask\";\r\n    WalletType[\"WalletConnect\"] = \"walletConnect\";\r\n    WalletType[\"CoinbaseWallet\"] = \"coinbase\";\r\n    WalletType[\"Web3Auth\"] = \"web3Auth\";\r\n    WalletType[\"MagicLink\"] = \"MagicLink\";\r\n    WalletType[\"Unknown\"] = \"unknown\";\r\n})(WalletType || (WalletType = {}));\r\n\n;// CONCATENATED MODULE: ./src/wallet/ProviderInfo.ts\n\r\nclass ProviderInfo {\r\n    constructor(web3Provider) {\r\n        this.ProviderName = 'unknown';\r\n        this.WalletName = '';\r\n        this.WalletUrl = '';\r\n        this.WalletType = WalletType.Unknown;\r\n        this.UserAddress = '';\r\n        this.InternalWallet = false;\r\n        if (!web3Provider || !web3Provider.provider)\r\n            return;\r\n        this.web3Provider = web3Provider;\r\n        if (this.web3Provider.connection && this.web3Provider.connection.url == 'metamask') {\r\n            this.loadMetamask(web3Provider);\r\n        }\r\n        else if (this.web3Provider.provider.wc) {\r\n            this.loadWalletConnect(web3Provider);\r\n        }\r\n        else if (this.web3Provider.provider.isMagic) {\r\n            this.loadMagicConnect(web3Provider);\r\n        }\r\n        else {\r\n            this.loadCustom(web3Provider);\r\n        }\r\n        ProviderInfo.Instance = this;\r\n    }\r\n    loadMetamask(walletConnectionInfo) {\r\n        this.ProviderName = 'metamask';\r\n        this.WalletName = \"Metamask\";\r\n        this.WalletUrl = 'https://metamask.io/';\r\n        this.WalletType = WalletType.Metamask;\r\n        this.UserAddress = walletConnectionInfo.provider.selectedAddress;\r\n    }\r\n    loadWalletConnect(walletConnectionInfo) {\r\n        var _a;\r\n        let wc = walletConnectionInfo.provider.wc;\r\n        this.ProviderName = \"walletConnect\";\r\n        this.WalletName = wc._peerMeta.name;\r\n        this.WalletUrl = (_a = wc._peerMeta.url) !== null && _a !== void 0 ? _a : '';\r\n        this.WalletType = WalletType.WalletConnect;\r\n    }\r\n    loadCustom(provider) {\r\n        this.ProviderName = 'web3auth';\r\n        this.WalletName = 'Torus';\r\n        this.WalletUrl = 'https://app.tor.us/';\r\n        this.WalletType = WalletType.Web3Auth;\r\n    }\r\n    loadMagicConnect(walletConnectionInfo) {\r\n        this.ProviderName = 'MagicLink';\r\n        this.WalletName = 'MagicLink';\r\n        this.WalletType = WalletType.MagicLink;\r\n        this.InternalWallet = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/dto/User.ts\n\r\n\r\nclass User {\r\n    constructor(provider, address, chainId, ether) {\r\n        this._token = '';\r\n        this.isLoggedIn = false;\r\n        this.provider = provider;\r\n        this.address = address;\r\n        this.chainId = chainId;\r\n        this.ether = ether;\r\n        this.providerInfo = new ProviderInfo(provider);\r\n        this.email = '';\r\n        let cookieHelper = new CookieHelper();\r\n        this._token = cookieHelper.getCookieValue('token');\r\n    }\r\n    get token() {\r\n        return this._token;\r\n    }\r\n    set token(value) {\r\n        this._token = value;\r\n    }\r\n    setValidate(validate) {\r\n        let base64 = btoa(JSON.stringify(validate));\r\n        let cookieHelper = new CookieHelper();\r\n        cookieHelper.setCookie('validate', base64);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/bignumber.js/bignumber.mjs\n/*\r\n *      bignumber.js v9.1.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  bignumber_MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > bignumber_MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, P.lt);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, P.gt);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // THe index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne;\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  function maxOrMin(args, method) {\r\n    var n,\r\n      i = 1,\r\n      m = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      n = new BigNumber(args[i]);\r\n\r\n      // If any number is NaN, return NaN.\r\n      if (!n.s) {\r\n        m = n;\r\n        break;\r\n      } else if (method.call(m, n)) {\r\n        m = n;\r\n      }\r\n    }\r\n\r\n    return m;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = n / pows10[d - j - 1] % 10 | 0;\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return 0, else return Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return Infinity if either is Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return 0 if either is 0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return Infinity if either Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -bignumber_MAX_SAFE_INTEGER, bignumber_MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nvar bignumber_BigNumber = clone();\r\n\r\n/* harmony default export */ const bignumber = (bignumber_BigNumber);\r\n\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js\n\n\n\n\nconst fixednumber_logger = new Logger(bignumber_lib_esm_version_version);\n\nconst fixednumber_constructorGuard = {};\nconst fixednumber_Zero = BigNumber.from(0);\nconst fixednumber_NegativeOne = BigNumber.from(-1);\nfunction fixednumber_throwFault(message, fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value !== undefined) {\n        params.value = value;\n    }\n    return fixednumber_logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\n}\n// Constant to pull zeros from for multipliers\nlet zeros = \"0\";\nwhile (zeros.length < 256) {\n    zeros += zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getMultiplier(decimals) {\n    if (typeof (decimals) !== \"number\") {\n        try {\n            decimals = BigNumber.from(decimals).toNumber();\n        }\n        catch (e) { }\n    }\n    if (typeof (decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n        return (\"1\" + zeros.substring(0, decimals));\n    }\n    return fixednumber_logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\n}\nfunction formatFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    // Make sure wei is a big number (convert as necessary)\n    value = BigNumber.from(value);\n    const negative = value.lt(fixednumber_Zero);\n    if (negative) {\n        value = value.mul(fixednumber_NegativeOne);\n    }\n    let fraction = value.mod(multiplier).toString();\n    while (fraction.length < multiplier.length - 1) {\n        fraction = \"0\" + fraction;\n    }\n    // Strip training 0\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n    const whole = value.div(multiplier).toString();\n    if (multiplier.length === 1) {\n        value = whole;\n    }\n    else {\n        value = whole + \".\" + fraction;\n    }\n    if (negative) {\n        value = \"-\" + value;\n    }\n    return value;\n}\nfunction parseFixed(value, decimals) {\n    if (decimals == null) {\n        decimals = 0;\n    }\n    const multiplier = getMultiplier(decimals);\n    if (typeof (value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\n        fixednumber_logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\n    }\n    // Is it negative?\n    const negative = (value.substring(0, 1) === \"-\");\n    if (negative) {\n        value = value.substring(1);\n    }\n    if (value === \".\") {\n        fixednumber_logger.throwArgumentError(\"missing value\", \"value\", value);\n    }\n    // Split it into a whole and fractional part\n    const comps = value.split(\".\");\n    if (comps.length > 2) {\n        fixednumber_logger.throwArgumentError(\"too many decimal points\", \"value\", value);\n    }\n    let whole = comps[0], fraction = comps[1];\n    if (!whole) {\n        whole = \"0\";\n    }\n    if (!fraction) {\n        fraction = \"0\";\n    }\n    // Trim trailing zeros\n    while (fraction[fraction.length - 1] === \"0\") {\n        fraction = fraction.substring(0, fraction.length - 1);\n    }\n    // Check the fraction doesn't exceed our decimals size\n    if (fraction.length > multiplier.length - 1) {\n        fixednumber_throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\n    }\n    // If decimals is 0, we have an empty string for fraction\n    if (fraction === \"\") {\n        fraction = \"0\";\n    }\n    // Fully pad the string with zeros to get to wei\n    while (fraction.length < multiplier.length - 1) {\n        fraction += \"0\";\n    }\n    const wholeValue = BigNumber.from(whole);\n    const fractionValue = BigNumber.from(fraction);\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\n    if (negative) {\n        wei = wei.mul(fixednumber_NegativeOne);\n    }\n    return wei;\n}\nclass FixedFormat {\n    constructor(constructorGuard, signed, width, decimals) {\n        if (constructorGuard !== fixednumber_constructorGuard) {\n            fixednumber_logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.signed = signed;\n        this.width = width;\n        this.decimals = decimals;\n        this.name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n        this._multiplier = getMultiplier(decimals);\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (value instanceof FixedFormat) {\n            return value;\n        }\n        if (typeof (value) === \"number\") {\n            value = `fixed128x${value}`;\n        }\n        let signed = true;\n        let width = 128;\n        let decimals = 18;\n        if (typeof (value) === \"string\") {\n            if (value === \"fixed\") {\n                // defaults...\n            }\n            else if (value === \"ufixed\") {\n                signed = false;\n            }\n            else {\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n                if (!match) {\n                    fixednumber_logger.throwArgumentError(\"invalid fixed format\", \"format\", value);\n                }\n                signed = (match[1] !== \"u\");\n                width = parseInt(match[2]);\n                decimals = parseInt(match[3]);\n            }\n        }\n        else if (value) {\n            const check = (key, type, defaultValue) => {\n                if (value[key] == null) {\n                    return defaultValue;\n                }\n                if (typeof (value[key]) !== type) {\n                    fixednumber_logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, value[key]);\n                }\n                return value[key];\n            };\n            signed = check(\"signed\", \"boolean\", signed);\n            width = check(\"width\", \"number\", width);\n            decimals = check(\"decimals\", \"number\", decimals);\n        }\n        if (width % 8) {\n            fixednumber_logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\n        }\n        if (decimals > 80) {\n            fixednumber_logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\n        }\n        return new FixedFormat(fixednumber_constructorGuard, signed, width, decimals);\n    }\n}\nclass FixedNumber {\n    constructor(constructorGuard, hex, value, format) {\n        if (constructorGuard !== fixednumber_constructorGuard) {\n            fixednumber_logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new FixedFormat\"\n            });\n        }\n        this.format = format;\n        this._hex = hex;\n        this._value = value;\n        this._isFixedNumber = true;\n        Object.freeze(this);\n    }\n    _checkFormat(other) {\n        if (this.format.name !== other.format.name) {\n            fixednumber_logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n        }\n    }\n    addUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n    }\n    subUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n    }\n    mulUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n    }\n    divUnsafe(other) {\n        this._checkFormat(other);\n        const a = parseFixed(this._value, this.format.decimals);\n        const b = parseFixed(other._value, other.format.decimals);\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n    }\n    floor() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (this.isNegative() && hasFraction) {\n            result = result.subUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    ceiling() {\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        let result = FixedNumber.from(comps[0], this.format);\n        const hasFraction = !comps[1].match(/^(0*)$/);\n        if (!this.isNegative() && hasFraction) {\n            result = result.addUnsafe(ONE.toFormat(result.format));\n        }\n        return result;\n    }\n    // @TODO: Support other rounding algorithms\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // If we are already in range, we're done\n        const comps = this.toString().split(\".\");\n        if (comps.length === 1) {\n            comps.push(\"0\");\n        }\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n            fixednumber_logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\n        }\n        if (comps[1].length <= decimals) {\n            return this;\n        }\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\n        const bump = BUMP.toFormat(this.format);\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\n    }\n    isZero() {\n        return (this._value === \"0.0\" || this._value === \"0\");\n    }\n    isNegative() {\n        return (this._value[0] === \"-\");\n    }\n    toString() { return this._value; }\n    toHexString(width) {\n        if (width == null) {\n            return this._hex;\n        }\n        if (width % 8) {\n            fixednumber_logger.throwArgumentError(\"invalid byte width\", \"width\", width);\n        }\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n        return hexZeroPad(hex, width / 8);\n    }\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    toFormat(format) {\n        return FixedNumber.fromString(this._value, format);\n    }\n    static fromValue(value, decimals, format) {\n        // If decimals looks more like a format, and there is no format, shift the parameters\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\n            format = decimals;\n            decimals = null;\n        }\n        if (decimals == null) {\n            decimals = 0;\n        }\n        if (format == null) {\n            format = \"fixed\";\n        }\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n    }\n    static fromString(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        const numeric = parseFixed(value, fixedFormat.decimals);\n        if (!fixedFormat.signed && numeric.lt(fixednumber_Zero)) {\n            fixednumber_throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\n        }\n        let hex = null;\n        if (fixedFormat.signed) {\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\n        }\n        else {\n            hex = numeric.toHexString();\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\n        }\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(fixednumber_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static fromBytes(value, format) {\n        if (format == null) {\n            format = \"fixed\";\n        }\n        const fixedFormat = FixedFormat.from(format);\n        if (arrayify(value).length > fixedFormat.width / 8) {\n            throw new Error(\"overflow\");\n        }\n        let numeric = BigNumber.from(value);\n        if (fixedFormat.signed) {\n            numeric = numeric.fromTwos(fixedFormat.width);\n        }\n        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\n        return new FixedNumber(fixednumber_constructorGuard, hex, decimal, fixedFormat);\n    }\n    static from(value, format) {\n        if (typeof (value) === \"string\") {\n            return FixedNumber.fromString(value, format);\n        }\n        if (isBytes(value)) {\n            return FixedNumber.fromBytes(value, format);\n        }\n        try {\n            return FixedNumber.fromValue(value, 0, format);\n        }\n        catch (error) {\n            // Allow NUMERIC_FAULT to bubble up\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\n                throw error;\n            }\n        }\n        return fixednumber_logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\n    }\n    static isFixedNumber(value) {\n        return !!(value && value._isFixedNumber);\n    }\n}\nconst ONE = FixedNumber.from(1);\nconst BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/units/lib.esm/_version.js\nconst units_lib_esm_version_version = \"units/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/units/lib.esm/index.js\n\n\n\n\nconst units_lib_esm_logger = new Logger(units_lib_esm_version_version);\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\n// use them.\nfunction commify(value) {\n    const comps = String(value).split(\".\");\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\n        units_lib_esm_logger.throwArgumentError(\"invalid value\", \"value\", value);\n    }\n    // Make sure we have at least one whole digit (0 if none)\n    let whole = comps[0];\n    let negative = \"\";\n    if (whole.substring(0, 1) === \"-\") {\n        negative = \"-\";\n        whole = whole.substring(1);\n    }\n    // Make sure we have at least 1 whole digit with no leading zeros\n    while (whole.substring(0, 1) === \"0\") {\n        whole = whole.substring(1);\n    }\n    if (whole === \"\") {\n        whole = \"0\";\n    }\n    let suffix = \"\";\n    if (comps.length === 2) {\n        suffix = \".\" + (comps[1] || \"0\");\n    }\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\n        suffix = suffix.substring(0, suffix.length - 1);\n    }\n    const formatted = [];\n    while (whole.length) {\n        if (whole.length <= 3) {\n            formatted.unshift(whole);\n            break;\n        }\n        else {\n            const index = whole.length - 3;\n            formatted.unshift(whole.substring(index));\n            whole = whole.substring(0, index);\n        }\n    }\n    return negative + formatted.join(\",\") + suffix;\n}\nfunction formatUnits(value, unitName) {\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return formatFixed(value, (unitName != null) ? unitName : 18);\n}\nfunction parseUnits(value, unitName) {\n    if (typeof (value) !== \"string\") {\n        units_lib_esm_logger.throwArgumentError(\"value must be a string\", \"value\", value);\n    }\n    if (typeof (unitName) === \"string\") {\n        const index = names.indexOf(unitName);\n        if (index !== -1) {\n            unitName = 3 * index;\n        }\n    }\n    return parseFixed(value, (unitName != null) ? unitName : 18);\n}\nfunction formatEther(wei) {\n    return formatUnits(wei, 18);\n}\nfunction parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./src/util/Helper.ts\n\r\n\r\nconst showContainer = function (id) {\r\n    let containers = document.querySelectorAll('.container');\r\n    for (let i = 0; i < containers.length; i++) {\r\n        let element = containers[i];\r\n        if (element.id == id) {\r\n            element.classList.remove('d-none');\r\n            element.style.display = 'block';\r\n        }\r\n        else {\r\n            element.style.display = 'none';\r\n        }\r\n    }\r\n};\r\nconst roundNumber = function (number) {\r\n    return Math.round(number * 100) / 100;\r\n};\r\nconst roundNumberDecimal = function (number, decimal) {\r\n    let hundred = parseInt('1' + '0'.repeat(decimal));\r\n    return Math.round(number * hundred) / hundred;\r\n};\r\nconst formatWeiAsCurrency = function (number) {\r\n    return '$' + formatEther(number.toString());\r\n};\r\nconst formatWei = function (number) {\r\n    return formatEther(number.toString());\r\n};\r\nconst roundBigNumber = function (number) {\r\n    return new bignumber(Math.round(number.toNumber() * 100) / 100);\r\n};\r\nconst roundBigNumberDecimal = function (number, decimal) {\r\n    let hundred = parseInt('1' + '0'.repeat(decimal));\r\n    return new bignumber(Math.round(number.toNumber() * hundred) / hundred);\r\n};\r\nconst Helper_AddressZero = \"0x0000000000000000000000000000000000000000\";\r\nconst isJSON = function (str) {\r\n    try {\r\n        return JSON.parse(str);\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n};\r\nconst ethereumInstalled = function () {\r\n    try {\r\n        return (typeof ethereum !== 'undefined');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n};\r\nconst shortEth = function (ethAddress) {\r\n    if (!ethAddress)\r\n        return '';\r\n    return ethAddress.substring(0, 6) + \"...\" + ethAddress.substring(ethAddress.length - 4);\r\n};\r\nconst upperFirstLetter = function (text) {\r\n    return text[0].toUpperCase() + text.substring(1);\r\n};\r\nconst showBar = function (text) {\r\n    let header = document.querySelector('header');\r\n    if (!header)\r\n        return;\r\n    let warningHtml = '<div class=\"errorBar\">' + text + '</div>';\r\n    header.insertAdjacentHTML('beforebegin', warningHtml);\r\n};\r\n\n;// CONCATENATED MODULE: ./src/services/backend/AuthenticateService.ts\nvar AuthenticateService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AuthenticateService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    static enableWeb3() {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            if (App.User.connector)\r\n                return App.User.connector;\r\n            let magicWeb3Connector = new MagicWeb3Connector();\r\n            let connector = yield magicWeb3Connector.activate();\r\n            App.User.connector = connector;\r\n            App.User.magic = connector.magic;\r\n            App.User.provider = connector.provider;\r\n            App.User.ether = connector.ether;\r\n            App.User.signer = connector.signer;\r\n            return connector;\r\n        });\r\n    }\r\n    logOut() {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            let cookieHelper = new CookieHelper(document);\r\n            cookieHelper.deleteCookie('validate');\r\n            if (!App.User.ether) {\r\n                let connection = yield AuthenticateService.enableWeb3();\r\n                App.User.magic = connection.magic;\r\n            }\r\n            App.User.magic.connect.disconnect();\r\n            App.User = new User(null, '', App.Network.ChainId, '');\r\n        });\r\n    }\r\n    login() {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            let connector = yield AuthenticateService.enableWeb3();\r\n            App.User = new User(connector.provider, connector.account, connector.chainId, connector.ether);\r\n            App.User.magic = connector.magic;\r\n            App.User.signer = connector.signer;\r\n            App.User.isLoggedIn = true;\r\n        });\r\n    }\r\n    isAuthenticated() {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            let cookieHelper = new CookieHelper();\r\n            let validate = cookieHelper.getCookieValue('validate');\r\n            if (!validate)\r\n                return false;\r\n            try {\r\n                let obj = JSON.parse(atob(validate));\r\n                App.User.token = obj.token;\r\n                let result = yield this.post('/me/jwt');\r\n                if (!result.jwt) {\r\n                    yield this.logOut();\r\n                    return false;\r\n                }\r\n                yield AuthenticateService.enableWeb3();\r\n                App.User.address = obj.address;\r\n                App.User.alpacaId = obj.alpacaId;\r\n                App.User.chainId = obj.chainId;\r\n                App.User.isLoggedIn = true;\r\n                return true;\r\n            }\r\n            catch (e) {\r\n                cookieHelper.deleteCookie('validate');\r\n                console.info(e);\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    authenticateUser(enableWeb3Callback, authenticatedCallback) {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            let connector = yield AuthenticateService.enableWeb3();\r\n            if (enableWeb3Callback && connector.provider) {\r\n                enableWeb3Callback(connector.provider);\r\n            }\r\n            if (connector.chainId != App.Network.ChainId) {\r\n                let userNetwork = NetworkInfo.getNetworkInfoByChainId(connector.chainId);\r\n                if (userNetwork) {\r\n                    NetworkInfo.setNetworkByChainId(connector.chainId);\r\n                }\r\n                else {\r\n                    let modal = new SwitchNetworkModal();\r\n                    modal.show();\r\n                    return;\r\n                }\r\n            }\r\n            let response = yield this.post('/me/nonce', { address: connector.account });\r\n            let obj = {\r\n                signingMessage: \"You are logging into Liminal.market.\\n\\nNonce:\" + response.nonce,\r\n                connector: MagicWeb3Connector\r\n            };\r\n            console.log('isWebview', WalletHelper.isWebview());\r\n            // @ts-ignore\r\n            console.log('Ethereum', window.ethereum);\r\n            console.log('connector.ether', connector.ether);\r\n            console.log('network', App.Network);\r\n            // @ts-ignore\r\n            if (window.ethereum) {\r\n                // @ts-ignore\r\n                console.log('Ethereum', window.ethereum.networkVersion, window.ethereum.chainId, App.Network.ChainIdHex);\r\n                if (WalletHelper.isWebview()) {\r\n                }\r\n            }\r\n            console.log('calling signMessage');\r\n            const signedMessage = yield connector.ether.getSigner()\r\n                .signMessage(obj.signingMessage)\r\n                .catch((e) => {\r\n                console.log(e);\r\n                if (e.message && e.message.toLowerCase().indexOf('wrong network') != -1) {\r\n                    showBar('Your wallet is on wrong network. I expect you to be on ' + App.Network.Name + '(chainId:' + App.Network.ChainId + ') network');\r\n                }\r\n                else {\r\n                    showBar('Error signing in:' + e.message);\r\n                }\r\n            });\r\n            if (!signedMessage)\r\n                return;\r\n            let loginResponse = yield this.post('me/validate', { address: connector.account, signedMessage });\r\n            if (!loginResponse.address) {\r\n                yield this.logOut();\r\n                return;\r\n            }\r\n            App.User.setValidate(loginResponse);\r\n            App.User.token = loginResponse.token;\r\n            App.User.alpacaId = loginResponse.alpacaId;\r\n            App.User.address = loginResponse.address;\r\n            App.User.isLoggedIn = true;\r\n            if (authenticatedCallback) {\r\n                authenticatedCallback();\r\n            }\r\n            else {\r\n                location.reload();\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/_version.js\nconst abi_lib_esm_version_version = \"abi/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js\n\n\n\n\n\n\nconst abstract_coder_logger = new Logger(abi_lib_esm_version_version);\nfunction checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nclass Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        abstract_coder_logger.throwArgumentError(message, this.localName, value);\n    }\n}\nclass Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return hexConcat(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            abstract_coder_logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nclass Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                abstract_coder_logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/address.js\n\n\n\n\nclass AddressCoder extends Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, value) {\n        try {\n            value = getAddress(value);\n        }\n        catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js\n\n\n// Clones the functionality of an existing Coder, but without a localName\nclass AnonymousCoder extends Coder {\n    constructor(coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/array.js\n\n\n\nconst array_logger = new Logger(abi_lib_esm_version_version);\n\n\nfunction pack(writer, coders, values) {\n    let arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                array_logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique[name]) {\n                array_logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        array_logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        array_logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nfunction unpack(reader, coders) {\n    let values = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder, index) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        const value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n    return Object.freeze(values);\n}\nclass ArrayCoder extends Coder {\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        this.coder = coder;\n        this.length = length;\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        array_logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                array_logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n//# sourceMappingURL=array.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js\n\n\nclass BooleanCoder extends Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, value) {\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n//# sourceMappingURL=boolean.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js\n\n\n\nclass DynamicBytesCoder extends Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\nclass BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n//# sourceMappingURL=bytes.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js\n\n\n\n// @TODO: Merge this with bytes\nclass FixedBytesCoder extends Coder {\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, value) {\n        let data = arrayify(value);\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/null.js\n\n\nclass NullCoder extends Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes([]);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n//# sourceMappingURL=null.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/number.js\n\n\n\n\nclass NumberCoder extends Coder {\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        this.size = size;\n        this.signed = signed;\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, value) {\n        let v = BigNumber.from(value);\n        // Check bounds are safe for encoding\n        let maxUintValue = bignumbers_MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(bignumbers_One).mul(bignumbers_NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        }\n        else if (v.lt(bignumbers_Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n        return writer.writeValue(v);\n    }\n    decode(reader) {\n        let value = reader.readValue().mask(this.size * 8);\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        return reader.coerce(this.name, value);\n    }\n}\n//# sourceMappingURL=number.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/string.js\n\n\n\nclass StringCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, value) {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n    decode(reader) {\n        return toUtf8String(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js\n\n\n\nclass TupleCoder extends Coder {\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, value) {\n        return pack(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n//# sourceMappingURL=tuple.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/fragments.js\n\n\n\n\n\nconst fragments_logger = new Logger(abi_lib_esm_version_version);\n;\nconst fragments_constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        fragments_logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        fragments_logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        fragments_logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        defineReadOnly(object, key, params[key]);\n    }\n}\nconst FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nclass ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== fragments_constructorGuard) {\n            fragments_logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            fragments_logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(fragments_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nclass Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== fragments_constructorGuard) {\n            fragments_logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return fragments_logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return fragments_logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nclass EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            fragments_logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            fragments_logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(fragments_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            fragments_logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    fragments_logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            fragments_logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            fragments_logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                fragments_logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                fragments_logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            fragments_logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            fragments_logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        fragments_logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nclass ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            fragments_logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            fragments_logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            fragments_logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            fragments_logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(fragments_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            fragments_logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nclass FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            fragments_logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            fragments_logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(fragments_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            fragments_logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            fragments_logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                fragments_logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        fragments_logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nclass ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            fragments_logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            fragments_logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(fragments_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = { type: \"error\" };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            fragments_logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        fragments_logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    fragments_logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/abi-coder.js\n\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\nconst abi_coder_logger = new Logger(abi_lib_esm_version_version);\n\n\n\n\n\n\n\n\n\n\n\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nclass AbiCoder {\n    constructor(coerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                abi_coder_logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                abi_coder_logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n        return abi_coder_logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data, allowLoose) {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            abi_coder_logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\nconst defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abi-coder.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abi/lib.esm/interface.js\n\n\n\n\n\n\n\n\n\n\n\n\nconst interface_logger = new Logger(abi_lib_esm_version_version);\n\nclass LogDescription extends Description {\n}\nclass TransactionDescription extends Description {\n}\nclass ErrorDescription extends Description {\n}\nclass Indexed extends Description {\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n}\nconst BuiltinErrors = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [\"string\"], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [\"uint256\"] }\n};\nfunction wrapAccessError(property, error) {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);\n    wrap.error = error;\n    return wrap;\n}\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nclass Interface {\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n        defineReadOnly(this, \"_abiCoder\", getStatic(new.target, \"getAbiCoder\")());\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"errors\", {});\n        defineReadOnly(this, \"events\", {});\n        defineReadOnly(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        interface_logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                interface_logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n    format(format) {\n        if (!format) {\n            format = FormatTypes.full;\n        }\n        if (format === FormatTypes.sighash) {\n            interface_logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n            return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n        return abi;\n    }\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder() {\n        return defaultAbiCoder;\n    }\n    static getAddress(address) {\n        return getAddress(address);\n    }\n    static getSighash(fragment) {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n    static getEventTopic(eventFragment) {\n        return id(eventFragment.format());\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash) {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            interface_logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                interface_logger.throwArgumentError(\"no matching function\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                interface_logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            interface_logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic) {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            interface_logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                interface_logger.throwArgumentError(\"no matching event\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                interface_logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n            return this.events[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            interface_logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash) {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            interface_logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                interface_logger.throwArgumentError(\"no matching error\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                interface_logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n            return this.errors[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            interface_logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment) {\n        if (typeof (fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            }\n            catch (error) {\n                try {\n                    fragment = this.getError(fragment);\n                }\n                catch (_) {\n                    throw error;\n                }\n            }\n        }\n        return getStatic(this.constructor, \"getSighash\")(fragment);\n    }\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return getStatic(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n    _decodeParams(params, data) {\n        return this._abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this._abiCoder.encode(params, values);\n    }\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        const bytes = arrayify(data);\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            interface_logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, \"data\", hexlify(bytes));\n        }\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [])\n        ]));\n    }\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        const bytes = arrayify(data);\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            interface_logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, \"data\", hexlify(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    }\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        let bytes = arrayify(data);\n        let reason = null;\n        let message = \"\";\n        let errorArgs = null;\n        let errorName = null;\n        let errorSignature = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                }\n                catch (error) { }\n                break;\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) {\n                        reason = errorArgs[0];\n                    }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;\n                    }\n                    else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;\n                    }\n                }\n                else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    }\n                    catch (error) { }\n                }\n                break;\n            }\n        }\n        return interface_logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));\n    }\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            interface_logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        let topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return id(value);\n            }\n            else if (param.type === \"bytes\") {\n                return keccak256(hexlify(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            if (param.type.match(/^u?int/)) {\n                value = BigNumber.from(value).toHexString();\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                this._abiCoder.encode([\"address\"], [value]);\n            }\n            return hexZeroPad(hexlify(value), 32);\n        };\n        values.forEach((value, index) => {\n            let param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    interface_logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                interface_logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            interface_logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this._abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment, data, topics) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                interface_logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n        let indexed = [];\n        let nonIndexed = [];\n        let dynamic = [];\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n        let result = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n                }\n                else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n                }\n                else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        result[index] = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }\n                    });\n                }\n                else {\n                    result[param.name] = value;\n                }\n            }\n        });\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${i}`, value); }\n                });\n            }\n        }\n        return Object.freeze(result);\n    }\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx) {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log) {\n        let fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n    parseError(data) {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n    static isInterface(value) {\n        return !!(value && value._isInterface);\n    }\n}\n//# sourceMappingURL=interface.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/contracts/lib.esm/_version.js\nconst contracts_lib_esm_version_version = \"contracts/5.7.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/contracts/lib.esm/index.js\n\nvar contracts_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst contracts_lib_esm_logger = new Logger(contracts_lib_esm_version_version);\n;\n;\n///////////////////////////////\nconst contracts_lib_esm_allowedTransactionKeys = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n        const name = yield nameOrPromise;\n        if (typeof (name) !== \"string\") {\n            contracts_lib_esm_logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return getAddress(name);\n        }\n        catch (error) { }\n        if (!resolver) {\n            contracts_lib_esm_logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            contracts_lib_esm_logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index) => {\n                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(contracts_lib_esm_logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            overrides = shallowCopy(args.pop());\n        }\n        // Make sure the parameter count matches\n        contracts_lib_esm_logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = resolveProperties({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check) => contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n                    if (getAddress(check.signer) !== check.override) {\n                        contracts_lib_esm_logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"overrides.from\"\n                        });\n                    }\n                    return check.override;\n                }));\n            }\n            else {\n                overrides.from = contract.signer.getAddress();\n            }\n        }\n        else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n            //} else {\n            // Contracts without a signer can override \"from\", and if\n            // unspecified the zero address is used\n            //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield resolveProperties({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: (resolveProperties(overrides) || {})\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = accessListify(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = arrayify(data);\n            for (let i = 0; i < bytes.length; i++) {\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                contracts_lib_esm_logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = shallowCopy(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));\n        if (leftovers.length) {\n            contracts_lib_esm_logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(\",\")}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function (...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n            if (!signerOrProvider) {\n                contracts_lib_esm_logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations) => {\n        return wait(confirmations).then((receipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event = deepCopy(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                }\n                catch (e) { }\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = () => { return contract.provider; };\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n                const overrides = shallowCopy(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function (...args) {\n        return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n            if (!contract.signer) {\n                contracts_lib_esm_logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction lib_esm_getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({ listener: listener, once: once });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i) => i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {\n    }\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [event];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics) {\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                contracts_lib_esm_logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        }\n        else {\n            filter.topics = [topic];\n        }\n        super(lib_esm_getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        }\n        catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        }\n        catch (error) {\n            // No matching event\n        }\n    }\n}\nclass BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        }\n        else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else {\n            contracts_lib_esm_logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        defineReadOnly(this, \"callStatic\", {});\n        defineReadOnly(this, \"estimateGas\", {});\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"populateTransaction\", {});\n        defineReadOnly(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                }\n                else {\n                    contracts_lib_esm_logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        defineReadOnly(this, \"_runningEvents\", {});\n        defineReadOnly(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            contracts_lib_esm_logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        }\n        else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            }\n            catch (error) {\n                // Without a provider, we cannot use ENS names\n                contracts_lib_esm_logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                contracts_lib_esm_logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                defineReadOnly(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    defineReadOnly(this, name, this[signature]);\n                }\n            }\n            catch (e) { }\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return getContractAddress(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n            }\n            else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        contracts_lib_esm_logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            contracts_lib_esm_logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n        }\n        const tx = shallowCopy(overrides || {});\n        [\"from\", \"to\"].forEach(function (key) {\n            if (tx[key] == null) {\n                return;\n            }\n            contracts_lib_esm_logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof (signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof (eventName) === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof (topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            }\n            catch (error) { }\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(lib_esm_getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = deepCopy(log);\n        event.removeListener = () => {\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            contracts_lib_esm_logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    }\n                    catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n        if (typeof (fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                contracts_lib_esm_logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        }\n        else {\n            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n        }\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nclass Contract extends BaseContract {\n}\nclass ContractFactory {\n    constructor(contractInterface, bytecode, signer) {\n        let bytecodeHex = null;\n        if (typeof (bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        }\n        else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        }\n        else if (bytecode && typeof (bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        }\n        else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            contracts_lib_esm_logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            contracts_lib_esm_logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!contracts_lib_esm_allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            contracts_lib_esm_logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                contracts_lib_esm_logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        contracts_lib_esm_logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return contracts_lib_esm_awaiter(this, void 0, void 0, function* () {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            contracts_lib_esm_logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = getStatic(this.constructor, \"getContractAddress\")(tx);\n            const contract = getStatic(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            defineReadOnly(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return (this.constructor).getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new (this.constructor)(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            contracts_lib_esm_logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n        if (typeof (compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        }\n        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return getContractAddress(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./src/contracts/localhost-contract-addresses.ts\nclass localhostContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0xA700528a2B9Bd3126c96378b76f2c99f5F0e0F76\";\r\n        this.AUSD_ADDRESS = \"0x7ad1630b2E9F0e5401f220A33B473C7E5551dd3e\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x19d5ABE7854b01960D4911e6536b26F8A38C3a18\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0x12bA221061255c11EA4895C363633bD43F28F9c3\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/mumbai-contract-addresses.ts\nclass mumbaiContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0x9e2B28D9F841300bE3B64e505dEcA36c35250609\";\r\n        this.AUSD_ADDRESS = \"0x38F2B1E9F11937dD276D64521535b15280A7F137\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x6e9C29e416dc9F7A6A03ffebaB3f02Ef62a1baE4\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0xc6B29dfd4FD756EF94b3A3FF7a531F4467BDDA75\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/fuji-contract-addresses.ts\nclass fujiContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0x0594D04FDB5C98Fb7F777a799139424Ae2414AaD\";\r\n        this.AUSD_ADDRESS = \"0xbAc482aE0b0d652854df377be566445984A021ED\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x098A512B017408008a23ECe22843788799CDebFd\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0x77E6A62Be8398B18d2dA81CDB6Eb097bD8132ccB\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/polygon-contract-addresses.ts\nclass polygonContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0xc7dA98E282cc30BD4fe0a7dE38372F876DB577E4\";\r\n        this.AUSD_ADDRESS = \"0x9B780e71C2a8492E805e17616EB878f2e3874E21\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x8B4fc0bcaED76a6569525d8Fe51E57cAd32FDd94\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0x77b54CbF3e1370af13da41196B4d99cd02eBcC44\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/ContractInfo.ts\n\r\n\r\n\r\n\r\n\r\nclass ContractInfo {\r\n    static getContractInfo(networkName) {\r\n        let contractInfos = {\r\n            localhostContractAddresses: localhostContractAddresses, mumbaiContractAddresses: mumbaiContractAddresses, fujiContractAddresses: fujiContractAddresses,\r\n            polygonContractAddresses: polygonContractAddresses\r\n        };\r\n        if (!networkName) {\r\n            networkName = App.Network.Name;\r\n        }\r\n        const contractInfoType = contractInfos[networkName + 'ContractAddresses'];\r\n        return new contractInfoType();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/EventService.ts\n\r\n\r\n\r\nclass EventService {\r\n    constructor() {\r\n        this.lmAbi = [\r\n            {\r\n                \"anonymous\": false,\r\n                \"inputs\": [\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"walletAddress\",\r\n                        \"type\": \"address\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"uint256\",\r\n                        \"name\": \"amount\",\r\n                        \"type\": \"uint256\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"string\",\r\n                        \"name\": \"accountId\",\r\n                        \"type\": \"string\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"string\",\r\n                        \"name\": \"symbol\",\r\n                        \"type\": \"string\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"tokenAddress\",\r\n                        \"type\": \"address\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"spender\",\r\n                        \"type\": \"address\"\r\n                    }\r\n                ],\r\n                \"name\": \"BuyWithAUsd\",\r\n                \"type\": \"event\"\r\n            },\r\n            {\r\n                \"anonymous\": false,\r\n                \"inputs\": [\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"string\",\r\n                        \"name\": \"accountId\",\r\n                        \"type\": \"string\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"walletAddress\",\r\n                        \"type\": \"address\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"aUsdAddress\",\r\n                        \"type\": \"address\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"string\",\r\n                        \"name\": \"symbol\",\r\n                        \"type\": \"string\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"uint256\",\r\n                        \"name\": \"amount\",\r\n                        \"type\": \"uint256\"\r\n                    },\r\n                    {\r\n                        \"indexed\": false,\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"spender\",\r\n                        \"type\": \"address\"\r\n                    }\r\n                ],\r\n                \"name\": \"SellSecurityToken\",\r\n                \"type\": \"event\"\r\n            }\r\n        ];\r\n        this.contracts = ContractInfo.getContractInfo(App.Network.Name);\r\n    }\r\n    subscribeToBuy(hash) {\r\n        this.listen(hash, 'BuyWithAUsd');\r\n    }\r\n    subscribeToSell(hash) {\r\n        this.listen(hash, 'SellSecurityToken');\r\n    }\r\n    listen(hash, eventName) {\r\n        this.store(hash);\r\n        const lmContract = new Contract(this.contracts.LIMINAL_MARKET_ADDRESS, this.lmAbi, App.User.signer);\r\n        let listeners = lmContract.listeners(eventName);\r\n        if (listeners.length > 0) {\r\n            return;\r\n        }\r\n        lmContract.on(eventName, (walletAddress, amount, accountId, symbol, tokenAddress, spender) => {\r\n            console.log(eventName + ' event');\r\n            lmContract.off(eventName, App.User.provider);\r\n            this.remove(hash);\r\n        });\r\n    }\r\n    store(hash) {\r\n        if (!window.localStorage)\r\n            return;\r\n        let hashes = [];\r\n        let obj = window.localStorage.getItem('hashes');\r\n        if (obj) {\r\n            hashes = JSON.parse(obj);\r\n        }\r\n        hashes.push(hash);\r\n        window.localStorage.setItem('hashes', JSON.stringify(hashes));\r\n    }\r\n    remove(hash) {\r\n        if (!window.localStorage)\r\n            return;\r\n        let json = window.localStorage.getItem('hashes');\r\n        if (!json)\r\n            return;\r\n        let hashes = JSON.parse(json);\r\n        let idx = hashes.indexOf(hash);\r\n        hashes.splice(idx, 1);\r\n        if (hashes.length == 0) {\r\n            window.localStorage.removeItem('hashes');\r\n        }\r\n        else {\r\n            window.localStorage.setItem('hashes', JSON.stringify(hashes));\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/BlockchainService.ts\nvar BlockchainService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass BlockchainService extends BaseService {\r\n    constructor() {\r\n        super();\r\n        this.balanceOfAbi = [{\r\n                \"inputs\": [\r\n                    {\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"account\",\r\n                        \"type\": \"address\"\r\n                    }\r\n                ],\r\n                \"name\": \"balanceOf\",\r\n                \"outputs\": [\r\n                    {\r\n                        \"internalType\": \"uint256\",\r\n                        \"name\": \"\",\r\n                        \"type\": \"uint256\"\r\n                    }\r\n                ],\r\n                \"stateMutability\": \"view\",\r\n                \"type\": \"function\"\r\n            }];\r\n        this.transferAbi = [\"function transfer(address to, uint amount)\"];\r\n        this.network = App.Network;\r\n        this.contracts = ContractInfo.getContractInfo(this.network.Name);\r\n    }\r\n    getBalanceOf(tokenAddress, ethAddress) {\r\n        return BlockchainService_awaiter(this, void 0, void 0, function* () {\r\n            yield this.loadEther();\r\n            if (!App.User.ether) {\r\n                return new bignumber(0);\r\n            }\r\n            const contract = new Contract(tokenAddress, this.balanceOfAbi, App.User.ether);\r\n            return yield contract.balanceOf(ethAddress);\r\n        });\r\n    }\r\n    transferInner(tokenAddress, to, qty) {\r\n        return BlockchainService_awaiter(this, void 0, void 0, function* () {\r\n            yield this.loadEther();\r\n            let qtyWei = parseUnits(qty.toString(), 'ether');\r\n            console.log('transferInner', qtyWei.toString(), tokenAddress, to);\r\n            const contract = new Contract(tokenAddress, this.transferAbi, App.User.signer);\r\n            let result = yield contract.transfer(to, qtyWei);\r\n            let eventService = new EventService();\r\n            if (tokenAddress == this.contracts.AUSD_ADDRESS) {\r\n                eventService.subscribeToBuy(result.hash);\r\n            }\r\n            else {\r\n                eventService.subscribeToSell(result.hash);\r\n            }\r\n            console.log('transfer result', result);\r\n            return result;\r\n        });\r\n    }\r\n    loadEther() {\r\n        return BlockchainService_awaiter(this, void 0, void 0, function* () {\r\n            if (App.User.ether)\r\n                return;\r\n            yield AuthenticateService.enableWeb3();\r\n        });\r\n    }\r\n    getNativeBalance() {\r\n        return BlockchainService_awaiter(this, void 0, void 0, function* () {\r\n            const balanceInWei = yield App.User.ether.getBalance(App.User.address);\r\n            const balanceInEther = formatEther(balanceInWei);\r\n            return balanceInEther;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/LiminalMarketService.ts\nvar LiminalMarketService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass LiminalMarketService extends BlockchainService {\r\n    constructor() {\r\n        super();\r\n        this.getSecurityTokenAbi = [{\r\n                \"inputs\": [\r\n                    {\r\n                        \"internalType\": \"string\",\r\n                        \"name\": \"symbol\",\r\n                        \"type\": \"string\"\r\n                    }\r\n                ],\r\n                \"name\": \"getSecurityToken\",\r\n                \"outputs\": [\r\n                    {\r\n                        \"internalType\": \"address\",\r\n                        \"name\": \"\",\r\n                        \"type\": \"address\"\r\n                    }\r\n                ],\r\n                \"stateMutability\": \"view\",\r\n                \"type\": \"function\"\r\n            }];\r\n        this.createTokenAbi = [{\r\n                \"inputs\": [\r\n                    {\r\n                        \"internalType\": \"string\",\r\n                        \"name\": \"symbol\",\r\n                        \"type\": \"string\"\r\n                    }\r\n                ],\r\n                \"name\": \"createToken\",\r\n                \"outputs\": [\r\n                    {\r\n                        \"internalType\": \"contract SecurityToken\",\r\n                        \"name\": \"\",\r\n                        \"type\": \"address\"\r\n                    }\r\n                ],\r\n                \"stateMutability\": \"nonpayable\",\r\n                \"type\": \"function\"\r\n            }];\r\n    }\r\n    getSymbolContractAddress(symbol) {\r\n        return LiminalMarketService_awaiter(this, void 0, void 0, function* () {\r\n            yield this.loadEther();\r\n            const contract = new Contract(this.contracts.LIMINAL_MARKET_ADDRESS, this.getSecurityTokenAbi, App.User.ether);\r\n            return yield contract.getSecurityToken(symbol);\r\n        });\r\n    }\r\n    createToken(symbol, creatingToken) {\r\n        return LiminalMarketService_awaiter(this, void 0, void 0, function* () {\r\n            const contract = new Contract(this.contracts.LIMINAL_MARKET_ADDRESS, this.createTokenAbi, App.User.signer);\r\n            let result = yield contract.createToken(symbol);\r\n            creatingToken();\r\n            console.log('createToken result:', result);\r\n            yield result.wait();\r\n            return yield this.getSymbolContractAddress(symbol);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/SecuritiesList.html\n// Module\nvar SecuritiesList_code = \"<figure>\\r\\n    <table id=\\\"liminal_market_securities_table\\\" role=\\\"grid\\\">\\r\\n    <thead>\\r\\n    <tr>\\r\\n        <th colspan=\\\"2\\\"><input autocomplete=\\\"off\\\" type=\\\"search\\\" id=\\\"search_for_symbol\\\" placeholder=\\\"Search for name or symbol in {{securitiesCount}} stocks\\\"></th>\\r\\n    </tr>\\r\\n    </thead>\\r\\n    <tbody id=\\\"{{tbodyId}}\\\">\\r\\n    {{>securities}}\\r\\n    </tbody>\\r\\n</table>\\r\\n<span id=\\\"liminal_market_load_more\\\"></span>\\r\\n</figure>\";\n// Exports\n/* harmony default export */ const elements_SecuritiesList = (SecuritiesList_code);\n;// CONCATENATED MODULE: ./src/html/elements/Securities.html\n// Module\nvar Securities_code = \"{{#each securities}}\\r\\n<tr data-symbol=\\\"{{{Symbol}}}\\\" data-logo=\\\"{{LogoPath}}{{Logo}}\\\" data-name=\\\"{{Name}}\\\">\\r\\n    <td class=\\\"symbol_logo\\\"><img src=\\\"{{LogoPath}}{{Logo}}\\\"/></td>\\r\\n    <td class=\\\"security_information\\\">\\r\\n        <strong>{{Name}}</strong><br/>\\r\\n        <nav class=\\\"security_extra\\\">\\r\\n            <ul>\\r\\n                <li>\\r\\n                    <a href=\\\"https://strike.market/stocks/{{Symbol}}\\\" target=\\\"_blank\\\">{{Symbol}}</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n            <ul>\\r\\n                <li>\\r\\n                    <a href=\\\"\\\" class=\\\"getAddress\\\" data-symbol=\\\"{{Symbol}}\\\">Get address</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n            <ul>\\r\\n                <li>\\r\\n                    <a href=\\\"\\\" class=\\\"addToWallet\\\" data-symbol=\\\"{{Symbol}}\\\">Add to wallet</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n        </nav>\\r\\n    </td>\\r\\n</tr>\\r\\n{{/each}}\";\n// Exports\n/* harmony default export */ const Securities = (Securities_code);\n;// CONCATENATED MODULE: ./src/util/CopyHelper.ts\nvar CopyHelper_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass CopyHelper {\r\n    fallbackCopyTextToClipboard(text) {\r\n        let textArea = document.createElement(\"textarea\");\r\n        textArea.value = text;\r\n        // Avoid scrolling to bottom\r\n        textArea.style.top = \"0\";\r\n        textArea.style.left = \"0\";\r\n        textArea.style.position = \"fixed\";\r\n        document.body.appendChild(textArea);\r\n        textArea.focus();\r\n        textArea.select();\r\n        try {\r\n            let successful = document.execCommand('copy');\r\n            return successful;\r\n        }\r\n        catch (err) {\r\n            console.error(err);\r\n            return false;\r\n        }\r\n        finally {\r\n            document.body.removeChild(textArea);\r\n        }\r\n    }\r\n    copyTextToClipboard(text) {\r\n        return CopyHelper_awaiter(this, void 0, void 0, function* () {\r\n            if (!navigator.clipboard) {\r\n                return this.fallbackCopyTextToClipboard(text);\r\n            }\r\n            let result = yield navigator.clipboard.writeText(text).then(ble => {\r\n                console.log('ble', ble);\r\n                return true;\r\n            }).\r\n                catch(function (err) {\r\n                console.info(err);\r\n                return false;\r\n            });\r\n            console.log(result);\r\n            return result;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/AddressInfo.html\n// Module\nvar AddressInfo_code = \"<article id=\\\"symbolInfoToCopy\\\">\\r\\n    This is the address for the symbol {{symbol}}.\\r\\n    <br/>\\r\\n    <input value=\\\"{{address}}\\\"/>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const AddressInfo = (AddressInfo_code);\n;// CONCATENATED MODULE: ./src/html/elements/ContractAddressNotFound.html\n// Module\nvar ContractAddressNotFound_code = \"<tr id=\\\"symbolInfoToCopy\\\">\\r\\n    <td colspan=\\\"4\\\">\\r\\n        <article>\\r\\n        This symbol has never been bought and does not exist. Buy this symbol and address will become available.\\r\\n        </article>\\r\\n    </td>\\r\\n</tr>\";\n// Exports\n/* harmony default export */ const ContractAddressNotFound = (ContractAddressNotFound_code);\n;// CONCATENATED MODULE: ./src/html/elements/AddToWallet.html\n// Module\nvar AddToWallet_code = \"<article>\\r\\n    Some wallets detect automatically the coins that are registered to your address.\\r\\n    Those that don't do automatic detection, you need to add them manually.\\r\\n    <br/><br/>\\r\\n    This is the address for the symbol {{symbol}},\\r\\n    you need to copy it and import the token in your wallet\\r\\n    <br/><br/>\\r\\n    Contract address:<br/>\\r\\n    <input value=\\\"{{address}}\\\"/>\\r\\n    Symbol:<br/>\\r\\n    <input value=\\\"{{symbol}}\\\"/>\\r\\n    Decimal:<br/>\\r\\n    <input value=\\\"18\\\"/>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const AddToWallet = (AddToWallet_code);\n;// CONCATENATED MODULE: ./src/ui/elements/InfoBarType.ts\nvar InfoBarType;\r\n(function (InfoBarType) {\r\n    InfoBarType[\"Info\"] = \"infoBar\";\r\n    InfoBarType[\"Warning\"] = \"warningBar\";\r\n    InfoBarType[\"Error\"] = \"errorBar\";\r\n})(InfoBarType || (InfoBarType = {}));\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/InfoBar.ts\n\r\nclass InfoBar {\r\n    static show(message, type, timeoutInSeconds = 4) {\r\n        let infoBar = document.getElementById('infoBar');\r\n        if (!infoBar) {\r\n            infoBar = document.createElement('div');\r\n            infoBar.classList.add('notificationBar');\r\n            infoBar.id = 'infoBar';\r\n            document.body.insertAdjacentElement('afterbegin', infoBar);\r\n        }\r\n        infoBar.innerHTML = message;\r\n        infoBar.classList.remove('hidden');\r\n        infoBar.classList.remove(InfoBarType.Info);\r\n        infoBar.classList.remove(InfoBarType.Warning);\r\n        infoBar.classList.remove(InfoBarType.Error);\r\n        infoBar.classList.add(type);\r\n        if (timeoutInSeconds > 0) {\r\n            setTimeout(() => {\r\n                infoBar === null || infoBar === void 0 ? void 0 : infoBar.classList.add('hidden');\r\n            }, timeoutInSeconds * 1000);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/WalletMissing.html\n// Module\nvar WalletMissing_code = \"\\r\\nYou need to set up a wallet in your browser before you can use liminal.market.\\r\\n<br/><br/>\\r\\nTo make it simple, we would like to suggest two options. In your browser or your phone.\\r\\n<ul>\\r\\n    <li>For the browser we recommend <a href=\\\"https://metamask.io/download/\\\"\\r\\n                                                                         target=\\\"_blank\\\">Metamask</a>.\\r\\n    </li>\\r\\n    <li>\\r\\n        For your phone, we like <a href=\\\"https://www.tokenpocket.pro/en/download/app\\\" target=\\\"_blank\\\">Token Poket</a>\\r\\n    </li>\\r\\n</ul>\\r\\n<br/>\\r\\nBut, you have <a href=\\\"https://ethereum.org/en/wallets/\\\" target=\\\"_blank\\\">many options</a> if you want to learn more.\";\n// Exports\n/* harmony default export */ const WalletMissing = (WalletMissing_code);\n;// CONCATENATED MODULE: ./src/errors/PredefinedErrorHandlers.ts\n\r\n\r\n\r\n\r\n\r\nclass PredefinedErrorHandlers {\r\n    constructor() {\r\n        this.errorMessageMapping = new Map();\r\n        this.SentLoginRequest = \"We have sent request to you wallet to login. Open your wallet to login\";\r\n        this.errorMessageMapping.set('chain not supported', () => {\r\n            let div = 'Network is not supported. <a href=\"\" id=\"switchNetworkLink\">Click me to switch to supported network</a>';\r\n            InfoBar.show(div, InfoBarType.Warning, 120);\r\n            let switchNetworkLink = document.getElementById('switchNetworkLink');\r\n            switchNetworkLink === null || switchNetworkLink === void 0 ? void 0 : switchNetworkLink.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let modal = new SwitchNetworkModal();\r\n                modal.show();\r\n            });\r\n        });\r\n        this.errorMessageMapping.set('already processing eth_requestaccounts', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('request of type \\'wallet_requestPermissions\\' already pending', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('already has been called, but is not finished yet', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('request is already in progress', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('web3 instance', () => {\r\n            let elements = document.querySelectorAll(\".liminal_market_connect_wallet\");\r\n            if (elements.length > 0) {\r\n                elements[0].dispatchEvent(new MouseEvent('click'));\r\n                return;\r\n            }\r\n        });\r\n        this.errorMessageMapping.set('user rejected the request', () => {\r\n            Moralis.User.logOut();\r\n            window.location.reload();\r\n        });\r\n        this.errorMessageMapping.set('Non ethereum enabled browser', () => {\r\n            let modal = new Modal();\r\n            let template = Handlebars.compile(WalletMissing);\r\n            modal.showModal('New to blockchain?', template(null), false, () => {\r\n                //window.location.reload();\r\n            });\r\n        });\r\n    }\r\n    handle(message) {\r\n        let handled = false;\r\n        this.errorMessageMapping.forEach((value, key) => {\r\n            if (!handled && message.toLowerCase().indexOf(key.toLowerCase()) != -1) {\r\n                if (typeof value == 'string') {\r\n                    InfoBar.show(value.toString(), InfoBarType.Warning, 10);\r\n                }\r\n                else {\r\n                    value();\r\n                }\r\n                handled = true;\r\n                return handled;\r\n            }\r\n        });\r\n        return handled;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/ErrorInfo.ts\n\r\n\r\n\r\nclass ErrorInfo {\r\n    constructor(errorInfo) {\r\n        this.errorInfo = errorInfo;\r\n    }\r\n    getErrorInfo() {\r\n        return this.errorInfo;\r\n    }\r\n    static report(error) {\r\n        LoadingHelper.removeLoading();\r\n        if (!error)\r\n            return;\r\n        let errorHandler = new PredefinedErrorHandlers();\r\n        if (errorHandler.handle(error.message)) {\r\n            return;\r\n        }\r\n        if (error.callback) {\r\n            error.callback();\r\n            return;\r\n        }\r\n        if (error) {\r\n            console.error(error.toString());\r\n        }\r\n        //InfoBar.show(error.message, InfoBarType.Error);\r\n    }\r\n    static log(obj) {\r\n        ErrorInfo.report(new GeneralError(obj));\r\n    }\r\n    static info(obj) {\r\n        ErrorInfo.report(new GeneralError(obj));\r\n    }\r\n    static error(obj) {\r\n        console.log(obj);\r\n        ErrorInfo.report(new GeneralError(obj));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/SecuritiesList.ts\nvar SecuritiesList_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SecuritiesList {\r\n    constructor() {\r\n        this.tbodyId = 'liminal_market_securities_list';\r\n        this.onSelectSymbol = undefined;\r\n        this.page = 0;\r\n        this.loadmore = true;\r\n    }\r\n    render() {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            let securitiesCount = securitiesService.securitiesArray.length;\r\n            let securities = yield securitiesService.getPaginatingSecurities(this.page++);\r\n            Handlebars.registerPartial(\"securities\", Securities);\r\n            let template = Handlebars.compile(elements_SecuritiesList);\r\n            let obj = {\r\n                tbodyId: this.tbodyId,\r\n                securities: securities,\r\n                securitiesCount: securitiesCount\r\n            };\r\n            return template(obj);\r\n        });\r\n    }\r\n    bindEvents(onSelectSymbol) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            this.bindOnClickEvent(onSelectSymbol);\r\n            yield this.bindSearchEvent();\r\n            this.bindLoadMore();\r\n        });\r\n    }\r\n    bindOnClickEvent(onSelectSymbol) {\r\n        let table = document.getElementById('liminal_market_securities_table');\r\n        if (!table) {\r\n            ErrorInfo.report(new GeneralError(\"Page could not load correctly, try reloading\"));\r\n            return;\r\n        }\r\n        this.onSelectSymbol = onSelectSymbol;\r\n        table.onclick = (evt) => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            yield this.handleClick(evt);\r\n        });\r\n    }\r\n    handleClick(evt) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let element = evt.target;\r\n            if (element.tagName.toLocaleLowerCase() === 'a') {\r\n                yield this.addToWalletOrGetAddress(evt, element);\r\n                return;\r\n            }\r\n            let parentTr = element.parentElement;\r\n            if (!parentTr)\r\n                return;\r\n            if (parentTr.tagName.toLocaleLowerCase() !== 'tr') {\r\n                parentTr = parentTr.parentElement;\r\n            }\r\n            let symbol = parentTr.dataset.symbol;\r\n            if (!symbol)\r\n                return;\r\n            let name = parentTr.dataset.name;\r\n            let logo = parentTr.dataset.logo;\r\n            if (this.onSelectSymbol) {\r\n                this.onSelectSymbol(symbol, name, logo);\r\n            }\r\n        });\r\n    }\r\n    bindSearchEvent() {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let searchForSymbol = document.getElementById('search_for_symbol');\r\n            if (!searchForSymbol)\r\n                return;\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            let timeout = null;\r\n            searchForSymbol.addEventListener('keyup', (evt) => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n                if (timeout != null)\r\n                    clearTimeout(timeout);\r\n                timeout = setTimeout(() => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n                    let search = evt.target.value;\r\n                    if (!search || search.length < 2) {\r\n                        this.loadmore = true;\r\n                        yield this.showTopSecurities(securitiesService);\r\n                        return;\r\n                    }\r\n                    this.loadmore = false;\r\n                    let securities = yield securitiesService.find(search);\r\n                    this.loadSecuritiesToDom(securities);\r\n                }), 500);\r\n            }));\r\n        });\r\n    }\r\n    showTopSecurities(securitiesService) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let securities = yield securitiesService.getTopSecurities();\r\n            this.loadSecuritiesToDom(securities);\r\n        });\r\n    }\r\n    loadSecuritiesToDom(securities) {\r\n        let tbody = document.getElementById(this.tbodyId);\r\n        if (!tbody)\r\n            return;\r\n        let template = Handlebars.compile(Securities);\r\n        let obj = {\r\n            securities: securities\r\n        };\r\n        let content = template(obj);\r\n        tbody.innerHTML = content;\r\n    }\r\n    bindLoadMore() {\r\n        const el = document.querySelector('#liminal_market_load_more');\r\n        const observer = new window.IntersectionObserver(([entry]) => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (entry.isIntersecting) {\r\n                yield this.loadMore();\r\n            }\r\n        }), {\r\n            root: null,\r\n            threshold: 0.1, // set offset 0.1 means trigger if atleast 10% of element in viewport\r\n        });\r\n        observer.observe(el);\r\n    }\r\n    loadMore() {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.loadmore)\r\n                return;\r\n            let tbody = document.getElementById(this.tbodyId);\r\n            if (!tbody)\r\n                return;\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            let securities = yield securitiesService.getPaginatingSecurities(this.page++);\r\n            let template = Handlebars.compile(Securities);\r\n            let obj = {\r\n                securities: securities\r\n            };\r\n            let content = template(obj);\r\n            tbody.insertAdjacentHTML('beforeend', content);\r\n        });\r\n    }\r\n    addToWalletOrGetAddress(event, element) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let className = element.className;\r\n            if (className != 'getAddress' && className != 'addToWallet') {\r\n                return;\r\n            }\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            let symbol = element.dataset.symbol;\r\n            if (!symbol)\r\n                return;\r\n            LoadingHelper.setLoading(element);\r\n            let liminalMarketService = new LiminalMarketService();\r\n            let address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n            if (className == 'getAddress') {\r\n                yield this.showGetAddress(element, symbol, address);\r\n            }\r\n            else {\r\n                yield this.showAddToWallet(element, symbol, address);\r\n            }\r\n            LoadingHelper.removeLoading();\r\n        });\r\n    }\r\n    showGetAddress(element, symbol, address) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (address !== Helper_AddressZero) {\r\n                let copyHelper = new CopyHelper();\r\n                let success = yield copyHelper.copyTextToClipboard(address);\r\n                if (success) {\r\n                    element.innerText = 'Copied';\r\n                    return;\r\n                }\r\n            }\r\n            this.renderContractInfoToString(element, address, symbol, AddressInfo);\r\n        });\r\n    }\r\n    showAddToWallet(element, symbol, address) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (address !== Helper_AddressZero) {\r\n                let walletHelper = new WalletHelper();\r\n                let added = yield walletHelper.addTokenToWallet(address, symbol, () => {\r\n                    LoadingHelper.removeLoading();\r\n                    this.renderContractInfoToString(element, address, symbol, AddToWallet);\r\n                });\r\n                if (added) {\r\n                    return '';\r\n                }\r\n            }\r\n            this.renderContractInfoToString(element, address, symbol, AddToWallet);\r\n        });\r\n    }\r\n    renderContractInfoToString(element, address, symbol, template) {\r\n        let symbolInfoToCopy = document.getElementById('symbolInfoToCopy');\r\n        if (symbolInfoToCopy)\r\n            symbolInfoToCopy.remove();\r\n        let content = '';\r\n        if (address === Helper_AddressZero) {\r\n            let template = Handlebars.compile(ContractAddressNotFound);\r\n            content = template(null);\r\n        }\r\n        else {\r\n            let template = Handlebars.compile(AddressInfo);\r\n            let obj = {\r\n                symbol: symbol,\r\n                address: address\r\n            };\r\n            content = template(obj);\r\n        }\r\n        element.parentElement.parentElement.parentElement.insertAdjacentHTML('afterend', content);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/broker/MarketService.ts\nvar MarketService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass MarketService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    isMarketOpen() {\r\n        return MarketService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.get('isOpen');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/UserService.ts\nvar UserService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass UserService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    isMarketOpenOrUserOffHours() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let marketService = new MarketService();\r\n            let response = yield marketService.isMarketOpen();\r\n            return response.marketIsOpen;\r\n        });\r\n    }\r\n    getUser() {\r\n        let cookieHelper = new CookieHelper(document);\r\n        let signedMessage = cookieHelper.getCookieValue('signedMessage');\r\n        if (!signedMessage) {\r\n            App.User = new User(null, '', App.Network.ChainId, null);\r\n            return App.User;\r\n        }\r\n        const signingAddress = recoverAddress('', signedMessage);\r\n        App.User = new User(null, signingAddress, App.Network.ChainId, null);\r\n        return App.User;\r\n    }\r\n    load(address) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let response = yield fetch('/user', { body: address });\r\n            let json = yield response.json();\r\n        });\r\n    }\r\n    getAlpacaId() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let user = yield this.getUser();\r\n            if (user.alpacaId)\r\n                return user.alpacaId;\r\n            let result = yield fetch('');\r\n            user.alpacaId = result.alpacaId;\r\n            return user.alpacaId;\r\n        });\r\n    }\r\n    getAccount() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.get('account');\r\n        });\r\n    }\r\n    getEthAddress() {\r\n        return App.User.address;\r\n    }\r\n    kycActionRequired() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let kycResults = yield this.get('kycActionRequired');\r\n            return kycResults;\r\n        });\r\n    }\r\n    updateName(given_name, middle_name, family_name) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('updateName', {\r\n                given_name: given_name,\r\n                middle_name: middle_name,\r\n                family_name: family_name\r\n            });\r\n        });\r\n    }\r\n    updateContact(data) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('updateContact', data);\r\n        });\r\n    }\r\n    updateTrustedContact(data) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('updateTrustedContact', data);\r\n        });\r\n    }\r\n    createAchRelationship(account_owner_name, bank_account_type, bank_account_number, bank_routing_number) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('createAchRelationship', {\r\n                account_owner_name, bank_account_type, bank_account_number, bank_routing_number\r\n            });\r\n        });\r\n    }\r\n    getBankRelationship() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.get('getBankRelationship');\r\n        });\r\n    }\r\n    getLatestTransfers(direction) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.get('getTransfers', { direction: direction });\r\n        });\r\n    }\r\n    createTransfer(amount, direction) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('createTransfer', { amount: amount, direction: direction });\r\n        });\r\n    }\r\n    deleteTransfer(id) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('deleteTransfer', { id: id });\r\n        });\r\n    }\r\n    registerWireTransferRelationship(params) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('createWireRelationship', params);\r\n        });\r\n    }\r\n}\r\nUserService.signedMessage = 'signedMessage';\r\n\n;// CONCATENATED MODULE: ./src/html/elements/UserInfo.html\n// Module\nvar UserInfo_code = \"<div id=\\\"userMenuPanel\\\">\\r\\n    <a href=\\\"#\\\" id=\\\"userInfoAction\\\" aria-expanded=\\\"false\\\">\\r\\n        <img src=\\\"https://effigy.im/a/{{ethAddress}}.png\\\" width=\\\"24\\\">\\r\\n        <span id=\\\"user_info_ethAddress\\\">{{shortEthAddress}}</span>\\r\\n    </a>\\r\\n\\r\\n    <div id=\\\"userInfoDropdown\\\" class=\\\"d-none\\\">\\r\\n        <div class=\\\"grid account_info\\\">\\r\\n            <h6>Account</h6>\\r\\n            <a id=\\\"disconnectFromNetwork\\\" href=\\\"#\\\">Disconnect</a>\\r\\n\\r\\n        </div>\\r\\n        <div class=\\\"edit_account\\\">\\r\\n            <a id=\\\"editName\\\" href=\\\"#\\\">Edit name</a><br/>\\r\\n            <a id=\\\"editContact\\\" href=\\\"#\\\">Edit contact info</a><br/>\\r\\n            <a id=\\\"editTrustedContact\\\" href=\\\"#\\\">Edit trusted contact</a>\\r\\n        </div>\\r\\n        <hr/>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <img src=\\\"https://effigy.im/a/{{ethAddress}}.png\\\">\\r\\n            </div>\\r\\n            <div>\\r\\n                <strong class=\\\"d-block\\\"><a href=\\\"{{blockchainExplorer}}{{ethAddress}}\\\" target=\\\"_blank\\\">{{shortEthAddress}}</a></strong>\\r\\n                <br/>\\r\\n                {{#if isMagic}}\\r\\n                <a href=\\\"#\\\" id=\\\"wallet\\\">Open my wallet</a>\\r\\n                {{/if}}\\r\\n                <a href=\\\"https://info.liminal.market/#/chain/{{chainId}}/{{ethAddress}}\\\" target=\\\"_blank\\\">View\\r\\n                    positions</a>\\r\\n            </div>\\r\\n        </div>\\r\\n        <hr/>\\r\\n        <div class=\\\"hidden\\\" id=\\\"userInfoAUsdBalance\\\">\\r\\n            <div class=\\\"grid\\\">\\r\\n                <div><img src=\\\"https://app.liminal.market/img/ausd.png\\\"></div>\\r\\n                <div>\\r\\n                    <strong class=\\\"d-block\\\">aUSD <span id=\\\"user_info_ausd_balance\\\"></span></strong>\\r\\n                    <a href=\\\"\\\" class=\\\"add_aUSD_to_wallet\\\">Add aUSD to wallet</a>\\r\\n                </div>\\r\\n            </div>\\r\\n            <div id=\\\"fund_account_options\\\">\\r\\n                <h6>Fund your account</h6>\\r\\n                <div class=\\\"grid\\\">\\r\\n                    <a href=\\\"#\\\" class=\\\"fund_account\\\">Fund my account</a>\\r\\n                    <a href=\\\"#\\\" id=\\\"withdraw_from_account\\\">Withdraw from account</a>\\r\\n                </div>\\r\\n            </div>\\r\\n            <hr/>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <strong class=\\\"d-block\\\">Network</strong>\\r\\n            <small>{{networkName}}<br/>\\r\\n                <a href=\\\"#\\\" id=\\\"switch_network\\\">Change network</a>\\r\\n            </small>\\r\\n        </div>\\r\\n\\r\\n    </div>\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const elements_UserInfo = (UserInfo_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycEditName.html\n// Module\nvar KycEditName_code = \"<fieldset id=\\\"kycEditName\\\">\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        <strong>Warning</strong><br/>\\r\\n        You can only change the name once. Be careful of what you change.\\r\\n        <br/><br/>\\r\\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\\r\\n        trades\\r\\n        until it has been approved.\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"given_name\\\">Legal First name</label>\\r\\n        <input required id=\\\"given_name\\\" name=\\\"given_name\\\"\\r\\n               placeholder=\\\"Ron\\\"\\r\\n               value=\\\"{{given_name}}\\\" autocomplete=\\\"given-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"middle_name\\\">Legal Middle name</label>\\r\\n        <input id=\\\"middle_name\\\" name=\\\"middle_name\\\"\\r\\n               placeholder=\\\"\\\"\\r\\n               value=\\\"{{middle_name}}\\\" autocomplete=\\\"additional-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"family_name\\\">Legal Last name</label>\\r\\n        <input required id=\\\"family_name\\\" name=\\\"family_name\\\"\\r\\n               placeholder=\\\"Swanson\\\"\\r\\n               value=\\\"{{family_name}}\\\" autocomplete=\\\"family-name\\\">\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"buttons\\\">\\r\\n        <button id=\\\"kycEditNameConfirm\\\">Confirm</button>\\r\\n    </div>\\r\\n</fieldset>\\r\\n\\r\\n<fieldset class=\\\"hidden\\\" id=\\\"confirmNameFieldset\\\">\\r\\n    <div class=\\\"confirm_name\\\">\\r\\n        <label for=\\\"confirm_name\\\" id=\\\"label_confirm_name\\\">Please type</label>\\r\\n        <input name=\\\"confirm_name\\\" id=\\\"confirm_name\\\"/>\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"input_error\\\" id=\\\"kycEditNameError\\\"></div>\\r\\n\\r\\n    <div class=\\\"buttons grid\\\">\\r\\n        <button id=\\\"kycEditNameBack\\\">Back</button>\\r\\n        <button type=\\\"submit\\\" id=\\\"kycEditNameSave\\\">Confirm</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const KycEditName = (KycEditName_code);\n;// CONCATENATED MODULE: ./src/util/StringHelper.ts\nclass StringHelper {\r\n    static isNullOrEmpty(str) {\r\n        return !str || str.toString().trim().length == 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycEditNameForm.ts\nvar KycEditNameForm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass KycEditNameForm {\r\n    constructor() {\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        return KycEditNameForm_awaiter(this, void 0, void 0, function* () {\r\n            let kycEditNameError = document.getElementById('kycEditNameError');\r\n            if (kycEditNameError)\r\n                kycEditNameError.style.display = 'none';\r\n            let userService = new UserService();\r\n            let account = yield userService.getAccount();\r\n            let given_name = account.identity.given_name;\r\n            let middle_name = account.identity.middle_name;\r\n            let family_name = account.identity.family_name;\r\n            let template = Handlebars.compile(KycEditName);\r\n            let content = template({ given_name: given_name, middle_name: middle_name, family_name: family_name });\r\n            this.modal.showModal('Edit name', content);\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let kycEditNameConfirm = document.getElementById('kycEditNameConfirm');\r\n        kycEditNameConfirm === null || kycEditNameConfirm === void 0 ? void 0 : kycEditNameConfirm.addEventListener('click', (evt) => KycEditNameForm_awaiter(this, void 0, void 0, function* () {\r\n            var _a, _b;\r\n            let given_name = document.getElementById('given_name');\r\n            let middle_name = document.getElementById('middle_name');\r\n            let family_name = document.getElementById('family_name');\r\n            if (StringHelper.isNullOrEmpty(given_name.value)) {\r\n                this.showError('Given name cannot be empty');\r\n                return;\r\n            }\r\n            if (StringHelper.isNullOrEmpty(family_name.value)) {\r\n                this.showError('Family name cannot be empty');\r\n                return;\r\n            }\r\n            let full_name = this.getFullName();\r\n            let label_confirm_name = document.getElementById('label_confirm_name');\r\n            if (!label_confirm_name) {\r\n                //TODO: report error in form\r\n                return;\r\n            }\r\n            label_confirm_name.innerHTML = 'Please type in the full name \"' + full_name + '\" in the box below to confirm. You WILL NOT be able to change it again.';\r\n            (_a = document.getElementById('confirmNameFieldset')) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n            (_b = document.getElementById('kycEditName')) === null || _b === void 0 ? void 0 : _b.classList.add('hidden');\r\n        }));\r\n        let kycEditNameBack = document.getElementById('kycEditNameBack');\r\n        kycEditNameBack === null || kycEditNameBack === void 0 ? void 0 : kycEditNameBack.addEventListener('click', (evt) => {\r\n            var _a, _b;\r\n            (_a = document.getElementById('confirmNameFieldset')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n            (_b = document.getElementById('kycEditName')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');\r\n        });\r\n        let confirm_name = document.getElementById('confirm_name');\r\n        if (!confirm_name) {\r\n            //TODO: report error in form\r\n            return;\r\n        }\r\n        let kycEditNameSave = document.getElementById('kycEditNameSave');\r\n        kycEditNameSave.disabled = true;\r\n        confirm_name.setAttribute('aria-invalid', 'true');\r\n        confirm_name.addEventListener('keyup', (evt) => {\r\n            if (confirm_name.value == this.getFullName()) {\r\n                confirm_name.setAttribute('aria-invalid', 'false');\r\n                kycEditNameSave.disabled = false;\r\n            }\r\n            else {\r\n                confirm_name.setAttribute('aria-invalid', 'true');\r\n                kycEditNameSave.disabled = true;\r\n            }\r\n        });\r\n        kycEditNameSave === null || kycEditNameSave === void 0 ? void 0 : kycEditNameSave.addEventListener('click', (evt) => KycEditNameForm_awaiter(this, void 0, void 0, function* () {\r\n            let confirm_name = document.getElementById('confirm_name');\r\n            if (confirm_name && confirm_name.value != this.getFullName()) {\r\n                alert(confirm_name.value + ' is not same as ' + this.getFullName() + '. Go over the name and make sure it is identical');\r\n                return;\r\n            }\r\n            let given_name = document.getElementById('given_name');\r\n            let middle_name = document.getElementById('middle_name');\r\n            let family_name = document.getElementById('family_name');\r\n            LoadingHelper.setLoading(kycEditNameSave);\r\n            let userService = new UserService();\r\n            yield userService.updateName(given_name.value, middle_name.value, family_name.value)\r\n                .then((response) => {\r\n                if (response.message) {\r\n                    this.showError(response.message);\r\n                    return;\r\n                }\r\n                this.modal.hideModal();\r\n            }).catch(reason => {\r\n                if (reason.message) {\r\n                    this.showError(JSON.parse(reason.message).message);\r\n                }\r\n                else {\r\n                    this.showError(reason);\r\n                }\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n    showError(message) {\r\n        let kycEditNameError = document.getElementById('kycEditNameError');\r\n        if (!kycEditNameError)\r\n            return;\r\n        kycEditNameError.innerHTML = message;\r\n        kycEditNameError.style.display = 'block';\r\n    }\r\n    getFullName() {\r\n        let given_name = document.getElementById('given_name');\r\n        let middle_name = document.getElementById('middle_name');\r\n        let family_name = document.getElementById('family_name');\r\n        return given_name.value + ' ' + (!StringHelper.isNullOrEmpty(middle_name.value) ? middle_name.value + ' ' : '') + family_name.value;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycEditContactForm.html\n// Module\nvar KycEditContactForm_code = \"<fieldset id=\\\"kycEditContactFieldset\\\">\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        <strong>Warning</strong><br/>\\r\\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\\r\\n        trades until it has been approved.\\r\\n    </div>\\r\\n    <form id=\\\"kycEditContactForm\\\">\\r\\n        <div>\\r\\n            <label for=\\\"email_address\\\">Email</label>\\r\\n            <input type=\\\"email\\\" required class=\\\"form-control\\\" id=\\\"email_address\\\" name=\\\"email_address\\\"\\r\\n                   placeholder=\\\"name@example.com\\\" autocomplete=\\\"email\\\"\\r\\n                   value=\\\"\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"phone_number\\\">Phone</label>\\r\\n            <input type=\\\"tel\\\" class=\\\"form-control\\\" id=\\\"phone_number\\\" name=\\\"phone_number\\\"\\r\\n                   placeholder=\\\"+1-555-666-7788\\\" autocomplete=\\\"tel\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"street_address\\\">Permanent Residential Address</label>\\r\\n            <div class=\\\"explain\\\">It must be a physical address, not a PO box.</div>\\r\\n            <input required id=\\\"street_address\\\" name=\\\"street_address\\\"\\r\\n                   placeholder=\\\"20 N San Mateo Dr\\\" value=\\\"\\\" autocomplete=\\\"address-line1\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"unit\\\">Unit / Apt #</label>\\r\\n            <input id=\\\"unit\\\" name=\\\"unit\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"city\\\">City</label>\\r\\n            <input id=\\\"city\\\" name=\\\"city\\\" placeholder=\\\"Pawnee\\\"\\r\\n                   value=\\\"\\\" autocomplete=\\\"address-level2\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"postal_code\\\">Postal code</label>\\r\\n            <input required id=\\\"postal_code\\\" autocomplete=\\\"postal-code\\\" name=\\\"postal_code\\\"\\r\\n                   placeholder=\\\"94401\\\"\\r\\n                   value=\\\"\\\">\\r\\n        </div>\\r\\n        {{#if usa}}\\r\\n        <div id=\\\"state_div\\\">\\r\\n            <label for=\\\"state\\\">State (2 letters)</label>\\r\\n            <input required maxlength=\\\"2\\\" id=\\\"state\\\" name=\\\"state\\\" placeholder=\\\"NY\\\"\\r\\n                   value=\\\"\\\" autocomplete=\\\"address-level1\\\">\\r\\n        </div>\\r\\n        {{/if}}\\r\\n        <div class=\\\"input_error\\\" id=\\\"kycEditContactError\\\"></div>\\r\\n        <div class=\\\"buttons\\\">\\r\\n            <button type=\\\"submit\\\" id=\\\"kycEditContactSave\\\">Save</button>\\r\\n        </div>\\r\\n    </form>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycEditContactForm = (KycEditContactForm_code);\n;// CONCATENATED MODULE: ./src/util/FormHelper.ts\n\r\nclass FormHelper {\r\n    static getParams(selector) {\r\n        let form = document.querySelector(selector);\r\n        if (!form)\r\n            return;\r\n        let data = new FormData(form);\r\n        return this.serialize(data);\r\n    }\r\n    static serialize(data) {\r\n        let obj = {};\r\n        for (let [key, value] of data) {\r\n            if (obj[key] !== undefined) {\r\n                if (!Array.isArray(obj[key])) {\r\n                    obj[key] = [obj[key]];\r\n                }\r\n                obj[key].push(value);\r\n            }\r\n            else {\r\n                obj[key] = value;\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    static fillInputs(properties, item) {\r\n        properties.forEach((value) => {\r\n            let input = document.querySelector('input[name=' + value + ']');\r\n            if (input) {\r\n                if (input.type == 'radio') {\r\n                    console.log('checkbox', input, item[value]);\r\n                    input.value = item[value];\r\n                }\r\n                else {\r\n                    input.value = item[value];\r\n                }\r\n                input.dispatchEvent(new Event('change'));\r\n            }\r\n            else {\r\n                let select = document.querySelector('select[name=' + value + ']');\r\n                if (select) {\r\n                    select.value = item[value];\r\n                    select.dispatchEvent(new Event('change'));\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static validate(selector) {\r\n        let inputs = document.querySelectorAll(selector + ' input[required], ' + selector + ' select[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            input.setAttribute('aria-invalid', 'false');\r\n            if (StringHelper.isNullOrEmpty(input.value)) {\r\n                input.setAttribute('aria-invalid', 'true');\r\n                input.focus();\r\n                input.addEventListener('change', (evt) => {\r\n                    if (!StringHelper.isNullOrEmpty(input.value)) {\r\n                        input.setAttribute('aria-invalid', 'false');\r\n                    }\r\n                });\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycEditContactForm.ts\nvar KycEditContactForm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycEditContactForm {\r\n    constructor() {\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        return KycEditContactForm_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService();\r\n            let account = yield userService.getAccount();\r\n            let usa = account.identity.country_of_tax_residence == 'USA';\r\n            let template = Handlebars.compile(Kyc_KycEditContactForm);\r\n            this.modal.showModal('Edit contact information', template({ usa: usa }));\r\n            let contactProperties = Object.getOwnPropertyNames(account.contact);\r\n            FormHelper.fillInputs(contactProperties, account.contact);\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let kycEditContactSave = document.getElementById('kycEditContactSave');\r\n        kycEditContactSave === null || kycEditContactSave === void 0 ? void 0 : kycEditContactSave.addEventListener('click', (evt) => KycEditContactForm_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.validate())\r\n                return;\r\n            LoadingHelper.setLoading(kycEditContactSave);\r\n            let data = FormHelper.getParams('#kycEditContactForm');\r\n            let userService = new UserService();\r\n            yield userService.updateContact(data).then((response) => {\r\n                if (response.message) {\r\n                    this.showError(response.message);\r\n                    return;\r\n                }\r\n                let accountInfo = response;\r\n                let email_address = document.getElementById('email_address');\r\n                if (accountInfo.contact.email_address != (email_address === null || email_address === void 0 ? void 0 : email_address.value)) {\r\n                    this.showError('Email was not changed. The email ' + (email_address === null || email_address === void 0 ? void 0 : email_address.value) + ' is already registered under different account.');\r\n                    return;\r\n                }\r\n                this.modal.hideModal();\r\n            }).catch(reason => {\r\n                if (reason.message) {\r\n                    this.showError(JSON.parse(reason.message).message);\r\n                }\r\n                else {\r\n                    this.showError(reason);\r\n                }\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n    showError(message) {\r\n        let kycEditNameError = document.getElementById('kycEditContactError');\r\n        if (!kycEditNameError)\r\n            return;\r\n        kycEditNameError.innerHTML = message;\r\n        kycEditNameError.style.display = 'block';\r\n    }\r\n    validate() {\r\n        let inputs = document.querySelectorAll('#kycEditContactFieldset input[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (StringHelper.isNullOrEmpty(input.value)) {\r\n                input.setAttribute('aria-invalid', 'true');\r\n                input.addEventListener('change', (evt) => {\r\n                    if (!StringHelper.isNullOrEmpty(input.value)) {\r\n                        input.setAttribute('aria-invalid', 'false');\r\n                    }\r\n                });\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycEditTrustedContact.html\n// Module\nvar KycEditTrustedContact_code = \"<fieldset class=\\\"kycTrustedContact\\\">\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        <strong>Warning</strong><br/>\\r\\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\\r\\n        trades until it has been approved.\\r\\n    </div>\\r\\n\\r\\n    <form id=\\\"kycTrustedContactForm\\\" method=\\\"post\\\">\\r\\n        <div class=\\\"explain\\\">\\r\\n            A trusted contact is a person you authorize your financial firm to contact in limited circumstances,\\r\\n            such as if there is a concern about activity in your account and they have been unable to get in touch with\\r\\n            you.\\r\\n            <br/><br/>\\r\\n            A trusted contact may be a family member, attorney, accountant or another third-party who you believe would\\r\\n            respect your privacy and know how to handle the responsibility.\\r\\n            The trusted person should be 18 years old or older.\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"given_name\\\">Legal given name of trusted contact</label>\\r\\n            <input required id=\\\"given_name\\\" name=\\\"given_name\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"family_name\\\">Legal family name of trusted contact</label>\\r\\n            <input required id=\\\"family_name\\\" name=\\\"family_name\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            If you fill in name, you are required to fill in one of the following, email, phone or address\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"contact_missing_info\\\"></div>\\r\\n        <div>\\r\\n            <label for=\\\"email_address\\\">Email of trusted contact</label>\\r\\n            <input id=\\\"email_address\\\" type=\\\"email\\\" name=\\\"email_address\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"phone_number\\\">Phone of trusted contact</label>\\r\\n            <input id=\\\"phone_number\\\" type=\\\"tel\\\" name=\\\"phone_number\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"street_address\\\">Address of trusted contact</label>\\r\\n            <input id=\\\"street_address\\\" name=\\\"street_address\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"city\\\">City of trusted contact</label>\\r\\n            <input id=\\\"city\\\" name=\\\"city\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"state\\\">State of trusted contact</label>\\r\\n            <input id=\\\"state\\\" name=\\\"state\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"postal_code\\\">Postal code of trusted contact</label>\\r\\n            <input id=\\\"postal_code\\\" name=\\\"postal_code\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"country\\\">Country of trusted contact</label>\\r\\n            <select required id=\\\"country\\\" required name=\\\"country\\\">\\r\\n                <option value=\\\"\\\"></option>\\r\\n                {{#each countries}}\\r\\n                <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n                {{/each}}\\r\\n            </select>\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"kycEditNameError\\\"></div>\\r\\n        <div class=\\\"buttons\\\">\\r\\n            <button type=\\\"submit\\\" id=\\\"trustedContactSubmit\\\">Submit</button>\\r\\n        </div>\\r\\n    </form>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycEditTrustedContact = (KycEditTrustedContact_code);\n;// CONCATENATED MODULE: ./src/util/CountryHelper.ts\nclass CountryHelper {\r\n}\r\nCountryHelper.Countries = [\r\n    { \"name\": \"United States of America\", \"code\": \"USA\" },\r\n    { \"name\": \"United Kingdom\", \"code\": \"GBR\" },\r\n    { \"name\": \"Afghanistan\", \"code\": \"AFG\" }, { \"name\": \"Albania\", \"code\": \"ALB\" }, {\r\n        \"name\": \"Algeria\",\r\n        \"code\": \"DZA\"\r\n    }, { \"name\": \"American Samoa\", \"code\": \"ASM\" }, { \"name\": \"Andorra\", \"code\": \"AND\" }, {\r\n        \"name\": \"Angola\",\r\n        \"code\": \"AGO\"\r\n    }, { \"name\": \"Anguilla\", \"code\": \"AIA\" }, { \"name\": \"Antarctica\", \"code\": \"ATA\" }, {\r\n        \"name\": \"Antigua and Barbuda\",\r\n        \"code\": \"ATG\"\r\n    }, { \"name\": \"Argentina\", \"code\": \"ARG\" }, { \"name\": \"Armenia\", \"code\": \"ARM\" }, {\r\n        \"name\": \"Aruba\",\r\n        \"code\": \"ABW\"\r\n    }, { \"name\": \"Australia\", \"code\": \"AUS\" }, { \"name\": \"Austria\", \"code\": \"AUT\" }, {\r\n        \"name\": \"Azerbaijan\",\r\n        \"code\": \"AZE\"\r\n    }, { \"name\": \"land Islands\", \"code\": \"ALA\" }, { \"name\": \"Bahamas\", \"code\": \"BHS\" }, {\r\n        \"name\": \"Bahrain\",\r\n        \"code\": \"BHR\"\r\n    }, { \"name\": \"Bangladesh\", \"code\": \"BGD\" }, { \"name\": \"Barbados\", \"code\": \"BRB\" }, {\r\n        \"name\": \"Belarus\",\r\n        \"code\": \"BLR\"\r\n    }, { \"name\": \"Belgium\", \"code\": \"BEL\" }, { \"name\": \"Belize\", \"code\": \"BLZ\" }, {\r\n        \"name\": \"Benin\",\r\n        \"code\": \"BEN\"\r\n    }, { \"name\": \"Bermuda\", \"code\": \"BMU\" }, {\r\n        \"name\": \"Bhutan\",\r\n        \"code\": \"BTN\"\r\n    }, { \"name\": \"Bolivia (Plurinational State of)\", \"code\": \"BOL\" }, {\r\n        \"name\": \"Bonaire, Sint Eustatius and Saba\",\r\n        \"code\": \"BES\"\r\n    }, { \"name\": \"Bosnia and Herzegovina\", \"code\": \"BIH\" }, {\r\n        \"name\": \"Botswana\",\r\n        \"code\": \"BWA\"\r\n    }, { \"name\": \"Bouvet Island\", \"code\": \"BVT\" }, {\r\n        \"name\": \"Brazil\",\r\n        \"code\": \"BRA\"\r\n    }, { \"name\": \"British Indian Ocean Territory\", \"code\": \"IOT\" }, {\r\n        \"name\": \"Brunei Darussalam\",\r\n        \"code\": \"BRN\"\r\n    }, { \"name\": \"Bulgaria\", \"code\": \"BGR\" }, { \"name\": \"Burkina Faso\", \"code\": \"BFA\" }, {\r\n        \"name\": \"Burundi\",\r\n        \"code\": \"BDI\"\r\n    }, { \"name\": \"Cabo Verde\", \"code\": \"CPV\" }, { \"name\": \"Cambodia\", \"code\": \"KHM\" }, {\r\n        \"name\": \"Cameroon\",\r\n        \"code\": \"CMR\"\r\n    }, { \"name\": \"Canada\", \"code\": \"CAN\" }, {\r\n        \"name\": \"Cayman Islands\",\r\n        \"code\": \"CYM\"\r\n    }, { \"name\": \"Central African Republic\", \"code\": \"CAF\" }, { \"name\": \"Chad\", \"code\": \"TCD\" }, {\r\n        \"name\": \"Chile\",\r\n        \"code\": \"CHL\"\r\n    }, { \"name\": \"China\", \"code\": \"CHN\" }, {\r\n        \"name\": \"Christmas Island\",\r\n        \"code\": \"CXR\"\r\n    }, { \"name\": \"Cocos (Keeling) Islands\", \"code\": \"CCK\" }, { \"name\": \"Colombia\", \"code\": \"COL\" }, {\r\n        \"name\": \"Comoros\",\r\n        \"code\": \"COM\"\r\n    }, { \"name\": \"Congo (the Democratic Republic of the)\", \"code\": \"COD\" }, {\r\n        \"name\": \"Congo\",\r\n        \"code\": \"COG\"\r\n    }, { \"name\": \"Cook Islands\", \"code\": \"COK\" }, { \"name\": \"Costa Rica\", \"code\": \"CRI\" }, {\r\n        \"name\": \"Croatia\",\r\n        \"code\": \"HRV\"\r\n    }, { \"name\": \"Cuba\", \"code\": \"CUB\" }, { \"name\": \"Curaao\", \"code\": \"CUW\" }, {\r\n        \"name\": \"Cyprus\",\r\n        \"code\": \"CYP\"\r\n    }, { \"name\": \"Czechia\", \"code\": \"CZE\" }, { \"name\": \"Cte d'Ivoire\", \"code\": \"CIV\" }, {\r\n        \"name\": \"Denmark\",\r\n        \"code\": \"DNK\"\r\n    }, { \"name\": \"Djibouti\", \"code\": \"DJI\" }, { \"name\": \"Dominica\", \"code\": \"DMA\" }, {\r\n        \"name\": \"Dominican Republic\",\r\n        \"code\": \"DOM\"\r\n    }, { \"name\": \"Ecuador\", \"code\": \"ECU\" }, { \"name\": \"Egypt\", \"code\": \"EGY\" }, {\r\n        \"name\": \"El Salvador\",\r\n        \"code\": \"SLV\"\r\n    }, { \"name\": \"Equatorial Guinea\", \"code\": \"GNQ\" }, { \"name\": \"Eritrea\", \"code\": \"ERI\" }, {\r\n        \"name\": \"Estonia\",\r\n        \"code\": \"EST\"\r\n    }, { \"name\": \"Eswatini\", \"code\": \"SWZ\" }, {\r\n        \"name\": \"Ethiopia\",\r\n        \"code\": \"ETH\"\r\n    }, { \"name\": \"Falkland Islands [Malvinas]\", \"code\": \"FLK\" }, {\r\n        \"name\": \"Faroe Islands\",\r\n        \"code\": \"FRO\"\r\n    }, { \"name\": \"Fiji\", \"code\": \"FJI\" }, { \"name\": \"Finland\", \"code\": \"FIN\" }, {\r\n        \"name\": \"France\",\r\n        \"code\": \"FRA\"\r\n    }, { \"name\": \"French Guiana\", \"code\": \"GUF\" }, {\r\n        \"name\": \"French Polynesia\",\r\n        \"code\": \"PYF\"\r\n    }, { \"name\": \"French Southern Territories\", \"code\": \"ATF\" }, { \"name\": \"Gabon\", \"code\": \"GAB\" }, {\r\n        \"name\": \"Gambia\",\r\n        \"code\": \"GMB\"\r\n    }, { \"name\": \"Georgia\", \"code\": \"GEO\" }, { \"name\": \"Germany\", \"code\": \"DEU\" }, {\r\n        \"name\": \"Ghana\",\r\n        \"code\": \"GHA\"\r\n    }, { \"name\": \"Gibraltar\", \"code\": \"GIB\" }, { \"name\": \"Greece\", \"code\": \"GRC\" }, {\r\n        \"name\": \"Greenland\",\r\n        \"code\": \"GRL\"\r\n    }, { \"name\": \"Grenada\", \"code\": \"GRD\" }, { \"name\": \"Guadeloupe\", \"code\": \"GLP\" }, {\r\n        \"name\": \"Guam\",\r\n        \"code\": \"GUM\"\r\n    }, { \"name\": \"Guatemala\", \"code\": \"GTM\" }, { \"name\": \"Guernsey\", \"code\": \"GGY\" }, {\r\n        \"name\": \"Guinea\",\r\n        \"code\": \"GIN\"\r\n    }, { \"name\": \"Guinea-Bissau\", \"code\": \"GNB\" }, { \"name\": \"Guyana\", \"code\": \"GUY\" }, {\r\n        \"name\": \"Haiti\",\r\n        \"code\": \"HTI\"\r\n    }, { \"name\": \"Heard Island and McDonald Islands\", \"code\": \"HMD\" }, {\r\n        \"name\": \"Holy See\",\r\n        \"code\": \"VAT\"\r\n    }, { \"name\": \"Honduras\", \"code\": \"HND\" }, { \"name\": \"Hong Kong\", \"code\": \"HKG\" }, {\r\n        \"name\": \"Hungary\",\r\n        \"code\": \"HUN\"\r\n    }, { \"name\": \"Iceland\", \"code\": \"ISL\" }, { \"name\": \"India\", \"code\": \"IND\" }, {\r\n        \"name\": \"Indonesia\",\r\n        \"code\": \"IDN\"\r\n    }, { \"name\": \"Iran (Islamic Republic of)\", \"code\": \"IRN\" }, { \"name\": \"Iraq\", \"code\": \"IRQ\" }, {\r\n        \"name\": \"Ireland\",\r\n        \"code\": \"IRL\"\r\n    }, { \"name\": \"Isle of Man\", \"code\": \"IMN\" }, { \"name\": \"Israel\", \"code\": \"ISR\" }, {\r\n        \"name\": \"Italy\",\r\n        \"code\": \"ITA\"\r\n    }, { \"name\": \"Jamaica\", \"code\": \"JAM\" }, { \"name\": \"Japan\", \"code\": \"JPN\" }, {\r\n        \"name\": \"Jersey\",\r\n        \"code\": \"JEY\"\r\n    }, { \"name\": \"Jordan\", \"code\": \"JOR\" }, { \"name\": \"Kazakhstan\", \"code\": \"KAZ\" }, {\r\n        \"name\": \"Kenya\",\r\n        \"code\": \"KEN\"\r\n    }, { \"name\": \"Kiribati\", \"code\": \"KIR\" }, {\r\n        \"name\": \"Korea (the Democratic People's Republic of)\",\r\n        \"code\": \"PRK\"\r\n    }, { \"name\": \"Korea (the Republic of)\", \"code\": \"KOR\" }, { \"name\": \"Kuwait\", \"code\": \"KWT\" }, {\r\n        \"name\": \"Kyrgyzstan\",\r\n        \"code\": \"KGZ\"\r\n    }, { \"name\": \"Lao People's Democratic Republic\", \"code\": \"LAO\" }, {\r\n        \"name\": \"Latvia\",\r\n        \"code\": \"LVA\"\r\n    }, { \"name\": \"Lebanon\", \"code\": \"LBN\" }, { \"name\": \"Lesotho\", \"code\": \"LSO\" }, {\r\n        \"name\": \"Liberia\",\r\n        \"code\": \"LBR\"\r\n    }, { \"name\": \"Libya\", \"code\": \"LBY\" }, { \"name\": \"Liechtenstein\", \"code\": \"LIE\" }, {\r\n        \"name\": \"Lithuania\",\r\n        \"code\": \"LTU\"\r\n    }, { \"name\": \"Luxembourg\", \"code\": \"LUX\" }, { \"name\": \"Macao\", \"code\": \"MAC\" }, {\r\n        \"name\": \"Madagascar\",\r\n        \"code\": \"MDG\"\r\n    }, { \"name\": \"Malawi\", \"code\": \"MWI\" }, { \"name\": \"Malaysia\", \"code\": \"MYS\" }, {\r\n        \"name\": \"Maldives\",\r\n        \"code\": \"MDV\"\r\n    }, { \"name\": \"Mali\", \"code\": \"MLI\" }, { \"name\": \"Malta\", \"code\": \"MLT\" }, {\r\n        \"name\": \"Marshall Islands\",\r\n        \"code\": \"MHL\"\r\n    }, { \"name\": \"Martinique\", \"code\": \"MTQ\" }, { \"name\": \"Mauritania\", \"code\": \"MRT\" }, {\r\n        \"name\": \"Mauritius\",\r\n        \"code\": \"MUS\"\r\n    }, { \"name\": \"Mayotte\", \"code\": \"MYT\" }, {\r\n        \"name\": \"Mexico\",\r\n        \"code\": \"MEX\"\r\n    }, { \"name\": \"Micronesia (Federated States of)\", \"code\": \"FSM\" }, {\r\n        \"name\": \"Moldova (the Republic of)\",\r\n        \"code\": \"MDA\"\r\n    }, { \"name\": \"Monaco\", \"code\": \"MCO\" }, { \"name\": \"Mongolia\", \"code\": \"MNG\" }, {\r\n        \"name\": \"Montenegro\",\r\n        \"code\": \"MNE\"\r\n    }, { \"name\": \"Montserrat\", \"code\": \"MSR\" }, { \"name\": \"Morocco\", \"code\": \"MAR\" }, {\r\n        \"name\": \"Mozambique\",\r\n        \"code\": \"MOZ\"\r\n    }, { \"name\": \"Myanmar\", \"code\": \"MMR\" }, { \"name\": \"Namibia\", \"code\": \"NAM\" }, {\r\n        \"name\": \"Nauru\",\r\n        \"code\": \"NRU\"\r\n    }, { \"name\": \"Nepal\", \"code\": \"NPL\" }, { \"name\": \"Netherlands\", \"code\": \"NLD\" }, {\r\n        \"name\": \"New Caledonia\",\r\n        \"code\": \"NCL\"\r\n    }, { \"name\": \"New Zealand\", \"code\": \"NZL\" }, { \"name\": \"Nicaragua\", \"code\": \"NIC\" }, {\r\n        \"name\": \"Niger\",\r\n        \"code\": \"NER\"\r\n    }, { \"name\": \"Nigeria\", \"code\": \"NGA\" }, { \"name\": \"Niue\", \"code\": \"NIU\" }, {\r\n        \"name\": \"Norfolk Island\",\r\n        \"code\": \"NFK\"\r\n    }, { \"name\": \"Northern Mariana Islands\", \"code\": \"MNP\" }, { \"name\": \"Norway\", \"code\": \"NOR\" }, {\r\n        \"name\": \"Oman\",\r\n        \"code\": \"OMN\"\r\n    }, { \"name\": \"Pakistan\", \"code\": \"PAK\" }, { \"name\": \"Palau\", \"code\": \"PLW\" }, {\r\n        \"name\": \"Palestine, State of\",\r\n        \"code\": \"PSE\"\r\n    }, { \"name\": \"Panama\", \"code\": \"PAN\" }, { \"name\": \"Papua New Guinea\", \"code\": \"PNG\" }, {\r\n        \"name\": \"Paraguay\",\r\n        \"code\": \"PRY\"\r\n    }, { \"name\": \"Peru\", \"code\": \"PER\" }, { \"name\": \"Philippines\", \"code\": \"PHL\" }, {\r\n        \"name\": \"Pitcairn\",\r\n        \"code\": \"PCN\"\r\n    }, { \"name\": \"Poland\", \"code\": \"POL\" }, { \"name\": \"Portugal\", \"code\": \"PRT\" }, {\r\n        \"name\": \"Puerto Rico\",\r\n        \"code\": \"PRI\"\r\n    }, { \"name\": \"Qatar\", \"code\": \"QAT\" }, { \"name\": \"Republic of North Macedonia\", \"code\": \"MKD\" }, {\r\n        \"name\": \"Romania\",\r\n        \"code\": \"ROU\"\r\n    }, { \"name\": \"Russian Federation\", \"code\": \"RUS\" }, { \"name\": \"Rwanda\", \"code\": \"RWA\" }, {\r\n        \"name\": \"Runion\",\r\n        \"code\": \"REU\"\r\n    }, { \"name\": \"Saint Barthlemy\", \"code\": \"BLM\" }, {\r\n        \"name\": \"Saint Helena, Ascension and Tristan da Cunha\",\r\n        \"code\": \"SHN\"\r\n    }, { \"name\": \"Saint Kitts and Nevis\", \"code\": \"KNA\" }, {\r\n        \"name\": \"Saint Lucia\",\r\n        \"code\": \"LCA\"\r\n    }, { \"name\": \"Saint Martin (French part)\", \"code\": \"MAF\" }, {\r\n        \"name\": \"Saint Pierre and Miquelon\",\r\n        \"code\": \"SPM\"\r\n    }, { \"name\": \"Saint Vincent and the Grenadines\", \"code\": \"VCT\" }, {\r\n        \"name\": \"Samoa\",\r\n        \"code\": \"WSM\"\r\n    }, { \"name\": \"San Marino\", \"code\": \"SMR\" }, {\r\n        \"name\": \"Sao Tome and Principe\",\r\n        \"code\": \"STP\"\r\n    }, { \"name\": \"Saudi Arabia\", \"code\": \"SAU\" }, { \"name\": \"Senegal\", \"code\": \"SEN\" }, {\r\n        \"name\": \"Serbia\",\r\n        \"code\": \"SRB\"\r\n    }, { \"name\": \"Seychelles\", \"code\": \"SYC\" }, { \"name\": \"Sierra Leone\", \"code\": \"SLE\" }, {\r\n        \"name\": \"Singapore\",\r\n        \"code\": \"SGP\"\r\n    }, { \"name\": \"Sint Maarten (Dutch part)\", \"code\": \"SXM\" }, {\r\n        \"name\": \"Slovakia\",\r\n        \"code\": \"SVK\"\r\n    }, { \"name\": \"Slovenia\", \"code\": \"SVN\" }, { \"name\": \"Solomon Islands\", \"code\": \"SLB\" }, {\r\n        \"name\": \"Somalia\",\r\n        \"code\": \"SOM\"\r\n    }, { \"name\": \"South Africa\", \"code\": \"ZAF\" }, {\r\n        \"name\": \"South Georgia and the South Sandwich Islands\",\r\n        \"code\": \"SGS\"\r\n    }, { \"name\": \"South Sudan\", \"code\": \"SSD\" }, { \"name\": \"Spain\", \"code\": \"ESP\" }, {\r\n        \"name\": \"Sri Lanka\",\r\n        \"code\": \"LKA\"\r\n    }, { \"name\": \"Sudan\", \"code\": \"SDN\" }, { \"name\": \"Suriname\", \"code\": \"SUR\" }, {\r\n        \"name\": \"Svalbard and Jan Mayen\",\r\n        \"code\": \"SJM\"\r\n    }, { \"name\": \"Sweden\", \"code\": \"SWE\" }, { \"name\": \"Switzerland\", \"code\": \"CHE\" }, {\r\n        \"name\": \"Syrian Arab Republic\",\r\n        \"code\": \"SYR\"\r\n    }, { \"name\": \"Taiwan (Province of China)\", \"code\": \"TWN\" }, {\r\n        \"name\": \"Tajikistan\",\r\n        \"code\": \"TJK\"\r\n    }, { \"name\": \"Tanzania, United Republic of\", \"code\": \"TZA\" }, {\r\n        \"name\": \"Thailand\",\r\n        \"code\": \"THA\"\r\n    }, { \"name\": \"Timor-Leste\", \"code\": \"TLS\" }, { \"name\": \"Togo\", \"code\": \"TGO\" }, {\r\n        \"name\": \"Tokelau\",\r\n        \"code\": \"TKL\"\r\n    }, { \"name\": \"Tonga\", \"code\": \"TON\" }, { \"name\": \"Trinidad and Tobago\", \"code\": \"TTO\" }, {\r\n        \"name\": \"Tunisia\",\r\n        \"code\": \"TUN\"\r\n    }, { \"name\": \"Turkey\", \"code\": \"TUR\" }, {\r\n        \"name\": \"Turkmenistan\",\r\n        \"code\": \"TKM\"\r\n    }, { \"name\": \"Turks and Caicos Islands\", \"code\": \"TCA\" }, { \"name\": \"Tuvalu\", \"code\": \"TUV\" }, {\r\n        \"name\": \"Uganda\",\r\n        \"code\": \"UGA\"\r\n    }, { \"name\": \"Ukraine\", \"code\": \"UKR\" }, {\r\n        \"name\": \"United Arab Emirates\",\r\n        \"code\": \"ARE\"\r\n    }, {\r\n        \"name\": \"United Kingdom of Great Britain and Northern Ireland\",\r\n        \"code\": \"GBR\"\r\n    }, { \"name\": \"United States Minor Outlying Islands\", \"code\": \"UMI\" }, {\r\n        \"name\": \"United States of America\",\r\n        \"code\": \"USA\"\r\n    }, { \"name\": \"Uruguay\", \"code\": \"URY\" }, { \"name\": \"Uzbekistan\", \"code\": \"UZB\" }, {\r\n        \"name\": \"Vanuatu\",\r\n        \"code\": \"VUT\"\r\n    }, { \"name\": \"Venezuela (Bolivarian Republic of)\", \"code\": \"VEN\" }, {\r\n        \"name\": \"Viet Nam\",\r\n        \"code\": \"VNM\"\r\n    }, { \"name\": \"Virgin Islands (British)\", \"code\": \"VGB\" }, {\r\n        \"name\": \"Virgin Islands (U.S.)\",\r\n        \"code\": \"VIR\"\r\n    }, { \"name\": \"Wallis and Futuna\", \"code\": \"WLF\" }, { \"name\": \"Western Sahara\", \"code\": \"ESH\" }, {\r\n        \"name\": \"Yemen\",\r\n        \"code\": \"YEM\"\r\n    }, { \"name\": \"Zambia\", \"code\": \"ZMB\" }, { \"name\": \"Zimbabwe\", \"code\": \"ZWE\" }\r\n];\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycEditTrustedContact.ts\nvar KycEditTrustedContact_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycEditTrustedContact {\r\n    constructor() {\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        return KycEditTrustedContact_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService();\r\n            let account = yield userService.getAccount();\r\n            let template = Handlebars.compile(Kyc_KycEditTrustedContact);\r\n            this.modal.showModal('Edit trusted contact', template({ countries: CountryHelper.Countries }));\r\n            if (account.trusted_contact) {\r\n                let contactProperties = Object.getOwnPropertyNames(account.trusted_contact);\r\n                FormHelper.fillInputs(contactProperties, account.trusted_contact);\r\n            }\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let trustedContactSubmit = document.getElementById('trustedContactSubmit');\r\n        trustedContactSubmit === null || trustedContactSubmit === void 0 ? void 0 : trustedContactSubmit.addEventListener('click', (evt) => KycEditTrustedContact_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!FormHelper.validate('#kycTrustedContactForm'))\r\n                return;\r\n            LoadingHelper.setLoading(trustedContactSubmit);\r\n            let params = FormHelper.getParams('#kycTrustedContactForm');\r\n            let userService = new UserService();\r\n            yield userService.updateTrustedContact(params).then((response) => {\r\n                if (response.message) {\r\n                    this.showError(response.message);\r\n                    return;\r\n                }\r\n                this.modal.hideModal();\r\n            }).catch(reason => {\r\n                if (reason.message) {\r\n                    this.showError(JSON.parse(reason.message).message);\r\n                }\r\n                else {\r\n                    this.showError(reason);\r\n                }\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n    showError(message) {\r\n        let kycEditNameError = document.getElementById('kycEditNameError');\r\n        if (!kycEditNameError)\r\n            return;\r\n        kycEditNameError.innerHTML = message;\r\n        kycEditNameError.style.display = 'block';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/util/DateHelper.ts\nclass DateHelper {\r\n    static isOlderThen(date, minutes) {\r\n        let currentTime = new Date().getTime();\r\n        return (currentTime > (date.getTime() + minutes * 60 * 1000));\r\n    }\r\n    ;\r\n    static getWeekday() {\r\n        const weekday = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\r\n        const d = new Date();\r\n        return weekday[d.getDay()];\r\n    }\r\n    static getOpenAndCloseHours() {\r\n        const d = new Date();\r\n        let openHour = 9 + 4 + (-1 * (d.getTimezoneOffset() / 60));\r\n        let closeHour = 16 + 4 + (-1 * (d.getTimezoneOffset() / 60));\r\n        return [openHour + ':30', closeHour + ':00'];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/AUSDService.ts\nvar AUSDService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass AUSDService extends BlockchainService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    getAUSDBalanceOf(ethAddress) {\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            if (AUSDService.lastUpdate && AUSDService.aUSDAmount &&\r\n                !DateHelper.isOlderThen(AUSDService.lastUpdate, 5)) {\r\n                return AUSDService.aUSDAmount;\r\n            }\r\n            let balanceOf = yield this.getBalanceOf(this.contracts.AUSD_ADDRESS, ethAddress);\r\n            let amount = formatEther(balanceOf.toString());\r\n            AUSDService.aUSDAmount = new bignumber(amount);\r\n            AUSDService.lastUpdate = new Date();\r\n            for (let i = 0; i < AUSDService.onAUsdLoad.length; i++) {\r\n                AUSDService.onAUsdLoad[i]();\r\n            }\r\n            return AUSDService.aUSDAmount;\r\n        });\r\n    }\r\n    transfer(symbolAddress, qty) {\r\n        const _super = Object.create(null, {\r\n            transferInner: { get: () => super.transferInner }\r\n        });\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            let result = yield _super.transferInner.call(this, this.contracts.AUSD_ADDRESS, symbolAddress, qty);\r\n            AUSDService.aUSDAmount = undefined;\r\n            AUSDService.lastUpdate = undefined;\r\n            return result;\r\n        });\r\n    }\r\n    getAUsdAbi() {\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            if (AUSDService.AUSDInfo)\r\n                return AUSDService.AUSDInfo.abi;\r\n            let response = yield fetch('../abi/aUSD.json');\r\n            AUSDService.AUSDInfo = yield response.json();\r\n            return AUSDService.AUSDInfo.abi;\r\n        });\r\n    }\r\n}\r\nAUSDService.onAUsdLoad = [];\r\n\n;// CONCATENATED MODULE: ./src/html/modal/funding/FakeFunding.html\n// Module\nvar FakeFunding_code = \"<article>\\r\\n    <div id=\\\"beforeFunding\\\">\\r\\n        To use liminal.market you need some aUSD. aUSD is the same value as USD.\\r\\n        We can give you some aUSD (this is all fake money), so you can play with the system.\\r\\n\\r\\n        First, you need to add aUSD to you wallet.\\r\\n\\r\\n        <button id=\\\"addTokenToWallet\\\">Add aUSD to wallet</button>\\r\\n        <blockquote id=\\\"needToCopy\\\" class=\\\"d-none\\\">\\r\\n            If the button didn't work, you can copy the address here and import it into your wallet\\r\\n            <input value=\\\"{{aUSDAddress}}\\\"/>\\r\\n        </blockquote>\\r\\n        When you have aUSD to you wallet, you can request some money to trade with.\\r\\n\\r\\n        <button id=\\\"requestFakeAUSD\\\">Request some aUSD</button>\\r\\n        <div class=\\\"warningBar notificationBar d-none\\\" id=\\\"fundingError\\\"></div>\\r\\n    </div>\\r\\n    <div id=\\\"afterFunding\\\" class=\\\"d-none center\\\">\\r\\n        We have now sending aUSD to your wallet. This usually takes few minutes, so lets wait.\\r\\n<br /><br />\\r\\n        When you have the aUSD in you wallet, we will tell you.\\r\\n        <div>\\r\\n            <h3>Current aUSD balance</h3>\\r\\n            <div id=\\\"currentAUSDBalance\\\"></div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div id=\\\"errorAfterTryFunding\\\" class=\\\"d-none\\\">\\r\\n        We had an error while trying to fund you. We'll be cracking at the issue soon to fix it.\\r\\n        Try again in few minutes. If not, try again in few hours.\\r\\n    </div>\\r\\n\\r\\n    <a href=\\\"#\\\" id=\\\"registerBankInfo\\\">Register bank information (not needed for Sandbox)</a>\\r\\n</article>\";\n// Exports\n/* harmony default export */ const FakeFunding = (FakeFunding_code);\n;// CONCATENATED MODULE: ./src/services/broker/FundingService.ts\nvar FundingService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass FundingService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    requestFakeFunding() {\r\n        return FundingService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post('fundUser');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/Relationship/SelectFundingType.html\n// Module\nvar SelectFundingType_code = \"<p>Setup your bank relationship with Liminal.market. Please choose the type of transfer you want to make</p>\\r\\n<ul class=\\\"funding_type\\\">\\r\\n    <li><label><input type=\\\"radio\\\" name=\\\"bank_transfer\\\" id=\\\"ach_transfer\\\" value=\\\"1\\\"/> ACH bank transfer (US)</label>\\r\\n    </li>\\r\\n    <li><label><input type=\\\"radio\\\" name=\\\"bank_transfer\\\" id=\\\"wire_transfer\\\" value=\\\"2\\\"/> Wire transfer\\r\\n        (International)</label></li>\\r\\n</ul>\\r\\n<div id=\\\"selectFundingTypeError\\\" class=\\\"input_error\\\"></div>\\r\\n<button id=\\\"next_bank_information\\\">Next: Bank information</button>\\r\\n\";\n// Exports\n/* harmony default export */ const Relationship_SelectFundingType = (SelectFundingType_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/SelectFundingType.ts\n\r\nclass SelectFundingType {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(Relationship_SelectFundingType);\r\n        this.aUsdFund.modal.showModal('Select funding type', template({}));\r\n        this.bindEvent();\r\n    }\r\n    bindEvent() {\r\n        let next_bank_information = document.getElementById('next_bank_information');\r\n        next_bank_information === null || next_bank_information === void 0 ? void 0 : next_bank_information.addEventListener('click', (evt) => {\r\n            this.aUsdFund.hideError('selectFundingTypeError');\r\n            let ach_transfer = document.getElementById('ach_transfer');\r\n            if (ach_transfer === null || ach_transfer === void 0 ? void 0 : ach_transfer.checked) {\r\n                this.aUsdFund.achRelationship.show();\r\n            }\r\n            let wire_transfer = document.getElementById('wire_transfer');\r\n            if (wire_transfer === null || wire_transfer === void 0 ? void 0 : wire_transfer.checked) {\r\n                this.aUsdFund.wireTransferRelationship.show();\r\n            }\r\n            this.aUsdFund.showError('selectFundingTypeError', 'Please select funding type');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/Relationship/ACHRelationship.html\n// Module\nvar ACHRelationship_code = \"<fieldset>\\r\\n    <p>Before you can transfer, you need to set up your bank information</p>\\r\\n\\r\\n    <form id=\\\"achForm\\\">\\r\\n        <div class=\\\"grid\\\">\\r\\n            <label>\\r\\n                Account owner name\\r\\n                <input name=\\\"account_owner_name\\\" required id=\\\"account_owner_name\\\"/>\\r\\n            </label>\\r\\n            <label>Bank Account Type\\r\\n                <select name=\\\"bank_account_type\\\" id=\\\"bank_account_type\\\" required>\\r\\n                    <option value=\\\"\\\"></option>\\r\\n                    <option value=\\\"CHECKING\\\">Checking</option>\\r\\n                    <option value=\\\"SAVINGS\\\">Savings</option>\\r\\n                </select>\\r\\n            </label>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <label>\\r\\n                Bank account number\\r\\n                <input name=\\\"bank_account_number\\\" id=\\\"bank_account_number\\\" required/>\\r\\n            </label>\\r\\n            <label>\\r\\n                Bank routing number\\r\\n                <input name=\\\"bank_routing_number\\\" id=\\\"bank_routing_number\\\" required/>\\r\\n            </label>\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"relationshipError\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <button id=\\\"ach_previous\\\">Previous: Funding type</button>\\r\\n            <button id=\\\"ach_next\\\">Next: Save bank information</button>\\r\\n        </div>\\r\\n\\r\\n    </form>\\r\\n\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Relationship_ACHRelationship = (ACHRelationship_code);\n;// CONCATENATED MODULE: ./src/enums/TransferDirectionEnum.ts\nvar TransferDirectionEnum;\r\n(function (TransferDirectionEnum) {\r\n    TransferDirectionEnum[\"Incoming\"] = \"INCOMING\";\r\n    TransferDirectionEnum[\"Outgoing\"] = \"OUTGOING\";\r\n})(TransferDirectionEnum || (TransferDirectionEnum = {}));\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/RelationshipBase.ts\nvar RelationshipBase_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass RelationshipBase {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show(title, html, param) {\r\n        let template = Handlebars.compile(html);\r\n        this.aUsdFund.modal.showModal(title, template(param));\r\n        this.bindEvents();\r\n    }\r\n    handleErrorResponse(reason) {\r\n        return RelationshipBase_awaiter(this, void 0, void 0, function* () {\r\n            if (!reason.message) {\r\n                alert(reason);\r\n                return;\r\n            }\r\n            let obj = JSON.parse(reason.message);\r\n            let errorElement = document.getElementById('relationshipError');\r\n            if (!errorElement) {\r\n                let message = (obj.serverError) ? obj.serverError.message : reason.message;\r\n                alert(message);\r\n                return;\r\n            }\r\n            if (obj.serverError.message.indexOf('only one bank association') != -1) {\r\n                let userService = new UserService();\r\n                let bankRelationship = yield userService.getBankRelationship();\r\n                if (!bankRelationship) {\r\n                    errorElement.innerText = 'We cannot create the bank connection. Something is not working as it should. Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a>';\r\n                    errorElement.style.display = 'block';\r\n                }\r\n                else {\r\n                    let transfers = yield userService.getLatestTransfers(TransferDirectionEnum.Incoming);\r\n                    yield this.aUsdFund.transferNotification.show(bankRelationship, transfers);\r\n                }\r\n            }\r\n            else {\r\n                errorElement.innerText = obj.serverError.message;\r\n                errorElement.style.display = 'block';\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/ACHRelationship.ts\nvar ACHRelationship_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass ACHRelationship extends RelationshipBase {\r\n    constructor(aUsdFund) {\r\n        super(aUsdFund);\r\n    }\r\n    show() {\r\n        super.show('Bank information', Relationship_ACHRelationship);\r\n    }\r\n    bindEvents() {\r\n        let ach_next = document.getElementById('ach_next');\r\n        ach_next === null || ach_next === void 0 ? void 0 : ach_next.addEventListener('click', (evt) => ACHRelationship_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.validate())\r\n                return;\r\n            let params = FormHelper.getParams('#achForm');\r\n            let userService = new UserService();\r\n            userService.createAchRelationship(params.account_owner_name, params.bank_account_type, params.bank_account_number, params.bank_routing_number)\r\n                .then(result => {\r\n                this.aUsdFund.firstTransferSetup.show(result);\r\n            })\r\n                .catch((reason) => ACHRelationship_awaiter(this, void 0, void 0, function* () {\r\n                yield this.handleErrorResponse(reason);\r\n            }));\r\n        }));\r\n        let ach_previous = document.getElementById('ach_previous');\r\n        ach_previous === null || ach_previous === void 0 ? void 0 : ach_previous.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            this.aUsdFund.selectFundingType.show();\r\n        });\r\n    }\r\n    validate() {\r\n        if (!FormHelper.validate('#achForm'))\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/TransferNotification.html\n// Module\nvar TransferNotification_code = \"<fieldset>\\r\\n\\r\\n\\r\\n    <p>\\r\\n        To fill up your broker account, you need to notify Liminal.market first about your transfer,\\r\\n        we can then match it with your account.\\r\\n        <a href=\\\"#\\\" id=\\\"first_transfer_setup\\\">Need bank information? Click here</a>\\r\\n    </p>\\r\\n    <br/>\\r\\n\\r\\n    {{{moneyTransferred}}}\\r\\n\\r\\n    {{{transfers}}}\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Funding_TransferNotification = (TransferNotification_code);\n;// CONCATENATED MODULE: ./src/html/modal/Funding/TransfersList.html\n// Module\nvar TransfersList_code = \"<hr/>\\r\\n<h3>{{Direction}} transfers</h3>\\r\\n{{#if transfers.length}}\\r\\n<p>Below is a list of transfers, confirmed and not confirmed.</p>\\r\\n<table>\\r\\n    <thead>\\r\\n    <tr>\\r\\n        <th>Amount</th>\\r\\n        <th>Status</th>\\r\\n        <th>Created</th>\\r\\n        <th>Expires</th>\\r\\n    </tr>\\r\\n    </thead>\\r\\n    <tbody>\\r\\n    {{#each transfers}}\\r\\n    <tr>\\r\\n        <td>${{amount}}</td>\\r\\n        <td id=\\\"status_{{id}}\\\">{{status}}</td>\\r\\n        <td>{{dateTimeFormat created_at}}</td>\\r\\n        <td>{{dateTimeFormat expires_at}}</td>\\r\\n        <td id=\\\"delete_{{id}}\\\" class=\\\"{{classByStatus status}}\\\"><a href=\\\"#\\\" class=\\\"deleteTransfer\\\" data-id=\\\"{{id}}\\\">Cancel</a>\\r\\n        </td>\\r\\n    </tr>\\r\\n    {{/each}}\\r\\n    </tbody>\\r\\n</table>\\r\\n{{else}}\\r\\n<p>No transfers registered</p>\\r\\n{{/if}}\";\n// Exports\n/* harmony default export */ const Funding_TransfersList = (TransfersList_code);\n;// CONCATENATED MODULE: ./src/util/HandlebarHelpers.ts\nclass HandlebarHelpers {\r\n    static registerHelpers() {\r\n        Handlebars.registerHelper('perc', function (number) {\r\n            return Math.round(parseFloat(number) * 10000) / 100 + '%';\r\n        });\r\n        Handlebars.registerHelper('round', function (number) {\r\n            return Math.round(parseFloat(number) * 100) / 100;\r\n        });\r\n        Handlebars.registerHelper('round2', function (number) {\r\n            return Math.round(parseFloat(number) * 10000) / 10000;\r\n        });\r\n        Handlebars.registerHelper('classColor', function (number) {\r\n            return (number > 0) ? \"green\" : \"red\";\r\n        });\r\n        Handlebars.registerHelper('dateTimeFormat', function (strDate) {\r\n            let date = new Date(strDate);\r\n            return date.toLocaleString();\r\n        });\r\n        Handlebars.registerHelper('classByStatus', function (status) {\r\n            return (status == 'QUEUED' || status == 'APPROVAL_PENDING') ? '' : 'hidden';\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/TransfersList.ts\nvar TransfersList_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass TransfersList {\r\n    constructor() {\r\n        this.userService = new UserService();\r\n    }\r\n    render(direction, transfers) {\r\n        return TransfersList_awaiter(this, void 0, void 0, function* () {\r\n            HandlebarHelpers.registerHelpers();\r\n            let transfersTemplate = Handlebars.compile(Funding_TransfersList);\r\n            return transfersTemplate({ Direction: direction, transfers: transfers });\r\n        });\r\n    }\r\n    bindEvents() {\r\n        var _a;\r\n        let deleteTransfers = document.querySelectorAll('.deleteTransfer');\r\n        for (let i = 0; i < deleteTransfers.length; i++) {\r\n            (_a = deleteTransfers[i]) === null || _a === void 0 ? void 0 : _a.addEventListener('click', (evt) => TransfersList_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                if (!confirm('Are you sure you want to cancel this withdraw request?')) {\r\n                    return;\r\n                }\r\n                let id = deleteTransfers[i].dataset['id'];\r\n                if (!id)\r\n                    return;\r\n                let userService = new UserService();\r\n                yield userService.deleteTransfer(id)\r\n                    .then(() => {\r\n                    let statusTd = document.getElementById('status_' + id);\r\n                    if (statusTd) {\r\n                        statusTd.innerText = 'CANCELED';\r\n                    }\r\n                    let deleteTd = document.getElementById('delete_' + id);\r\n                    deleteTd === null || deleteTd === void 0 ? void 0 : deleteTd.remove();\r\n                });\r\n            }));\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/FirstTransferSetupBase.ts\nclass FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        this.aUsdFund = aUsdFund;\r\n        this.bankRelationship = bankRelationship;\r\n    }\r\n    render(html) {\r\n        let element = document.getElementById('html_to_fill');\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = html;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/MoneyTransferred.html\n// Module\nvar MoneyTransferred_code = \"<form>\\r\\n    <label>Type in the amount in US Dollars ($) that you transferred\\r\\n        <input name=\\\"amount\\\" class=\\\"amount\\\" type=\\\"tel\\\" id=\\\"amount\\\" minlength=\\\"1\\\" required/>\\r\\n    </label>\\r\\n    <div class=\\\"input_error\\\" id=\\\"transferError\\\"></div>\\r\\n    <button id=\\\"notifyTransfer\\\">Notify Liminal.market of incoming transfer</button>\\r\\n\\r\\n    <input type=\\\"hidden\\\" name=\\\"transfer_type\\\" id=\\\"transfer_type\\\" value=\\\"{{transfer_type}}\\\"/>\\r\\n    <input type=\\\"hidden\\\" name=\\\"relationship_id\\\" id=\\\"relationship_id\\\" value=\\\"{{relationshipId}}\\\"/>\\r\\n    <input type=\\\"hidden\\\" name=\\\"direction\\\" id=\\\"direction\\\" value=\\\"INCOMING\\\"/>\\r\\n</form>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_MoneyTransferred = (MoneyTransferred_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/MoneyTransferred.ts\nvar MoneyTransferred_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass MoneyTransferred extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(FirstTransferSetup_MoneyTransferred);\r\n        super.render(template({}));\r\n        this.bindEvents();\r\n    }\r\n    render() {\r\n        let template = Handlebars.compile(FirstTransferSetup_MoneyTransferred);\r\n        return template({\r\n            transfer_type: this.bankRelationship.transfer_type,\r\n            relationshipId: this.bankRelationship.id\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let notifyTransfer = document.getElementById('notifyTransfer');\r\n        notifyTransfer === null || notifyTransfer === void 0 ? void 0 : notifyTransfer.addEventListener('click', (evt) => MoneyTransferred_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            this.aUsdFund.hideError('transferError');\r\n            let amount = document.getElementById('amount');\r\n            if (StringHelper.isNullOrEmpty(amount.value) || parseFloat(amount.value) < 10) {\r\n                this.aUsdFund.showError('amountError', 'Amount cannot be empty or below $10');\r\n            }\r\n            LoadingHelper.setLoading(notifyTransfer);\r\n            let userService = new UserService();\r\n            yield userService.createTransfer(amount.value, 'INCOMING')\r\n                .then(() => {\r\n                this.aUsdFund.transferNotified.show(this.bankRelationship, amount.value);\r\n            })\r\n                .catch(reason => {\r\n                let httpError = JSON.parse(reason.message);\r\n                this.aUsdFund.showError('transferError', httpError.serverError.message);\r\n            })\r\n                .finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/TransferNotification.ts\nvar TransferNotification_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass TransferNotification {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n        this.transfersList = new TransfersList();\r\n    }\r\n    show(bankRelationship, transfers) {\r\n        return TransferNotification_awaiter(this, void 0, void 0, function* () {\r\n            this.bankRelationship = bankRelationship;\r\n            let template = Handlebars.compile(Funding_TransferNotification);\r\n            let transfersListHtml = yield this.transfersList.render(TransferDirectionEnum.Incoming, transfers);\r\n            this.moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);\r\n            this.aUsdFund.modal.showModal('Create transfer notification', template({\r\n                moneyTransferred: this.moneyTransferred.render(),\r\n                transfers: transfersListHtml\r\n            }));\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        var _a;\r\n        (_a = this.moneyTransferred) === null || _a === void 0 ? void 0 : _a.bindEvents();\r\n        this.transfersList.bindEvents();\r\n        let first_transfer_setup = document.getElementById('first_transfer_setup');\r\n        first_transfer_setup === null || first_transfer_setup === void 0 ? void 0 : first_transfer_setup.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            this.aUsdFund.firstTransferSetup.show(this.bankRelationship);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/Relationship/WireTransferRelationship.html\n// Module\nvar WireTransferRelationship_code = \"<fieldset>\\r\\n    <p>Before you can transfer, you need to set up your bank information</p>\\r\\n    <form id=\\\"wireTransferForm\\\">\\r\\n        <label>Bank name\\r\\n            <input name=\\\"name\\\" required id=\\\"name\\\"/>\\r\\n        </label>\\r\\n        <div class=\\\"input_error\\\" id=\\\"swift_error\\\">BIC/SWIFT code should be 8 or 11 characters</div>\\r\\n        <label>\\r\\n            Bank code (BIC/SWIFT)\\r\\n            <input name=\\\"bank_code\\\" maxlength=\\\"11\\\" id=\\\"bank_code\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Bank Street address\\r\\n            <input name=\\\"street_address\\\" id=\\\"street_address\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Bank Postal code\\r\\n            <input name=\\\"postal_code\\\" id=\\\"postal_code\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Bank City\\r\\n            <input name=\\\"city\\\" id=\\\"city\\\" required/>\\r\\n        </label>\\r\\n\\r\\n        <label>Bank State\\r\\n            <input name=\\\"state_province\\\" id=\\\"state_province\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Country where bank account is located\\r\\n            <select required id=\\\"country\\\" required name=\\\"country\\\">\\r\\n                <option value=\\\"\\\"></option>\\r\\n                {{#each countries}}\\r\\n                <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n                {{/each}}\\r\\n            </select>\\r\\n        </label>\\r\\n        <label>\\r\\n            Account number (IBAN)\\r\\n            <input name=\\\"account_number\\\" id=\\\"account_number\\\" required/>\\r\\n        </label>\\r\\n        <input type=\\\"hidden\\\" name=\\\"bank_code_type\\\" value=\\\"BIC\\\"/>\\r\\n        <div id=\\\"relationshipError\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <button id=\\\"wire_transfer_previous\\\">Previous: Funding type</button>\\r\\n            <button id=\\\"save_international_bank_information\\\">Next: Transfer</button>\\r\\n        </div>\\r\\n    </form>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Relationship_WireTransferRelationship = (WireTransferRelationship_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/WireTransferRelationship.ts\nvar WireTransferRelationship_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass WireTransferRelationship extends RelationshipBase {\r\n    constructor(aUsdFund) {\r\n        super(aUsdFund);\r\n    }\r\n    show() {\r\n        super.show('Create bank information', Relationship_WireTransferRelationship, { countries: CountryHelper.Countries });\r\n    }\r\n    bindEvents() {\r\n        let wire_transfer_previous = document.getElementById('wire_transfer_previous');\r\n        wire_transfer_previous === null || wire_transfer_previous === void 0 ? void 0 : wire_transfer_previous.addEventListener('click', (evt) => {\r\n            this.aUsdFund.selectFundingType.show();\r\n        });\r\n        let save_international_bank_information = document.getElementById('save_international_bank_information');\r\n        save_international_bank_information === null || save_international_bank_information === void 0 ? void 0 : save_international_bank_information.addEventListener('click', (evt) => WireTransferRelationship_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.validate())\r\n                return;\r\n            let params = FormHelper.getParams('#wireTransferForm');\r\n            let userService = new UserService();\r\n            yield userService.registerWireTransferRelationship(params)\r\n                .then((bankRelationship) => WireTransferRelationship_awaiter(this, void 0, void 0, function* () {\r\n                let transfers = yield userService.getLatestTransfers(TransferDirectionEnum.Incoming);\r\n                yield this.aUsdFund.transferNotification.show(bankRelationship, transfers);\r\n            }))\r\n                .catch((reason) => WireTransferRelationship_awaiter(this, void 0, void 0, function* () {\r\n                yield this.handleErrorResponse(reason);\r\n            }));\r\n        }));\r\n    }\r\n    validate() {\r\n        let swift_error = document.getElementById('swift_error');\r\n        if (swift_error)\r\n            swift_error.style.display = 'none';\r\n        let writeTransferError = document.getElementById('writeTransferError');\r\n        if (writeTransferError)\r\n            writeTransferError.style.display = 'none';\r\n        if (!FormHelper.validate('#wireTransferForm'))\r\n            return false;\r\n        let bank_code = document.getElementById('bank_code');\r\n        if (bank_code.value.length != 8 && bank_code.value.length != 11) {\r\n            bank_code.setAttribute('aria-invalid', 'true');\r\n            let swift_error = document.getElementById('swift_error');\r\n            if (swift_error)\r\n                swift_error.style.display = 'block';\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/TransferInfo.html\n// Module\nvar TransferInfo_code = \"<h2>You should transfer your money now</h2>\\r\\n\\r\\n<ul>\\r\\n    <li>Amount: {{amount}}</li>\\r\\n    <li>From Account: {{account_number}}</li>\\r\\n</ul>\";\n// Exports\n/* harmony default export */ const TransferInfo = (TransferInfo_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/TransferNotified.ts\n\r\nclass TransferNotified {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show(bankRelationship, amount) {\r\n        let template = Handlebars.compile(TransferInfo);\r\n        let obj = {\r\n            amount,\r\n            account_number: bankRelationship.alpaca_account_number,\r\n            wire: (bankRelationship.transfer_type == 'wire')\r\n        };\r\n        this.aUsdFund.modal.showModal('Transfer information', template(obj));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/FirstTransferSetup.html\n// Module\nvar FirstTransferSetup_code = \"<div id=\\\"html_to_fill\\\">\\r\\n    {{{html}}}\\r\\n</div>\\r\\n\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_FirstTransferSetup = (FirstTransferSetup_code);\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/BankInfo.html\n// Module\nvar BankInfo_code = \"Create the bank information you need in your internet bank\\r\\n<table>\\r\\n    <tr>\\r\\n        <td>Bank name</td>\\r\\n        <td>BMO Harris Bank NA</td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Bank address</td>\\r\\n        <td>BMO Harris Bank\\r\\n            111. W. Monroe Street\\r\\n            Chicago, IL 60603, USA\\r\\n        </td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Recipient - Account name</td>\\r\\n        <td>Alpaca Securities LLC</td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Alpaca address</td>\\r\\n        <td>Alpaca Securities LLC\\r\\n            3 East Third Ave, Suite 233\\r\\n            San Mateo, CA 94401, USA\\r\\n        </td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Account number / IBAN</td>\\r\\n        <td>1636877</td>\\r\\n    </tr>\\r\\n    {{#if wire}}\\r\\n    <tr>\\r\\n        <td>SWIFT CODE</td>\\r\\n        <td>HATRUS44</td>\\r\\n    </tr>\\r\\n    {{^}}\\r\\n    <tr>\\r\\n        <td>ABA ROUTING NUMBER (ACH)</td>\\r\\n        <td>071000288</td>\\r\\n    </tr>\\r\\n    {{/if}}\\r\\n    <tr>\\r\\n        <td>Please specify the following in the reference of the wire:</td>\\r\\n        <td>FFC LMKT-{{account_number}}</td>\\r\\n    </tr>\\r\\n</table>\\r\\n<button id=\\\"bank_info_next\\\">Next: I set up the information in my bank</button>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_BankInfo = (BankInfo_code);\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/WireTransferMoney.html\n// Module\nvar WireTransferMoney_code = \"<h3>Transfer money</h3>\\r\\nYou can now log in to your internet bank and transfer the money to Alpaca.\\r\\n<br/><br/>\\r\\nAfter you have transferred the money, you need to let us know the amount that you transferred.\\r\\n\\r\\n<div class=\\\"grid\\\">\\r\\n    <button id=\\\"prev_wire_transfer_money\\\">Previous: See bank information</button>\\r\\n    <button id=\\\"next_wire_transfer_money\\\">Next: I have transferred the money</button>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_WireTransferMoney = (WireTransferMoney_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/WireTransferMoney.ts\n\r\n\r\n\r\n\r\nclass WireTransferMoney extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(FirstTransferSetup_WireTransferMoney);\r\n        this.render(template({}));\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        let next = document.getElementById('next_wire_transfer_money');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);\r\n            moneyTransferred.show();\r\n        });\r\n        let prev = document.getElementById('prev_wire_transfer_money');\r\n        prev === null || prev === void 0 ? void 0 : prev.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let transferSetup = new FirstTransferSetup(this.aUsdFund);\r\n            transferSetup.show(this.bankRelationship);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/ACHTransferAccountNumber.html\n// Module\nvar ACHTransferAccountNumber_code = \"The money should come from bank account number <strong>{{bank_account_number}}</strong>\\r\\n<div class=\\\"grid\\\">\\r\\n    <button id=\\\"next_ach_account_number\\\">Yes, it's coming from {{bank_account_number}}</button>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_ACHTransferAccountNumber = (ACHTransferAccountNumber_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/ACHTransferAccountNumber.ts\n\r\n\r\n\r\nclass ACHTransferAccountNumber extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(FirstTransferSetup_ACHTransferAccountNumber);\r\n        this.render(template({ bank_account_number: this.bankRelationship.alpaca_account_number }));\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        let next = document.getElementById('next_ach_account_number');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);\r\n            moneyTransferred.show();\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/BankInfo.ts\n\r\n\r\n\r\n\r\nclass BankInfo extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let bankInfoTemplate = Handlebars.compile(FirstTransferSetup_BankInfo);\r\n        let bankInfoHtml = bankInfoTemplate({\r\n            wire: this.bankRelationship.transfer_type == 'wire',\r\n            account_number: this.bankRelationship.alpaca_account_number\r\n        });\r\n        this.render(bankInfoHtml);\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        let next = document.getElementById('bank_info_next');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            if (this.bankRelationship.transfer_type == 'wire') {\r\n                let wireTransferMoney = new WireTransferMoney(this.aUsdFund, this.bankRelationship);\r\n                wireTransferMoney.show();\r\n            }\r\n            else {\r\n                let ach = new ACHTransferAccountNumber(this.aUsdFund, this.bankRelationship);\r\n                ach.show();\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/FirstTransferSetup.ts\n\r\n\r\nclass FirstTransferSetup {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show(bankRelationship) {\r\n        this.bankRelationship = bankRelationship;\r\n        let template = Handlebars.compile(FirstTransferSetup_FirstTransferSetup);\r\n        this.aUsdFund.modal.showModal('Setup transfer', template({}));\r\n        let bankInfo = new BankInfo(this.aUsdFund, bankRelationship);\r\n        bankInfo.show();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/AUSDFund.ts\nvar AUSDFund_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AUSDFund {\r\n    constructor() {\r\n        this.modal = new Modal();\r\n        this.selectFundingType = new SelectFundingType(this);\r\n        this.achRelationship = new ACHRelationship(this);\r\n        this.wireTransferRelationship = new WireTransferRelationship(this);\r\n        this.firstTransferSetup = new FirstTransferSetup(this);\r\n        this.transferNotification = new TransferNotification(this);\r\n        this.transferNotified = new TransferNotified(this);\r\n    }\r\n    show() {\r\n        return AUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService();\r\n            let bankRelationship = yield userService.getBankRelationship();\r\n            if (bankRelationship) {\r\n                let transfers = yield userService.getLatestTransfers(TransferDirectionEnum.Incoming);\r\n                if (transfers.length > 0) {\r\n                    yield this.transferNotification.show(bankRelationship, transfers);\r\n                }\r\n                else {\r\n                    this.firstTransferSetup.show(bankRelationship);\r\n                }\r\n            }\r\n            else {\r\n                this.selectFundingType.show();\r\n            }\r\n        });\r\n    }\r\n    showError(elementId, reason) {\r\n        let element = document.getElementById(elementId);\r\n        if (element) {\r\n            element.innerText = reason;\r\n            element.style.display = 'block';\r\n        }\r\n    }\r\n    hideError(elementId) {\r\n        let element = document.getElementById(elementId);\r\n        if (element) {\r\n            element.style.display = 'none';\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FakeAUSDFund.ts\nvar FakeAUSDFund_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass FakeAUSDFund {\r\n    constructor() {\r\n        this.currentBalance = new bignumber(-1);\r\n        this.modal = new Modal();\r\n    }\r\n    showAUSDFund() {\r\n        let aUsdFund = new AUSDFund();\r\n        aUsdFund.show();\r\n    }\r\n    showAUSDFakeFund() {\r\n        let networkInfo = App.Network;\r\n        if (!networkInfo.TestNetwork) {\r\n            this.showAUSDFund();\r\n            return;\r\n        }\r\n        let template = Handlebars.compile(FakeFunding);\r\n        let contractInfo = ContractInfo.getContractInfo();\r\n        let content = template({ aUSDAddress: contractInfo.AUSD_ADDRESS });\r\n        this.modal.showModal('Fund my account (Fake money)', content);\r\n        let addToWallet = document.getElementById('addTokenToWallet');\r\n        if (!addToWallet)\r\n            return;\r\n        addToWallet.addEventListener('click', (evt) => FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let walletHelper = new WalletHelper();\r\n            let result = yield walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, 'aUSD', () => {\r\n                this.showCopyField();\r\n            });\r\n            if (!result)\r\n                this.showCopyField();\r\n        }));\r\n        let registerBankInfo = document.getElementById('registerBankInfo');\r\n        registerBankInfo === null || registerBankInfo === void 0 ? void 0 : registerBankInfo.addEventListener('click', (evt) => {\r\n            this.modal.hideModal();\r\n            let aUsdFund = new AUSDFund();\r\n            aUsdFund.show();\r\n        });\r\n        let requestFakeAUSD = document.getElementById('requestFakeAUSD');\r\n        requestFakeAUSD === null || requestFakeAUSD === void 0 ? void 0 : requestFakeAUSD.addEventListener('click', (evt) => FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            requestFakeAUSD.setAttribute('aria-busy', 'true');\r\n            let fundingService = new FundingService();\r\n            let result = yield fundingService.requestFakeFunding()\r\n                .catch((reason) => {\r\n                this.errorWhileFunding({});\r\n            });\r\n            if (!result)\r\n                return;\r\n            if (!result.success) {\r\n                let fundingError = document.getElementById('fundingError');\r\n                if (fundingError) {\r\n                    requestFakeAUSD.removeAttribute('aria-busy');\r\n                    fundingError.classList.remove('d-none');\r\n                    fundingError.innerHTML = result.message;\r\n                    setTimeout(() => {\r\n                        fundingError.classList.add('d-none');\r\n                    }, 10 * 1000);\r\n                }\r\n            }\r\n            else if (result.success) {\r\n                let beforeFunding = document.getElementById('beforeFunding');\r\n                let afterFunding = document.getElementById('afterFunding');\r\n                if (!beforeFunding || !afterFunding)\r\n                    return;\r\n                yield this.loadAUSDBalance();\r\n                beforeFunding.classList.add('d-none');\r\n                afterFunding.classList.remove('d-none');\r\n            }\r\n            else {\r\n                this.errorWhileFunding(result);\r\n            }\r\n            //callback();\r\n        }));\r\n    }\r\n    loadAUSDBalance() {\r\n        return FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            let currentAUSDBalance = document.getElementById('currentAUSDBalance');\r\n            if (!currentAUSDBalance)\r\n                return;\r\n            let aUSDService = new AUSDService();\r\n            let userService = new UserService();\r\n            let ethAddress = userService.getEthAddress();\r\n            let amount = new bignumber(0);\r\n            if (ethAddress) {\r\n                AUSDService.lastUpdate = undefined;\r\n                amount = yield aUSDService.getAUSDBalanceOf(ethAddress);\r\n            }\r\n            currentAUSDBalance.innerHTML = '$' + roundBigNumber(amount).toString();\r\n            if (this.currentBalance.eq(-1)) {\r\n                this.currentBalance = amount;\r\n            }\r\n            if (this.currentBalance.eq(amount)) {\r\n                setTimeout(() => FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n                    yield this.loadAUSDBalance();\r\n                }), 5 * 1000);\r\n            }\r\n            else {\r\n                window.location.reload();\r\n            }\r\n        });\r\n    }\r\n    showCopyField() {\r\n        let needToCopy = document.getElementById('needToCopy');\r\n        if (!needToCopy)\r\n            return;\r\n        needToCopy.classList.remove('d-none');\r\n    }\r\n    errorWhileFunding(result) {\r\n        let beforeFunding = document.getElementById('beforeFunding');\r\n        let errorAfterFunding = document.getElementById('errorAfterTryFunding');\r\n        if (!beforeFunding || !errorAfterFunding)\r\n            return;\r\n        if (result.message) {\r\n            errorAfterFunding.innerHTML = result.message;\r\n        }\r\n        beforeFunding.classList.add('d-none');\r\n        errorAfterFunding.classList.remove('d-none');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/WithdrawModal.html\n// Module\nvar WithdrawModal_code = \"<fieldset id=\\\"withdrawInput\\\">\\r\\n\\r\\n    {{#if bank.bank_code_type}}\\r\\n    Your money will be sent to {{bank.name}} to account number {{bank.account_number}}.\\r\\n    <br/><br/>\\r\\n    Outgoing International Wire Transfers cost is ${{transferCost}}.<br/>\\r\\n    Fees will be deducted from the amount.\\r\\n    {{/if}}\\r\\n    {{#unless bank.bank_code_type}}\\r\\n    Your money will be sent to account number {{bank.bank_account_number}}.\\r\\n    <br/><br/>\\r\\n    ACH transfer costs is ${{transferCost}}. Fees will be deducted from the amount.\\r\\n    {{/unless}}\\r\\n    <form id=\\\"withdrawForm\\\">\\r\\n        <label>Amount to withdraw\\r\\n            <input type=\\\"tel\\\" name=\\\"amount\\\" id=\\\"amount\\\"/>\\r\\n        </label>\\r\\n        <div class=\\\"input_error\\\" id=\\\"withdrawAmountError\\\">The amount is lower than the cost of transfer</div>\\r\\n        <button id=\\\"confirmWithdraw\\\">Confirm withdraw</button>\\r\\n    </form>\\r\\n    {{{Transfers}}}\\r\\n</fieldset>\\r\\n\\r\\n<fieldset id=\\\"withdrawConfirm\\\" class=\\\"hidden\\\">\\r\\n    You are about to withdraw $<span id=\\\"withdrawAmountText\\\"></span> from your account\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        Warning: The fee of this transaction will be $<span id=\\\"feeWarning\\\"></span>\\r\\n        and is <span id=\\\"feePercentage\\\"></span>% of the amount.\\r\\n    </div>\\r\\n    <div class=\\\"input_error\\\" id=\\\"withdrawError\\\"></div>\\r\\n    <button id=\\\"confirmWithdrawButton\\\">Execute transfer</button>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Funding_WithdrawModal = (WithdrawModal_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/WithdrawModal.ts\nvar WithdrawModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass WithdrawModal {\r\n    constructor() {\r\n        this.wireTransferCost = 50;\r\n        this.achTransferCost = 25;\r\n        this.userService = new UserService();\r\n        this.transferCost = this.wireTransferCost;\r\n        this.transfersList = new TransfersList();\r\n    }\r\n    show() {\r\n        return WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n            let modal = new Modal();\r\n            let bankRelationships = yield this.userService.getBankRelationship();\r\n            if (!bankRelationships) {\r\n                modal.showModal('Withdraw information', \"You haven't setup bank connection. You cannot withdraw from without bank connection\");\r\n                return;\r\n            }\r\n            let transfers = yield this.userService.getLatestTransfers(TransferDirectionEnum.Outgoing);\r\n            let transfersHtml = yield this.transfersList.render(TransferDirectionEnum.Outgoing, transfers);\r\n            let ethAddress = this.userService.getEthAddress();\r\n            let ausdService = new AUSDService();\r\n            this.currentBalance = new bignumber(0);\r\n            if (ethAddress) {\r\n                this.currentBalance = yield ausdService.getAUSDBalanceOf(ethAddress);\r\n            }\r\n            if (this.currentBalance.eq(0)) {\r\n                let tmp = Handlebars.compile(\"Your current balance is $0. There is nothing to withdraw. {{{transfers}}}\");\r\n                modal.showModal('Withdraw information', tmp({ transfers: transfersHtml }));\r\n                return;\r\n            }\r\n            let withdrawTemplate = Handlebars.compile(Funding_WithdrawModal);\r\n            this.bankInfo = bankRelationships;\r\n            this.transferCost = (this.bankInfo.bank_code_type) ? this.wireTransferCost : this.achTransferCost;\r\n            let obj = {\r\n                amount: this.currentBalance,\r\n                transferCost: this.transferCost,\r\n                Transfers: transfersHtml,\r\n                bank: this.bankInfo\r\n            };\r\n            modal.showModal('Withdraw information', withdrawTemplate(obj));\r\n            this.bindEvents();\r\n            this.transfersList.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let confirmWithdraw = document.getElementById('confirmWithdraw');\r\n        confirmWithdraw === null || confirmWithdraw === void 0 ? void 0 : confirmWithdraw.addEventListener('click', (evt) => WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.bankInfo)\r\n                return;\r\n            let amount = document.getElementById('amount');\r\n            if (StringHelper.isNullOrEmpty(amount.value)) {\r\n                amount.setAttribute('aria-invalid', 'true');\r\n                return;\r\n            }\r\n            else if (parseFloat(amount.value) <= this.transferCost) {\r\n                let withdrawAmountError = document.getElementById('withdrawAmountError');\r\n                withdrawAmountError.style.display = 'block';\r\n                amount.setAttribute('aria-invalid', 'true');\r\n                return;\r\n            }\r\n            else {\r\n                amount.setAttribute('aria-invalid', 'false');\r\n            }\r\n            this.showWithdrawConfirmation();\r\n        }));\r\n    }\r\n    showWithdrawConfirmation() {\r\n        if (!this.bankInfo)\r\n            return;\r\n        let amount = document.getElementById('amount');\r\n        let withdrawInput = document.getElementById('withdrawInput');\r\n        withdrawInput === null || withdrawInput === void 0 ? void 0 : withdrawInput.classList.add('hidden');\r\n        let withdrawConfirm = document.getElementById('withdrawConfirm');\r\n        withdrawConfirm === null || withdrawConfirm === void 0 ? void 0 : withdrawConfirm.classList.remove('hidden');\r\n        let withdrawAmountText = document.getElementById('withdrawAmountText');\r\n        let feeWarning = document.getElementById('feeWarning');\r\n        let feePercentage = document.getElementById('feePercentage');\r\n        withdrawAmountText.innerText = amount.value;\r\n        feeWarning.innerText = this.transferCost.toString();\r\n        feePercentage.innerText = roundNumber((this.transferCost / parseFloat(amount.value)) * 100).toString();\r\n        let confirmWithdrawButton = document.getElementById('confirmWithdrawButton');\r\n        confirmWithdrawButton === null || confirmWithdrawButton === void 0 ? void 0 : confirmWithdrawButton.addEventListener('click', (evt) => WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            yield this.userService.createTransfer(amount.value, TransferDirectionEnum.Outgoing)\r\n                .then((response) => WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n                let transfers = yield this.userService.getLatestTransfers(TransferDirectionEnum.Outgoing);\r\n                withdrawConfirm.innerHTML = yield this.transfersList.render(TransferDirectionEnum.Outgoing, transfers);\r\n                this.transfersList.bindEvents();\r\n            }))\r\n                .catch(reason => {\r\n                let withdrawError = document.getElementById('withdrawError');\r\n                if (!withdrawError)\r\n                    return;\r\n                if (withdrawError && isJSON(reason.message)) {\r\n                    let error = JSON.parse(reason.message);\r\n                    withdrawError.innerText = error.serverError.message;\r\n                }\r\n                else {\r\n                    withdrawError.innerText = reason.toString();\r\n                }\r\n                withdrawError.style.display = 'block';\r\n            });\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/AUsdBalance.ts\nvar AUsdBalance_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AUsdBalance {\r\n    constructor() {\r\n    }\r\n    static forceLoadAUSDBalanceUI() {\r\n        return AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n            let ui = new AUsdBalance();\r\n            AUSDService.lastUpdate = undefined;\r\n            yield ui.loadAUSDBalanceUI();\r\n        });\r\n    }\r\n    loadAUSDBalanceUI() {\r\n        return AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n            if (!App.User.ether) {\r\n                yield AuthenticateService.enableWeb3();\r\n                if (!App.User.ether)\r\n                    return;\r\n            }\r\n            let userInfoAUsdBalance = document.getElementById('userInfoAUsdBalance');\r\n            let frontpageAUsdBalance = document.getElementById('frontpageAUsdBalance');\r\n            if (!App.User.alpacaId) {\r\n                frontpageAUsdBalance === null || frontpageAUsdBalance === void 0 ? void 0 : frontpageAUsdBalance.classList.add('hidden');\r\n                userInfoAUsdBalance === null || userInfoAUsdBalance === void 0 ? void 0 : userInfoAUsdBalance.classList.add('hidden');\r\n                //return;\r\n            }\r\n            else {\r\n                frontpageAUsdBalance === null || frontpageAUsdBalance === void 0 ? void 0 : frontpageAUsdBalance.classList.remove('hidden');\r\n                userInfoAUsdBalance === null || userInfoAUsdBalance === void 0 ? void 0 : userInfoAUsdBalance.classList.remove('hidden');\r\n            }\r\n            let aUSDService = new AUSDService();\r\n            let aUsdValueWei = yield aUSDService.getAUSDBalanceOf(App.User.address);\r\n            let aUsdValue = roundBigNumber(aUsdValueWei);\r\n            let frontpageAUSDBalance = document.getElementById('front_page_aUSD_balance');\r\n            if (frontpageAUSDBalance)\r\n                frontpageAUSDBalance.innerHTML = '$' + aUsdValue;\r\n            let user_info_ausd_balance = document.getElementById('user_info_ausd_balance');\r\n            if (user_info_ausd_balance)\r\n                user_info_ausd_balance.innerHTML = '$' + aUsdValue;\r\n            this.bindEvents();\r\n            let balance_value = document.querySelector('.balance_value');\r\n            if (balance_value) {\r\n                balance_value.innerHTML = '$' + aUsdValue.toFixed();\r\n                balance_value.title = aUsdValueWei.toFixed();\r\n                balance_value.dataset['tooltip'] = aUsdValueWei.toFixed();\r\n            }\r\n            if (aUsdValue.isLessThan(10)) {\r\n                let frontpage_fund_account = document.getElementById('frontpage_fund_account');\r\n                frontpage_fund_account === null || frontpage_fund_account === void 0 ? void 0 : frontpage_fund_account.classList.remove('hidden');\r\n            }\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let networkInfo = App.Network;\r\n        let add_aUSD_to_wallet = document.querySelectorAll('.add_aUSD_to_wallet');\r\n        add_aUSD_to_wallet.forEach(element => {\r\n            element.addEventListener('click', (evt) => AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                let contractInfo = ContractInfo.getContractInfo(networkInfo.Name);\r\n                let walletHelper = new WalletHelper();\r\n                yield walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, 'aUSD', () => {\r\n                    let template = Handlebars.compile(AddToWallet);\r\n                    let obj = { symbol: 'aUSD', address: contractInfo.AUSD_ADDRESS };\r\n                    let modal = new Modal();\r\n                    modal.showModal('Add aUSD token', template(obj));\r\n                });\r\n            }));\r\n        });\r\n        let fund_accountButtons = document.querySelectorAll('.fund_account');\r\n        fund_accountButtons.forEach(element => {\r\n            let aUSDFundingModal = new FakeAUSDFund();\r\n            if (networkInfo.TestNetwork) {\r\n                element.innerHTML = 'Click for some aUSD';\r\n                element.addEventListener('click', (evt) => {\r\n                    evt.preventDefault();\r\n                    aUSDFundingModal.showAUSDFakeFund();\r\n                });\r\n            }\r\n            else {\r\n                element.addEventListener('click', (evt) => AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    let aUsdFund = new AUSDFund();\r\n                    yield aUsdFund.show();\r\n                }));\r\n            }\r\n        });\r\n        let withdraw_from_account = document.getElementById('withdraw_from_account');\r\n        withdraw_from_account === null || withdraw_from_account === void 0 ? void 0 : withdraw_from_account.addEventListener('click', (evt) => AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let withdrawModal = new WithdrawModal();\r\n            yield withdrawModal.show();\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/TestNetworkBanner.html\n// Module\nvar TestNetworkBanner_code = \"<div class=\\\"errorBar\\\">You are running on testnet. No real trades will be executed. <a href=\\\"#\\\"\\r\\n                                                                                      id=\\\"switch_from_test_network\\\">Switch\\r\\n    to mainnet</a></div>\";\n// Exports\n/* harmony default export */ const TestNetworkBanner = (TestNetworkBanner_code);\n;// CONCATENATED MODULE: ./src/ui/elements/UserInfo.ts\nvar UserInfo_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass UserInfo {\r\n    constructor(providerInfo) {\r\n        this.walletLoaded = false;\r\n        this.authenticationService = new AuthenticateService();\r\n        this.userService = new UserService();\r\n        this.providerInfo = providerInfo;\r\n        this.walletHelper = new WalletHelper();\r\n    }\r\n    render(elementId) {\r\n        return UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            let user_header_info = document.getElementById('user_header_info');\r\n            if (user_header_info)\r\n                user_header_info.innerHTML = 'Loading wallet..';\r\n            LoadingHelper.setLoading(user_header_info);\r\n            this.listenForWalletChanges();\r\n            this.loadUserMenuUI(elementId);\r\n            this.loadIfTestNetwork();\r\n            this.ifTradePage();\r\n            LoadingHelper.removeLoading();\r\n            let aUsdBalance = new AUsdBalance();\r\n            yield aUsdBalance.loadAUSDBalanceUI();\r\n        });\r\n    }\r\n    listenForWalletChanges() {\r\n        /*\r\n        TODO: need fixing\r\n        this.moralis.onChainChanged(function () {\r\n            location.reload();\r\n        });\r\n        this.moralis.onAccountChanged(function () {\r\n            location.reload();\r\n        });\r\n        this.moralis.onDisconnect(function () {\r\n            location.reload();\r\n        });\r\n        this.moralis.onConnect(function () {\r\n            location.reload();\r\n        });\r\n\r\n         */\r\n    }\r\n    loadUserMenuUI(elementId) {\r\n        return UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            let userInfoDiv = document.getElementById(elementId);\r\n            if (!userInfoDiv)\r\n                return;\r\n            console.log('loadUserMenuUI User:', App.User);\r\n            let networkInfo = App.Network;\r\n            let obj = {\r\n                ethAddress: App.User.address,\r\n                shortEthAddress: shortEth(App.User.address),\r\n                walletName: this.providerInfo.WalletName,\r\n                networkName: networkInfo.ChainName + ((networkInfo.TestNetwork) ? ' - (Test network)' : ''),\r\n                blockchainExplorer: networkInfo.BlockExplorer + '/address/',\r\n                isMagic: yield this.walletHelper.isMagic(),\r\n                chainId: networkInfo.ChainId\r\n            };\r\n            let template = Handlebars.compile(elements_UserInfo);\r\n            let html = template(obj);\r\n            userInfoDiv.innerHTML = html;\r\n            this.bindEvents();\r\n            this.bindUserActionEvents();\r\n            for (let i = 0; i < UserInfo.onUserLoggedIn.length; i++) {\r\n                UserInfo.onUserLoggedIn[i]();\r\n            }\r\n        });\r\n    }\r\n    bindUserActionEvents() {\r\n        let editName = document.getElementById('editName');\r\n        editName === null || editName === void 0 ? void 0 : editName.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let kycModal = new KycEditNameForm();\r\n            yield kycModal.show();\r\n        }));\r\n        let editContact = document.getElementById('editContact');\r\n        editContact === null || editContact === void 0 ? void 0 : editContact.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let kycModal = new KycEditContactForm();\r\n            yield kycModal.show();\r\n        }));\r\n        let editTrustedContact = document.getElementById('editTrustedContact');\r\n        editTrustedContact === null || editTrustedContact === void 0 ? void 0 : editTrustedContact.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let kycModal = new KycEditTrustedContact();\r\n            yield kycModal.show();\r\n        }));\r\n    }\r\n    bindEvents() {\r\n        return UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            let userInfoDropdown = document.getElementById('userInfoDropdown');\r\n            if (!userInfoDropdown)\r\n                return;\r\n            document.body.addEventListener('click', (evt) => {\r\n                if (userInfoDropdown && !userInfoDropdown.classList.contains('d-none')) {\r\n                    userInfoDropdown.classList.add('d-none');\r\n                    evt.stopPropagation();\r\n                    evt.preventDefault();\r\n                }\r\n            });\r\n            let userInfoAction = document.getElementById('userInfoAction');\r\n            userInfoAction === null || userInfoAction === void 0 ? void 0 : userInfoAction.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                evt.stopPropagation();\r\n                userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.classList.toggle('d-none');\r\n                userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.addEventListener('click', (evt) => {\r\n                    evt.stopPropagation();\r\n                });\r\n                WalletHelper.hideMagicWallet();\r\n            });\r\n            let disconnectFromNetwork = document.getElementById('disconnectFromNetwork');\r\n            disconnectFromNetwork === null || disconnectFromNetwork === void 0 ? void 0 : disconnectFromNetwork.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                yield this.authenticationService.logOut();\r\n                window.location.reload();\r\n            }));\r\n            let wallet = document.getElementById('wallet');\r\n            wallet === null || wallet === void 0 ? void 0 : wallet.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                LoadingHelper.setLoading(evt.target);\r\n                if (this.walletLoaded) {\r\n                    let magicIframe = document.querySelector('.magic-iframe');\r\n                    if (magicIframe)\r\n                        magicIframe.style.display = 'block';\r\n                    LoadingHelper.removeLoading();\r\n                    userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.classList.add('d-none');\r\n                    return;\r\n                }\r\n                App.User.provider.magic.connect.showWallet()\r\n                    .catch((e) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n                    this.walletLoaded = false;\r\n                    if (e.message.indexOf('User denied account access') != -1) {\r\n                        yield this.authenticationService.logOut();\r\n                        alert('You have been logged out of you wallet and need to log back in. We will now reload the page and you can log in.');\r\n                        location.reload();\r\n                        return;\r\n                    }\r\n                    throw e;\r\n                }));\r\n                let closeMenuInterval = setInterval(() => {\r\n                    let magicIframe = document.querySelector('.magic-iframe');\r\n                    if (!magicIframe)\r\n                        clearInterval(closeMenuInterval);\r\n                    if (magicIframe && magicIframe.style.display == 'block') {\r\n                        LoadingHelper.removeLoading();\r\n                        userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.classList.add('d-none');\r\n                        this.walletLoaded = true;\r\n                        clearInterval(closeMenuInterval);\r\n                    }\r\n                }, 1000);\r\n            }));\r\n            let switch_network = document.getElementById('switch_network');\r\n            switch_network === null || switch_network === void 0 ? void 0 : switch_network.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let switchNetworkModal = new SwitchNetworkModal();\r\n                switchNetworkModal.show();\r\n            });\r\n        });\r\n    }\r\n    loadIfTestNetwork() {\r\n        if (!App.User.provider)\r\n            return;\r\n        if (!App.Network.TestNetwork)\r\n            return;\r\n        let header = document.querySelector('header');\r\n        if (!header)\r\n            return;\r\n        let template = Handlebars.compile(TestNetworkBanner);\r\n        header.insertAdjacentHTML('beforebegin', template({}));\r\n        let switch_from_test_network = document.getElementById('switch_from_test_network');\r\n        switch_from_test_network === null || switch_from_test_network === void 0 ? void 0 : switch_from_test_network.addEventListener('click', (evt) => {\r\n            let switchNetworkModal = new SwitchNetworkModal();\r\n            switchNetworkModal.show();\r\n        });\r\n    }\r\n    ifTradePage() {\r\n        let btn = document.getElementById('liminal_market_execute_trade');\r\n        if (!btn)\r\n            return;\r\n        ExecuteOrderButton.Instance.renderButton();\r\n    }\r\n}\r\nUserInfo.onUserLoggedIn = [];\r\n\n;// CONCATENATED MODULE: ./src/html/elements/ConnectWalletButton.html\n// Module\nvar ConnectWalletButton_code = \"<button class=\\\"liminal_market_connect_wallet outline\\\">Connect wallet</button>\";\n// Exports\n/* harmony default export */ const ConnectWalletButton = (ConnectWalletButton_code);\n;// CONCATENATED MODULE: ./src/ui/modals/ConnectWallet.ts\nvar ConnectWallet_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ConnectWallet {\r\n    constructor() {\r\n        this.providerInfo = new ProviderInfo(null);\r\n    }\r\n    renderButton(elementId) {\r\n        if (!document.getElementById(elementId))\r\n            return;\r\n        document.getElementById(elementId).innerHTML = ConnectWalletButton;\r\n        let elements = document.querySelectorAll(\".liminal_market_connect_wallet\");\r\n        elements.forEach((el) => ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n            el.addEventListener('click', (evt) => ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                yield this.connectWallet(evt.target);\r\n            }));\r\n        }));\r\n    }\r\n    connectWallet(button) {\r\n        return ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n            LoadingHelper.setLoading(button);\r\n            let authenticationService = new AuthenticateService();\r\n            yield authenticationService.authenticateUser((walletConnectionInfo) => {\r\n                this.web3EnabledResult(walletConnectionInfo);\r\n            }, () => ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n                let userInfo = new UserInfo(this.providerInfo);\r\n                yield userInfo.render('user_header_info');\r\n                if (document.getElementById('liminal_market_execute_trade')) {\r\n                    let page = new TradePage();\r\n                    yield page.load();\r\n                }\r\n            }))\r\n                .catch((reason) => {\r\n                ErrorInfo.report(reason);\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        });\r\n    }\r\n    web3EnabledResult(walletConnectionInfo) {\r\n        this.providerInfo = new ProviderInfo(walletConnectionInfo);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/MarketIsClosed.html\n// Module\nvar MarketIsClosed_code = \"<div class=\\\"center\\\">\\r\\n    The stock market is currently closed.<br/>\\r\\nIt is usually open monday to friday between 9:30 AM and 4:00 PM EST (9:30 - 16:00 EST).\\r\\n    <br/><br/>\\r\\nToday is {{dayOfWeek}}\\r\\n<br /><br/>\\r\\nYour current time is {{currentTime}} ({{GMT}})\\r\\n    <br/><br/>\\r\\nThat means the market is open your time between\\r\\n{{openFrom}} - {{openTo}}\\r\\n</div>\";\n// Exports\n/* harmony default export */ const MarketIsClosed = (MarketIsClosed_code);\n;// CONCATENATED MODULE: ./src/errors/BlockchainError.ts\n\r\n\r\n\r\n\r\nclass BlockchainError extends GeneralError {\r\n    constructor(e) {\r\n        super(e);\r\n        this.message = e.toString();\r\n        if (this.userDeniedTransactionSignature()) {\r\n            this.code = BlockchainError.UserCancelled;\r\n        }\r\n        else if (this.addressIsNotValidKYC()) {\r\n            this.code = BlockchainError.AddressIsNotValidKYC;\r\n        }\r\n        else if (this.isMarketClosed()) {\r\n            this.code = BlockchainError.MarketIsClosed;\r\n            this.callback = this.marketIsClosedModal;\r\n        }\r\n        if (e.data && e.data.message) {\r\n            let msg = e.data.message;\r\n            let searchStr = 'reverted with reason string';\r\n            let idx = msg.indexOf(searchStr) + searchStr.length;\r\n            if (idx != -1) {\r\n                this.message = msg.substring(idx).trim().replace(/'/g, '');\r\n                this.code = BlockchainError.ErrorFromContract;\r\n            }\r\n        }\r\n    }\r\n    userDeniedTransactionSignature() {\r\n        return this.message.indexOf('denied transaction signature') !== -1;\r\n    }\r\n    addressIsNotValidKYC() {\r\n        return this.message.indexOf('address is not kyc valid') !== -1;\r\n    }\r\n    isMarketClosed() {\r\n        let searchStr = 'Market is closed';\r\n        return this.message.indexOf(searchStr) !== -1;\r\n    }\r\n    marketIsClosedModal() {\r\n        let [openHour, closeHour] = DateHelper.getOpenAndCloseHours();\r\n        let time = new Date().toTimeString().split(' ');\r\n        let obj = {\r\n            currentTime: time[0],\r\n            GMT: time[1],\r\n            dayOfWeek: DateHelper.getWeekday(),\r\n            openFrom: openHour,\r\n            openTo: closeHour\r\n        };\r\n        let modal = new Modal();\r\n        let template = Handlebars.compile(MarketIsClosed);\r\n        modal.showModal('Market is closed', template(obj));\r\n    }\r\n}\r\nBlockchainError.ErrorFromContract = -1;\r\nBlockchainError.UserCancelled = 1;\r\nBlockchainError.AddressIsNotValidKYC = 2;\r\nBlockchainError.MarketIsClosed = 3;\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/KYCService.ts\nvar KYCService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass KYCService extends BlockchainService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    getKYCAbi() {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            if (KYCService.KYCInfo)\r\n                return KYCService.KYCInfo.abi;\r\n            const response = yield fetch(\"../abi/KYC.json\");\r\n            KYCService.KYCInfo = yield response.json();\r\n            return KYCService.KYCInfo.abi;\r\n        });\r\n    }\r\n    hasValidKYC() {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            if (KYCService.KycResponse && KYCService.KycResponse.isValidKyc)\r\n                return KYCService.KycResponse;\r\n            KYCService.KycResponse = (yield this.get('isValidKyc')\r\n                .catch(reason => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                if (blockchainError.addressIsNotValidKYC()) {\r\n                    return false;\r\n                }\r\n                ErrorInfo.report(blockchainError);\r\n                return false;\r\n            }));\r\n            if (KYCService.KycResponse.alpacaId) {\r\n                App.User.alpacaId = KYCService.KycResponse.alpacaId;\r\n                let aUsdBalance = new AUsdBalance();\r\n                yield aUsdBalance.loadAUSDBalanceUI();\r\n            }\r\n            return KYCService.KycResponse;\r\n        });\r\n    }\r\n    saveKYCInfo(data) {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post(\"kycRegistration\", data);\r\n        });\r\n    }\r\n    updateKYCInfo(data) {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post(\"updateAccount\", data);\r\n        });\r\n    }\r\n    isValidAccountId(str) {\r\n        const regex = new RegExp('^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$');\r\n        return regex.test(str);\r\n    }\r\n    updateDocuments(params) {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.post(\"kycActionRequiredUpdate\", params);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/SecurityTokenService.ts\nvar SecurityTokenService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass SecurityTokenService extends BlockchainService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    getQuantityByAddress(symbol, ethAddress) {\r\n        return SecurityTokenService_awaiter(this, void 0, void 0, function* () {\r\n            let liminalMarketService = new LiminalMarketService();\r\n            let symbolAddress = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n            if (symbolAddress === Helper_AddressZero)\r\n                return new bignumber(0);\r\n            let qty = yield this.getBalanceOf(symbolAddress, ethAddress);\r\n            return new bignumber(formatEther(qty.toString()));\r\n        });\r\n    }\r\n    transfer(symbolAddress, qty) {\r\n        const _super = Object.create(null, {\r\n            transferInner: { get: () => super.transferInner }\r\n        });\r\n        return SecurityTokenService_awaiter(this, void 0, void 0, function* () {\r\n            let result = _super.transferInner.call(this, symbolAddress, this.contracts.AUSD_ADDRESS, qty);\r\n            return result;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/ExecuteTradeButton.html\n// Module\nvar ExecuteTradeButton_code = \"<button id=\\\"liminal_market_execute_trade\\\"></button>\";\n// Exports\n/* harmony default export */ const ExecuteTradeButton = (ExecuteTradeButton_code);\n;// CONCATENATED MODULE: ./src/html/modal/FakeNativeTokenNeeded.html\n// Module\nvar FakeNativeTokenNeeded_code = \"You need to have {{symbol}} currency in your wallet. You use {{symbol}} to pay for using the blockchain.\\r\\n\\r\\nTo get some {{symbol}} currency\\r\\n<ol>\\r\\n    <li>Copy your address shown below\\r\\n        <input value=\\\"{{ethAddress}}\\\" />\\r\\n    </li>\\r\\n    <li>Open <a href=\\\"{{faucetUrl}}\\\" id=\\\"getNativeTokens\\\" target=\\\"_blank\\\">{{faucetUrl}}</a></li>\\r\\n    <li>Paste in your address you just copied and click the submit button</li>\\r\\n</ol>\\r\\n\\r\\n<div class=\\\"infoBar d-none\\\" id=\\\"waitingForNativeToken\\\">Waiting for {{symbol}}. Window will close when you have some in\\r\\n    you wallet.\\r\\n    It might take few minutes after you requested it.\\r\\n    <progress></progress>\\r\\n</div>\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\";\n// Exports\n/* harmony default export */ const FakeNativeTokenNeeded = (FakeNativeTokenNeeded_code);\n;// CONCATENATED MODULE: ./src/html/modal/NativeTokenNeeded.html\n// Module\nvar NativeTokenNeeded_code = \"You need to have {{symbol}} currency in your wallet. You use {{symbol}} to pay for using the blockchain.\\r\\n\\r\\nTo get some {{symbol}} currency\\r\\n<ol>\\r\\n    <li>Copy your address shown below\\r\\n        <input value=\\\"{{ethAddress}}\\\" />\\r\\n    </li>\\r\\n    <li>Open <a href=\\\"{{buyUrl}}\\\" target=\\\"_blank\\\">{{buyUrl}}</a></li>\\r\\n    <li>Paste in your address you just copied and click the submit button</li>\\r\\n</ol>\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\";\n// Exports\n/* harmony default export */ const modal_NativeTokenNeeded = (NativeTokenNeeded_code);\n;// CONCATENATED MODULE: ./src/ui/modals/NativeTokenNeeded.ts\nvar NativeTokenNeeded_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass NativeTokenNeeded {\r\n    constructor(onNativeTokenArrived) {\r\n        this.timeOut = undefined;\r\n        this.onNativeTokenArrived = onNativeTokenArrived;\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        let networkInfo = App.Network;\r\n        let userService = new UserService();\r\n        let ethAddress = userService.getEthAddress();\r\n        if (networkInfo.TestNetwork) {\r\n            let template = Handlebars.compile(FakeNativeTokenNeeded);\r\n            let content = template({ symbol: networkInfo.NativeSymbol, faucetUrl: networkInfo.FaucetUrl, ethAddress: ethAddress });\r\n            this.modal.showModal('Get some ' + networkInfo.NativeSymbol, content, false, () => {\r\n                this.cancelTimer();\r\n            });\r\n        }\r\n        else {\r\n            let template = Handlebars.compile(modal_NativeTokenNeeded);\r\n            let content = template({ symbol: networkInfo.NativeSymbol, buyUrl: networkInfo.BuyUrl, ethAddress: ethAddress });\r\n            this.modal.showModal('Get some ' + networkInfo.NativeSymbol, content, false, () => {\r\n                this.cancelTimer();\r\n            });\r\n        }\r\n        let link = document.getElementById('getNativeTokens');\r\n        if (!link)\r\n            return;\r\n        link.addEventListener('click', () => NativeTokenNeeded_awaiter(this, void 0, void 0, function* () {\r\n            let waitingForNativeToken = document.getElementById('waitingForNativeToken');\r\n            waitingForNativeToken === null || waitingForNativeToken === void 0 ? void 0 : waitingForNativeToken.classList.remove('d-none');\r\n            yield this.checkForNativeTokens();\r\n        }));\r\n    }\r\n    cancelTimer() {\r\n        if (this.timeOut)\r\n            clearTimeout(this.timeOut);\r\n    }\r\n    checkForNativeTokens() {\r\n        return NativeTokenNeeded_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = App.Network;\r\n            let hasEnoughNativeTokens = yield networkInfo.hasEnoughNativeTokens();\r\n            if (hasEnoughNativeTokens) {\r\n                this.modal.hideModal();\r\n                this.onNativeTokenArrived();\r\n            }\r\n            else {\r\n                this.timeOut = setTimeout(() => this.checkForNativeTokens(), 5 * 1000);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycActionRequired.html\n// Module\nvar KycActionRequired_code = \"<div id=\\\"kycActionRequiredDiv\\\">\\r\\n\\r\\n    {{#if Other}}\\r\\n    <strong>This is the message from KYC processor we received</strong>\\r\\n    <blockquote>\\r\\n        {{Other}}\\r\\n    </blockquote>\\r\\n    {{/if}}\\r\\n    <form novalidate id=\\\"kycActionRequiredForm\\\" name=\\\"kycActionRequiredForm\\\" onsubmit=\\\"return false;\\\">\\r\\n        {{{KycInfo}}}\\r\\n        {{#if SubmitData}}\\r\\n        <div class=\\\"input_error\\\" id=\\\"kycActionRequiredError\\\"></div>\\r\\n        <div class=\\\"buttons\\\">\\r\\n            <button type=\\\"submit\\\" id=\\\"kycActionRequiredSubmit\\\">Send new information</button>\\r\\n        </div>\\r\\n        {{/if}}\\r\\n    </form>\\r\\n</div>\\r\\n\\r\\n<div id=\\\"kycActionRequiredSubmittedDiv\\\" class=\\\"hidden center\\\">\\r\\n    <h3>You documents have been submitted.<br/>We will email you when your account is ready.</h3>\\r\\n    You can close this window.\\r\\n</div>\";\n// Exports\n/* harmony default export */ const Kyc_KycActionRequired = (KycActionRequired_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/WeDontKnowWhy.html\n// Module\nvar WeDontKnowWhy_code = \"<fieldset>\\r\\n    Your application has been rejected during KYC process.<br/><br/>\\r\\n    We don't have the information on why that happened, but you can email us at\\r\\n    <a href='mailto:info@liminal.market?subject=My application was rejected&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\\r\\n    and we can find out, and we should be able to solve it together.\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const WeDontKnowWhy = (WeDontKnowWhy_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/IDENTITY_VERIFICATION.html\n// Module\nvar IDENTITY_VERIFICATION_code = \"<fieldset>\\r\\n    <p>\\r\\n        Identity needs to be verified.\\r\\n        This means you need to upload\\r\\n        a new photo of your id. You might try another type of ID, such as\\r\\n        driver's license if you tried passport before\\r\\n    </p>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Photo ID Front (Front of passport)\\\"}}}\\r\\n    </div>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification_2\\\" \\\"Photo ID Back (Passport picture of ID) \\\"}}}\\r\\n    </div>\\r\\n\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const IDENTITY_VERIFICATION = (IDENTITY_VERIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/ADDRESS_VERIFICATION.html\n// Module\nvar ADDRESS_VERIFICATION_code = \"<fieldset>\\r\\n    <p>\\r\\n        Address needs to be verified. Please upload document that confirms your address.\\r\\n        A bill from the government or utility company in that last 30 days with your name it should work.\\r\\n    </p>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"address_verification\\\" \\\"Picture of address verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const ADDRESS_VERIFICATION = (ADDRESS_VERIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/AFFILIATED.html\n// Module\nvar AFFILIATED_code = \"<fieldset>\\r\\n    Further information needs to be submitted if account owner is affiliated to finra or an exchange\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const AFFILIATED = (AFFILIATED_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/CONTROL_PERSON.html\n// Module\nvar CONTROL_PERSON_code = \"<fieldset>\\r\\n    Further information needs to be submitted if account owner is a control person\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const CONTROL_PERSON = (CONTROL_PERSON_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/COUNTRY_NOT_SUPPORTED.html\n// Module\nvar COUNTRY_NOT_SUPPORTED_code = \"<fieldset>\\r\\n    The account owners country of tax residence is not supported by our KYC providers.\\r\\n    In this case, well manually perform KYC on the user\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const COUNTRY_NOT_SUPPORTED = (COUNTRY_NOT_SUPPORTED_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/DATE_OF_BIRTH.html\n// Module\nvar DATE_OF_BIRTH_code = \"<fieldset>\\r\\n    Date of birth needs to be verified. Please upload document that confirms your date of birth.\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"date_of_birth_verification\\\" \\\"Date of birth verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const DATE_OF_BIRTH = (DATE_OF_BIRTH_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/FAMILY_MEMBER_PEP.html\n// Module\nvar FAMILY_MEMBER_PEP_code = \"<fieldset>\\r\\n    Further information needs to be submitted if family member is a politically exposed person\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const FAMILY_MEMBER_PEP = (FAMILY_MEMBER_PEP_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/INVALID_IDENTITY_PASSPORT.html\n// Module\nvar INVALID_IDENTITY_PASSPORT_code = \"<fieldset>\\r\\n    Identity needs to be verified via a government issued ID.\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Photo ID Front (Front of passport)\\\"}}}\\r\\n    </div>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification_2\\\" \\\"Photo ID Back (Passport picture of ID) \\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const INVALID_IDENTITY_PASSPORT = (INVALID_IDENTITY_PASSPORT_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/PEP.html\n// Module\nvar PEP_code = \"<fieldset>\\r\\n    Further information needs to be submitted if account owner is politically exposed person\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const PEP = (PEP_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/SELFIE_VERIFICATION.html\n// Module\nvar SELFIE_VERIFICATION_code = \"<fieldset>\\r\\n    Identity needs to be verified via a live selfie of the account owner\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Live selfie verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const SELFIE_VERIFICATION = (SELFIE_VERIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/TAX_IDENTIFICATION.html\n// Module\nvar TAX_IDENTIFICATION_code = \"<fieldset>\\r\\n    Tax ID number needs to be verified. Please upload document that confirms your Tax Id\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"tax_id_verification\\\" \\\"Tax id verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const TAX_IDENTIFICATION = (TAX_IDENTIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/VISA_TYPE_OTHER.html\n// Module\nvar VISA_TYPE_OTHER_code = \"<fieldset>\\r\\n    Further information needs to be submitted about account owners visa\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const VISA_TYPE_OTHER = (VISA_TYPE_OTHER_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/W8BEN_CORRECTION.html\n// Module\nvar W8BEN_CORRECTION_code = \"<fieldset>\\r\\n    Identifying information submitted by the user was incorrect so a new, corrected, W8BEN needs to be submitted\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const W8BEN_CORRECTION = (W8BEN_CORRECTION_code);\n;// CONCATENATED MODULE: ./src/html/elements/FileUpload.html\n// Module\nvar FileUpload_code = \"<div>\\r\\n    <label for=\\\"{{inputId}}\\\">{{label}}</label>\\r\\n    <input type=\\\"file\\\" required id=\\\"{{inputId}}\\\" accept=\\\"{{accept}}\\\" capture=\\\"{{capture}}\\\"/>\\r\\n    <input type=\\\"hidden\\\" id=\\\"{{inputId}}_base64\\\" name=\\\"{{inputId}}_base64\\\"/>\\r\\n    <div class=\\\"error hidden\\\" id=\\\"{{inputId}}_error\\\"></div>\\r\\n</div>\\r\\n<div id=\\\"{{inputId}}_preview\\\">\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const elements_FileUpload = (FileUpload_code);\n;// CONCATENATED MODULE: ./src/ui/elements/FileUpload.ts\n\r\nclass FileUpload {\r\n    constructor(inputId, label, accept = \"image/png,image/jpeg,.pdf\", capture = 'environment') {\r\n        this.maxFileSize = 8 * 1024 * 1024 * 10; //10MB\r\n        this.accept = \"image/*,.pdf\";\r\n        this.capture = 'environment';\r\n        this.inputId = inputId;\r\n        this.label = label;\r\n        this.accept = accept;\r\n        this.capture = capture;\r\n    }\r\n    render() {\r\n        let template = Handlebars.compile(elements_FileUpload);\r\n        return template(this);\r\n    }\r\n    bindEvents() {\r\n        let fileInput = document.getElementById(this.inputId);\r\n        fileInput === null || fileInput === void 0 ? void 0 : fileInput.addEventListener('change', (evt) => {\r\n            this.processFile(fileInput);\r\n        });\r\n    }\r\n    processFile(element) {\r\n        this.hideFileRelatedInfo(element.id);\r\n        let files = element.files;\r\n        if (!files)\r\n            return;\r\n        let file = files[0];\r\n        if (!file) {\r\n            this.showFileRelatedInfo(element.id, 'No file selected. Please select file.');\r\n            this.setBase64Input(element.id, '');\r\n            return;\r\n        }\r\n        if (file.size > this.maxFileSize) {\r\n            this.showFileRelatedInfo(element.id, 'File ' + file.name + ' is to large. Files cannot be larger then 10MB. You need to make it smaller before submitting your application');\r\n            this.setBase64Input(element.id, '');\r\n            return;\r\n        }\r\n        let reader = new FileReader();\r\n        reader.addEventListener('load', () => {\r\n            this.setBase64Input(element.id, reader.result);\r\n        });\r\n        reader.addEventListener('error', () => {\r\n            this.showFileRelatedInfo(element.id, 'Could not read file ' + file.name + '. Either the file is corrupt or your browser does not allow us to read it');\r\n        });\r\n        reader.readAsDataURL(file);\r\n    }\r\n    setBase64Input(elementId, value) {\r\n        let base64Input = document.getElementById(elementId + '_base64');\r\n        base64Input.value = value;\r\n        let previewElement = document.getElementById(elementId + '_preview');\r\n        if (!previewElement)\r\n            return;\r\n        if (value.indexOf('data:image') != -1) {\r\n            previewElement.innerHTML = '<img src=\"' + base64Input.value + '\" />';\r\n        }\r\n        else {\r\n            previewElement.innerHTML = '';\r\n        }\r\n    }\r\n    showFileRelatedInfo(elementId, text) {\r\n        let fileRelatedInfo = document.getElementById(elementId + '_error');\r\n        if (!fileRelatedInfo)\r\n            return;\r\n        fileRelatedInfo.innerHTML = text;\r\n        fileRelatedInfo.classList.remove('hidden');\r\n    }\r\n    hideFileRelatedInfo(elementId) {\r\n        let fileRelatedInfo = document.getElementById(elementId + '_error');\r\n        if (!fileRelatedInfo)\r\n            return;\r\n        fileRelatedInfo.classList.add('hidden');\r\n    }\r\n    static registerHandler() {\r\n        Handlebars.registerHelper('fileUpload', (id, label) => {\r\n            let fileUpload = new FileUpload(id, label);\r\n            FileUpload.fileUploads.push(fileUpload);\r\n            return fileUpload.render();\r\n        });\r\n    }\r\n}\r\nFileUpload.fileUploads = [];\r\n\n;// CONCATENATED MODULE: ./src/util/FormValidator.ts\n\r\nclass FormValidator {\r\n    constructor(selector) {\r\n        this.selector = selector;\r\n    }\r\n    validateRequiredFields() {\r\n        let inputs = document.querySelectorAll(this.selector + ' input[required], ' + this.selector + ' select[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (this.isMissingInputFromUser(input)) {\r\n                let obj = {\r\n                    message: 'You must fill into this field',\r\n                    inputName: input.id,\r\n                    labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                    pattern: input.pattern\r\n                };\r\n                this.handle(obj);\r\n                return false;\r\n            }\r\n            if (input.pattern) {\r\n                let pattern = input.pattern;\r\n                let matches = input.value.match(pattern);\r\n                if (matches == null) {\r\n                    let obj = {\r\n                        message: 'This is not valid date format, please use YYYY-MM-DD (year-month-date)',\r\n                        inputName: input.id,\r\n                        labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                        pattern: input.pattern\r\n                    };\r\n                    this.handle(obj);\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    isMissingInputFromUser(input) {\r\n        return ((input.type == 'checkbox' && !input.checked) || StringHelper.isNullOrEmpty(input.value));\r\n    }\r\n    removeMissingInfo(errorDivId, focusElementId) {\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.style.display = 'none';\r\n        if (!focusElementId)\r\n            return;\r\n        let focusElement = document.getElementById(focusElementId);\r\n        if (focusElement) {\r\n            focusElement.removeAttribute('aria-invalid');\r\n        }\r\n    }\r\n    setMissingInfo(errorDivId, text, focusElementId) {\r\n        var _a, _b;\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = text;\r\n        if (text == '') {\r\n            element.style.display = 'none';\r\n        }\r\n        else {\r\n            element.style.display = 'block';\r\n            if (focusElementId) {\r\n                (_a = document.getElementById(focusElementId)) === null || _a === void 0 ? void 0 : _a.focus();\r\n                (_b = document.getElementById(focusElementId)) === null || _b === void 0 ? void 0 : _b.setAttribute('aria-invalid', 'true');\r\n            }\r\n        }\r\n    }\r\n    handle(obj) {\r\n        let input = document.getElementById(obj.inputName);\r\n        if (!input)\r\n            return;\r\n        let inputError = input.parentElement.querySelector('.input_error');\r\n        if (inputError) {\r\n            inputError.scrollIntoView({ block: 'center' });\r\n            return;\r\n        }\r\n        input.setAttribute('aria-invalid', 'true');\r\n        input.insertAdjacentHTML(\"beforebegin\", '<div class=\"input_error\" style=\"display: block\" id=\"input_error_' + obj.inputName + '\">' + obj.message + '</div>');\r\n        input.focus();\r\n        if (obj.pattern) {\r\n            input.setAttribute('pattern', obj.pattern);\r\n        }\r\n        input.addEventListener('blur', (evt) => {\r\n            evt.preventDefault();\r\n            setTimeout(() => {\r\n                let input = evt.target;\r\n                let pattern = input.getAttribute('pattern');\r\n                if ((pattern && input.value.match(pattern)) || (input.required && input.value) || input.checked) {\r\n                    input.removeAttribute('aria-invalid');\r\n                    let errorMessage = document.getElementById('input_error_' + obj.inputName);\r\n                    if (errorMessage)\r\n                        errorMessage.remove();\r\n                }\r\n            }, 800);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycActionRequired.ts\nvar KycActionRequired_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycActionRequired {\r\n    constructor(executeTradeButton) {\r\n        this.modal = new Modal();\r\n        this.templates = new Map();\r\n        this.executeTradeButton = executeTradeButton;\r\n        this.templates.set('WeDontKnowWhyHtml', WeDontKnowWhy);\r\n        this.templates.set('ADDRESS_VERIFICATION', ADDRESS_VERIFICATION);\r\n        this.templates.set('AFFILIATED', AFFILIATED);\r\n        this.templates.set('CONTROL_PERSON', CONTROL_PERSON);\r\n        this.templates.set('COUNTRY_NOT_SUPPORTED', COUNTRY_NOT_SUPPORTED);\r\n        this.templates.set('DATE_OF_BIRTH', DATE_OF_BIRTH);\r\n        this.templates.set('FAMILY_MEMBER_PEP', FAMILY_MEMBER_PEP);\r\n        this.templates.set('IDENTITY_VERIFICATION', IDENTITY_VERIFICATION);\r\n        this.templates.set('INVALID_IDENTITY_PASSPORT', INVALID_IDENTITY_PASSPORT);\r\n        this.templates.set('PEP', PEP);\r\n        this.templates.set('SELFIE_VERIFICATION', SELFIE_VERIFICATION);\r\n        this.templates.set('TAX_IDENTIFICATION', TAX_IDENTIFICATION);\r\n        this.templates.set('VISA_TYPE_OTHER', VISA_TYPE_OTHER);\r\n        this.templates.set('W8BEN_CORRECTION', W8BEN_CORRECTION);\r\n        FileUpload.registerHandler();\r\n    }\r\n    show() {\r\n        return KycActionRequired_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService();\r\n            let kycResult = yield userService.kycActionRequired();\r\n            if (!kycResult)\r\n                return;\r\n            let kycInfo = this.getKycMessages(kycResult.messages);\r\n            let template = Handlebars.compile(Kyc_KycActionRequired);\r\n            let content = template({\r\n                json: JSON.stringify(kycResult),\r\n                KycInfo: kycInfo,\r\n                Other: kycResult.additional_information,\r\n                SubmitData: kycInfo.indexOf('<input') != -1\r\n            });\r\n            this.modal.showModal('Action required', content, false, () => {\r\n            }, false);\r\n            let kycActionRequiredForm = document.getElementById('kycActionRequiredForm');\r\n            kycActionRequiredForm === null || kycActionRequiredForm === void 0 ? void 0 : kycActionRequiredForm.addEventListener('submit', (evt) => KycActionRequired_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                this.hideError();\r\n                let submitBtn = document.getElementById('kycActionRequiredSubmit');\r\n                LoadingHelper.setLoading(submitBtn);\r\n                let formValidator = new FormValidator('#kycActionRequiredForm');\r\n                if (!formValidator.validateRequiredFields())\r\n                    return;\r\n                let params = FormHelper.getParams('#kycActionRequiredForm');\r\n                let kycService = new KYCService();\r\n                yield kycService.updateDocuments(params)\r\n                    .then(() => {\r\n                    let kycActionRequiredDiv = document.getElementById('kycActionRequiredDiv');\r\n                    kycActionRequiredDiv === null || kycActionRequiredDiv === void 0 ? void 0 : kycActionRequiredDiv.classList.add('hidden');\r\n                    let kycActionRequiredSubmittedDiv = document.getElementById('kycActionRequiredSubmittedDiv');\r\n                    kycActionRequiredSubmittedDiv === null || kycActionRequiredSubmittedDiv === void 0 ? void 0 : kycActionRequiredSubmittedDiv.classList.remove('hidden');\r\n                    this.executeTradeButton.renderButton();\r\n                })\r\n                    .catch(reason => {\r\n                    this.showError(reason);\r\n                }).finally(() => {\r\n                    LoadingHelper.removeLoading();\r\n                });\r\n            }));\r\n            for (let i = 0; i < FileUpload.fileUploads.length; i++) {\r\n                FileUpload.fileUploads[i].bindEvents();\r\n            }\r\n        });\r\n    }\r\n    getKycMessages(messages) {\r\n        let kycInfo = '';\r\n        for (let i = 0; i < messages.length; i++) {\r\n            let htmlTemplate = this.templates.get(messages[i].key);\r\n            if (!htmlTemplate) {\r\n                //TODO: Here we should to logger, critical that we dont know why\r\n                continue;\r\n            }\r\n            let template = Handlebars.compile(htmlTemplate);\r\n            kycInfo += template({ message: messages[i].message });\r\n        }\r\n        if (kycInfo == '') {\r\n            let html = this.templates.get('WeDontKnowWhyHtml');\r\n            let template = Handlebars.compile(html);\r\n            kycInfo = template({});\r\n        }\r\n        return kycInfo;\r\n    }\r\n    hideError() {\r\n        let kycActionRequiredError = document.getElementById('kycActionRequiredError');\r\n        if (!kycActionRequiredError)\r\n            return;\r\n        kycActionRequiredError.style.display = 'none';\r\n    }\r\n    showError(reason) {\r\n        let kycActionRequiredError = document.getElementById('kycActionRequiredError');\r\n        if (!kycActionRequiredError)\r\n            return;\r\n        kycActionRequiredError.innerHTML = 'Error occurred while saving your documents. Reason:' + reason;\r\n        kycActionRequiredError.style.display = 'block';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/KYCModal.html\n// Module\nvar KYCModal_code = \"<div id=\\\"kyc_reg\\\">\\r\\n\\r\\n    <form id=\\\"kyc_wizard_form\\\" name=\\\"kyc_wizard_form\\\" novalidate onsubmit=\\\"return false\\\">\\r\\n        {{{KycContactHtml}}}\\r\\n        {{{KycIdentityHtml}}}\\r\\n        {{{KycTrustedContactHtml}}}\\r\\n        {{{KycDisclosureHtml}}}\\r\\n        {{{KycUploadHtml}}}\\r\\n        {{{KycAccountAgreementHtml}}}\\r\\n    </form>\\r\\n</div>\\r\\n\\r\\n<div id=\\\"waiting_for_kyc_reg\\\" class=\\\"hidden\\\">\\r\\n    KYC is being processed. This may take about 4-5 minutes. Window will close when it's done.\\r\\n    <br/><br/>\\r\\n    You can close the window, we will email you when KYC is finished.\\r\\n\\r\\n    <progress></progress>\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const KYCModal = (KYCModal_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycContact.html\n// Module\nvar KycContact_code = \"<fieldset class=\\\"kycContact hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"explain\\\">\\r\\n        To be able to trade on the stock market, we need to get your information.\\r\\n        This is a requirement from the financial regulators.\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"email_address\\\">Email</label>\\r\\n        <input type=\\\"email\\\" required class=\\\"form-control\\\" id=\\\"email_address\\\" name=\\\"email_address\\\"\\r\\n               placeholder=\\\"name@example.com\\\" autocomplete=\\\"email\\\"\\r\\n               value=\\\"\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"phone_number\\\">Phone</label>\\r\\n        <input type=\\\"tel\\\" class=\\\"form-control\\\" id=\\\"phone_number\\\" name=\\\"phone_number\\\"\\r\\n               placeholder=\\\"+1-555-666-7788\\\" autocomplete=\\\"tel\\\" value=\\\"\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"street_address\\\">Permanent Residential Address</label>\\r\\n        <div class=\\\"explain\\\">It must be a physical address, not a PO box.</div>\\r\\n        <input required id=\\\"street_address\\\" name=\\\"street_address\\\"\\r\\n               placeholder=\\\"20 N San Mateo Dr\\\" value=\\\"\\\" autocomplete=\\\"address-line1\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"unit\\\">Unit / Apt #</label>\\r\\n        <input id=\\\"unit\\\" name=\\\"unit\\\" value=\\\"\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"city\\\">City</label>\\r\\n        <input id=\\\"city\\\" name=\\\"city\\\" placeholder=\\\"Pawnee\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"address-level2\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"postal_code\\\">Postal code</label>\\r\\n        <input required id=\\\"postal_code\\\" autocomplete=\\\"postal-code\\\" name=\\\"postal_code\\\"\\r\\n               placeholder=\\\"94401\\\"\\r\\n               value=\\\"\\\">\\r\\n    </div>\\r\\n    <div id=\\\"state_div\\\">\\r\\n        <label for=\\\"state\\\">State (2 letters)</label>\\r\\n        <input maxlength=\\\"2\\\" id=\\\"state\\\" name=\\\"state\\\" placeholder=\\\"NY\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"address-level1\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"country_of_tax_residence\\\">Country of tax residence</label>\\r\\n        {{#if edit}}\\r\\n        <input name=\\\"country_of_tax_residence\\\" readonly id=\\\"country_of_tax_residence\\\"/>\\r\\n        {{/if}}\\r\\n        {{#unless edit}}\\r\\n        <select required id=\\\"country_of_tax_residence\\\" name=\\\"country_of_tax_residence\\\" autocomplete=\\\"country\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n        {{/unless}}\\r\\n    </div>\\r\\n    <div class=\\\"buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"contact_next\\\">Next: Identity</button>\\r\\n    </div>\\r\\n</fieldset>\\r\\n\";\n// Exports\n/* harmony default export */ const Kyc_KycContact = (KycContact_code);\n;// CONCATENATED MODULE: ./src/errors/cloud/KycValidatorError.ts\nvar KycValidatorError_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass KycValidatorError {\r\n    constructor(error, kycForm) {\r\n        var _a, _b;\r\n        this.validValues = '';\r\n        this.inputName = '';\r\n        this.labelText = '';\r\n        this.pattern = '';\r\n        let obj = {};\r\n        try {\r\n            if (!error.inputName) {\r\n                obj = JSON.parse(error);\r\n            }\r\n            else {\r\n                obj = error;\r\n            }\r\n            this.message = (_a = obj.message) === null || _a === void 0 ? void 0 : _a.replace(/_/g, ' ');\r\n            this.validValues = (_b = obj.validValues) === null || _b === void 0 ? void 0 : _b.replace(/_/g, ' ');\r\n            this.inputName = obj.inputName;\r\n            this.labelText = obj.labelText;\r\n            this.pattern = obj.pattern;\r\n            this.onshow = obj.onshow;\r\n        }\r\n        catch (e) {\r\n            this.message = error.messsage;\r\n        }\r\n        this.kycForm = kycForm;\r\n    }\r\n    handle() {\r\n        if (StringHelper.isNullOrEmpty(this.inputName)) {\r\n            let activeFieldset = document.querySelector(this.kycForm.activeFieldsetSelector);\r\n            let inputError = activeFieldset.querySelector('.input_error');\r\n            if (inputError) {\r\n                if (this.validValues) {\r\n                    inputError.innerHTML = this.validValues.toString();\r\n                }\r\n                else {\r\n                    if (this.message && this.message.indexOf('Invalid function') != -1 || this.message.indexOf('Unable to connect to the Parse API') != -1) {\r\n                        inputError.innerHTML = 'We just deployed new version of our website. This can cause interruption. Please wait 30 seconds and submit again';\r\n                    }\r\n                    else {\r\n                        inputError.innerHTML = this.message;\r\n                    }\r\n                }\r\n                inputError.style.display = 'block';\r\n                inputError.scrollIntoView();\r\n            }\r\n            return;\r\n        }\r\n        let input = document.getElementById(this.inputName);\r\n        if (!input)\r\n            return;\r\n        let inputError = input.parentElement.querySelector('.input_error');\r\n        if (inputError) {\r\n            inputError.scrollIntoView({ block: 'center' });\r\n            return;\r\n        }\r\n        input.setAttribute('aria-invalid', 'true');\r\n        let errorInput = '<div class=\"input_error\" style=\"display: block\" id=\"input_error_' + this.inputName + '\">' + this.message + '</div>';\r\n        if (input.clientWidth < 300) {\r\n            let div = this.getDivToDisplayErrorMessage(input);\r\n            div.insertAdjacentHTML(\"beforebegin\", errorInput);\r\n        }\r\n        else {\r\n            input.insertAdjacentHTML(\"beforebegin\", errorInput);\r\n        }\r\n        input.focus();\r\n        if (this.pattern) {\r\n            input.setAttribute('pattern', this.pattern);\r\n        }\r\n        input.addEventListener('blur', (evt) => {\r\n            evt.preventDefault();\r\n            setTimeout(() => {\r\n                let input = evt.target;\r\n                let pattern = input.getAttribute('pattern');\r\n                if ((pattern && input.value.match(pattern)) || (input.type != 'checkbox' && input.type != 'radio' && input.required && input.value) || input.checked) {\r\n                    input.removeAttribute('aria-invalid');\r\n                    let errorMessage = document.getElementById('input_error_' + this.inputName);\r\n                    if (errorMessage)\r\n                        errorMessage.remove();\r\n                }\r\n            }, 800);\r\n        });\r\n        let fieldsetElement = input.closest('fieldset[data-form=\"1\"]');\r\n        if (fieldsetElement) {\r\n            let className = fieldsetElement.className.replace('hidden', '').trim();\r\n            this.kycForm.show(className);\r\n            input.scrollIntoView(false);\r\n        }\r\n        if (this.onshow) {\r\n            let link = document.getElementById(this.onshow.id);\r\n            if (!link)\r\n                return;\r\n            link.addEventListener('click', (evt) => KycValidatorError_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                yield Moralis.Cloud.run(this.onshow.functionName, this.onshow.params);\r\n                document.getElementById('input_error_' + this.inputName).innerHTML = 'Email has been sent to ' + this.onshow.params.email;\r\n            }));\r\n        }\r\n    }\r\n    getDivToDisplayErrorMessage(input, counter = 1) {\r\n        let div = input.parentElement.closest('div');\r\n        if (!div)\r\n            return input;\r\n        if (div.clientWidth > 300 || counter > 5) {\r\n            return div;\r\n        }\r\n        return this.getDivToDisplayErrorMessage(div, ++counter);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycBase.ts\n\r\n\r\n\r\nclass KycBase {\r\n    constructor(kycForm) {\r\n        this.kycForm = kycForm;\r\n        FileUpload.registerHandler();\r\n    }\r\n    showFieldset(selector, header) {\r\n        var _a;\r\n        this.hideFieldsets();\r\n        (_a = document.querySelector(selector)) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n        document.querySelector('#liminal_market_modal_div > article > header > span').innerHTML = header;\r\n        document.querySelector('#liminal_market_modal_div > article').scrollTop = 0;\r\n        this.kycForm.activeFieldsetSelector = selector;\r\n    }\r\n    showRequiredMarker() {\r\n        let inputs = document.querySelectorAll('input, select');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (!input.id)\r\n                continue;\r\n            let label = document.querySelector('label[for=' + input.id + ']');\r\n            if (!label)\r\n                continue;\r\n            if (input.required) {\r\n                if (label.innerHTML.indexOf('*') == -1) {\r\n                    label.innerHTML += '*';\r\n                }\r\n            }\r\n            else {\r\n                if (label.innerHTML.indexOf('*') != -1) {\r\n                    label.innerHTML = label.innerHTML.replace('*', '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setRequired(inputId) {\r\n        var _a;\r\n        (_a = document.getElementById(inputId)) === null || _a === void 0 ? void 0 : _a.setAttribute('required', 'required');\r\n    }\r\n    removeRequired(inputId) {\r\n        var _a;\r\n        (_a = document.getElementById(inputId)) === null || _a === void 0 ? void 0 : _a.removeAttribute('required');\r\n    }\r\n    bind(selector, eventName, action) {\r\n        let elements = document.querySelectorAll(selector);\r\n        for (let i = 0; i < elements.length; i++) {\r\n            elements[i].addEventListener(eventName, (evt) => {\r\n                action(evt);\r\n            });\r\n        }\r\n    }\r\n    bindFileUploads() {\r\n        for (let i = 0; i < FileUpload.fileUploads.length; i++) {\r\n            FileUpload.fileUploads[i].bindEvents();\r\n        }\r\n    }\r\n    hideFieldsets() {\r\n        let fieldsets = document.querySelectorAll('#kyc_wizard_form > fieldset');\r\n        for (let i = 0; i < fieldsets.length; i++) {\r\n            fieldsets[i].classList.add('hidden');\r\n        }\r\n    }\r\n    validateRequiredFields(selector) {\r\n        let inputs = document.querySelectorAll(selector + ' input[required], ' + selector + ' select[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (this.isMissingInputFromUser(input)) {\r\n                let obj = {\r\n                    message: 'You must fill into this field',\r\n                    inputName: input.id,\r\n                    labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                    pattern: input.pattern\r\n                };\r\n                let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n                kycValidationError.handle();\r\n                return false;\r\n            }\r\n            if (input.pattern) {\r\n                let pattern = input.pattern;\r\n                let matches = input.value.match(pattern);\r\n                if (matches == null) {\r\n                    let obj = {\r\n                        message: 'This is not valid date format, please use YYYY-MM-DD (year-month-date)',\r\n                        inputName: input.id,\r\n                        labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                        pattern: input.pattern\r\n                    };\r\n                    let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n                    kycValidationError.handle();\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    showElement(elementId) {\r\n        var _a;\r\n        (_a = document.getElementById(elementId)) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n    }\r\n    hideElement(elementId) {\r\n        var _a;\r\n        (_a = document.getElementById(elementId)) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n    }\r\n    setLabel(elementId, text) {\r\n        let element = document.getElementById('tax_id_label');\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = text;\r\n    }\r\n    isMissingInputFromUser(input) {\r\n        return ((input.type == 'checkbox' && !input.checked) || StringHelper.isNullOrEmpty(input.value));\r\n    }\r\n    removeMissingInfo(errorDivId, focusElementId) {\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.style.display = 'none';\r\n        if (!focusElementId)\r\n            return;\r\n        let focusElement = document.getElementById(focusElementId);\r\n        if (focusElement) {\r\n            focusElement.removeAttribute('aria-invalid');\r\n        }\r\n    }\r\n    setMissingInfo(errorDivId, text, focusElementId) {\r\n        var _a, _b;\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = text;\r\n        if (text == '') {\r\n            element.style.display = 'none';\r\n        }\r\n        else {\r\n            element.style.display = 'block';\r\n            if (focusElementId) {\r\n                (_a = document.getElementById(focusElementId)) === null || _a === void 0 ? void 0 : _a.focus();\r\n                (_b = document.getElementById(focusElementId)) === null || _b === void 0 ? void 0 : _b.setAttribute('aria-invalid', 'true');\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycContact.ts\n\r\n\r\n\r\nclass KycContact extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.usTaxResidence = false;\r\n    }\r\n    render(edit = false) {\r\n        let template = Handlebars.compile(Kyc_KycContact);\r\n        return template({ edit: edit, countries: CountryHelper.Countries });\r\n    }\r\n    show() {\r\n        this.showFieldset('.kycContact', 'Contact information');\r\n    }\r\n    bindEvents() {\r\n        this.bind('#country_of_tax_residence', 'change', (evt) => {\r\n            var _a, _b;\r\n            let input = evt.target;\r\n            this.usTaxResidence = (input.value.toUpperCase() == 'USA');\r\n            if (this.usTaxResidence) {\r\n                (_a = document.getElementById('state_div')) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n                this.kycForm.setSteps(5);\r\n                this.setRequired('state');\r\n            }\r\n            else {\r\n                this.kycForm.setSteps(6);\r\n                this.removeRequired('state');\r\n                (_b = document.getElementById('state_div')) === null || _b === void 0 ? void 0 : _b.classList.add('hidden');\r\n            }\r\n        });\r\n        let showIdentityButton = document.getElementById('contact_next');\r\n        if (showIdentityButton) {\r\n            showIdentityButton.addEventListener('click', (evt) => {\r\n                if (!this.validateRequiredFields('.kycContact'))\r\n                    return;\r\n                this.kycForm.kycIdentity.show();\r\n            });\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycIdentity.html\n// Module\nvar KycIdentity_code = \"<fieldset class=\\\"kycIdentity hidden\\\" data-form=\\\"1\\\">\\r\\n    <div>\\r\\n        <label for=\\\"given_name\\\">Legal First name</label>\\r\\n        <input required id=\\\"given_name\\\" name=\\\"given_name\\\"\\r\\n               placeholder=\\\"Ron\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"given-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"middle_name\\\">Legal Middle name</label>\\r\\n        <input id=\\\"middle_name\\\" name=\\\"middle_name\\\"\\r\\n               placeholder=\\\"\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"additional-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"family_name\\\">Legal Last name</label>\\r\\n        <input required id=\\\"family_name\\\" name=\\\"family_name\\\"\\r\\n               placeholder=\\\"Swanson\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"family-name\\\">\\r\\n    </div>\\r\\n    {{#unless edit}}\\r\\n    <div>\\r\\n        <label for=\\\"date_of_birth\\\">Date of birth</label>\\r\\n        <input type=\\\"date\\\" required id=\\\"date_of_birth\\\" name=\\\"date_of_birth\\\"\\r\\n               placeholder=\\\"1978-11-24\\\" pattern=\\\"\\\\d{4}-\\\\d{2}-\\\\d{2}\\\" value=\\\"\\\" autocomplete=\\\"bday\\\">\\r\\n    </div>\\r\\n\\r\\n    <div id=\\\"citizen_of_usa_question\\\" class=\\\"hidden\\\">\\r\\n        <label for=\\\"citizen_yes\\\">Are you a citizen of the United States?</label>\\r\\n        <fieldset>\\r\\n            <label>\\r\\n                <input type=\\\"radio\\\" id=\\\"citizen_yes\\\"\\r\\n                       name=\\\"citizen\\\" value=\\\"1\\\"> Yes\\r\\n            </label>\\r\\n            <label>\\r\\n                <input type=\\\"radio\\\" id=\\\"citizen_no\\\"\\r\\n                       name=\\\"citizen\\\" value=\\\"0\\\"> No\\r\\n            </label>\\r\\n            <fieldset id=\\\"citizen_no_type_options\\\" class=\\\"hidden\\\">\\r\\n                <label>\\r\\n                    <input type=\\\"radio\\\" name=\\\"permanent_resident\\\" id=\\\"citizen_no_type_options_1\\\" value=\\\"1\\\"/> Green Card\\r\\n                    / Permanent Resident\\r\\n                </label>\\r\\n                <label><input type=\\\"radio\\\" name=\\\"permanent_resident\\\" id=\\\"citizen_no_type_options_2\\\" value=\\\"0\\\"/>\\r\\n                    Visa</label>\\r\\n            </fieldset>\\r\\n        </fieldset>\\r\\n    </div>\\r\\n    <div id=\\\"tax_id_type_options\\\">\\r\\n        <label for=\\\"tax_id_type\\\">Tax Id Type</label>\\r\\n        <select required id=\\\"tax_id_type\\\" name=\\\"tax_id_type\\\" placeholder=\\\"USA_SSN\\\">\\r\\n            <option value=\\\"USA_SSN\\\"></option>\\r\\n            <option value=\\\"ARG_AR_CUIT\\\">Argentina CUIT</option>\\r\\n            <option value=\\\"AUS_TFN\\\">Australian Tax File Number</option>\\r\\n            <option value=\\\"AUS_ABN\\\">Australian Business Number</option>\\r\\n            <option value=\\\"BOL_NIT\\\">Bolivia NIT</option>\\r\\n            <option value=\\\"BRA_CPF\\\">Brazil CPF</option>\\r\\n            <option value=\\\"CHL_RUT\\\">Chile RUT</option>\\r\\n            <option value=\\\"COL_NIT\\\">Colombia NIT</option>\\r\\n            <option value=\\\"CRI_NITE\\\">Costa Rica NITE</option>\\r\\n            <option value=\\\"DEU_TAX_ID\\\">Germany Tax ID (Identifikationsnummer)</option>\\r\\n            <option value=\\\"DOM_RNC\\\">Dominican Republic RNC</option>\\r\\n            <option value=\\\"ECU_RUC\\\">Ecuador RUC</option>\\r\\n            <option value=\\\"FRA_SPI\\\">France SPI (Reference Tax Number)</option>\\r\\n            <option value=\\\"GBR_UTR\\\">UK UTR (Unique Taxpayer Reference)</option>\\r\\n            <option value=\\\"GBR_NINO\\\">UK NINO (National Insurance Number)</option>\\r\\n            <option value=\\\"GTM_NIT\\\">Guatemala NIT</option>\\r\\n            <option value=\\\"HND_RTN\\\">Honduras RTN</option>\\r\\n            <option value=\\\"HUN_TIN\\\">Hungary TIN Number</option>\\r\\n            <option value=\\\"IDN_KTP\\\">Indonesia KTP</option>\\r\\n            <option value=\\\"IND_PAN\\\">India PAN Number</option>\\r\\n            <option value=\\\"ISR_TAX_ID\\\">Israel Tax ID (Teudat Zehut)</option>\\r\\n            <option value=\\\"ITA_TAX_ID\\\">Italy Tax ID (Codice Fiscale)</option>\\r\\n            <option value=\\\"JPN_TAX_ID\\\">Japan Tax ID (Koijin Bango)</option>\\r\\n            <option value=\\\"MEX_RFC\\\">Mexico RFC</option>\\r\\n            <option value=\\\"NIC_RUC\\\">Nicaragua RUC</option>\\r\\n            <option value=\\\"NLD_TIN\\\">Netherlands TIN Number</option>\\r\\n            <option value=\\\"PAN_RUC\\\">Panama RUC</option>\\r\\n            <option value=\\\"PER_RUC\\\">Peru RUC</option>\\r\\n            <option value=\\\"PRY_RUC\\\">Paraguay RUC</option>\\r\\n            <option value=\\\"SGP_NRIC\\\">Singapore NRIC</option>\\r\\n            <option value=\\\"SGP_FIN\\\">Singapore FIN</option>\\r\\n            <option value=\\\"SGP_ASGD\\\">Singapore ASGD</option>\\r\\n            <option value=\\\"SGP_ITR\\\">Singapore ITR</option>\\r\\n            <option value=\\\"SLV_NIT\\\">El Salvador NIT</option>\\r\\n            <option value=\\\"SWE_TAX_ID\\\">Sweden Tax ID (Personnummer)</option>\\r\\n            <option value=\\\"URY_RUT\\\">Uruguay RUT</option>\\r\\n            <option value=\\\"VEN_RIF\\\">Venezuela RIF</option>\\r\\n            <option value=\\\"NOT_SPECIFIED\\\">Other Tax IDs</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label id=\\\"tax_id_label\\\" for=\\\"tax_id\\\">Tax Id (SSN)</label>\\r\\n        <input required id=\\\"tax_id\\\" name=\\\"tax_id\\\"\\r\\n               placeholder=\\\"666-55-4321\\\"\\r\\n               value=\\\"\\\">\\r\\n    </div>\\r\\n    <div id=\\\"country_of_birth_option\\\">\\r\\n        <label for=\\\"country_of_birth\\\">Country of birth</label>\\r\\n        <select id=\\\"country_of_birth\\\" name=\\\"country_of_birth\\\">\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    <div id=\\\"country_of_citizenship_option\\\">\\r\\n        <label for=\\\"country_of_citizenship\\\">Country of citizenship</label>\\r\\n        <select required id=\\\"country_of_citizenship\\\" name=\\\"country_of_citizenship\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    <div id=\\\"visa_type_option\\\" class=\\\"hidden\\\">\\r\\n        <div>\\r\\n            <label for=\\\"visa_type\\\">Visa type - <a\\r\\n                    href=\\\"https://travel.state.gov/content/travel/en/us-visas/visa-information-resources/all-visa-categories.html\\\"\\r\\n                    target=\\\"_blank\\\">Visa\\r\\n                information</a></label>\\r\\n            <select id=\\\"visa_type\\\" name=\\\"visa_type\\\">\\r\\n                <option value=\\\"\\\"></option>\\r\\n                <option value=\\\"B1\\\" selected>USA Visa Category B-1</option>\\r\\n                <option value=\\\"B2\\\">USA Visa Category B-2</option>\\r\\n                <option value=\\\"DACA\\\">USA Visa Category DACA</option>\\r\\n                <option value=\\\"E1\\\">USA Visa Category E-1</option>\\r\\n                <option value=\\\"E2\\\">USA Visa Category E-2</option>\\r\\n                <option value=\\\"E3\\\">USA Visa Category E-3</option>\\r\\n                <option value=\\\"F1\\\">USA Visa Category F-1</option>\\r\\n                <option value=\\\"G4\\\">USA Visa Category G-4</option>\\r\\n                <option value=\\\"H1B\\\">USA Visa Category H-1B</option>\\r\\n                <option value=\\\"J1\\\">USA Visa Category J-1</option>\\r\\n                <option value=\\\"L1\\\">USA Visa Category L-1</option>\\r\\n                <option value=\\\"OTHER\\\">Any other USA Visa Category</option>\\r\\n                <option value=\\\"O1\\\">USA Visa Category O-1</option>\\r\\n                <option value=\\\"TN1\\\">USA Visa Category TN-1</option>\\r\\n            </select>\\r\\n        </div>\\r\\n        <div id=\\\"visa_expiration_date_option\\\">\\r\\n            <label for=\\\"visa_expiration_date\\\">Visa expiration date</label>\\r\\n            <input type=\\\"date\\\" id=\\\"visa_expiration_date\\\"\\r\\n                   name=\\\"visa_expiration_date\\\" placeholder=\\\"2028-05-01\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n        <div id=\\\"date_of_departure_from_usa_option\\\">\\r\\n            <label for=\\\"date_of_departure_from_usa\\\">Date of departure from USA</label>\\r\\n            <input type=\\\"date\\\" id=\\\"date_of_departure_from_usa\\\"\\r\\n                   name=\\\"date_of_departure_from_usa\\\" placeholder=\\\"2028-05-01\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"annual_income\\\">Annual Household Income</label>\\r\\n        <div class=\\\"explain\\\">\\r\\n            Annual household income includes income from sources such as employment, alimony, social security,\\r\\n            investment income, etc.\\r\\n        </div>\\r\\n        <select name=\\\"annual_income\\\" id=\\\"annual_income\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            <option value=\\\"1\\\">0 - $20,000</option>\\r\\n            <option value=\\\"2\\\">$20,000 - $49,999</option>\\r\\n            <option value=\\\"3\\\">$50,000 - $99,999</option>\\r\\n            <option value=\\\"4\\\">$100,000 - $499,999</option>\\r\\n            <option value=\\\"5\\\">$500,000 - $999,999</option>\\r\\n            <option value=\\\"6\\\">$1,000,000 - $9,999,999</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"liquid_net_worth\\\">Liquid Assets</label>\\r\\n        <div class=\\\"explain\\\">Liquid assets is your net worth minus assets that cannot be\\r\\n            converted quickly and easily into cash, such as real estate, business equity,\\r\\n            personal property and automobiles, expected inheritances, assets earmarked for\\r\\n            other purposes, and investments or accounts subject to substantial penalties\\r\\n            if they were sold or if assets were withdrawn from them.\\r\\n        </div>\\r\\n        <select name=\\\"liquid_net_worth\\\" required id=\\\"liquid_net_worth\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            <option value=\\\"1\\\">0 - $20,000</option>\\r\\n            <option value=\\\"2\\\">$20,000 - $49,999</option>\\r\\n            <option value=\\\"3\\\">$50,000 - $99,999</option>\\r\\n            <option value=\\\"4\\\">$100,000 - $499,999</option>\\r\\n            <option value=\\\"5\\\">$500,000 - $999,999</option>\\r\\n            <option value=\\\"1\\\">$1,000,000 - $9,999,999</option>\\r\\n        </select>\\r\\n    </div>\\r\\n\\r\\n    <div>\\r\\n        <label for=\\\"funding_source\\\">Funding source</label>\\r\\n        <select required id=\\\"funding_source\\\" name=\\\"funding_source\\\"\\r\\n                multiple size=\\\"4\\\" aria-label=\\\"size 3 select\\\">\\r\\n            <option value=\\\"employment_income\\\">Employment income</option>\\r\\n            <option value=\\\"investments\\\">Investments</option>\\r\\n            <option value=\\\"inheritance\\\">Inheritance</option>\\r\\n            <option value=\\\"business_income\\\">Business income</option>\\r\\n            <option value=\\\"savings\\\">Savings</option>\\r\\n            <option value=\\\"family\\\">Family</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    {{/unless}}\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"identity_prev\\\">Previous: Contact</button>\\r\\n        <button type=\\\"button\\\" id=\\\"identity_next\\\">Next: Trusted contacts</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycIdentity = (KycIdentity_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycIdentity.ts\n\r\n\r\n\r\n\r\nclass KycIdentity extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.edit = false;\r\n    }\r\n    render(edit = false) {\r\n        this.edit = edit;\r\n        let template = Handlebars.compile(Kyc_KycIdentity);\r\n        return template({ edit: edit, countries: CountryHelper.Countries });\r\n    }\r\n    show() {\r\n        if (this.kycForm.kycContact.usTaxResidence) {\r\n            this.showElement('citizen_of_usa_question');\r\n            this.hideElement('tax_id_type_options');\r\n            this.setLabel('tax_id_label', 'SSN');\r\n        }\r\n        else {\r\n            this.hideElement('citizen_of_usa_question');\r\n            this.setLabel('tax_id_label', 'National Tax Id (SSN)');\r\n            this.showElement('tax_id_type_options');\r\n        }\r\n        this.showFieldset('.kycIdentity', 'Identity');\r\n        this.showElement('country_of_citizenship_option');\r\n        let country_of_citizenship = document.getElementById('country_of_citizenship');\r\n        if (country_of_citizenship) {\r\n            country_of_citizenship.options[1].disabled = false;\r\n        }\r\n    }\r\n    bindEvents() {\r\n        this.bind('#citizen_yes', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                let taxIdType = document.getElementById('tax_id_type');\r\n                if (taxIdType)\r\n                    taxIdType.value = 'USA_SSN';\r\n                let country_of_citizenship = document.getElementById('country_of_citizenship');\r\n                country_of_citizenship.options[1].disabled = false;\r\n                country_of_citizenship.value = 'USA';\r\n                this.hideElement('citizen_no_type_options');\r\n                this.hideElement('visa_type_option');\r\n                this.hideElement('country_of_citizenship_option');\r\n                this.removeRequired('country_of_birth');\r\n                this.removeRequired('visa_type');\r\n                this.removeRequired('visa_expiration_date');\r\n                this.removeRequired('date_of_departure_from_usa');\r\n                document.getElementById('tax_id_label').innerHTML = 'SSN';\r\n                this.hideCitizenErrorMessage();\r\n            }\r\n        });\r\n        this.bind('#citizen_no', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                this.showElement('citizen_no_type_options');\r\n                this.showElement('country_of_citizenship_option');\r\n                this.setRequired('country_of_birth');\r\n                document.getElementById('tax_id_label').innerHTML = 'SSN';\r\n                let country_of_citizenship = document.getElementById('country_of_citizenship');\r\n                country_of_citizenship.options[0].selected = true;\r\n                country_of_citizenship.options[1].disabled = true;\r\n                this.hideCitizenErrorMessage();\r\n            }\r\n        });\r\n        this.bind('#citizen_no_type_options_1', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                this.showElement('country_of_citizenship_option');\r\n                this.hideElement('visa_type_option');\r\n                this.setRequired('country_of_birth');\r\n                this.removeRequired('visa_type');\r\n                this.removeRequired('visa_expiration_date');\r\n                this.removeRequired('date_of_departure_from_usa');\r\n            }\r\n        });\r\n        this.bind('#citizen_no_type_options_2', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                this.showElement('visa_type_option');\r\n                this.showElement('country_of_citizenship_option');\r\n                this.setRequired('country_of_birth');\r\n                this.setRequired('country_of_citizenship');\r\n                this.setRequired('visa_type');\r\n                this.setRequired('visa_expiration_date');\r\n                this.setRequired('date_of_departure_from_usa');\r\n            }\r\n        });\r\n        this.bind('#visa_type', 'change', (evt) => {\r\n            let input = evt.target;\r\n            if (input.value == 'B1' || input.value == 'B2') {\r\n                this.showElement('date_of_departure_from_usa_option');\r\n            }\r\n            else {\r\n                this.hideElement('date_of_departure_from_usa_option');\r\n            }\r\n        });\r\n        this.bindButtons();\r\n    }\r\n    hideCitizenErrorMessage() {\r\n        document.getElementById('citizen_yes').removeAttribute('aria-invalid');\r\n        let errorMessage = document.getElementById('input_error_citizen_yes');\r\n        if (errorMessage)\r\n            errorMessage.remove();\r\n    }\r\n    bindButtons() {\r\n        let showContactButton = document.getElementById('identity_prev');\r\n        showContactButton === null || showContactButton === void 0 ? void 0 : showContactButton.addEventListener('click', (evt) => {\r\n            this.kycForm.kycContact.show();\r\n        });\r\n        let showDisclosuresButton = document.getElementById('identity_next');\r\n        showDisclosuresButton === null || showDisclosuresButton === void 0 ? void 0 : showDisclosuresButton.addEventListener('click', (evt) => {\r\n            if (!this.validateInputs())\r\n                return;\r\n            if (!this.validateRequiredFields('.kycIdentity'))\r\n                return;\r\n            this.kycForm.kycTrustedContact.show();\r\n        });\r\n    }\r\n    validateInputs() {\r\n        if (this.edit)\r\n            return true;\r\n        let citizen_yes = document.getElementById('citizen_yes');\r\n        let citizen_no = document.getElementById('citizen_no');\r\n        if (!this.kycForm.kycContact.usTaxResidence) {\r\n            citizen_yes.checked = false;\r\n            citizen_no.checked = false;\r\n            return true;\r\n        }\r\n        if (!citizen_yes.checked && !citizen_no.checked) {\r\n            let obj = {\r\n                message: 'You must select either option',\r\n                inputName: 'citizen_yes',\r\n                labelText: document.querySelector('label[for=citizen_yes]').innerHTML\r\n            };\r\n            let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n            kycValidationError.handle();\r\n            return false;\r\n        }\r\n        let greenCardOption = document.getElementById('citizen_no_type_options_1');\r\n        let visaOption = document.getElementById('citizen_no_type_options_2');\r\n        if (citizen_no.checked && !greenCardOption.checked && !visaOption.checked) {\r\n            let obj = {\r\n                message: 'You must select either option, \"Green Card / Permanent Resident\" or \"Visa\"',\r\n                inputName: 'citizen_no',\r\n                labelText: ''\r\n            };\r\n            let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n            kycValidationError.handle();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycDisclosures.html\n// Module\nvar KycDisclosures_code = \"<fieldset class=\\\"kycDisclosures hidden\\\" data-form=\\\"1\\\">\\r\\n    {{#unless edit}}\\r\\n    <div>\\r\\n        <label for=\\\"employment_status\\\">Employment status</label>\\r\\n        <select id=\\\"employment_status\\\" required name=\\\"employment_status\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            <option value=\\\"employed\\\">Employed</option>\\r\\n            <option value=\\\"unemployed\\\">Unemployed</option>\\r\\n            <option value=\\\"retired\\\">Retired</option>\\r\\n            <option value=\\\"student\\\">Student</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"employer_name\\\">Employer name</label>\\r\\n        <input name=\\\"employer_name\\\" id=\\\"employer_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"employer_address\\\">Employer address</label>\\r\\n        <input name=\\\"employer_address\\\" id=\\\"employer_address\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"employment_position\\\">Occupation / Job title</label>\\r\\n        <input name=\\\"employment_position\\\" id=\\\"employment_position\\\" autocomplete=\\\"organization-title\\\"/>\\r\\n    </div>\\r\\n    {{/unless}}\\r\\n    <div class=\\\"disclosure_selections\\\">\\r\\n        Do any of the following apply to you or a member of your immediate family?\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"is_affiliated_exchange_or_finra\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"is_affiliated_exchange_or_finra\\\" name=\\\"is_affiliated_exchange_or_finra\\\"\\r\\n                           role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                Affiliated or work with a US registered broker-dealer or\\r\\n                FINRA.\\r\\n                <small class=\\\"explain\\\">Are you or an immediate family member affiliated with or employed by a stock\\r\\n                    exchange, regulatory body, member firm of an exchange, FINRA or a municipal securities\\r\\n                    broker-dealer?</small>\\r\\n\\r\\n                <div id=\\\"is_affiliated_exchange_or_finra_extra\\\"></div>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"is_control_person\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"is_control_person\\\" name=\\\"is_control_person\\\" role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n\\r\\n                Senior executive at or a 10% or greater shareholder of a publicly traded company.\\r\\n                <small class=\\\"explain\\\">Are you or an immediate family member an officer or 10% or greater shareholder of\\r\\n                    a publicly traded company, subject to the US Securities Exchange Act 1934?</small>\\r\\n                <div id=\\\"is_control_person_extra\\\"></div>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"is_politically_exposed\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"is_politically_exposed\\\" name=\\\"is_politically_exposed\\\" role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                I am a senior political figure.\\r\\n                <small class=\\\"explain\\\">Are you currently or formerly a Politically Exposed Person or Public Official\\r\\n                    (PEP)? <a href=\\\"https://www.google.com/search?q=%E2%80%9CPolitically+Exposed+Person%E2%80%9D+(PEP)\\\"\\r\\n                              target=\\\"_blank\\\">What is PEP?</a> </a></small>\\r\\n                <div id=\\\"is_politically_exposed_extra\\\"></div>\\r\\n            </div>\\r\\n            </label>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"immediate_family_exposed\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"immediate_family_exposed\\\" name=\\\"immediate_family_exposed\\\" role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                I am a family member or relative of a senior political figure.\\r\\n                <small class=\\\"explain\\\">Are you an immediate family member currently or formerly a Politically Exposed\\r\\n                    Person or Public Official (PEP)? <a\\r\\n                            href=\\\"https://www.google.com/search?q=%E2%80%9CPolitically+Exposed+Person%E2%80%9D+(PEP)\\\"\\r\\n                            target=\\\"_blank\\\">What is PEP?</a></small>\\r\\n                <div id=\\\"immediate_family_exposed_extra\\\"></div>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"none_above\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"none_above\\\" name=\\\"none_above\\\" role=\\\"switch\\\"></label>\\r\\n            </div>\\r\\n            <div>\\r\\n                None of the above apply to me or my family.\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"none_above_error\\\"></div>\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"disclosures_prev\\\">Previous: Trusted contact</button>\\r\\n        <button type=\\\"button\\\" id=\\\"disclosures_next\\\">Next: Agreements</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycDisclosures = (KycDisclosures_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycAffiliateOrControlled.html\n// Module\nvar KycAffiliateOrControlled_code = \"<fieldset id=\\\"affiliate_or_controlled\\\">\\r\\n    <div>You need to fill in the following information</div>\\r\\n    <div>\\r\\n        <label for=\\\"company_name\\\">Company name</label>\\r\\n        <input name=\\\"company_name\\\" required id=\\\"company_name\\\" autocomplete=\\\"organization\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_street_address\\\">Company street address</label>\\r\\n        <input name=\\\"company_street_address\\\" required id=\\\"company_street_address\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_city\\\">Company city</label>\\r\\n        <input name=\\\"company_city\\\" required id=\\\"company_city\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_state\\\">Company state</label>\\r\\n        <input name=\\\"company_state\\\" required id=\\\"company_state\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_country\\\">Company country</label>\\r\\n        <select required id=\\\"company_country\\\" required name=\\\"company_country\\\">\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_compliance_email\\\">Company compliance officer email</label>\\r\\n        <input name=\\\"company_compliance_email\\\" required id=\\\"company_compliance_email\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <div class=\\\"explain\\\">\\r\\n            In accordance with applicable FINRA rules, user will need to obtain a letter written\\r\\n            and signed by a compliance officer on company letterhead explicitly granting permission for\\r\\n            the applicant to carry the account and explicitly stating whether or not the firm requires\\r\\n            access to duplicate account statements and/or trade confirmations.\\r\\n\\r\\n            If the firm would like online access your duplicate account statements and/or trade confirmations,\\r\\n            include in the letter the applicant's full name and the following information for the interested\\r\\n            party: First and last name, title, email address, telephone number.\\r\\n\\r\\n        </div>\\r\\n        {{{fileUpload \\\"account_approval_letter\\\" \\\"Account approval letter\\\"}}}\\r\\n\\r\\n    </div>\\r\\n</fieldset>\\r\\n\";\n// Exports\n/* harmony default export */ const Kyc_KycAffiliateOrControlled = (KycAffiliateOrControlled_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycAffiliateOrControlled.ts\n\r\n\r\n\r\nclass KycAffiliateOrControlled extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render() {\r\n        let kycAffiliateOrControlledTemplate = Handlebars.compile(Kyc_KycAffiliateOrControlled);\r\n        return kycAffiliateOrControlledTemplate({ countries: CountryHelper.Countries });\r\n    }\r\n    bindEvents() {\r\n        this.bindFileUploads();\r\n        let company_country = document.getElementById('company_country');\r\n        company_country === null || company_country === void 0 ? void 0 : company_country.addEventListener('change', (evt) => {\r\n            let select = evt.target;\r\n            if (select.value === 'USA') {\r\n                this.setRequired('company_state');\r\n            }\r\n            else {\r\n                this.removeRequired('company_state');\r\n            }\r\n        });\r\n    }\r\n    validate() {\r\n        let company_name = document.getElementById('company_name');\r\n        if (!company_name)\r\n            return true;\r\n        return this.validateRequiredFields('#affiliate_or_controlled');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycImmediateFamily.html\n// Module\nvar KycImmediateFamily_code = \"<fieldset id=\\\"immediate_family\\\">\\r\\n    <div>Since you chose that your immediate family member, you need to fill in the following information</div>\\r\\n    <div>\\r\\n        <label for=\\\"disclosure_given_name\\\">Given name of political person</label>\\r\\n        <input name=\\\"disclosure_given_name\\\" id=\\\"disclosure_given_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"disclosure_family_name\\\">Family name of political person</label>\\r\\n        <input name=\\\"disclosure_family_name\\\" id=\\\"disclosure_family_name\\\"/>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycImmediateFamily = (KycImmediateFamily_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycImmediateFamily.ts\n\r\n\r\nclass KycImmediateFamily extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render() {\r\n        let kycImmediateFamilyTemplate = Handlebars.compile(Kyc_KycImmediateFamily);\r\n        return kycImmediateFamilyTemplate({});\r\n    }\r\n    bindEvents() {\r\n    }\r\n    validate() {\r\n        let disclosure_given_name = document.getElementById('disclosure_given_name');\r\n        if (!disclosure_given_name)\r\n            return true;\r\n        return this.validateRequiredFields('#immediate_family');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycDisclosures.ts\n\r\n\r\n\r\n\r\nclass KycDisclosures extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.kycAffiliatedOrControlled = new KycAffiliateOrControlled(this.kycForm);\r\n        this.kycImmediateFamily = new KycImmediateFamily(this.kycForm);\r\n    }\r\n    render(edit = false) {\r\n        let template = Handlebars.compile(Kyc_KycDisclosures);\r\n        return template({ edit: edit });\r\n    }\r\n    show() {\r\n        if (this.kycForm.steps == 5) {\r\n            document.getElementById('disclosures_next').innerText = 'Next: Agreements';\r\n        }\r\n        else {\r\n            document.getElementById('disclosures_next').innerText = 'Next: Upload documents';\r\n        }\r\n        this.showFieldset('.kycDisclosures', 'Disclosures');\r\n    }\r\n    bindEvents() {\r\n        let is_affiliated_exchange_or_finra = document.getElementById('is_affiliated_exchange_or_finra');\r\n        is_affiliated_exchange_or_finra === null || is_affiliated_exchange_or_finra === void 0 ? void 0 : is_affiliated_exchange_or_finra.addEventListener('click', (evt) => {\r\n            this.loadAffiliatedOrControlComponent('is_affiliated_exchange_or_finra');\r\n        });\r\n        let is_control_person = document.getElementById('is_control_person');\r\n        is_control_person === null || is_control_person === void 0 ? void 0 : is_control_person.addEventListener('click', (evt) => {\r\n            this.loadAffiliatedOrControlComponent('is_control_person');\r\n        });\r\n        let immediate_family_exposed = document.getElementById('immediate_family_exposed');\r\n        immediate_family_exposed === null || immediate_family_exposed === void 0 ? void 0 : immediate_family_exposed.addEventListener('click', (evt) => {\r\n            this.loadPep('immediate_family_exposed');\r\n        });\r\n        let is_politically_exposed = document.getElementById('is_politically_exposed');\r\n        is_politically_exposed === null || is_politically_exposed === void 0 ? void 0 : is_politically_exposed.addEventListener('click', (evt) => {\r\n            this.uncheck('immediate_family_exposed');\r\n        });\r\n        let none_above = document.getElementById('none_above');\r\n        none_above === null || none_above === void 0 ? void 0 : none_above.addEventListener('click', (evt) => {\r\n            this.removeMissingInfo('none_above_error');\r\n            none_above.removeAttribute('aria-invalid');\r\n        });\r\n        let prev = document.getElementById('disclosures_prev');\r\n        prev === null || prev === void 0 ? void 0 : prev.addEventListener('click', (evt) => {\r\n            this.kycForm.kycTrustedContact.show();\r\n        });\r\n        let next = document.getElementById('disclosures_next');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            if (!this.validateFields())\r\n                return;\r\n            if (this.kycForm.steps == 5) {\r\n                this.kycForm.kycAccountAgreement.show();\r\n            }\r\n            else {\r\n                this.kycForm.kycUpload.show();\r\n            }\r\n        });\r\n    }\r\n    loadAffiliatedOrControlComponent(elementId) {\r\n        if (elementId == 'is_affiliated_exchange_or_finra') {\r\n            this.uncheck('is_control_person');\r\n        }\r\n        else {\r\n            this.uncheck('is_affiliated_exchange_or_finra');\r\n        }\r\n        let element = document.getElementById(elementId);\r\n        let extra = document.getElementById(elementId + '_extra');\r\n        if (!extra)\r\n            return;\r\n        if (element.checked) {\r\n            extra.innerHTML = this.kycAffiliatedOrControlled.render();\r\n            this.kycAffiliatedOrControlled.bindEvents();\r\n        }\r\n        else {\r\n            extra.innerHTML = '';\r\n        }\r\n    }\r\n    loadPep(elementId) {\r\n        if (elementId == 'immediate_family_exposed') {\r\n            this.uncheck('is_politically_exposed');\r\n        }\r\n        else {\r\n            this.uncheck('immediate_family_exposed');\r\n        }\r\n        let element = document.getElementById(elementId);\r\n        let extra = document.getElementById(elementId + '_extra');\r\n        if (!extra)\r\n            return;\r\n        if (element.checked) {\r\n            extra.innerHTML = this.kycImmediateFamily.render();\r\n            this.kycImmediateFamily.bindEvents();\r\n        }\r\n        else {\r\n            extra.innerHTML = '';\r\n        }\r\n    }\r\n    uncheck(elementId) {\r\n        let element = document.getElementById(elementId);\r\n        element.checked = false;\r\n        let extra = document.getElementById(elementId + '_extra');\r\n        extra.innerHTML = '';\r\n    }\r\n    validateFields() {\r\n        if (!this.validateRequiredFields('.kycDisclosures'))\r\n            return false;\r\n        if (!this.kycImmediateFamily.validate())\r\n            return false;\r\n        if (!this.kycAffiliatedOrControlled.validate())\r\n            return false;\r\n        let is_affiliated_exchange_or_finra = document.getElementById('is_affiliated_exchange_or_finra');\r\n        let is_control_person = document.getElementById('is_control_person');\r\n        let is_politically_exposed = document.getElementById('is_politically_exposed');\r\n        let immediate_family_exposed = document.getElementById('immediate_family_exposed');\r\n        let none_above = document.getElementById('none_above');\r\n        if (!none_above.checked && !is_affiliated_exchange_or_finra.checked && !is_control_person.checked\r\n            && !is_politically_exposed.checked && !immediate_family_exposed.checked) {\r\n            this.setMissingInfo('none_above_error', 'You must select, \"None of the above apply to me or my family.\" if nothing is selected', 'none_above');\r\n            return false;\r\n        }\r\n        if (none_above.checked && (is_affiliated_exchange_or_finra.checked || is_control_person.checked\r\n            || is_politically_exposed.checked || immediate_family_exposed.checked)) {\r\n            this.setMissingInfo('none_above_error', 'You cannot have \"None of the above apply to me or my family.\" selected and other options selected. Please select only one', 'none_above');\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycAccountAgreement.html\n// Module\nvar KycAccountAgreement_code = \"<fieldset class=\\\"kycAccountAgreement hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"kycAccountAgreementGrid\\\">\\r\\n        <div id=\\\"account_agreement_error\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"account_agreement\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"account_agreement\\\" id=\\\"account_agreement\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                <label for=\\\"account_agreement\\\">\\r\\n                    I agree to <a href=\\\"https://files.alpaca.markets/disclosures/library/AcctAppMarginAndCustAgmt.pdf\\\"\\r\\n                                  target=\\\"_blank\\\">Alpaca Customer Agreement</a>\\r\\n                </label>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div id=\\\"customer_agreement_error\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"customer_agreement\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"customer_agreement\\\" id=\\\"customer_agreement\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                <label for=\\\"customer_agreement\\\">\\r\\n                    Customer Agreement Acknowledgement</label>\\r\\n                <div class=\\\"explain\\\">\\r\\n                    I have read, understood, and agree to be bound by Alpaca Securities LLC and Liminal.market Inc.\\r\\n                    account\\r\\n                    terms,\\r\\n                    and all other terms, disclosures and disclaimers applicable to me, as referenced in the Alpaca\\r\\n                    Customer\\r\\n                    Agreement.\\r\\n                    I also acknowledge that the Alpaca Customer Agreement contains a pre-dispute arbitration clause\\r\\n                    in\\r\\n                    Section\\r\\n                    43.\\r\\n                </div>\\r\\n\\r\\n            </div>\\r\\n\\r\\n        </div>\\r\\n        <div id=\\\"digital_signature_error\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"digital_signature\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"digital_signature\\\" id=\\\"digital_signature\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                <label for=\\\"digital_signature\\\">\\r\\n                    Digital Signature Acknowledgement</label>\\r\\n                <div class=\\\"explain\\\">\\r\\n                    I understand I am signing this agreement electronically,\\r\\n                    and that my electronic signature will have the same effect as physically signing and returning\\r\\n                    the\\r\\n                    Application Agreement.\\r\\n                </div>\\r\\n\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid hidden\\\" id=\\\"w8disclosure_div\\\">\\r\\n            <div>\\r\\n                <label for=\\\"w8disclosure\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"w8disclosure\\\" id=\\\"w8disclosure\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div><label for=\\\"w8disclosure\\\">\\r\\n                I certify that I am not a US citizen, US resident alien or other US person for US tax purposes,\\r\\n                and I am submitting the applicable Form W-8 BEN with this form to certify my foreign status and,\\r\\n                if applicable, claim tax treaty benefits. </label>\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"account_agreement_prev\\\">Previous: Upload documents</button>\\r\\n        <button type=\\\"submit\\\" id=\\\"submitKYC\\\">Confirm identity</button>\\r\\n    </div>\\r\\n    <div class=\\\"alert alert-danger\\\" id=\\\"kycError\\\" role=\\\"alert\\\"></div>\\r\\n</fieldset>\\r\\n\";\n// Exports\n/* harmony default export */ const Kyc_KycAccountAgreement = (KycAccountAgreement_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycAccountAgreement.ts\nvar KycAccountAgreement_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycAccountAgreement extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render(edit = false) {\r\n        let template = Handlebars.compile(Kyc_KycAccountAgreement);\r\n        return template({ edit: edit });\r\n    }\r\n    show() {\r\n        var _a, _b;\r\n        this.showFieldset('.kycAccountAgreement', 'Agreements');\r\n        if (this.kycForm.steps == 5) {\r\n            document.getElementById('account_agreement_prev').innerText = 'Previous: Disclosure';\r\n        }\r\n        else {\r\n            document.getElementById('account_agreement_prev').innerText = 'Previous: Upload documents';\r\n        }\r\n        if (this.kycForm.kycContact.usTaxResidence) {\r\n            (_a = document.getElementById('w8disclosure_div')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n        }\r\n        else {\r\n            (_b = document.getElementById('w8disclosure_div')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');\r\n        }\r\n    }\r\n    bindEvents() {\r\n        let account_agreement_prev = document.getElementById('account_agreement_prev');\r\n        account_agreement_prev === null || account_agreement_prev === void 0 ? void 0 : account_agreement_prev.addEventListener('click', (evt) => {\r\n            if (this.kycForm.steps == 5) {\r\n                this.kycForm.kycDisclosures.show();\r\n            }\r\n            else {\r\n                this.kycForm.kycUpload.show();\r\n            }\r\n        });\r\n        this.bindSubmitKyc();\r\n    }\r\n    bindSubmitKyc(edit = false) {\r\n        let submitKYC = document.getElementById('submitKYC');\r\n        if (!submitKYC)\r\n            return;\r\n        submitKYC.addEventListener('click', (evt) => KycAccountAgreement_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!edit && !this.validate())\r\n                return;\r\n            let account_agreement_prev = document.getElementById('account_agreement_prev');\r\n            //if (account_agreement_prev) account_agreement_prev.classList.add('hidden');\r\n            let liminal_market_modal_close = document.getElementById('liminal_market_modal_close');\r\n            // if (liminal_market_modal_close) liminal_market_modal_close.style.display = 'none';\r\n            let submitBtn = evt.target;\r\n            LoadingHelper.setLoading(submitBtn);\r\n            let params = FormHelper.getParams('#kyc_wizard_form');\r\n            let networkInfo = App.Network;\r\n            params.chainId = networkInfo.ChainId;\r\n            let kycService = new KYCService();\r\n            let result = yield kycService.saveKYCInfo(params)\r\n                .catch((reason) => {\r\n                if (account_agreement_prev)\r\n                    account_agreement_prev.classList.remove('hidden');\r\n                LoadingHelper.removeLoading();\r\n                if (reason.message) {\r\n                    let kycError = new KycValidatorError(JSON.parse(reason.message), this.kycForm);\r\n                    kycError.handle();\r\n                }\r\n                else {\r\n                    console.log(reason);\r\n                }\r\n            });\r\n            if (result) {\r\n                let ausdFund = new FakeAUSDFund();\r\n                ausdFund.showAUSDFakeFund();\r\n                ExecuteOrderButton.Instance.renderButton();\r\n            }\r\n            else {\r\n                if (account_agreement_prev)\r\n                    account_agreement_prev.classList.remove('hidden');\r\n                LoadingHelper.removeLoading();\r\n            }\r\n        }));\r\n    }\r\n    validate() {\r\n        let account_agreement = document.getElementById('account_agreement');\r\n        if (!(account_agreement === null || account_agreement === void 0 ? void 0 : account_agreement.checked)) {\r\n            this.setMissingInfo('account_agreement_error', 'You need to agree to agreements', 'account_agreement');\r\n            return false;\r\n        }\r\n        else {\r\n            this.removeMissingInfo('account_agreement_error', 'account_agreement');\r\n        }\r\n        let customer_agreement = document.getElementById('customer_agreement');\r\n        if (!(customer_agreement === null || customer_agreement === void 0 ? void 0 : customer_agreement.checked)) {\r\n            this.setMissingInfo('customer_agreement_error', 'You need to agree to customer agrement', 'customer_agreement');\r\n            return false;\r\n        }\r\n        else {\r\n            this.removeMissingInfo('customer_agreement_error', 'customer_agreement');\r\n        }\r\n        let digital_signature = document.getElementById('digital_signature');\r\n        if (!(digital_signature === null || digital_signature === void 0 ? void 0 : digital_signature.checked)) {\r\n            this.setMissingInfo('digital_signature_error', 'You need to sign', 'digital_signature');\r\n            return false;\r\n        }\r\n        else {\r\n            this.removeMissingInfo('digital_signature_error', 'digital_signature');\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycTrustedContact.html\n// Module\nvar KycTrustedContact_code = \"<fieldset class=\\\"kycTrustedContact hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"explain\\\">\\r\\n        A trusted contact is a person you authorize your financial firm to contact in limited circumstances,\\r\\n        such as if there is a concern about activity in your account and they have been unable to get in touch with you.\\r\\n        <br/><br/>\\r\\n        A trusted contact may be a family member, attorney, accountant or another third-party who you believe would\\r\\n        respect your privacy and know how to handle the responsibility.\\r\\n        The trusted person should be 18 years old or older.\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_first_name\\\">Legal first name of trusted contact</label>\\r\\n        <input id=\\\"trusted_first_name\\\" name=\\\"trusted_first_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_last_name\\\">Legal last name of trusted contact</label>\\r\\n        <input id=\\\"trusted_last_name\\\" name=\\\"trusted_last_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        If you fill in name, you are required to fill in one of the following, email, phone or address\\r\\n    </div>\\r\\n    <div class=\\\"input_error\\\" id=\\\"trusted_contact_missing_info\\\"></div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_email\\\">Email of trusted contact</label>\\r\\n        <input id=\\\"trusted_email\\\" type=\\\"email\\\" name=\\\"trusted_email\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_phone\\\">Phone of trusted contact</label>\\r\\n        <input id=\\\"trusted_phone\\\" type=\\\"tel\\\" name=\\\"trusted_phone\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_street_address\\\">Address of trusted contact</label>\\r\\n        <input id=\\\"trusted_street_address\\\" name=\\\"trusted_street_address\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_city\\\">City of trusted contact</label>\\r\\n        <input id=\\\"trusted_city\\\" name=\\\"trusted_city\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_state\\\">State of trusted contact</label>\\r\\n        <input id=\\\"trusted_state\\\" name=\\\"trusted_state\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_postal_code\\\">Postal code of trusted contact</label>\\r\\n        <input id=\\\"trusted_postal_code\\\" name=\\\"trusted_postal_code\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_country\\\">Country of trusted contact</label>\\r\\n        <select required id=\\\"trusted_country\\\" required name=\\\"trusted_country\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    {{#unless edit}}\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"trustedContact_prev\\\">Previous: Identity</button>\\r\\n        <button type=\\\"button\\\" id=\\\"trustedContact_next\\\">Next: Disclosures</button>\\r\\n    </div>\\r\\n    {{/unless}}\\r\\n    {{#if edit}}\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"trustedContact_prev\\\">Previous: Identity</button>\\r\\n        <button type=\\\"submit\\\" id=\\\"submitKYC\\\">Update account</button>\\r\\n    </div>\\r\\n    <div class=\\\"alert alert-danger\\\" id=\\\"kycError\\\" role=\\\"alert\\\"></div>\\r\\n    {{/if}}\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycTrustedContact = (KycTrustedContact_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycTrustedContact.ts\n\r\n\r\n\r\n\r\n\r\nclass KycTrustedContact extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.edit = false;\r\n    }\r\n    render(edit = false) {\r\n        this.edit = edit;\r\n        let template = Handlebars.compile(Kyc_KycTrustedContact);\r\n        return template({ edit: edit, countries: CountryHelper.Countries });\r\n    }\r\n    show() {\r\n        this.showFieldset('.kycTrustedContact', 'Trusted contact');\r\n    }\r\n    bindEvents() {\r\n        let showPrev = document.getElementById('trustedContact_prev');\r\n        showPrev === null || showPrev === void 0 ? void 0 : showPrev.addEventListener('click', (evt) => {\r\n            this.kycForm.kycIdentity.show();\r\n        });\r\n        let showNext = document.getElementById('trustedContact_next');\r\n        showNext === null || showNext === void 0 ? void 0 : showNext.addEventListener('click', (evt) => {\r\n            if (!this.validate())\r\n                return;\r\n            this.kycForm.kycDisclosures.show();\r\n        });\r\n        if (this.edit) {\r\n            let kycAccount = new KycAccountAgreement(this.kycForm);\r\n            if (!this.validate())\r\n                return;\r\n            kycAccount.bindSubmitKyc(this.edit);\r\n        }\r\n    }\r\n    validate() {\r\n        this.setMissingInfo('trusted_contact_missing_info', '');\r\n        let trusted_first_name = document.getElementById('trusted_first_name');\r\n        if (trusted_first_name && !StringHelper.isNullOrEmpty(trusted_first_name.value)) {\r\n            let trusted_email = document.getElementById('trusted_email');\r\n            let trusted_phone = document.getElementById('trusted_phone');\r\n            let trusted_street_address = document.getElementById('trusted_street_address');\r\n            let trusted_city = document.getElementById('trusted_city');\r\n            let trusted_postal_code = document.getElementById('trusted_postal_code');\r\n            let trusted_country = document.getElementById('trusted_country');\r\n            if (StringHelper.isNullOrEmpty(trusted_email.value) && StringHelper.isNullOrEmpty(trusted_phone.value)\r\n                && StringHelper.isNullOrEmpty(trusted_street_address.value)) {\r\n                this.setMissingInfo('trusted_contact_missing_info', 'You need to fill in either email, phone or address');\r\n                return;\r\n            }\r\n            if (!StringHelper.isNullOrEmpty(trusted_email.value) && trusted_email.value.indexOf('@') == -1) {\r\n                this.setMissingInfo('trusted_contact_missing_info', 'Email is not valid. It must contain @ sign');\r\n                return;\r\n            }\r\n            if (!StringHelper.isNullOrEmpty(trusted_street_address.value) &&\r\n                (StringHelper.isNullOrEmpty(trusted_city.value) ||\r\n                    StringHelper.isNullOrEmpty(trusted_postal_code.value) ||\r\n                    StringHelper.isNullOrEmpty(trusted_country.value))) {\r\n                this.setMissingInfo('trusted_contact_missing_info', 'You need fill inn into City, Postal code and Country when filling the street address');\r\n                return;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycUpload.html\n// Module\nvar KycUpload_code = \"<fieldset class=\\\"kycUpload hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Photo ID Front (Front of passport)\\\"}}}\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification_2\\\" \\\"Photo ID Back (Passport picture of ID) \\\"}}}\\r\\n    </div>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"address_verification\\\" \\\"Picture of address verification\\\"}}}\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"upload_prev\\\">Previous: Disclosures</button>\\r\\n        <button type=\\\"button\\\" id=\\\"upload_next\\\">Next: Agreements</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycUpload = (KycUpload_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycUpload.ts\n\r\n\r\nclass KycUpload extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render() {\r\n        let template = Handlebars.compile(Kyc_KycUpload);\r\n        return template({});\r\n    }\r\n    show() {\r\n        this.showFieldset('.kycUpload', 'Upload documents');\r\n    }\r\n    bindEvents() {\r\n        this.bindFileUploads();\r\n        let upload_prev = document.getElementById('upload_prev');\r\n        upload_prev === null || upload_prev === void 0 ? void 0 : upload_prev.addEventListener('click', (evt) => {\r\n            this.kycForm.kycDisclosures.show();\r\n        });\r\n        let upload_next = document.getElementById('upload_next');\r\n        upload_next === null || upload_next === void 0 ? void 0 : upload_next.addEventListener('click', (evt) => {\r\n            if (!this.validateRequiredFields('.kycUpload'))\r\n                return;\r\n            this.kycForm.kycAccountAgreement.show();\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYCForm.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KYCForm {\r\n    constructor(onHide) {\r\n        this.steps = 5;\r\n        this.timeout = undefined;\r\n        this.activeFieldsetSelector = '.kycContact';\r\n        this.modal = new Modal();\r\n        this.onHide = onHide;\r\n        this.kycContact = new KycContact(this);\r\n        this.kycIdentity = new KycIdentity(this);\r\n        this.kycTrustedContact = new KycTrustedContact(this);\r\n        this.kycDisclosures = new KycDisclosures(this);\r\n        this.kycUpload = new KycUpload(this);\r\n        this.kycAccountAgreement = new KycAccountAgreement(this);\r\n    }\r\n    show(className) {\r\n        let kycForm = new KYCForm(() => {\r\n        });\r\n        const ble = className;\r\n        this[ble].show();\r\n        this.activeFieldsetSelector = className;\r\n    }\r\n    showKYCForm(edit = false) {\r\n        let template = Handlebars.compile(KYCModal);\r\n        let obj = {\r\n            KycContactHtml: this.kycContact.render(),\r\n            KycIdentityHtml: this.kycIdentity.render(),\r\n            KycDisclosureHtml: this.kycDisclosures.render(),\r\n            KycTrustedContactHtml: this.kycTrustedContact.render(),\r\n            KycAccountAgreementHtml: this.kycAccountAgreement.render(),\r\n            KycUploadHtml: this.kycUpload.render()\r\n        };\r\n        let content = template(obj);\r\n        let newModal = this.modal.showModal('KYC & AML', content, true, () => {\r\n            this.clearTimeout();\r\n            this.onHide();\r\n        }, false);\r\n        let taxResidence = document.getElementById('country_of_tax_residence');\r\n        if (taxResidence) {\r\n            this.steps = (taxResidence.value == 'USA') ? 5 : 6;\r\n        }\r\n        if (newModal) {\r\n            this.kycContact.bindEvents();\r\n            this.kycIdentity.bindEvents();\r\n            this.kycTrustedContact.bindEvents();\r\n            this.kycDisclosures.bindEvents();\r\n            this.kycUpload.bindEvents();\r\n            this.kycAccountAgreement.bindEvents();\r\n            document.getElementById('kyc_wizard_form').addEventListener('keyup', (evt) => {\r\n                if (evt.key == 'Enter') {\r\n                    evt.preventDefault();\r\n                    evt.stopPropagation();\r\n                }\r\n            });\r\n        }\r\n        this.kycContact.show();\r\n    }\r\n    setSteps(steps) {\r\n        this.steps = steps;\r\n    }\r\n    clearTimeout() {\r\n        if (this.timeout)\r\n            clearTimeout(this.timeout);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycStatusHandler.ts\nvar KycStatusHandler_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass KycStatusHandler {\r\n    constructor(kycResponse, executeTradeButton) {\r\n        this.kycResponse = kycResponse;\r\n        this.executeTradeButton = executeTradeButton;\r\n    }\r\n    getButtonText() {\r\n        let txt = 'Finish KYC';\r\n        switch (this.kycResponse.status) {\r\n            case 'SUBMITTED':\r\n            case 'ONBOARDING':\r\n            case 'INACTIVE':\r\n            case 'APPROVED':\r\n            case 'EDITED':\r\n            case 'APPROVAL_PENDING':\r\n                txt = 'Submitted to KYC processor';\r\n                break;\r\n            case 'ACTION_REQUIRED':\r\n                txt = 'Action required. Click to continue';\r\n                break;\r\n            case 'REJECTED':\r\n                txt = 'Your application was rejected';\r\n                break;\r\n            case 'DISABLED':\r\n                txt = 'Your account has been disabled';\r\n                break;\r\n            case 'ACTIVE':\r\n            case 'ACCOUNT_UPDATED':\r\n                txt = 'You are approved. KYC is being sent to blockchain. Give it few minutes';\r\n                break;\r\n            case 'ACCOUNT_CLOSED':\r\n                txt = 'Your account has been closed';\r\n                break;\r\n        }\r\n        return txt + '<small>Click for more info</small>';\r\n    }\r\n    getButtonClickEvent(executeTradeButton) {\r\n        switch (this.kycResponse.status) {\r\n            case 'SUBMITTED':\r\n            case 'ONBOARDING':\r\n            case 'INACTIVE':\r\n            case 'APPROVED':\r\n            case 'EDITED':\r\n            case 'APPROVAL_PENDING':\r\n                return this.showModal('Application is being processed', \"You need to wait for KYC to be approved. Then you'll be able to do trades. \" +\r\n                    \"This usually takes few minutes for the first submission, but can take longer for second submission. \" +\r\n                    \"We will email you when you are approved or if there are problems<br /><br />\" +\r\n                    \"If this status has been for more than 1 day, and you haven't gotten any email from us. Please email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application is being processed for to long&body=Hi, can you help me to find out what the problem is, the KYC process has not changed for some time? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\");\r\n            case 'ACTION_REQUIRED':\r\n                return () => KycStatusHandler_awaiter(this, void 0, void 0, function* () {\r\n                    let kycActionRequired = new KycActionRequired(executeTradeButton);\r\n                    yield kycActionRequired.show();\r\n                });\r\n            case 'REJECTED':\r\n                return this.showModal('Application was rejected', \"Your application has been rejected during KYC process.<br /><br />\" +\r\n                    \"We don't have the information on why that happened, but you can email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application was rejected&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\" +\r\n                    \" and we can find out, and we should be able to solve it together.\");\r\n            case 'DISABLED':\r\n                return this.showModal('Application was disabled', \"Your account has been disabled.<br /><br />\" +\r\n                    \"We don't have the information on why that happened, but you can email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application was disabled&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\" +\r\n                    \" and we can find out, and we should be able to solve it together.\");\r\n            case 'ACCOUNT_CLOSED':\r\n                return this.showModal('Application was closed', \"Your account has been closed.<br /><br />\" +\r\n                    \"We don't have the information on why that happened, but you can email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application was closed&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\" +\r\n                    \" and we can find out, and we should be able to solve it together.\");\r\n            case 'ACCOUNT_UPDATED':\r\n            case 'ACTIVE':\r\n                return this.showModal('Account soon ready', 'Your account has been approved...<br /><br/>' +\r\n                    '..but, after we approve your account, we write the information to the blockchain.' +\r\n                    ' This usually takes just few(2-3) minutes.<br /><br/> If this is taking longer, ' +\r\n                    'please email us at <a target=\"_blank\" href=\"mailto:info@liminal.market?subject=KYC is being written to blockchain&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market\">info@liminal.market</a>');\r\n        }\r\n        return () => {\r\n            let kycForm = new KYCForm(() => KycStatusHandler_awaiter(this, void 0, void 0, function* () {\r\n                yield this.executeTradeButton.renderButton();\r\n            }));\r\n            kycForm.showKYCForm();\r\n        };\r\n    }\r\n    showModal(title, content) {\r\n        return () => {\r\n            let modal = new Modal();\r\n            modal.showModal(title, content);\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycApproved.html\n// Module\nvar KycApproved_code = \"<h2>You are account has been approved</h2>\\r\\n<p>We have approved your account. You can now fund your account and start to trade.\\r\\n\\r\\n    <button id=\\\"kycApprovedFund\\\">Fund account</button>\\r\\n</p>\";\n// Exports\n/* harmony default export */ const Kyc_KycApproved = (KycApproved_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycApproved.ts\n\r\n\r\n\r\n\r\nclass KycApproved {\r\n    show() {\r\n        let template = Handlebars.compile(Kyc_KycApproved);\r\n        let modal = new Modal();\r\n        modal.showModal('Account approved', template({}));\r\n        let fundAccount = document.getElementById('kycApprovedFund');\r\n        fundAccount === null || fundAccount === void 0 ? void 0 : fundAccount.addEventListener('click', (evt) => {\r\n            modal.hideModal();\r\n            let ausdFund = new FakeAUSDFund();\r\n            ausdFund.showAUSDFakeFund();\r\n        });\r\n        if (ExecuteOrderButton.Instance) {\r\n            clearInterval(ExecuteOrderButton.Instance.kycIdDoneTimeout);\r\n            ExecuteOrderButton.Instance.renderButton();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/OrderProgress.ts\n\r\nclass OrderProgress {\r\n    constructor() {\r\n        this.progressNr = 0;\r\n    }\r\n    static getInstance() {\r\n        return this.instance;\r\n    }\r\n    clearProgressText() {\r\n        let executingOrderProgress = document.getElementById('executing-order-progress');\r\n        executingOrderProgress === null || executingOrderProgress === void 0 ? void 0 : executingOrderProgress.classList.add('hidden');\r\n        this.progressNr = 0;\r\n    }\r\n    setProgressText(progressNr, text, hash) {\r\n        console.log('thisNr', this.progressNr, 'nr', progressNr, 'text', text);\r\n        if (progressNr < this.progressNr)\r\n            return;\r\n        let executingOrderProgress = document.getElementById('executing-order-progress');\r\n        if (!executingOrderProgress)\r\n            return;\r\n        let progressText = document.getElementById('progress-text');\r\n        if (!progressText)\r\n            return;\r\n        let networkInfo = App.Network;\r\n        progressText.innerHTML = text + '<br /><a href=\"' + networkInfo.BlockExplorer + '/tx/' + hash + '\" target=\"_blank\" style=\"font-size:10px\">View</a>';\r\n        executingOrderProgress.classList.remove('hidden');\r\n        this.progressNr = progressNr;\r\n    }\r\n}\r\nOrderProgress.instance = new OrderProgress();\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/ExecuteOrderButton.ts\nvar ExecuteOrderButton_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ExecuteOrderButton {\r\n    constructor(sellTradeInput, buyTradeInput) {\r\n        this.hasBuyingPower = false;\r\n        this.sellTradeInput = sellTradeInput;\r\n        this.buyTradeInput = buyTradeInput;\r\n        this.authenticateService = new AuthenticateService();\r\n        this.template = Handlebars.compile(ExecuteTradeButton);\r\n        this.button = document.getElementById('liminal_market_execute_trade');\r\n        ExecuteOrderButton.Instance = this;\r\n    }\r\n    renderButton() {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            this.button.outerHTML = this.button.outerHTML;\r\n            this.button = document.getElementById('liminal_market_execute_trade');\r\n            this.loadingButton(this.button);\r\n            //wallet connected\r\n            if (!this.walletIsConnected(this.button)) {\r\n                return;\r\n            }\r\n            //user logged in\r\n            if (!(yield this.userIsLoggedIn(this.button))) {\r\n                return;\r\n            }\r\n            //chain id correct\r\n            if (!this.chainIdIsCorrect(this.button)) {\r\n                return;\r\n            }\r\n            //native token is available\r\n            if (!(yield this.userHasNativeToken(this.button))) {\r\n                return;\r\n            }\r\n            //kyc is done\r\n            if (!(yield this.kycIsDone(this.button))) {\r\n                return;\r\n            }\r\n            //ausd is setup\r\n            if (!(yield this.userHasAUSD(this.button))) {\r\n                return;\r\n            }\r\n            //ausd > buy amount\r\n            if (!(yield this.userHasEnoughQty(this.button))) {\r\n                return;\r\n            }\r\n            if (!this.hasQuantityAndSymbol(this.button)) {\r\n                return;\r\n            }\r\n            if (!(yield this.isMarketOpen(this.button))) {\r\n                return;\r\n            }\r\n            this.enableExecuteOrder(this.button);\r\n        });\r\n    }\r\n    enableExecuteOrder(button) {\r\n        //if (this.sellTradeInput.quantity.eq(0)) return;\r\n        //execute trade can be done\r\n        button.innerHTML = 'Execute trade';\r\n        button.classList.replace('disabled', 'enabled');\r\n        this.stopLoadingButton(button);\r\n        button.addEventListener('click', () => ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            this.loadingButton(button);\r\n            button.innerHTML = 'Confirm transaction in your wallet';\r\n            if (this.sellTradeInput.symbol == 'aUSD') {\r\n                let liminalMarketService = new LiminalMarketService();\r\n                let symbolAddress = yield liminalMarketService.getSymbolContractAddress(this.buyTradeInput.symbol);\r\n                if (symbolAddress === Helper_AddressZero) {\r\n                    let result = yield liminalMarketService.createToken(this.buyTradeInput.symbol, () => {\r\n                        button.innerHTML = 'Creating token. Give it few seconds';\r\n                    }).finally(() => {\r\n                        this.stopLoadingButton(button);\r\n                        button.innerHTML = 'Execute trade';\r\n                    });\r\n                    if (result instanceof BlockchainError) {\r\n                        showBar('Error:' + result.message);\r\n                        console.error(result);\r\n                        return;\r\n                    }\r\n                    symbolAddress = result;\r\n                }\r\n                yield this.executeTransfer(symbolAddress, this.sellTradeInput.quantity, new AUSDService(), button);\r\n            }\r\n            else {\r\n                let liminalMarketService = new LiminalMarketService();\r\n                let symbolAddress = yield liminalMarketService.getSymbolContractAddress(this.sellTradeInput.symbol);\r\n                yield this.executeTransfer(symbolAddress, this.sellTradeInput.quantity, new SecurityTokenService(), button);\r\n            }\r\n        }));\r\n    }\r\n    executeTransfer(symbolAddress, quantity, service, button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            yield service.transfer(symbolAddress, quantity)\r\n                .then(transaction => {\r\n                button.innerHTML = 'Execute trade';\r\n                if (!transaction)\r\n                    return;\r\n                OrderProgress.getInstance().setProgressText(0, 'Sending to blockchain', transaction.hash);\r\n            }).catch(reason => {\r\n                let msg = reason.toString();\r\n                console.log('CATCH - contract.transfer', reason);\r\n                if (msg.indexOf('Market is closed') != -1) {\r\n                    this.button.innerHTML = 'Market is closed';\r\n                }\r\n                else {\r\n                    button.innerHTML = 'Execute trade';\r\n                }\r\n            }).finally(() => {\r\n                this.stopLoadingButton(button);\r\n            });\r\n        });\r\n    }\r\n    loadingButton(button) {\r\n        button.setAttribute('aria-busy', 'true');\r\n    }\r\n    stopLoadingButton(button) {\r\n        button.removeAttribute('aria-busy');\r\n    }\r\n    walletIsConnected(button) {\r\n        if (App.User.provider)\r\n            return true;\r\n        button.innerHTML = 'Connect wallet';\r\n        button.addEventListener('click', (evt) => ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            let connectWallet = new ConnectWallet();\r\n            yield connectWallet.connectWallet(evt.target);\r\n        }));\r\n        this.stopLoadingButton(button);\r\n        return false;\r\n    }\r\n    userIsLoggedIn(button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            if (App.User.isLoggedIn)\r\n                return true;\r\n            button.innerHTML = 'Login';\r\n            button.addEventListener('click', () => ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n                yield this.authenticateService.authenticateUser();\r\n            }));\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    chainIdIsCorrect(button) {\r\n        let chainId = App.User.chainId;\r\n        if (chainId === App.Network.ChainId)\r\n            return true;\r\n        let usersWalletNetwork = NetworkInfo.getNetworkInfoByChainId(chainId);\r\n        if (usersWalletNetwork) {\r\n            NetworkInfo.setNetworkByChainId(chainId);\r\n            return true;\r\n        }\r\n        button.innerHTML = 'Switch Network';\r\n        button.addEventListener('click', () => ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            yield App.Network.addNetworkToWallet();\r\n        }));\r\n        this.stopLoadingButton(button);\r\n        return false;\r\n    }\r\n    userHasNativeToken(button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = App.Network;\r\n            let hasEnoughNativeTokens = yield networkInfo.hasEnoughNativeTokens();\r\n            if (hasEnoughNativeTokens)\r\n                return true;\r\n            button.classList.replace('enabled', 'disabled');\r\n            button.innerHTML = 'You need ' + networkInfo.NativeCurrencyName + ' tokens. Click me for some tokens';\r\n            button.addEventListener('click', () => {\r\n                let nativeTokenNeededModal = new NativeTokenNeeded(() => {\r\n                    this.renderButton();\r\n                });\r\n                nativeTokenNeededModal.show();\r\n            });\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    kycIsDone(button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            let kycService = new KYCService();\r\n            let kycResponse = yield kycService.hasValidKYC();\r\n            if (!kycResponse.isValidKyc) {\r\n                let kycStatusHandler = new KycStatusHandler(kycResponse, this);\r\n                button.innerHTML = kycStatusHandler.getButtonText();\r\n                button.addEventListener('click', kycStatusHandler.getButtonClickEvent(this));\r\n                if (kycResponse.status == 'ACTIVE') {\r\n                    this.loadingButton(button);\r\n                    this.kycIdDoneTimeout = setInterval(() => ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n                        kycResponse = yield kycService.hasValidKYC();\r\n                        if (kycResponse.isValidKyc) {\r\n                            this.hasBuyingPower = kycResponse.hasBuyingPower;\r\n                            if (!this.hasBuyingPower) {\r\n                                let kycApproved = new KycApproved();\r\n                                kycApproved.show();\r\n                            }\r\n                            clearInterval(this.kycIdDoneTimeout);\r\n                            yield this.renderButton();\r\n                        }\r\n                    }), 30 * 1000);\r\n                }\r\n                else {\r\n                    this.stopLoadingButton(button);\r\n                }\r\n                return false;\r\n            }\r\n            this.stopLoadingButton(button);\r\n            return true;\r\n        });\r\n    }\r\n    userHasAUSD(button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            let ausdService = new AUSDService();\r\n            let balance = yield ausdService.getAUSDBalanceOf(App.User.address);\r\n            if (balance.isGreaterThan(0))\r\n                return true;\r\n            if (this.hasBuyingPower) {\r\n                button.innerHTML = 'We are funding your aUSD token';\r\n                this.checkBalanceInterval = setInterval(() => ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n                    AUSDService.lastUpdate = undefined;\r\n                    let balance = yield ausdService.getAUSDBalanceOf(App.User.address);\r\n                    if (balance.isGreaterThan(0)) {\r\n                        yield AUsdBalance.forceLoadAUSDBalanceUI();\r\n                        clearInterval(this.checkBalanceInterval);\r\n                        yield this.renderButton();\r\n                    }\r\n                }), 10 * 1000);\r\n                return false;\r\n            }\r\n            if (App.Network.TestNetwork) {\r\n                button.innerHTML = 'You need aUSD. Click here to get some';\r\n            }\r\n            else {\r\n                button.innerHTML = 'You need aUSD. Click here for instructions';\r\n            }\r\n            button.addEventListener('click', () => {\r\n                let ausdFund = new FakeAUSDFund();\r\n                ausdFund.showAUSDFakeFund();\r\n            });\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    userHasEnoughQty(button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            let ausdService = new AUSDService();\r\n            if (this.sellTradeInput.symbol == 'aUSD') {\r\n                let balance = yield ausdService.getAUSDBalanceOf(App.User.address);\r\n                if (balance.isGreaterThanOrEqualTo(this.sellTradeInput.quantity))\r\n                    return true;\r\n                button.innerHTML = \"You don't have enough aUSD. Click for more funding\";\r\n                button.addEventListener('click', () => {\r\n                    let ausdFund = new FakeAUSDFund();\r\n                    ausdFund.showAUSDFakeFund();\r\n                });\r\n            }\r\n            else {\r\n                let securityTokenService = new SecurityTokenService();\r\n                let userQuantity = yield securityTokenService.getQuantityByAddress(this.sellTradeInput.symbol, App.User.address);\r\n                if (this.sellTradeInput.quantity <= userQuantity)\r\n                    return true;\r\n                button.innerHTML = \"You don't have enough \" + this.sellTradeInput.symbol;\r\n                button.classList.replace('disable', 'enable');\r\n            }\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    isMarketOpen(button) {\r\n        return ExecuteOrderButton_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService();\r\n            let isMarketOpen = yield userService.isMarketOpenOrUserOffHours();\r\n            if (isMarketOpen)\r\n                return true;\r\n            button.innerHTML = 'Market is closed';\r\n            button.classList.replace('enabled', 'disabled');\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    hasQuantityAndSymbol(button) {\r\n        if (this.sellTradeInput.quantity.eq(0)) {\r\n            button.innerHTML = 'Type in quantity';\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        }\r\n        if (this.buyTradeInput.name == '') {\r\n            button.innerHTML = 'Select stock to buy';\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/enums/TradeType.ts\nvar TradeType;\r\n(function (TradeType) {\r\n    TradeType[\"Sell\"] = \"Sell\";\r\n    TradeType[\"Buy\"] = \"Buy\";\r\n})(TradeType || (TradeType = {}));\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/TradeInput.html\n// Module\nvar TradeInput_code = \"<article class=\\\"{{tradeType}}Inputs tradeInputArticle\\\">\\r\\n    <div class=\\\"grid tradeInput\\\">\\r\\n        <div class=\\\"select_token\\\">\\r\\n            <a id=\\\"{{tradeType}}SelectStock\\\" href=\\\"#\\\" role=\\\"button\\\">\\r\\n                <img src=\\\"{{logo}}\\\"/>\\r\\n                {{symbol}}\\r\\n            </a>\\r\\n        </div>\\r\\n        <div class=\\\"trade_input\\\"><input autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" type=\\\"tel\\\" spellcheck=\\\"false\\\"\\r\\n                                        value=\\\"{{strQuantity}}\\\" placeholder=\\\"0.0\\\"/></div>\\r\\n        <div class=\\\"balance\\\">Balance : <abbr title=\\\"{{balance}}\\\" data-tooltip=\\\"{{balance}}\\\" class=\\\"balance_value\\\">{{abbrBalance}}</abbr>\\r\\n            <a href=\\\"\\\" class=\\\"balance_max\\\">Max</a></div>\\r\\n        <div class=\\\"price_per_share\\\"></div>\\r\\n    </div>\\r\\n    <progress class=\\\"progress d-none\\\" value=\\\"0\\\" max=\\\"1\\\"></progress>\\r\\n    <div class=\\\"exceeds_wallet_balance d-none\\\">Exceeds wallet balance</div>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const TradeInput = (TradeInput_code);\n;// CONCATENATED MODULE: ./src/ui/modals/SecuritiesListModal.ts\nvar SecuritiesListModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass SecuritiesListModal {\r\n    constructor() {\r\n        this.tbodyId = 'liminal_market_securities_list';\r\n        this.page = 0;\r\n        this.loadmore = true;\r\n        this.modal = new Modal();\r\n    }\r\n    showModal(onSelectSymbol) {\r\n        return SecuritiesListModal_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesList = new SecuritiesList();\r\n            let content = yield securitiesList.render();\r\n            let newInstance = this.modal.showModal('Select stock to buy', content, true);\r\n            //if (newInstance)\r\n            {\r\n                yield securitiesList.bindEvents(onSelectSymbol);\r\n            }\r\n        });\r\n    }\r\n    hideModal() {\r\n        this.modal.hideModal();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/TradeInfo.ts\nclass TradeInfo {\r\n    constructor(price, lastTrade) {\r\n        this.price = price;\r\n        this.lastTrade = lastTrade;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/cloud/HttpError.ts\n\r\n\r\nclass HttpError {\r\n    constructor(obj) {\r\n        this.method = obj.method;\r\n        this.url = obj.url;\r\n        this.body = obj.body;\r\n        this.serverError = obj.serverError;\r\n    }\r\n    handle() {\r\n        console.log(this);\r\n        ErrorInfo.report(new GeneralError('Error doing request. Server response was:' + this.serverError.data.message));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/CloudError.ts\n\r\n\r\n\r\nclass CloudError extends GeneralError {\r\n    constructor(e) {\r\n        super(e);\r\n        try {\r\n            let obj = JSON.parse(e.message);\r\n            if (obj.name) {\r\n                let errorHandler = CloudError.getActionInstance(obj.name, obj);\r\n                if (errorHandler) {\r\n                    errorHandler.handle();\r\n                    return;\r\n                }\r\n            }\r\n            ErrorInfo.error(obj);\r\n        }\r\n        catch (jsonError) {\r\n            ErrorInfo.error(e);\r\n        }\r\n    }\r\n    static getActionInstance(action, obj) {\r\n        let tmp = undefined;\r\n        for (let i = 0; i < CloudError.Errors.length; i++) {\r\n            if (CloudError.Errors[i].name === action) {\r\n                let errorHandler = CloudError.Errors[i];\r\n                return new errorHandler(obj);\r\n            }\r\n        }\r\n        return tmp;\r\n    }\r\n}\r\nCloudError.Errors = [\r\n    HttpError\r\n];\r\n\n;// CONCATENATED MODULE: ./src/services/backend/StockPriceService.ts\nvar StockPriceService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass StockPriceService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    getSymbolPrice(symbol, tradeType) {\r\n        return StockPriceService_awaiter(this, void 0, void 0, function* () {\r\n            const params = {\r\n                symbol: symbol\r\n            };\r\n            let result = yield this.get(\"getSymbolPrice\", params)\r\n                .catch((e) => {\r\n                throw new CloudError(e);\r\n            });\r\n            let quote = result.quote;\r\n            let price = (tradeType == TradeType.Sell) ? quote.ap : quote.bp;\r\n            let tradeInfo = new TradeInfo(price, quote.t);\r\n            return tradeInfo;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/PricePerShare.html\n// Module\nvar PricePerShare_code = \"<abbr title=\\\"Last trade was {{lastTraded}}\\\" data-tooltip=\\\"Last trade was {{lastTraded}}\\\">{{text}}</abbr>\";\n// Exports\n/* harmony default export */ const PricePerShare = (PricePerShare_code);\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/TradePanelInput.ts\nvar TradePanelInput_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TradePanelInput {\r\n    constructor(symbol, name, logo, address, tradeType) {\r\n        this.isDirty = false;\r\n        this.symbol = symbol;\r\n        this.name = name;\r\n        this.logo = logo;\r\n        this.address = address;\r\n        this.tradeType = tradeType;\r\n        this.quantity = new bignumber(0);\r\n        this.strQuantity = '';\r\n        this.balance = new bignumber(0);\r\n        this.lastPrice = 0;\r\n        this.qtyPerDollar = 0;\r\n        this.lastTraded = '';\r\n        this.template = Handlebars.compile(TradeInput);\r\n        this.pricePerShareTemplate = Handlebars.compile(PricePerShare);\r\n    }\r\n    setOtherTradePanelInput(tradePanelInput) {\r\n        this.otherTradePanelInput = tradePanelInput;\r\n    }\r\n    renderToString() {\r\n        return this.template(this);\r\n    }\r\n    render(bindEvents = true) {\r\n        let element = document.querySelector('.' + this.tradeType + 'Inputs');\r\n        element.outerHTML = this.renderToString();\r\n        if (bindEvents) {\r\n            this.bindEvents();\r\n        }\r\n    }\r\n    bindEvents() {\r\n        this.bindQuantityListener();\r\n        this.bindSelectStockButton();\r\n        this.bindMaxLink();\r\n    }\r\n    setSymbol(symbol, name, logo) {\r\n        this.symbol = symbol;\r\n        this.name = name;\r\n        this.logo = logo;\r\n        this.isDirty = true;\r\n    }\r\n    bindSelectStockButton() {\r\n        let selectStock = document.querySelector('#' + this.tradeType + 'SelectStock');\r\n        if (!selectStock)\r\n            return;\r\n        selectStock.addEventListener('click', (evt) => TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let securityList = new SecuritiesListModal();\r\n            yield securityList.showModal((symbol, name, logo) => TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n                securityList.hideModal();\r\n                if (this.otherTradePanelInput && this.symbol == 'aUSD' && symbol != this.symbol) {\r\n                    this.otherTradePanelInput.setSymbol(this.symbol, this.name, this.logo);\r\n                }\r\n                this.symbol = symbol;\r\n                this.name = name;\r\n                this.logo = logo;\r\n                let liminalMarketService = new LiminalMarketService();\r\n                this.address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                this.render();\r\n                this.loadBalance().then();\r\n                yield this.loadLastTrade();\r\n                if (this.onUpdate)\r\n                    this.onUpdate();\r\n            }));\r\n        }));\r\n    }\r\n    bindQuantityListener() {\r\n        let qtyInput = document.querySelector('.' + this.tradeType + 'Inputs .trade_input input');\r\n        if (!qtyInput)\r\n            return;\r\n        let inputTimer;\r\n        qtyInput.addEventListener('keyup', (evt) => {\r\n            if (inputTimer)\r\n                clearTimeout(inputTimer);\r\n            inputTimer = setTimeout(() => {\r\n                let inputValue = evt.target.value;\r\n                this.setQuantity(inputValue);\r\n                this.loadProgressbar();\r\n                if (this.otherTradePanelInput)\r\n                    this.otherTradePanelInput.updateQuantity();\r\n                if (this.onUpdate)\r\n                    this.onUpdate();\r\n            }, 300);\r\n        });\r\n    }\r\n    bindMaxLink() {\r\n        let maxBalanceDom = document.querySelector('.' + this.tradeType + 'Inputs .balance_max');\r\n        if (!maxBalanceDom)\r\n            return;\r\n        maxBalanceDom.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let qtyInput = document.querySelector('.' + this.tradeType + 'Inputs .trade_input input');\r\n            if (!qtyInput)\r\n                return;\r\n            qtyInput.value = this.balance.toFixed();\r\n            this.setQuantity(qtyInput.value);\r\n            this.loadProgressbar();\r\n            if (this.otherTradePanelInput)\r\n                this.otherTradePanelInput.updateQuantity();\r\n            if (this.onUpdate)\r\n                this.onUpdate();\r\n        });\r\n    }\r\n    loadBalance() {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            this.balance = new bignumber(0);\r\n            let userService = new UserService();\r\n            let ethAddress = userService.getEthAddress();\r\n            let balanceDom = document.querySelector('.' + this.tradeType + 'Inputs .balance_value');\r\n            if (!balanceDom)\r\n                return;\r\n            if (this.symbol === 'aUSD') {\r\n                if (ethAddress) {\r\n                    let aUsdService = new AUSDService();\r\n                    this.balance = yield aUsdService.getAUSDBalanceOf(ethAddress);\r\n                }\r\n                balanceDom.innerHTML = '$' + this.balance;\r\n            }\r\n            else if (this.name !== '') {\r\n                this.balance = new bignumber(0);\r\n                if (ethAddress) {\r\n                    let securityTokenService = new SecurityTokenService();\r\n                    this.balance = yield securityTokenService.getQuantityByAddress(this.symbol, ethAddress);\r\n                }\r\n                balanceDom.innerHTML = this.balance.toString();\r\n            }\r\n            balanceDom.dataset.tooltip = this.balance.toString();\r\n            balanceDom.title = this.balance.toString();\r\n            this.loadProgressbar();\r\n            this.toggleMaxBalanceLink();\r\n        });\r\n    }\r\n    loadLastTrade() {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            if (this.symbol === 'aUSD') {\r\n                this.lastPrice = 1;\r\n                this.qtyPerDollar = 1;\r\n                return;\r\n            }\r\n            if (!this.otherTradePanelInput || this.name == '')\r\n                return;\r\n            let aUsdPricePerShare = document.querySelector('.' + this.otherTradePanelInput.tradeType + 'Inputs .price_per_share');\r\n            if (!aUsdPricePerShare)\r\n                return;\r\n            let pricePerShare = document.querySelector('.' + this.tradeType + 'Inputs .price_per_share');\r\n            if (!pricePerShare)\r\n                return;\r\n            aUsdPricePerShare.setAttribute('aria-busy', 'true');\r\n            pricePerShare.setAttribute('aria-busy', 'true');\r\n            let stockPriceService = new StockPriceService();\r\n            let tradeInfo = yield stockPriceService.getSymbolPrice(this.symbol, this.otherTradePanelInput.tradeType);\r\n            this.lastPrice = tradeInfo.price;\r\n            this.lastTraded = tradeInfo.lastTrade.toString();\r\n            this.qtyPerDollar = 1 / this.lastPrice;\r\n            let pricePerShareHtml = {\r\n                lastTraded: this.lastTraded,\r\n                text: ' $' + this.lastPrice + ' per share'\r\n            };\r\n            pricePerShare.innerHTML = this.pricePerShareTemplate(pricePerShareHtml);\r\n            let pricePerAUsdHtml = {\r\n                lastTraded: this.lastTraded,\r\n                text: '1 aUSD  ' + roundNumberDecimal(this.qtyPerDollar, 6) + ' ' + this.symbol\r\n            };\r\n            aUsdPricePerShare.innerHTML = this.pricePerShareTemplate(pricePerAUsdHtml);\r\n            this.updateQuantity();\r\n            aUsdPricePerShare.removeAttribute('aria-busy');\r\n            pricePerShare.removeAttribute('aria-busy');\r\n        });\r\n    }\r\n    updateQuantity() {\r\n        if (!this.otherTradePanelInput)\r\n            return;\r\n        let qtyInput = document.querySelector('.' + this.tradeType + 'Inputs .trade_input input');\r\n        if (!qtyInput)\r\n            return;\r\n        if (this.symbol === 'aUSD') {\r\n            qtyInput.value = this.otherTradePanelInput.quantity.div(this.otherTradePanelInput.qtyPerDollar).toString();\r\n        }\r\n        else {\r\n            qtyInput.value = this.otherTradePanelInput.quantity.multipliedBy(this.qtyPerDollar).toString();\r\n        }\r\n        this.setQuantity(qtyInput.value);\r\n        this.loadProgressbar();\r\n    }\r\n    loadProgressbar() {\r\n        if (this.quantity.eq(0) || this.balance.eq(0) || this.tradeType == TradeType.Buy)\r\n            return;\r\n        let progressDom = document.querySelector('.' + this.tradeType + 'Inputs .progress');\r\n        if (!progressDom)\r\n            return;\r\n        let percentage = this.quantity.div(this.balance).toNumber();\r\n        progressDom.value = percentage;\r\n        progressDom.classList.remove('d-none');\r\n        let exceedsBalance = document.querySelector('.' + this.tradeType + 'Inputs .exceeds_wallet_balance');\r\n        if (percentage > 1) {\r\n            exceedsBalance.classList.remove('d-none');\r\n            progressDom.setAttribute('aria-invalid', 'true');\r\n        }\r\n        else {\r\n            exceedsBalance.classList.add('d-none');\r\n        }\r\n    }\r\n    static switchPanels(sellTradePanelInput, buyTradePanelInput) {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            let sellSymbol = sellTradePanelInput.symbol;\r\n            let sellName = sellTradePanelInput.name;\r\n            let sellLogo = sellTradePanelInput.logo;\r\n            let sellQuantity = sellTradePanelInput.quantity;\r\n            sellTradePanelInput.setSymbol(buyTradePanelInput.symbol, buyTradePanelInput.name, buyTradePanelInput.logo);\r\n            sellTradePanelInput.quantity = buyTradePanelInput.quantity;\r\n            buyTradePanelInput.setSymbol(sellSymbol, sellName, sellLogo);\r\n            buyTradePanelInput.quantity = sellQuantity;\r\n            yield sellTradePanelInput.updatePanel();\r\n            yield buyTradePanelInput.updatePanel();\r\n            return [sellTradePanelInput, buyTradePanelInput];\r\n        });\r\n    }\r\n    setQuantity(value) {\r\n        if (value == '' || value == '0')\r\n            return;\r\n        this.quantity = new bignumber(value);\r\n        this.strQuantity = value;\r\n    }\r\n    quantityFormatted() {\r\n        return (this.symbol === 'aUSD') ? '$' + this.quantity : this.quantity;\r\n    }\r\n    updatePanel() {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            this.updateQuantity();\r\n            this.render(true);\r\n            yield this.loadBalance();\r\n            yield this.loadLastTrade();\r\n        });\r\n    }\r\n    toggleMaxBalanceLink() {\r\n        let maxBalanceDom = document.querySelector('.' + this.tradeType + 'Inputs .balance_max');\r\n        if (!maxBalanceDom)\r\n            return;\r\n        if (this.balance.eq(0)) {\r\n            maxBalanceDom.classList.add('d-none');\r\n        }\r\n        else {\r\n            maxBalanceDom.classList.remove('d-none');\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/TradeSwitch.html\n// Module\nvar TradeSwitch_code = \"<div class=\\\"grid tradeSwitch\\\">\\r\\n    <a title=\\\"Switch the trade\\\" href=\\\"\\\" class=\\\"switchBtn\\\" class=\\\"outline\\\"></a>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const tradepanel_TradeSwitch = (TradeSwitch_code);\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/TradeSwitch.ts\nvar TradeSwitch_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass TradeSwitch {\r\n    constructor() {\r\n        this.template = undefined;\r\n        this.template = Handlebars.compile(tradepanel_TradeSwitch);\r\n    }\r\n    renderToString() {\r\n        return this.template();\r\n    }\r\n    render() {\r\n        let dom = document.querySelector('.tradeSwitch');\r\n        if (!dom)\r\n            return;\r\n        dom.outerHTML = this.renderToString();\r\n    }\r\n    bindEvents(sellTradePanelInput, buyTradePanelInput, executeTradeButton) {\r\n        let dom = document.querySelector('.switchBtn');\r\n        if (!dom)\r\n            return;\r\n        dom.addEventListener('click', (evt) => TradeSwitch_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            [sellTradePanelInput, buyTradePanelInput] = yield TradePanelInput.switchPanels(sellTradePanelInput, buyTradePanelInput);\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/TradePanel.ts\nvar TradePanel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass TradePanel {\r\n    constructor() {\r\n        this.quantity = 0;\r\n    }\r\n    render(elementId, symbol, name, logo, address) {\r\n        return TradePanel_awaiter(this, void 0, void 0, function* () {\r\n            let element = document.getElementById(elementId);\r\n            if (!element)\r\n                return;\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let sellTradeInput = new TradePanelInput(\"aUSD\", \"aUSD at Broker\", \"/img/ausd.png\", contractInfo.AUSD_ADDRESS, TradeType.Sell);\r\n            let buyTradeInput;\r\n            if (!symbol) {\r\n                buyTradeInput = new TradePanelInput(\"Select stock\", \"\", \"\", \"\", TradeType.Buy);\r\n            }\r\n            else {\r\n                buyTradeInput = new TradePanelInput(symbol, name, logo, address, TradeType.Buy);\r\n            }\r\n            sellTradeInput.setOtherTradePanelInput(buyTradeInput);\r\n            buyTradeInput.setOtherTradePanelInput(sellTradeInput);\r\n            let tradeSwitch = new TradeSwitch();\r\n            let sellInput = sellTradeInput.renderToString();\r\n            let buyInput = buyTradeInput.renderToString();\r\n            let switchHtml = tradeSwitch.renderToString();\r\n            element.innerHTML = sellInput + switchHtml + buyInput;\r\n            yield sellTradeInput.loadBalance();\r\n            yield buyTradeInput.loadBalance();\r\n            if (symbol) {\r\n                yield buyTradeInput.loadLastTrade();\r\n            }\r\n            sellTradeInput.bindEvents();\r\n            buyTradeInput.bindEvents();\r\n            let executeTradeButton = new ExecuteOrderButton(sellTradeInput, buyTradeInput);\r\n            yield executeTradeButton.renderButton();\r\n            tradeSwitch.bindEvents(sellTradeInput, buyTradeInput, executeTradeButton);\r\n            sellTradeInput.onUpdate = () => {\r\n                if (buyTradeInput.isDirty)\r\n                    buyTradeInput.updatePanel();\r\n                executeTradeButton.renderButton();\r\n            };\r\n            buyTradeInput.onUpdate = () => {\r\n                if (sellTradeInput.isDirty)\r\n                    sellTradeInput.updatePanel();\r\n                executeTradeButton.renderButton();\r\n            };\r\n        });\r\n    }\r\n    formatBuyPanel(symbol, name, logo, tradeType, contractAddress) {\r\n        document.getElementById('liminal_market_select_symbol').innerHTML = symbol;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/pages/trade.html\n// Module\nvar trade_code = \"<div id=\\\"tradingPanel\\\">\\r\\n    <a href=\\\"#use_wallet_for_orders\\\" id=\\\"use_wallet_for_orders_link\\\" class=\\\"not_visible\\\">Trade in your wallet instead of\\r\\n        here</a>\\r\\n    <article id=\\\"liminal_market_trade_panel\\\"></article>\\r\\n    <div id=\\\"executing-order-progress\\\" class=\\\"hidden\\\">\\r\\n        <div id=\\\"progress-text\\\"></div>\\r\\n        <progress></progress>\\r\\n    </div>\\r\\n    <button id=\\\"liminal_market_execute_trade\\\"></button>\\r\\n\\r\\n    <article id=\\\"use_wallet_for_orders\\\">\\r\\n\\r\\n        <h3>How to buy in wallet</h3>\\r\\n        <ul>\\r\\n            <li>If you haven't added aUSD to your wallet, now is the time - <small><a href=\\\"\\\" id=\\\"addAUSDToWallet\\\">Click\\r\\n                here to add aUSD to wallet</a></small></li>\\r\\n            <li><a href=\\\"\\\" class=\\\"findSymbol\\\">Find symbol</a> you want to buy & click \\\"Get address\\\"</li>\\r\\n            <li>Go to your wallet and find the aUSD token, click \\\"Send\\\"</li>\\r\\n            <li>Paste in the address you just copied for the Receiver.\\r\\n                <ul>\\r\\n                    <li><em>Note: If you can, save the address to your contact list for easy access next time</em></li>\\r\\n                </ul>\\r\\n            </li>\\r\\n\\r\\n            <li>Type in the amount & click Confirm</li>\\r\\n            <li>You have now bought the shares, don't forget to <a href=\\\"\\\" class=\\\"findSymbol\\\">add the token to wallet</a>. &#127881;</li>\\r\\n        </ul>\\r\\n        <div style=\\\"text-align: center;\\\">\\r\\n            <!--\\r\\n                        <iframe width=\\\"380\\\" height=\\\"500\\\" src=\\\"https://www.youtube.com/embed/m1iNotgaic4?autoplay=1&cc_load_policy=1&playlist=m1iNotgaic4&loop=1\\\" title=\\\"YouTube video player\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\\\" allowfullscreen></iframe>\\r\\n            -->\\r\\n        </div>\\r\\n\\r\\n\\r\\n        <h3>Sell your securities</h3>\\r\\n\\r\\n        <ul>\\r\\n            <li>Find the token you want so sell in you wallet and click Send</li>\\r\\n            <li>Put the in the aUSD address<br/><input id=\\\"aUsdAddress\\\" value=\\\"{{AUSDAddress}}\\\">\\r\\n                <ul>\\r\\n                    <li><em>Note: If you can, save the address to your contact list for easy access next time</em></li>\\r\\n                </ul>\\r\\n            </li>\\r\\n            <li>Type in the quantity of shares you want to sell & click Confirm</li>\\r\\n            <li>You have now sold the shares &#127881;</li>\\r\\n        </ul>\\r\\n\\r\\n    </article>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const trade = (trade_code);\n;// CONCATENATED MODULE: ./src/html/modal/CopyTokenAddressToAddToWallet.html\n// Module\nvar CopyTokenAddressToAddToWallet_code = \"\\r\\n\\r\\n    You can copy the address of {{symbol}} and import it into your wallet\\r\\n    <input id=\\\"tokenAddress\\\" value=\\\"{{tokenAddress}}\\\" />\\r\\n\\r\\n\";\n// Exports\n/* harmony default export */ const CopyTokenAddressToAddToWallet = (CopyTokenAddressToAddToWallet_code);\n;// CONCATENATED MODULE: ./src/ui/pages/TradePage.ts\nvar TradePage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TradePage {\r\n    constructor() {\r\n        this.contractInfo = ContractInfo.getContractInfo();\r\n    }\r\n    load(symbol, name, logo, address) {\r\n        return TradePage_awaiter(this, void 0, void 0, function* () {\r\n            let mainContainer = document.getElementById('main_container');\r\n            if (!mainContainer)\r\n                return;\r\n            let template = Handlebars.compile(trade);\r\n            mainContainer.innerHTML = template({ AUSDAddress: this.contractInfo.AUSD_ADDRESS });\r\n            let tradePanel = new TradePanel();\r\n            yield tradePanel.render('liminal_market_trade_panel');\r\n            if (symbol) {\r\n                yield this.selectSymbol(symbol, name, logo, address);\r\n            }\r\n            AUSDService.onAUsdLoad.push(() => {\r\n                this.loadBuyWithWallet();\r\n            });\r\n            let findSymbols = document.querySelectorAll('.findSymbol');\r\n            findSymbols === null || findSymbols === void 0 ? void 0 : findSymbols.forEach(findSymbol => {\r\n                findSymbol.addEventListener('click', (evt) => {\r\n                    evt.preventDefault();\r\n                    let securitiesModal = new SecuritiesListModal();\r\n                    securitiesModal.showModal(() => {\r\n                        securitiesModal.hideModal();\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    selectSymbol(symbol, name, logo, address) {\r\n        return TradePage_awaiter(this, void 0, void 0, function* () {\r\n            let tradePanel = new TradePanel();\r\n            yield tradePanel.render('liminal_market_trade_panel', symbol, name, logo, address);\r\n        });\r\n    }\r\n    loadBuyWithWallet() {\r\n        return TradePage_awaiter(this, void 0, void 0, function* () {\r\n            let user = new UserService();\r\n            let ethAddress = user.getEthAddress();\r\n            if (!ethAddress) {\r\n                return;\r\n            }\r\n            let aUSDService = new AUSDService();\r\n            let ausdAmount = yield aUSDService.getAUSDBalanceOf(ethAddress);\r\n            let userWallet = document.getElementById('use_wallet_for_orders');\r\n            let userWalletLink = document.getElementById('use_wallet_for_orders_link');\r\n            if (ausdAmount.eq(0)) {\r\n                userWallet === null || userWallet === void 0 ? void 0 : userWallet.classList.add('hidden');\r\n                userWalletLink === null || userWalletLink === void 0 ? void 0 : userWalletLink.classList.add('not_visible');\r\n            }\r\n            else {\r\n                userWallet === null || userWallet === void 0 ? void 0 : userWallet.classList.remove('hidden');\r\n                userWalletLink === null || userWalletLink === void 0 ? void 0 : userWalletLink.classList.remove('not_visible');\r\n            }\r\n            let addAUSDToWallet = document.getElementById('addAUSDToWallet');\r\n            addAUSDToWallet === null || addAUSDToWallet === void 0 ? void 0 : addAUSDToWallet.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let walletHelper = new WalletHelper();\r\n                walletHelper.addTokenToWallet(this.contractInfo.AUSD_ADDRESS, 'aUSD', () => {\r\n                    let modal = new Modal();\r\n                    let template = Handlebars.compile(CopyTokenAddressToAddToWallet);\r\n                    let content = template({ symbol: 'aUSD', tokenAddress: this.contractInfo.AUSD_ADDRESS });\r\n                    modal.showModal('Add aUSD to wallet', content);\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/pages/stockspage.html\n// Module\nvar stockspage_code = \"\\r\\n<article id=\\\"stockList\\\">\\r\\n <div id=\\\"ua\\\"></div>\\r\\n <div id=\\\"list_of_securities\\\">{{{securities}}}</div>\\r\\n\\r\\n</article>\";\n// Exports\n/* harmony default export */ const stockspage = (stockspage_code);\n;// CONCATENATED MODULE: ./src/ui/pages/StocksPage.ts\nvar StocksPage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass StocksPage {\r\n    constructor() {\r\n    }\r\n    load() {\r\n        return StocksPage_awaiter(this, void 0, void 0, function* () {\r\n            let mainContainer = document.getElementById('main_container');\r\n            if (!mainContainer)\r\n                return;\r\n            let securitiesList = new SecuritiesList();\r\n            let securities = yield securitiesList.render();\r\n            let template = Handlebars.compile(stockspage);\r\n            mainContainer.innerHTML = template({ securities: securities });\r\n            yield securitiesList.loadMore();\r\n            yield securitiesList.bindEvents((symbol, name, logo) => StocksPage_awaiter(this, void 0, void 0, function* () {\r\n                let liminalMarketService = new LiminalMarketService();\r\n                let address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                let tradePage = new TradePage();\r\n                window.scrollTo(0, 0);\r\n                history.pushState(null, 'Buy stocks', '#/trade');\r\n                yield tradePage.load(symbol, name, logo, address);\r\n            }));\r\n        });\r\n    }\r\n    ;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/documents.html\n// Module\nvar documents_code = \"<h3>Documents</h3>\\r\\n<p>These are your documents for your trades, generated by the broker. These documents are trade confirmation & monthly statements.\\r\\n\\tThey are generated at the end of the day, between 06:30PM-07:30PM EST.\\r\\n</p>\\r\\n{{#if result}}\\r\\n<table class=\\\"table table-hover\\\">\\r\\n\\t<thead>\\r\\n\\t\\t<tr>\\r\\n\\t\\t\\t<th>Type</th>\\r\\n\\t\\t\\t<th>Date</th>\\r\\n\\t\\t\\t<th>Download</th>\\r\\n\\t\\t</tr>\\r\\n\\t</thead>\\r\\n\\t<tbody>\\r\\n\\t\\t{{#each result}}\\r\\n\\t\\t<tr>\\r\\n\\t\\t\\t<td title=\\\"{{id}}\\\">{{type}}</a></td>\\r\\n\\t\\t\\t<td>{{date}}</td>\\r\\n\\t\\t\\t<td><a href=\\\"\\\" class=\\\"downloadDoc\\\" data-docid=\\\"{{id}}\\\">Download</a></td>\\r\\n\\t\\t</tr>\\r\\n\\t\\t{{/each}}\\r\\n\\t</tbody>\\r\\n</table>\\r\\n{{/if}}\";\n// Exports\n/* harmony default export */ const elements_documents = (documents_code);\n;// CONCATENATED MODULE: ./src/services/backend/DocumentService.ts\nvar DocumentService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass DocumentService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    getDocuments() {\r\n        return DocumentService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.get('documents');\r\n        });\r\n    }\r\n    getDocument(documentId) {\r\n        return DocumentService_awaiter(this, void 0, void 0, function* () {\r\n            const params = {\r\n                documentId: documentId\r\n            };\r\n            return yield this.get(\"download\", params);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/CreateToken.html\n// Module\nvar CreateToken_code = \"Token for {{symbol}} does not exist. You can click the button below to create the token. This will cost a bit of gas.\\r\\n<br /><br />\\r\\nAfter the token has been created we will try to add it to your wallet.\\r\\n<br /><br />\\r\\n<button id=\\\"createTokenBtn\\\">Create token</button>\\r\\n\\r\\n<div class=\\\"d-none\\\" id=\\\"copyAddressInfo\\\">\\r\\n    You can copy the address of the token and import it into your wallet\\r\\n    <input id=\\\"tokenAddress\\\" />\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const modal_CreateToken = (CreateToken_code);\n;// CONCATENATED MODULE: ./src/ui/modals/CreateToken.ts\nvar CreateToken_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass CreateToken {\r\n    constructor() {\r\n    }\r\n    show(symbol) {\r\n        let modal = new Modal();\r\n        let template = Handlebars.compile(modal_CreateToken);\r\n        modal.showModal(\"Token \" + symbol + \" doesn't exist\", template({ symbol: symbol }));\r\n        let btn = document.getElementById('createTokenBtn');\r\n        if (!btn)\r\n            return;\r\n        btn.addEventListener('click', () => CreateToken_awaiter(this, void 0, void 0, function* () {\r\n            LoadingHelper.setLoading(btn);\r\n            let liminalMarketService = new LiminalMarketService();\r\n            let address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n            if (address === Helper_AddressZero) {\r\n                let result = yield liminalMarketService.createToken(symbol, () => {\r\n                    btn.innerHTML = 'Creating token. Give it few seconds';\r\n                });\r\n                if (result instanceof BlockchainError && result.code == BlockchainError.UserCancelled) {\r\n                    LoadingHelper.removeLoading();\r\n                    return;\r\n                }\r\n                address = result;\r\n            }\r\n            LoadingHelper.removeLoading();\r\n            btn.innerHTML = 'Add token to wallet';\r\n            let walletHelper = new WalletHelper();\r\n            yield walletHelper.addTokenToWallet(address, symbol, () => {\r\n                let tokenAddressInput = document.getElementById('tokenAddress');\r\n                if (!tokenAddressInput)\r\n                    return;\r\n                tokenAddressInput.innerHTML = address;\r\n                document.getElementById('copyAddressInfo').classList.remove('d-none');\r\n            });\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/pages/positions.html\n// Module\nvar positions_code = \"<article class=\\\"loaded-content2\\\">\\r\\n\\t<h3>Positions<!-- <a href=\\\"\\\" role=\\\"button\\\" id=\\\"syncWallet\\\">Sync wallet</a>--></h3>\\r\\n\\t<figure>\\r\\n\\t<table>\\r\\n\\t\\t<thead>\\r\\n\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t<th></th>\\r\\n\\t\\t\\t\\t<th>Symbol</th>\\r\\n\\t\\t\\t\\t<th>Current price</th>\\r\\n\\t\\t\\t\\t<th>Avg. entry value</th>\\r\\n\\t\\t\\t\\t<th>Quantity</th>\\r\\n\\t\\t\\t\\t<th>Market value</th>\\r\\n\\t\\t\\t\\t<th>Unrealize PL</th>\\r\\n\\t\\t\\t\\t<th>Trade</th>\\r\\n\\t\\t\\t\\t<th>Add to wallet</th>\\r\\n\\t\\t\\t</tr>\\r\\n\\t\\t</thead>\\r\\n\\t\\t<tbody>\\r\\n\\t\\t\\t{{#if result}}\\r\\n\\t\\t\\t{{#each result}}\\r\\n\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t<td class=\\\"symbol_logo\\\"><img id=\\\"symbol_logo_{{symbol}}\\\" src=\\\"/img/logos/default_logo.png\\\" /></td>\\r\\n\\t\\t\\t\\t<td><a href=\\\"https://strike.market/stocks/{{symbol}}\\\" target=\\\"_blank\\\">{{symbol}}</a></td>\\r\\n\\t\\t\\t\\t<td>{{current_price}}</td>\\r\\n\\t\\t\\t\\t<td>{{round2 avg_entry_price}}</td>\\r\\n\\t\\t\\t\\t<td>{{round2 qty}}</td>\\r\\n\\t\\t\\t\\t<td>${{round market_value}}</td>\\r\\n\\t\\t\\t\\t<td class=\\\"{{classColor unrealized_pl}}\\\">${{round unrealized_pl}} ({{perc unrealized_plpc}})</td>\\r\\n\\t\\t\\t\\t<td><a href=\\\"#\\\" class=\\\"tradeSecurity\\\" data-symbol=\\\"{{symbol}}\\\" data-qty={{qty}}>Trade</a></td>\\r\\n\\t\\t\\t\\t<td><a href=\\\"\\\" class=\\\"addToWallet\\\" data-symbol=\\\"{{symbol}}\\\">Add</a></td>\\r\\n\\t\\t\\t</tr>\\r\\n\\t\\t\\t{{/each}}\\r\\n\\t\\t\\t{{^}}\\r\\n\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t<td colspan=\\\"9\\\">No trades have been executed on this wallet. Start trading to see\\r\\n\\t\\t\\t\\t\\tyour positions\\r\\n\\t\\t\\t\\t</td>\\r\\n\\t\\t\\t</tr>\\r\\n\\t\\t\\t{{/if}}\\r\\n\\t\\t</tbody>\\r\\n\\t</table>\\r\\n\\t</figure>\\r\\n\\t<div id=\\\"documents\\\"></div>\\r\\n\\r\\n</article>\";\n// Exports\n/* harmony default export */ const pages_positions = (positions_code);\n;// CONCATENATED MODULE: ./src/services/backend/PositionsService.ts\nvar PositionsService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass PositionsService extends BaseService {\r\n    constructor() {\r\n        super();\r\n    }\r\n    getPositions(address) {\r\n        return PositionsService_awaiter(this, void 0, void 0, function* () {\r\n            let userPosition = yield this.get('positions', { address });\r\n            return userPosition === null || userPosition === void 0 ? void 0 : userPosition.positions;\r\n        });\r\n    }\r\n    getUserPositions(address) {\r\n        return PositionsService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.get('positions', { address });\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/pages/BasePage.ts\n\r\nclass BasePage {\r\n    constructor() {\r\n        this.user = App.User;\r\n        this.network = App.Network;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/pages/PositionsPage.ts\nvar PositionsPage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PositionsPage extends BasePage {\r\n    constructor() {\r\n        super();\r\n        this.documentService = new DocumentService();\r\n    }\r\n    load() {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            let mainContainer = document.getElementById('main_container');\r\n            if (!mainContainer)\r\n                return;\r\n            let userService = new UserService();\r\n            let positionService = new PositionsService();\r\n            let positions = yield positionService.getPositions(userService.getEthAddress());\r\n            if (!positions)\r\n                positions = [];\r\n            HandlebarHelpers.registerHelpers();\r\n            let template = Handlebars.compile(pages_positions);\r\n            mainContainer.innerHTML = template({ result: positions });\r\n            let symbols = new Array();\r\n            const sellLinks = document.getElementsByClassName('tradeSecurity');\r\n            for (let i = 0; i < sellLinks.length; i++) {\r\n                let element = sellLinks[i];\r\n                let symbol = element.dataset.symbol;\r\n                if (!symbol)\r\n                    continue;\r\n                symbols.push(symbol);\r\n                sellLinks[i].addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    let element = evt.target;\r\n                    let symbol = element.dataset.symbol;\r\n                    if (!symbol)\r\n                        return;\r\n                    let liminalMarketService = new LiminalMarketService();\r\n                    let contractAddress = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                    let securitiesService = yield SecuritiesService.getInstance();\r\n                    let security = yield securitiesService.getSecurityBySymbol(symbol);\r\n                    let tradePage = new TradePage();\r\n                    yield tradePage.load(symbol, security.Name, security.LogoPath + security.Logo, contractAddress);\r\n                    window.scrollTo(0, 0);\r\n                }));\r\n            }\r\n            const addToWalletLinks = document.getElementsByClassName('addToWallet');\r\n            for (let i = 0; i < addToWalletLinks.length; i++) {\r\n                addToWalletLinks[i].addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    console.log(evt.target);\r\n                    let element = addToWalletLinks[i];\r\n                    let symbol = element.dataset.symbol;\r\n                    let liminalMarketService = new LiminalMarketService();\r\n                    let contractAddress = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                    if (contractAddress.toString() == Helper_AddressZero) {\r\n                        let createToken = new CreateToken();\r\n                        createToken.show(symbol);\r\n                        return;\r\n                    }\r\n                    let walletHelper = new WalletHelper();\r\n                    yield walletHelper.addTokenToWallet(contractAddress.toString(), symbol, () => {\r\n                        let modal = new Modal();\r\n                        let template = Handlebars.compile(AddressInfo);\r\n                        let content = template({ symbol: symbol, address: contractAddress });\r\n                        modal.showModal('Import token to wallet', content);\r\n                    });\r\n                }));\r\n            }\r\n            yield this.renderSymbolLogos(symbols);\r\n            let docTemplate = Handlebars.compile(elements_documents);\r\n            let documents = yield this.documentService.getDocuments();\r\n            let documentDom = document.getElementById('documents');\r\n            if (!documentDom)\r\n                return;\r\n            documentDom.innerHTML = docTemplate({ result: documents });\r\n            yield this.initDocuments();\r\n        });\r\n    }\r\n    renderSymbolLogos(symbols) {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            const assets = yield securitiesService.getSecurities();\r\n            let asset;\r\n            for (let i = 0; i < symbols.length; i++) {\r\n                asset = assets.get(symbols[i]);\r\n                if (asset) {\r\n                    document.getElementById('symbol_logo_' + symbols[i]).setAttribute('src', '/img/logos/' + asset.Logo);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    initDocuments() {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.user.isLoggedIn)\r\n                return;\r\n            const links = document.getElementsByClassName('downloadDoc');\r\n            for (let i = 0; i < links.length; i++) {\r\n                links[i].addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    let documentId = links[i].dataset.docid;\r\n                    if (!documentId)\r\n                        return;\r\n                    let locationUrl = yield this.documentService.getDocument(documentId);\r\n                    if (locationUrl == '') {\r\n                        alert('Could not find document. Please contact us if you should have gotten a document');\r\n                        return;\r\n                    }\r\n                    window.location = locationUrl;\r\n                }));\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/routing/Routing.ts\nvar Routing_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Routing {\r\n    constructor() {\r\n        this.settings = {\r\n            show_trade: this.showTrade,\r\n            show_positions: this.showPositions,\r\n            show_stocks: this.showStocks,\r\n            show_kyc_action_required: this.showKycActionRequired,\r\n            show_funding: this.showFunding,\r\n            show_kyc: this.showKyc\r\n        };\r\n    }\r\n    loadRoutes() {\r\n        var _a;\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            let path = window.location.hash.replace('#', '').replace('/', '');\r\n            if (path === '')\r\n                path = 'stocks';\r\n            this.attachNavLinks();\r\n            let fn = (_a = this.settings['show_' + path]) !== null && _a !== void 0 ? _a : this.settings['show_stocks'];\r\n            if (typeof fn === 'function') {\r\n                yield fn(this);\r\n            }\r\n            else {\r\n                yield fn(this.settings['show_stocks']);\r\n            }\r\n        });\r\n    }\r\n    showKycActionRequired(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage();\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/kyc_action_required');\r\n            let button = document.getElementById('liminal_market_execute_trade');\r\n            button === null || button === void 0 ? void 0 : button.dispatchEvent(new MouseEvent('click'));\r\n        });\r\n    }\r\n    showKyc(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage();\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/kyc');\r\n            let button = document.getElementById('liminal_market_execute_trade');\r\n            button === null || button === void 0 ? void 0 : button.dispatchEvent(new MouseEvent('click'));\r\n        });\r\n    }\r\n    showFunding(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage();\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/funding');\r\n            let aUSDFundingModal = new FakeAUSDFund();\r\n            if (App.Network.TestNetwork) {\r\n                aUSDFundingModal.showAUSDFakeFund();\r\n            }\r\n            else {\r\n                aUSDFundingModal.showAUSDFund();\r\n            }\r\n        });\r\n    }\r\n    showTrade(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage();\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/trade');\r\n        });\r\n    }\r\n    showStocks(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new StocksPage();\r\n            yield page.load();\r\n            history.pushState(null, 'Stocks', '#/stocks');\r\n        });\r\n    }\r\n    showPositions(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new PositionsPage();\r\n            yield page.load();\r\n            history.pushState(null, 'Positions', '#/positions');\r\n        });\r\n    }\r\n    attachNavLinks() {\r\n        let router = this;\r\n        let tradeNavLinks = document.querySelectorAll('.tradeNavLink');\r\n        tradeNavLinks.forEach(link => {\r\n            link.addEventListener('click', (evt) => Routing_awaiter(this, void 0, void 0, function* () {\r\n                WalletHelper.hideMagicWallet();\r\n                yield router.showTrade(router, evt);\r\n                link.parentElement.parentElement.parentElement.removeAttribute('open');\r\n            }));\r\n        });\r\n        let investLinks = document.querySelectorAll('.investNavLink');\r\n        investLinks.forEach(link => {\r\n            link.addEventListener('click', (evt) => Routing_awaiter(this, void 0, void 0, function* () {\r\n                WalletHelper.hideMagicWallet();\r\n                yield router.showStocks(router, evt);\r\n                link.parentElement.parentElement.parentElement.removeAttribute('open');\r\n            }));\r\n        });\r\n        let positionLinks = document.querySelectorAll('.positionNavLink');\r\n        positionLinks.forEach(link => {\r\n            link.addEventListener('click', (evt) => Routing_awaiter(this, void 0, void 0, function* () {\r\n                WalletHelper.hideMagicWallet();\r\n                yield router.showPositions(router, evt);\r\n                link.parentElement.parentElement.parentElement.removeAttribute('open');\r\n            }));\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/Header.ts\nvar Header_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass Header {\r\n    load() {\r\n        return Header_awaiter(this, void 0, void 0, function* () {\r\n            this.loadImage();\r\n            yield this.showUserOptions();\r\n        });\r\n    }\r\n    loadImage() {\r\n        return Header_awaiter(this, void 0, void 0, function* () {\r\n            let header = document.querySelector('body > header');\r\n            if (!header)\r\n                return;\r\n            let random = Math.floor(Math.random() * 10);\r\n            header.style.backgroundImage = \"url(/img/header/\" + random + \".jpg)\";\r\n        });\r\n    }\r\n    showUserOptions() {\r\n        return Header_awaiter(this, void 0, void 0, function* () {\r\n            let authenticationService = new AuthenticateService();\r\n            let isAuthenticated = yield authenticationService.isAuthenticated();\r\n            if (!isAuthenticated) {\r\n                let connectWallet = new ConnectWallet();\r\n                connectWallet.renderButton('user_header_info');\r\n                return;\r\n            }\r\n            let userInfo = new UserInfo(App.User.providerInfo);\r\n            yield userInfo.render('user_header_info');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/UserPosition.ts\nvar UserPosition_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass UserPosition {\r\n    constructor() {\r\n    }\r\n    static registerListener() {\r\n        UserInfo.onUserLoggedIn.push(() => UserPosition_awaiter(this, void 0, void 0, function* () {\r\n            let userPosition = new UserPosition();\r\n            userPosition.render();\r\n        }));\r\n    }\r\n    render() {\r\n        return UserPosition_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService();\r\n            let positionService = new PositionsService();\r\n            let userPosition = yield positionService.getUserPositions(userService.getEthAddress());\r\n            if (!userPosition)\r\n                return;\r\n            let pl_status = document.querySelector('.pl_status');\r\n            pl_status === null || pl_status === void 0 ? void 0 : pl_status.classList.remove('hidden');\r\n            pl_status === null || pl_status === void 0 ? void 0 : pl_status.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let positionPage = new PositionsPage();\r\n                positionPage.load();\r\n            });\r\n            let unrealized_pl = document.getElementById('unrealized_pl');\r\n            if (unrealized_pl) {\r\n                let number = new bignumber(userPosition.unrealizedPL);\r\n                unrealized_pl.innerHTML = '$' + number.decimalPlaces(0).toFixed();\r\n                let className = this.getClassName(userPosition.unrealizedPL);\r\n                unrealized_pl.classList.add(className);\r\n            }\r\n            let unrealized_plpc = document.getElementById('unrealized_plpc');\r\n            if (unrealized_plpc) {\r\n                let number = new bignumber(userPosition.unrealizedPLPc);\r\n                unrealized_plpc.innerHTML = number.multipliedBy(100).decimalPlaces(2).toFixed() + '%';\r\n                let className = this.getClassName(userPosition.unrealizedPL);\r\n                unrealized_plpc.classList.add(className);\r\n            }\r\n        });\r\n    }\r\n    getClassName(value) {\r\n        return (value.toString().indexOf('-') == -1) ? 'green' : 'red';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/TradeExecuted.html\n// Module\nvar TradeExecuted_code = \"\\r\\n<article class=\\\"trade_executed\\\">\\r\\n    <nav>\\r\\n    <ul>\\r\\n        <li>\\r\\n            <img src=\\\"{{sellingLogo}}\\\"><br />\\r\\n            {{sellingSymbol}}<br />\\r\\n            {{sellingAmount}}\\r\\n        </li>\\r\\n    </ul>\\r\\n    <ul>\\r\\n        <li> ----> </li>\\r\\n    </ul>\\r\\n    <ul>\\r\\n        <li>\\r\\n            <img src=\\\"{{buyingLogo}}\\\" /><br />\\r\\n            {{buyingSymbol}}<br />\\r\\n            <abbr title=\\\"{{buyingQuantity}}\\\" data-tooltip=\\\"{{buyingQuantity}}\\\">{{buyingRoundQuantity}}</abbr>\\r\\n        </li>\\r\\n    </ul>\\r\\n    </nav>\\r\\n    <div>\\r\\n        If you haven't already, add the {{buyingSymbol}} to your wallet.\\r\\n        <br /><br />\\r\\n        <button id=\\\"addTokenToWallet\\\" data-address=\\\"{{tokenAddress}}\\\">Add {{buyingSymbol}} to wallet</button>\\r\\n        <div id=\\\"addTokenToWalletFailed\\\" class=\\\"d-none\\\">\\r\\n            You can copy the address, to import the token\\r\\n            <input value=\\\"{{tokenAddress}}\\\" />\\r\\n        </div>\\r\\n        <br />\\r\\n        Should be visible in your {{walletName}} on address {{shortEthAddress}}.\\r\\n        <br /><br />\\r\\n        <small>You can view the <a href=\\\"{{blockExplorerLink}}\\\" target=\\\"_blank\\\">block transaction here</a></small>\\r\\n    </div>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const TradeExecuted = (TradeExecuted_code);\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/OrderExecutedModal.ts\nvar OrderExecutedModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst confetti = __webpack_require__(/*! canvas-confetti */ \"./node_modules/canvas-confetti/dist/confetti.module.mjs\");\r\nclass OrderExecutedModal {\r\n    show(object) {\r\n        var _a;\r\n        return OrderExecutedModal_awaiter(this, void 0, void 0, function* () {\r\n            yield AUsdBalance.forceLoadAUSDBalanceUI();\r\n            OrderProgress.getInstance().clearProgressText();\r\n            let providerInfo = ProviderInfo.Instance;\r\n            let networkInfo = App.Network;\r\n            let isBuy = (object.side == 'buy');\r\n            let obj = (isBuy) ? this.getBuyingSharesObj(object) : this.getSellSharesObj(object);\r\n            obj.walletName = (_a = providerInfo === null || providerInfo === void 0 ? void 0 : providerInfo.WalletName) !== null && _a !== void 0 ? _a : '';\r\n            obj.blockExplorerLink = networkInfo.BlockExplorer + '/tx/' + object.transaction_hash;\r\n            let template = Handlebars.compile(TradeExecuted);\r\n            let content = template(obj);\r\n            let modal = new Modal();\r\n            modal.showModal('Trade executed', content);\r\n            let myCanvas = document.createElement('canvas');\r\n            myCanvas.id = 'confetti';\r\n            document.querySelector('.trade_executed').appendChild(myCanvas);\r\n            let myConfetti = confetti.create(myCanvas, { resize: true, useWorker: true });\r\n            myConfetti({ particleCount: 200, spread: 200 });\r\n            let addTokenToWallet = document.getElementById('addTokenToWallet');\r\n            if (!addTokenToWallet)\r\n                return;\r\n            addTokenToWallet.addEventListener('click', (evt) => {\r\n                let address = evt.target.dataset.address;\r\n                let walletHelper = new WalletHelper();\r\n                walletHelper.addTokenToWallet(address, obj.buyingSymbol, () => {\r\n                    let addTokenToWalletFailed = document.getElementById('addTokenToWalletFailed');\r\n                    if (!addTokenToWalletFailed)\r\n                        return;\r\n                    addTokenToWalletFailed.classList.remove('d-none');\r\n                });\r\n            });\r\n        });\r\n    }\r\n    getBuyingSharesObj(object) {\r\n        let ethAddress = object.walletAddress;\r\n        let tokenAddress = object.tokenAddress;\r\n        let buyingQuantity = object.filled_qty;\r\n        let sellingAmount = '$' + object.amount;\r\n        return {\r\n            sellingLogo: '/img/logos/aUSD.png',\r\n            sellingSymbol: 'aUSD',\r\n            sellingAmount: sellingAmount,\r\n            buyingLogo: '/img/logos/' + object.symbol + '.png',\r\n            buyingSymbol: object.symbol,\r\n            buyingQuantity: buyingQuantity,\r\n            buyingRoundQuantity: roundNumberDecimal(buyingQuantity, 6) + ' shares',\r\n            shortEthAddress: shortEth(ethAddress),\r\n            tokenAddress: tokenAddress\r\n        };\r\n    }\r\n    getSellSharesObj(object) {\r\n        let ethAddress = object.sender;\r\n        let tokenAddress = object.recipient;\r\n        let buyingQuantity = new bignumber(object.filled_avg_price).multipliedBy(new bignumber(object.filled_qty));\r\n        let sellingAmount = object.filled_qty;\r\n        return {\r\n            sellingLogo: '/img/logos/' + object.symbol + '.png',\r\n            sellingSymbol: object.symbol,\r\n            sellingAmount: sellingAmount + ' shares',\r\n            buyingLogo: '/img/logos/aUSD.png',\r\n            buyingSymbol: 'aUSD',\r\n            buyingQuantity: buyingQuantity.toFixed(),\r\n            buyingRoundQuantity: '$' + roundBigNumberDecimal(buyingQuantity, 6).toFixed(),\r\n            shortEthAddress: shortEth(ethAddress),\r\n            tokenAddress: tokenAddress\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/EventService.ts\nvar EventService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass EventService_EventService {\r\n    static register() {\r\n        UserInfo.onUserLoggedIn.push(() => EventService_awaiter(this, void 0, void 0, function* () {\r\n            let eventService = new EventService_EventService();\r\n            eventService.listen();\r\n        }));\r\n    }\r\n    listen() {\r\n        let network = App.Network;\r\n        let eventSource = new EventSource(network.ServerUrl + '/listenForChanges?jwt=' + App.User.token);\r\n        eventSource.onmessage = (e) => EventService_awaiter(this, void 0, void 0, function* () {\r\n            let data = e.data;\r\n            console.log(e);\r\n            if (!data || data == 'ok')\r\n                return;\r\n            let obj = isJSON(data);\r\n            if (!obj) {\r\n                console.log('data is not json:', data);\r\n                return;\r\n            }\r\n            if (obj.methodName == 'OrderExecuted') {\r\n                let orderExecutedModal = new OrderExecutedModal();\r\n                orderExecutedModal.show(obj);\r\n            }\r\n            else if (obj.methodName == 'SendingToExchange') {\r\n                yield OrderProgress.getInstance().setProgressText(1, 'Received order, sending to stock exchange', obj.hash);\r\n            }\r\n            else if (obj.methodName == 'BalanceSet') {\r\n                if (obj.balance != '0') {\r\n                    ExecuteOrderButton.Instance.renderButton();\r\n                }\r\n            }\r\n            else if (obj.methodName == 'AccountValidated') {\r\n                let hasBuyingPower = obj.hasBuyingPower;\r\n                if (!hasBuyingPower) {\r\n                    let kycApproved = new KycApproved();\r\n                    kycApproved.show();\r\n                }\r\n                else if (ExecuteOrderButton.Instance) {\r\n                    ExecuteOrderButton.Instance.hasBuyingPower = obj.hasBuyingPower;\r\n                    clearInterval(ExecuteOrderButton.Instance.kycIdDoneTimeout);\r\n                    ExecuteOrderButton.Instance.renderButton();\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/main.ts\nvar main_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass App {\r\n    constructor() {\r\n        App.Network = NetworkInfo.getInstance();\r\n        console.log('network', App.Network);\r\n        App.User = new User(null, '', App.Network.ChainId, '');\r\n    }\r\n    start() {\r\n        return main_awaiter(this, void 0, void 0, function* () {\r\n            let routing = new Routing();\r\n            yield routing.loadRoutes();\r\n            UserPosition.registerListener();\r\n            EventService_EventService.register();\r\n            let header = new Header();\r\n            header.load();\r\n            if (WalletHelper.isWebview()) {\r\n                // @ts-ignore\r\n                var vConsole = new window.VConsole();\r\n            }\r\n        });\r\n    }\r\n}\r\nlet app = new App();\r\napp.start().then();\r\n// @ts-ignore\r\nwindow.app = app;\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyxLQUFLO0FBQ3pDLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxjQUFFO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQUU7QUFDbkIsSUFBSTtBQUNKLGlCQUFpQixjQUFFO0FBQ25CLGlCQUFpQixjQUFFO0FBQ25CLGlCQUFpQixjQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxjQUFFOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQzs7QUFFRDs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTtBQUNBLGFBQWEscUJBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQUU7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxjQUFFO0FBQ2pCLGVBQWUsY0FBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGNBQUU7QUFDakIsZUFBZSxjQUFFO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQSwyREFBMkQsaUNBQWlDO0FBQzVGOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0Esa0NBQWtDLG1EQUFtRCxHQUFHLEdBQUc7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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bUIsNkJBQTZCO0FBQ2hEO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBYztBQUN0QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBLGlD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RUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUU7UUFDN0UsTUFBTSxFQUFFLFNBQVM7UUFDakIsTUFBTSxFQUFFLEtBQUs7S0FDaEIsRUFBRSxFQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQyxFQUFFLEVBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUU7UUFDekUsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUUsRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUNyRSxNQUFNLEVBQUUsYUFBYTtRQUNyQixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLG1CQUFtQixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQyxFQUFFO1FBQ2pGLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLE1BQU0sRUFBRSxLQUFLO0tBQ2hCLEVBQUUsRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUNwQyxNQUFNLEVBQUUsVUFBVTtRQUNsQixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLDZCQUE2QixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUN2RCxNQUFNLEVBQUUsZUFBZTtRQUN2QixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUUsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUNwRSxNQUFNLEVBQUUsUUFBUTtRQUNoQixNQUFNLEVBQUUsS0FBSztLQUNo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d29ya3MvTmV0d29yay50cz9iY2RjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL25ldHdvcmtzL1Rlc3ROZXR3b3JrLnRzPzU4OWUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvbmV0d29ya3MvbG9jYWxob3N0LW5ldHdvcmsudHM/OTNjYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9uZXR3b3Jrcy9tdW1iYWktbmV0d29yay50cz81MjdkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvQ29va2llSGVscGVyLnRzP2Q4ZDYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvbmV0d29ya3MvTWFpbk5ldHdvcmsudHM/MWQ3NCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9uZXR3b3Jrcy9wb2x5Z29uLW5ldHdvcmsudHM/YTExZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9uZXR3b3Jrcy9OZXR3b3JrVHlwZS50cz8xY2QxIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL25ldHdvcmtzL05ldHdvcmtJbmZvLnRzP2ExYzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9Td2l0Y2hOZXR3b3JrLmh0bWw/YjVjMiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL01vZGFsLmh0bWw/MzBkYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvTW9kYWwudHM/YjllNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9icm9rZXIvU2VjdXJpdHkudHM/MDEzMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9iYWNrZW5kL0Jhc2VTZXJ2aWNlLnRzPzFhMjkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYnJva2VyL1NlY3VyaXRpZXNTZXJ2aWNlLnRzPzE4YzIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9Mb2FkaW5nSGVscGVyLnRzPzY1MmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9XYWxsZXRIZWxwZXIudHM/YTMxNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvR2VuZXJhbEVycm9yLnRzPzFkNjciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL1N3aXRjaE5ldHdvcmtNb2RhbC50cz9jM2Q1Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL192ZXJzaW9uLmpzPzIyOTQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vaW5kZXguanM/ZmZiMiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vX3ZlcnNpb24uanM/MTUyYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vaW5kZXguanM/OWJkYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9fdmVyc2lvbi5qcz80YTQ1Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL192ZXJzaW9uLmpzP2MyYmUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vaW5kZXguanM/N2NhNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ieXRlcy9saWIuZXNtL192ZXJzaW9uLmpzPzBiODIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9pbmRleC5qcz81NDllIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL192ZXJzaW9uLmpzP2E5NjAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vYmlnbnVtYmVyLmpzP2UzNmQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2L2xpYi5lc20vaW5kZXguanM/NmY1YSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9fdmVyc2lvbi5qcz8wMGNkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JscC9saWIuZXNtL2luZGV4LmpzP2UxNjUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL192ZXJzaW9uLmpzPzUwMDMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL2luZGV4LmpzPzNiMWMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL192ZXJzaW9uLmpzPzU4NzMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL192ZXJzaW9uLmpzPzJhNDkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL3V0ZjguanM/NTI3MyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vaWQuanM/MzVhOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vdHlwZWQtZGF0YS5qcz9lMTA4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2JpZ251bWJlcnMuanM/OWQ1NiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2VsbGlwdGljLmpzP2MyNGIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9fdmVyc2lvbi5qcz82MjI0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vaW5kZXguanM/YWUxYyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMvbGliLmVzbS9fdmVyc2lvbi5qcz83MTNhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzPzVhYzMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZTY0L2xpYi5lc20vYmFzZTY0LmpzPzIwN2IiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vX3ZlcnNpb24uanM/ZTMwMyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9nZXR1cmwuanM/MjFkZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9pbmRleC5qcz9iYWY3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyL2xpYi5lc20vX3ZlcnNpb24uanM/ZWI2YyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL2luZGV4LmpzP2VkYWEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmFzZXgvbGliLmVzbS9pbmRleC5qcz8yY2YyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2hhc2hlcy5qcz80ODc3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9lbnMtbm9ybWFsaXplL2RlY29kZXIuanM/N2U3ZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vZW5zLW5vcm1hbGl6ZS9pbmNsdWRlLmpzPzU3MDgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2Vucy1ub3JtYWxpemUvbGliLmpzPzZlYWUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzPzBhN2YiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbmV0d29ya3MvbGliLmVzbS9fdmVyc2lvbi5qcz8zZmI3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vaW5kZXguanM/MDEwOSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vdHlwZXMuanM/ZDQ1NyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vX3ZlcnNpb24uanM/ZTY0YSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vc2hhMi5qcz8zNzk2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcz9jMDBiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Zvcm1hdHRlci5qcz83ZjA2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Jhc2UtcHJvdmlkZXIuanM/YmM3OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1wcm92aWRlci5qcz8zZTgwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYjMtcHJvdmlkZXIuanM/ZGE0ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy93YWxsZXQvZXZlbnRzLnRzPzI0NmMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvd2FsbGV0L0Fic3RyYWN0V2ViM0Nvbm5lY3Rvci50cz8yMWFjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BtYWdpYy1zZGsvdHlwZXMvZGlzdC9lcy9pbmRleC5tanM/MTg5ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AbWFnaWMtc2RrL3Byb3ZpZGVyL2Rpc3QvZXMvaW5kZXgubWpzPzQxZjciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQG1hZ2ljLXNkay9jb21tb25zL2Rpc3QvZXMvaW5kZXgubWpzPzAwOTIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvbWFnaWMtc2RrL2Rpc3QvZXMvaW5kZXgubWpzPzMwMTMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQG1hZ2ljLWV4dC9jb25uZWN0L2Rpc3QvZXMvaW5kZXgubWpzP2U3ZmQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvd2FsbGV0L01hZ2ljV2ViM0Nvbm5lY3Rvci50cz9lMDI4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2VudW1zL1dhbGxldFR5cGUudHM/NTljYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy93YWxsZXQvUHJvdmlkZXJJbmZvLnRzPzQ4NGMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvZHRvL1VzZXIudHM/OWNjNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLm1qcz9mOGNjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2ZpeGVkbnVtYmVyLmpzPzBkMTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdW5pdHMvbGliLmVzbS9fdmVyc2lvbi5qcz8zYmM3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3VuaXRzL2xpYi5lc20vaW5kZXguanM/NzE0OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91dGlsL0hlbHBlci50cz9kYWU3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvQXV0aGVudGljYXRlU2VydmljZS50cz9lMjUwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL192ZXJzaW9uLmpzPzEwYTgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2Fic3RyYWN0LWNvZGVyLmpzPzUxMzQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2FkZHJlc3MuanM/YmRhNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYW5vbnltb3VzLmpzP2YyNWEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2FycmF5LmpzPzA0NDEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL2Jvb2xlYW4uanM/NTRkOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYnl0ZXMuanM/ZDY3ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvZml4ZWQtYnl0ZXMuanM/Yzg1MiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvbnVsbC5qcz9jMDk4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udW1iZXIuanM/OTBmZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvc3RyaW5nLmpzPzQ4YzUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL3R1cGxlLmpzP2IyYzgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vZnJhZ21lbnRzLmpzP2MxNjciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vYWJpLWNvZGVyLmpzPzU3OTEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vaW50ZXJmYWNlLmpzP2E4MDciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vX3ZlcnNpb24uanM/MzhjZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb250cmFjdHMvbGliLmVzbS9pbmRleC5qcz9mMTc5Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2NvbnRyYWN0cy9sb2NhbGhvc3QtY29udHJhY3QtYWRkcmVzc2VzLnRzPzNjNTIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvY29udHJhY3RzL211bWJhaS1jb250cmFjdC1hZGRyZXNzZXMudHM/YjA3OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9jb250cmFjdHMvZnVqaS1jb250cmFjdC1hZGRyZXNzZXMudHM/ZTU2NiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9jb250cmFjdHMvcG9seWdvbi1jb250cmFjdC1hZGRyZXNzZXMudHM/MzA1ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9jb250cmFjdHMvQ29udHJhY3RJbmZvLnRzP2IyMGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmxvY2tjaGFpbi9FdmVudFNlcnZpY2UudHM/NWQ3ZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9ibG9ja2NoYWluL0Jsb2NrY2hhaW5TZXJ2aWNlLnRzPzJkNDMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmxvY2tjaGFpbi9MaW1pbmFsTWFya2V0U2VydmljZS50cz83YjgyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvU2VjdXJpdGllc0xpc3QuaHRtbD83ZmQzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvU2VjdXJpdGllcy5odG1sPzhlODUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9Db3B5SGVscGVyLnRzPzJjYjMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9BZGRyZXNzSW5mby5odG1sP2ZiNzUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9Db250cmFjdEFkZHJlc3NOb3RGb3VuZC5odG1sP2I3ZTQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9BZGRUb1dhbGxldC5odG1sPzU2ZDYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvSW5mb0JhclR5cGUudHM/ODgwNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy9JbmZvQmFyLnRzPzYxMzciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9XYWxsZXRNaXNzaW5nLmh0bWw/ZmYyNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvUHJlZGVmaW5lZEVycm9ySGFuZGxlcnMudHM/N2Q4ZiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvRXJyb3JJbmZvLnRzPzM3ZmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvU2VjdXJpdGllc0xpc3QudHM/ZjYxMiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9icm9rZXIvTWFya2V0U2VydmljZS50cz9iNjE4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2UudHM/YmJhYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL1VzZXJJbmZvLmh0bWw/MzUwOSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNFZGl0TmFtZS5odG1sPzQ5YTMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9TdHJpbmdIZWxwZXIudHM/NGIxNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0VkaXROYW1lRm9ybS50cz84YWI3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0t5Y0VkaXRDb250YWN0Rm9ybS5odG1sPzQxMzAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9Gb3JtSGVscGVyLnRzP2ExNzEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNFZGl0Q29udGFjdEZvcm0udHM/ZDc0MyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNFZGl0VHJ1c3RlZENvbnRhY3QuaHRtbD82YzZiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvQ291bnRyeUhlbHBlci50cz8xOGI2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljRWRpdFRydXN0ZWRDb250YWN0LnRzPzk0OTkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9EYXRlSGVscGVyLnRzPzM0NGYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZS50cz9kMGM0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvZnVuZGluZy9GYWtlRnVuZGluZy5odG1sPzkzZTYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYnJva2VyL0Z1bmRpbmdTZXJ2aWNlLnRzP2U2OWMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9TZWxlY3RGdW5kaW5nVHlwZS5odG1sP2IyYTAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvUmVsYXRpb25zaGlwL1NlbGVjdEZ1bmRpbmdUeXBlLnRzPzBlMzgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9BQ0hSZWxhdGlvbnNoaXAuaHRtbD82ZTFkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2VudW1zL1RyYW5zZmVyRGlyZWN0aW9uRW51bS50cz81NTExIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL1JlbGF0aW9uc2hpcC9SZWxhdGlvbnNoaXBCYXNlLnRzPzM4NzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvUmVsYXRpb25zaGlwL0FDSFJlbGF0aW9uc2hpcC50cz82ZTRhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9UcmFuc2Zlck5vdGlmaWNhdGlvbi5odG1sPzFlZGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1RyYW5zZmVyc0xpc3QuaHRtbD8yNjgzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvSGFuZGxlYmFySGVscGVycy50cz9jOWMzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL1RyYW5zZmVyc0xpc3QudHM/MGRjYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvRmlyc3RUcmFuc2ZlclNldHVwQmFzZS50cz83NzEwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvTW9uZXlUcmFuc2ZlcnJlZC5odG1sP2QwYjEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL01vbmV5VHJhbnNmZXJyZWQudHM/OTdmYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9UcmFuc2Zlck5vdGlmaWNhdGlvbi50cz9mNDgzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9SZWxhdGlvbnNoaXAvV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwLmh0bWw/YWMwZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9SZWxhdGlvbnNoaXAvV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwLnRzP2VmNTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1RyYW5zZmVySW5mby5odG1sPzJkMjQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvVHJhbnNmZXJOb3RpZmllZC50cz85NzNjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvRmlyc3RUcmFuc2ZlclNldHVwLmh0bWw/OGRjOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0JhbmtJbmZvLmh0bWw/ZjlhNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL1dpcmVUcmFuc2Zlck1vbmV5Lmh0bWw/MjdkZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvV2lyZVRyYW5zZmVyTW9uZXkudHM/NWNjMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0FDSFRyYW5zZmVyQWNjb3VudE51bWJlci5odG1sPzg3MTIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0FDSFRyYW5zZmVyQWNjb3VudE51bWJlci50cz81ZTA3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9CYW5rSW5mby50cz9jZDlhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9GaXJzdFRyYW5zZmVyU2V0dXAudHM/Y2Y2YiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9BVVNERnVuZC50cz9mOTBjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL0Zha2VBVVNERnVuZC50cz9lMzlhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9XaXRoZHJhd01vZGFsLmh0bWw/NWU3OCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9XaXRoZHJhd01vZGFsLnRzP2NmZWQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvQVVzZEJhbGFuY2UudHM/NWIzYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL1Rlc3ROZXR3b3JrQmFubmVyLmh0bWw/NTkyYyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy9Vc2VySW5mby50cz8yZjA3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvQ29ubmVjdFdhbGxldEJ1dHRvbi5odG1sPzlmOTMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Nvbm5lY3RXYWxsZXQudHM/MGZiYyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL01hcmtldElzQ2xvc2VkLmh0bWw/YzBiNCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvQmxvY2tjaGFpbkVycm9yLnRzP2ZkNWEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmxvY2tjaGFpbi9LWUNTZXJ2aWNlLnRzP2FjOTgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmxvY2tjaGFpbi9TZWN1cml0eVRva2VuU2VydmljZS50cz9jMmNkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlVHJhZGVCdXR0b24uaHRtbD9mMTllIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRmFrZU5hdGl2ZVRva2VuTmVlZGVkLmh0bWw/YWQxNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL05hdGl2ZVRva2VuTmVlZGVkLmh0bWw/YTFiMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvTmF0aXZlVG9rZW5OZWVkZWQudHM/NGY4NyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNBY3Rpb25SZXF1aXJlZC5odG1sP2QyYWIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvV2VEb250S25vd1doeS5odG1sPzAxN2IiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvSURFTlRJVFlfVkVSSUZJQ0FUSU9OLmh0bWw/MDU2YSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9BRERSRVNTX1ZFUklGSUNBVElPTi5odG1sPzFjZTMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvQUZGSUxJQVRFRC5odG1sPzkyMzkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvQ09OVFJPTF9QRVJTT04uaHRtbD9lYTE1Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0NPVU5UUllfTk9UX1NVUFBPUlRFRC5odG1sPzM2OWMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvREFURV9PRl9CSVJUSC5odG1sPzI2ODUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvRkFNSUxZX01FTUJFUl9QRVAuaHRtbD83YTdiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0lOVkFMSURfSURFTlRJVFlfUEFTU1BPUlQuaHRtbD9hOTA0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1BFUC5odG1sPzY0NTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvU0VMRklFX1ZFUklGSUNBVElPTi5odG1sPzJiZmMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvVEFYX0lERU5USUZJQ0FUSU9OLmh0bWw/OTA3NiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9WSVNBX1RZUEVfT1RIRVIuaHRtbD81MTk0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1c4QkVOX0NPUlJFQ1RJT04uaHRtbD84ZDgwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvRmlsZVVwbG9hZC5odG1sPzM1ODYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvRmlsZVVwbG9hZC50cz82MjhjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvRm9ybVZhbGlkYXRvci50cz83YzhkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljQWN0aW9uUmVxdWlyZWQudHM/M2IwZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0tZQ01vZGFsLmh0bWw/NTBiOSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNDb250YWN0Lmh0bWw/MDMzNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvY2xvdWQvS3ljVmFsaWRhdG9yRXJyb3IudHM/MzU3OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0Jhc2UudHM/NmI3ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0NvbnRhY3QudHM/ODYxNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNJZGVudGl0eS5odG1sPzNkOTkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNJZGVudGl0eS50cz9kZTY4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0t5Y0Rpc2Nsb3N1cmVzLmh0bWw/MzBhOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNBZmZpbGlhdGVPckNvbnRyb2xsZWQuaHRtbD83MjEzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkLnRzPzM4NzEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljSW1tZWRpYXRlRmFtaWx5Lmh0bWw/MTUyYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0ltbWVkaWF0ZUZhbWlseS50cz82MWE1Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljRGlzY2xvc3VyZXMudHM/ZGYwMiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNBY2NvdW50QWdyZWVtZW50Lmh0bWw/NDEzYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0FjY291bnRBZ3JlZW1lbnQudHM/MzIwMCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNUcnVzdGVkQ29udGFjdC5odG1sP2E1MWMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNUcnVzdGVkQ29udGFjdC50cz8wZjhhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0t5Y1VwbG9hZC5odG1sPzcyMTYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNVcGxvYWQudHM/YmZlNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDRm9ybS50cz9jOTg2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljU3RhdHVzSGFuZGxlci50cz80ZjUyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0t5Y0FwcHJvdmVkLmh0bWw/ZTJiMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0FwcHJvdmVkLnRzPzBlNjMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9PcmRlclByb2dyZXNzLnRzP2QzZGYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlT3JkZXJCdXR0b24udHM/MTk1NSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lbnVtcy9UcmFkZVR5cGUudHM/OTAyMyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVJbnB1dC5odG1sP2UwMzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL1NlY3VyaXRpZXNMaXN0TW9kYWwudHM/YTc2OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9iYWNrZW5kL1RyYWRlSW5mby50cz8wNTkzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2Vycm9ycy9jbG91ZC9IdHRwRXJyb3IudHM/MzNkNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvQ2xvdWRFcnJvci50cz85YjYzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvU3RvY2tQcmljZVNlcnZpY2UudHM/YWU5NCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvUHJpY2VQZXJTaGFyZS5odG1sPzYzYTAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9UcmFkZVBhbmVsSW5wdXQudHM/NjhjYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVTd2l0Y2guaHRtbD8wNjJjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVTd2l0Y2gudHM/YzQyMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy9UcmFkZVBhbmVsLnRzP2ZhNDQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9wYWdlcy90cmFkZS5odG1sP2Y2ZjYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9Db3B5VG9rZW5BZGRyZXNzVG9BZGRUb1dhbGxldC5odG1sP2RkYzMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvcGFnZXMvVHJhZGVQYWdlLnRzPzBmOTQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9wYWdlcy9zdG9ja3NwYWdlLmh0bWw/YTJjNCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9wYWdlcy9TdG9ja3NQYWdlLnRzPzM4MzciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9kb2N1bWVudHMuaHRtbD8zOWNiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvRG9jdW1lbnRTZXJ2aWNlLnRzPzgwYjciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9DcmVhdGVUb2tlbi5odG1sPzQ5NmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0NyZWF0ZVRva2VuLnRzPzI0ZDYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9wYWdlcy9wb3NpdGlvbnMuaHRtbD82ZmE5Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvUG9zaXRpb25zU2VydmljZS50cz84YTM4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL3BhZ2VzL0Jhc2VQYWdlLnRzPzE2NmUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvcGFnZXMvUG9zaXRpb25zUGFnZS50cz9iYWRhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3JvdXRpbmcvUm91dGluZy50cz9kNjY0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL2VsZW1lbnRzL0hlYWRlci50cz9lMjMwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL2VsZW1lbnRzL1VzZXJQb3NpdGlvbi50cz8zNTA0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvdHJhZGVwYW5lbC9UcmFkZUV4ZWN1dGVkLmh0bWw/YjYyMCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy90cmFkZXBhbmVsL09yZGVyRXhlY3V0ZWRNb2RhbC50cz83YzdiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvRXZlbnRTZXJ2aWNlLnRzPzEyY2QiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvbWFpbi50cz9jZDQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IEJsb2NrY2hhaW5TZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0Jsb2NrY2hhaW5TZXJ2aWNlXCI7XHJcbmltcG9ydCB7ZXRoZXJzfSBmcm9tIFwiZXRoZXJzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZXR3b3JrIHtcclxuICAgIFNlcnZlclVybCA9IFwiXCI7XHJcbiAgICBBcHBJZCA9IFwiXCI7XHJcbiAgICBDaGFpbklkID0gMDtcclxuICAgIE5hbWUgPSBcIlwiO1xyXG4gICAgQ2hhaW5OYW1lID0gJyc7XHJcbiAgICBOYXRpdmVDdXJyZW5jeU5hbWUgPSBcIlwiO1xyXG4gICAgTmF0aXZlU3ltYm9sID0gXCJcIjtcclxuICAgIE5hdGl2ZURlY2ltYWwgPSAxODtcclxuICAgIFJwY1VybCA9ICcnO1xyXG4gICAgQmxvY2tFeHBsb3JlciA9ICcnO1xyXG4gICAgVGVzdE5ldHdvcmsgPSB0cnVlO1xyXG4gICAgRmF1Y2V0VXJsID0gJyc7XHJcbiAgICBCdXlVcmwgPSAnJztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IENoYWluSWRIZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuICcweCcgKyB0aGlzLkNoYWluSWQudG9TdHJpbmcoMTYpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGFkZE5ldHdvcmtUb1dhbGxldCgpIHtcclxuICAgICAgICBjb25zdCB3ZWIzID0gYXdhaXQgQXV0aGVudGljYXRlU2VydmljZS5lbmFibGVXZWIzKCk7XHJcbiAgICAgICAgaWYgKCF3ZWIzIHx8ICF3ZWIzLnByb3ZpZGVyLnJlcXVlc3QpIHJldHVybjtcclxuXHJcbiAgICAgICAgd2ViMy5wcm92aWRlci5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxyXG4gICAgICAgICAgICBwYXJhbXM6IFt7XHJcbiAgICAgICAgICAgICAgICBjaGFpbklkOiAnMHgnICsgdGhpcy5DaGFpbklkLnRvU3RyaW5nKDE2KSxcclxuICAgICAgICAgICAgICAgIGNoYWluTmFtZTogdGhpcy5DaGFpbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuTmF0aXZlQ3VycmVuY3lOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdGhpcy5OYXRpdmVTeW1ib2wsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRoaXMuTmF0aXZlRGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJwY1VybHM6IFt0aGlzLlJwY1VybF0sXHJcbiAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogW3RoaXMuQmxvY2tFeHBsb3Jlcl1cclxuICAgICAgICAgICAgfV1cclxuICAgICAgICB9KS5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBoYXNFbm91Z2hOYXRpdmVUb2tlbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgbGV0IGJsb2NrY2hhaW5TZXJ2aWNlID0gbmV3IEJsb2NrY2hhaW5TZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGJhbGFuY2VOYXRpdmUgPSBhd2FpdCBibG9ja2NoYWluU2VydmljZS5nZXROYXRpdmVCYWxhbmNlKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhbGFuY2UgPSBwYXJzZUZsb2F0KGJhbGFuY2VOYXRpdmUpO1xyXG4gICAgICAgIGlmIChiYWxhbmNlIDwgMC4wMDUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB9O1xyXG5cclxufVxyXG5cclxuIiwiaW1wb3J0IE5ldHdvcmsgZnJvbSBcIi4vTmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVzdE5ldHdvcmsgZXh0ZW5kcyBOZXR3b3JrIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLlNlcnZlclVybCA9IFwiaHR0cHM6Ly9jbG91ZC10ZXN0bmV0Lm9ucmVuZGVyLmNvbVwiO1xyXG4gICAgICAgIHRoaXMuVGVzdE5ldHdvcmsgPSB0cnVlO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE5ldHdvcmsgZnJvbSAnLi9OZXR3b3JrJztcclxuaW1wb3J0IFRlc3ROZXR3b3JrIGZyb20gXCIuL1Rlc3ROZXR3b3JrXCI7XHJcbi8vbG9jYWxob3N0XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGxvY2FsaG9zdE5ldHdvcmsgZXh0ZW5kcyBUZXN0TmV0d29yayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLkNoYWluSWQgPSAzMTMzNztcclxuICAgICAgICB0aGlzLk5hbWUgPSBcImxvY2FsaG9zdFwiO1xyXG4gICAgICAgIHRoaXMuQ2hhaW5OYW1lID0gJ2xvY2FsaG9zdCB0ZXN0JztcclxuICAgICAgICB0aGlzLk5hdGl2ZUN1cnJlbmN5TmFtZSA9IFwiRXRoZXJldW1cIjtcclxuICAgICAgICB0aGlzLk5hdGl2ZVN5bWJvbCA9IFwiRVRIXCI7XHJcbiAgICAgICAgdGhpcy5OYXRpdmVEZWNpbWFsID0gMTg7XHJcbiAgICAgICAgdGhpcy5ScGNVcmwgPSAnaHR0cDovLzEyNy4wLjAuMTo4NTQ1Lyc7XHJcbiAgICAgICAgdGhpcy5CbG9ja0V4cGxvcmVyID0gJ2h0dHBzOi8vcmlua2VieS5ldGhlcnNjYW4uaW8nO1xyXG4gICAgICAgIHRoaXMuU2VydmVyVXJsID0gXCJodHRwOi8vbG9jYWxob3N0OjEwMDAwXCI7XHJcblx0fVxyXG5cclxuXHJcblxyXG59XHJcblxyXG4iLCJcclxuXHJcbmltcG9ydCBOZXR3b3JrIGZyb20gJy4vTmV0d29yayc7XHJcbmltcG9ydCBUZXN0TmV0d29yayBmcm9tIFwiLi9UZXN0TmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgbXVtYmFpTmV0d29yayBleHRlbmRzIFRlc3ROZXR3b3JrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuQ2hhaW5JZCA9IDgwMDAxO1xyXG4gICAgICAgIHRoaXMuTmFtZSA9IFwibXVtYmFpXCI7XHJcbiAgICAgICAgdGhpcy5DaGFpbk5hbWUgPSAnUG9seWdvbiBNdW1iYWknO1xyXG4gICAgICAgIHRoaXMuTmF0aXZlQ3VycmVuY3lOYW1lID0gXCJNYXRpY1wiO1xyXG4gICAgICAgIHRoaXMuTmF0aXZlU3ltYm9sID0gXCJNQVRJQ1wiO1xyXG4gICAgICAgIHRoaXMuTmF0aXZlRGVjaW1hbCA9IDE4O1xyXG4gICAgICAgIHRoaXMuUnBjVXJsID0gJ2h0dHBzOi8vcG9seWdvbi1tdW1iYWkuZy5hbGNoZW15LmNvbS92Mi9GSUxUQms4RlQ5UnpjUlZ4a01YSWc3SXBsOEpDTmRLMic7XHJcbiAgICAgICAgdGhpcy5CbG9ja0V4cGxvcmVyID0gJ2h0dHBzOi8vbXVtYmFpLnBvbHlnb25zY2FuLmNvbS8nO1xyXG4gICAgICAgICAgICB0aGlzLkZhdWNldFVybCA9ICdodHRwczovL2ZhdWNldC5wb2x5Z29uLnRlY2hub2xvZ3kvJztcclxuICAgICAgICAgICAgdGhpcy5CdXlVcmwgPSAnaHR0cHM6Ly93d3cubW9vbnBheS5jb20vYnV5L21hdGljJztcclxuXHR9XHJcblxyXG5cclxuXHJcbn1cclxuXHJcbiIsIlxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29va2llSGVscGVyIHtcclxuICAgIGRvY3VtZW50OiBEb2N1bWVudFxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGRvYz86IERvY3VtZW50KSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IChkb2MpID8gZG9jIDogZG9jdW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldENvb2tpZShuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5kZWxldGVDb29raWUobmFtZSk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudC5jb29raWUgPSBuYW1lICsgXCI9XCIgKyB2YWx1ZSArIFwiOyBleHBpcmVzPU1vbiwgMiBEZWMgXCIgKyAoZGF0ZS5nZXRGdWxsWWVhcigpICsgMSkgKyBcIiAxMjowMDowMCBVVEM7cGF0aD0vO1NhbWVTaXRlPVN0cmljdDtcIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29va2llVmFsdWUobmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuY29va2llLm1hdGNoKCcoXnw7KVxcXFxzKicgKyBuYW1lICsgJ1xcXFxzKj1cXFxccyooW147XSspJyk/LnBvcCgpIHx8ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRDb29raWVQcm92aWRlcihwcm92aWRlck5hbWU6IHN0cmluZykge1xyXG4gICAgICAgdGhpcy5zZXRDb29raWUoXCJwcm92aWRlclwiLCBwcm92aWRlck5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZWxldGVDb29raWUobmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudC5jb29raWUgPSBuYW1lICsgXCI9MDsgZXhwaXJlcz1Nb24sIDIgRGVjIDIwMjAgMTI6MDA6MDAgVVRDO3BhdGg9L1wiO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE5ldHdvcmsgZnJvbSBcIi4vTmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpbk5ldHdvcmsgZXh0ZW5kcyBOZXR3b3JrIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLlNlcnZlclVybCA9IFwiaHR0cHM6Ly9jbG91ZC1tYWlubmV0Lm9ucmVuZGVyLmNvbVwiO1xyXG4gICAgICAgIHRoaXMuVGVzdE5ldHdvcmsgPSBmYWxzZTtcclxuICAgIH1cclxufSIsImltcG9ydCBOZXR3b3JrIGZyb20gJy4vTmV0d29yayc7XHJcbmltcG9ydCBNYWluTmV0d29yayBmcm9tIFwiLi9NYWluTmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgcG9seWdvbk5ldHdvcmsgZXh0ZW5kcyBNYWluTmV0d29yayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLkNoYWluSWQgPSAxMzc7XHJcbiAgICAgICAgdGhpcy5OYW1lID0gXCJwb2x5Z29uXCI7XHJcbiAgICAgICAgdGhpcy5DaGFpbk5hbWUgPSAnUG9seWdvbiBNYWlubmV0JztcclxuICAgICAgICB0aGlzLk5hdGl2ZUN1cnJlbmN5TmFtZSA9IFwiTWF0aWNcIjtcclxuICAgICAgICB0aGlzLk5hdGl2ZVN5bWJvbCA9IFwiTUFUSUNcIjtcclxuICAgICAgICB0aGlzLk5hdGl2ZURlY2ltYWwgPSAxODtcclxuICAgICAgICB0aGlzLlJwY1VybCA9ICdodHRwczovL3BvbHlnb24tcnBjLmNvbS8nO1xyXG4gICAgICAgIHRoaXMuQmxvY2tFeHBsb3JlciA9ICdodHRwczovL3BvbHlnb25zY2FuLmNvbS8nO1xyXG4gICAgICAgIHRoaXMuRmF1Y2V0VXJsID0gJ2h0dHBzOi8vZmF1Y2V0LnBvbHlnb24udGVjaG5vbG9neS8nO1xyXG4gICAgICAgIHRoaXMuQnV5VXJsID0gJ2h0dHBzOi8vd3d3Lm1vb25wYXkuY29tL2J1eS9tYXRpYyc7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuIiwiZXhwb3J0IGVudW0gTmV0d29ya1R5cGUge1xyXG4gICAgTWFpbm5ldCA9IDAsXHJcbiAgICBUZXN0bmV0ID0gMVxyXG59IiwiaW1wb3J0IGxvY2FsaG9zdE5ldHdvcmsgZnJvbSAnLi9sb2NhbGhvc3QtbmV0d29yayc7XHJcbmltcG9ydCBtdW1iYWlOZXR3b3JrIGZyb20gJy4vbXVtYmFpLW5ldHdvcmsnO1xyXG5pbXBvcnQgTmV0d29yayBmcm9tIFwiLi9OZXR3b3JrXCI7XHJcbmltcG9ydCBDb29raWVIZWxwZXIgZnJvbSBcIi4uL3V0aWwvQ29va2llSGVscGVyXCI7XHJcbmltcG9ydCBwb2x5Z29uTmV0d29yayBmcm9tIFwiLi9wb2x5Z29uLW5ldHdvcmtcIjtcclxuaW1wb3J0IHtOZXR3b3JrVHlwZX0gZnJvbSBcIi4vTmV0d29ya1R5cGVcIjtcclxuXHJcblxyXG5jb25zdCBuZXR3b3JrSW5mb3MgPSBbbG9jYWxob3N0TmV0d29yaywgbXVtYmFpTmV0d29yaywgcG9seWdvbk5ldHdvcmtdO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5ldHdvcmtJbmZvIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBOZXR3b3JrO1xyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBOZXR3b3JrIHtcclxuICAgICAgICBpZiAoTmV0d29ya0luZm8uaW5zdGFuY2UpIHJldHVybiBOZXR3b3JrSW5mby5pbnN0YW5jZTtcclxuXHJcbiAgICAgICAgTmV0d29ya0luZm8uaW5zdGFuY2UgPSB0aGlzLmdldE5ldHdvcmtJbmZvKCk7XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtJbmZvLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgbG9hZE5ldHdvcmsobmV0d29ya05hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIE5ldHdvcmtJbmZvLmluc3RhbmNlID0gdGhpcy5nZXROZXR3b3JrSW5mbyhuZXR3b3JrTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzZXROZXR3b3JrQnlDaGFpbklkKGNoYWluSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrSW5mb0J5Q2hhaW5JZChjaGFpbklkKTtcclxuICAgICAgICBpZiAobmV0d29yaykge1xyXG4gICAgICAgICAgICBOZXR3b3JrSW5mby5pbnN0YW5jZSA9IG5ldHdvcms7XHJcblxyXG4gICAgICAgICAgICBsZXQgY29va2llSGVscGVyID0gbmV3IENvb2tpZUhlbHBlcihkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGNvb2tpZUhlbHBlci5zZXRDb29raWUoJ25ldHdvcmsnLCBuZXR3b3JrLk5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldE5ldHdvcmtzKG5ldHdvcmtUeXBlPzogbnVtYmVyKTogQXJyYXk8TmV0d29yaz4ge1xyXG4gICAgICAgIGxldCBuZXR3b3JrcyA9IG5ldyBBcnJheTxOZXR3b3JrPigpO1xyXG4gICAgICAgIGxldCBpc0xvY2FsaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0LmluZGV4T2YoJ2xvY2FsaG9zdCcpICE9IC0xO1xyXG4gICAgICAgIG5ldHdvcmtJbmZvcy5mb3JFYWNoKG5ldHdvcmtJbmZvVHlwZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0bXAgPSBuZXcgbmV0d29ya0luZm9UeXBlKCk7XHJcbiAgICAgICAgICAgIGlmICghaXNMb2NhbGhvc3QgJiYgdG1wLk5hbWUgPT0gXCJsb2NhbGhvc3RcIikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5ldHdvcmtUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmtzLnB1c2godG1wKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrVHlwZSA9PSBOZXR3b3JrVHlwZS5NYWlubmV0ICYmICF0bXAuVGVzdE5ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXR3b3Jrcy5wdXNoKHRtcCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ldHdvcmtUeXBlID09IE5ldHdvcmtUeXBlLlRlc3RuZXQgJiYgdG1wLlRlc3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya3MucHVzaCh0bXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0TmV0d29ya0luZm9CeUNoYWluSWQoY2hhaW5JZDogbnVtYmVyKTogTmV0d29yayB8IHVuZGVmaW5lZCB7XHJcblxyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbzogTmV0d29yayB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgbmV0d29ya0luZm9zLmZvckVhY2gobmV0d29ya0luZm9UeXBlID0+IHtcclxuICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBuZXR3b3JrSW5mb1R5cGUoKTtcclxuICAgICAgICAgICAgaWYgKHRtcC5DaGFpbklkID09IGNoYWluSWQpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmtJbmZvID0gdG1wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtJbmZvO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXROZXR3b3JrSW5mbyhuZXR3b3JrTmFtZT86IHN0cmluZyk6IE5ldHdvcmsge1xyXG4gICAgICAgIGxldCBjb29raWVIZWxwZXIgPSBuZXcgQ29va2llSGVscGVyKGRvY3VtZW50KTtcclxuXHJcbiAgICAgICAgaWYgKCFuZXR3b3JrTmFtZSkgbmV0d29ya05hbWUgPSBjb29raWVIZWxwZXIuZ2V0Q29va2llVmFsdWUoJ25ldHdvcmsnKTtcclxuICAgICAgICBpZiAoIW5ldHdvcmtOYW1lKSBuZXR3b3JrTmFtZSA9ICdwb2x5Z29uJztcclxuXHJcbiAgICAgICAgbGV0IGlzTG9jYWwgPSAod2luZG93LmxvY2F0aW9uLmhvc3QuaW5kZXhPZignbG9jYWxob3N0JykgIT0gLTEpXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGlmIChpc0xvY2FsICYmICFuZXR3b3JrTmFtZSAmJiB3aW5kb3cuZXRoZXJldW0gJiYgd2luZG93LmV0aGVyZXVtLmNoYWluSWQpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9ICh3aW5kb3cuZXRoZXJldW0uY2hhaW5JZCkgPyB3aW5kb3cuZXRoZXJldW0uY2hhaW5JZCA6IDMxMzM3O1xyXG4gICAgICAgICAgICBsZXQgbmV0d29ya0luZm8gPSB0aGlzLmdldE5ldHdvcmtOYW1lQnlDaGFpbklkSGV4KGNoYWluSWQpO1xyXG4gICAgICAgICAgICBpZiAobmV0d29ya0luZm8pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrSW5mbztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBudWxsO1xyXG4gICAgICAgIG5ldHdvcmtJbmZvcy5mb3JFYWNoKG5ldHdvcmtJbmZvVHlwZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0bXAgPSBuZXcgbmV0d29ya0luZm9UeXBlKCk7XHJcbiAgICAgICAgICAgIGlmICh0bXAuTmFtZSA9PSBuZXR3b3JrTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbmV0d29ya0luZm8gPSB0bXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAobmV0d29ya0luZm8pIHJldHVybiBuZXR3b3JrSW5mbztcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5ldHdvcmsgJ1wiICsgbmV0d29ya05hbWUgKyBcIicgY291bGQgbm90IGJlIGZvdW5kLiBEZWZhdWx0aW5nIHRvIFBvbHlnb24gbmV0d29yay5cIik7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgcG9seWdvbk5ldHdvcmsoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXROZXR3b3JrTmFtZUJ5Q2hhaW5JZEhleChjaGFpbklkSGV4OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm86IE5ldHdvcmsgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgbmV0d29ya0luZm9zLmZvckVhY2gobmV0d29ya0luZm9UeXBlID0+IHtcclxuICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBuZXR3b3JrSW5mb1R5cGUoKTtcclxuICAgICAgICAgICAgaWYgKHRtcC5DaGFpbklkSGV4ID09IGNoYWluSWRIZXgpIHtcclxuICAgICAgICAgICAgICAgIG5ldHdvcmtJbmZvID0gdG1wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldHdvcmtJbmZvO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBpZD1cXFwic3dpdGNoTmV0d29ya0luZm9cXFwiPlxcclxcbiAgICBZb3UgY2FuIGNob29zZSBhbnkgb2YgdGhlc2UgbmV0d29ya3MuXFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8aDM+TWFpbm5ldCAtIHJlYWwgbW9uZXkgJiBzdG9ja3M8L2gzPlxcclxcbiAgICAgICAge3sjZWFjaCBtYWluTmV0d29ya3N9fVxcclxcbiAgICAgICAgPGJ1dHRvbiBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJzZXROZXR3b3JrXFxcIlxcclxcbiAgICAgICAgICAgICAgICBkYXRhLWNoYWluaWQ9XFxcInt7Q2hhaW5JZH19XFxcIj57e0NoYWluTmFtZX19XFxyXFxuICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxoMz5UZXN0bmV0IC0gZmFrZSBtb25leSAmIHN0b2NrczwvaDM+XFxyXFxuICAgICAgICB7eyNlYWNoIHRlc3ROZXR3b3Jrc319XFxyXFxuICAgICAgICA8YnV0dG9uIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcInNldE5ldHdvcmtcXFwiXFxyXFxuICAgICAgICAgICAgICAgIGRhdGEtY2hhaW5pZD1cXFwie3tDaGFpbklkfX1cXFwiPnt7Q2hhaW5OYW1lfX1cXHJcXG4gICAgICAgIDwvYnV0dG9uPlxcclxcbiAgICAgICAge3svZWFjaH19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjxkaXYgaWQ9XFxcImpzU3dpdGNoTmV0d29ya05vdFdvcmtpbmdcXFwiIGNsYXNzPVxcXCJkLW5vbmVcXFwiPlxcclxcbiAgICBJdCBzZWVtIGFzIHdlIGNhbid0IGFkZCB0aGUgbmV0d29yayBhdXRvbWF0aWNhbGx5IGZvciB5b3VyLCBzbyB5b3UgbmVlZCB0byBhZGQgaXQgeW91ciBzZWxmLlxcclxcbiAgICBUaGlzIGlzIHRoZSBpbmZvcm1hdGlvbiB5b3UgbmVlZCB0byBhZGQgdGhlIG5ldHdvcmsuIFlvdSB3aWxsIG5lZWQgdG8gZmlndXJlIG91dCB3aGVyZSB0b1xcclxcbiAgICBhZGQgbmV3IG5ldHdvcmsgZm9yIHlvdXIgd2FsbGV0LCBhcyBpdCBkaWZmZXJlbmNlIGJldHdlZW4gd2FsbGV0cy5cXHJcXG4gICAgPGZvcm0+XFxyXFxuICAgICAgICA8bGFiZWw+Q2hhaW5JZDpcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaENoYWluSWRcXFwiLz5cXHJcXG4gICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8bGFiZWw+Q2hhaW4gbmFtZVxcclxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwic3dpdGNoQ2hhaW5OYW1lXFxcIi8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGxhYmVsPkN1cnJlbmN5IG5hbWVcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaEN1cnJlbmN5TmFtZVxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBTeW1ib2xcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaFN5bWJvbFxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5EZWNpbWFsXFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJzd2l0Y2hEZWNpbWFsXFxcIi8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGxhYmVsPlJwYyBVcmxcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaFJwY1VybFxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgPC9mb3JtPlxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGlhbG9nIGlkPVxcXCJsaW1pbmFsX21hcmtldF9tb2RhbF9kaXZcXFwiIGRhdGEtdGl0bGU9XFxcInt7e3RpdGxlfX19XFxcIj5cXHJcXG4gICAgPGFydGljbGU+XFxyXFxuICAgICAgICA8aGVhZGVyPlxcclxcbiAgICAgICAgICAgIDxzcGFuPnt7dGl0bGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjY2xvc2VcXFwiIGFyaWEtbGFiZWw9XFxcIkNsb3NlXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGlkPVxcXCJsaW1pbmFsX21hcmtldF9tb2RhbF9jbG9zZVxcXCI+PC9hPlxcclxcbiAgICAgICAgPC9oZWFkZXI+XFxyXFxuICAgICAgICB7e3tjb250ZW50fX19XFxyXFxuICAgIDwvYXJ0aWNsZT5cXHJcXG5cXHJcXG48L2RpYWxvZz5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IE1vZGFsSHRtbCBmcm9tICcuLi8uLi9odG1sL21vZGFsL01vZGFsLmh0bWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWwge1xyXG4gICAgbW9kYWxJZCA9ICdsaW1pbmFsX21hcmtldF9tb2RhbF9kaXYnO1xyXG4gICAgb25IaWRlPyA6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIGhpZGVNb2RhbCgpIHtcclxuICAgICAgICBsZXQgbW9kYWxEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1vZGFsSWQpO1xyXG4gICAgICAgIG1vZGFsRGl2Py5yZW1vdmVBdHRyaWJ1dGUoJ29wZW4nKTtcclxuICAgICAgICBpZiAodGhpcy5vbkhpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3dNb2RhbCh0aXRsZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIHJldXNlTW9kYWxJZlNhbWVUaXRsZTogYm9vbGVhbiA9IGZhbHNlLCBvbkhpZGU/OiAoKSA9PiB2b2lkLCBoaWRlT25PdXRzaWRlQ2xpY2sgPSB0cnVlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IG1vZGFsRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tb2RhbElkKTtcclxuICAgICAgICBpZiAobW9kYWxEaXYpIHtcclxuICAgICAgICAgICAgbGV0IG1vZGFsVGl0bGUgPSBtb2RhbERpdi5kYXRhc2V0LnRpdGxlO1xyXG4gICAgICAgICAgICBpZiAocmV1c2VNb2RhbElmU2FtZVRpdGxlICYmIG1vZGFsVGl0bGUgJiYgbW9kYWxUaXRsZSA9PT0gdGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIG1vZGFsRGl2LnNldEF0dHJpYnV0ZSgnb3BlbicsICcnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKE1vZGFsSHRtbCk7XHJcblxyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCBjb250ZW50OiBjb250ZW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBodG1sID0gdGVtcGxhdGUob2JqKTtcclxuXHJcbiAgICAgICAgaWYgKG1vZGFsRGl2KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobW9kYWxEaXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaHRtbCk7XHJcblxyXG4gICAgICAgIG1vZGFsRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tb2RhbElkKSE7XHJcbiAgICAgICAgbW9kYWxEaXYuc2V0QXR0cmlidXRlKCdvcGVuJywgJycpO1xyXG5cclxuICAgICAgICBpZiAoaGlkZU9uT3V0c2lkZUNsaWNrKSB7XHJcbiAgICAgICAgICAgIG1vZGFsRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldnQudGFyZ2V0ICYmIChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5pZCA9PT0gJ2xpbWluYWxfbWFya2V0X21vZGFsX2RpdicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlJylcclxuICAgICAgICBpZiAobGltaW5hbF9tYXJrZXRfbW9kYWxfY2xvc2UpIGxpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfbW9kYWxfY2xvc2UnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5vbkhpZGUgPSBvbkhpZGU7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3VyaXR5IHtcclxuICAgIENsYXNzIDogc3RyaW5nID0gXCJcIjtcclxuICAgIEV4Y2hhbmdlIDogc3RyaW5nID0gXCJcIjtcclxuICAgIFN5bWJvbCA6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBOYW1lIDogc3RyaW5nID0gXCJcIjtcclxuICAgIFN0YXR1cyA6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBUcmFkYWJsZSA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEZyYWN0aW9uYWJsZSA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIExvZ28gOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgRmF2b3JpdGUgOiBudW1iZXIgPSAwO1xyXG4gICAgTG9nb1BhdGggOiBzdHJpbmcgPSBcIi9pbWcvbG9nb3MvXCIgO1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5Mb2dvUGF0aCA9IFwiL2ltZy9sb2dvcy9cIiA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBBcHAgZnJvbSBcIi4uLy4uL21haW5cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTZXJ2aWNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0KHBhdGg6IHN0cmluZywgZGF0YT86IGFueSwgb3B0aW9ucz86IGFueSk6IFByb21pc2U8YW55PiB7XHJcbiAgICAgICAgbGV0IHVybCA9ICcnO1xyXG4gICAgICAgIGxldCBtZXRob2QgPSAnR0VUJ1xyXG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5yZWxhdGl2ZVVybCkge1xyXG4gICAgICAgICAgICB1cmwgPSBBcHAuTmV0d29yay5TZXJ2ZXJVcmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGRhdGEpO1xyXG4gICAgICAgIGlmICghcGFyYW1zLmhhcygnY2hhaW5JZCcpKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoJ2NoYWluSWQnLCBBcHAuTmV0d29yay5DaGFpbklkLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmFtcy5oYXMoJ2FkZHJlc3MnKSkge1xyXG4gICAgICAgICAgICBwYXJhbXMuc2V0KCdhZGRyZXNzJywgQXBwLlVzZXIuYWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmdldFVybCh1cmwsIHBhdGgpICsgJz8nICsgcGFyYW1zLnRvU3RyaW5nKCksXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeydBdXRoZW50aWNhdGlvbic6ICdCZWFyZXI6ICcgKyBBcHAuVXNlci50b2tlbiwgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ31cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICBsZXQgb2JqID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiAob2JqLnJlc3VsdCkgPyBvYmoucmVzdWx0IDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBwb3N0PFQ+KHBhdGg6IHN0cmluZywgZGF0YT86IGFueSkge1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICBkYXRhID0ge31cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5jaGFpbklkID0gKGRhdGEuY2hhaW5JZCkgPyBkYXRhLmNoYWluSWQgOiBBcHAuTmV0d29yay5DaGFpbklkO1xyXG4gICAgICAgIGRhdGEuYWRkcmVzcyA9IChkYXRhLmFkZHJlc3MpID8gZGF0YS5hZGRyZXNzIDogQXBwLlVzZXIuYWRkcmVzcztcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdldFVybChBcHAuTmV0d29yay5TZXJ2ZXJVcmwsIHBhdGgpKTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5nZXRVcmwoQXBwLk5ldHdvcmsuU2VydmVyVXJsLCBwYXRoKSxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJ0F1dGhlbnRpY2F0aW9uJzogJ0JlYXJlcjogJyArIEFwcC5Vc2VyLnRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIGxldCBvYmogPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgaWYgKG9iai5zdWNjZXNzKSByZXR1cm4gb2JqLnJlc3VsdDtcclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG9iai5lcnJvcik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0VXJsKFNlcnZlclVybDogc3RyaW5nLCBwYXRoOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAocGF0aC5zdGFydHNXaXRoKCcvJykpIHJldHVybiBTZXJ2ZXJVcmwgKyBwYXRoO1xyXG4gICAgICAgIHJldHVybiBTZXJ2ZXJVcmwgKyAnLycgKyBwYXRoO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFNlY3VyaXR5IGZyb20gXCIuL1NlY3VyaXR5XCI7XHJcbmltcG9ydCBCYXNlU2VydmljZSBmcm9tIFwiLi4vYmFja2VuZC9CYXNlU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VjdXJpdGllc1NlcnZpY2UgZXh0ZW5kcyBCYXNlU2VydmljZSB7XHJcblxyXG4gICAgc2VjdXJpdGllcyA9IG5ldyBNYXA8c3RyaW5nLCBTZWN1cml0eT4oKTtcclxuICAgIHNlY3VyaXRpZXNBcnJheTogYW55O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFNlY3VyaXRpZXNTZXJ2aWNlO1xyXG4gICAgcGFnZTogbnVtYmVyO1xyXG4gICAgc3ltYm9scyA9IFtcIk1TRlRcIiwgXCJBQVBMXCIsIFwiQU1aTlwiLCBcIlRTTEFcIiwgXCJHT09HTFwiLCBcIkdPT0dcIiwgXCJHTUVcIiwgXCJNRVRBXCIsIFwiTlZEQVwiLCBcIkJSSy5CXCIsIFwiSlBNXCIsIFwiSERcIiwgXCJKTkpcIiwgXCJVTkhcIiwgXCJQR1wiLCBcIkJBQ1wiLCBcIlZcIiwgXCJBREJFXCIsIFwiTkZMWFwiLCBcIkNSTVwiLCBcIlBGRVwiLCBcIkRJU1wiLCBcIk1BXCIsIFwiWE9NXCIsIFwiVE1PXCIsIFwiQ09TVFwiXVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5zZWN1cml0aWVzID0gbmV3IE1hcDxzdHJpbmcsIFNlY3VyaXR5PigpO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBnZXRJbnN0YW5jZSgpOiBQcm9taXNlPFNlY3VyaXRpZXNTZXJ2aWNlPiB7XHJcbiAgICAgICAgaWYgKCFTZWN1cml0aWVzU2VydmljZS5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBTZWN1cml0aWVzU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTZWN1cml0aWVzU2VydmljZSgpO1xyXG4gICAgICAgICAgICBTZWN1cml0aWVzU2VydmljZS5pbnN0YW5jZS5zZWN1cml0aWVzID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuaW5zdGFuY2UuZ2V0U2VjdXJpdGllcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU2VjdXJpdGllc1NlcnZpY2UuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFNlY3VyaXRpZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdGllcy5zaXplICE9IDApIHJldHVybiB0aGlzLnNlY3VyaXRpZXM7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCAoYXdhaXQgZmV0Y2goJy9zZWN1cml0aWVzL3NlY3VyaXRpZXMuanNvbicpKS5qc29uKCk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNlY3VyaXRpZXMuc2V0KHJlc3VsdHNbaV0uU3ltYm9sLCBPYmplY3QuYXNzaWduKG5ldyBTZWN1cml0eSwgcmVzdWx0c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY3VyaXRpZXNBcnJheSA9IEFycmF5LmZyb20odGhpcy5zZWN1cml0aWVzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VjdXJpdGllcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2VjdXJpdHlCeVN5bWJvbChzeW1ib2wgOiBzdHJpbmcpIDogUHJvbWlzZTxTZWN1cml0eT4ge1xyXG4gICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgdGhpcy5nZXRTZWN1cml0aWVzKCk7XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0eSA9IHNlY3VyaXRpZXMuZ2V0KHN5bWJvbCk7XHJcbiAgICAgICAgcmV0dXJuIChzZWN1cml0eSkgPyBzZWN1cml0eSA6IG5ldyBTZWN1cml0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUb3BTZWN1cml0aWVzKCkge1xyXG4gICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgdGhpcy5nZXRTZWN1cml0aWVzKCk7XHJcbiAgICAgICAgbGV0IHRvcFNlY3VyaXRpZXMgPSBuZXcgQXJyYXk8U2VjdXJpdHk+KCk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICBsZXQgc2VjdXJpdHkgPSBzZWN1cml0aWVzLmdldChzeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoc2VjdXJpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRvcFNlY3VyaXRpZXMucHVzaChzZWN1cml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvcFNlY3VyaXRpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFBhZ2luYXRpbmdTZWN1cml0aWVzKHBhZ2UgOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAocGFnZSA9PSAwKSByZXR1cm4gdGhpcy5nZXRUb3BTZWN1cml0aWVzKCk7XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0aWVzT25QYWdlID0gbmV3IEFycmF5PFNlY3VyaXR5PigpO1xyXG4gICAgICAgIGxldCBpID0gcGFnZSAqIHRoaXMuc3ltYm9scy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHBhZ2VDb3VudCA9IGkgKyAxMDtcclxuICAgICAgICBmb3IgKDtpPHBhZ2VDb3VudCAmJiBpPHRoaXMuc2VjdXJpdGllc0FycmF5Lmxlbmd0aDtpKyspIHtcclxuICAgICAgICAgICAgc2VjdXJpdGllc09uUGFnZS5wdXNoKHRoaXMuc2VjdXJpdGllc0FycmF5W2ldWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlY3VyaXRpZXNPblBhZ2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBmaW5kKHNlYXJjaDogc3RyaW5nKSA6IFByb21pc2U8QXJyYXk8U2VjdXJpdHk+PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBuZXcgQXJyYXk8U2VjdXJpdHk+KCk7XHJcbiAgICAgICAgc2VhcmNoID0gc2VhcmNoLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VjdXJpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWN1cml0eSkge1xyXG4gICAgICAgICAgICBpZiAoc2VjdXJpdHkuU3ltYm9sLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpICE9IC0xIHx8XHJcbiAgICAgICAgICAgICAgICBzZWN1cml0eS5OYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc2VjdXJpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBMb2FkaW5nSGVscGVyIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGxhc3RFbGVtZW50PyA6IEhUTUxFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0TG9hZGluZyhlbGVtZW50PzogSFRNTEVsZW1lbnQgfCBudWxsKSB7XHJcbiAgICAgICAgaWYgKExvYWRpbmdIZWxwZXIubGFzdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5sYXN0RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5sYXN0RWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVMb2FkaW5nKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWJ1c3knKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFNlY3VyaXRpZXNTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9icm9rZXIvU2VjdXJpdGllc1NlcnZpY2VcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4vTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuLi9lcnJvcnMvR2VuZXJhbEVycm9yXCI7XHJcbmltcG9ydCBOZXR3b3JrIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgUHJvdmlkZXJJbmZvIGZyb20gXCIuLi93YWxsZXQvUHJvdmlkZXJJbmZvXCI7XHJcbmltcG9ydCB7V2FsbGV0VHlwZX0gZnJvbSBcIi4uL2VudW1zL1dhbGxldFR5cGVcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBBcHAgZnJvbSBcIi4uL21haW5cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGxldEhlbHBlciB7XHJcbiAgICBzdGF0aWMgYWRkVG9rZW5GYWxsYmFja0xvYWRlZD86IGJvb2xlYW4gPSB1bmRlZmluZWQ7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRBVXNkQXNzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgTG9nbzogJy4uL2F1c2QucG5nJ1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGFkZFRva2VuVG9XYWxsZXQoYWRkcmVzczogc3RyaW5nLCBzeW1ib2w6IHN0cmluZywgZmFsbGJhY2tUaW1lb3V0OiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXNTZXJ2aWNlID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgICAgICAgY29uc3QgYXNzZXQgPSAoc3ltYm9sID09ICdhVVNEJykgPyB0aGlzLmdldEFVc2RBc3NldCgpIDogYXdhaXQgc2VjdXJpdGllc1NlcnZpY2UuZ2V0U2VjdXJpdHlCeVN5bWJvbChzeW1ib2wpO1xyXG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjMoKTtcclxuICAgICAgICBpZiAoIWNvbm5lY3RvciB8fCAhY29ubmVjdG9yLnByb3ZpZGVyIHx8ICFjb25uZWN0b3IucHJvdmlkZXIucmVxdWVzdCkge1xyXG4gICAgICAgICAgICBmYWxsYmFja1RpbWVvdXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGltZW91dCA9IChXYWxsZXRIZWxwZXIuYWRkVG9rZW5GYWxsYmFja0xvYWRlZCA9PT0gdW5kZWZpbmVkKSA/IDIgKiAxMDAwIDogMjAwO1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoV2FsbGV0SGVscGVyLmFkZFRva2VuRmFsbGJhY2tMb2FkZWQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBXYWxsZXRIZWxwZXIuYWRkVG9rZW5GYWxsYmFja0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmFsbGJhY2tUaW1lb3V0KSBmYWxsYmFja1RpbWVvdXQoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LCB0aW1lb3V0KTtcclxuXHJcbiAgICAgICAgY29uc3Qgd2FzQWRkZWQgPSBhd2FpdCBjb25uZWN0b3IucHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF93YXRjaEFzc2V0JyxcclxuICAgICAgICAgICAgcGFyYW1zOiBbe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ0VSQzIwJyxcclxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAxOCxcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogJ2h0dHBzOi8vYXBwLmxpbWluYWwubWFya2V0L2ltZy9sb2dvcy8nICsgYXNzZXQuTG9nbyxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH1dXHJcbiAgICAgICAgfSkudGhlbigocmVzdWx0OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgV2FsbGV0SGVscGVyLmFkZFRva2VuRmFsbGJhY2tMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSkuY2F0Y2goKGVycm9yOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gd2FzQWRkZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgaXNXZWJ2aWV3KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIGxldCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICAgICAgLy8gaWYgaXQgc2F5cyBpdCdzIGEgd2VidmlldywgbGV0J3MgZ28gd2l0aCB0aGF0XHJcbiAgICAgICAgbGV0IHJ1bGVzID0gWydXZWJWaWV3JyxcclxuICAgICAgICAgICAgLy8gaU9TIHdlYnZpZXcgd2lsbCBiZSB0aGUgc2FtZSBhcyBzYWZhcmkgYnV0IG1pc3NpbmcgXCJTYWZhcmlcIlxyXG4gICAgICAgICAgICAnKGlQaG9uZXxpUG9kfGlQYWQpKD8hLipTYWZhcmkpJyxcclxuICAgICAgICAgICAgLy8gQW5kcm9pZCBMb2xsaXBvcCBhbmQgQWJvdmU6IHdlYnZpZXcgd2lsbCBiZSB0aGUgc2FtZSBhcyBuYXRpdmUgYnV0IGl0IHdpbGwgY29udGFpbiBcInd2XCJcclxuICAgICAgICAgICAgLy8gQW5kcm9pZCBLaXRLYXQgdG8gbG9sbGlwb3Agd2VidmlldyB3aWxsIHB1dCB7dmVyc2lvbn0uMC4wLjBcclxuICAgICAgICAgICAgJ0FuZHJvaWQuKih3dnwuMC4wLjApJyxcclxuICAgICAgICAgICAgLy8gb2xkIGNocm9tZSBhbmRyb2lkIHdlYnZpZXcgYWdlbnRcclxuICAgICAgICAgICAgJ0xpbnV4OyBVOyBBbmRyb2lkJyxcclxuICAgICAgICAgICAgJ1NESydcclxuICAgICAgICBdXHJcbiAgICAgICAgbGV0IHdlYnZpZXdSZWdFeHAgPSBuZXcgUmVnRXhwKCcoJyArIHJ1bGVzLmpvaW4oJ3wnKSArICcpJywgJ2lnJyk7XHJcbiAgICAgICAgcmV0dXJuICEhdWEubWF0Y2god2Vidmlld1JlZ0V4cClcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgaXNNYWdpYygpIHtcclxuICAgICAgICBjb25zdCB3YWxsZXRJbmZvID0gQXBwLlVzZXIucHJvdmlkZXJJbmZvXHJcbiAgICAgICAgY29uc3Qgd2FsbGV0VHlwZSA9IHdhbGxldEluZm8ud2FsbGV0VHlwZTtcclxuICAgICAgICByZXR1cm4gKHdhbGxldFR5cGUgPT09IFwibWFnaWNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHN3aXRjaE5ldHdvcmsobmV0d29yazogTmV0d29yayk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIE5ldHdvcmtJbmZvLnNldE5ldHdvcmtCeUNoYWluSWQobmV0d29yay5DaGFpbklkKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaGlkZU1hZ2ljV2FsbGV0KCkge1xyXG4gICAgICAgIGxldCBtYWdpY0lmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWdpYy1pZnJhbWUnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAobWFnaWNJZnJhbWUgJiYgbWFnaWNJZnJhbWUuc3R5bGUuZGlzcGxheSA9PSAnYmxvY2snKSBtYWdpY0lmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBHZW5lcmFsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb2RlIDogbnVtYmVyO1xyXG4gICAgbWVzc2FnZSA6IHN0cmluZztcclxuICAgIGhlYWRlcnMgOiBhbnk7XHJcbiAgICBlcnJvciA6IGFueTtcclxuICAgIHN0YWNrIDogc3RyaW5nO1xyXG4gICAgY2FsbGJhY2s/IDogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihlIDogYW55KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBcIlwiO1xyXG4gICAgICAgIGlmICghZS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGUudG9TdHJpbmcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUubWVzc2FnZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IGUubWVzc2FnZS5kYXRhLmNvZGU7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZS5kYXRhLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBlLm1lc3NhZ2UuaGVhZGVycztcclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoZS5kYXRhKSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBlLmRhdGEuY29kZTtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZS5kYXRhLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFN3aXRjaE5ldHdvcmtIdG1sIGZyb20gJy4uLy4uL2h0bWwvbW9kYWwvU3dpdGNoTmV0d29yay5odG1sJztcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4vTW9kYWxcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9XYWxsZXRIZWxwZXJcIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi4vLi4vZXJyb3JzL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgTmV0d29yayBmcm9tIFwiLi4vLi4vbmV0d29ya3MvTmV0d29ya1wiO1xyXG5pbXBvcnQge05ldHdvcmtUeXBlfSBmcm9tIFwiLi4vLi4vbmV0d29ya3MvTmV0d29ya1R5cGVcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2hOZXR3b3JrTW9kYWwge1xyXG4gICAgc2VsZWN0ZWROZXR3b3JrPzogTmV0d29yaztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU3dpdGNoTmV0d29ya0h0bWwpO1xyXG4gICAgICAgIGxldCB0ZXN0TmV0d29ya3MgPSBOZXR3b3JrSW5mby5nZXROZXR3b3JrcyhOZXR3b3JrVHlwZS5UZXN0bmV0KTtcclxuICAgICAgICBsZXQgbWFpbk5ldHdvcmtzID0gTmV0d29ya0luZm8uZ2V0TmV0d29ya3MoTmV0d29ya1R5cGUuTWFpbm5ldCk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZSh7dGVzdE5ldHdvcmtzLCBtYWluTmV0d29ya3N9KTtcclxuXHJcbiAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdTd2l0Y2ggbmV0d29yaycsIGNvbnRlbnQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgbGV0IHNldE5ldHdvcmtMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZXROZXR3b3JrJyk7XHJcbiAgICAgICAgc2V0TmV0d29ya0xpbmtzLmZvckVhY2goc2V0TmV0d29ya0xpbmsgPT4ge1xyXG4gICAgICAgICAgICBzZXROZXR3b3JrTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkYXRhc2V0ID0gKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmRhdGFzZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTmV0d29yayA9IE5ldHdvcmtJbmZvLmdldE5ldHdvcmtJbmZvQnlDaGFpbklkKHBhcnNlSW50KGRhdGFzZXQuY2hhaW5pZCEpKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZE5ldHdvcmspIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGNoYWluSWQ6JyArIGRhdGFzZXQuY2hhaW5pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzQWRkaW5nTmV0d29yayA9IGF3YWl0IHdhbGxldEhlbHBlci5zd2l0Y2hOZXR3b3JrKHRoaXMuc2VsZWN0ZWROZXR3b3JrKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEdlbmVyYWxFcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQganNTd2l0Y2hOZXR3b3JrTm90V29ya2luZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqc1N3aXRjaE5ldHdvcmtOb3RXb3JraW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghanNTd2l0Y2hOZXR3b3JrTm90V29ya2luZykgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc1N3aXRjaE5ldHdvcmtOb3RXb3JraW5nLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3dpdGNoTmV0d29ya0luZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoTmV0d29ya0luZm8nKSE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaE5ldHdvcmtJbmZvLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hDaGFpbklkJykgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSBkYXRhc2V0LmNoYWluaWQhICsgJyBvciBpdCBtaWdodCBiZTogJyArICcweCcgKyBwYXJzZUludChkYXRhc2V0LmNoYWluaWQhKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoQ2hhaW5OYW1lJykhIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gdGhpcy5zZWxlY3RlZE5ldHdvcmshLk5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoQ3VycmVuY3lOYW1lJykhIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gdGhpcy5zZWxlY3RlZE5ldHdvcmshLk5hdGl2ZUN1cnJlbmN5TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hTeW1ib2wnKSEgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSB0aGlzLnNlbGVjdGVkTmV0d29yayEuTmF0aXZlU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N3aXRjaERlY2ltYWwnKSAhIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gdGhpcy5zZWxlY3RlZE5ldHdvcmshLk5hdGl2ZURlY2ltYWwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hScGNVcmwnKSEgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSB0aGlzLnNlbGVjdGVkTmV0d29yayEuUnBjVXJsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0FkZGluZ05ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RhbC5oaWRlTW9kYWwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF1dGhlbnRpY2F0aW9uU2VydmljZSA9IG5ldyBBdXRoZW50aWNhdGVTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYXV0aGVudGljYXRpb25TZXJ2aWNlLmxvZ091dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59IiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImxvZ2dlci81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5sZXQgX3Blcm1hbmVudENlbnNvckVycm9ycyA9IGZhbHNlO1xubGV0IF9jZW5zb3JFcnJvcnMgPSBmYWxzZTtcbmNvbnN0IExvZ0xldmVscyA9IHsgZGVidWc6IDEsIFwiZGVmYXVsdFwiOiAyLCBpbmZvOiAyLCB3YXJuaW5nOiAzLCBlcnJvcjogNCwgb2ZmOiA1IH07XG5sZXQgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xubGV0IF9nbG9iYWxMb2dnZXIgPSBudWxsO1xuZnVuY3Rpb24gX2NoZWNrTm9ybWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBbXTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCBmb3JtcyBvZiBub3JtYWxpemF0aW9uIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaCgoZm9ybSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0ZXN0XCIubm9ybWFsaXplKGZvcm0pICE9PSBcInRlc3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nLnB1c2goZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWlzc2luZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgXCIgKyBtaXNzaW5nLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZy5mcm9tQ2hhckNvZGUoMHhlOSkubm9ybWFsaXplKFwiTkZEXCIpICE9PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4NjUsIDB4MDMwMSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgX25vcm1hbGl6ZUVycm9yID0gX2NoZWNrTm9ybWFsaXplKCk7XG5leHBvcnQgdmFyIExvZ0xldmVsO1xuKGZ1bmN0aW9uIChMb2dMZXZlbCkge1xuICAgIExvZ0xldmVsW1wiREVCVUdcIl0gPSBcIkRFQlVHXCI7XG4gICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG4gICAgTG9nTGV2ZWxbXCJXQVJOSU5HXCJdID0gXCJXQVJOSU5HXCI7XG4gICAgTG9nTGV2ZWxbXCJFUlJPUlwiXSA9IFwiRVJST1JcIjtcbiAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xuZXhwb3J0IHZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEVycm9yQ29kZSkge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBHZW5lcmljIEVycm9yc1xuICAgIC8vIFVua25vd24gRXJyb3JcbiAgICBFcnJvckNvZGVbXCJVTktOT1dOX0VSUk9SXCJdID0gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgLy8gTm90IEltcGxlbWVudGVkXG4gICAgRXJyb3JDb2RlW1wiTk9UX0lNUExFTUVOVEVEXCJdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvLyBVbnN1cHBvcnRlZCBPcGVyYXRpb25cbiAgICAvLyAgIC0gb3BlcmF0aW9uXG4gICAgRXJyb3JDb2RlW1wiVU5TVVBQT1JURURfT1BFUkFUSU9OXCJdID0gXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIjtcbiAgICAvLyBOZXR3b3JrIEVycm9yIChpLmUuIEV0aGVyZXVtIE5ldHdvcmssIHN1Y2ggYXMgYW4gaW52YWxpZCBjaGFpbiBJRClcbiAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcbiAgICBFcnJvckNvZGVbXCJORVRXT1JLX0VSUk9SXCJdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgLy8gU29tZSBzb3J0IG9mIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuICAgIC8vIFRpbWVvdXRcbiAgICBFcnJvckNvZGVbXCJUSU1FT1VUXCJdID0gXCJUSU1FT1VUXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIE9wZXJhdGlvbmFsICBFcnJvcnNcbiAgICAvLyBCdWZmZXIgT3ZlcnJ1blxuICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuICAgIC8vIE51bWVyaWMgRmF1bHRcbiAgICAvLyAgIC0gb3BlcmF0aW9uOiB0aGUgb3BlcmF0aW9uIGJlaW5nIGV4ZWN1dGVkXG4gICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuICAgIEVycm9yQ29kZVtcIk5VTUVSSUNfRkFVTFRcIl0gPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gQXJndW1lbnQgRXJyb3JzXG4gICAgLy8gTWlzc2luZyBuZXcgb3BlcmF0b3IgdG8gYW4gb2JqZWN0XG4gICAgLy8gIC0gbmFtZTogVGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG4gICAgLy8gSW52YWxpZCBhcmd1bWVudCAoZS5nLiB2YWx1ZSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0eXBlKSB0byBhIGZ1bmN0aW9uOlxuICAgIC8vICAgLSBhcmd1bWVudDogVGhlIGFyZ3VtZW50IG5hbWUgdGhhdCB3YXMgaW52YWxpZFxuICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICAgIEVycm9yQ29kZVtcIklOVkFMSURfQVJHVU1FTlRcIl0gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICAvLyBNaXNzaW5nIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuICAgIEVycm9yQ29kZVtcIk1JU1NJTkdfQVJHVU1FTlRcIl0gPSBcIk1JU1NJTkdfQVJHVU1FTlRcIjtcbiAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBCbG9ja2NoYWluIEVycm9yc1xuICAgIC8vIENhbGwgZXhjZXB0aW9uXG4gICAgLy8gIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvblxuICAgIC8vICAtIGFkZHJlc3M/OiB0aGUgY29udHJhY3QgYWRkcmVzc1xuICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuICAgIC8vICAtIG1ldGhvZD86IFRoZSBTb2xpZGl0eSBtZXRob2Qgc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JTaWduYXR1cmU/OiBUaGUgRUlQODQ4IGVycm9yIHNpZ25hdHVyZVxuICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuICAgIC8vICAtIHJlYXNvbjogVGhlIHJlYXNvbiAob25seSBmb3IgRUlQODQ4IFwiRXJyb3Ioc3RyaW5nKVwiKVxuICAgIEVycm9yQ29kZVtcIkNBTExfRVhDRVBUSU9OXCJdID0gXCJDQUxMX0VYQ0VQVElPTlwiO1xuICAgIC8vIEluc3VmZmljaWVudCBmdW5kcyAoPCB2YWx1ZSArIGdhc0xpbWl0ICogZ2FzUHJpY2UpXG4gICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG4gICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcbiAgICAvLyBOb25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG4gICAgLy8gVGhlIHJlcGxhY2VtZW50IGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uIGlzIHRvbyBsb3dcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcbiAgICAvLyBUaGUgZ2FzIGxpbWl0IGNvdWxkIG5vdCBiZSBlc3RpbWF0ZWRcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBwYXNzZWQgdG8gZXN0aW1hdGVHYXNcbiAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcbiAgICAvLyBUaGUgdHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkIGJ5IG9uZSB3aXRoIGEgaGlnaGVyIGdhcyBwcmljZVxuICAgIC8vICAgLSByZWFzb246IFwiY2FuY2VsbGVkXCIsIFwicmVwbGFjZWRcIiBvciBcInJlcHJpY2VkXCJcbiAgICAvLyAgIC0gY2FuY2VsbGVkOiB0cnVlIGlmIHJlYXNvbiA9PSBcImNhbmNlbGxlZFwiIG9yIHJlYXNvbiA9PSBcInJlcGxhY2VkXCIpXG4gICAgLy8gICAtIGhhc2g6IG9yaWdpbmFsIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAvLyAgIC0gcmVwbGFjZW1lbnQ6IHRoZSBmdWxsIFRyYW5zYWN0aW9uc1Jlc3BvbnNlIGZvciB0aGUgcmVwbGFjZW1lbnRcbiAgICAvLyAgIC0gcmVjZWlwdDogdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgRXJyb3JDb2RlW1wiVFJBTlNBQ1RJT05fUkVQTEFDRURcIl0gPSBcIlRSQU5TQUNUSU9OX1JFUExBQ0VEXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEludGVyYWN0aW9uIEVycm9yc1xuICAgIC8vIFRoZSB1c2VyIHJlamVjdGVkIHRoZSBhY3Rpb24sIHN1Y2ggYXMgc2lnbmluZyBhIG1lc3NhZ2Ugb3Igc2VuZGluZ1xuICAgIC8vIGEgdHJhbnNhY3Rpb25cbiAgICBFcnJvckNvZGVbXCJBQ1RJT05fUkVKRUNURURcIl0gPSBcIkFDVElPTl9SRUpFQ1RFRFwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xuO1xuY29uc3QgSEVYID0gXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbG9nKGxvZ0xldmVsLCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKExvZ0xldmVsc1tsZXZlbF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxvZyBsZXZlbCBuYW1lXCIsIFwibG9nTGV2ZWxcIiwgbG9nTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbG9nTGV2ZWwgPiBMb2dMZXZlbHNbbGV2ZWxdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuREVCVUcsIGFyZ3MpO1xuICAgIH1cbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuSU5GTywgYXJncyk7XG4gICAgfVxuICAgIHdhcm4oLi4uYXJncykge1xuICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5XQVJOSU5HLCBhcmdzKTtcbiAgICB9XG4gICAgbWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICAvLyBFcnJvcnMgYXJlIGJlaW5nIGNlbnNvcmVkXG4gICAgICAgIGlmIChfY2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGV0YWlscyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGV4ICs9IEhFWFt2YWx1ZVtpXSA+PiA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gJiAweDBmXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVVpbnQ4QXJyYXkoMHhcIiArIGhleCArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGBjb2RlPSR7Y29kZX1gKTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgdmVyc2lvbj0ke3RoaXMudmVyc2lvbn1gKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgbGV0IHVybCA9IFwiXCI7XG4gICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTlVNRVJJQ19GQVVMVDoge1xuICAgICAgICAgICAgICAgIHVybCA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdmVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5kZXJmbG93XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXZpc2lvbi1ieS16ZXJvXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItXCIgKyBmYXVsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibmVnYXRpdmUtcG93ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXdpZHRoXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCItdW5zdXBwb3J0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuYm91bmQtcmVzdWx0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5DQUxMX0VYQ0VQVElPTjpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLklOU1VGRklDSUVOVF9GVU5EUzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk1JU1NJTkdfTkVXOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuTk9OQ0VfRVhQSVJFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVFJBTlNBQ1RJT05fUkVQTEFDRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVDpcbiAgICAgICAgICAgICAgICB1cmwgPSBjb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgWyBTZWU6IGh0dHBzOi9cXC9saW5rcy5ldGhlcnMub3JnL3Y1LWVycm9ycy1cIiArIHVybCArIFwiIF1cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZURldGFpbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIChcIiArIG1lc3NhZ2VEZXRhaWxzLmpvaW4oXCIsIFwiKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBBbnk/P1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgZXJyb3IucmVhc29uID0gcmVhc29uO1xuICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGVycm9yW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5tYWtlRXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgdGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICBhcmd1bWVudDogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3NlcnRBcmd1bWVudChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgY2hlY2tOb3JtYWxpemUobWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9ub3JtYWxpemVFcnJvcikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMHgxZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwib3V0LW9mLXNhZmUtcmFuZ2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0FyZ3VtZW50Q291bnQoY291bnQsIGV4cGVjdGVkQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBhcmd1bWVudFwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50c1wiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrTmV3KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQWJzdHJhY3QodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IGtpbmQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcImNhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyBcIiArIEpTT04uc3RyaW5naWZ5KGtpbmQubmFtZSkgKyBcIiBkaXJlY3RseTsgdXNlIGEgc3ViLWNsYXNzXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG5hbWU6IHRhcmdldC5uYW1lLCBvcGVyYXRpb246IFwibmV3XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFyZ2V0ID09PSBPYmplY3QgfHwgdGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnbG9iYWxMb2dnZXIoKSB7XG4gICAgICAgIGlmICghX2dsb2JhbExvZ2dlcikge1xuICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9nbG9iYWxMb2dnZXI7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRDZW5zb3JzaGlwKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuICAgICAgICBpZiAoIWNlbnNvcnNoaXAgJiYgcGVybWFuZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJjYW5ub3QgcGVybWFuZW50bHkgZGlzYWJsZSBjZW5zb3JzaGlwXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcbiAgICAgICAgICAgIGlmICghY2Vuc29yc2hpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImVycm9yIGNlbnNvcnNoaXAgcGVybWFuZW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgX2NlbnNvckVycm9ycyA9ICEhY2Vuc29yc2hpcDtcbiAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0TG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBMb2dMZXZlbHNbbG9nTGV2ZWwudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmIChsZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2dnZXIodmVyc2lvbik7XG4gICAgfVxufVxuTG9nZ2VyLmVycm9ycyA9IEVycm9yQ29kZTtcbkxvZ2dlci5sZXZlbHMgPSBMb2dMZXZlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIH0pO1xufVxuLy8gQ3Jhd2wgdXAgdGhlIGNvbnN0cnVjdG9yIGNoYWluIHRvIGZpbmQgYSBzdGF0aWMgbWV0aG9kXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGljKGN0b3IsIGtleSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICBpZiAoY3RvcltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gY3RvcltrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3Rvci5wcm90b3R5cGUgfHwgdHlwZW9mIChjdG9yLnByb3RvdHlwZSkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUHJvcGVydGllcyhvYmplY3QpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKCh2KSA9PiAoeyBrZXk6IGtleSwgdmFsdWU6IHYgfSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChhY2N1bSwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVsocmVzdWx0LmtleSldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCB7fSk7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKG9iamVjdCwgcHJvcGVydGllcykge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiAob2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdCBrZXkgLSBcIiArIGtleSwgXCJ0cmFuc2FjdGlvbjpcIiArIGtleSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDb3B5KG9iamVjdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qgb3BhcXVlID0geyBiaWdpbnQ6IHRydWUsIGJvb2xlYW46IHRydWUsIFwiZnVuY3Rpb25cIjogdHJ1ZSwgbnVtYmVyOiB0cnVlLCBzdHJpbmc6IHRydWUgfTtcbmZ1bmN0aW9uIF9pc0Zyb3plbihvYmplY3QpIHtcbiAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG4gICAgaWYgKG9iamVjdCA9PT0gdW5kZWZpbmVkIHx8IG9iamVjdCA9PT0gbnVsbCB8fCBvcGFxdWVbdHlwZW9mIChvYmplY3QpXSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSB8fCB0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleXNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWNjZXNzaW5nIGEgdmFsdWUgdHJpZ2dlcnMgYW4gZXJyb3IsIGl0IGlzIGEgZ2V0dGVyXG4gICAgICAgICAgICAgICAgLy8gZGVzaWduZWQgdG8gZG8gc28gKGUuZy4gUmVzdWx0KSBhbmQgaXMgdGhlcmVmb3JlIFwiZnJvemVuXCJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX2lzRnJvemVuKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuLy8gUmV0dXJucyBhIG5ldyBjb3B5IG9mIG9iamVjdCwgc3VjaCB0aGF0IG5vIHByb3BlcnRpZXMgbWF5IGJlIHJlcGxhY2VkLlxuLy8gTmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIG9ubHkgdG8gb2JqZWN0cy5cbmZ1bmN0aW9uIF9kZWVwQ29weShvYmplY3QpIHtcbiAgICBpZiAoX2lzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgLy8gQXJyYXlzIGFyZSBtdXRhYmxlLCBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBhIGNvcHlcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKG9iamVjdC5tYXAoKGl0ZW0pID0+IGRlZXBDb3B5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShyZXN1bHQsIGtleSwgZGVlcENvcHkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9kZWVwQ29weShvYmplY3QpO1xufVxuZXhwb3J0IGNsYXNzIERlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZm8pIHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IGRlZXBDb3B5KGluZm9ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicHJvdmlkZXJzLzUuNy4yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3Qtc2lnbmVyLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIHJlc29sdmVQcm9wZXJ0aWVzLCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0gW1xuICAgIFwiYWNjZXNzTGlzdFwiLCBcImNjaXBSZWFkRW5hYmxlZFwiLCBcImNoYWluSWRcIiwgXCJjdXN0b21EYXRhXCIsIFwiZGF0YVwiLCBcImZyb21cIiwgXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInRvXCIsIFwidHlwZVwiLCBcInZhbHVlXCJcbl07XG5jb25zdCBmb3J3YXJkRXJyb3JzID0gW1xuICAgIExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLFxuICAgIExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCxcbiAgICBMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELFxuXTtcbjtcbjtcbmV4cG9ydCBjbGFzcyBTaWduZXIge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdWItY2xhc3NlcyBNVVNUIGNhbGwgc3VwZXJcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCwgU2lnbmVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNTaWduZXJcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdWItY2xhc3NlcyBNQVkgb3ZlcnJpZGUgdGhlc2VcbiAgICBnZXRCYWxhbmNlKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0QmFsYW5jZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2UodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uQ291bnQoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25Db3VudCh0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIFwiZnJvbVwiIGlmIHVuc3BlY2lmaWVkLCBhbmQgZXN0aW1hdGVzIHRoZSBnYXMgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZXN0aW1hdGVHYXNcIik7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXModHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIFwiZnJvbVwiIGlmIHVuc3BlY2lmaWVkLCBhbmQgY2FsbHMgd2l0aCB0aGUgdHJhbnNhY3Rpb25cbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImNhbGxcIik7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIGFsbCBmaWVsZHMgaW4gYSB0cmFuc2FjdGlvbiwgc2lnbnMgaXQgYW5kIHNlbmRzIGl0IHRvIHRoZSBuZXR3b3JrXG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwic2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0eCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRDaGFpbklkXCIpO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldHdvcmsuY2hhaW5JZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEdhc1ByaWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEdhc1ByaWNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0R2FzUHJpY2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEZlZURhdGEoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0RmVlRGF0YVwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEZlZURhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJyZXNvbHZlTmFtZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQ2hlY2tzIGEgdHJhbnNhY3Rpb24gZG9lcyBub3QgY29udGFpbiBpbnZhbGlkIGtleXMgYW5kIGlmXG4gICAgLy8gbm8gXCJmcm9tXCIgaXMgcHJvdmlkZWQsIHBvcHVsYXRlcyBpdC5cbiAgICAvLyAtIGRvZXMgTk9UIHJlcXVpcmUgYSBwcm92aWRlclxuICAgIC8vIC0gYWRkcyBcImZyb21cIiBpcyBub3QgcHJlc2VudFxuICAgIC8vIC0gcmV0dXJucyBhIENPUFkgKHNhZmUgdG8gbXV0YXRlIHRoZSByZXN1bHQpXG4gICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG4gICAgLy8gICAtIGNhbGxcbiAgICAvLyAgIC0gZXN0aW1hdGVHYXNcbiAgICAvLyAgIC0gcG9wdWxhdGVUcmFuc2FjdGlvbiAoYW5kIHRoZXJlZm9yIHNlbmRUcmFuc2FjdGlvbilcbiAgICBjaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHJhbnNhY3Rpb24ga2V5OiBcIiArIGtleSwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBzaGFsbG93Q29weSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGlmICh0eC5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBhbnkgcHJvdmlkZWQgYWRkcmVzcyBtYXRjaGVzIHRoaXMgc2lnbmVyXG4gICAgICAgICAgICB0eC5mcm9tID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5mcm9tKSxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgXSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFswXS50b0xvd2VyQ2FzZSgpICE9PSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgQUxMIGtleXMgZm9yIGEgdHJhbnNhY3Rpb24gYW5kIGNoZWNrcyB0aGF0IFwiZnJvbVwiIG1hdGNoZXNcbiAgICAvLyB0aGlzIFNpZ25lci4gU2hvdWxkIGJlIHVzZWQgYnkgc2VuZFRyYW5zYWN0aW9uIGJ1dCBOT1QgYnkgc2lnblRyYW5zYWN0aW9uLlxuICAgIC8vIEJ5IGRlZmF1bHQgY2FsbGVkIGZyb206IChvdmVycmlkaW5nIHRoZXNlIHByZXZlbnRzIGl0KVxuICAgIC8vICAgLSBzZW5kVHJhbnNhY3Rpb25cbiAgICAvL1xuICAgIC8vIE5vdGVzOlxuICAgIC8vICAtIFdlIGFsbG93IGdhc1ByaWNlIGZvciBFSVAtMTU1OSBhcyBsb25nIGFzIGl0IG1hdGNoZXMgbWF4RmVlUGVyR2FzXG4gICAgcG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIGlmICh0eC50byAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHgudG8gPSBQcm9taXNlLnJlc29sdmUodHgudG8pLnRoZW4oKHRvKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZSh0byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHRoaXMgZXJyb3IgZnJvbSBjYXVzaW5nIGFuIFVuaGFuZGxlZFByb21pc2VFeGNlcHRpb25cbiAgICAgICAgICAgICAgICB0eC50by5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgbWl4aW5nIHByZS1laXAtMTU1OSBhbmQgZWlwLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgY29uc3QgaGFzRWlwMTU1OSA9ICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCB8fCB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKTtcbiAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSAhPSBudWxsICYmICh0eC50eXBlID09PSAyIHx8IGhhc0VpcDE1NTkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IGdhc1ByaWNlXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHR4LnR5cGUgPT09IDAgfHwgdHgudHlwZSA9PT0gMSkgJiYgaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcmUtZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgbWF4RmVlUGVyR2FzL21heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0eC50eXBlID09PSAyIHx8IHR4LnR5cGUgPT0gbnVsbCkgJiYgKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgLy8gRnVsbHktZm9ybWVkIEVJUC0xNTU5IHRyYW5zYWN0aW9uIChza2lwIGdldEZlZURhdGEpXG4gICAgICAgICAgICAgICAgdHgudHlwZSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eC50eXBlID09PSAwIHx8IHR4LnR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdCBMZWdhY3kgb3IgRUlQLTI5MzAgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGdhc1ByaWNlXG4gICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSB0aGlzLmdldEdhc1ByaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBnZXQgZmVlIGRhdGEgdG8gZGV0ZXJtaW5lIHRoaW5nc1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB5aWVsZCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICBpZiAodHgudHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYXV0by1kZXRlY3QgdGhlIGludGVuZGVkIHR5cGUgb2YgdGhpcyB0cmFuc2FjdGlvbi4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVlRGF0YS5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXR3b3JrIHN1cHBvcnRzIEVJUC0xNTU5IVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBncmFkZSB0cmFuc2FjdGlvbiBmcm9tIG51bGwgdG8gZWlwLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2luZyBsZWdhY3kgZ2FzUHJpY2UgcHJvcGVydHkgb24gYW4gZWlwLTE1NTkgbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB1c2UgZ2FzUHJpY2UgYXMgYm90aCBmZWUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlID0gdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZlZURhdGEuZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IHN1cHBvcnQgRUlQLTE1NTkuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCB0aGV5IGFyZSB0cnlpbmcgdG8gdXNlIEVJUC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRUlQLTE1NTlcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IGZlZURhdGEuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHNldCB1bnR5cGVkIHRyYW5zYWN0aW9uIHRvIGxlZ2FjeVxuICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRGZWVEYXRhIGhhcyBmYWlsZWQgdXMuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImZhaWxlZCB0byBnZXQgY29uc2lzdGVudCBmZWUgZGF0YVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzaWduZXIuZ2V0RmVlRGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC50eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdXNpbmcgRUlQLTE1NTlcbiAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IGZlZURhdGEubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHgubm9uY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4Lm5vbmNlID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50KFwicGVuZGluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eC5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSB0aGlzLmVzdGltYXRlR2FzKHR4KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcndhcmRFcnJvcnMuaW5kZXhPZihlcnJvci5jb2RlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4OiB0eFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eC5jaGFpbklkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5jaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5jaGFpbklkID0gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguY2hhaW5JZCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2hhaW5JZCgpXG4gICAgICAgICAgICAgICAgXSkudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0c1sxXSAhPT0gMCAmJiByZXN1bHRzWzBdICE9PSByZXN1bHRzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2hhaW5JZCBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzWzBdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBTdWItY2xhc3NlcyBTSE9VTEQgbGVhdmUgdGhlc2UgYWxvbmVcbiAgICBfY2hlY2tQcm92aWRlcihvcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IChvcGVyYXRpb24gfHwgXCJfY2hlY2tQcm92aWRlclwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGlzU2lnbmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNTaWduZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBWb2lkU2lnbmVyIGV4dGVuZHMgU2lnbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm92aWRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIgfHwgbnVsbCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKTtcbiAgICB9XG4gICAgX2ZhaWwobWVzc2FnZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogb3BlcmF0aW9uIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gbWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIF9zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0eXBlZCBkYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJ5dGVzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG59XG5mdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuICAgIGlmIChhcnJheS5zbGljZSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSwgYXJncykpKTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKGlzSGV4U3RyaW5nKHZhbHVlKSAmJiAhKHZhbHVlLmxlbmd0aCAlIDIpKSB8fCBpc0J5dGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgfHwgdmFsdWUubGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoIWlzSW50ZWdlcih2KSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlIC8gMjU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsZXQgaGV4ID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggKz0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGl0ZW1zKSB7XG4gICAgY29uc3Qgb2JqZWN0cyA9IGl0ZW1zLm1hcChpdGVtID0+IGFycmF5aWZ5KGl0ZW0pKTtcbiAgICBjb25zdCBsZW5ndGggPSBvYmplY3RzLnJlZHVjZSgoYWNjdW0sIGl0ZW0pID0+IChhY2N1bSArIGl0ZW0ubGVuZ3RoKSwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBvYmplY3RzLnJlZHVjZSgob2Zmc2V0LCBvYmplY3QpID0+IHtcbiAgICAgICAgcmVzdWx0LnNldChvYmplY3QsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuICAgIH0sIDApO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGVudHJ5XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzdGFydF0gPT09IDApIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIHplcm9zLCBzdHJpcCB0aGVtXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO1xuICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgICAgICBoZXggPSBIZXhDaGFyYWN0ZXJzW3ZhbHVlICYgMHhmXSArIGhleDtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCIweFwiICsgaGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcmV0dXJuIChcIjB4MFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLypcbmZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICUgMiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLCBvZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4RGF0YVwiLCBcInZhbHVlXCIsIGRhdGEpO1xuICAgIH1cbiAgICBvZmZzZXQgPSAyICsgMiAqIG9mZnNldDtcbiAgICBpZiAoZW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCwgMiArIDIgKiBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhDb25jYXQoaXRlbXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgcmVzdWx0ICs9IGhleGxpZnkoaXRlbSkuc3Vic3RyaW5nKDIpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB0cmltbWVkID0gaGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLCB7IGhleFBhZDogXCJsZWZ0XCIgfSkpO1xuICAgIGlmICh0cmltbWVkID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmltbWVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZVtvZmZzZXRdID09PSBcIjBcIikge1xuICAgICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICogbGVuZ3RoICsgMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IDIgKiBsZW5ndGggKyAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgcjogXCIweFwiLFxuICAgICAgICBzOiBcIjB4XCIsXG4gICAgICAgIF92czogXCIweFwiLFxuICAgICAgICByZWNvdmVyeVBhcmFtOiAwLFxuICAgICAgICB2OiAwLFxuICAgICAgICB5UGFyaXR5QW5kUzogXCIweFwiLFxuICAgICAgICBjb21wYWN0OiBcIjB4XCJcbiAgICB9O1xuICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG4gICAgICAgIC8vIEdldCB0aGUgciwgcyBhbmQgdlxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgLy8gRUlQLTIwOTg7IHB1bGwgdGhlIHYgZnJvbSB0aGUgdG9wIGJpdCBvZiBzIGFuZCBjbGVhciBpdFxuICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIChieXRlc1szMl0gPj4gNyk7XG4gICAgICAgICAgICBieXRlc1szMl0gJj0gMHg3ZjtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgYSByZWNpZCB0byBiZSB1c2VkIGFzIHRoZSB2XG4gICAgICAgIGlmIChyZXN1bHQudiA8IDI3KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiArPSAyNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCB2IGJ5dGVcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHJlY292ZXJ5UGFyYW0gZnJvbSB2XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAvLyBDb21wdXRlIF92cyBmcm9tIHJlY292ZXJ5UGFyYW0gYW5kIHNcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICBieXRlc1szMl0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5yID0gc2lnbmF0dXJlLnI7XG4gICAgICAgIHJlc3VsdC5zID0gc2lnbmF0dXJlLnM7XG4gICAgICAgIHJlc3VsdC52ID0gc2lnbmF0dXJlLnY7XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG4gICAgICAgIHJlc3VsdC5fdnMgPSBzaWduYXR1cmUuX3ZzO1xuICAgICAgICAvLyBJZiB0aGUgX3ZzIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIHBvcHVsYXRlIG1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuICAgICAgICAvLyBhbmQgdmVyaWZ5IG5vbi1taXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgaWYgKHJlc3VsdC5fdnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB6ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLCAzMik7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHJlY2lkXG4gICAgICAgICAgICBjb25zdCByZWNvdmVyeVBhcmFtID0gKCh2c1swXSA+PSAxMjgpID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgc1xuICAgICAgICAgICAgdnNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBoZXhsaWZ5KHZzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZXN1bHQudjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNJZCA9IChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkgPyByZXN1bHQudiA6ICgxIC0gKHJlc3VsdC52ICUgMikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIHZcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5yKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnIgPSBoZXhaZXJvUGFkKHJlc3VsdC5yLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5zKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5zLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdnMgPSBhcnJheWlmeShyZXN1bHQucyk7XG4gICAgICAgIGlmICh2c1swXSA+PSAxMjgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgIHZzWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgIGlmIChyZXN1bHQuX3ZzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgX3ZzXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnlQYXJpdHlBbmRTID0gcmVzdWx0Ll92cztcbiAgICByZXN1bHQuY29tcGFjdCA9IHJlc3VsdC5yICsgcmVzdWx0LnlQYXJpdHlBbmRTLnN1YnN0cmluZygyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUucixcbiAgICAgICAgc2lnbmF0dXJlLnMsXG4gICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG4gICAgXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJpZ251bWJlci81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBCaWdOdW1iZXJcbiAqXG4gKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcbiAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlc3MuXG4gKlxuICovXG5pbXBvcnQgX0JOIGZyb20gXCJibi5qc1wiO1xudmFyIEJOID0gX0JOLkJOO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5leHBvcnQgZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgaXNIZXhTdHJpbmcodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcbiAgICAgICAgaXNCeXRlcyh2YWx1ZSkpO1xufVxuLy8gT25seSB3YXJuIGFib3V0IHBhc3NpbmcgMTAgaW50byByYWRpeCBvbmNlXG5sZXQgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSBmYWxzZTtcbmV4cG9ydCBjbGFzcyBCaWdOdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGNhbGwgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBCaWdOdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgKEJpZ051bWJlcilcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGZyb21Ud29zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmZyb21Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIHRvVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS50b1R3b3ModmFsdWUpKTtcbiAgICB9XG4gICAgYWJzKCkge1xuICAgICAgICBpZiAodGhpcy5faGV4WzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYWRkKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIHN1YihvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zdWIodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgZGl2KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IG8gPSBCaWdOdW1iZXIuZnJvbShvdGhlcik7XG4gICAgICAgIGlmIChvLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcImRpdlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5kaXYodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbXVsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm11bCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBtb2Qob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJkaXZpc2lvbi1ieS16ZXJvXCIsIFwibW9kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnVtb2QodmFsdWUpKTtcbiAgICB9XG4gICAgcG93KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtcG93ZXJcIiwgXCJwb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykucG93KHZhbHVlKSk7XG4gICAgfVxuICAgIGFuZChvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJhbmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuYW5kKHZhbHVlKSk7XG4gICAgfVxuICAgIG9yKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5ib3VuZC1iaXR3aXNlLXJlc3VsdFwiLCBcIm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJ4b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG4gICAgfVxuICAgIG1hc2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwibWFza1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tYXNrbih2YWx1ZSkpO1xuICAgIH1cbiAgICBzaGwodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXdpZHRoXCIsIFwic2hsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcbiAgICB9XG4gICAgc2hyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNoclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaHJuKHZhbHVlKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmVxKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHQodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBsdGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykubHRlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3Qob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3QodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZ3RlKHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgaXNOZWdhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9oZXhbMF0gPT09IFwiLVwiKTtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5pc1plcm8oKTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwidG9OdW1iZXJcIiwgdGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9CaWdJbnQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJ0aGlzIHBsYXRmb3JtIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgLy8gTG90cyBvZiBwZW9wbGUgZXhwZWN0IHRoaXMsIHdoaWNoIHdlIGRvIG5vdCBzdXBwb3J0LCBzbyBjaGVjayAoU2VlOiAjODg5KVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfd2FybmVkVG9TdHJpbmdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBfd2FybmVkVG9TdHJpbmdSYWRpeCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgYmFzZS0xMCBpcyBhc3N1bWVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSA9PT0gMTYpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IHVzZSBiaWdOdW1iZXIudG9IZXhTdHJpbmcoKVwiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXJzXCIsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvU3RyaW5nKDEwKTtcbiAgICB9XG4gICAgdG9IZXhTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZXg7XG4gICAgfVxuICAgIHRvSlNPTihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJCaWdOdW1iZXJcIiwgaGV4OiB0aGlzLnRvSGV4U3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tPzB4WzAtOWEtZl0rJC9pKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgobmV3IEJOKHZhbHVlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuZGVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBNQVhfU0FGRSB8fCB2YWx1ZSA8PSAtTUFYX1NBRkUpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW55VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiAoYW55VmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oYW55VmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnl0ZXMoYW55VmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4bGlmeShhbnlWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlWYWx1ZSkge1xuICAgICAgICAgICAgLy8gSGV4YWJsZSBpbnRlcmZhY2UgKHRha2VzIHByaW9yaXR5KVxuICAgICAgICAgICAgaWYgKGFueVZhbHVlLnRvSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4ID0gYW55VmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGhhbmRsZSBsZWdhY3kgSlNPTi1pZmllZCB2YWx1ZXMgKGdvZXMgYXdheSBpbiB2NilcbiAgICAgICAgICAgICAgICBsZXQgaGV4ID0gYW55VmFsdWUuX2hleDtcbiAgICAgICAgICAgICAgICAvLyBOZXctZm9ybSBKU09OXG4gICAgICAgICAgICAgICAgaWYgKGhleCA9PSBudWxsICYmIGFueVZhbHVlLnR5cGUgPT09IFwiQmlnTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGV4ID0gYW55VmFsdWUuaGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhoZXgpIHx8IChoZXhbMF0gPT09IFwiLVwiICYmIGlzSGV4U3RyaW5nKGhleC5zdWJzdHJpbmcoMSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJpZ051bWJlciB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuICAgIH1cbn1cbi8vIE5vcm1hbGl6ZSB0aGUgaGV4IHN0cmluZ1xuZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcbiAgICAvLyBGb3IgQk4sIGNhbGwgb24gdGhlIGhleCBzdHJpbmdcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIC8vIElmIG5lZ2F0aXZlLCBwcmVwZW5kIHRoZSBuZWdhdGl2ZSBzaWduIHRvIHRoZSBub3JtYWxpemVkIHBvc2l0aXZlIHZhbHVlXG4gICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIC8vIENhbm5vdCBoYXZlIG11bHRpcGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG4gICAgICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIHRvSGV4IG9uIHRoZSBwb3NpdGl2ZSBjb21wb25lbnRcbiAgICAgICAgdmFsdWUgPSB0b0hleCh2YWx1ZSk7XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcbiAgICAgICAgaWYgKHZhbHVlID09PSBcIjB4MDBcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5lZ2F0ZSB0aGUgdmFsdWVcbiAgICAgICAgcmV0dXJuIFwiLVwiICsgdmFsdWU7XG4gICAgfVxuICAgIC8vIEFkZCBhIFwiMHhcIiBwcmVmaXggaWYgbWlzc2luZ1xuICAgIGlmICh2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemUgemVyb1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICAvLyBUcmltIHRvIHNtYWxsZXN0IGV2ZW4tbGVuZ3RoIHN0cmluZ1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPiA0ICYmIHZhbHVlLnN1YnN0cmluZygwLCA0KSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRvQmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRvSGV4KHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0b0JOKHZhbHVlKSB7XG4gICAgY29uc3QgaGV4ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpLnRvSGV4U3RyaW5nKCk7XG4gICAgaWYgKGhleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgcmV0dXJuIChuZXcgQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJOKGhleC5zdWJzdHJpbmcoMiksIDE2KTtcbn1cbmZ1bmN0aW9uIHRocm93RmF1bHQoZmF1bHQsIG9wZXJhdGlvbiwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IGZhdWx0OiBmYXVsdCwgb3BlcmF0aW9uOiBvcGVyYXRpb24gfTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGZhdWx0LCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTM2VG8xNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAzNikpLnRvU3RyaW5nKDE2KTtcbn1cbi8vIHZhbHVlIHNob3VsZCBoYXZlIG5vIHByZWZpeFxuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlMTZUbzM2KHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDE2KSkudG9TdHJpbmcoMzYpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHNoYTMgZnJvbSBcImpzLXNoYTNcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KGRhdGEpIHtcbiAgICByZXR1cm4gJzB4JyArIHNoYTMua2VjY2FrXzI1NihhcnJheWlmeShkYXRhKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicmxwLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBhcnJheWlmeUludGVnZXIodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgdmFsdWUgPj49IDg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2VuY29kZShvYmplY3QpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGxldCBwYXlsb2FkID0gW107XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgcGF5bG9hZCA9IHBheWxvYWQuY29uY2F0KF9lbmNvZGUoY2hpbGQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgcGF5bG9hZC51bnNoaWZ0KDB4YzAgKyBwYXlsb2FkLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBhcnJheWlmeUludGVnZXIocGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICBsZW5ndGgudW5zaGlmdCgweGY3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBsZW5ndGguY29uY2F0KHBheWxvYWQpO1xuICAgIH1cbiAgICBpZiAoIWlzQnl0ZXNMaWtlKG9iamVjdCkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIlJMUCBvYmplY3QgbXVzdCBiZSBCeXRlc0xpa2VcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5aWZ5KG9iamVjdCkpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgIGRhdGEudW5zaGlmdCgweDgwICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcbiAgICBsZW5ndGgudW5zaGlmdCgweGI3ICsgbGVuZ3RoLmxlbmd0aCk7XG4gICAgcmV0dXJuIGxlbmd0aC5jb25jYXQoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG9iamVjdCkge1xuICAgIHJldHVybiBoZXhsaWZ5KF9lbmNvZGUob2JqZWN0KSk7XG59XG5mdW5jdGlvbiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBjaGlsZE9mZnNldCwgbGVuZ3RoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKGNoaWxkT2Zmc2V0IDwgb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShkYXRhLCBjaGlsZE9mZnNldCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQucmVzdWx0KTtcbiAgICAgICAgY2hpbGRPZmZzZXQgKz0gZGVjb2RlZC5jb25zdW1lZDtcbiAgICAgICAgaWYgKGNoaWxkT2Zmc2V0ID4gb2Zmc2V0ICsgMSArIGxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbn1cbi8vIHJldHVybnMgeyBjb25zdW1lZDogbnVtYmVyLCByZXN1bHQ6IE9iamVjdCB9XG5mdW5jdGlvbiBfZGVjb2RlKGRhdGEsIG9mZnNldCkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICB9XG4gICAgLy8gQXJyYXkgd2l0aCBleHRyYSBsZW5ndGggcHJlZml4XG4gICAgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGY4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBzaG9ydCBzZWdtZW50IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGxvbmcgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZGVjb2RlQ2hpbGRyZW4oZGF0YSwgb2Zmc2V0LCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBsZW5ndGhMZW5ndGggKyBsZW5ndGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhW29mZnNldF0gPj0gMHhjMCkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGMwO1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgYXJyYXkgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YjgpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4ODApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHsgY29uc3VtZWQ6ICgxICsgbGVuZ3RoKSwgcmVzdWx0OiByZXN1bHQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29uc3VtZWQ6IDEsIHJlc3VsdDogaGV4bGlmeShkYXRhW29mZnNldF0pIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcbiAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgIGNvbnN0IGRlY29kZWQgPSBfZGVjb2RlKGJ5dGVzLCAwKTtcbiAgICBpZiAoZGVjb2RlZC5jb25zdW1lZCAhPT0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJscCBkYXRhXCIsIFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFkZHJlc3MvNS43LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBpc0hleFN0cmluZywgc3RyaXBaZXJvcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBfYmFzZTE2VG8zNiwgX2Jhc2UzNlRvMTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBlbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmxwXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgIH1cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG4gICAgY29uc3QgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSsrKSB7XG4gICAgICAgIGV4cGFuZGVkW2ldID0gY2hhcnNbaV0uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaGVkID0gYXJyYXlpZnkoa2VjY2FrMjU2KGV4cGFuZGVkKSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gPj4gNCkgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaGVkW2kgPj4gMV0gJiAweDBmKSA+PSA4KSB7XG4gICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcbn1cbi8vIFNoaW1zIGZvciBlbnZpcm9ubWVudHMgdGhhdCBhcmUgbWlzc2luZyBzb21lIHJlcXVpcmVkIGNvbnN0YW50cyBhbmQgZnVuY3Rpb25zXG5jb25zdCBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZjtcbmZ1bmN0aW9uIGxvZzEwKHgpIHtcbiAgICBpZiAoTWF0aC5sb2cxMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5sb2cxMCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwO1xufVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcbi8vIENyZWF0ZSBsb29rdXAgdGFibGVcbmNvbnN0IGliYW5Mb29rdXAgPSB7fTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcbn1cbmZvciAobGV0IGkgPSAwOyBpIDwgMjY7IGkrKykge1xuICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xufVxuLy8gSG93IG1hbnkgZGVjaW1hbCBkaWdpdHMgY2FuIHdlIHByb2Nlc3M/IChmb3IgNjQtYml0IGZsb2F0LCB0aGlzIGlzIDE1KVxuY29uc3Qgc2FmZURpZ2l0cyA9IE1hdGguZmxvb3IobG9nMTAoTUFYX1NBRkVfSU5URUdFUikpO1xuZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b1VwcGVyQ2FzZSgpO1xuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnN1YnN0cmluZyg0KSArIGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICsgXCIwMFwiO1xuICAgIGxldCBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKChjKSA9PiB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuICAgIC8vIEphdmFzY3JpcHQgY2FuIGhhbmRsZSBpbnRlZ2VycyBzYWZlbHkgdXAgdG8gMTUgKGRlY2ltYWwpIGRpZ2l0c1xuICAgIHdoaWxlIChleHBhbmRlZC5sZW5ndGggPj0gc2FmZURpZ2l0cykge1xuICAgICAgICBsZXQgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG4gICAgICAgIGV4cGFuZGVkID0gcGFyc2VJbnQoYmxvY2ssIDEwKSAlIDk3ICsgZXhwYW5kZWQuc3Vic3RyaW5nKGJsb2NrLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcbiAgICB3aGlsZSAoY2hlY2tzdW0ubGVuZ3RoIDwgMikge1xuICAgICAgICBjaGVja3N1bSA9IFwiMFwiICsgY2hlY2tzdW07XG4gICAgfVxuICAgIHJldHVybiBjaGVja3N1bTtcbn1cbjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIChhZGRyZXNzKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgaWYgKGFkZHJlc3MubWF0Y2goL14oMHgpP1swLTlhLWZBLUZdezQwfSQvKSkge1xuICAgICAgICAvLyBNaXNzaW5nIHRoZSAweCBwcmVmaXhcbiAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBcIjB4XCIgKyBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgLy8gSXQgaXMgYSBjaGVja3N1bW1lZCBhZGRyZXNzIHdpdGggYSBiYWQgY2hlY2tzdW1cbiAgICAgICAgaWYgKGFkZHJlc3MubWF0Y2goLyhbQS1GXS4qW2EtZl0pfChbYS1mXS4qW0EtRl0pLykgJiYgcmVzdWx0ICE9PSBhZGRyZXNzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heWJlIElDQVA/ICh3ZSBvbmx5IHN1cHBvcnQgZGlyZWN0IG1vZGUpXG4gICAgfVxuICAgIGVsc2UgaWYgKGFkZHJlc3MubWF0Y2goL15YRVswLTldezJ9WzAtOUEtWmEtel17MzAsMzF9JC8pKSB7XG4gICAgICAgIC8vIEl0IGlzIGFuIElDQVAgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSAhPT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGljYXAgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9iYXNlMzZUbzE2KGFkZHJlc3Muc3Vic3RyaW5nKDQpKTtcbiAgICAgICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCA0MCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gZ2V0Q2hlY2tzdW1BZGRyZXNzKFwiMHhcIiArIHJlc3VsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgbGV0IGJhc2UzNiA9IF9iYXNlMTZUbzM2KGdldEFkZHJlc3MoYWRkcmVzcykuc3Vic3RyaW5nKDIpKS50b1VwcGVyQ2FzZSgpO1xuICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcbiAgICAgICAgYmFzZTM2ID0gXCIwXCIgKyBiYXNlMzY7XG4gICAgfVxuICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xufVxuLy8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKSB7XG4gICAgbGV0IGZyb20gPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGZyb20gPSBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgZnJvbSBhZGRyZXNzXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBub25jZSA9IHN0cmlwWmVyb3MoYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGVuY29kZShbZnJvbSwgbm9uY2VdKSksIDEyKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKSB7XG4gICAgaWYgKGhleERhdGFMZW5ndGgoc2FsdCkgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzYWx0IG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJzYWx0XCIsIHNhbHQpO1xuICAgIH1cbiAgICBpZiAoaGV4RGF0YUxlbmd0aChpbml0Q29kZUhhc2gpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW5pdENvZGVIYXNoIG11c3QgYmUgMzIgYnl0ZXNcIiwgXCJpbml0Q29kZUhhc2hcIiwgaW5pdENvZGVIYXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1Nihjb25jYXQoW1wiMHhmZlwiLCBnZXRBZGRyZXNzKGZyb20pLCBzYWx0LCBpbml0Q29kZUhhc2hdKSksIDEyKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiaGFzaC81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInN0cmluZ3MvNS43LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCB2YXIgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuKGZ1bmN0aW9uIChVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0pIHtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJjdXJyZW50XCJdID0gXCJcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkNcIl0gPSBcIk5GQ1wiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GRFwiXSA9IFwiTkZEXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZLQ1wiXSA9IFwiTkZLQ1wiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0RcIl0gPSBcIk5GS0RcIjtcbn0pKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSB8fCAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0ge30pKTtcbjtcbmV4cG9ydCB2YXIgVXRmOEVycm9yUmVhc29uO1xuKGZ1bmN0aW9uIChVdGY4RXJyb3JSZWFzb24pIHtcbiAgICAvLyBBIGNvbnRpbnVhdGlvbiBieXRlIHdhcyBwcmVzZW50IHdoZXJlIHRoZXJlIHdhcyBub3RoaW5nIHRvIGNvbnRpbnVlXG4gICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuICAgIFV0ZjhFcnJvclJlYXNvbltcIlVORVhQRUNURURfQ09OVElOVUVcIl0gPSBcInVuZXhwZWN0ZWQgY29udGludWF0aW9uIGJ5dGVcIjtcbiAgICAvLyBBbiBpbnZhbGlkIChub24tY29udGludWF0aW9uKSBieXRlIHRvIHN0YXJ0IGEgVVRGLTggY29kZXBvaW50IHdhcyBmb3VuZFxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJCQURfUFJFRklYXCJdID0gXCJiYWQgY29kZXBvaW50IHByZWZpeFwiO1xuICAgIC8vIFRoZSBzdHJpbmcgaXMgdG9vIHNob3J0IHRvIHByb2Nlc3MgdGhlIGV4cGVjdGVkIGNvZGVwb2ludFxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSUlVOXCJdID0gXCJzdHJpbmcgb3ZlcnJ1blwiO1xuICAgIC8vIEEgbWlzc2luZyBjb250aW51YXRpb24gYnl0ZSB3YXMgZXhwZWN0ZWQgYnV0IG5vdCBmb3VuZFxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb250aW51YXRpb24gYnl0ZSB3YXMgZXhwZWN0ZWQgYXRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJNSVNTSU5HX0NPTlRJTlVFXCJdID0gXCJtaXNzaW5nIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gVGhlIGNvbXB1dGVkIGNvZGUgcG9pbnQgaXMgb3V0c2lkZSB0aGUgcmFuZ2UgZm9yIFVURi04XG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgb3V0c2lkZSB0aGUgVVRGLTggcmFuZ2VcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVVRfT0ZfUkFOR0VcIl0gPSBcIm91dCBvZiBVVEYtOCByYW5nZVwiO1xuICAgIC8vIFVURi04IHN0cmluZ3MgbWF5IG5vdCBjb250YWluIFVURi0xNiBzdXJyb2dhdGUgcGFpcnNcbiAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG4gICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBpbnNpZGUgdGhlIFVURi0xNiBzdXJyb2dhdGUgcmFuZ2VcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVVEYxNl9TVVJST0dBVEVcIl0gPSBcIlVURi0xNiBzdXJyb2dhdGVcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIGFuIG92ZXJsb25nIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgYWxyZWFkeSBib3VuZHMgY2hlY2tlZFxuICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJMT05HXCJdID0gXCJvdmVybG9uZyByZXByZXNlbnRhdGlvblwiO1xufSkoVXRmOEVycm9yUmVhc29uIHx8IChVdGY4RXJyb3JSZWFzb24gPSB7fSkpO1xuO1xuZnVuY3Rpb24gZXJyb3JGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBjb2RlcG9pbnQgYXQgb2Zmc2V0ICR7b2Zmc2V0fTsgJHtyZWFzb259YCwgXCJieXRlc1wiLCBieXRlcyk7XG59XG5mdW5jdGlvbiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnZhbGlkIHByZWZpeCAoaW5jbHVkaW5nIHN0cmF5IGNvbnRpbnVhdGlvbiksIHNraXAgYW55IGFkZGl0aW9uYWwgY29udGludWF0aW9uIGJ5dGVzXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVggfHwgcmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAobGV0IG8gPSBvZmZzZXQgKyAxOyBvIDwgYnl0ZXMubGVuZ3RoOyBvKyspIHtcbiAgICAgICAgICAgIGlmIChieXRlc1tvXSA+PiA2ICE9PSAweDAyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIC8vIFRoaXMgYnl0ZSBydW5zIHVzIHBhc3QgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzbyBqdXN0IGp1bXAgdG8gdGhlIGVuZFxuICAgIC8vIChidXQgdGhlIGZpcnN0IGJ5dGUgd2FzIHJlYWQgYWxyZWFkeSByZWFkIGFuZCB0aGVyZWZvcmUgc2tpcHBlZClcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTikge1xuICAgICAgICByZXR1cm4gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0IC0gMTtcbiAgICB9XG4gICAgLy8gTm90aGluZyB0byBza2lwXG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiByZXBsYWNlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gT3ZlcmxvbmcgcmVwcmVzZW50YXRpb25zIGFyZSBvdGhlcndpc2UgXCJ2YWxpZFwiIGNvZGUgcG9pbnRzOyBqdXN0IG5vbi1kZWlzdGluZ3Rpc2hlZFxuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORykge1xuICAgICAgICBvdXRwdXQucHVzaChiYWRDb2RlcG9pbnQpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gUHV0IHRoZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaW50byB0aGUgb3V0cHV0XG4gICAgb3V0cHV0LnB1c2goMHhmZmZkKTtcbiAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG4gICAgcmV0dXJuIGlnbm9yZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCk7XG59XG4vLyBDb21tb24gZXJyb3IgaGFuZGluZyBzdHJhdGVnaWVzXG5leHBvcnQgY29uc3QgVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcbiAgICBlcnJvcjogZXJyb3JGdW5jLFxuICAgIGlnbm9yZTogaWdub3JlRnVuYyxcbiAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xufSk7XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMzU2NDkzL2RlY29kZS11dGYtOC13aXRoLWphdmFzY3JpcHQjMTM2OTE0OTlcbmZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgaWYgKG9uRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICBvbkVycm9yID0gVXRmOEVycm9yRnVuY3MuZXJyb3I7XG4gICAgfVxuICAgIGJ5dGVzID0gYXJyYXlpZnkoYnl0ZXMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBJbnZhbGlkIGJ5dGVzIGFyZSBpZ25vcmVkXG4gICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYyA9IGJ5dGVzW2krK107XG4gICAgICAgIC8vIDB4eHggeHh4eFxuICAgICAgICBpZiAoYyA+PiA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpYnl0ZTsgaG93IG1hbnkgYnl0ZXMgbGVmdCBmb3IgdGhpcyBjaGFyYWN0ZXI/XG4gICAgICAgIGxldCBleHRyYUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGxldCBvdmVybG9uZ01hc2sgPSBudWxsO1xuICAgICAgICAvLyAxMTB4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmO1xuICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjApID09PSAweGUwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweDdmZjtcbiAgICAgICAgICAgIC8vIDExMTEgMHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4IDEweHggeHh4eFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhmOCkgPT09IDB4ZjApIHtcbiAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMztcbiAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLkJBRF9QUkVGSVgsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIHdlIGhhdmUgZW5vdWdoIGJ5dGVzIGluIG91ciBkYXRhP1xuICAgICAgICBpZiAoaSAtIDEgKyBleHRyYUxlbmd0aCA+PSBieXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUlJVTiwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsZW5ndGggcHJlZml4IGZyb20gdGhlIGNoYXJcbiAgICAgICAgbGV0IHJlcyA9IGMgJiAoKDEgPDwgKDggLSBleHRyYUxlbmd0aCAtIDEpKSAtIDEpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCBuZXh0Q2hhciA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgLy8gSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVxuICAgICAgICAgICAgaWYgKChuZXh0Q2hhciAmIDB4YzApICE9IDB4ODApIHtcbiAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk1JU1NJTkdfQ09OVElOVUUsIGksIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWF4aW11bSBjb2RlIHBvaW50XG4gICAgICAgIGlmIChyZXMgPiAweDEwZmZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVVRfT0ZfUkFOR0UsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcbiAgICAgICAgaWYgKHJlcyA+PSAweGQ4MDAgJiYgcmVzIDw9IDB4ZGZmZikge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5VVEYxNl9TVVJST0dBVEUsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3Igb3Zlcmxvbmcgc2VxdWVuY2VzIChtb3JlIGJ5dGVzIHRoYW4gbmVlZGVkKVxuICAgICAgICBpZiAocmVzIDw9IG92ZXJsb25nTWFzaykge1xuICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORywgaSAtIDEgLSBleHRyYUxlbmd0aCwgYnl0ZXMsIHJlc3VsdCwgcmVzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE4NzI5NDA1L2hvdy10by1jb252ZXJ0LXV0Zjgtc3RyaW5nLXRvLWJ5dGUtYXJyYXlcbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhCeXRlcyhzdHIsIGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgIGlmIChmb3JtICE9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuICAgICAgICBzdHIgPSBzdHIubm9ybWFsaXplKGZvcm0pO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gNikgfCAweGMwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZmMwMCkgPT0gMHhkODAwKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb25zdCBjMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGkgPj0gc3RyLmxlbmd0aCB8fCAoYzIgJiAweGZjMDApICE9PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV0Zi04IHN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG4gICAgICAgICAgICBjb25zdCBwYWlyID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyID4+IDE4KSB8IDB4ZjApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDEyKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgPj4gMTIpIHwgMHhlMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoKGMgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheWlmeShyZXN1bHQpO1xufVxuO1xuZnVuY3Rpb24gZXNjYXBlQ2hhcih2YWx1ZSkge1xuICAgIGNvbnN0IGhleCA9IChcIjAwMDBcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgcmV0dXJuIFwiXFxcXHVcIiArIGhleC5zdWJzdHJpbmcoaGV4Lmxlbmd0aCAtIDQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF90b0VzY2FwZWRVdGY4U3RyaW5nKGJ5dGVzLCBvbkVycm9yKSB7XG4gICAgcmV0dXJuICdcIicgKyBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikubWFwKChjb2RlUG9pbnQpID0+IHtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDI1Nikge1xuICAgICAgICAgICAgc3dpdGNoIChjb2RlUG9pbnQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgICAgY2FzZSA5OiByZXR1cm4gXCJcXFxcdFwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IHJldHVybiBcIlxcXFxuXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFwiXFxcXHJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDM0OiByZXR1cm4gXCJcXFxcXFxcIlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTI6IHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID49IDMyICYmIGNvZGVQb2ludCA8IDEyNykge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGVDaGFyKGNvZGVQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICAgIHJldHVybiBlc2NhcGVDaGFyKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCkgKyBlc2NhcGVDaGFyKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApO1xuICAgIH0pLmpvaW4oXCJcIikgKyAnXCInO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF90b1V0ZjhTdHJpbmcoY29kZVBvaW50cykge1xuICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoKChjb2RlUG9pbnQgPj4gMTApICYgMHgzZmYpICsgMHhkODAwKSwgKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApKTtcbiAgICB9KS5qb2luKFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiBfdG9VdGY4U3RyaW5nKGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsIGZvcm0gPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgIHJldHVybiBnZXRVdGY4Q29kZVBvaW50cyh0b1V0ZjhCeXRlcyhzdHIsIGZvcm0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0ZjguanMubWFwIiwiaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlkKHRleHQpIHtcbiAgICByZXR1cm4ga2VjY2FrMjU2KHRvVXRmOEJ5dGVzKHRleHQpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkLmpzLm1hcCIsInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4Q29uY2F0LCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkXCI7XG5jb25zdCBwYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xucGFkZGluZy5maWxsKDApO1xuY29uc3QgTmVnYXRpdmVPbmUgPSBCaWdOdW1iZXIuZnJvbSgtMSk7XG5jb25zdCBaZXJvID0gQmlnTnVtYmVyLmZyb20oMCk7XG5jb25zdCBPbmUgPSBCaWdOdW1iZXIuZnJvbSgxKTtcbmNvbnN0IE1heFVpbnQyNTYgPSBCaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcbmZ1bmN0aW9uIGhleFBhZFJpZ2h0KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgY29uc3QgcGFkT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgMzI7XG4gICAgaWYgKHBhZE9mZnNldCkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KFtieXRlcywgcGFkZGluZy5zbGljZShwYWRPZmZzZXQpXSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbn1cbmNvbnN0IGhleFRydWUgPSBoZXhaZXJvUGFkKE9uZS50b0hleFN0cmluZygpLCAzMik7XG5jb25zdCBoZXhGYWxzZSA9IGhleFplcm9QYWQoWmVyby50b0hleFN0cmluZygpLCAzMik7XG5jb25zdCBkb21haW5GaWVsZFR5cGVzID0ge1xuICAgIG5hbWU6IFwic3RyaW5nXCIsXG4gICAgdmVyc2lvbjogXCJzdHJpbmdcIixcbiAgICBjaGFpbklkOiBcInVpbnQyNTZcIixcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogXCJhZGRyZXNzXCIsXG4gICAgc2FsdDogXCJieXRlczMyXCJcbn07XG5jb25zdCBkb21haW5GaWVsZE5hbWVzID0gW1xuICAgIFwibmFtZVwiLCBcInZlcnNpb25cIiwgXCJjaGFpbklkXCIsIFwidmVyaWZ5aW5nQ29udHJhY3RcIiwgXCJzYWx0XCJcbl07XG5mdW5jdGlvbiBjaGVja1N0cmluZyhrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gLCBgZG9tYWluLiR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmNvbnN0IGRvbWFpbkNoZWNrcyA9IHtcbiAgICBuYW1lOiBjaGVja1N0cmluZyhcIm5hbWVcIiksXG4gICAgdmVyc2lvbjogY2hlY2tTdHJpbmcoXCJ2ZXJzaW9uXCIpLFxuICAgIGNoYWluSWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBmb3IgXCJjaGFpbklkXCJgLCBcImRvbWFpbi5jaGFpbklkXCIsIHZhbHVlKTtcbiAgICB9LFxuICAgIHZlcmlmeWluZ0NvbnRyYWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInZlcmlmeWluZ0NvbnRyYWN0XCJgLCBcImRvbWFpbi52ZXJpZnlpbmdDb250cmFjdFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzYWx0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbGVuZ3RoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIGRvbWFpbiB2YWx1ZSBcInNhbHRcImAsIFwiZG9tYWluLnNhbHRcIiwgdmFsdWUpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBnZXRCYXNlRW5jb2Rlcih0eXBlKSB7XG4gICAgLy8gaW50WFggYW5kIHVpbnRYWFxuICAgIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKHU/KWludChcXGQqKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCAlIDggIT09IDAgfHwgd2lkdGggPiAyNTYgfHwgKG1hdGNoWzJdICYmIG1hdGNoWzJdICE9PSBTdHJpbmcod2lkdGgpKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG51bWVyaWMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYm91bmRzVXBwZXIgPSBNYXhVaW50MjU2Lm1hc2soc2lnbmVkID8gKHdpZHRoIC0gMSkgOiB3aWR0aCk7XG4gICAgICAgICAgICBjb25zdCBib3VuZHNMb3dlciA9IHNpZ25lZCA/IGJvdW5kc1VwcGVyLmFkZChPbmUpLm11bChOZWdhdGl2ZU9uZSkgOiBaZXJvO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHYubHQoYm91bmRzTG93ZXIpIHx8IHYuZ3QoYm91bmRzVXBwZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHZhbHVlIG91dC1vZi1ib3VuZHMgZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQodi50b1R3b3MoMjU2KS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJ5dGVzWFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCspJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IHdpZHRoID4gMzIgfHwgbWF0Y2hbMV0gIT09IFN0cmluZyh3aWR0aCkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyB3aWR0aFwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleFBhZFJpZ2h0KHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKGdldEFkZHJlc3ModmFsdWUpLCAzMik7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJib29sXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKCF2YWx1ZSkgPyBoZXhGYWxzZSA6IGhleFRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYnl0ZXNcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1Nih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlbmNvZGVUeXBlKG5hbWUsIGZpZWxkcykge1xuICAgIHJldHVybiBgJHtuYW1lfSgke2ZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiAodHlwZSArIFwiIFwiICsgbmFtZSkpLmpvaW4oXCIsXCIpfSlgO1xufVxuZXhwb3J0IGNsYXNzIFR5cGVkRGF0YUVuY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKHR5cGVzKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidHlwZXNcIiwgT2JqZWN0LmZyZWV6ZShkZWVwQ29weSh0eXBlcykpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfZW5jb2RlckNhY2hlXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfdHlwZXNcIiwge30pO1xuICAgICAgICAvLyBMaW5rIHN0cnVjdCB0eXBlcyB0byB0aGVpciBkaXJlY3QgY2hpbGQgc3RydWN0c1xuICAgICAgICBjb25zdCBsaW5rcyA9IHt9O1xuICAgICAgICAvLyBMaW5rIHN0cnVjdHMgdG8gc3RydWN0cyB3aGljaCBjb250YWluIHRoZW0gYXMgYSBjaGlsZFxuICAgICAgICBjb25zdCBwYXJlbnRzID0ge307XG4gICAgICAgIC8vIExpbmsgYWxsIHN1YnR5cGVzIHdpdGhpbiBhIGdpdmVuIHN0cnVjdFxuICAgICAgICBjb25zdCBzdWJ0eXBlcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0eXBlcykuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICAgICAgbGlua3NbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIHBhcmVudHNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIHN1YnR5cGVzW3R5cGVdID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgICAgICB0eXBlc1tuYW1lXS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGVhY2ggZmllbGQgaGFzIGEgdW5pcXVlIG5hbWVcbiAgICAgICAgICAgICAgICBpZiAodW5pcXVlTmFtZXNbZmllbGQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWUgJHtKU09OLnN0cmluZ2lmeShmaWVsZC5uYW1lKX0gaW4gJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlTmFtZXNbZmllbGQubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSB0eXBlIChkcm9wIGFueSBhcnJheSBzcGVjaWZpZXJzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gZmllbGQudHlwZS5tYXRjaCgvXihbXlxceDViXSopKFxceDVifCQpLylbMV07XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VUeXBlID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlIHRvICR7SlNPTi5zdHJpbmdpZnkoYmFzZVR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJcyB0aGlzIGEgYmFzZSBlbmNvZGluZyB0eXBlP1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2RlcihiYXNlVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHNbYmFzZVR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZSAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmthZ2VcbiAgICAgICAgICAgICAgICBwYXJlbnRzW2Jhc2VUeXBlXS5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgICAgIGxpbmtzW25hbWVdW2Jhc2VUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWR1Y2UgdGhlIHByaW1hcnkgdHlwZVxuICAgICAgICBjb25zdCBwcmltYXJ5VHlwZXMgPSBPYmplY3Qua2V5cyhwYXJlbnRzKS5maWx0ZXIoKG4pID0+IChwYXJlbnRzW25dLmxlbmd0aCA9PT0gMCkpO1xuICAgICAgICBpZiAocHJpbWFyeVR5cGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJpbWFyeSB0eXBlXCIsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByaW1hcnlUeXBlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBhbWJpZ3VvdXMgcHJpbWFyeSB0eXBlcyBvciB1bnVzZWQgdHlwZXM6ICR7cHJpbWFyeVR5cGVzLm1hcCgodCkgPT4gKEpTT04uc3RyaW5naWZ5KHQpKSkuam9pbihcIiwgXCIpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpbWFyeVR5cGVcIiwgcHJpbWFyeVR5cGVzWzBdKTtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHR5cGUgcmVmZXJlbmNlc1xuICAgICAgICBmdW5jdGlvbiBjaGVja0NpcmN1bGFyKHR5cGUsIGZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoZm91bmRbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KHR5cGUpfWAsIFwidHlwZXNcIiwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmRbdHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobGlua3NbdHlwZV0pLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2NoaWxkXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNoZWNrIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgY2hlY2tDaXJjdWxhcihjaGlsZCwgZm91bmQpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmsgYWxsIGFuY2VzdG9ycyBhcyBoYXZpbmcgdGhpcyBkZWNlbmRhbnRcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhmb3VuZCkuZm9yRWFjaCgoc3VidHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlc1tzdWJ0eXBlXVtjaGlsZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgZm91bmRbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tDaXJjdWxhcih0aGlzLnByaW1hcnlUeXBlLCB7fSk7XG4gICAgICAgIC8vIENvbXB1dGUgZWFjaCBmdWxseSBkZXNjcmliZSB0eXBlXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdWJ0eXBlcykge1xuICAgICAgICAgICAgY29uc3Qgc3QgPSBPYmplY3Qua2V5cyhzdWJ0eXBlc1tuYW1lXSk7XG4gICAgICAgICAgICBzdC5zb3J0KCk7XG4gICAgICAgICAgICB0aGlzLl90eXBlc1tuYW1lXSA9IGVuY29kZVR5cGUobmFtZSwgdHlwZXNbbmFtZV0pICsgc3QubWFwKCh0KSA9PiBlbmNvZGVUeXBlKHQsIHR5cGVzW3RdKSkuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgbGV0IGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV07XG4gICAgICAgIGlmICghZW5jb2Rlcikge1xuICAgICAgICAgICAgZW5jb2RlciA9IHRoaXMuX2VuY29kZXJDYWNoZVt0eXBlXSA9IHRoaXMuX2dldEVuY29kZXIodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgfVxuICAgIF9nZXRFbmNvZGVyKHR5cGUpIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0eXBlLm1hdGNoKC9eKC4qKShcXHg1YihcXGQqKVxceDVkKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCBzdWJFbmNvZGVyID0gdGhpcy5nZXRFbmNvZGVyKHN1YnR5cGUpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYXJyYXkgbGVuZ3RoIG1pc21hdGNoOyBleHBlY3RlZCBsZW5ndGggJHsgYXJyYXlMZW5ndGggfVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHZhbHVlLm1hcChzdWJFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZXNbc3VidHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm1hcChrZWNjYWsyNTYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2VjY2FrMjU2KGhleENvbmNhdChyZXN1bHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RydWN0XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMudHlwZXNbdHlwZV07XG4gICAgICAgIGlmIChmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZWRUeXBlID0gaWQodGhpcy5fdHlwZXNbdHlwZV0pO1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGZpZWxkcy5tYXAoKHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0RW5jb2Rlcih0eXBlKSh2YWx1ZVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90eXBlc1t0eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnVuc2hpZnQoZW5jb2RlZFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhDb25jYXQodmFsdWVzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgZW5jb2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3R5cGVzW25hbWVdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBlbmNvZGVEYXRhKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWUpO1xuICAgIH1cbiAgICBoYXNoU3RydWN0KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYodGhpcy5lbmNvZGVEYXRhKG5hbWUsIHZhbHVlKSk7XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVEYXRhKHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgaGFzaCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoU3RydWN0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgX3Zpc2l0KHR5cGUsIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBCYXNpYyBlbmNvZGVyIHR5cGUgKGFkZHJlc3MsIGJvb2wsIHVpbnQyNTYsIGV0YylcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IGdldEJhc2VFbmNvZGVyKHR5cGUpO1xuICAgICAgICAgICAgaWYgKGVuY29kZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodHlwZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA+PSAwICYmIHZhbHVlLmxlbmd0aCAhPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLl92aXNpdChzdWJ0eXBlLCB2LCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRzLnJlZHVjZSgoYWNjdW0sIHsgbmFtZSwgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSB0aGlzLl92aXNpdCh0eXBlLCB2YWx1ZVtuYW1lXSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5rbm93biB0eXBlOiAke3R5cGV9YCwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgIH1cbiAgICB2aXNpdCh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0KHRoaXMucHJpbWFyeVR5cGUsIHZhbHVlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZWREYXRhRW5jb2Rlcih0eXBlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQcmltYXJ5VHlwZSh0eXBlcykge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5wcmltYXJ5VHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2hTdHJ1Y3QobmFtZSwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2hTdHJ1Y3QobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaERvbWFpbihkb21haW4pIHtcbiAgICAgICAgY29uc3QgZG9tYWluRmllbGRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkb21haW5GaWVsZFR5cGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCB0eXBlZC1kYXRhIGRvbWFpbiBrZXk6ICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJkb21haW5cIiwgZG9tYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbWFpbkZpZWxkcy5wdXNoKHsgbmFtZSwgdHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW5GaWVsZHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihhLm5hbWUpIC0gZG9tYWluRmllbGROYW1lcy5pbmRleE9mKGIubmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5oYXNoU3RydWN0KFwiRUlQNzEyRG9tYWluXCIsIHsgRUlQNzEyRG9tYWluOiBkb21haW5GaWVsZHMgfSwgZG9tYWluKTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaGV4Q29uY2F0KFtcbiAgICAgICAgICAgIFwiMHgxOTAxXCIsXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKSxcbiAgICAgICAgICAgIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykuaGFzaCh2YWx1ZSlcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyNTYoVHlwZWREYXRhRW5jb2Rlci5lbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpKTtcbiAgICB9XG4gICAgLy8gUmVwbGFjZXMgYWxsIGFkZHJlc3MgdHlwZXMgd2l0aCBFTlMgbmFtZXMgd2l0aCB0aGVpciBsb29rZWQgdXAgYWRkcmVzc1xuICAgIHN0YXRpYyByZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIHJlc29sdmVOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIGEgY29weSB0byBpc29sYXRlIGl0IGZyb20gdGhlIG9iamVjdCBwYXNzZWQgaW5cbiAgICAgICAgICAgIGRvbWFpbiA9IHNoYWxsb3dDb3B5KGRvbWFpbik7XG4gICAgICAgICAgICAvLyBMb29rIHVwIGFsbCBFTlMgbmFtZXNcbiAgICAgICAgICAgIGNvbnN0IGVuc0NhY2hlID0ge307XG4gICAgICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGRvbWFpbidzIHZlcmlmeWluZ0NvbnRyYWN0P1xuICAgICAgICAgICAgaWYgKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCAmJiAhaXNIZXhTdHJpbmcoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0LCAyMCkpIHtcbiAgICAgICAgICAgICAgICBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdID0gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgZW5jb2RlciB0byB2aXNpdCBhbGwgdGhlIGJhc2UgdmFsdWVzXG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgICAgIC8vIEdldCBhIGxpc3Qgb2YgYWxsIHRoZSBhZGRyZXNzZXNcbiAgICAgICAgICAgIGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiAhaXNIZXhTdHJpbmcodmFsdWUsIDIwKSkge1xuICAgICAgICAgICAgICAgICAgICBlbnNDYWNoZVt2YWx1ZV0gPSBcIjB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gTG9va3VwIGVhY2ggbmFtZVxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVuc0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbbmFtZV0gPSB5aWVsZCByZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGRvbWFpbiB2ZXJpZnlpbmdDb250cmFjdCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCA9IGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIGFsbCBFTlMgbmFtZXMgd2l0aCB0aGVpciBhZGRyZXNzXG4gICAgICAgICAgICB2YWx1ZSA9IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZHJlc3NcIiAmJiBlbnNDYWNoZVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuc0NhY2hlW3ZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkb21haW4sIHZhbHVlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGF5bG9hZChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZG9tYWluIGZpZWxkc1xuICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmhhc2hEb21haW4oZG9tYWluKTtcbiAgICAgICAgLy8gRGVyaXZlIHRoZSBFSVA3MTJEb21haW4gU3RydWN0IHJlZmVyZW5jZSB0eXBlXG4gICAgICAgIGNvbnN0IGRvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgICBjb25zdCBkb21haW5UeXBlcyA9IFtdO1xuICAgICAgICBkb21haW5GaWVsZE5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9tYWluW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5WYWx1ZXNbbmFtZV0gPSBkb21haW5DaGVja3NbbmFtZV0odmFsdWUpO1xuICAgICAgICAgICAgZG9tYWluVHlwZXMucHVzaCh7IG5hbWUsIHR5cGU6IGRvbWFpbkZpZWxkVHlwZXNbbmFtZV0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKTtcbiAgICAgICAgY29uc3QgdHlwZXNXaXRoRG9tYWluID0gc2hhbGxvd0NvcHkodHlwZXMpO1xuICAgICAgICBpZiAodHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzIG11c3Qgbm90IGNvbnRhaW4gRUlQNzEyRG9tYWluIHR5cGVcIiwgXCJ0eXBlcy5FSVA3MTJEb21haW5cIiwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHlwZXNXaXRoRG9tYWluLkVJUDcxMkRvbWFpbiA9IGRvbWFpblR5cGVzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBkYXRhIHN0cnVjdHVyZXMgYW5kIHR5cGVzXG4gICAgICAgIGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGVzOiB0eXBlc1dpdGhEb21haW4sXG4gICAgICAgICAgICBkb21haW46IGRvbWFpblZhbHVlcyxcbiAgICAgICAgICAgIHByaW1hcnlUeXBlOiBlbmNvZGVyLnByaW1hcnlUeXBlLFxuICAgICAgICAgICAgbWVzc2FnZTogZW5jb2Rlci52aXNpdCh2YWx1ZSwgKHR5cGUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXmJ5dGVzKFxcZCopLykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYXJyYXlpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdWludCBvciBpbnRcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgc3RyaW5nYCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVkLWRhdGEuanMubWFwIiwiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuY29uc3QgTmVnYXRpdmVPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgtMSkpO1xuY29uc3QgWmVybyA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDApKTtcbmNvbnN0IE9uZSA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDEpKTtcbmNvbnN0IFR3byA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKDIpKTtcbmNvbnN0IFdlaVBlckV0aGVyID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIxMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heFVpbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG5jb25zdCBNaW5JbnQyNTYgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbShcIi0weDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikpO1xuY29uc3QgTWF4SW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuZXhwb3J0IHsgTmVnYXRpdmVPbmUsIFplcm8sIE9uZSwgVHdvLCBXZWlQZXJFdGhlciwgTWF4VWludDI1NiwgTWluSW50MjU2LCBNYXhJbnQyNTYsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdudW1iZXJzLmpzLm1hcCIsImltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgaGFzaCBmcm9tICdoYXNoLmpzJztcblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBiYXNlZGlyLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHtcblx0XHRwYXRoOiBiYXNlZGlyLFxuXHRcdGV4cG9ydHM6IHt9LFxuXHRcdHJlcXVpcmU6IGZ1bmN0aW9uIChwYXRoLCBiYXNlKSB7XG5cdFx0XHRyZXR1cm4gY29tbW9uanNSZXF1aXJlKHBhdGgsIChiYXNlID09PSB1bmRlZmluZWQgfHwgYmFzZSA9PT0gbnVsbCkgPyBtb2R1bGUucGF0aCA6IGJhc2UpO1xuXHRcdH1cblx0fSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmUHJlc2VudCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSA/IG5bJ2RlZmF1bHQnXSA6IG47XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZOb3ROYW1lZCAobikge1xuXHRyZXR1cm4gbiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgJ2RlZmF1bHQnKSAmJiBPYmplY3Qua2V5cyhuKS5sZW5ndGggPT09IDEgPyBuWydkZWZhdWx0J10gOiBuO1xufVxuXG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2Uobikge1xuXHRpZiAobi5fX2VzTW9kdWxlKSByZXR1cm4gbjtcblx0dmFyIGEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdfX2VzTW9kdWxlJywge3ZhbHVlOiB0cnVlfSk7XG5cdE9iamVjdC5rZXlzKG4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcblx0XHR2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobiwgayk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIGssIGQuZ2V0ID8gZCA6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIG5ba107XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlICgpIHtcblx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBAcm9sbHVwL3BsdWdpbi1jb21tb25qcycpO1xufVxuXG52YXIgbWluaW1hbGlzdGljQXNzZXJ0ID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuXG52YXIgdXRpbHNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGhpID0gYyA+PiA4O1xuICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG4gICAgICBpZiAoaGkpXG4gICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG4gICAgICBlbHNlXG4gICAgICAgIHJlcy5wdXNoKGxvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxudXRpbHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9IZXggPSB0b0hleDtcblxudXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0b0hleChhcnIpO1xuICBlbHNlXG4gICAgcmV0dXJuIGFycjtcbn07XG59KTtcblxudmFyIHV0aWxzXzEkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gZXhwb3J0cztcblxuXG5cblxudXRpbHMuYXNzZXJ0ID0gbWluaW1hbGlzdGljQXNzZXJ0O1xudXRpbHMudG9BcnJheSA9IHV0aWxzXzEudG9BcnJheTtcbnV0aWxzLnplcm8yID0gdXRpbHNfMS56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gdXRpbHNfMS50b0hleDtcbnV0aWxzLmVuY29kZSA9IHV0aWxzXzEuZW5jb2RlO1xuXG4vLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuZnVuY3Rpb24gZ2V0TkFGKG51bSwgdywgYml0cykge1xuICB2YXIgbmFmID0gbmV3IEFycmF5KE1hdGgubWF4KG51bS5iaXRMZW5ndGgoKSwgYml0cykgKyAxKTtcbiAgbmFmLmZpbGwoMCk7XG5cbiAgdmFyIHdzID0gMSA8PCAodyArIDEpO1xuICB2YXIgayA9IG51bS5jbG9uZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHo7XG4gICAgdmFyIG1vZCA9IGsuYW5kbG4od3MgLSAxKTtcbiAgICBpZiAoay5pc09kZCgpKSB7XG4gICAgICBpZiAobW9kID4gKHdzID4+IDEpIC0gMSlcbiAgICAgICAgeiA9ICh3cyA+PiAxKSAtIG1vZDtcbiAgICAgIGVsc2VcbiAgICAgICAgeiA9IG1vZDtcbiAgICAgIGsuaXN1Ym4oeik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSAwO1xuICAgIH1cblxuICAgIG5hZltpXSA9IHo7XG4gICAgay5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4gbmFmO1xufVxudXRpbHMuZ2V0TkFGID0gZ2V0TkFGO1xuXG4vLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cbmZ1bmN0aW9uIGdldEpTRihrMSwgazIpIHtcbiAgdmFyIGpzZiA9IFtcbiAgICBbXSxcbiAgICBbXSxcbiAgXTtcblxuICBrMSA9IGsxLmNsb25lKCk7XG4gIGsyID0gazIuY2xvbmUoKTtcbiAgdmFyIGQxID0gMDtcbiAgdmFyIGQyID0gMDtcbiAgdmFyIG04O1xuICB3aGlsZSAoazEuY21wbigtZDEpID4gMCB8fCBrMi5jbXBuKC1kMikgPiAwKSB7XG4gICAgLy8gRmlyc3QgcGhhc2VcbiAgICB2YXIgbTE0ID0gKGsxLmFuZGxuKDMpICsgZDEpICYgMztcbiAgICB2YXIgbTI0ID0gKGsyLmFuZGxuKDMpICsgZDIpICYgMztcbiAgICBpZiAobTE0ID09PSAzKVxuICAgICAgbTE0ID0gLTE7XG4gICAgaWYgKG0yNCA9PT0gMylcbiAgICAgIG0yNCA9IC0xO1xuICAgIHZhciB1MTtcbiAgICBpZiAoKG0xNCAmIDEpID09PSAwKSB7XG4gICAgICB1MSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG04ID0gKGsxLmFuZGxuKDcpICsgZDEpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0yNCA9PT0gMilcbiAgICAgICAgdTEgPSAtbTE0O1xuICAgICAgZWxzZVxuICAgICAgICB1MSA9IG0xNDtcbiAgICB9XG4gICAganNmWzBdLnB1c2godTEpO1xuXG4gICAgdmFyIHUyO1xuICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcbiAgICAgIHUyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazIuYW5kbG4oNykgKyBkMikgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuICAgICAgICB1MiA9IC1tMjQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUyID0gbTI0O1xuICAgIH1cbiAgICBqc2ZbMV0ucHVzaCh1Mik7XG5cbiAgICAvLyBTZWNvbmQgcGhhc2VcbiAgICBpZiAoMiAqIGQxID09PSB1MSArIDEpXG4gICAgICBkMSA9IDEgLSBkMTtcbiAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG4gICAgICBkMiA9IDEgLSBkMjtcbiAgICBrMS5pdXNocm4oMSk7XG4gICAgazIuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIGpzZjtcbn1cbnV0aWxzLmdldEpTRiA9IGdldEpTRjtcblxuZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkob2JqLCBuYW1lLCBjb21wdXRlcikge1xuICB2YXIga2V5ID0gJ18nICsgbmFtZTtcbiAgb2JqLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzW2tleV0gIT09IHVuZGVmaW5lZCA/IHRoaXNba2V5XSA6XG4gICAgICB0aGlzW2tleV0gPSBjb21wdXRlci5jYWxsKHRoaXMpO1xuICB9O1xufVxudXRpbHMuY2FjaGVkUHJvcGVydHkgPSBjYWNoZWRQcm9wZXJ0eTtcblxuZnVuY3Rpb24gcGFyc2VCeXRlcyhieXRlcykge1xuICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG4gICAgYnl0ZXM7XG59XG51dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuZnVuY3Rpb24gaW50RnJvbUxFKGJ5dGVzKSB7XG4gIHJldHVybiBuZXcgQk4oYnl0ZXMsICdoZXgnLCAnbGUnKTtcbn1cbnV0aWxzLmludEZyb21MRSA9IGludEZyb21MRTtcbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgZ2V0TkFGID0gdXRpbHNfMSQxLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlsc18xJDEuZ2V0SlNGO1xudmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gQmFzZUN1cnZlKHR5cGUsIGNvbmYpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wID0gbmV3IEJOKGNvbmYucCwgMTYpO1xuXG4gIC8vIFVzZSBNb250Z29tZXJ5LCB3aGVuIHRoZXJlIGlzIG5vIGZhc3QgcmVkdWN0aW9uIGZvciB0aGUgcHJpbWVcbiAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gQk4ucmVkKGNvbmYucHJpbWUpIDogQk4ubW9udCh0aGlzLnApO1xuXG4gIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcbiAgdGhpcy56ZXJvID0gbmV3IEJOKDApLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5vbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnR3byA9IG5ldyBCTigyKS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8gQ3VydmUgY29uZmlndXJhdGlvbiwgb3B0aW9uYWxcbiAgdGhpcy5uID0gY29uZi5uICYmIG5ldyBCTihjb25mLm4sIDE2KTtcbiAgdGhpcy5nID0gY29uZi5nICYmIHRoaXMucG9pbnRGcm9tSlNPTihjb25mLmcsIGNvbmYuZ1JlZCk7XG5cbiAgLy8gVGVtcG9yYXJ5IGFycmF5c1xuICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMiA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQzID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5fYml0TGVuZ3RoID0gdGhpcy5uID8gdGhpcy5uLmJpdExlbmd0aCgpIDogMDtcblxuICAvLyBHZW5lcmFsaXplZCBHcmVnIE1heHdlbGwncyB0cmlja1xuICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuICBpZiAoIWFkanVzdENvdW50IHx8IGFkanVzdENvdW50LmNtcG4oMTAwKSA+IDApIHtcbiAgICB0aGlzLnJlZE4gPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX21heHdlbGxUcmljayA9IHRydWU7XG4gICAgdGhpcy5yZWROID0gdGhpcy5uLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxufVxudmFyIGJhc2UgPSBCYXNlQ3VydmU7XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcbiAgYXNzZXJ0JDEocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgdmFyIGo7XG4gIHZhciBuYWZXO1xuICBmb3IgKGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBsID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGwgPj0gajsgbC0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2xdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBsID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgbCsrO1xuICAgIGlmIChpID49IDApXG4gICAgICBsKys7XG4gICAgYWNjID0gYWNjLmRibHAobCk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQkMSh6ICE9PSAwKTtcbiAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJykge1xuICAgICAgLy8gSiArLSBQXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBKICstIEpcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKHogLSAxKSA+PiAxXSk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHAudHlwZSA9PT0gJ2FmZmluZScgPyBhY2MudG9QKCkgOiBhY2M7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcbiAgcG9pbnRzLFxuICBjb2VmZnMsXG4gIGxlbixcbiAgamFjb2JpYW5SZXN1bHQpIHtcbiAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuICB2YXIgd25kID0gdGhpcy5fd25hZlQyO1xuICB2YXIgbmFmID0gdGhpcy5fd25hZlQzO1xuXG4gIC8vIEZpbGwgYWxsIGFycmF5c1xuICB2YXIgbWF4ID0gMDtcbiAgdmFyIGk7XG4gIHZhciBqO1xuICB2YXIgcDtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKGRlZlcpO1xuICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcbiAgICB3bmRbaV0gPSBuYWZQb2ludHMucG9pbnRzO1xuICB9XG5cbiAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuICAgIHZhciBhID0gaSAtIDE7XG4gICAgdmFyIGIgPSBpO1xuICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuICAgICAgbmFmW2FdID0gZ2V0TkFGKGNvZWZmc1thXSwgd25kV2lkdGhbYV0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBuYWZbYl0gPSBnZXROQUYoY29lZmZzW2JdLCB3bmRXaWR0aFtiXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYl0ubGVuZ3RoLCBtYXgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNvbWIgPSBbXG4gICAgICBwb2ludHNbYV0sIC8qIDEgKi9cbiAgICAgIG51bGwsIC8qIDMgKi9cbiAgICAgIG51bGwsIC8qIDUgKi9cbiAgICAgIHBvaW50c1tiXSwgLyogNyAqL1xuICAgIF07XG5cbiAgICAvLyBUcnkgdG8gYXZvaWQgUHJvamVjdGl2ZSBwb2ludHMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXSk7XG4gICAgICBjb21iWzJdID0gcG9pbnRzW2FdLnRvSigpLm1peGVkQWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gW1xuICAgICAgLTMsIC8qIC0xIC0xICovXG4gICAgICAtMSwgLyogLTEgMCAqL1xuICAgICAgLTUsIC8qIC0xIDEgKi9cbiAgICAgIC03LCAvKiAwIC0xICovXG4gICAgICAwLCAvKiAwIDAgKi9cbiAgICAgIDcsIC8qIDAgMSAqL1xuICAgICAgNSwgLyogMSAtMSAqL1xuICAgICAgMSwgLyogMSAwICovXG4gICAgICAzLCAgLyogMSAxICovXG4gICAgXTtcblxuICAgIHZhciBqc2YgPSBnZXRKU0YoY29lZmZzW2FdLCBjb2VmZnNbYl0pO1xuICAgIG1heCA9IE1hdGgubWF4KGpzZlswXS5sZW5ndGgsIG1heCk7XG4gICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG4gICAgbmFmW2JdID0gbmV3IEFycmF5KG1heCk7XG4gICAgZm9yIChqID0gMDsgaiA8IG1heDsgaisrKSB7XG4gICAgICB2YXIgamEgPSBqc2ZbMF1bal0gfCAwO1xuICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuICAgICAgbmFmW2FdW2pdID0gaW5kZXhbKGphICsgMSkgKiAzICsgKGpiICsgMSldO1xuICAgICAgbmFmW2JdW2pdID0gMDtcbiAgICAgIHduZFthXSA9IGNvbWI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgdG1wID0gdGhpcy5fd25hZlQ0O1xuICBmb3IgKGkgPSBtYXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGsgPSAwO1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgdmFyIHplcm8gPSB0cnVlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHRtcFtqXSA9IG5hZltqXVtpXSB8IDA7XG4gICAgICAgIGlmICh0bXBbal0gIT09IDApXG4gICAgICAgICAgemVybyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCF6ZXJvKVxuICAgICAgICBicmVhaztcbiAgICAgIGsrKztcbiAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGsrKztcbiAgICBhY2MgPSBhY2MuZGJscChrKTtcbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcblxuICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHogPSB0bXBbal07XG4gICAgICBwO1xuICAgICAgaWYgKHogPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgZWxzZSBpZiAoeiA+IDApXG4gICAgICAgIHAgPSB3bmRbal1bKHogLSAxKSA+PiAxXTtcbiAgICAgIGVsc2UgaWYgKHogPCAwKVxuICAgICAgICBwID0gd25kW2pdWygteiAtIDEpID4+IDFdLm5lZygpO1xuXG4gICAgICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgIH1cbiAgfVxuICAvLyBaZXJvaWZ5IHJlZmVyZW5jZXNcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgIHduZFtpXSA9IG51bGw7XG5cbiAgaWYgKGphY29iaWFuUmVzdWx0KVxuICAgIHJldHVybiBhY2M7XG4gIGVsc2VcbiAgICByZXR1cm4gYWNjLnRvUCgpO1xufTtcblxuZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG59XG5CYXNlQ3VydmUuQmFzZVBvaW50ID0gQmFzZVBvaW50O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLnZhbGlkYXRlKHRoaXMpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgYnl0ZXMgPSB1dGlsc18xJDEudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAwKTtcbiAgICBlbHNlIGlmIChieXRlc1swXSA9PT0gMHgwNylcbiAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cbiAgICB2YXIgcmVzID0gIHRoaXMucG9pbnQoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksXG4gICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfSBlbHNlIGlmICgoYnl0ZXNbMF0gPT09IDB4MDIgfHwgYnl0ZXNbMF0gPT09IDB4MDMpICYmXG4gICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50RnJvbVgoYnl0ZXMuc2xpY2UoMSwgMSArIGxlbiksIGJ5dGVzWzBdID09PSAweDAzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWQgPSBmdW5jdGlvbiBlbmNvZGVDb21wcmVzc2VkKGVuYykge1xuICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoY29tcGFjdCkge1xuICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIHggPSB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIGxlbik7XG5cbiAgaWYgKGNvbXBhY3QpXG4gICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuICByZXR1cm4gWyAweDA0IF0uY29uY2F0KHgsIHRoaXMuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgbGVuKSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShlbmMsIGNvbXBhY3QpIHtcbiAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5wcmVjb21wdXRlID0gZnVuY3Rpb24gcHJlY29tcHV0ZShwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcHJlY29tcHV0ZWQgPSB7XG4gICAgZG91YmxlczogbnVsbCxcbiAgICBuYWY6IG51bGwsXG4gICAgYmV0YTogbnVsbCxcbiAgfTtcbiAgcHJlY29tcHV0ZWQubmFmID0gdGhpcy5fZ2V0TkFGUG9pbnRzKDgpO1xuICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG4gIHByZWNvbXB1dGVkLmJldGEgPSB0aGlzLl9nZXRCZXRhKCk7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBwcmVjb21wdXRlZDtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2hhc0RvdWJsZXMgPSBmdW5jdGlvbiBfaGFzRG91YmxlcyhrKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRvdWJsZXMgPSB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG4gIGlmICghZG91YmxlcylcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIGRvdWJsZXMucG9pbnRzLmxlbmd0aCA+PSBNYXRoLmNlaWwoKGsuYml0TGVuZ3RoKCkgKyAxKSAvIGRvdWJsZXMuc3RlcCk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXREb3VibGVzID0gZnVuY3Rpb24gX2dldERvdWJsZXMoc3RlcCwgcG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cbiAgdmFyIGRvdWJsZXMgPSBbIHRoaXMgXTtcbiAgdmFyIGFjYyA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RlcDsgaisrKVxuICAgICAgYWNjID0gYWNjLmRibCgpO1xuICAgIGRvdWJsZXMucHVzaChhY2MpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RlcDogc3RlcCxcbiAgICBwb2ludHM6IGRvdWJsZXMsXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXROQUZQb2ludHMgPSBmdW5jdGlvbiBfZ2V0TkFGUG9pbnRzKHduZCkge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5uYWY7XG5cbiAgdmFyIHJlcyA9IFsgdGhpcyBdO1xuICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG4gIHZhciBkYmwgPSBtYXggPT09IDEgPyBudWxsIDogdGhpcy5kYmwoKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBtYXg7IGkrKylcbiAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuICByZXR1cm4ge1xuICAgIHduZDogd25kLFxuICAgIHBvaW50czogcmVzLFxuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAoaykge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuICAgIHIgPSByLmRibCgpO1xuICByZXR1cm4gcjtcbn07XG5cbnZhciBpbmhlcml0c19icm93c2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge307XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICB9XG4gIH07XG59XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxudmFyIGFzc2VydCQyID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gU2hvcnRDdXJ2ZShjb25mKSB7XG4gIGJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLnRpbnYgPSB0aGlzLnR3by5yZWRJbnZtKCk7XG5cbiAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcbiAgdGhpcy50aHJlZUEgPSB0aGlzLmEuZnJvbVJlZCgpLnN1Yih0aGlzLnApLmNtcG4oLTMpID09PSAwO1xuXG4gIC8vIElmIHRoZSBjdXJ2ZSBpcyBlbmRvbW9ycGhpYywgcHJlY2FsY3VsYXRlIGJldGEgYW5kIGxhbWJkYVxuICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG4gIHRoaXMuX2VuZG9XbmFmVDEgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX2VuZG9XbmFmVDIgPSBuZXcgQXJyYXkoNCk7XG59XG5pbmhlcml0c19icm93c2VyKFNob3J0Q3VydmUsIGJhc2UpO1xudmFyIHNob3J0XzEgPSBTaG9ydEN1cnZlO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG4gIC8vIE5vIGVmZmljaWVudCBlbmRvbW9ycGhpc21cbiAgaWYgKCF0aGlzLnplcm9BIHx8ICF0aGlzLmcgfHwgIXRoaXMubiB8fCB0aGlzLnAubW9kbigzKSAhPT0gMSlcbiAgICByZXR1cm47XG5cbiAgLy8gQ29tcHV0ZSBiZXRhIGFuZCBsYW1iZGEsIHRoYXQgbGFtYmRhICogUCA9IChiZXRhICogUHg7IFB5KVxuICB2YXIgYmV0YTtcbiAgdmFyIGxhbWJkYTtcbiAgaWYgKGNvbmYuYmV0YSkge1xuICAgIGJldGEgPSBuZXcgQk4oY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZXRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLnApO1xuICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuICAgIGJldGEgPSBiZXRhc1swXS5jbXAoYmV0YXNbMV0pIDwgMCA/IGJldGFzWzBdIDogYmV0YXNbMV07XG4gICAgYmV0YSA9IGJldGEudG9SZWQodGhpcy5yZWQpO1xuICB9XG4gIGlmIChjb25mLmxhbWJkYSkge1xuICAgIGxhbWJkYSA9IG5ldyBCTihjb25mLmxhbWJkYSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIC8vIENob29zZSB0aGUgbGFtYmRhIHRoYXQgaXMgbWF0Y2hpbmcgc2VsZWN0ZWQgYmV0YVxuICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG4gICAgaWYgKHRoaXMuZy5tdWwobGFtYmRhc1swXSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCkge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFtYmRhID0gbGFtYmRhc1sxXTtcbiAgICAgIGFzc2VydCQyKHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXMsXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9LFxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gICAgICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gICAgICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICAgICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICAgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICAgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gICAgICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICAgICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHNfYnJvd3NlcihQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcywgeCwgeSwgaXNSZWQpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaiwgcmVkKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuICBpZiAoIXRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm47XG5cbiAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gIGlmIChwcmUgJiYgcHJlLmJldGEpXG4gICAgcmV0dXJuIHByZS5iZXRhO1xuXG4gIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcbiAgaWYgKHByZSkge1xuICAgIHZhciBjdXJ2ZSA9IHRoaXMuY3VydmU7XG4gICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gY3VydmUucG9pbnQocC54LnJlZE11bChjdXJ2ZS5lbmRvLmJldGEpLCBwLnkpO1xuICAgIH07XG4gICAgcHJlLmJldGEgPSBiZXRhO1xuICAgIGJldGEucHJlY29tcHV0ZWQgPSB7XG4gICAgICBiZXRhOiBudWxsLFxuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAoZW5kb011bCksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJldGE7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnkgXTtcblxuICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG4gICAgZG91YmxlczogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG4gICAgICB3bmQ6IHRoaXMucHJlY29tcHV0ZWQubmFmLnduZCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5uYWYucG9pbnRzLnNsaWNlKDEpLFxuICAgIH0sXG4gIH0gXTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaiwgcmVkKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcbiAgICBvYmogPSBKU09OLnBhcnNlKG9iaik7XG4gIHZhciByZXMgPSBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgaWYgKCFvYmpbMl0pXG4gICAgcmV0dXJuIHJlcztcblxuICBmdW5jdGlvbiBvYmoycG9pbnQob2JqKSB7XG4gICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICB9XG5cbiAgdmFyIHByZSA9IG9ialsyXTtcbiAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgIGJldGE6IG51bGwsXG4gICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLmRvdWJsZXMucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcbiAgICB9LFxuICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgfSxcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5mO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBQICsgUCA9IDJQXG4gIGlmICh0aGlzLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIC8vIFAgKyAoLVApID0gT1xuICBpZiAodGhpcy5uZWcoKS5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICAvLyBQICsgUSA9IE9cbiAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYyA9IHRoaXMueS5yZWRTdWIocC55KTtcbiAgaWYgKGMuY21wbigwKSAhPT0gMClcbiAgICBjID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihwLngpLnJlZEludm0oKSk7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngpLnJlZElTdWIocC54KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAyUCA9IE9cbiAgdmFyIHlzMSA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgaWYgKHlzMS5jbXBuKDApID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIHZhciB4MiA9IHRoaXMueC5yZWRTcXIoKTtcbiAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcbiAgdmFyIGMgPSB4Mi5yZWRBZGQoeDIpLnJlZElBZGQoeDIpLnJlZElBZGQoYSkucmVkTXVsKGR5aW52KTtcblxuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54LnJlZEFkZCh0aGlzLngpKTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGsgPSBuZXcgQk4oaywgMTYpO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGVsc2UgaWYgKHRoaXMuX2hhc0RvdWJsZXMoaykpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKFsgdGhpcyBdLCBbIGsgXSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmptdWxBZGQgPSBmdW5jdGlvbiBqbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyLCB0cnVlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgcmV0dXJuIHRoaXMgPT09IHAgfHxcbiAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuICAgICAgICAgICAgICh0aGlzLmluZiB8fCB0aGlzLnguY21wKHAueCkgPT09IDAgJiYgdGhpcy55LmNtcChwLnkpID09PSAwKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcbiAgaWYgKF9wcmVjb21wdXRlICYmIHRoaXMucHJlY29tcHV0ZWQpIHtcbiAgICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAubmVnKCk7XG4gICAgfTtcbiAgICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpLFxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0ogPSBmdW5jdGlvbiB0b0ooKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LCB0aGlzLmN1cnZlLm9uZSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBKUG9pbnQoY3VydmUsIHgsIHksIHopIHtcbiAgYmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2phY29iaWFuJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueSA9IHRoaXMuY3VydmUub25lO1xuICAgIHRoaXMueiA9IG5ldyBCTigwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgdGhpcy56ID0gbmV3IEJOKHosIDE2KTtcbiAgfVxuICBpZiAoIXRoaXMueC5yZWQpXG4gICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnkucmVkKVxuICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy56LnJlZClcbiAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG4gIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG59XG5pbmhlcml0c19icm93c2VyKEpQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5qcG9pbnQgPSBmdW5jdGlvbiBqcG9pbnQoeCwgeSwgeikge1xuICByZXR1cm4gbmV3IEpQb2ludCh0aGlzLCB4LCB5LCB6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudG9QID0gZnVuY3Rpb24gdG9QKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIHppbnYgPSB0aGlzLnoucmVkSW52bSgpO1xuICB2YXIgemludjIgPSB6aW52LnJlZFNxcigpO1xuICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcbiAgdmFyIGF5ID0gdGhpcy55LnJlZE11bCh6aW52MikucmVkTXVsKHppbnYpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KGF4LCBheSk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZygpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpLCB0aGlzLnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMTJNICsgNFMgKyA3QVxuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueC5yZWRNdWwocHoyKTtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueS5yZWRNdWwocHoyLnJlZE11bChwLnopKTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6Mi5yZWRNdWwodGhpcy56KSk7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwocC56KS5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5taXhlZEFkZCA9IGZ1bmN0aW9uIG1peGVkQWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcC50b0ooKTtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDhNICsgM1MgKyA3QVxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciB1MSA9IHRoaXMueDtcbiAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG4gIHZhciBzMSA9IHRoaXMueTtcbiAgdmFyIHMyID0gcC55LnJlZE11bCh6MikucmVkTXVsKHRoaXMueik7XG5cbiAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG4gIGlmIChoLmNtcG4oMCkgPT09IDApIHtcbiAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuICB9XG5cbiAgdmFyIGgyID0gaC5yZWRTcXIoKTtcbiAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cbiAgdmFyIG54ID0gci5yZWRTcXIoKS5yZWRJQWRkKGgzKS5yZWRJU3ViKHYpLnJlZElTdWIodik7XG4gIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG4gIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcbiAgaWYgKHBvdyA9PT0gMClcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAoIXBvdylcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICB2YXIgaTtcbiAgaWYgKHRoaXMuY3VydmUuemVyb0EgfHwgdGhpcy5jdXJ2ZS50aHJlZUEpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKVxuICAgICAgciA9IHIuZGJsKCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICAvLyAxTSArIDJTICsgMUEgKyBOICogKDRTICsgNU0gKyA4QSlcbiAgLy8gTiA9IDEgPT4gNk0gKyA2UyArIDlBXG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuICB2YXIgdGludiA9IHRoaXMuY3VydmUudGludjtcblxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgLy8gUmV1c2UgcmVzdWx0c1xuICB2YXIganlkID0gankucmVkQWRkKGp5KTtcbiAgZm9yIChpID0gMDsgaSA8IHBvdzsgaSsrKSB7XG4gICAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuICAgIHZhciBqeWQ0ID0ganlkMi5yZWRTcXIoKTtcbiAgICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcbiAgICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gICAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG4gICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcbiAgICBkbnkgPSBkbnkucmVkSUFkZChkbnkpLnJlZElTdWIoanlkNCk7XG4gICAgdmFyIG56ID0ganlkLnJlZE11bChqeik7XG4gICAgaWYgKGkgKyAxIDwgcG93KVxuICAgICAgano0ID0gano0LnJlZE11bChqeWQ0KTtcblxuICAgIGp4ID0gbng7XG4gICAganogPSBuejtcbiAgICBqeWQgPSBkbnk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS50aHJlZUEpXG4gICAgcmV0dXJuIHRoaXMuX3RocmVlRGJsKCk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5fZGJsKCk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE0QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAgIC8vIFQgPSBNIF4gMiAtIDIqU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cbiAgICAvLyA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMipZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOS1sXG4gICAgLy8gMk0gKyA1UyArIDEzQVxuXG4gICAgLy8gQSA9IFgxXjJcbiAgICB2YXIgYSA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBCID0gWTFeMlxuICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIEMgPSBCXjJcbiAgICB2YXIgYyA9IGIucmVkU3FyKCk7XG4gICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuICAgIHZhciBkID0gdGhpcy54LnJlZEFkZChiKS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYyk7XG4gICAgZCA9IGQucmVkSUFkZChkKTtcbiAgICAvLyBFID0gMyAqIEFcbiAgICB2YXIgZSA9IGEucmVkQWRkKGEpLnJlZElBZGQoYSk7XG4gICAgLy8gRiA9IEVeMlxuICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuICAgIC8vIDggKiBDXG4gICAgdmFyIGM4ID0gYy5yZWRJQWRkKGMpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcblxuICAgIC8vIFgzID0gRiAtIDIgKiBEXG4gICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcbiAgICAvLyBZMyA9IEUgKiAoRCAtIFgzKSAtIDggKiBDXG4gICAgbnkgPSBlLnJlZE11bChkLnJlZElTdWIobngpKS5yZWRJU3ViKGM4KTtcbiAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG4gICAgbnogPSB0aGlzLnkucmVkTXVsKHRoaXMueik7XG4gICAgbnogPSBuei5yZWRJQWRkKG56KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNUFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhXG4gICAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpLnJlZElBZGQodGhpcy5jdXJ2ZS5hKTtcbiAgICAvLyBUID0gTV4yIC0gMiAqIFNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIgKiBZMVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sI2RvdWJsaW5nLWRibC0yMDAxLWJcbiAgICAvLyAzTSArIDVTXG5cbiAgICAvLyBkZWx0YSA9IFoxXjJcbiAgICB2YXIgZGVsdGEgPSB0aGlzLnoucmVkU3FyKCk7XG4gICAgLy8gZ2FtbWEgPSBZMV4yXG4gICAgdmFyIGdhbW1hID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIGJldGEgPSBYMSAqIGdhbW1hXG4gICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcbiAgICAvLyBhbHBoYSA9IDMgKiAoWDEgLSBkZWx0YSkgKiAoWDEgKyBkZWx0YSlcbiAgICB2YXIgYWxwaGEgPSB0aGlzLngucmVkU3ViKGRlbHRhKS5yZWRNdWwodGhpcy54LnJlZEFkZChkZWx0YSkpO1xuICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcbiAgICAvLyBYMyA9IGFscGhhXjIgLSA4ICogYmV0YVxuICAgIHZhciBiZXRhNCA9IGJldGEucmVkSUFkZChiZXRhKTtcbiAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuICAgIHZhciBiZXRhOCA9IGJldGE0LnJlZEFkZChiZXRhNCk7XG4gICAgbnggPSBhbHBoYS5yZWRTcXIoKS5yZWRJU3ViKGJldGE4KTtcbiAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnopLnJlZFNxcigpLnJlZElTdWIoZ2FtbWEpLnJlZElTdWIoZGVsdGEpO1xuICAgIC8vIFkzID0gYWxwaGEgKiAoNCAqIGJldGEgLSBYMykgLSA4ICogZ2FtbWFeMlxuICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgbnkgPSBhbHBoYS5yZWRNdWwoYmV0YTQucmVkSVN1YihueCkpLnJlZElTdWIoZ2dhbW1hOCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl9kYmwgPSBmdW5jdGlvbiBfZGJsKCkge1xuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICAvLyA0TSArIDZTICsgMTBBXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICB2YXIgangyID0gangucmVkU3FyKCk7XG4gIHZhciBqeTIgPSBqeS5yZWRTcXIoKTtcblxuICB2YXIgYyA9IGp4Mi5yZWRBZGQoangyKS5yZWRJQWRkKGp4MikucmVkSUFkZChhLnJlZE11bChqejQpKTtcblxuICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG4gIGp4ZDQgPSBqeGQ0LnJlZElBZGQoanhkNCk7XG4gIHZhciB0MSA9IGp4ZDQucmVkTXVsKGp5Mik7XG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgdmFyIHQyID0gdDEucmVkSVN1YihueCk7XG5cbiAgdmFyIGp5ZDggPSBqeTIucmVkU3FyKCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuICB2YXIgbnogPSBqeS5yZWRBZGQoankpLnJlZE11bChqeik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50cnBsID0gZnVuY3Rpb24gdHJwbCgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbCN0cmlwbGluZy10cGwtMjAwNy1ibFxuICAvLyA1TSArIDEwUyArIC4uLlxuXG4gIC8vIFhYID0gWDFeMlxuICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIFlZID0gWTFeMlxuICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gIC8vIFpaID0gWjFeMlxuICB2YXIgenogPSB0aGlzLnoucmVkU3FyKCk7XG4gIC8vIFlZWVkgPSBZWV4yXG4gIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gIC8vIE0gPSAzICogWFggKyBhICogWloyOyBhID0gMFxuICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gIC8vIE1NID0gTV4yXG4gIHZhciBtbSA9IG0ucmVkU3FyKCk7XG4gIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG4gIHZhciBlID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgZSA9IGUucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZElTdWIobW0pO1xuICAvLyBFRSA9IEVeMlxuICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuICAvLyBUID0gMTYqWVlZWVxuICB2YXIgdCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgdCA9IHQucmVkSUFkZCh0KTtcbiAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG4gIHZhciB1ID0gbS5yZWRJQWRkKGUpLnJlZFNxcigpLnJlZElTdWIobW0pLnJlZElTdWIoZWUpLnJlZElTdWIodCk7XG4gIC8vIFgzID0gNCAqIChYMSAqIEVFIC0gNCAqIFlZICogVSlcbiAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHl5dTQgPSB5eXU0LnJlZElBZGQoeXl1NCk7XG4gIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIG54ID0gbngucmVkSUFkZChueCk7XG4gIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuICB2YXIgbnkgPSB0aGlzLnkucmVkTXVsKHUucmVkTXVsKHQucmVkSVN1Yih1KSkucmVkSVN1YihlLnJlZE11bChlZSkpKTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgbnkgPSBueS5yZWRJQWRkKG55KTtcbiAgLy8gWjMgPSAoWjEgKyBFKV4yIC0gWlogLSBFRVxuICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG4gIGsgPSBuZXcgQk4oaywga2Jhc2UpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKHApIHtcbiAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgcmV0dXJuIHRoaXMuZXEocC50b0ooKSk7XG5cbiAgaWYgKHRoaXMgPT09IHApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgLy8geDEgKiB6Ml4yID09IHgyICogejFeMlxuICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIGlmICh0aGlzLngucmVkTXVsKHB6MikucmVkSVN1YihwLngucmVkTXVsKHoyKSkuY21wbigwKSAhPT0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuICB2YXIgejMgPSB6Mi5yZWRNdWwodGhpcy56KTtcbiAgdmFyIHB6MyA9IHB6Mi5yZWRNdWwocC56KTtcbiAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5lcVhUb1AgPSBmdW5jdGlvbiBlcVhUb1AoeCkge1xuICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG4gIHZhciByeCA9IHgudG9SZWQodGhpcy5jdXJ2ZS5yZWQpLnJlZE11bCh6cyk7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh6cyk7XG4gIGZvciAoOzspIHtcbiAgICB4Yy5pYWRkKHRoaXMuY3VydmUubik7XG4gICAgaWYgKHhjLmNtcCh0aGlzLmN1cnZlLnApID49IDApXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByeC5yZWRJQWRkKHQpO1xuICAgIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgSlBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgejogJyArIHRoaXMuei50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICAvLyBYWFggVGhpcyBjb2RlIGFzc3VtZXMgdGhhdCB6ZXJvIGlzIGFsd2F5cyB6ZXJvIGluIHJlZFxuICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG59O1xuXG52YXIgY3VydmVfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlID0gZXhwb3J0cztcblxuY3VydmUuYmFzZSA9IGJhc2U7XG5jdXJ2ZS5zaG9ydCA9IHNob3J0XzE7XG5jdXJ2ZS5tb250ID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9tb250KSovKG51bGwpO1xuY3VydmUuZWR3YXJkcyA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWR3YXJkcykqLyhudWxsKTtcbn0pO1xuXG52YXIgY3VydmVzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xuXG5cblxuXG5cbnZhciBhc3NlcnQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnR5cGUgPT09ICdzaG9ydCcpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLnNob3J0KG9wdGlvbnMpO1xuICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG4gIGFzc2VydCh0aGlzLmcudmFsaWRhdGUoKSwgJ0ludmFsaWQgY3VydmUnKTtcbiAgYXNzZXJ0KHRoaXMuZy5tdWwodGhpcy5uKS5pc0luZmluaXR5KCksICdJbnZhbGlkIGN1cnZlLCBHKk4gIT0gTycpO1xufVxuY3VydmVzLlByZXNldEN1cnZlID0gUHJlc2V0Q3VydmU7XG5cbmZ1bmN0aW9uIGRlZmluZUN1cnZlKG5hbWUsIG9wdGlvbnMpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUHJlc2V0Q3VydmUob3B0aW9ucyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGN1cnZlLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY3VydmU7XG4gICAgfSxcbiAgfSk7XG59XG5cbmRlZmluZUN1cnZlKCdwMTkyJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AxOTInLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgOTlkZWY4MzYgMTQ2YmM5YjEgYjRkMjI4MzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuICAgICcwNzE5MmI5NSBmZmM4ZGE3OCA2MzEwMTFlZCA2YjI0Y2RkNSA3M2Y5NzdhMSAxZTc5NDgxMScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDIyNCcsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZScsXG4gIGI6ICdiNDA1MGE4NSAwYzA0YjNhYiBmNTQxMzI1NiA1MDQ0YjBiNyBkN2JmZDhiYSAyNzBiMzk0MyAyMzU1ZmZiNCcsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdiNzBlMGNiZCA2YmI0YmY3ZiAzMjEzOTBiOSA0YTAzYzFkMyA1NmMyMTEyMiAzNDMyODBkNiAxMTVjMWQyMScsXG4gICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDI1NicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc1YWM2MzVkOCBhYTNhOTNlNyBiM2ViYmQ1NSA3Njk4ODZiYyA2NTFkMDZiMCBjYzUzYjBmNiAzYmNlM2MzZSAyN2QyNjA0YicsXG4gIG46ICdmZmZmZmZmZiAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBiY2U2ZmFhZCBhNzE3OWU4NCBmM2I5Y2FjMiBmYzYzMjU1MScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc2YjE3ZDFmMiBlMTJjNDI0NyBmOGJjZTZlNSA2M2E0NDBmMiA3NzAzN2Q4MSAyZGViMzNhMCBmNGExMzk0NSBkODk4YzI5NicsXG4gICAgJzRmZTM0MmUyIGZlMWE3ZjliIDhlZTdlYjRhIDdjMGY5ZTE2IDJiY2UzMzU3IDZiMzE1ZWNlIGNiYjY0MDY4IDM3YmY1MWY1JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDM4NCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmMnLFxuICBiOiAnYjMzMTJmYTcgZTIzZWU3ZTQgOTg4ZTA1NmIgZTNmODJkMTkgMTgxZDljNmUgZmU4MTQxMTIgMDMxNDA4OGYgJyArXG4gICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBjNzYzNGQ4MSAnICtcbiAgICAgJ2Y0MzcyZGRmIDU4MWEwZGIyIDQ4YjBhNzdhIGVjZWMxOTZhIGNjYzUyOTczJyxcbiAgaGFzaDogaGFzaC5zaGEzODQsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2FhODdjYTIyIGJlOGIwNTM3IDhlYjFjNzFlIGYzMjBhZDc0IDZlMWQzYjYyIDhiYTc5Yjk4IDU5Zjc0MWUwIDgyNTQyYTM4ICcgK1xuICAgICc1NTAyZjI1ZCBiZjU1Mjk2YyAzYTU0NWUzOCA3Mjc2MGFiNycsXG4gICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuICAgICcwYTYwYjFjZSAxZDdlODE5ZCA3YTQzMWQ3YyA5MGVhMGU1ZicsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcbiAgICAgJzk5YjMxNWYzIGI4YjQ4OTkxIDhlZjEwOWUxIDU2MTkzOTUxIGVjN2U5MzdiIDE2NTJjMGJkICcgK1xuICAgICAnM2JiMWJmMDcgMzU3M2RmODggM2QyYzM0ZjEgZWY0NTFmZDQgNmI1MDNmMDAnLFxuICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYSA1MTg2ODc4MyBiZjJmOTY2YiA3ZmNjMDE0OCAnICtcbiAgICAgJ2Y3MDlhNWQwIDNiYjVjOWI4IDg5OWM0N2FlIGJiNmZiNzFlIDkxMzg2NDA5JyxcbiAgaGFzaDogaGFzaC5zaGE1MTIsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzAwMDAwMGM2IDg1OGUwNmI3IDA0MDRlOWNkIDllM2VjYjY2IDIzOTViNDQyIDljNjQ4MTM5ICcgK1xuICAgICcwNTNmYjUyMSBmODI4YWY2MCA2YjRkM2RiYSBhMTRiNWU3NyBlZmU3NTkyOCBmZTFkYzEyNyAnICtcbiAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuICAgICcwMDAwMDExOCAzOTI5NmE3OCA5YTNiYzAwNCA1YzhhNWZiNCAyYzdkMWJkOSA5OGY1NDQ0OSAnICtcbiAgICAnNTc5YjQ0NjggMTdhZmJkMTcgMjczZTY2MmMgOTdlZTcyOTkgNWVmNDI2NDAgYzU1MGI5MDEgJyArXG4gICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnY3VydmUyNTUxOScsIHtcbiAgdHlwZTogJ21vbnQnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJzc2ZDA2JyxcbiAgYjogJzEnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc5JyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcbiAgdHlwZTogJ2Vkd2FyZHMnLFxuICBwcmltZTogJ3AyNTUxOScsXG4gIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcbiAgYTogJy0xJyxcbiAgYzogJzEnLFxuICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG4gIGQ6ICc1MjAzNmNlZTJiNmZmZTczIDhjYzc0MDc5Nzc3OWU4OTggMDA3MDBhNGQ0MTQxZDhhYiA3NWViNGRjYTEzNTk3OGEzJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMjE2OTM2ZDNjZDZlNTNmZWMwYTRlMjMxZmRkNmRjNWM2OTJjYzc2MDk1MjVhN2IyYzk1NjJkNjA4ZjI1ZDUxYScsXG5cbiAgICAvLyA0LzVcbiAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCcsXG4gIF0sXG59KTtcblxudmFyIHByZTtcbnRyeSB7XG4gIHByZSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vcHJlY29tcHV0ZWQvc2VjcDI1NmsxKSovKG51bGwpLmNyYXNoKCk7XG59IGNhdGNoIChlKSB7XG4gIHByZSA9IHVuZGVmaW5lZDtcbn1cblxuZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdrMjU2JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcbiAgYTogJzAnLFxuICBiOiAnNycsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG4gIGg6ICcxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG5cbiAgLy8gUHJlY29tcHV0ZWQgZW5kb21vcnBoaXNtXG4gIGJldGE6ICc3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyxcbiAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG4gIGJhc2lzOiBbXG4gICAge1xuICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICAgIGI6ICctZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnLFxuICAgIH0sXG4gICAge1xuICAgICAgYTogJzExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcsXG4gICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgIH0sXG4gIF0sXG5cbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcsXG4gICAgJzQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnLFxuICAgIHByZSxcbiAgXSxcbn0pO1xufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBub25jZSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLm5vbmNlLCBvcHRpb25zLm5vbmNlRW5jIHx8ICdoZXgnKTtcbiAgdmFyIHBlcnMgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbnZhciBobWFjRHJiZyA9IEhtYWNEUkJHO1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKSB7XG4gIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuICB0aGlzLksgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgdGhpcy5WID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5LW2ldID0gMHgwMDtcbiAgICB0aGlzLlZbaV0gPSAweDAxO1xuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHNlZWQpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl9obWFjID0gZnVuY3Rpb24gaG1hYygpIHtcbiAgcmV0dXJuIG5ldyBoYXNoLmhtYWModGhpcy5oYXNoLCB0aGlzLkspO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuICB2YXIga21hYyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG4gIGlmIChzZWVkKVxuICAgIGttYWMgPSBrbWFjLnVwZGF0ZShzZWVkKTtcbiAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICBpZiAoIXNlZWQpXG4gICAgcmV0dXJuO1xuXG4gIHRoaXMuSyA9IHRoaXMuX2htYWMoKVxuICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxuICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUucmVzZWVkID0gZnVuY3Rpb24gcmVzZWVkKGVudHJvcHksIGVudHJvcHlFbmMsIGFkZCwgYWRkRW5jKSB7XG4gIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG4gIGlmICh0eXBlb2YgZW50cm9weUVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW50cm9weUVuYztcbiAgICBlbnRyb3B5RW5jID0gbnVsbDtcbiAgfVxuXG4gIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyk7XG5cbiAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuICB0aGlzLl91cGRhdGUoZW50cm9weS5jb25jYXQoYWRkIHx8IFtdKSk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiBnZW5lcmF0ZShsZW4sIGVuYywgYWRkLCBhZGRFbmMpIHtcbiAgaWYgKHRoaXMuX3Jlc2VlZCA+IHRoaXMucmVzZWVkSW50ZXJ2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuICAvLyBPcHRpb25hbCBlbmNvZGluZ1xuICBpZiAodHlwZW9mIGVuYyAhPT0gJ3N0cmluZycpIHtcbiAgICBhZGRFbmMgPSBhZGQ7XG4gICAgYWRkID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cblxuICAvLyBPcHRpb25hbCBhZGRpdGlvbmFsIGRhdGFcbiAgaWYgKGFkZCkge1xuICAgIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG4gICAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIH1cblxuICB2YXIgdGVtcCA9IFtdO1xuICB3aGlsZSAodGVtcC5sZW5ndGggPCBsZW4pIHtcbiAgICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG4gIH1cblxuICB2YXIgcmVzID0gdGVtcC5zbGljZSgwLCBsZW4pO1xuICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgdGhpcy5fcmVzZWVkKys7XG4gIHJldHVybiB1dGlsc18xLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG52YXIgYXNzZXJ0JDMgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG52YXIga2V5ID0gS2V5UGFpcjtcblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlYywgcHViLCBlbmMpIHtcbiAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHB1YjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwdWI6IHB1YixcbiAgICBwdWJFbmM6IGVuYyxcbiAgfSk7XG59O1xuXG5LZXlQYWlyLmZyb21Qcml2YXRlID0gZnVuY3Rpb24gZnJvbVByaXZhdGUoZWMsIHByaXYsIGVuYykge1xuICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG4gICAgcmV0dXJuIHByaXY7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHJpdjogcHJpdixcbiAgICBwcml2RW5jOiBlbmMsXG4gIH0pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cbiAgaWYgKHB1Yi5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnSW52YWxpZCBwdWJsaWMga2V5JyB9O1xuICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgaXMgbm90IGEgcG9pbnQnIH07XG4gIGlmICghcHViLm11bCh0aGlzLmVjLmN1cnZlLm4pLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG4gIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgcmVhc29uOiBudWxsIH07XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG4gIC8vIGNvbXBhY3QgaXMgb3B0aW9uYWwgYXJndW1lbnRcbiAgaWYgKHR5cGVvZiBjb21wYWN0ID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGNvbXBhY3Q7XG4gICAgY29tcGFjdCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXRoaXMucHViKVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5nLm11bCh0aGlzLnByaXYpO1xuXG4gIGlmICghZW5jKVxuICAgIHJldHVybiB0aGlzLnB1YjtcblxuICByZXR1cm4gdGhpcy5wdWIuZW5jb2RlKGVuYywgY29tcGFjdCk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRoaXMucHJpdi50b1N0cmluZygxNiwgMik7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5wcml2O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuICB0aGlzLnByaXYgPSBuZXcgQk4oa2V5LCBlbmMgfHwgMTYpO1xuXG4gIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuICAvLyBpbiBmaXhlZCBtdWx0aXBsaWNhdGlvbiBtZXRob2RcbiAgdGhpcy5wcml2ID0gdGhpcy5wcml2LnVtb2QodGhpcy5lYy5jdXJ2ZS5uKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiBfaW1wb3J0UHVibGljKGtleSwgZW5jKSB7XG4gIGlmIChrZXkueCB8fCBrZXkueSkge1xuICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cbiAgICAvLyBXZWllcnN0cmFzcy9FZHdhcmRzIHBvaW50cyBvbiB0aGUgb3RoZXIgaGFuZCBoYXZlIGJvdGggYHhgIGFuZFxuICAgIC8vIGB5YCBjb29yZGluYXRlcy5cbiAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcbiAgICAgIGFzc2VydCQzKGtleS54LCAnTmVlZCB4IGNvb3JkaW5hdGUnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ3Nob3J0JyB8fFxuICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcbiAgICAgIGFzc2VydCQzKGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgaWYoIXB1Yi52YWxpZGF0ZSgpKSB7XG4gICAgYXNzZXJ0JDMocHViLnZhbGlkYXRlKCksICdwdWJsaWMgcG9pbnQgbm90IHZhbGlkYXRlZCcpO1xuICB9XG4gIHJldHVybiBwdWIubXVsKHRoaXMucHJpdikuZ2V0WCgpO1xufTtcblxuLy8gRUNEU0FcbktleVBhaXIucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywgZW5jLCBvcHRpb25zKSB7XG4gIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlKSB7XG4gIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcbiAgICAgICAgICcgcHViOiAnICsgKHRoaXMucHViICYmIHRoaXMucHViLmluc3BlY3QoKSkgKyAnID4nO1xufTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG52YXIgYXNzZXJ0JDQgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0JDQob3B0aW9ucy5yICYmIG9wdGlvbnMucywgJ1NpZ25hdHVyZSB3aXRob3V0IHIgb3IgcycpO1xuICB0aGlzLnIgPSBuZXcgQk4ob3B0aW9ucy5yLCAxNik7XG4gIHRoaXMucyA9IG5ldyBCTihvcHRpb25zLnMsIDE2KTtcbiAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG4gIGVsc2VcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG59XG52YXIgc2lnbmF0dXJlID0gU2lnbmF0dXJlO1xuXG5mdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgdGhpcy5wbGFjZSA9IDA7XG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcbiAgdmFyIGluaXRpYWwgPSBidWZbcC5wbGFjZSsrXTtcbiAgaWYgKCEoaW5pdGlhbCAmIDB4ODApKSB7XG4gICAgcmV0dXJuIGluaXRpYWw7XG4gIH1cbiAgdmFyIG9jdGV0TGVuID0gaW5pdGlhbCAmIDB4ZjtcblxuICAvLyBJbmRlZmluaXRlIGxlbmd0aCBvciBvdmVyZmxvd1xuICBpZiAob2N0ZXRMZW4gPT09IDAgfHwgb2N0ZXRMZW4gPiA0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwLCBvZmYgPSBwLnBsYWNlOyBpIDwgb2N0ZXRMZW47IGkrKywgb2ZmKyspIHtcbiAgICB2YWwgPDw9IDg7XG4gICAgdmFsIHw9IGJ1ZltvZmZdO1xuICAgIHZhbCA+Pj49IDA7XG4gIH1cblxuICAvLyBMZWFkaW5nIHplcm9lc1xuICBpZiAodmFsIDw9IDB4N2YpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwLnBsYWNlID0gb2ZmO1xuICByZXR1cm4gdmFsO1xufVxuXG5mdW5jdGlvbiBybVBhZGRpbmcoYnVmKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGggLSAxO1xuICB3aGlsZSAoIWJ1ZltpXSAmJiAhKGJ1ZltpICsgMV0gJiAweDgwKSAmJiBpIDwgbGVuKSB7XG4gICAgaSsrO1xuICB9XG4gIGlmIChpID09PSAwKSB7XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuICByZXR1cm4gYnVmLnNsaWNlKGkpO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLl9pbXBvcnRERVIgPSBmdW5jdGlvbiBfaW1wb3J0REVSKGRhdGEsIGVuYykge1xuICBkYXRhID0gdXRpbHNfMSQxLnRvQXJyYXkoZGF0YSwgZW5jKTtcbiAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAobGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoKGxlbiArIHAucGxhY2UpICE9PSBkYXRhLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBybGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAocmxlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcbiAgcC5wbGFjZSArPSBybGVuO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzbGVuID0gZ2V0TGVuZ3RoKGRhdGEsIHApO1xuICBpZiAoc2xlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuICBpZiAoclswXSA9PT0gMCkge1xuICAgIGlmIChyWzFdICYgMHg4MCkge1xuICAgICAgciA9IHIuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlYWRpbmcgemVyb2VzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChzWzBdID09PSAwKSB7XG4gICAgaWYgKHNbMV0gJiAweDgwKSB7XG4gICAgICBzID0gcy5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnIgPSBuZXcgQk4ocik7XG4gIHRoaXMucyA9IG5ldyBCTihzKTtcbiAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuICBpZiAobGVuIDwgMHg4MCkge1xuICAgIGFyci5wdXNoKGxlbik7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBvY3RldHMgPSAxICsgKE1hdGgubG9nKGxlbikgLyBNYXRoLkxOMiA+Pj4gMyk7XG4gIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuICB3aGlsZSAoLS1vY3RldHMpIHtcbiAgICBhcnIucHVzaCgobGVuID4+PiAob2N0ZXRzIDw8IDMpKSAmIDB4ZmYpO1xuICB9XG4gIGFyci5wdXNoKGxlbik7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcbiAgdmFyIHIgPSB0aGlzLnIudG9BcnJheSgpO1xuICB2YXIgcyA9IHRoaXMucy50b0FycmF5KCk7XG5cbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoclswXSAmIDB4ODApXG4gICAgciA9IFsgMCBdLmNvbmNhdChyKTtcbiAgLy8gUGFkIHZhbHVlc1xuICBpZiAoc1swXSAmIDB4ODApXG4gICAgcyA9IFsgMCBdLmNvbmNhdChzKTtcblxuICByID0gcm1QYWRkaW5nKHIpO1xuICBzID0gcm1QYWRkaW5nKHMpO1xuXG4gIHdoaWxlICghc1swXSAmJiAhKHNbMV0gJiAweDgwKSkge1xuICAgIHMgPSBzLnNsaWNlKDEpO1xuICB9XG4gIHZhciBhcnIgPSBbIDB4MDIgXTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuICBhcnIgPSBhcnIuY29uY2F0KHIpO1xuICBhcnIucHVzaCgweDAyKTtcbiAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuICB2YXIgYmFja0hhbGYgPSBhcnIuY29uY2F0KHMpO1xuICB2YXIgcmVzID0gWyAweDMwIF07XG4gIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG4gIHJlcyA9IHJlcy5jb25jYXQoYmFja0hhbGYpO1xuICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZShyZXMsIGVuYyk7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxudmFyIHJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xudmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuZnVuY3Rpb24gRUMob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRUMpKVxuICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cbiAgLy8gU2hvcnRjdXQgYGVsbGlwdGljLmVjKGN1cnZlLW5hbWUpYFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgYXNzZXJ0JDUoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnZlc18xLCBvcHRpb25zKSxcbiAgICAgICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBjdXJ2ZXNfMVtvcHRpb25zXTtcbiAgfVxuXG4gIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgY3VydmVzXzEuUHJlc2V0Q3VydmUpXG4gICAgb3B0aW9ucyA9IHsgY3VydmU6IG9wdGlvbnMgfTtcblxuICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLm5oID0gdGhpcy5uLnVzaHJuKDEpO1xuICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cbiAgLy8gUG9pbnQgb24gY3VydmVcbiAgdGhpcy5nID0gb3B0aW9ucy5jdXJ2ZS5nO1xuICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICAvLyBIYXNoIGZvciBmdW5jdGlvbiBmb3IgRFJCR1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2ggfHwgb3B0aW9ucy5jdXJ2ZS5oYXNoO1xufVxudmFyIGVjID0gRUM7XG5cbkVDLnByb3RvdHlwZS5rZXlQYWlyID0gZnVuY3Rpb24ga2V5UGFpcihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcga2V5KHRoaXMsIG9wdGlvbnMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21Qcml2YXRlID0gZnVuY3Rpb24ga2V5RnJvbVByaXZhdGUocHJpdiwgZW5jKSB7XG4gIHJldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4ga2V5LmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmdlbktleVBhaXIgPSBmdW5jdGlvbiBnZW5LZXlQYWlyKG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgICBlbnRyb3B5OiBvcHRpb25zLmVudHJvcHkgfHwgcmFuZCh0aGlzLmhhc2guaG1hY1N0cmVuZ3RoKSxcbiAgICBlbnRyb3B5RW5jOiBvcHRpb25zLmVudHJvcHkgJiYgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICd1dGY4JyxcbiAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKSxcbiAgfSk7XG5cbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIG5zMiA9IHRoaXMubi5zdWIobmV3IEJOKDIpKTtcbiAgZm9yICg7Oykge1xuICAgIHZhciBwcml2ID0gbmV3IEJOKGRyYmcuZ2VuZXJhdGUoYnl0ZXMpKTtcbiAgICBpZiAocHJpdi5jbXAobnMyKSA+IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHByaXYuaWFkZG4oMSk7XG4gICAgcmV0dXJuIHRoaXMua2V5RnJvbVByaXZhdGUocHJpdik7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS5fdHJ1bmNhdGVUb04gPSBmdW5jdGlvbiBfdHJ1bmNhdGVUb04obXNnLCB0cnVuY09ubHkpIHtcbiAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG4gIGlmIChkZWx0YSA+IDApXG4gICAgbXNnID0gbXNnLnVzaHJuKGRlbHRhKTtcbiAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIG1zZy5zdWIodGhpcy5uKTtcbiAgZWxzZVxuICAgIHJldHVybiBtc2c7XG59O1xuXG5FQy5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBrZXksIGVuYywgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0gZW5jO1xuICAgIGVuYyA9IG51bGw7XG4gIH1cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fTtcblxuICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcblxuICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgYmtleSA9IGtleS5nZXRQcml2YXRlKCkudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuICB2YXIgbm9uY2UgPSBtc2cudG9BcnJheSgnYmUnLCBieXRlcyk7XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGhtYWNEcmJnKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgZW50cm9weTogYmtleSxcbiAgICBub25jZTogbm9uY2UsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG4gIH0pO1xuXG4gIC8vIE51bWJlciBvZiBieXRlcyB0byBnZW5lcmF0ZVxuICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgQk4oMSkpO1xuXG4gIGZvciAodmFyIGl0ZXIgPSAwOyA7IGl0ZXIrKykge1xuICAgIHZhciBrID0gb3B0aW9ucy5rID9cbiAgICAgIG9wdGlvbnMuayhpdGVyKSA6XG4gICAgICBuZXcgQk4oZHJiZy5nZW5lcmF0ZSh0aGlzLm4uYnl0ZUxlbmd0aCgpKSk7XG4gICAgayA9IHRoaXMuX3RydW5jYXRlVG9OKGssIHRydWUpO1xuICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcCA9IHRoaXMuZy5tdWwoayk7XG4gICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwWCA9IGtwLmdldFgoKTtcbiAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG4gICAgaWYgKHIuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcbiAgICBzID0gcy51bW9kKHRoaXMubik7XG4gICAgaWYgKHMuY21wbigwKSA9PT0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIHJlY292ZXJ5UGFyYW0gPSAoa3AuZ2V0WSgpLmlzT2RkKCkgPyAxIDogMCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGtwWC5jbXAocikgIT09IDAgPyAyIDogMCk7XG5cbiAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuICAgIGlmIChvcHRpb25zLmNhbm9uaWNhbCAmJiBzLmNtcCh0aGlzLm5oKSA+IDApIHtcbiAgICAgIHMgPSB0aGlzLm4uc3ViKHMpO1xuICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgc2lnbmF0dXJlKHsgcjogciwgczogcywgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSQxLCBrZXksIGVuYykge1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuICBrZXkgPSB0aGlzLmtleUZyb21QdWJsaWMoa2V5LCBlbmMpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsICdoZXgnKTtcblxuICAvLyBQZXJmb3JtIHByaW1pdGl2ZSB2YWx1ZXMgdmFsaWRhdGlvblxuICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlJDEucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHA7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlJDEsIGosIGVuYykge1xuICBhc3NlcnQkNSgoMyAmIGopID09PSBqLCAnVGhlIHJlY292ZXJ5IHBhcmFtIGlzIG1vcmUgdGhhbiB0d28gYml0cycpO1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG5cbiAgdmFyIG4gPSB0aGlzLm47XG4gIHZhciBlID0gbmV3IEJOKG1zZyk7XG4gIHZhciByID0gc2lnbmF0dXJlJDEucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlJDEuci5pbnZtKG4pO1xuICB2YXIgczEgPSBuLnN1YihlKS5tdWwockludikudW1vZChuKTtcbiAgdmFyIHMyID0gcy5tdWwockludikudW1vZChuKTtcblxuICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcbiAgLy8gICAgICAgICAgICAgICBRID0gcl4tMSAoc1IgKyAtZUcpXG4gIHJldHVybiB0aGlzLmcubXVsQWRkKHMxLCByLCBzMik7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2V0S2V5UmVjb3ZlcnlQYXJhbSA9IGZ1bmN0aW9uKGUsIHNpZ25hdHVyZSQxLCBRLCBlbmMpIHtcbiAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuICBpZiAoc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcbiAgICByZXR1cm4gc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUkMSwgaSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKFFwcmltZS5lcShRKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG59O1xuXG52YXIgZWxsaXB0aWNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGVsbGlwdGljID0gZXhwb3J0cztcblxuZWxsaXB0aWMudmVyc2lvbiA9IC8qUmljTW9vOmV0aGVycyoveyB2ZXJzaW9uOiBcIjYuNS40XCIgfS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSB1dGlsc18xJDE7XG5lbGxpcHRpYy5yYW5kID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqLyhmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpOyB9KTtcbmVsbGlwdGljLmN1cnZlID0gY3VydmVfMTtcbmVsbGlwdGljLmN1cnZlcyA9IGN1cnZlc18xO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gZWM7XG5lbGxpcHRpYy5lZGRzYSA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vZWxsaXB0aWMvZWRkc2EpKi8obnVsbCk7XG59KTtcblxudmFyIEVDJDEgPSBlbGxpcHRpY18xLmVjO1xuXG5leHBvcnQgeyBFQyQxIGFzIEVDIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbGxpcHRpYy5qcy5tYXBcbiIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzaWduaW5nLWtleS81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBFQyB9IGZyb20gXCIuL2VsbGlwdGljXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4RGF0YUxlbmd0aCwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgc3BsaXRTaWduYXR1cmUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmxldCBfY3VydmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3VydmUoKSB7XG4gICAgaWYgKCFfY3VydmUpIHtcbiAgICAgICAgX2N1cnZlID0gbmV3IEVDKFwic2VjcDI1NmsxXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX2N1cnZlO1xufVxuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIGhleGxpZnkocHJpdmF0ZUtleSkpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aCh0aGlzLnByaXZhdGVLZXkpICE9PSAzMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJpdmF0ZSBrZXlcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1sgUkVEQUNURUQgXV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmluZ0tleVwiLCB0cnVlKTtcbiAgICB9XG4gICAgX2FkZFBvaW50KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHAwID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KHRoaXMucHVibGljS2V5KSk7XG4gICAgICAgIGNvbnN0IHAxID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KG90aGVyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwMC5wdWIuYWRkKHAxLnB1YikuZW5jb2RlQ29tcHJlc3NlZChcImhleFwiKTtcbiAgICB9XG4gICAgc2lnbkRpZ2VzdChkaWdlc3QpIHtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gYXJyYXlpZnkoZGlnZXN0KTtcbiAgICAgICAgaWYgKGRpZ2VzdEJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihkaWdlc3RCeXRlcywgeyBjYW5vbmljYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzcGxpdFNpZ25hdHVyZSh7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxcbiAgICAgICAgICAgIHI6IGhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnIudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICAgICAgICBzOiBoZXhaZXJvUGFkKFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcktleSkge1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3Qgb3RoZXJLZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KGNvbXB1dGVQdWJsaWNLZXkob3RoZXJLZXkpKSk7XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKFwiMHhcIiArIGtleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLCAzMik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25pbmdLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25pbmdLZXkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBycyA9IHsgcjogYXJyYXlpZnkoc2lnLnIpLCBzOiBhcnJheWlmeShzaWcucykgfTtcbiAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KGFycmF5aWZ5KGRpZ2VzdCksIHJzLCBzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoa2V5KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkoYnl0ZXMpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgIGlmICghY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHB1YmxpYyBvciBwcml2YXRlIGtleVwiLCBcImtleVwiLCBcIltSRURBQ1RFRF1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleENvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0J5dGVzTGlrZSwgc3BsaXRTaWduYXR1cmUsIHN0cmlwWmVyb3MsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgY2hlY2tQcm9wZXJ0aWVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJMUCBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmxwXCI7XG5pbXBvcnQgeyBjb21wdXRlUHVibGljS2V5LCByZWNvdmVyUHVibGljS2V5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgdmFyIFRyYW5zYWN0aW9uVHlwZXM7XG4oZnVuY3Rpb24gKFRyYW5zYWN0aW9uVHlwZXMpIHtcbiAgICBUcmFuc2FjdGlvblR5cGVzW1RyYW5zYWN0aW9uVHlwZXNbXCJsZWdhY3lcIl0gPSAwXSA9IFwibGVnYWN5XCI7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wiZWlwMjkzMFwiXSA9IDFdID0gXCJlaXAyOTMwXCI7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wiZWlwMTU1OVwiXSA9IDJdID0gXCJlaXAxNTU5XCI7XG59KShUcmFuc2FjdGlvblR5cGVzIHx8IChUcmFuc2FjdGlvblR5cGVzID0ge30pKTtcbjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFplcm87XG4gICAgfVxuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG59XG4vLyBMZWdhY3kgVHJhbnNhY3Rpb24gRmllbGRzXG5jb25zdCB0cmFuc2FjdGlvbkZpZWxkcyA9IFtcbiAgICB7IG5hbWU6IFwibm9uY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNQcmljZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcImdhc0xpbWl0XCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwidG9cIiwgbGVuZ3RoOiAyMCB9LFxuICAgIHsgbmFtZTogXCJ2YWx1ZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcImRhdGFcIiB9LFxuXTtcbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHR5cGU6IHRydWUsIHZhbHVlOiB0cnVlXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGNvbXB1dGVQdWJsaWNLZXkoa2V5KTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGhleERhdGFTbGljZShwdWJsaWNLZXksIDEpKSwgMTIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhyZWNvdmVyUHVibGljS2V5KGFycmF5aWZ5KGRpZ2VzdCksIHNpZ25hdHVyZSkpO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3RyaXBaZXJvcyhCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgbmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBuYW1lKSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IChzdG9yYWdlS2V5cyB8fCBbXSkubWFwKChzdG9yYWdlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhleERhdGFMZW5ndGgoc3RvcmFnZUtleSkgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWNjZXNzIGxpc3Qgc3RvcmFnZUtleVwiLCBgYWNjZXNzTGlzdFske2FkZHJ9OiR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYWNjZXNzIGxpc3QgZXhwZWN0ZWQgdG8gYmUgWyBhZGRyZXNzLCBzdG9yYWdlS2V5c1tdIF1cIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleHBsaWNpdCBnYXNQcmljZSwgbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlXG4gICAgLy8gRUlQLTE1NTkgZmVlczsgb3RoZXJ3aXNlIHRoZXkgbWF5IG5vdCB1bmRlcnN0YW5kIHdoYXQgdGhleVxuICAgIC8vIHRoaW5rIHRoZXkgYXJlIHNldHRpbmcgaW4gdGVybXMgb2YgZmVlLlxuICAgIGlmICh0cmFuc2FjdGlvbi5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGdhc1ByaWNlID0gQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24uZ2FzUHJpY2UpO1xuICAgICAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgfHwgMCk7XG4gICAgICAgIGlmICghZ2FzUHJpY2UuZXEobWF4RmVlUGVyR2FzKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc21hdGNoIEVJUC0xNTU5IGdhc1ByaWNlICE9IG1heEZlZVBlckdhc1wiLCBcInR4XCIsIHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZSwgbWF4RmVlUGVyR2FzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0cmFuc2FjdGlvbi50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHJhbnNhY3Rpb24udG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0cmFuc2FjdGlvbi5kYXRhIHx8IFwiMHhcIiksXG4gICAgICAgIChmb3JtYXRBY2Nlc3NMaXN0KHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgfHwgW10pKVxuICAgIF07XG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBzaWcgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4Q29uY2F0KFtcIjB4MDJcIiwgUkxQLmVuY29kZShmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChbXCIweDAxXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9ucyBhbmQgRUlQLTE1NVxuZnVuY3Rpb24gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzKTtcbiAgICBjb25zdCByYXcgPSBbXTtcbiAgICB0cmFuc2FjdGlvbkZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZEluZm8pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdHJhbnNhY3Rpb25bZmllbGRJbmZvLm5hbWVdIHx8IChbXSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGZpZWxkSW5mby5udW1lcmljKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhleFBhZCA9IFwibGVmdFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXJyYXlpZnkoaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykpO1xuICAgICAgICAvLyBGaXhlZC13aWR0aCBmaWVsZFxuICAgICAgICBpZiAoZmllbGRJbmZvLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhcmlhYmxlLXdpZHRoICh3aXRoIGEgbWF4aW11bSlcbiAgICAgICAgaWYgKGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3RyaXBaZXJvcyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gZmllbGRJbmZvLm1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByYXcucHVzaChoZXhsaWZ5KHZhbHVlKSk7XG4gICAgfSk7XG4gICAgbGV0IGNoYWluSWQgPSAwO1xuICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbi5jaGFpbklkXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpZ25hdHVyZSAmJiAhaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSAmJiBzaWduYXR1cmUudiA+IDI4KSB7XG4gICAgICAgIC8vIE5vIGNoYWluSWQgcHJvdmlkZWQsIGJ1dCB0aGUgc2lnbmF0dXJlIGlzIHNpZ25pbmcgd2l0aCBFSVAtMTU1OyBkZXJpdmUgY2hhaW5JZFxuICAgICAgICBjaGFpbklkID0gTWF0aC5mbG9vcigoc2lnbmF0dXJlLnYgLSAzNSkgLyAyKTtcbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wdXNoKGhleGxpZnkoY2hhaW5JZCkpOyAvLyBAVE9ETzogaGV4VmFsdWU/XG4gICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgfVxuICAgIC8vIFJlcXVlc3RpbmcgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gUkxQLmVuY29kZShyYXcpO1xuICAgIH1cbiAgICAvLyBUaGUgc3BsaXRTaWduYXR1cmUgd2lsbCBlbnN1cmUgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIHJlY292ZXJ5UGFyYW0gaW4gdGhlXG4gICAgLy8gY2FzZSB0aGF0IHRoZSBzaWduVHJhbnNhY3Rpb24gZnVuY3Rpb24gb25seSBhZGRzIGEgdi5cbiAgICBjb25zdCBzaWcgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIC8vIFdlIHB1c2hlZCBhIGNoYWluSWQgYW5kIG51bGwgciwgcyBvbiBmb3IgaGFzaGluZyBvbmx5OyByZW1vdmUgdGhvc2VcbiAgICBsZXQgdiA9IDI3ICsgc2lnLnJlY292ZXJ5UGFyYW07XG4gICAgaWYgKGNoYWluSWQgIT09IDApIHtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgdiArPSBjaGFpbklkICogMiArIDg7XG4gICAgICAgIC8vIElmIGFuIEVJUC0xNTUgdiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseTsgbWF5YmUgX3ZzKSB3YXMgcHJvdmlkZWQsIGNoZWNrIGl0IVxuICAgICAgICBpZiAoc2lnLnYgPiAyOCAmJiBzaWcudiAhPT0gdikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWcudiAhPT0gdikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgIH1cbiAgICByYXcucHVzaChoZXhsaWZ5KHYpKTtcbiAgICByYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5yKSkpO1xuICAgIHJhdy5wdXNoKHN0cmlwWmVyb3MoYXJyYXlpZnkoc2lnLnMpKSk7XG4gICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIC8vIExlZ2FjeSBhbmQgRUlQLTE1NSBUcmFuc2FjdGlvbnNcbiAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PSBudWxsIHx8IHRyYW5zYWN0aW9uLnR5cGUgPT09IDApIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVudHlwZWQgdHJhbnNhY3Rpb25zIGRvIG5vdCBzdXBwb3J0IGFjY2Vzc0xpc3Q7IGluY2x1ZGUgdHlwZTogMVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLy8gVHlwZWQgVHJhbnNhY3Rpb25zIChFSVAtMjcxOClcbiAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3RyYW5zYWN0aW9uLnR5cGV9YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInNlcmlhbGl6ZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogdHJhbnNhY3Rpb24udHlwZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMsIHNlcmlhbGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlY2lkID0gaGFuZGxlTnVtYmVyKGZpZWxkc1swXSkudG9OdW1iZXIoKTtcbiAgICAgICAgaWYgKHJlY2lkICE9PSAwICYmIHJlY2lkICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVjaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHgudiA9IHJlY2lkO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdiBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcInZcIiwgZmllbGRzWzBdKTtcbiAgICB9XG4gICAgdHguciA9IGhleFplcm9QYWQoZmllbGRzWzFdLCAzMik7XG4gICAgdHgucyA9IGhleFplcm9QYWQoZmllbGRzWzJdLCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0ga2VjY2FrMjU2KHNlcmlhbGl6ZSh0eCkpO1xuICAgICAgICB0eC5mcm9tID0gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCB7IHI6IHR4LnIsIHM6IHR4LnMsIHJlY292ZXJ5UGFyYW06IHR4LnYgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IFJMUC5kZWNvZGUocGF5bG9hZC5zbGljZSgxKSk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDEyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbXBvbmVudCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcInBheWxvYWRcIiwgaGV4bGlmeShwYXlsb2FkKSk7XG4gICAgfVxuICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKTtcbiAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMV0pLnRvTnVtYmVyKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzRdKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzZdKSxcbiAgICAgICAgZGF0YTogdHJhbnNhY3Rpb25bN10sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb25bOF0pLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9IGtlY2NhazI1NihwYXlsb2FkKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIHRyYW5zYWN0aW9uLnNsaWNlKDkpLCBfc2VyaWFsaXplRWlwMTU1OSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDggJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls1XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzZdLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzddKVxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTI5MzAgVHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9IGtlY2NhazI1NihwYXlsb2FkKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIHRyYW5zYWN0aW9uLnNsaWNlKDgpLCBfc2VyaWFsaXplRWlwMjkzMCk7XG4gICAgcmV0dXJuIHR4O1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9ucyBhbmQgRUlQLTE1NVxuZnVuY3Rpb24gX3BhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA5ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gNikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByYXcgdHJhbnNhY3Rpb25cIiwgXCJyYXdUcmFuc2FjdGlvblwiLCByYXdUcmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzNdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzVdLFxuICAgICAgICBjaGFpbklkOiAwXG4gICAgfTtcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdHgudiA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uWzZdKS50b051bWJlcigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gQFRPRE86IFdoYXQgbWFrZXMgc25lc2UgdG8gZG8/IFRoZSB2IGlzIHRvbyBiaWdcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5yID0gaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls3XSwgMzIpO1xuICAgIHR4LnMgPSBoZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzhdLCAzMik7XG4gICAgaWYgKEJpZ051bWJlci5mcm9tKHR4LnIpLmlzWmVybygpICYmIEJpZ051bWJlci5mcm9tKHR4LnMpLmlzWmVybygpKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHR4LnY7XG4gICAgICAgIHR4LnYgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU2lnbmVkIFRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSBNYXRoLmZsb29yKCh0eC52IC0gMzUpIC8gMik7XG4gICAgICAgIGlmICh0eC5jaGFpbklkIDwgMCkge1xuICAgICAgICAgICAgdHguY2hhaW5JZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlY292ZXJ5UGFyYW0gPSB0eC52IC0gMjc7XG4gICAgICAgIGNvbnN0IHJhdyA9IHRyYW5zYWN0aW9uLnNsaWNlKDAsIDYpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICAgICAgcmF3LnB1c2goaGV4bGlmeSh0eC5jaGFpbklkKSk7XG4gICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJlY292ZXJ5UGFyYW0gLT0gdHguY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGtlY2NhazI1NihSTFAuZW5jb2RlKHJhdykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiBoZXhsaWZ5KHR4LnIpLCBzOiBoZXhsaWZ5KHR4LnMpLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICB0eC50eXBlID0gbnVsbDtcbiAgICByZXR1cm4gdHg7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2UocmF3VHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBwYXlsb2FkID0gYXJyYXlpZnkocmF3VHJhbnNhY3Rpb24pO1xuICAgIC8vIExlZ2FjeSBhbmQgRUlQLTE1NSBUcmFuc2FjdGlvbnNcbiAgICBpZiAocGF5bG9hZFswXSA+IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZShwYXlsb2FkKTtcbiAgICB9XG4gICAgLy8gVHlwZWQgVHJhbnNhY3Rpb24gKEVJUC0yNzE4KVxuICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3BhcnNlRWlwMjkzMChwYXlsb2FkKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVpcDE1NTkocGF5bG9hZCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3BheWxvYWRbMF19YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInBhcnNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiBwYXlsb2FkWzBdXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhLnB1c2godGV4dERhdGEuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheWlmeShkYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGRhdGEgPSBhcnJheWlmeShkYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIndlYi81LjcuMVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKGhyZWYsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLFxuICAgICAgICAgICAgaGVhZGVyczogKG9wdGlvbnMuaGVhZGVycyB8fCB7fSksXG4gICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBGZXRjaFNldHVwICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSBcImNvcnNcIjsgLy8gbm8tY29ycywgY29ycywgKnNhbWUtb3JpZ2luXG4gICAgICAgICAgICByZXF1ZXN0LmNhY2hlID0gXCJuby1jYWNoZVwiOyAvLyAqZGVmYXVsdCwgbm8tY2FjaGUsIHJlbG9hZCwgZm9yY2UtY2FjaGUsIG9ubHktaWYtY2FjaGVkXG4gICAgICAgICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gXCJzYW1lLW9yaWdpblwiOyAvLyBpbmNsdWRlLCAqc2FtZS1vcmlnaW4sIG9taXRcbiAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBcImZvbGxvd1wiOyAvLyBtYW51YWwsICpmb2xsb3csIGVycm9yXG4gICAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gXCJjbGllbnRcIjsgLy8gbm8tcmVmZXJyZXIsICpjbGllbnRcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChvcHRpb25zLmZldGNoT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gb3B0aW9ucy5mZXRjaE9wdGlvbnM7XG4gICAgICAgICAgICBpZiAob3B0cy5tb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5tb2RlID0gKG9wdHMubW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5jYWNoZSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSAob3B0cy5jYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSAob3B0cy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWRpcmVjdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSAob3B0cy5yZWRpcmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5yZWZlcnJlcikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBvcHRzLnJlZmVycmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaHJlZiwgcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgocmVzcG9uc2UuaGVhZGVycykua2V5cykoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBib2R5OiBhcnJheWlmeShuZXcgVWludDhBcnJheShib2R5KSksXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlY29kZSBhcyBiYXNlNjREZWNvZGUsIGVuY29kZSBhcyBiYXNlNjRFbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZTY0XCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBnZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmxcIjtcbmZ1bmN0aW9uIHN0YWxsZXIoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBib2R5aWZ5KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHR5cGUgJiYgKHR5cGUuc3BsaXQoXCIvXCIpWzBdID09PSBcInRleHRcIiB8fCB0eXBlLnNwbGl0KFwiO1wiKVswXS50cmltKCkgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB1bnBlcmNlbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdG9VdGY4Qnl0ZXModmFsdWUucmVwbGFjZSgvJShbMC05YS1mXVswLTlhLWZdKS9naSwgKGFsbCwgY29kZSkgPT4ge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH0pKTtcbn1cbi8vIFRoaXMgQVBJIGlzIHN0aWxsIGEgd29yayBpbiBwcm9ncmVzczsgdGhlIGZ1dHVyZSBjaGFuZ2VzIHdpbGwgbGlrZWx5IGJlOlxuLy8gLSBDb25uZWN0aW9uSW5mbyA9PiBGZXRjaERhdGFSZXF1ZXN0PFQgPSBhbnk+XG4vLyAtIEZldGNoRGF0YVJlcXVlc3QuYm9keT8gPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgeyBjb250ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5IH1cbi8vICAgLSBJZiBzdHJpbmcgPT4gdGV4dC9wbGFpbiwgVWludDhBcnJheSA9PiBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0gKGlmIGNvbnRlbnQtdHlwZSB1bnNwZWNpZmllZClcbi8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5wcm9jZXNzRnVuYyA9IChib2R5OiBVaW50OEFycmF5LCByZXNwb25zZTogRmV0Y2hEYXRhUmVzcG9uc2UpID0+IFRcbi8vIEZvciB0aGlzIHJlYXNvbiwgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW50ZXJuYWwgdW50aWwgdGhlIEFQSSBpcyBmaW5hbGl6ZWRcbmV4cG9ydCBmdW5jdGlvbiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sIGJvZHksIHByb2Nlc3NGdW5jKSB7XG4gICAgLy8gSG93IG1hbnkgdGltZXMgdG8gcmV0cnkgaW4gdGhlIGV2ZW50IG9mIGEgdGhyb3R0bGVcbiAgICBjb25zdCBhdHRlbXB0TGltaXQgPSAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgIT0gbnVsbCkgPyBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgOiAxMjtcbiAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKGF0dGVtcHRMaW1pdCA+IDAgJiYgKGF0dGVtcHRMaW1pdCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgbGltaXRcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlTGltaXRcIiwgYXR0ZW1wdExpbWl0KTtcbiAgICBjb25zdCB0aHJvdHRsZUNhbGxiYWNrID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVDYWxsYmFjayA6IG51bGwpO1xuICAgIGNvbnN0IHRocm90dGxlU2xvdEludGVydmFsID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAoY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpID8gY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbCA6IDEwMCk7XG4gICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0aHJvdHRsZVNsb3RJbnRlcnZhbCA+IDAgJiYgKHRocm90dGxlU2xvdEludGVydmFsICUgMSkgPT09IDApLCBcImludmFsaWQgY29ubmVjdGlvbiB0aHJvdHRsZSBzbG90IGludGVydmFsXCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbFwiLCB0aHJvdHRsZVNsb3RJbnRlcnZhbCk7XG4gICAgY29uc3QgZXJyb3JQYXNzVGhyb3VnaCA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikgPyAhIShjb25uZWN0aW9uLmVycm9yUGFzc1Rocm91Z2gpIDogZmFsc2UpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBsZXQgdXJsID0gbnVsbDtcbiAgICAvLyBAVE9ETzogQWxsb3cgQ29ubmVjdGlvbkluZm8gdG8gb3ZlcnJpZGUgc29tZSBvZiB0aGVzZSB2YWx1ZXNcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgfTtcbiAgICBsZXQgYWxsb3czMDQgPSBmYWxzZTtcbiAgICBsZXQgdGltZW91dCA9IDIgKiA2MCAqIDEwMDA7XG4gICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdXJsID0gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoY29ubmVjdGlvbiA9PSBudWxsIHx8IGNvbm5lY3Rpb24udXJsID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIFVSTFwiLCBcImNvbm5lY3Rpb24udXJsXCIsIGNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGNvbm5lY3Rpb24udXJsO1xuICAgICAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uLnRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIGNvbm5lY3Rpb24udGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBjb25uZWN0aW9uLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29ubmVjdGlvbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB7IGtleToga2V5LCB2YWx1ZTogU3RyaW5nKGNvbm5lY3Rpb24uaGVhZGVyc1trZXldKSB9O1xuICAgICAgICAgICAgICAgIGlmIChbXCJpZi1ub25lLW1hdGNoXCIsIFwiaWYtbW9kaWZpZWQtc2luY2VcIl0uaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvdzMwNCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuYWxsb3dHemlwID0gISFjb25uZWN0aW9uLmFsbG93R3ppcDtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24udXNlciAhPSBudWxsICYmIGNvbm5lY3Rpb24ucGFzc3dvcmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHVybC5zdWJzdHJpbmcoMCwgNikgIT09IFwiaHR0cHM6XCIgJiYgY29ubmVjdGlvbi5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImJhc2ljIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIGEgc2VjdXJlIGh0dHBzIHVybFwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwidXJsXCIsIHVybDogdXJsLCB1c2VyOiBjb25uZWN0aW9uLnVzZXIsIHBhc3N3b3JkOiBcIltSRURBQ1RFRF1cIiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSBjb25uZWN0aW9uLnVzZXIgKyBcIjpcIiArIGNvbm5lY3Rpb24ucGFzc3dvcmQ7XG4gICAgICAgICAgICBoZWFkZXJzW1wiYXV0aG9yaXphdGlvblwiXSA9IHtcbiAgICAgICAgICAgICAgICBrZXk6IFwiQXV0aG9yaXphdGlvblwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBcIkJhc2ljIFwiICsgYmFzZTY0RW5jb2RlKHRvVXRmOEJ5dGVzKGF1dGhvcml6YXRpb24pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5za2lwRmV0Y2hTZXR1cCAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNraXBGZXRjaFNldHVwID0gISFjb25uZWN0aW9uLnNraXBGZXRjaFNldHVwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmZldGNoT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZldGNoT3B0aW9ucyA9IHNoYWxsb3dDb3B5KGNvbm5lY3Rpb24uZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFteOzpdKik/KDtiYXNlNjQpPywoLiopJFwiLCBcImlcIik7XG4gICAgY29uc3QgZGF0YU1hdGNoID0gKCh1cmwpID8gdXJsLm1hdGNoKHJlRGF0YSkgOiBudWxsKTtcbiAgICBpZiAoZGF0YU1hdGNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogXCJPS1wiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJjb250ZW50LXR5cGVcIjogKGRhdGFNYXRjaFsxXSB8fCBcInRleHQvcGxhaW5cIikgfSxcbiAgICAgICAgICAgICAgICBib2R5OiAoZGF0YU1hdGNoWzJdID8gYmFzZTY0RGVjb2RlKGRhdGFNYXRjaFszXSkgOiB1bnBlcmNlbnQoZGF0YU1hdGNoWzNdKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3BvbnNlLmJvZHksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvY2Vzc2luZyByZXNwb25zZSBlcnJvclwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoZGF0YU1hdGNoWzFdLCBkYXRhTWF0Y2hbMl0pLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogbnVsbCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm9keSkge1xuICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0geyBrZXk6IFwiQ29udGVudC1UeXBlXCIsIHZhbHVlOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPSB7IGtleTogXCJDb250ZW50LUxlbmd0aFwiLCB2YWx1ZTogU3RyaW5nKGJvZHkubGVuZ3RoKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZsYXRIZWFkZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgZmxhdEhlYWRlcnNbaGVhZGVyLmtleV0gPSBoZWFkZXIudmFsdWU7XG4gICAgfSk7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gZmxhdEhlYWRlcnM7XG4gICAgY29uc3QgcnVubmluZ1RpbWVvdXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0XCIsIExvZ2dlci5lcnJvcnMuVElNRU9VVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHByb21pc2UsIGNhbmNlbCB9O1xuICAgIH0pKCk7XG4gICAgY29uc3QgcnVubmluZ0ZldGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgYXR0ZW1wdExpbWl0OyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geWllbGQgZ2V0VXJsKHVybCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0IDwgYXR0ZW1wdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAxIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlZGlyZWN0aW9uOyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBhYnNvbHV0ZSBsb2NhdGFpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSBcIkdFVFwiICYmIGxvY2F0aW9uLm1hdGNoKC9eaHR0cHM6LykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFjay1vZmYgdGhyb3R0bGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cnlBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocm90dGxlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSB5aWVsZCB0aHJvdHRsZUNhbGxiYWNrKGF0dGVtcHQsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cnlBZ2Fpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhbGwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUFmdGVyKSA9PT0gXCJzdHJpbmdcIiAmJiByZXRyeUFmdGVyLm1hdGNoKC9eWzEtOV1bMC05XSokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gcGFyc2VJbnQocmV0cnlBZnRlcikgKiAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSB0aHJvdHRsZVNsb3RJbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgNDI5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbGVyKHN0YWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBib2R5ID0gcmVzcG9uc2UuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3czMDQgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZXJyb3JQYXNzVGhyb3VnaCAmJiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShib2R5LCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwcm9jZXNzRnVuYyhib2R5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgcHJvY2Vzc0Z1bmMgdG8gdHJpZ2dlciBhIHRocm90dGxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IudGhyb3R0bGVSZXRyeSAmJiBhdHRlbXB0IDwgYXR0ZW1wdExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyeUFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3R0bGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHlpZWxkIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUFnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aHJvdHRsZVNsb3RJbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbGVyKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvY2Vzc2luZyByZXNwb25zZSBlcnJvclwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoYm9keSwgKChyZXNwb25zZS5oZWFkZXJzKSA/IHJlc3BvbnNlLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYWQgYSBwcm9jZXNzRnVuYywgaXQgZWl0aGVyIHJldHVybmVkIGEgVCBvciB0aHJldyBhYm92ZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJib2R5XCIgaXMgbm93IGEgVWludDhBcnJheS5cbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImZhaWxlZCByZXNwb25zZVwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtydW5uaW5nVGltZW91dC5wcm9taXNlLCBydW5uaW5nRmV0Y2hdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEpzb24oY29ubmVjdGlvbiwganNvbiwgcHJvY2Vzc0Z1bmMpIHtcbiAgICBsZXQgcHJvY2Vzc0pzb25GdW5jID0gKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZSh0b1V0ZjhTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBKU09OXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3VsdCwgcmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvLyBJZiB3ZSBoYXZlIGpzb24gdG8gc2VuZCwgd2UgbXVzdFxuICAgIC8vIC0gYWRkIGNvbnRlbnQtdHlwZSBvZiBhcHBsaWNhdGlvbi9qc29uICh1bmxlc3MgYWxyZWFkeSBvdmVycmlkZGVuKVxuICAgIC8vIC0gY29udmVydCB0aGUganNvbiB0byBieXRlc1xuICAgIGxldCBib2R5ID0gbnVsbDtcbiAgICBpZiAoanNvbiAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSB0b1V0ZjhCeXRlcyhqc29uKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29ubmVjdGlvbiB3aXRoIHRoZSBjb250ZW50LXR5cGUgc2V0IGZvciBKU09OXG4gICAgICAgIGNvbnN0IHVwZGF0ZWQgPSAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikgPyAoeyB1cmw6IGNvbm5lY3Rpb24gfSkgOiBzaGFsbG93Q29weShjb25uZWN0aW9uKTtcbiAgICAgICAgaWYgKHVwZGF0ZWQuaGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgaGFzQ29udGVudFR5cGUgPSAoT2JqZWN0LmtleXModXBkYXRlZC5oZWFkZXJzKS5maWx0ZXIoKGspID0+IChrLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIpKS5sZW5ndGgpICE9PSAwO1xuICAgICAgICAgICAgaWYgKCFoYXNDb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IHNoYWxsb3dDb3B5KHVwZGF0ZWQuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnMgPSB7IFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbiA9IHVwZGF0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sIGJvZHksIHByb2Nlc3NKc29uRnVuYyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcG9sbChmdW5jLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHNoYWxsb3dDb3B5KG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmZsb29yID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucy5mbG9vciA9IDA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNlaWxpbmcgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmNlaWxpbmcgPSAxMDAwMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaW50ZXJ2YWwgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmludGVydmFsID0gMjUwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgY2FuY2VsIHdhcyBzdWNjZXNzZnVsLiBVbnN1Y2Nlc3NmdWwgY2FuY2VsIG1lYW5zIHdlJ3JlIGFscmVhZHkgZG9uZS5cbiAgICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRpbWVvdXRcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0cnlMaW1pdCA9IG9wdGlvbnMucmV0cnlMaW1pdDtcbiAgICAgICAgbGV0IGF0dGVtcHQgPSAwO1xuICAgICAgICBmdW5jdGlvbiBjaGVjaygpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHJlc3VsdCwgb3IgYXJlIGFsbG93ZWQgbnVsbCB0aGVuIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlUG9sbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VQb2xsLm9uY2UoXCJwb2xsXCIsIGNoZWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5vbmNlQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlQmxvY2sub25jZShcImJsb2NrXCIsIGNoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBleHBvbmVudGlhbCBiYWNrLW9mZiAodXAgdG8gMTBzKSBvdXIgbmV4dCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPiByZXRyeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwicmV0cnkgbGltaXQgcmVhY2hlZFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVvdXQgPSBvcHRpb25zLmludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA8IG9wdGlvbnMuZmxvb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmZsb29yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0ID4gb3B0aW9ucy5jZWlsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy5jZWlsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2hlY2ssIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrKCk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3QtcHJvdmlkZXIvNS43LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgRGVzY3JpcHRpb24sIGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vL2V4cG9ydCB0eXBlIENhbGxUcmFuc2FjdGlvbmFibGUgPSB7XG4vLyAgICBjYWxsKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuLy99O1xuZXhwb3J0IGNsYXNzIEZvcmtFdmVudCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNGb3JrRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZvcmtFdmVudCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJsb2NrRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0hhc2gsIGV4cGlyeSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJsb2NrSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNCbG9ja0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogYmxvY2tIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoaGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiaGFzaFwiLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGhhc2g6IGhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJlZm9yZUhhc2gsIGFmdGVySGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYmVmb3JlSGFzaFwiLCBiZWZvcmVIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGFmdGVySGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYWZ0ZXJIYXNoXCIsIGFmdGVySGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgX2lzVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJlZm9yZUhhc2g6IGJlZm9yZUhhc2gsXG4gICAgICAgICAgICBhZnRlckhhc2g6IGFmdGVySGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRlZCBBYnN0cmFjdHNcbmV4cG9ydCBjbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2ssIGdhc1ByaWNlIH0gPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2s6IHRoaXMuZ2V0QmxvY2soXCJsYXRlc3RcIiksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IHRoaXMuZ2V0R2FzUHJpY2UoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoeSBpcyB0aGlzIG5vdyBmYWlsaW5nIG9uIENhbGF2ZXJhcz9cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBsYXN0QmFzZUZlZVBlckdhcyA9IG51bGwsIG1heEZlZVBlckdhcyA9IG51bGwsIG1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gY29tcHV0ZSB0aGlzIG1vcmUgYWNjdXJhdGVseSBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBmb3JtdWxhIFwiY2hlY2sgaWYgdGhlIGJhc2UgZmVlIGlzIGNvcnJlY3RcIi5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTU1OVxuICAgICAgICAgICAgICAgIGxhc3RCYXNlRmVlUGVyR2FzID0gYmxvY2suYmFzZUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKFwiMTUwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzLm11bCgyKS5hZGQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbGFzdEJhc2VGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGdhc1ByaWNlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvblwiXG4gICAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcbiAgICByZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUHJvdmlkZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1Byb3ZpZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKipcbiAqIHZhciBiYXNleCA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGJhc2VkIG9uIGJhc2UteC4gVGhlIG1haW4gcmVhc29uIHRvXG4gKiBkZXZpYXRlIHdhcyB0byBwcmV2ZW50IHRoZSBkZXBlbmRlbmN5IG9mIEJ1ZmZlci5cbiAqXG4gKiBDb250cmlidXRvcnM6XG4gKlxuICogYmFzZS14IGVuY29kaW5nXG4gKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcbiAqIE9yaWdpbmFsbHkgd3JpdHRlbiBieSBNaWtlIEhlYXJuIGZvciBCaXRjb2luSlxuICogQ29weXJpZ2h0IChjKSAyMDExIEdvb2dsZSBJbmNcbiAqIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcbiAqIE1lcmdlZCBCdWZmZXIgcmVmYWN0b3JpbmdzIGZyb20gYmFzZTU4LW5hdGl2ZSBieSBTdGVwaGVuIFBhaXJcbiAqIENvcHlyaWdodCAoYykgMjAxMyBCaXRQYXkgSW5jXG4gKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAqIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKi9cbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5leHBvcnQgY2xhc3MgQmFzZVgge1xuICAgIGNvbnN0cnVjdG9yKGFscGhhYmV0KSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxwaGFiZXRcIiwgYWxwaGFiZXQpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImJhc2VcIiwgYWxwaGFiZXQubGVuZ3RoKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWxwaGFiZXRNYXBcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9sZWFkZXJcIiwgYWxwaGFiZXQuY2hhckF0KDApKTtcbiAgICAgICAgLy8gcHJlLWNvbXB1dGUgbG9va3VwIHRhYmxlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2FscGhhYmV0TWFwW2FscGhhYmV0LmNoYXJBdChpKV0gPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBsZXQgc291cmNlID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZ2l0cyA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjYXJyeSA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGlnaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gZGlnaXRzW2pdIDw8IDg7XG4gICAgICAgICAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgICAgICBkaWdpdHMucHVzaChjYXJyeSAlIHRoaXMuYmFzZSk7XG4gICAgICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgLyB0aGlzLmJhc2UpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyaW5nID0gXCJcIjtcbiAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IHNvdXJjZVtrXSA9PT0gMCAmJiBrIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuX2xlYWRlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb252ZXJ0IGRpZ2l0cyB0byBhIHN0cmluZ1xuICAgICAgICBmb3IgKGxldCBxID0gZGlnaXRzLmxlbmd0aCAtIDE7IHEgPj0gMDsgLS1xKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hbHBoYWJldFtkaWdpdHNbcV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIGRlY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVzID0gW107XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGJ5dGUgPSB0aGlzLl9hbHBoYWJldE1hcFt2YWx1ZVtpXV07XG4gICAgICAgICAgICBpZiAoYnl0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIHRoaXMuYmFzZSArIFwiIGNoYXJhY3RlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYXJyeSA9IGJ5dGU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJ5dGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiB0aGlzLmJhc2U7XG4gICAgICAgICAgICAgICAgYnl0ZXNbal0gPSBjYXJyeSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChjYXJyeSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyB2YWx1ZVtrXSA9PT0gdGhpcy5fbGVhZGVyICYmIGsgPCB2YWx1ZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJ5dGVzLnJldmVyc2UoKSkpO1xuICAgIH1cbn1cbmNvbnN0IEJhc2UzMiA9IG5ldyBCYXNlWChcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3XCIpO1xuY29uc3QgQmFzZTU4ID0gbmV3IEJhc2VYKFwiMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5elwiKTtcbmV4cG9ydCB7IEJhc2UzMiwgQmFzZTU4IH07XG4vL2NvbnNvbGUubG9nKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKVxuLy9jb25zb2xlLmxvZyhCYXNlNTguZW5jb2RlKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKSlcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCBIYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoZXMuanMubWFwIiwiLyoqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbmRyZXcgUmFmZmVuc3BlcmdlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogVGhpcyBpcyBhIG5lYXIgY2FyYm9uLWNvcHkgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSAobGluayBiZWxvdykgd2l0aCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwaW5ncyBhZGRlZCBhbmQgYSBmZXcgdHdlYWtzIHRvIG1ha2UgaXQgRVMzLWNvbXBhdGlibGUuXG4gKlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzXG4gKi9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZWhuYW1tb2RpL3BvbHlmaWxsL2Jsb2IvbWFzdGVyL2FycmF5LnBvbHlmaWxsLmpzXG5mdW5jdGlvbiBmbGF0KGFycmF5LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgIGRlcHRoID0gMTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgZm9yRWFjaCA9IHJlc3VsdC5mb3JFYWNoO1xuICAgIGNvbnN0IGZsYXREZWVwID0gZnVuY3Rpb24gKGFyciwgZGVwdGgpIHtcbiAgICAgICAgZm9yRWFjaC5jYWxsKGFyciwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgaWYgKGRlcHRoID4gMCAmJiBBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBmbGF0RGVlcCh2YWwsIGRlcHRoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZsYXREZWVwKGFycmF5LCBkZXB0aCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb21FbnRyaWVzKGFycmF5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFycmF5W2ldO1xuICAgICAgICByZXN1bHRbdmFsdWVbMF1dID0gdmFsdWVbMV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBmdW5jdGlvbiB1MTYoKSB7IHJldHVybiAoYnl0ZXNbcG9zKytdIDw8IDgpIHwgYnl0ZXNbcG9zKytdOyB9XG4gICAgLy8gZGVjb2RlIHRoZSBmcmVxdWVuY3kgdGFibGVcbiAgICBsZXQgc3ltYm9sX2NvdW50ID0gdTE2KCk7XG4gICAgbGV0IHRvdGFsID0gMTtcbiAgICBsZXQgYWNjID0gWzAsIDFdOyAvLyBmaXJzdCBzeW1ib2wgaGFzIGZyZXF1ZW5jeSAxXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzeW1ib2xfY291bnQ7IGkrKykge1xuICAgICAgICBhY2MucHVzaCh0b3RhbCArPSB1MTYoKSk7XG4gICAgfVxuICAgIC8vIHNraXAgdGhlIHNpemVkLXBheWxvYWQgdGhhdCB0aGUgbGFzdCAzIHN5bWJvbHMgaW5kZXggaW50b1xuICAgIGxldCBza2lwID0gdTE2KCk7XG4gICAgbGV0IHBvc19wYXlsb2FkID0gcG9zO1xuICAgIHBvcyArPSBza2lwO1xuICAgIGxldCByZWFkX3dpZHRoID0gMDtcbiAgICBsZXQgcmVhZF9idWZmZXIgPSAwO1xuICAgIGZ1bmN0aW9uIHJlYWRfYml0KCkge1xuICAgICAgICBpZiAocmVhZF93aWR0aCA9PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVhZCBiZXlvbmQgZW5kIG9mIGJ1ZmZlclxuICAgICAgICAgICAgLy8gYnV0ICh1bmRlZmluZWR8MCkgPT4gemVybyBwYWRcbiAgICAgICAgICAgIHJlYWRfYnVmZmVyID0gKHJlYWRfYnVmZmVyIDw8IDgpIHwgYnl0ZXNbcG9zKytdO1xuICAgICAgICAgICAgcmVhZF93aWR0aCA9IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChyZWFkX2J1ZmZlciA+PiAtLXJlYWRfd2lkdGgpICYgMTtcbiAgICB9XG4gICAgY29uc3QgTiA9IDMxO1xuICAgIGNvbnN0IEZVTEwgPSBNYXRoLnBvdygyLCBOKTtcbiAgICBjb25zdCBIQUxGID0gRlVMTCA+Pj4gMTtcbiAgICBjb25zdCBRUlRSID0gSEFMRiA+PiAxO1xuICAgIGNvbnN0IE1BU0sgPSBGVUxMIC0gMTtcbiAgICAvLyBmaWxsIHJlZ2lzdGVyXG4gICAgbGV0IHJlZ2lzdGVyID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKylcbiAgICAgICAgcmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgfCByZWFkX2JpdCgpO1xuICAgIGxldCBzeW1ib2xzID0gW107XG4gICAgbGV0IGxvdyA9IDA7XG4gICAgbGV0IHJhbmdlID0gRlVMTDsgLy8gdHJlYXQgbGlrZSBhIGZsb2F0XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gTWF0aC5mbG9vcigoKChyZWdpc3RlciAtIGxvdyArIDEpICogdG90YWwpIC0gMSkgLyByYW5nZSk7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSBzeW1ib2xfY291bnQ7XG4gICAgICAgIHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHsgLy8gYmluYXJ5IHNlYXJjaFxuICAgICAgICAgICAgbGV0IG1pZCA9IChzdGFydCArIGVuZCkgPj4+IDE7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCBhY2NbbWlkXSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7IC8vIGZpcnN0IHN5bWJvbCBpcyBlbmQgbWFya1xuICAgICAgICBzeW1ib2xzLnB1c2goc3RhcnQpO1xuICAgICAgICBsZXQgYSA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnRdIC8gdG90YWwpO1xuICAgICAgICBsZXQgYiA9IGxvdyArIE1hdGguZmxvb3IocmFuZ2UgKiBhY2Nbc3RhcnQgKyAxXSAvIHRvdGFsKSAtIDE7XG4gICAgICAgIHdoaWxlICgoKGEgXiBiKSAmIEhBTEYpID09IDApIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpICYgTUFTSyB8IHJlYWRfYml0KCk7XG4gICAgICAgICAgICBhID0gKGEgPDwgMSkgJiBNQVNLO1xuICAgICAgICAgICAgYiA9IChiIDw8IDEpICYgTUFTSyB8IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGEgJiB+YiAmIFFSVFIpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyID0gKHJlZ2lzdGVyICYgSEFMRikgfCAoKHJlZ2lzdGVyIDw8IDEpICYgKE1BU0sgPj4+IDEpKSB8IHJlYWRfYml0KCk7XG4gICAgICAgICAgICBhID0gKGEgPDwgMSkgXiBIQUxGO1xuICAgICAgICAgICAgYiA9ICgoYiBeIEhBTEYpIDw8IDEpIHwgSEFMRiB8IDE7XG4gICAgICAgIH1cbiAgICAgICAgbG93ID0gYTtcbiAgICAgICAgcmFuZ2UgPSAxICsgYiAtIGE7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSBzeW1ib2xfY291bnQgLSA0O1xuICAgIHJldHVybiBzeW1ib2xzLm1hcCh4ID0+IHtcbiAgICAgICAgc3dpdGNoICh4IC0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBjYXNlIDM6IHJldHVybiBvZmZzZXQgKyAweDEwMTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCAxNikgfCAoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBvZmZzZXQgKyAweDEwMCArICgoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBvZmZzZXQgKyBieXRlc1twb3NfcGF5bG9hZCsrXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB4IC0gMTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gcmV0dXJucyBhbiBpdGVyYXRvciB3aGljaCByZXR1cm5zIHRoZSBuZXh0IHN5bWJvbFxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfcGF5bG9hZCh2KSB7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgcmV0dXJuICgpID0+IHZbcG9zKytdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKGJ5dGVzKSB7XG4gICAgcmV0dXJuIHJlYWRfcGF5bG9hZChkZWNvZGVfYXJpdGhtZXRpYyhieXRlcykpO1xufVxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cbmV4cG9ydCBmdW5jdGlvbiBzaWduZWQoaSkge1xuICAgIHJldHVybiAoaSAmIDEpID8gKH5pID4+IDEpIDogKGkgPj4gMSk7XG59XG5mdW5jdGlvbiByZWFkX2NvdW50cyhuLCBuZXh0KSB7XG4gICAgbGV0IHYgPSBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKylcbiAgICAgICAgdltpXSA9IDEgKyBuZXh0KCk7XG4gICAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiByZWFkX2FzY2VuZGluZyhuLCBuZXh0KSB7XG4gICAgbGV0IHYgPSBBcnJheShuKTtcbiAgICBmb3IgKGxldCBpID0gMCwgeCA9IC0xOyBpIDwgbjsgaSsrKVxuICAgICAgICB2W2ldID0geCArPSAxICsgbmV4dCgpO1xuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xuICAgIGxldCB2ID0gQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKVxuICAgICAgICB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcbiAgICByZXR1cm4gdjtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkX21lbWJlcl9hcnJheShuZXh0LCBsb29rdXApIHtcbiAgICBsZXQgdiA9IHJlYWRfYXNjZW5kaW5nKG5leHQoKSwgbmV4dCk7XG4gICAgbGV0IG4gPSBuZXh0KCk7XG4gICAgbGV0IHZYID0gcmVhZF9hc2NlbmRpbmcobiwgbmV4dCk7XG4gICAgbGV0IHZOID0gcmVhZF9jb3VudHMobiwgbmV4dCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2TltpXTsgaisrKSB7XG4gICAgICAgICAgICB2LnB1c2godlhbaV0gKyBqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9va3VwID8gdi5tYXAoeCA9PiBsb29rdXBbeF0pIDogdjtcbn1cbi8vIHJldHVybnMgYXJyYXkgb2YgXG4vLyBbeCwgeXNdID0+IHNpbmdsZSByZXBsYWNlbWVudCBydWxlXG4vLyBbeCwgeXMsIG4sIGR4LCBkeF0gPT4gbGluZWFyIG1hcFxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfbWFwcGVkX21hcChuZXh0KSB7XG4gICAgbGV0IHJldCA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCB3ID0gbmV4dCgpO1xuICAgICAgICBpZiAodyA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcbiAgICB9XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IHcgPSBuZXh0KCkgLSAxO1xuICAgICAgICBpZiAodyA8IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0LnB1c2gocmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tRW50cmllcyhmbGF0KHJldCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRfemVyb190ZXJtaW5hdGVkX2FycmF5KG5leHQpIHtcbiAgICBsZXQgdiA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBpID0gbmV4dCgpO1xuICAgICAgICBpZiAoaSA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHYucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiByZWFkX3RyYW5zcG9zZWQobiwgdywgbmV4dCkge1xuICAgIGxldCBtID0gQXJyYXkobikuZmlsbCh1bmRlZmluZWQpLm1hcCgoKSA9PiBbXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgcmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XG4gICAgbGV0IGR4ID0gMSArIG5leHQoKTtcbiAgICBsZXQgZHkgPSBuZXh0KCk7XG4gICAgbGV0IHZOID0gcmVhZF96ZXJvX3Rlcm1pbmF0ZWRfYXJyYXkobmV4dCk7XG4gICAgbGV0IG0gPSByZWFkX3RyYW5zcG9zZWQodk4ubGVuZ3RoLCAxICsgdywgbmV4dCk7XG4gICAgcmV0dXJuIGZsYXQobS5tYXAoKHYsIGkpID0+IHtcbiAgICAgICAgY29uc3QgeCA9IHZbMF0sIHlzID0gdi5zbGljZSgxKTtcbiAgICAgICAgLy9sZXQgW3gsIC4uLnlzXSA9IHY7XG4gICAgICAgIC8vcmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheSh2TltpXSkuZmlsbCh1bmRlZmluZWQpLm1hcCgoXywgaikgPT4ge1xuICAgICAgICAgICAgbGV0IGpfZHkgPSBqICogZHk7XG4gICAgICAgICAgICByZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XG4gICAgICAgIH0pO1xuICAgIH0pKTtcbn1cbmZ1bmN0aW9uIHJlYWRfcmVwbGFjZW1lbnRfdGFibGUodywgbmV4dCkge1xuICAgIGxldCBuID0gMSArIG5leHQoKTtcbiAgICBsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZChuLCAxICsgdywgbmV4dCk7XG4gICAgcmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWFkX2Vtb2ppX3RyaWUobmV4dCkge1xuICAgIGxldCBzb3J0ZWQgPSByZWFkX21lbWJlcl9hcnJheShuZXh0KS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgcmV0dXJuIHJlYWQoKTtcbiAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICBsZXQgYnJhbmNoZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCBrZXlzID0gcmVhZF9tZW1iZXJfYXJyYXkobmV4dCwgc29ydGVkKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYnJhbmNoZXMucHVzaCh7IHNldDogbmV3IFNldChrZXlzKSwgbm9kZTogcmVhZCgpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+IGIuc2V0LnNpemUgLSBhLnNldC5zaXplKTsgLy8gc29ydCBieSBsaWtlbGlob29kXG4gICAgICAgIGxldCB0ZW1wID0gbmV4dCgpO1xuICAgICAgICBsZXQgdmFsaWQgPSB0ZW1wICUgMztcbiAgICAgICAgdGVtcCA9ICh0ZW1wIC8gMykgfCAwO1xuICAgICAgICBsZXQgZmUwZiA9ICEhKHRlbXAgJiAxKTtcbiAgICAgICAgdGVtcCA+Pj0gMTtcbiAgICAgICAgbGV0IHNhdmUgPSB0ZW1wID09IDE7XG4gICAgICAgIGxldCBjaGVjayA9IHRlbXAgPT0gMjtcbiAgICAgICAgcmV0dXJuIHsgYnJhbmNoZXMsIHZhbGlkLCBmZTBmLCBzYXZlLCBjaGVjayB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29kZXIuanMubWFwIiwiLyoqXG4gKiBNSVQgTGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAyMSBBbmRyZXcgUmFmZmVuc3BlcmdlclxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKlxuICogVGhpcyBpcyBhIG5lYXIgY2FyYm9uLWNvcHkgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZSAobGluayBiZWxvdykgd2l0aCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwaW5ncyBhZGRlZCBhbmQgYSBmZXcgdHdlYWtzIHRvIG1ha2UgaXQgRVMzLWNvbXBhdGlibGUuXG4gKlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzXG4gKi9cbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkIH0gZnJvbSAnLi9kZWNvZGVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgIHJldHVybiByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChkZWNvZGUoJ0FFUUYyQU8yREVzQTJ3SXJBR3NCUkFCeEFOOEFad0NjQUV3QXFnQTBBR3dBVWdCeUFEY0FUQUFWQUZZQUlRQXlBQ0VBS0FBWUFGZ0FHd0FqQUJRQU1BQW1BRElBRkFBZkFCUUFLd0FUQUNvQURnQWJBQThBSFFBWUFCb0FHUUF4QURnQUxBQW9BRHdBRXdBOUFCTUFHZ0FSQUE0QUR3QVdBQk1BRmdBSUFBOEFIZ1FYQllNQTVCSEpBUzhKdEFZb0FlNEFFeG96aTBVQUgyMXRBYU1uQlQ4Q3JuSXlock1EaFJnRHlnSUJVQUVIY29GSFVQZThBWEJqQWV3Q2pnRFFSOElJQ0ljRWNRTHdBVFhDRGd6dkh3Qm1Cb0hOQXFzQmRCY1VBeWtnRGhBTVNoc2tNZ284QVk4anFBUWZBVUFmSHc4QkR3ODdNaW9HbENJUEJ3WkNhNEVMYXRNQUFNc3BKVmdzRGw4QUloY2tTZzhYQUhkdlR3QmNJUUVpRFQ0T1BoVXFieUVDQUVvQVMzNEFlajhZYng4M0pnVC9YdzhnSHhaLzd3OFJJQ3hQSEE5dkJ3K1BmdzhQSHdBUEZ2K2ZBc0F2Q2M4dkVyOGl2d0QvRVE4Qm9sOE9FQmEvQTc4aHJ3QVBDVTh2RVNOdnZ3V2ZId05mQVZvREhyK1pBQUVEMzRZYUFkSlBBSzdQTHdTRWdETEhBR28xUHo4UHZ4OWZVd01ycGI4Ty81OFZUekFQSUJvWEl5UUpORjhocHdJVkFUOFlHQVVBREROQmFYM1JBTW9tSkNnOUVoVWVBMjlNQUJzWkJUTU5KaXBqT2hjMTlnY0lEUjhiQndRSEVnZ0NXaTZESWdMdUFRWUErQkFGQ2hhM0E1WGlBRXNxTTdVRkZnRkxoQU1qRlRNWUUxS2xudzc0blJWQkcvQVNDbTBCWVJOL0Jyc1UzVm9XeStTMHZWOExReCt2TjhnRjJBQzJBSzVFQVd3QXBnWURLbUFBcm9RME5EUTBBVCtPQ2c3d0FBSUhSQWJwTmdWY0JWMEFQVEE1QmZiUEZnTUx6Y1lML1FxcUE4MmVCQUxLQ2pRQ2pxWUNodDAvazIrT0FzWFFBb1AzQVNUS0RnRHc2QUNLQVVZQ01wSUtKcFJhQUU0QTV3b21BQnpadnMwUkVFS2lBQ0lRQWQ1UWRBRUNBajRZd2cvd0dxWTJBVmdBWUFEWXZBb0NHQUV1YkEwZ3ZBWTJBTEFBYnBidnFweUVBR0FFcGdRQUpnQUc3Z0FnQUVBQ21naFVGd0NxQU1wQUlOUUl3QzREdGhSQUFQY3ljS2dBcG9JZEFCd0JmQ2lzQUJvQVR3QnFBU0lBdmhuU0JQOGFIL0VDZUFLWEFxNDBOamdEQlR3RllRVTZBWHMzb0FCZ0FENFhOZ21jQ1kxZUNsNXRJRlplVXFHZ3lvTkhBQmdBRVFBYUFCTndXUUFtQUJNQVRQTWEzVDM0QURsZHlwcm1NMU0yWG9jaVVRZ0x6dndBWFQzeEFCZ0FFUUFhQUJOd0lHRkFuQUREOEFBZ0FENEJCSld6YUNjSUFJRUJGTUFXd0tvQUFkcTlCV0FGNXdMUXBBTEV0UUFLVVNHa2FoUjRHbkpNK2dzQXdDZ2VGQWlVQUVDUTBCUXVMOEFBSUFBQUFES2VJaGVjbHZGcVFBQUVUcjRpQU14SUFSTWdBTUlvSGhRSUFuMEUwcERRRkM0SGh6bm9BQUFBSUFJMkMwLzRsdkZxUUFBRVRnQkpKd1lDQXk0QUJnWUFGQUE4TUJLWUVINGVSaFRrQWpZZUZjZ0FDQVlBZUFCc09xeVE1Z1J3RGF5cXVnRWdhSUlBdGdvQUNnRG1FQUJtQkFXR21lNU9CSkpBMm00Y0Rlb0FtSVRXQVh3ck1nT2dBR3dCQ2g2Q0JYWUYxVHpnMXdLQUFGZGl1QUJSQUZ3QVhRQnNBRzhBZGdCckFIWUFid0NFQUhFd2Z4UUJWRTVURVFBRFZGaFRCd0JEQU5JTEFxY0N6Z0xUQXBRQ3JRTDZ2QUFNQUw4QVBMaE5CS2tFNmdsR0tUQVU0RHI0TjJFWUV3QkNrQUJLazhySEFiWUJtd0lvQWlVNEFqZi9BcTRDb3dDQUFOSUNoemdhTkJzQ3NUZ2VPRGNGWHJnQ2xRS2RBcVFCaVFHWUFxc0NzalRzTkhzZk5QQTBpeHNBV1RXaU9BTUZQRFFTTkNrMkJEWkhOb3cyVFRaVU5oazI4Sms5VnpJM1FrRW9Bb0lDb1FLd0FxY0FRQUF4QlY0RlhiUzlCVzQ3WWtJWFAxY2lVcXMwNURTL0Z3QUJVd0pXMTFlNm5IdVlabVNoL1JBWUE4b01Ldlo4S0FTb1VBSllXQUo2SUxBc0FaU29xanBnQTBvY0JJaG1EZ0RXQUFhd1JEUW9BQWN1QWo1aUFIQUJaaVIyQUlnaUhnQ2FBVTY4QUN4dUhBRzB5Z004TWlaSUFsZ0JkRjRHYWdKcUFQWk9IQU11QmdvQVRrWUFzQUJpQUhnQU1Mb0dEUGowSHBLRUJBQU9KZ0F1QUxnZ1RBSFdBZUFNRURiZDIwVWVnZTBBRHdBV0FEa0FRZ0E5T0hkKzJNVVFaQkJoQmdOTkRreHhQeFVRQXJFUHF3dnFFUm9NMWlyUTA5MEFOSzRIOEFOWUIvQURXQU5ZQi9BSDhBTllCL0FEV0FOWUExZ0RXQndQOEIvWXhSQmtEMDBFY2dXVEJaQUUyd2lJSms0UmhnY3RDTmRVRW5RakhFd0RTZ0VCSXlwSklUdVlNeEFsUjB3UlRRZ0lBVFpIYkt4OVBRTk1NYkJVK3BDbkE5QXlWRGx4QmdNZWRoS2xBQzhQZUNFMXVrNkRla3h4cFFwUVQ3Tlg5d0JGQmdBU3F3QVM1Z0JKRFNnQVVDd0dQUUJJNHpUWUFCTkdBRTJiQUUzS0FFeGRHQUJLYUFiZ0FGQlhBRkNPQUZCSkFCSTJTV2RPYkFMRE9xMC8vUW9tQ1podndIZFRCa0lRSENlbUVQZ01OQUcyQVR3TjdrdlpCUElHUEFUS0gzNFpHZy9PbFowSXBpM2VETzRtNUM2aWdGc2o5aXFFQmU1TDlUemVDMDVSYVE5YUMyWUo1RHBrZ1U4RElnRU9Jb3dLM2cwNkNHNFE5QXJLYkEzbUVVWUhPZ1BXU1pzQXBnY0NDeElkTmhXMkpoRmlyUXNLT1hnRy9CcjNDNUFtc0JNcWV2MEYxQm9pQms0Qktoc0FBTkF1NklXeFdqSmNIVTlnQmdRTEppUElGS2xRSVEwbVFMaDRTUm9jQnhZbHFnS1NRM0ZLaUZFM0hwUWg5encrRFdjdUZGRjlCL1k4QmhsUUM0SThuMGFzUlE4UjB6Nk9QVWtpU2t3dEJEYUFMREFuakFuUUQ0WU11bnh6QVZvSklnbXlESElUTWhFWU44WUlPZ2NhTHBjbEp4WUlJa2FXWUpzRStLQUQ5QlBTQXd3RlFBbENCeFFEdGh3dUV5OFZLZ1VPZ1NYWUF2UTIxaTYwQXBCV2dRRVlCY3dQSmgvZ0VGRkg0UTdxQ0p3Q1pnT0VKZXdBTGhVaUFCZ2luQWhFWkFCZ2o5bFRCaTdNQ01ocWJTTjFBMmdVNkdJUmRBZVNEbGdIcUJ3MEZjQWM0bkRKWGd5R0NTaWtzQWxjQVhZSm1nRmdCT1FJQ2pWY2pLRWdRbWRVaTFrWW5DQmlRVUJkL1FJeURHWVZvRVMraDNrQ2pBOXNFaHdCTmdGMEJ6b05BZ0o0RWU0UmJCQ1dDT3lHQlRXMk0vazZKZ1JRSVlRZ0Vnb29BMUJzendzb0p2b00rV29CcEJKakF3MDBQbmZ2WjZ4Z3R5VVgvZ2NhTXNaQllTSHlDNU5Qemd5ZEdzSVlRMVF2R2VVSHdBUDBHdlFuNjBGWUJnQURwQVFVT2s0ejd3UytDMm9JakFsQUFFb09wQmdIMkJockNuS00wUUV5akFHNG1nTllrb1FDY0pBR09BY01BR2dNaUFWNjVnQWVBcWdJcEFBR0FOQURXQUE2QXE0SG5nQWFBSVpDQVQ0REtEQUJJdVlDa0FPVUNETE1BWll3QWZRcUJCekVEQllBK0RodVN3TERzZ0tBYTJhakJkNVpBbzhDU2pZQlRpWUVCazlJVWdPd2N1SUEzQUJNQmhUZ1NBRVdyRXZNRytSRUFlQndMQURJQVB3QUJqWUhCa0lCemdIMGJnQzRBV0FMTWdtanRMWUJUdW9xQUlRQUZtd0IyQUtLQU40QU5nQ0E4Z0ZVQUU0Rld2b0YxQUpRU2dFU01oa3NXR0lCdkFNZ0FUUUJEZ0I2QnN5T3Bzb0lJQVJ1QjlRQ0VCd1Y0Z0x2THdlMkFnTWk0QlBPUXNZQ3ZkOVdBRElYVXU1ZVp3cW9DcWRlYUFDMFlUUUhNbk05VVFBUEg2ayt5QWR5L0JaSWlRSW1Td0JRNWdCUVF6U2FOVEZXU1RZQnB3R3FLUUszOEFGdHF3Qkkvd0szN2dLM3JRSzNzQUs2MjgwQzBnSzMzQUszenhBQVVFSUFVRDlTa2xLREFyZWtBcnc1QUVRQXpBSENPMTQ3V1R0ZU8xazdYanRaTzE0N1dUdGVPMWtEbUNoWUkwM0FWVTBvSnFrS2JWOUdZZXdNcHczVlJNazZTaFBjWUZKZ014UEpMYmdVd2hYUEpWY1pQaHE5SndZbDVWVUtEd1V0MUdZeENDMDBkaGU5QUVBcGFZTkNZNGNlTVFwTUhPaFRrbFQ1TFJ3QXNrdWpNN0FOclJzV1JFRUZTSFh1WWlzV0R3b2pBbVNDQW1KRFhFNndYRGNoQXFINEFtaVpBbVlLQXArRk9Cd01BbVk4QW1ZbkJHOEVnQU4vRkFOK2t6a0hPWGdZT1lNNkpDUUNiQjRDTWpjNEN3SnR5QUp0ci9DTEFEUm9SaXdCYUFEZkFPSUFTd1lIbVF5T0FQOE13d0FPdGdKM01BSjJvMEFDZVV4RUFuaTdIbDNjUmE5RzlBSjhRQUo2eVFKOUNnSjg4VWdCU0g1a0pRQXNGa2xaU2x3V0dFck5BdEVDQXRETlN5Z0RpRkFEaCtkRXhwRXpBdktpWFFRREE2OUx6MHd1SmdUUVRVMU5zQUtMUUFLSzJjSWNDQjVFYUFhNEFvNDRBbzVkUVppQ0FvN2FBbzVkZVZHMVV6WUxVdFZVaGdLVC9BS1REUURxQUIxVkgxV3dWZEVITEJ3cGxvY3k0bmhuUlR3NkFwZWdBdSt6V0NLcEFGb21BcGFRQXBaOW5RQ3FXYTFhQ29KT0FEd0NscllDbGs5Y1JWelNBcG5NQXBsbFhNdGRDQm9Dbkp3NXd6cWVBcHdYQXArY0FwNjVpd0FlRURJckVBS2Q4Z0tla3dDMlBtRTFZZkFDbnRRQ29HOEJxZ0tlb0NBQ25rK21ZOGxrS0NZc0FpZXdBaVovQXFEOEFxQk4yQUttTUFLbHp3S29BQUIrQXFmemFIMW9zZ0FFU21vZGF0SUNyT1FDcks4Q3JXZ0NyUU1DVng0Q1ZkMENzZUxZQXg5UGJKZ0NzcjRPQXJMcEdHemhiV1J0U1dBREpjNEN0bDA4UUc2UkF5bEdBcmhmQXJsSUZnSzVLM2h3TjNEaUFyMGFBeTJ6QXpJU0FyNkpjZ01ETTNJQ3ZodHpJM05RQXNQTUFzTUZjNE4wVERaR2RPRURQS2dEUEpzRFBjQUN4WDBDeGtnQ3hoR0tBc2hxVWdMSVJRTEpVQUxKTHdKa25nTGQwM2g2WW5pdmVTWkwwUU1ZcEdjREFtSDFHZlNWSlhzTVhwTmV2QklDejJ3Q3oyMHdURlRUOUJTZ0FNZXVBczkwQVNyckEwNFRma3dHQXR3b0F0dUxBdEpRQTFKZEExTmdBUUlEVlkyQWlrQUJ6QmZ1WVVaMkFJTFBnNDRDMnNnQzJkK0VFWVJLcHowRGhxWUFNQU5rRDRaeVd2b0FWZ0xmWmdMZXVYUjRBdUl3N1JVQjh6RW9BZlNjQWZMVGlBTHI5QUxwY1hvQUF1cjZBdXJsQVBwSUFib0M3b29DNjUyV3E1Y0VBdTVBQTRYaG1IcHc0WEdpQXZNRUFHb0RqaGVabEFMM0ZBT1Jid09TaUFMM21RTDUyZ0w0WjVvZG1xeThPSnNmQTUyRUF2NzdBUndBT3A4ZG43UURCWTREcG1zRHB0b0Ewc1lEQm11aGlhSUdDZ01NU2dGZ0FTQUN0Z05HQUp3RWdMcG9CZ0M4Qkd6QUVvd2NnZ0NFREM2a2Rqb0FKQU0wQzVJS1JvQUJaQ2dpQUl6dzNBWUJMQUNrZm5nOW9naWdrZ05tV0FONkFFUUN2cmtFVnFUR0F3Q3NCUmJBQSs0aVFrTUNIUjA3MmpJMlBUYlVOc2syUmpZNU52QTIzVFpLTmlVM0VEY1pONUkrUlR4RFJUQkNKa0s1VkJZS0ZoWmZ3UUNXeWdVM0FKQlJIcHUrT3l0Z054YTYxQTQwR01zWWpzbjdCVndGWFFWY0JWMEZhQVZkQlZ3RlhRVmNCVjBGWEFWZEJWd0ZYVXNhQ055S0FLNEFBUVVIQndLVTdvSUNvVzFlN2pBRXpnUHhBK1lEd2dDa0JGREF3QURBQkt6QUFPeEZMaGl0QTFVRlREZXlQa00rYmo1MVFrUkN1d1RRV1dROFgrMEFXQll6c0FDTkE4eHd6QUdtN0VaL1Fpc29DVEFiTERzNmZuTGZiOEgyR2Njc2JnRncxM00xSEFWa0JXL0p4c205Q05STzhFOEZERDBGQlF3OUZrY0NsT1lDb01GZWdwRGZBRGdjTWlBMkFKUUFDQjhBc2lnS0FJeklFQUpLZUJJQXBZNXlQWlFJQUtRaUhiNGZ2ajVCS1NSUFFyWkNPejBvWHl4Z095d2ZLQW5HYmdNQ2xRYUNBa0lMWGdkZUNEOUlJR1VnUWo1ZlBvWStkVDUyQW81Q00wZEFYOUJUVkc5U0R6RndXVFFBYnhCekpGL2xPRUlRUWdsQ0NrS0pJQWxzNUFjQ2xRSUNvS1BNT0RFRnhoaTZLU0FiaXlmSVJyTWp0Q2dkV0NBa1BsRkJJaXRDc0VKUnpBYk1BVi9PRXlRekRnME9BUVFFSjM2aTMyOC9NazlBeWJESnNRbHEzdERSQXBVS0FrRnpYZjFkL2o5dUFMWVA2aENvRmdDVEdEOGtQc0ZLUWlvYnJtMCt6ajBLU0Q4a1BuVkNSQndNRHlKUlRIRmdNVEphNXJ3WFFpUTJZZkkvSkQ3Qk1FSkVIR0lOVHc0VE9GbElSendKTzBpY01RcHlQeVErd3pKQ1JCdjZEVmduS0IwMU5nVUtqMmJ3WXpNcUNvQmt6bkJnRUYrellESW9jd1JJWCtOZ0hqNEhJQ05maDJDNEN3ZHdGV3BURy9sZ1VoWUdBd1JmdjJUczhtQWFYelZnbWwvWFlJSmZ1V0M0SEkxZ1VGOXBZSlpnTVI2aWxRSE1BT3dMQWxEUmVmQzBpbjRBWEFFSkE2UGpDd2MwSWFtT0FOTU1DQUVDUlFERk5SVFpCZ2QrQ3dRbFJBK3I2K2dMQkRFRkJud1VCWGdLQVRJQXJ3QUdSQUFIQTNjRGRBTjJBM2tEZHdOOUEzb0RkUU43QTMwRGZBTjRBM29EZlFBWUVBQWxBdFlBU3dNQVVBRnNBSGNLQUhjQW1nQjNBSFVBZFFCMkFIVnU4VWdBeWdEQUFIY0FkUUIxQUhZQWRRQUxDZ0IzQUFzQW1nQjNBQXNDT3dCM0FBdHU4VWdBeWdEQUFIZ0tBSm9BZHdCM0FIVUFkUUIyQUhVQWVBQjFBSFVBZGdCMWJ2RklBTW9Bd0FBTENnQ2FBSGNBQ3dCM0FBc0NPd0IzQUF0dThVZ0F5Z0RBQUg0QUN3R2dBTGNCcHdDNkFhaGRBdTBDT3dMdGJ2RklBTW9Bd0FBTENnQ2FBdTBBQ3dMdEFBc0NPd0x0QUF0dThVZ0F5Z0RBQTI0QUN3TnZBQXUwVnNRQUF6c0FBQkNralVJcEFBc0FVSXVzT2dnV2NnTWVCeFZzR3dMNjdVLzJIbHptV09FZU9nQUxBU3Z1QUFzZUFmcEtVcG5wR2dZSkRDSVpNNll5QVJVRTlUaHFBRDVpWFFnbkFKWUpQbk96dzBaQUVaeEVLc0lBa0E0RGhBSG5UQUlEeHhVREswbHhDUWxQWWdJdklRVllKUUJWcUUxR2FrVUFLR1lpRFRvU0JBMUV0QVlBWFFKWUFJRjhHZ01IUnlBQUlBak9lOVluY2VrUkFBMEtBQ1VyandFN0F5YzZBQVlXQXFhaUtHNE1jRWNxQU5vTjMrTWc5VHdDQmhJa3VDbnkrSndVUTI5TDAwOEpsdVJ4dTNLK29BZHFpSE9xRkgwQUc1U1VJZlVKNVN4Q0dmeGRpcFJ6cVRtVDRWNVpiK3IxVW80Vm0rTnFTU0VsMm1OdlIySmhJYThTcFlPNm50ZHdGWEhDV1RDSzhmMitIeG83dWlHM2RyRHljQXVLSU1QNWJoaTA2QUNucUFySDFyejRScWcvL2xtNlNnSkdFVmJGOXhKSElTYVI2SHhxeFNua3c2c2hEbmVsSEtORWZHVVhTSlJKMUdjc210SncyNXhyWk1ESzlnWFNtMS9ZTWtkWDQvNk5LWU9kdGsvTlEzL05uREFTalRjM2ZQaklqVy81c1ZmVk9iWDJvVERXa3IxZEY5ZjNreEJzRDMvM2FRTzhoUGZSeitlMHVFaUpxdDExNjFncml1N2d6OGhERHd0cHkrRitCV3RlZm5LSFpQQXhjWm9XYm56bmhKcHkwZTg0MmozNmJjTnpHbklFdXNnR1gwYThaeHNuamNTc1BEWjA5eVozNmZDUWJyaUhlUTcySlJNSUxObDZlUFBmMkhXb1Z3Z1dBbTFmYjNWMnNBWTArQjZyQVhxU3dQQmdzZVZtb3FzQlRTcm05MStYYXNNWVl5U0k4ZWVSeEgzWnZIa016M0JRNWFKM2lVVmJZUE5NMy83ZW1SdGpsc01ndi85VnlUc3l0L21LKzhmZ1dlVDZTb0ZhY2xYcW40MmRBSXN2QWFyRjV2Tk5XSHpLU2tLUS84SGZrNVpXSzdyOXlsaU9zb295QmpSaGZrSFA0UTJEa1dYUWk2RkcvOXIvSXdibWtWNVQ3SlNvcEhLbjFwSndtOXRiNU90MG95TjFaMm1QcEtYSFR4eDJubEswOGZLazFoRVlBOFdnVlZXTDVsZ3gwaVR2K0tkb2pKZVUyM1pEam1pdWJYT3hWWEpLS2kyV2p1aDJITFpPRkxpU0M3VGxzNVNNaDRmK1BqNnhVU3JOakZxTEdlaFJOQjhsQzBRU0xObWtKSngvd1NHM01uakU5VDFDa1B3Skkwd0gybGZ6d0VUSWlWcVV4ZzBkZnU1cTM5R3QraHdkY3hraGhOdlE0VHlyQmNlb2YzTWhzL0l4RmNpMUhtSHI0Rk1aZ1hFRWN6UGlHQ3gwSFJ3ekFxRHEyajlBVm0xa3dOMG1SVkxXTHlsZ3RvUE5hcEY1Y1k0WTF3SmgvZTBCQndaajQ0WWdackROcXZELzlIdjdHRllkVVFlREp1UTNFV0k0SGFLcWF2VTFYakMvbjQxa1Q0TDc5a3FHcTBrTGhkVFp2Z1AzVEEzZlMwb3pWeis1cGlac29PdEl2QlVGb01LYk5jbUJMNll4eGFVQXVzSEIzOFhyUzhkUU1uUXdKZlVVa3BSb0dyNUFVZVdpY3ZCVHp5SzlnNzcreUNrZjVQQXlzTDdyL0pqY1pncmJ2UnBNVzlpeWF4WnZLTzZjZVpOMkV3SXhLd1ZGUHV2RnVpRVBHQ29hZ2JNbytTcHlkTHJYcUJ6TkNER0ZDck8vcmtjd2EyeGhva1FaNUNkWjBBc1UzSmZTcUo2bjVJMTRZQStQL3VBZ2ZoUFU4NFRsdzdjRUZmcDdBRUU4ZXk0c1AxMlBUdDRDb2RzMUdSZ0RPQjV4dnlpUjVtK0J4OE81bkJDTmN0VThCZXZmVjVBMDh4NlJIZDVqY3dQVE1EU1pKT2VkSVoxY0dRNzA0bHhiQXpxWk9QMDVaeGFPZ2h6U2R2RkJIWXFvbUFUQVJ5QUFESzRlbFA4THkzSXJVWktmV2gyM1h5MjB1QlVtTFM0UGZhZ3U5K295VmEyaVBncVJQM0YyQ1RVc3ZKNytSWW5OOGZGWmJVL0hWdnh2Y0ZGREtraVRxVjVVQlozR3o1NEpBS0J5aTloa0tNWkp2dUdnY1NZWEZtdzA4VXlvUXlWZGZURDEvZE1rQ0hYY1RHQUtlUk9nQXJzdm1SclFUTFVPWGlvT0hHSzJRa2pIdW9ZRmdYY2lab1RKZDZGczVxMVFYMUcrcC9lMjZoWXNFZjdRWkQxbm5JeWwvU0ZrTnRZWW1tQmhwQnJ4bDlXYlkwWXBIV1J1dzJMbC90ajltRDhQNHNuVnpKbDRGOUorMWFyVmVUYjlFNXIySUxIMDRxU3RqeFFOd24zbTRZTnF4bWFOYkxBcVcyVE42TGlkd3VKUnFTK05YYnRxeG9lRFhweGVHV214elNrV3hqa3lDa1g0TlFSbWU2cTVTQWNDK003KzlFVGZBL0V3cnpRYWpLYWtDd1l5ZXVuUDZaRmx4VTJvTUVuMVB6MzF6ZVN0Vzc0RzQwNlpKRkNsMXdBWElvVUtrV290WUVwT3VYQjF1Vk54SjYzZHBKRXFmeEJlcHR3SUhOclB6OEJsbFpvSWNCb1h3Z2ZKKzhWQVVuVlB2UnZleG53ME1hL1dpR1l1Sk81eThRVHZFWUJpZ0ZtaFV4WTVScXpFOE9jeXdOLzhtNFVZcmxhbmlKTzc1WFE2S1NvOSt0V0hsdStoTWkwVVZkaUtRcDdOZWxub1pVek5hSXlCUFZlT3dLNkdOcCtGZkh1UE9veWhhV3VOdlRZRmt2eHNjTVFXRGgremVGQ0ZrZ3diWGZ0aVYyM3l3SjQrdXdScW1nOWszS3p3SVFwenBwdDhEQkJPTWJycXdRTTVHYjA1c0V3ZEt6TWlBcU9sb2FBL2xyMEtBKzFwcjAvK0hpV29pSWpIQS93aXIybkl1UzNQZVUvamkzTzZad294Y1IxU1o5Rmh0TEM1UzBGSXpGaGJCV2NHVlAvS3B4T1BTaVVvQWRXVXBxS0grKzZTY3o1MDdpQ2N4WUk2cmRNQklDUEpaZWE3T2NtZUZ3NW1PYkpTaXFwamcyVW9XTklzK2NGaHlEU3Q2Z2VWNXFnaTNGdW5td3dEb0dTTWdlckZPWkdYMW0wZE1DWW81WE9ydXhPMDYzZHdFTks5RGJuVk05d1lGUkV6aDR2eVUxV1lZSi9MUlJwNm94Z2pxUC9YNWE4LzRBZjZwNk5Xa1FmZXJ6Qm1YbWUwelkvNG53TUptL3dkMXRJcVN3R3orRTN4UEVBT29abEppdDNYZGRENy9CVDFwbGx6T3grOGJtUXRBTlEvUzZmWmV4YzZxaTNXK1EyeGNtWFRVaHVTNW1wSFFSdmN4WlVOMFM1K1BMOWxYV1VBYVJaaEVIOGhUZEFjdU5NTUN1Vk5LVEVHdFNVS05pM082S2hTYVR6Y2s4Y3NaMnZXUlorZDdtVzhjNElLd1hJWWQyNVMveklmdFBrd1B6dWZqRXZPSFdWRDFtK0ZqcERWVVRWMERHRHVIajZRbmFFd0x1L2RFZ2RMUU9nOUUxU3JvOVhISjh5a0xBd3RQdStweHFLRHVGZXhxT04xc0tRbTdyd2JFMUU2OFVDZkEvZXJvdnJUQ0crREJTTmcwbDRnb0RRdlpONnVObGJ5THBjWkF3ajJVY2x5Y3ZMcElaTWd2NHlSbHBiM1l1TWZ0b3pvcmJjR1ZIdC9WZURWMytGZGYxVFAwaXVhQ3NQaTJHNFhlR2hzeUYxdWJWRHhrb0pobW5pUTAvalNnL2VZTUw5S0xmbkNGZ0lTV2twOTFlYXVSM0lRdkVEMG5BUFhLKzZoUENZcytuMytoQ1piaXNrbVZNRzJkYSswRXNaUG9uVWVJWThFYmZ1c1FYanNLL2VGRGFvc2JQakVmUVMwUktHN3lqNUdHNjlNN01lTzFIbWlVWW9jZ3lnSkhMNk0xcXpVRER3VVNtcjk5VjdTZHIyRjNKalFBSlkrRjB5SDMzSXYzK0M5TTM4ZU1MN2dUZ21OdS9yMmJVTWlQdnBZYlo2djEvSWFFU2lyQkhOYTdtUEtuNGRFbVlnN3YvK0hRZ1BOMUc3OWpCUTErc295ZGZEQzJyK2gyQmwvS0ljNUtqTUs3T0g2bmIxakxzTmYwRUhWZTJLQmlFNTFveDYzNnV5RzZMaG8wdDNKMzRMNVFZL2lsRTNtaWthRjRIS1hHMW1HMXJDZXZUMVZ2Nkdhdmx0eG9RZS9iTXJwWnZSZ2duQnhTRVBFZUV6a0VkT3hUblBYSFZqVVlkdzhKWXZqQi9vN0VlZ2MzTWErTlV4TExuc0swa0psaW5QbVVIekhHdHJrNStDQWJWekZPQnFweXkzUVZVbnpURGZDLzBYRDk0L29rSCtPQitpN2c5bG9saFdJalNuZkliK0VxNDNaWE9XbXd2anlWL3FxRCt0MGUrN21URU03NHFQL096dDhubUM3bVJweXU2M09CNEtuVXpGYzA3NFNxb3lQVUFnTSsvVEpHRm82VDQ0RUhuUVU0WDR6NnFhbm5WcWd3L1U3ekNwd2NtWFYxQXViSXJ2T21rS0hhekpBUjU1ZVBqcDV0TEJzTjh2QXFzM05BSGRjRUhPUjJ4UTBsc05BRnpTVXV4RlFDRll2WExaSmRPajlwNGZOcTZwMEhCR1VpazJZemFJNHh5U3k5MUt6aFEwK3ExaGp4dkltUndQUmY3NnRDaGxSa2hSQ2k3NE5YWjlxVU5lSXdQK3M1cCszbTVud1BkTk9IZ1NMRDc5bjdPOW0xbjF1REhpTW50cTRua1l3VjVPWjFFTmJYeEZkNFBncmx2YXZac3lVTzRNcVlscXFuMU84Vy9JMWRFWnE1ZFhocmJFVExhWkliQzJLai9BYS9RTStmcVVPSGRmMHRYQVExaHVaM2NtV0VDV1NYeS80M2ozNStNdnE5eHdzN0pLc2VyaVoxcEVXS2M4cWx6TnJHUFVHY1ZnT2E5Y1BKWUlKc0duSlRBVXNFY0RPRVZVTE81eDByWEJpamMxbGdYRXpRUUtoUk9mOHpJVjgydzhlc3djNzhZWDExS1lMV1FSY2dITkpFbEJ4ZlhyNzJsUzJSQlNsMDdxVEtvck8ydVVEWnIzc0ZoWXN2bmhMWm4wQTk0S1J6Si83REVHSUFoVzVaV0ZwTDhnRXd1MWFMQTlNdVdaek53bDhPemU5WStiWCt2OWd5d1JWbm9CNUkvOGtYVFhVMzE0MXlSTFlySU9PejZTT255SE55NFNpZXF6a0JYaGFyamZqcXExcTZ0a2xhRWJBOFFmbTJEYUlQczdPVHEvbnZKQmpLZk8ySDliSDJjQ01oMSs1Z3NwZnljdThmL2N1dVJtdERqeXFaN3VDSU15amRWM2ErcDNmcW1Yc1J4NEM4bHVqZXpJRkhuUWlWVFhMWHVJMVhyd04zK3NpWVlqMkhIVHZFU1V4OERsT1RYcGFrOXFGUksrTDNtZ0oxV3NEN0Y0Y3UxYUpvRm9ZUW51K3dHRE1PakpNM2tpQlFXSENjdmhKL0hSZHhvZE9RcDQ1WVphT1RBMjJOYjRYS0NWeHFrYndNWUZoellRWUlBbkNXOEZXMTR1Zjk4amhVRzJ6cktoUVEwcTBDRXEwdDVuWHl2VXl2UjhEdkQ2OUxVK2czaStIRldRTVE4UHFadUhEK3NOS0FWMCtNNkVKQzBzenE3ckVyN0I1YlE4QmNOSHp2RE1jOWVxQjVaQ1FkVGY4ME9ibjR1emp3cFlVN1NJU2R0VjBRR2E5RDNXcmgyQkRRdHBCS3hhTkZWKy9DeTJQL1N2KzhzN1VkMEZkNzRYNCtvL1ROenRXZ0VUVWFweSttYWpOUTY4THEzZWUwWk80OFZFYlRaWWlIMUNvNE9sZldlZjgyUldleVVYbzd3b00wM1B5YXBHZmlrVG5RaW5vTnE1ejV2ZUxwZU1WM0hDQU1UYVptQTFvR0xBbjdYUzNYWXN6K1hLN1ZNUXNjNFhLcm1EWE9MVS9wU1hWTlVxOGRJcVRiYS8vLzN4NkxpTFM2eHMxeHVDQVlTZmNRMytyUWdtdTd1dmYzVEhLdDVPb285N1RxY2JScXh4N0VBU2l6YVFDQlFsbEcvcll4VmFwTUxndExiWlM2NHcxTURCTVhYK1BRcEJLTndxVUtPZjJERFJEVVhRZjlFaE9TMFFqNG5UbWxBOGR6U0x6L0cxZCtVZDhNVHkvNmdoaGRpTHBlZXJHWS9VbERPZml1cUZzTVVVNS9VWWxQK0JBbWdSTHVOcHZyVWFMbFZrcnFEaWV2TlZFQXdGKzRDb00xTVpUbWp4akpNc0tKcSt1OFpkN3ROQ1VGeTZMaXlZWFJKUTRWeXZFUUZGYUNHS3N4SXdRa2s3RXpaNkxUSnEyaFV1UGh2QVcrZ1FuU0c2SitNc3pDKzdRQ1JIY25xRGR5TlJKNlQ5eHlTODdBNk1EdXRiektHdkdrdHBiWHF0eld0WGI5SHNmSzJjQk1vbWpOOWE0eStUYUpMblh4QWVYL0hXem1mNGNSNHZBTHQvUDR3NHFnS1kwNG1sNFpkTE9pbkZZUzZjdXAzRy8xaWU0K3QxZU9ucEJObHFHcXM3NWlsemtUNCtEc1pReE52YVNLSi8vNnpJYmJrL003TE9oRm1SYy8xUitrQnR6N0pGR2RabS9DT290SWR2UW9YcFRxUC8xdXFFVW1DYi9RV29HTE13TzVBTmNIenhkWTQ4SUdQNStKK3pLT1RCRlo0UGlkK0dUTStXcTEyTVYvSDg2eEVKcHRCYTZUK3Aza2dwd0xlZE1hbkJIQzJHZ05yRnBvTjJ4bnJNejlXRldYLzgveWdTQmthdnEyVXY3RmRDc0xFWUx1OUxMSXZBVTBiTlJEdHpZbCsvdlhtanBJdnVKRllqbUkwaW02UUVZcW5JZU1zTmpYRzR2SXV0SUdIaWplQUcvOUVEQm96S1Y1Y2xka0hiTHhIaDI1dlQrWkV6YmhYbHF2cHpLSndjRWdmTndMQUtGZW8wL3B2RUUxMFhEQitFWFJUWHRTekpvelFLRkZBSmhNeFlrVmFDVytFOUFMN3RNZVU4YWN4aWRIcXpiNmxYNDY5MVVzRHB5L0xMUm1UK2VwZ1c1Nis1Q3c4dEI0a01VdjZzOWxoM2VSS2J5R3MrSC80bVFNYVl6UFRmMk9PZG9rRW4renpndm9EM0ZxTktrOFFxR0FYVnNxY0dkWHJUNjJmU1BrUjJ2Uk9GaTY4QTZzZTg2VXhSVWs0Y2FqZlB5Q0M0RzV3RGhEK3pOcTRqb2RRNHU0bi9tMzdMcjM2bjRMSUFBc1ZyMDJkRmk5QWl3QTgxTVlzMnJtNGVEbERObWRNUnZFS1JIZkJ3VzVEZE1OcDBqUEZaTWVBUnFGL3dMNFhCZmQrRU1MQmZNenBINUdINk5hVysxdnJ2TWRnK1Z4RHphdGszTVhnTzNybzNQL0RwY0M2K01vNE15U0poS0poU1IwMVNHR0dwNWhQV21yclVncnYzbERuUCtIaGNJM250M1lxQm9WQVZUQkFRVDVpdWhUZzhudlB0ZDhaZVlqNncxeDZScUdVQnJTa3U3K04xK0JhYXNadmpUazY0Um9JRGxMOGJycEVjSngzT21ZN2pMb1pzc3dkdG1oZkMvRzIxbGxYaElUT3dtdlJERGVUVFBieUFTT2ExNmNGNS9BMWZaQWlkSnBxanUzd1lBeTlhdlBSMXlhNmVOcDlLOFhZcnJ0dXhscWkrYkRLd2xmcllkUjBSUmlLUlZUTE9IODUrWlk3WFNtelJwZlpCSmphVGE4MVZEY0pIcFpuWm5TUUxBU0dZVzlsNTFaVi9oN2VWelRpM0h2NmhVc2djLzUxQXFKUlRrcGJGVkxYWHN6b0JMOG5CWDB1LzBqQkxUOG5IK2ZKZVBicndVUlQ1OE9ZK1VpZVJqZDF2czA0dzBWRzVWTjJVNk1vR1prUXpLTi9wdHowUTM2NmR4b1RHbWo3aTFOUUdIaTlHZ25xdVhGWWRyQ2ZaQm1lYjdzMFQ2eXJkbFpINWNadXdIRnlJSi9rQXRHc1RnMHhINXRhQUFxNDRCQWsxQ1BrOUtWVmJxUXpyQ1VpRmRGLzZndGxQUThiSEhjMUcxVzkyTVhHWjVIRUhmdHlMWXM4bWJELzl4WVJVV2tIbWxNMHpDMmlsSmxuTmdWNGJmQUxwUWdoeE9Vb1pMN1ZUcXRDSElhUVNYbStZVU1ucGtYeWJuVitBNnhsbTJDVnk4Zm4wWGxtMlhSYTArenpPYTIxSldXbWl4ZmlQTVNDWjdxQTRyUzkzVk4zcGtwRjFzNVRvblFqaXNIZjdpVTlaR3ZVUE9BS1pjUjFwYmVWZi9VbDdPaGVwR0NhSWQ5d090cW83cEo3eUxjQlowcEZrT0YyOHk0ekVJL2tjVU5tdXRCSGFRcEJkTk04dmpDUzZIWlJva2tlbzg4VEJBakd5RzdTUis2dlVnVGN5SzlJbWFsajBrdXh6MHdtSytieVFVMTFBaUpGay95YTVkTmR1UkNsY25VNjR5R3UvaWVXU2VPb3MxdDNlcCtSUElXUTJweVRZVmJabHRUYnNiN05pd1NpM0FWKzhLTFdrN0x4Q25mWlVldEVNOFRobnNTb0dIMzgvbnlBd0ZndUpwOEZqdmxIdGNXWnVVNGhQdmEwckhmcjBVaE9PSi9GNnZTNjJGVzdLemttUmxsMkhFYzdvVXE0ZnlpNVQ3MFZsN1lWSWZzUEhVQ2RIZXNmOUxrN1dOVldPNzVKRGtZYk1JOFRPVzhKS1Z0TFk5ZDZVSlJJVE84b0tvMHhTK285OVl5MDRpbmlHSEFhR2o4OGtFV2d3djBPckhkWS9ucjc2RE9HTlM1OWhYQ0dYelRLVXZEbDlpS3BMU1dZTjFseElleXl3ZE5wVGtoYXk3NHcyakZUNk5TOHFram81Q3hBMXlmU1l3cDZBSklaTktJZUVLNVBKQVc3T1JnV2d3cDBWZ3pZcHFvdk1yV3hidStER1o2TGhpZTFSQXFwem04VlV6S0pPSDNtQ3pXdVRPTHNOM1ZUL2R2MmVlWWU5VWpiUjhZVEJzTHo3cTYwVk4xc1U1MWsrdW0xZjhKeEQ1cFBoYmhTQzhyUmFCNDU0dG1oNllVV3JKSTMrR1dZMHFlV2lvai90YmtZSVRPa0phZXVHdDRKckp2SEErbDBHdTdrWTdYT2FhMDVhbE1uUldWQ1hxRmdMSXdTWTR1RjU5VWU1U1U0UUt1Yy9IYW1EeGJyMHg2Y3NDZXRYR29QN1FuMUJrL0o5RHN5bk8vVUQ2aVoxSHlyeitqaXQwaERDd2kvRTlPamdLVGJCM1pRS1EvMFpPdmV2Zk5IRzBOSzRBajNDcDdOcFJrMDdSVDFpL1MwRUw5M0FnOEdSZ0tJOUNmcGFqS3lLNitKai9QSTFLTzUvODVWQXd6MkF3elA4RlRCYjA3NUl4Q1h2NlQ5UlZ2V1QydFVhcXhEUzkyenJHVWJXelVZazltU3M4MnBFQ0grZmtxc0R0OTNWVysrNFlzUi9kSENZY1FTWVRPL0thQk1EajlMU0QvSi8rejIwS3E4WHZaVUFJSHRtOWhSUFAzSXRidUF1MkhtNWxrUHM5MnBkN2tDeGdSczB4T1ZCbloxM2NjZEEwYXVucnd2OVNkcUVsSlJDM2crb0N1K25YeUNnbVhVczl5TWpUTUFJSGZ4WlYrYVBLY1plVUJXdDA1N1hvODVLczFJcjVnekVIQ1dxWkVockxaTXVGMTF6aUd0RlFVZHMvRUVTYWpoYWd6Y0tzeGFtY1NaeEd0aDRVSUkrYWRQaFFrVW54Mld5Tis0WVdSK3IzZjhNbmt5R0Z1UjR6anp4SlM4V3NRWVI1UFR5UmFEOWl4YTZNaDc0MW5CSGJ6ZmpYSHNrR0RxMTc5eGFSTnJDSUIxejF4UmZXZmpxdzJwSGMxems5eGxQcEw4c1FXQUl1RVRaWmhibm1MNTRyY2VYVk5SdlVpS3JycUlrZW9nc2wwWFhiMTd5bE5iMGY0R0E5V2Q0NHZmZkVHOEZTWkdIRUwyZmJhVEdSY1NpQ2VBOFBtQS9mNkh6OEhDUzc2ZlhVSHdnd2t6U3dsSTcxZWtaN0ZhcG1say9LQytIczhoVWN3M04yTE41TGhrVll5aXpZRmwvdVBlVlA1bHNvSkhoaGZXdnZTV3J1Q1VXMVpjSk9ldVRickRneXdKL3FHMDdnWkpwbG5UdkxjWWROYUgwS01ZT1lNR1grckI0TkdQRm1Rc05hSXdsV3JmQ2V6eHJlOHpYQnJzTVQrZWRWTGJMcU4xQnFCNzZKSDRCdlpUcVVJTWZHd1BHRW4rRW5tVFY4NmZQQmFZYkZMM0RGRWhqQjQ1Q2V3a1hFQXRKeGs0L01zMnBQWG5hUnFka3kwSE9ZZGNVY0UyemNYcTR2YUl2VzIvdjBuSEZKSDJYWGUyMnVlRG1xLzE4WEd0RUxTcTg1ajlYOHEwdGNOU1NLSklYOEZUdUpGL1BmOGo1UGhxRzJ1K29zdnNMeFlydnZmZVZKTCs0dGtjWGNyOUpWN3YwRVJtai9YNmZNM05DNGo2ZFMxKzlVbXIyb1BhdnFpQXlkVFpQTE1OUkdZMjNMTzl6QVZEbHk3akQrNzBHNVRQUExkaFJJbDRXeGNZakxuTStTTmNKMjZGT3JrcklTVXRQT2JJejVaYjNBRzYxMmtybnB5MTVSTVcrMWNRamxuV0ZJNjUzOHFreTlheGQyb0ptSElIUDA4S3lQMHViR08rVFFOT1l1djJ1aDE3eUNJdlI4VmNTdHc3bzFnME5NNjBzays4VHE3WWZJQkpydHA1M0drdnpYSDdPQTBwOC9uL3Uxc2F0Zi9WSmh0UjFsOFdhNkdtYXVnN2hhU3BhQ2FZUWF4NnRhMG1rdXRsYitlQU9TRzFhb2JNODFEOUE0aVMxUlJsekJCb1ZYNnRVMVM2V0UyTjlPUlk2RGZlTFJDNGw5UnZyNWg5NVhEV0IybVIxZDRXRnVkcHNnVll3aVR3VDMxbGpza0Q4WnlET2xtNURrR2g5Ti9VQi8wQUk1WHZiOFpCbWFpMmhRNEJXTXFGd1luenh3QjI2WUhTT3Y5V2dZM0pYbnZvTisyUjRycUdWaC9MTERNdHBGUCtTcE1HSk5XdmJJbDVTT29kYkNjelcyUktsZWtzUG9VZUdFenJqdEtIVmR0WkEra2ZxTytyVngvaWNsQ3F3b29wZXB2SnBTVERqVCtiOUdXeWxHUkY4RURiR2x3NmVVem1KTTk1T3Zveitrd0xYM2MyZlRqRmVZRXNFN3ZVWm0zbXFkR0p1S2gydzkvUUdTYXFSSHM5OWFTY0dPZERxa0ZjQUNvcWRiQm9RcXFqYW1oSDZROW5nMzlKQ2czbHJHSndkNTBRazlvdm5xQlRyOE1NRTdQczJ3aVZmeWdVbVBvVUJKSmZKV1g1TmRhMG51bmNiRmtBPT0nKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmNsdWRlLmpzLm1hcCIsIi8qKlxuICogTUlUIExpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgQW5kcmV3IFJhZmZlbnNwZXJnZXJcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICpcbiAqIFRoaXMgaXMgYSBuZWFyIGNhcmJvbi1jb3B5IG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgKGxpbmsgYmVsb3cpIHdpdGggdGhlXG4gKiBUeXBlU2NyaXB0IHR5cGluZ3MgYWRkZWQgYW5kIGEgZmV3IHR3ZWFrcyB0byBtYWtlIGl0IEVTMy1jb21wYXRpYmxlLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qc1xuICovXG5pbXBvcnQgeyB0b1V0ZjhDb2RlUG9pbnRzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGdldERhdGEgfSBmcm9tICcuL2luY2x1ZGUuanMnO1xuY29uc3QgciA9IGdldERhdGEoKTtcbmltcG9ydCB7IHJlYWRfbWVtYmVyX2FycmF5LCByZWFkX21hcHBlZF9tYXAsIHJlYWRfZW1vamlfdHJpZSB9IGZyb20gJy4vZGVjb2Rlci5qcyc7XG4vLyBAVE9ETzogVGhpcyBzaG91bGQgYmUgbGF6aWx5IGxvYWRlZFxuY29uc3QgVkFMSUQgPSBuZXcgU2V0KHJlYWRfbWVtYmVyX2FycmF5KHIpKTtcbmNvbnN0IElHTk9SRUQgPSBuZXcgU2V0KHJlYWRfbWVtYmVyX2FycmF5KHIpKTtcbmNvbnN0IE1BUFBFRCA9IHJlYWRfbWFwcGVkX21hcChyKTtcbmNvbnN0IEVNT0pJX1JPT1QgPSByZWFkX2Vtb2ppX3RyaWUocik7XG4vL2NvbnN0IE5GQ19DSEVDSyA9IG5ldyBTZXQocmVhZF9tZW1iZXJfYXJyYXkociwgQXJyYXkuZnJvbShWQUxJRC52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpKSk7XG4vL2NvbnN0IFNUT1AgPSAweDJFO1xuY29uc3QgSFlQSEVOID0gMHgyRDtcbmNvbnN0IFVOREVSU0NPUkUgPSAweDVGO1xuZnVuY3Rpb24gZXhwbG9kZV9jcChuYW1lKSB7XG4gICAgcmV0dXJuIHRvVXRmOENvZGVQb2ludHMobmFtZSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJfZmUwZihjcHMpIHtcbiAgICByZXR1cm4gY3BzLmZpbHRlcihjcCA9PiBjcCAhPSAweEZFMEYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc19ub3JtYWxpemVfcG9zdF9jaGVjayhuYW1lKSB7XG4gICAgZm9yIChsZXQgbGFiZWwgb2YgbmFtZS5zcGxpdCgnLicpKSB7XG4gICAgICAgIGxldCBjcHMgPSBleHBsb2RlX2NwKGxhYmVsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBjcHMubGFzdEluZGV4T2YoVU5ERVJTQ09SRSkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChjcHNbaV0gIT09IFVOREVSU0NPUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmRlcnNjb3JlIG9ubHkgYWxsb3dlZCBhdCBzdGFydGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcHMubGVuZ3RoID49IDQgJiYgY3BzLmV2ZXJ5KGNwID0+IGNwIDwgMHg4MCkgJiYgY3BzWzJdID09PSBIWVBIRU4gJiYgY3BzWzNdID09PSBIWVBIRU4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgbGFiZWwgZXh0ZW5zaW9uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGxhYmVsIFwiJHtsYWJlbH1cIjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnNfbm9ybWFsaXplKG5hbWUpIHtcbiAgICByZXR1cm4gZW5zX25vcm1hbGl6ZV9wb3N0X2NoZWNrKG5vcm1hbGl6ZShuYW1lLCBmaWx0ZXJfZmUwZikpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGVtb2ppX2ZpbHRlcikge1xuICAgIGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobmFtZSkucmV2ZXJzZSgpOyAvLyBmbGlwIGZvciBwb3BcbiAgICBsZXQgb3V0cHV0ID0gW107XG4gICAgd2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0KTtcbiAgICAgICAgaWYgKGVtb2ppKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCguLi5lbW9qaV9maWx0ZXIoZW1vamkpKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjcCA9IGlucHV0LnBvcCgpO1xuICAgICAgICBpZiAoVkFMSUQuaGFzKGNwKSkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY3ApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElHTk9SRUQuaGFzKGNwKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNwcyA9IE1BUFBFRFtjcF07XG4gICAgICAgIGlmIChjcHMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKC4uLmNwcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2FsbG93ZWQgY29kZXBvaW50OiAweCR7Y3AudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgfVxuICAgIHJldHVybiBlbnNfbm9ybWFsaXplX3Bvc3RfY2hlY2sobmZjKFN0cmluZy5mcm9tQ29kZVBvaW50KC4uLm91dHB1dCkpKTtcbn1cbmZ1bmN0aW9uIG5mYyhzKSB7XG4gICAgcmV0dXJuIHMubm9ybWFsaXplKCdORkMnKTtcbn1cbmZ1bmN0aW9uIGNvbnN1bWVfZW1vamlfcmV2ZXJzZWQoY3BzLCBlYXRlbikge1xuICAgIHZhciBfYTtcbiAgICBsZXQgbm9kZSA9IEVNT0pJX1JPT1Q7XG4gICAgbGV0IGVtb2ppO1xuICAgIGxldCBzYXZlZDtcbiAgICBsZXQgc3RhY2sgPSBbXTtcbiAgICBsZXQgcG9zID0gY3BzLmxlbmd0aDtcbiAgICBpZiAoZWF0ZW4pXG4gICAgICAgIGVhdGVuLmxlbmd0aCA9IDA7IC8vIGNsZWFyIGlucHV0IGJ1ZmZlciAoaWYgbmVlZGVkKVxuICAgIHdoaWxlIChwb3MpIHtcbiAgICAgICAgbGV0IGNwID0gY3BzWy0tcG9zXTtcbiAgICAgICAgbm9kZSA9IChfYSA9IG5vZGUuYnJhbmNoZXMuZmluZCh4ID0+IHguc2V0LmhhcyhjcCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChub2RlLnNhdmUpIHsgLy8gcmVtZW1iZXJcbiAgICAgICAgICAgIHNhdmVkID0gY3A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5jaGVjaykgeyAvLyBjaGVjayBleGNsdXNpb25cbiAgICAgICAgICAgIGlmIChjcCA9PT0gc2F2ZWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChjcCk7XG4gICAgICAgIGlmIChub2RlLmZlMGYpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goMHhGRTBGKTtcbiAgICAgICAgICAgIGlmIChwb3MgPiAwICYmIGNwc1twb3MgLSAxXSA9PSAweEZFMEYpXG4gICAgICAgICAgICAgICAgcG9zLS07IC8vIGNvbnN1bWUgb3B0aW9uYWwgRkUwRlxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnZhbGlkKSB7IC8vIHRoaXMgaXMgYSB2YWxpZCBlbW9qaSAoc28gZmFyKVxuICAgICAgICAgICAgZW1vamkgPSBzdGFjay5zbGljZSgpOyAvLyBjb3B5IHN0YWNrXG4gICAgICAgICAgICBpZiAobm9kZS52YWxpZCA9PSAyKVxuICAgICAgICAgICAgICAgIGVtb2ppLnNwbGljZSgxLCAxKTsgLy8gZGVsZXRlIEZFMEYgYXQgcG9zaXRpb24gMSAoUkdJIFpXSiBkb24ndCBmb2xsb3cgc3BlYyEpXG4gICAgICAgICAgICBpZiAoZWF0ZW4pXG4gICAgICAgICAgICAgICAgZWF0ZW4ucHVzaCguLi5jcHMuc2xpY2UocG9zKS5yZXZlcnNlKCkpOyAvLyBjb3B5IGlucHV0IChpZiBuZWVkZWQpXG4gICAgICAgICAgICBjcHMubGVuZ3RoID0gcG9zOyAvLyB0cnVuY2F0ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbW9qaTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpYi5qcy5tYXAiLCJpbXBvcnQgeyBjb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgZW5zX25vcm1hbGl6ZSB9IGZyb20gXCIuL2Vucy1ub3JtYWxpemUvbGliXCI7XG5jb25zdCBaZXJvcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcblplcm9zLmZpbGwoMCk7XG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudChjb21wKSB7XG4gICAgaWYgKGNvbXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXA7XG59XG5mdW5jdGlvbiBlbnNOYW1lU3BsaXQobmFtZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXMoZW5zX25vcm1hbGl6ZShuYW1lKSk7XG4gICAgY29uc3QgY29tcHMgPSBbXTtcbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH1cbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkID0gYnl0ZXNbaV07XG4gICAgICAgIC8vIEEgc2VwYXJhdG9yIChpLmUuIFwiLlwiKTsgY29weSB0aGlzIGNvbXBvbmVudFxuICAgICAgICBpZiAoZCA9PT0gMHgyZSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0LCBpKSkpO1xuICAgICAgICAgICAgbGFzdCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlIHdhcyBhIHN0cmF5IHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBuYW1lXG4gICAgaWYgKGxhc3QgPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgRU5TIG5hbWU7IGVtcHR5IGNvbXBvbmVudFwiKTtcbiAgICB9XG4gICAgY29tcHMucHVzaChjaGVja0NvbXBvbmVudChieXRlcy5zbGljZShsYXN0KSkpO1xuICAgIHJldHVybiBjb21wcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnNOb3JtYWxpemUobmFtZSkge1xuICAgIHJldHVybiBlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB0b1V0ZjhTdHJpbmcoY29tcCkpLmpvaW4oXCIuXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKGVuc05hbWVTcGxpdChuYW1lKS5sZW5ndGggIT09IDApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuYW1laGFzaChuYW1lKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWU7IG5vdCBhIHN0cmluZ1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICBjb25zdCBjb21wcyA9IGVuc05hbWVTcGxpdChuYW1lKTtcbiAgICB3aGlsZSAoY29tcHMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KGNvbXBzLnBvcCgpKV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkbnNFbmNvZGUobmFtZSkge1xuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChlbnNOYW1lU3BsaXQobmFtZSkubWFwKChjb21wKSA9PiB7XG4gICAgICAgIC8vIEROUyBkb2VzIG5vdCBhbGxvdyBjb21wb25lbnRzIG92ZXIgNjMgYnl0ZXMgaW4gbGVuZ3RoXG4gICAgICAgIGlmIChjb21wLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEROUyBlbmNvZGVkIGVudHJ5OyBsZW5ndGggZXhjZWVkcyA2MyBieXRlc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNvbXAubGVuZ3RoICsgMSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wLCAxKTtcbiAgICAgICAgYnl0ZXNbMF0gPSBieXRlcy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSkpKSArIFwiMDBcIjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWVoYXNoLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJuZXR3b3Jrcy81LjcuMVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG5mdW5jdGlvbiBpc1JlbmV0d29ya2FibGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiAodmFsdWUucmVuZXR3b3JrKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKSB7XG4gICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTGlzdCA9IFtdO1xuICAgICAgICBpZiAocHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyICYmIG9wdGlvbnMuaW5mdXJhICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkluZnVyYVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuaW5mdXJhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIgJiYgb3B0aW9ucy5ldGhlcnNjYW4gIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5ldGhlcnNjYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIgJiYgb3B0aW9ucy5hbGNoZW15ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmFsY2hlbXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5Qb2NrZXRQcm92aWRlciAmJiBvcHRpb25zLnBvY2tldCAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIG5ldHdvcmtzIGFyZSBjdXJyZW50bHkgZmF1bHR5IG9uIFBvY2tldCBhcyB0aGVpclxuICAgICAgICAgICAgLy8gbmV0d29yayBkb2VzIG5vdCBoYW5kbGUgdGhlIEJlcmxpbiBoYXJkZm9yaywgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGxpdmUgb24gdGhlc2Ugb25lcy5cbiAgICAgICAgICAgIC8vIEBUT0RPOiBUaGlzIGdvZXMgYXdheSBvbmNlIFBvY2tldCBoYXMgdXBncmFkZWQgdGhlaXIgbm9kZXNcbiAgICAgICAgICAgIGNvbnN0IHNraXAgPSBbXCJnb2VybGlcIiwgXCJyb3BzdGVuXCIsIFwicmlua2VieVwiLCBcInNlcG9saWFcIl07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5Qb2NrZXRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLnBvY2tldCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm5ldHdvcmsgJiYgc2tpcC5pbmRleE9mKHByb3ZpZGVyLm5ldHdvcmsubmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyICYmIG9wdGlvbnMuY2xvdWRmbGFyZSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkFua3JQcm92aWRlciAmJiBvcHRpb25zLmFua3IgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNraXAgPSBbXCJyb3BzdGVuXCJdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHByb3ZpZGVycy5BbmtyUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbmtyKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvdmlkZXIubmV0d29yayAmJiBza2lwLmluZGV4T2YocHJvdmlkZXIubmV0d29yay5uYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVyTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICAgICAgbGV0IHF1b3J1bSA9IDE7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdW9ydW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHF1b3J1bSA9IG9wdGlvbnMucXVvcnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmV0d29yayA9PT0gXCJob21lc3RlYWRcIikge1xuICAgICAgICAgICAgICAgIHF1b3J1bSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVyTGlzdCwgcXVvcnVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvdmlkZXJMaXN0WzBdO1xuICAgIH07XG4gICAgZnVuYy5yZW5ldHdvcmsgPSBmdW5jdGlvbiAobmV0d29yaykge1xuICAgICAgICByZXR1cm4gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmM7XG59XG5mdW5jdGlvbiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG4gICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcih1cmwsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgZnVuYy5yZW5ldHdvcmsgPSBmdW5jdGlvbiAobmV0d29yaykge1xuICAgICAgICByZXR1cm4gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmNvbnN0IGhvbWVzdGVhZCA9IHtcbiAgICBjaGFpbklkOiAxLFxuICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgbmFtZTogXCJob21lc3RlYWRcIixcbiAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJob21lc3RlYWRcIilcbn07XG5jb25zdCByb3BzdGVuID0ge1xuICAgIGNoYWluSWQ6IDMsXG4gICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICBuYW1lOiBcInJvcHN0ZW5cIixcbiAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyb3BzdGVuXCIpXG59O1xuY29uc3QgY2xhc3NpY01vcmRvciA9IHtcbiAgICBjaGFpbklkOiA2MyxcbiAgICBuYW1lOiBcImNsYXNzaWNNb3Jkb3JcIixcbiAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL21vcmRvclwiLCBcImNsYXNzaWNNb3Jkb3JcIilcbn07XG4vLyBTZWU6IGh0dHBzOi8vY2hhaW5saXN0Lm9yZ1xuY29uc3QgbmV0d29ya3MgPSB7XG4gICAgdW5zcGVjaWZpZWQ6IHsgY2hhaW5JZDogMCwgbmFtZTogXCJ1bnNwZWNpZmllZFwiIH0sXG4gICAgaG9tZXN0ZWFkOiBob21lc3RlYWQsXG4gICAgbWFpbm5ldDogaG9tZXN0ZWFkLFxuICAgIG1vcmRlbjogeyBjaGFpbklkOiAyLCBuYW1lOiBcIm1vcmRlblwiIH0sXG4gICAgcm9wc3Rlbjogcm9wc3RlbixcbiAgICB0ZXN0bmV0OiByb3BzdGVuLFxuICAgIHJpbmtlYnk6IHtcbiAgICAgICAgY2hhaW5JZDogNCxcbiAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICAgICAgbmFtZTogXCJyaW5rZWJ5XCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJpbmtlYnlcIilcbiAgICB9LFxuICAgIGtvdmFuOiB7XG4gICAgICAgIGNoYWluSWQ6IDQyLFxuICAgICAgICBuYW1lOiBcImtvdmFuXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImtvdmFuXCIpXG4gICAgfSxcbiAgICBnb2VybGk6IHtcbiAgICAgICAgY2hhaW5JZDogNSxcbiAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICAgICAgbmFtZTogXCJnb2VybGlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiZ29lcmxpXCIpXG4gICAgfSxcbiAgICBraW50c3VnaTogeyBjaGFpbklkOiAxMzM3NzAyLCBuYW1lOiBcImtpbnRzdWdpXCIgfSxcbiAgICBzZXBvbGlhOiB7XG4gICAgICAgIGNoYWluSWQ6IDExMTU1MTExLFxuICAgICAgICBuYW1lOiBcInNlcG9saWFcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwic2Vwb2xpYVwiKVxuICAgIH0sXG4gICAgLy8gRVRDIChTZWU6ICMzNTEpXG4gICAgY2xhc3NpYzoge1xuICAgICAgICBjaGFpbklkOiA2MSxcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi9cXC93d3cuZXRoZXJjbHVzdGVyLmNvbS9ldGNcIiwgXCJjbGFzc2ljXCIpXG4gICAgfSxcbiAgICBjbGFzc2ljTW9yZGVuOiB7IGNoYWluSWQ6IDYyLCBuYW1lOiBcImNsYXNzaWNNb3JkZW5cIiB9LFxuICAgIGNsYXNzaWNNb3Jkb3I6IGNsYXNzaWNNb3Jkb3IsXG4gICAgY2xhc3NpY1Rlc3RuZXQ6IGNsYXNzaWNNb3Jkb3IsXG4gICAgY2xhc3NpY0tvdHRpOiB7XG4gICAgICAgIGNoYWluSWQ6IDYsXG4gICAgICAgIG5hbWU6IFwiY2xhc3NpY0tvdHRpXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi9cXC93d3cuZXRoZXJjbHVzdGVyLmNvbS9rb3R0aVwiLCBcImNsYXNzaWNLb3R0aVwiKVxuICAgIH0sXG4gICAgeGRhaTogeyBjaGFpbklkOiAxMDAsIG5hbWU6IFwieGRhaVwiIH0sXG4gICAgbWF0aWM6IHtcbiAgICAgICAgY2hhaW5JZDogMTM3LFxuICAgICAgICBuYW1lOiBcIm1hdGljXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcIm1hdGljXCIpXG4gICAgfSxcbiAgICBtYXRpY211bTogeyBjaGFpbklkOiA4MDAwMSwgbmFtZTogXCJtYXRpY211bVwiIH0sXG4gICAgb3B0aW1pc206IHtcbiAgICAgICAgY2hhaW5JZDogMTAsXG4gICAgICAgIG5hbWU6IFwib3B0aW1pc21cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwib3B0aW1pc21cIilcbiAgICB9LFxuICAgIFwib3B0aW1pc20ta292YW5cIjogeyBjaGFpbklkOiA2OSwgbmFtZTogXCJvcHRpbWlzbS1rb3ZhblwiIH0sXG4gICAgXCJvcHRpbWlzbS1nb2VybGlcIjogeyBjaGFpbklkOiA0MjAsIG5hbWU6IFwib3B0aW1pc20tZ29lcmxpXCIgfSxcbiAgICBhcmJpdHJ1bTogeyBjaGFpbklkOiA0MjE2MSwgbmFtZTogXCJhcmJpdHJ1bVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1yaW5rZWJ5XCI6IHsgY2hhaW5JZDogNDIxNjExLCBuYW1lOiBcImFyYml0cnVtLXJpbmtlYnlcIiB9LFxuICAgIFwiYXJiaXRydW0tZ29lcmxpXCI6IHsgY2hhaW5JZDogNDIxNjEzLCBuYW1lOiBcImFyYml0cnVtLWdvZXJsaVwiIH0sXG4gICAgYm5iOiB7IGNoYWluSWQ6IDU2LCBuYW1lOiBcImJuYlwiIH0sXG4gICAgYm5idDogeyBjaGFpbklkOiA5NywgbmFtZTogXCJibmJ0XCIgfSxcbn07XG4vKipcbiAqICBnZXROZXR3b3JrXG4gKlxuICogIENvbnZlcnRzIGEgbmFtZWQgY29tbW9uIG5ldHdvcmtzIG9yIGNoYWluIElEIChuZXR3b3JrIElEKSB0byBhIE5ldHdvcmtcbiAqICBhbmQgdmVyaWZpZXMgYSBuZXR3b3JrIGlzIGEgdmFsaWQgTmV0d29yay4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXR3b3JrKG5ldHdvcmspIHtcbiAgICAvLyBObyBuZXR3b3JrIChudWxsKVxuICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBuZXR3b3Jrcykge1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZC5jaGFpbklkID09PSBuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogc3RhbmRhcmQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgZW5zQWRkcmVzczogKHN0YW5kYXJkLmVuc0FkZHJlc3MgfHwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IChzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hhaW5JZDogbmV0d29yayxcbiAgICAgICAgICAgIG5hbWU6IFwidW5rbm93blwiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkID0gbmV0d29ya3NbbmV0d29ya107XG4gICAgICAgIGlmIChzdGFuZGFyZCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogc3RhbmRhcmQubmFtZSxcbiAgICAgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkLmNoYWluSWQsXG4gICAgICAgICAgICBlbnNBZGRyZXNzOiBzdGFuZGFyZC5lbnNBZGRyZXNzLFxuICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrLm5hbWVdO1xuICAgIC8vIE5vdCBhIHN0YW5kYXJkIG5ldHdvcms7IGNoZWNrIHRoYXQgaXQgaXMgYSB2YWxpZCBuZXR3b3JrIGluIGdlbmVyYWxcbiAgICBpZiAoIXN0YW5kYXJkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG5ldHdvcmsuY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG5ldHdvcmsgY2hhaW5JZFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2hhaW5JZCBtYXRjaGVzIHRoZSBleHBlY3RlZCBuZXR3b3JrIGNoYWluSWQgKG9yIGlzIDA7IGRpc2FibGUgRUlQLTE1NSlcbiAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSAwICYmIG5ldHdvcmsuY2hhaW5JZCAhPT0gc3RhbmRhcmQuY2hhaW5JZCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibmV0d29yayBjaGFpbklkIG1pc21hdGNoXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gYWRkIGFuIGF0dGFjaCBmdW5jdGlvbiB0byBhIGRlZmF1bHRQcm92aWRlclxuICAgIC8vIGNsYXNzIGFuZCBtb3ZlIHRoZSBfZGVmYXVsdFByb3ZpZGVyIGludGVybmFsIHRvIHRoaXMgZmlsZSAoZXh0ZW5kIE5ldHdvcmspXG4gICAgbGV0IGRlZmF1bHRQcm92aWRlciA9IG5ldHdvcmsuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsO1xuICAgIGlmIChkZWZhdWx0UHJvdmlkZXIgPT0gbnVsbCAmJiBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSB7XG4gICAgICAgIGlmIChpc1JlbmV0d29ya2FibGUoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcikpIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIucmVuZXR3b3JrKG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdGFuZGFyZCBOZXR3b3JrIChhbGxvdyBvdmVycmlkaW5nIHRoZSBFTlMgYWRkcmVzcylcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuZXR3b3JrLm5hbWUsXG4gICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkLmNoYWluSWQsXG4gICAgICAgIGVuc0FkZHJlc3M6IChuZXR3b3JrLmVuc0FkZHJlc3MgfHwgc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZGVmYXVsdFByb3ZpZGVyXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCB2YXIgU3VwcG9ydGVkQWxnb3JpdGhtO1xuKGZ1bmN0aW9uIChTdXBwb3J0ZWRBbGdvcml0aG0pIHtcbiAgICBTdXBwb3J0ZWRBbGdvcml0aG1bXCJzaGEyNTZcIl0gPSBcInNoYTI1NlwiO1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTUxMlwiXSA9IFwic2hhNTEyXCI7XG59KShTdXBwb3J0ZWRBbGdvcml0aG0gfHwgKFN1cHBvcnRlZEFsZ29yaXRobSA9IHt9KSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwic2hhMi81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgaGFzaCBmcm9tIFwiaGFzaC5qc1wiO1xuLy9jb25zdCBfcmlwZW1kMTYwID0gX2hhc2gucmlwZW1kMTYwO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IFN1cHBvcnRlZEFsZ29yaXRobSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2gucmlwZW1kMTYwKCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1NihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTI1NigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGE1MTIoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGE1MTIoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUhtYWMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcbiAgICBpZiAoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtIFwiICsgYWxnb3JpdGhtLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImhtYWNcIixcbiAgICAgICAgICAgIGFsZ29yaXRobTogYWxnb3JpdGhtXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgaGFzaC5obWFjKGhhc2hbYWxnb3JpdGhtXSwgYXJyYXlpZnkoa2V5KSkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCIsImV4cG9ydCBjb25zdCBBZGRyZXNzWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRyZXNzZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzLCBnZXRDb250cmFjdEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEFkZHJlc3NaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSwgcGFyc2UgYXMgcGFyc2VUcmFuc2FjdGlvbiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBjbGFzcyBGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB0aGlzLmdldERlZmF1bHRGb3JtYXRzKCk7XG4gICAgfVxuICAgIGdldERlZmF1bHRGb3JtYXRzKCkge1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gKHt9KTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBiaWdOdW1iZXIgPSB0aGlzLmJpZ051bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgc3RyaWN0RGF0YSA9ICh2KSA9PiB7IHJldHVybiB0aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hY2Nlc3NMaXN0LmJpbmQodGhpcyksIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpXG4gICAgICAgICAgICAvLyBtdXN0IGJlIHNldFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBub25jZTogbnVtYmVyLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHM6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHY6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICByYXc6IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd051bGwoc3RyaWN0RGF0YSksXG4gICAgICAgICAgICB0eXBlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5yZWNlaXB0TG9nID0ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICAgICAgICAgIHJvb3Q6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGxvZ3M6IEZvcm1hdHRlci5hcnJheU9mKHRoaXMucmVjZWlwdExvZy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHN0YXR1czogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrID0ge1xuICAgICAgICAgICAgaGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG4gICAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRoaXMuZGlmZmljdWx0eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIG1pbmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBkYXRhLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IHNoYWxsb3dDb3B5KGZvcm1hdHMuYmxvY2spO1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucy50cmFuc2FjdGlvbnMgPSBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKHRoaXMudHJhbnNhY3Rpb25SZXNwb25zZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuICAgICAgICAgICAgZnJvbUJsb2NrOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgYWRkcmVzczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudG9waWNzLmJpbmQodGhpcyksIHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyTG9nID0ge1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5ib29sZWFuLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd0ZhbHNpc2goZGF0YSwgXCIweFwiKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9XG4gICAgYWNjZXNzTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KGFjY2Vzc0xpc3QgfHwgW10pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgbnVtYmVyKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIHR5cGUobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGJpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGJvb2xlYW4sIFwidHJ1ZVwiIG9yICBcImZhbHNlXCI7IHJldHVybnMgYSBib29sZWFuXG4gICAgYm9vbGVhbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvb2xlYW4gLSBcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgaGV4KHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YTsgb2RkLWxlbmd0aCAtIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3NcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNhbGxBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUsIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKHZhbHVlLCAxMikpO1xuICAgICAgICByZXR1cm4gKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSA/IG51bGwgOiBhZGRyZXNzO1xuICAgIH1cbiAgICBjb250cmFjdEFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBibG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOiByZXR1cm4gXCIweDBcIjtcbiAgICAgICAgICAgIGNhc2UgXCJsYXRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwZW5kaW5nXCI6XG4gICAgICAgICAgICBjYXNlIFwic2FmZVwiOlxuICAgICAgICAgICAgY2FzZSBcImZpbmFsaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VmFsdWUoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGEgaGFzaCwgb3B0aW9uYWxseSByZXF1aXJlcyAweCBwcmVmaXg7IHJldHVybnMgcHJlZml4ZWQgbG93ZXJjYXNlIGhhc2guXG4gICAgaGFzaCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICE9PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgZGlmZmljdWx0eSBhcyBhIG51bWJlciwgb3IgaWYgdG9vIGxhcmdlIChpLmUuIFBvQSBuZXR3b3JrKSBudWxsXG4gICAgZGlmZmljdWx0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVpbnQyNTYodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuICAgIH1cbiAgICBfYmxvY2sodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUubWluZXIgPSB2YWx1ZS5hdXRob3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuICAgICAgICBjb25zdCBkaWZmaWN1bHR5ID0gKHZhbHVlLl9kaWZmaWN1bHR5ICE9IG51bGwpID8gdmFsdWUuX2RpZmZpY3VsdHkgOiB2YWx1ZS5kaWZmaWN1bHR5O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2soZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIHJlc3VsdC5fZGlmZmljdWx0eSA9ICgoZGlmZmljdWx0eSA9PSBudWxsKSA/IG51bGwgOiBCaWdOdW1iZXIuZnJvbShkaWZmaWN1bHR5KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGJsb2NrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrKTtcbiAgICB9XG4gICAgYmxvY2tXaXRoVHJhbnNhY3Rpb25zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICB0cmFuc2FjdGlvblJlcXVlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uUmVzcG9uc2UodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gUmVuYW1lIGdhcyB0byBnYXNMaW1pdFxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0cmFuc2FjdGlvbi5nYXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgICAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gJiYgQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24udG8pLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuYW1lIGlucHV0IHRvIGRhdGFcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gPT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5jcmVhdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPSB0aGlzLmNvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0cmFuc2FjdGlvbi50eXBlID09PSAxIHx8IHRyYW5zYWN0aW9uLnR5cGUgPT09IDIpICYmIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLm5ldHdvcmtJZDtcbiAgICAgICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIHJlc3VsdC5ibG9ja0hhc2gucmVwbGFjZSgvMC9nLCBcIlwiKSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmVjZWlwdExvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0LCB2YWx1ZSk7XG4gICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcbiAgICAgICAgaWYgKHJlc3VsdC5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucm9vdC5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgaWYgYm90aCBhcmUgc3BlY2lmaWVkLCB0aGV5IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwgJiYgKHJlc3VsdC5zdGF0dXMgIT09IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZVwiLCB7IHJvb3Q6IHJlc3VsdC5yb290LCBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhbHQtcm9vdC1zdGF0dXNcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucm9vdC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBhIHZhbGlkIGJ5dGVzMzJcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByb290IGhhc2hcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b3BpY3ModmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLnRvcGljcyh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbHRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZmlsdGVyTG9nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZywgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2soZm9ybWF0LCBvYmplY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdFtrZXldKG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBpZiB2YWx1ZSBpcyBudWxsLWlzaCwgbnVsbFZhbHVlIGlzIHJldHVybmVkXG4gICAgc3RhdGljIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd0ZhbHNpc2goZm9ybWF0LCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBBcnJheSBzYXRpc2Z5aW5nIGNoZWNrXG4gICAgc3RhdGljIGFycmF5T2YoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW11bml0eVJlc291cmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0NvbW11bml0eVJlc291cmNhYmxlKHZhbHVlKSAmJiB2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKCkpO1xufVxuLy8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2VcbmxldCB0aHJvdHRsZU1lc3NhZ2UgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCkge1xuICAgIGlmICh0aHJvdHRsZU1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdHRsZU1lc3NhZ2UgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIGRlZmF1bHQgQVBJIGtleXMgZm9yIGVhY2ggc2VydmljZSBhcmUgcHJvdmlkZWQgYXMgYSBoaWdobHktdGhyb3R0bGVkLFwiKTtcbiAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIldoaWxlIHlvdXIgYXBwbGljYXRpb24gd2lsbCBjb250aW51ZSB0byBmdW5jdGlvbiwgd2UgaGlnaGx5IHJlY29tbWVuZGVkXCIpO1xuICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcbiAgICBjb25zb2xlLmxvZyhcInJlcXVlc3QgcmF0ZS9saW1pdCBhbmQgZW5hYmxlIG90aGVyIHBlcmtzLCBzdWNoIGFzIG1ldHJpY3MgYW5kIGFkdmFuY2VkIEFQSXMuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGb3JrRXZlbnQsIFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBlbmNvZGUgYXMgYmFzZTY0RW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2V4XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4bGlmeSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBIYXNoWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGRuc0VuY29kZSwgbmFtZWhhc2ggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IGJlY2gzMiBmcm9tIFwiYmVjaDMyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBGb3JtYXR0ZXIgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmNvbnN0IE1BWF9DQ0lQX1JFRElSRUNUUyA9IDEwO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFdmVudCBTZXJpYWxpemVpbmdcbmZ1bmN0aW9uIGNoZWNrVG9waWModG9waWMpIHtcbiAgICBpZiAodG9waWMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGlmIChoZXhEYXRhTGVuZ3RoKHRvcGljKSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdG9waWNcIiwgXCJ0b3BpY1wiLCB0b3BpYyk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpYy50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVG9waWNzKHRvcGljcykge1xuICAgIC8vIFJlbW92ZSB0cmFpbGluZyBudWxsIEFORC10b3BpY3M7IHRoZXkgYXJlIHJlZHVuZGFudFxuICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoID4gMCAmJiB0b3BpY3NbdG9waWNzLmxlbmd0aCAtIDFdID09IG51bGwpIHtcbiAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdG9waWNzLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9waWMpKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHRyYWNrIHVuaXF1ZSBPUi10b3BpY3NcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZSA9IHt9O1xuICAgICAgICAgICAgdG9waWMuZm9yRWFjaCgodG9waWMpID0+IHtcbiAgICAgICAgICAgICAgICB1bmlxdWVbY2hlY2tUb3BpYyh0b3BpYyldID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIE9SLXRvcGljcyBkb2VzIG5vdCBtYXR0ZXJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZSk7XG4gICAgICAgICAgICBzb3J0ZWQuc29ydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1RvcGljKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH0pLmpvaW4oXCImXCIpO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVUb3BpY3MoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3BsaXQoLyYvZykubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wcyA9IHRvcGljLnNwbGl0KFwifFwiKS5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCh0b3BpYyA9PT0gXCJudWxsXCIpID8gbnVsbCA6IHRvcGljKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKGNvbXBzLmxlbmd0aCA9PT0gMSkgPyBjb21wc1swXSA6IGNvbXBzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50VGFnKGV2ZW50TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKGV2ZW50TmFtZSkgPT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0eDpcIiArIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoXCI6XCIpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOio6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoRm9ya0V2ZW50LmlzRm9ya0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnROYW1lICYmIHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6XCIgKyAoZXZlbnROYW1lLmFkZHJlc3MgfHwgXCIqXCIpICsgXCI6XCIgKyBzZXJpYWxpemVUb3BpY3MoZXZlbnROYW1lLnRvcGljcyB8fCBbXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZXZlbnQgLSBcIiArIGV2ZW50TmFtZSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlciBPYmplY3RcbmZ1bmN0aW9uIGdldFRpbWUoKSB7XG4gICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG59XG5mdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICB9KTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUHJvdmlkZXIgT2JqZWN0XG4vKipcbiAqICBFdmVudFR5cGVcbiAqICAgLSBcImJsb2NrXCJcbiAqICAgLSBcInBvbGxcIlxuICogICAtIFwiZGlkUG9sbFwiXG4gKiAgIC0gXCJwZW5kaW5nXCJcbiAqICAgLSBcImVycm9yXCJcbiAqICAgLSBcIm5ldHdvcmtcIlxuICogICAtIGZpbHRlclxuICogICAtIHRvcGljcyBhcnJheVxuICogICAtIHRyYW5zYWN0aW9uIGhhc2hcbiAqL1xuY29uc3QgUG9sbGFibGVFdmVudHMgPSBbXCJibG9ja1wiLCBcIm5ldHdvcmtcIiwgXCJwZW5kaW5nXCIsIFwicG9sbFwiXTtcbmV4cG9ydCBjbGFzcyBFdmVudCB7XG4gICAgY29uc3RydWN0b3IodGFnLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImxpc3RlbmVyXCIsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJvbmNlXCIsIG9uY2UpO1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwidHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gY29tcHNbMV07XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IGRlc2VyaWFsaXplVG9waWNzKGNvbXBzWzJdKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSBcIipcIikge1xuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIHBvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG4gICAgfVxufVxuO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxuY29uc3QgY29pbkluZm9zID0ge1xuICAgIFwiMFwiOiB7IHN5bWJvbDogXCJidGNcIiwgcDJwa2g6IDB4MDAsIHAyc2g6IDB4MDUsIHByZWZpeDogXCJiY1wiIH0sXG4gICAgXCIyXCI6IHsgc3ltYm9sOiBcImx0Y1wiLCBwMnBraDogMHgzMCwgcDJzaDogMHgzMiwgcHJlZml4OiBcImx0Y1wiIH0sXG4gICAgXCIzXCI6IHsgc3ltYm9sOiBcImRvZ2VcIiwgcDJwa2g6IDB4MWUsIHAyc2g6IDB4MTYgfSxcbiAgICBcIjYwXCI6IHsgc3ltYm9sOiBcImV0aFwiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjYxXCI6IHsgc3ltYm9sOiBcImV0Y1wiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjcwMFwiOiB7IHN5bWJvbDogXCJ4ZGFpXCIsIGlsazogXCJldGhcIiB9LFxufTtcbmZ1bmN0aW9uIGJ5dGVzMzJpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwgMzIpO1xufVxuLy8gQ29tcHV0ZSB0aGUgQmFzZTU4Q2hlY2sgZW5jb2RlZCBkYXRhIChjaGVja3N1bSBpcyBmaXJzdCA0IGJ5dGVzIG9mIHNoYTI1NmQpXG5mdW5jdGlvbiBiYXNlNThFbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiBCYXNlNTguZW5jb2RlKGNvbmNhdChbZGF0YSwgaGV4RGF0YVNsaWNlKHNoYTI1NihzaGEyNTYoZGF0YSkpLCAwLCA0KV0pKTtcbn1cbmNvbnN0IG1hdGNoZXJJcGZzID0gbmV3IFJlZ0V4cChcIl4oaXBmcyk6L1xcLyguKikkXCIsIFwiaVwiKTtcbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBtYXRjaGVySXBmcyxcbiAgICBuZXcgUmVnRXhwKFwiXmVpcDE1NTpbMC05XSsvKGVyY1swLTldKyk6KC4qKSRcIiwgXCJpXCIpLFxuXTtcbmZ1bmN0aW9uIF9wYXJzZVN0cmluZyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQsIHN0YXJ0KSB7XG4gICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBzdGFydCwgc3RhcnQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0LCBvZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgcmV0dXJuIGhleERhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCk7XG59XG4vLyBUcmltIG9mZiB0aGUgaXBmczovLyBwcmVmaXggYW5kIHJldHVybiB0aGUgZGVmYXVsdCBnYXRld2F5IFVSTFxuZnVuY3Rpb24gZ2V0SXBmc0xpbmsobGluaykge1xuICAgIGlmIChsaW5rLm1hdGNoKC9eaXBmczpcXC9cXC9pcGZzXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZygxMik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcLy9pKSkge1xuICAgICAgICBsaW5rID0gbGluay5zdWJzdHJpbmcoNyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgSVBGUyBmb3JtYXRcIiwgXCJsaW5rXCIsIGxpbmspO1xuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2xpbmt9YDtcbn1cbmZ1bmN0aW9uIG51bVBhZCh2YWx1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludGVybmFsOyBzaG91bGQgbm90IGhhcHBlblwiKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGVkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICAgIHBhZGRlZC5zZXQocmVzdWx0LCAzMiAtIHJlc3VsdC5sZW5ndGgpO1xuICAgIHJldHVybiBwYWRkZWQ7XG59XG5mdW5jdGlvbiBieXRlc1BhZCh2YWx1ZSkge1xuICAgIGlmICgodmFsdWUubGVuZ3RoICUgMzIpID09PSAwKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5jZWlsKHZhbHVlLmxlbmd0aCAvIDMyKSAqIDMyKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQUJJIEVuY29kZXMgYSBzZXJpZXMgb2YgKGJ5dGVzLCBieXRlcywgLi4uKVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMoZGF0YXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgYnl0ZUNvdW50ID0gMDtcbiAgICAvLyBBZGQgcGxhY2UtaG9sZGVycyBmb3IgcG9pbnRlcnMgYXMgd2UgYWRkIGl0ZW1zXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChudWxsKTtcbiAgICAgICAgYnl0ZUNvdW50ICs9IDMyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhcnJheWlmeShkYXRhc1tpXSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYnl0ZXMgb2Zmc2V0XG4gICAgICAgIHJlc3VsdFtpXSA9IG51bVBhZChieXRlQ291bnQpO1xuICAgICAgICAvLyBUaGUgbGVuZ3RoIGFuZCBwYWRkZWQgdmFsdWUgb2YgZGF0YVxuICAgICAgICByZXN1bHQucHVzaChudW1QYWQoZGF0YS5sZW5ndGgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZXNQYWQoZGF0YSkpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzIgKyBNYXRoLmNlaWwoZGF0YS5sZW5ndGggLyAzMikgKiAzMjtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChyZXN1bHQpO1xufVxuZXhwb3J0IGNsYXNzIFJlc29sdmVyIHtcbiAgICAvLyBUaGUgcmVzb2x2ZWRBZGRyZXNzIGlzIG9ubHkgZm9yIGNyZWF0aW5nIGEgUmV2ZXJzZUxvb2t1cCByZXNvbHZlclxuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBuYW1lLCByZXNvbHZlZEFkZHJlc3MpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIHByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcmVzb2x2ZWRBZGRyZXNzXCIsIHJlc29sdmVkQWRkcmVzcyk7XG4gICAgfVxuICAgIHN1cHBvcnRzV2lsZGNhcmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc3VwcG9ydHNFaXAyNTQ0KSB7XG4gICAgICAgICAgICAvLyBzdXBwb3J0c0ludGVyZmFjZShieXRlczQgPSBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpKVxuICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNFaXAyNTQ0ID0gdGhpcy5wcm92aWRlci5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IFwiMHgwMWZmYzlhNzkwNjFiOTIzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIlxuICAgICAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkuZXEoMSk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJldGhyb3cgdGhlIGVycm9yOiBsaW5rIGlzIGRvd24sIGV0Yy4gTGV0IGZ1dHVyZSBhdHRlbXB0cyByZXRyeS5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdXBwb3J0c0VpcDI1NDQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRzRWlwMjU0NDtcbiAgICB9XG4gICAgX2ZldGNoKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBlLmcuIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2KVwiKVxuICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgbmFtZWhhc2godGhpcy5uYW1lKSwgKHBhcmFtZXRlcnMgfHwgXCIweFwiKV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gV2lsZGNhcmQgc3VwcG9ydDsgdXNlIEVJUC0yNTQ0IHRvIHJlc29sdmUgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGxldCBwYXJzZUJ5dGVzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoeWllbGQgdGhpcy5zdXBwb3J0c1dpbGRjYXJkKCkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZUJ5dGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcihcInJlc29sdmUoYnl0ZXMsYnl0ZXMpXCIpXG4gICAgICAgICAgICAgICAgdHguZGF0YSA9IGhleENvbmNhdChbXCIweDkwNjFiOTIzXCIsIGVuY29kZUJ5dGVzKFtkbnNFbmNvZGUodGhpcy5uYW1lKSwgdHguZGF0YV0pXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpO1xuICAgICAgICAgICAgICAgIGlmICgoYXJyYXlpZnkocmVzdWx0KS5sZW5ndGggJSAzMikgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXNvbHZlciB0aHJldyBlcnJvclwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHgsIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlQnl0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9mZXRjaEJ5dGVzKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9mZXRjaChzZWxlY3RvciwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlQnl0ZXMocmVzdWx0LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFkZHJlc3MoY29pblR5cGUsIGhleEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvaW5JbmZvID0gY29pbkluZm9zW1N0cmluZyhjb2luVHlwZSldO1xuICAgICAgICBpZiAoY29pbkluZm8gPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIGNvaW4gdHlwZTogJHtjb2luVHlwZX1gLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvaW5JbmZvLmlsayA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoaGV4Qnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoaGV4Qnl0ZXMpO1xuICAgICAgICAvLyBQMlBLSDogT1BfRFVQIE9QX0hBU0gxNjAgPHB1YktleUhhc2g+IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG4gICAgICAgIGlmIChjb2luSW5mby5wMnBraCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnBraCA9IGhleEJ5dGVzLm1hdGNoKC9eMHg3NmE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4OGFjJC8pO1xuICAgICAgICAgICAgaWYgKHAycGtoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJwa2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJwa2hbMl0ubGVuZ3RoID09PSBsZW5ndGggKiAyICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTU4RW5jb2RlKGNvbmNhdChbW2NvaW5JbmZvLnAycGtoXSwgKFwiMHhcIiArIHAycGtoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUDJTSDogT1BfSEFTSDE2MCA8c2NyaXB0SGFzaD4gT1BfRVFVQUxcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAyc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcDJzaCA9IGhleEJ5dGVzLm1hdGNoKC9eMHhhOShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopODckLyk7XG4gICAgICAgICAgICBpZiAocDJzaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHAyc2hbMV0sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAocDJzaFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJzaF0sIChcIjB4XCIgKyBwMnNoWzJdKV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVjaDMyXG4gICAgICAgIGlmIChjb2luSW5mby5wcmVmaXggIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gYnl0ZXNbMV07XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMTQxLm1lZGlhd2lraSN3aXRuZXNzLXByb2dyYW1cbiAgICAgICAgICAgIGxldCB2ZXJzaW9uID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gMHgwMCkge1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggIT09IDIwICYmIGxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnNpb24gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID49IDAgJiYgYnl0ZXMubGVuZ3RoID09PSAyICsgbGVuZ3RoICYmIGxlbmd0aCA+PSAxICYmIGxlbmd0aCA8PSA3NSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyLnRvV29yZHMoYnl0ZXMuc2xpY2UoMikpO1xuICAgICAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlY2gzMi5lbmNvZGUoY29pbkluZm8ucHJlZml4LCB3b3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoY29pblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChjb2luVHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIEV0aGVyZXVtLCB1c2UgdGhlIHN0YW5kYXJkIGBhZGRyKGJ5dGVzMzIpYFxuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09PSA2MCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5fZmV0Y2goXCIweDNiM2I1N2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IFwiMHhcIiB8fCByZXN1bHQgPT09IEhhc2haZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhmMWNiN2UwNlwiLCBieXRlczMyaWZ5KGNvaW5UeXBlKSk7XG4gICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgY29pblR5cGU6IGNvaW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdmF0YXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rYWdlID0gW3sgdHlwZTogXCJuYW1lXCIsIGNvbnRlbnQ6IHRoaXMubmFtZSB9XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gdGVzdCBkYXRhIGZvciByaWNtb28uZXRoXG4gICAgICAgICAgICAgICAgLy9jb25zdCBhdmF0YXIgPSBcImVpcDE1NToxL2VyYzcyMToweDI2NTM4NWM3ZjQxMzIyMjhBMGQ1NEVCMUE5ZTc0NjBiOTFjMGNDNjgvMjkyMzNcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCB0aGlzLmdldFRleHQoXCJhdmF0YXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gYXZhdGFyLm1hdGNoKG1hdGNoZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtZSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2NoZW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJkYXRhXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogZ2V0SXBmc0xpbmsoYXZhdGFyKSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChzY2hlbWUgPT09IFwiZXJjNzIxXCIpID8gXCIweGM4N2I1NmRkXCIgOiBcIjB4MGU4OTM0MWNcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBzY2hlbWUsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3duZXIgb2YgdGhpcyBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSAodGhpcy5fcmVzb2x2ZWRBZGRyZXNzIHx8ICh5aWVsZCB0aGlzLmdldEFkZHJlc3MoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBzID0gKG1hdGNoWzJdIHx8IFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhjb21wc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5JZCA9IGhleFplcm9QYWQoQmlnTnVtYmVyLmZyb20oY29tcHNbMV0pLnRvSGV4U3RyaW5nKCksIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoaXMgYWNjb3VudCBvd25zIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duZXJPZih1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDYzNTIyMTFlXCIsIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCBjb250ZW50OiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJhbGFuY2VPZihhZGRyZXNzIG93bmVyLCB1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSBCaWdOdW1iZXIuZnJvbSh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDAwZmRkNThlXCIsIGhleFplcm9QYWQob3duZXIsIDMyKSwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhbGFuY2UuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiYmFsYW5jZVwiLCBjb250ZW50OiBiYWxhbmNlLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIHRva2VuIGNvbnRyYWN0IGZvciB0aGUgbWV0YWRhdGEgVVJMXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGFVcmwgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsLWJhc2VcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1lID09PSBcImVyYzExNTVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IG1ldGFkYXRhVXJsLnJlcGxhY2UoXCJ7aWR9XCIsIHRva2VuSWQuc3Vic3RyaW5nKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtZXhwYW5kZWRcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIG1ldGFkYXRhIGxpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhVXJsLm1hdGNoKC9eaXBmczovaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFVcmwgPSBnZXRJcGZzTGluayhtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwibWV0YWRhdGEtdXJsXCIsIGNvbnRlbnQ6IG1ldGFkYXRhVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdG9rZW4gbWV0YWRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHlpZWxkIGZldGNoSnNvbihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YVwiLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtZXRhZGF0YSkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHVsbCB0aGUgaW1hZ2UgVVJMIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZVVybCA9IG1ldGFkYXRhLmltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGltYWdlVXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsLm1hdGNoKC9eKGh0dHBzOlxcL1xcL3xkYXRhOikvaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBJUEZTIGxpbmsgdG8gZ2F0ZXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpcGZzID0gaW1hZ2VVcmwubWF0Y2gobWF0Y2hlcklwZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybC1pcGZzXCIsIGNvbnRlbnQ6IGltYWdlVXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IGdldElwZnNMaW5rKGltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJ1cmxcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBpbWFnZVVybCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29udGVudEhhc2goKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJjb250ZW50aGFzaCgpXCIpXG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGJjMWM1OGQxXCIpO1xuICAgICAgICAgICAgLy8gTm8gY29udGVudGhhc2hcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElQRlMgKENJRDogMSwgVHlwZTogREFHLVBCKVxuICAgICAgICAgICAgY29uc3QgaXBmcyA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlMzAxMDE3MCgoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKSkkLyk7XG4gICAgICAgICAgICBpZiAoaXBmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KGlwZnNbM10sIDE2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXBmc1s0XS5sZW5ndGggPT09IGxlbmd0aCAqIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiaXBmczovXFwvXCIgKyBCYXNlNTguZW5jb2RlKFwiMHhcIiArIGlwZnNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElQTlMgKENJRDogMSwgVHlwZTogbGlicDJwLWtleSlcbiAgICAgICAgICAgIGNvbnN0IGlwbnMgPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTUwMTAxNzIoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuICAgICAgICAgICAgaWYgKGlwbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChpcG5zWzNdLCAxNik7XG4gICAgICAgICAgICAgICAgaWYgKGlwbnNbNF0ubGVuZ3RoID09PSBsZW5ndGggKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImlwbnM6L1xcL1wiICsgQmFzZTU4LmVuY29kZShcIjB4XCIgKyBpcG5zWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTd2FybSAoQ0lEOiAxLCBUeXBlOiBzd2FybS1tYW5pZmVzdDsgaGFzaC9sZW5ndGggaGFyZC1jb2RlZCB0byBrZWNjYWsyNTYvMzIpXG4gICAgICAgICAgICBjb25zdCBzd2FybSA9IGhleEJ5dGVzLm1hdGNoKC9eMHhlNDAxMDFmYTAxMWIyMChbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgaWYgKHN3YXJtKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN3YXJtWzFdLmxlbmd0aCA9PT0gKDMyICogMikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiYnp6Oi9cXC9cIiArIHN3YXJtWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNreW5ldCA9IGhleEJ5dGVzLm1hdGNoKC9eMHg5MGIyYzYwNShbMC05YS1mXSopJC8pO1xuICAgICAgICAgICAgaWYgKHNreW5ldCkge1xuICAgICAgICAgICAgICAgIGlmIChza3luZXRbMV0ubGVuZ3RoID09PSAoMzQgKiAyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVUkwgU2FmZSBiYXNlNjQ7IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDY0OCNzZWN0aW9uLTVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsU2FmZSA9IHsgXCI9XCI6IFwiXCIsIFwiK1wiOiBcIi1cIiwgXCIvXCI6IFwiX1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBiYXNlNjRFbmNvZGUoXCIweFwiICsgc2t5bmV0WzFdKS5yZXBsYWNlKC9bPStcXC9dL2csIChhKSA9PiAodXJsU2FmZVthXSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzaWE6L1xcL1wiICsgaGFzaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgZW5jb2RlZCBhcyBwYXJhbWV0ZXIgdG8gZmV0Y2hCeXRlc1xuICAgICAgICAgICAgbGV0IGtleUJ5dGVzID0gdG9VdGY4Qnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIC8vIFRoZSBub2RlaGFzaCBjb25zdW1lcyB0aGUgZmlyc3Qgc2xvdCwgc28gdGhlIHN0cmluZyBwb2ludGVyIHRhcmdldHNcbiAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcbiAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtieXRlczMyaWZ5KDY0KSwgYnl0ZXMzMmlmeShrZXlCeXRlcy5sZW5ndGgpLCBrZXlCeXRlc10pO1xuICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG4gICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtrZXlCeXRlcywgaGV4WmVyb1BhZChcIjB4XCIsIDMyIC0gKGtleS5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweDU5ZDFkNDNjXCIsIGhleGxpZnkoa2V5Qnl0ZXMpKTtcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoaGV4Qnl0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5sZXQgbmV4dFBvbGxJZCA9IDE7XG5leHBvcnQgY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICByZWFkeVxuICAgICAqXG4gICAgICogIEEgUHJvbWlzZTxOZXR3b3JrPiB0aGF0IHJlc29sdmVzIG9ubHkgb25jZSB0aGUgcHJvdmlkZXIgaXMgcmVhZHkuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgdGhhdCBjYWxsIHRoZSBzdXBlciB3aXRoIGEgbmV0d29yayB3aXRob3V0IGEgY2hhaW5JZFxuICAgICAqICBNVVNUIHNldCB0aGlzLiBTdGFuZGFyZCBuYW1lZCBuZXR3b3JrcyBoYXZlIGEga25vd24gY2hhaW5JZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gRXZlbnRzIGJlaW5nIGxpc3RlbmVkIHRvXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0dGVkID0geyBibG9jazogLTIgfTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcudGFyZ2V0LmdldEZvcm1hdHRlcigpO1xuICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBuZXR3b3JrXG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYW55TmV0d29ya1wiLCAobmV0d29yayA9PT0gXCJhbnlcIikpO1xuICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUHJvbWlzZSA9IG5ldHdvcms7XG4gICAgICAgICAgICAvLyBTcXVhc2ggYW55IFwidW5oYW5kbGVkIHByb21pc2VcIiBlcnJvcnM7IHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgaGFuZGxlZFxuICAgICAgICAgICAgbmV0d29yay5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgbmV0d29yayBzZXR0aW5nIChhc3luYylcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5KCkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga25vd25OZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5fbWF4RmlsdGVyQmxvY2tSYW5nZSA9IDEwO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICB9XG4gICAgX3JlYWR5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9uZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIFByb3ZpZGVyJ3MgbmV0d29yayBkZXRlY3Rpb24gKHRoaXMgTVVTVCB0aHJvdyBpZiBpdCBjYW5ub3QpXG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGEgbmV0d29yayBieSBoZXJlIChvciBoYXZlIHRocm93bikuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cbiAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG4gICAgLy8gYW55IGNoYW5nZSBpcyByZWZsZWN0ZWQpOyBvdGhlcndpc2UgdGhpcyBjYW5ub3QgY2hhbmdlXG4gICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHkoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiAmJiBlcnJvci5ldmVudCA9PT0gXCJub05ldHdvcmtcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IGNyZWF0ZSBhIHNpbmdsZXRvbiBmb3JtYXR0ZXJcbiAgICBzdGF0aWMgZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICAgIH1cbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKChuZXR3b3JrID09IG51bGwpID8gXCJob21lc3RlYWRcIiA6IG5ldHdvcmspO1xuICAgIH1cbiAgICBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZW5kZXIgPSB0eC50by50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKHJlc3VsdC5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHsgdXJsLCBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgdXJscywgZXJyb3JNZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3NcbiAgICAvLyB0aGFuIG1heEFnZSBvbGQgb3IgaGFzIGJlZW4gcmVxdWVzdGVkIHNpbmNlIHRoZSBsYXN0IHJlcXVlc3RcbiAgICBfZ2V0SW50ZXJuYWxCbG9ja051bWJlcihtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3JlYWR5KCk7XG4gICAgICAgICAgICAvLyBBbGxvd2luZyBzdGFsZSBkYXRhIHVwIHRvIG1heEFnZSBvbGRcbiAgICAgICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgdGhlcmUgYXJlIHBlbmRpbmcgaW50ZXJuYWwgYmxvY2sgcmVxdWVzdHMuLi5cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5cInJlbWVtYmVyXCIgd2hpY2ggZmV0Y2ggd2Ugc3RhcnRlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBpcyBub3QgdG9vIHN0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBpbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZXRUaW1lKCkgLSByZXN1bHQucmVzcFRpbWUpIDw9IG1heEFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb28gb2xkOyBmZXRjaCBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmV0Y2ggcmVqZWN0ZWQ7IGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uLCBkcm9wIHRocm91Z2ggc28gd2UgcmVwbGFjZSBpdCB3aXRoIGEgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaDsgYWxsIG90aGVycyBibG9ja2VkIHdpbGwgdGhlbiBnZXQgdGhhdCBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd29uJ3QgbWF0Y2ggdGhlIG9uZSB0aGV5IFwicmVtZW1iZXJlZFwiIGFuZCBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gaW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tOdW1iZXJcIiwge30pLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogdGhpcy5nZXROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4gKG51bGwpLCAoZXJyb3IpID0+IChlcnJvcikpXG4gICAgICAgICAgICB9KS50aGVuKCh7IGJsb2NrTnVtYmVyLCBuZXR3b3JrRXJyb3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5yZW1lbWJlciB0aGlzIGJhZCBpbnRlcm5hbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKGJsb2NrTnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cbiAgICAgICAgICAgICAgICByZXR1cm4geyBibG9ja051bWJlciwgcmVxVGltZSwgcmVzcFRpbWUgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgdW5oYW5kbGVkIGV4Y2VwdGlvbnM7IGlmIG5lZWRlZCB0aGV5IGFyZSBoYW5kbGVkIGVsc2Ugd2hlcmVcbiAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBudWxsIHRoZSBkZWFkIChyZWplY3RlZCkgZmV0Y2gsIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikuYmxvY2tOdW1iZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcG9sbElkID0gbmV4dFBvbGxJZCsrO1xuICAgICAgICAgICAgLy8gVHJhY2sgYWxsIHJ1bm5pbmcgcHJvbWlzZXMsIHNvIHdlIGNhbiB0cmlnZ2VyIGEgcG9zdC1wb2xsIG9uY2UgdGhleSBhcmUgY29tcGxldGVcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5lcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBFbWl0IGEgcG9sbCBldmVudCBhZnRlciB3ZSBoYXZlIHRoZSBsYXRlc3QgKGZhc3QpIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiLCBwb2xsSWQsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gdGhpcy5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGUsIHRyaWdnZXIgYSBcImJsb2NrXCIgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgbmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHMgKGVtaXR0ZWQ9JHt0aGlzLl9lbWl0dGVkLmJsb2NrfSBibG9ja051bWJlciR7YmxvY2tOdW1iZXJ9KWApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGxvZ2dlci5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tOdW1iZXI6IHRoaXMuX2VtaXR0ZWQuYmxvY2tcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZW1pdHRlZC5ibG9jayArIDE7IGkgPD0gYmxvY2tOdW1iZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgIT09IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgZXZlbnQgZG9lcyBub3QgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayB3ZSB3ZXJlIGF0IHdoZW4gd2UgZW1pdHRlZCB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBnYXJiYWdlIGNvbGxlY3QgcGVuZGluZyB0cmFuc2FjdGlvbnMgb3IgYmxvY2tzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBcInBlbmRpbmdcIiBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QmxvY2tOdW1iZXIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZpY3QgYW55IHRyYW5zYWN0aW9uIGhhc2hlcyBvciBibG9jayBoYXNoZXMgb3ZlciAxMiBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSBldmVudEJsb2NrTnVtYmVyID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bm5lciA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIGhhc2hdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGEgc2luZ2xlIGdldExvZ3MgdG8gYmUgaW4tZmxpZ2h0IGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5faW5mbGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGZpbHRlciBmb3IgdGhpcyBldmVudCwgc28gd2Ugd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RyaWN0IGV2ZW50cyB0byBldmVudHMgdGhhdCBoYXBwZW5lZCBubyBlYXJsaWVyIHRoYW4gbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBmcm9tIHRoZSBsYXN0ICprbm93biogZXZlbnQ7IGR1ZSB0byBsb2FkLWJhbGFuY2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzb21lIG5vZGVzIHJldHVybmluZyB1cGRhdGVkIGJsb2NrIG51bWJlcnMgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5kZXhpbmcgZXZlbnRzLCBhIGxvZ3MgcmVzdWx0IHdpdGggMCBlbnRyaWVzIGNhbm5vdCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydXN0ZWQgYW5kIHdlIG11c3QgcmV0cnkgYSByYW5nZSB3aGljaCBpbmNsdWRlcyBpdCBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGV2ZW50LmZpbHRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gZXZlbnQuX2xhc3RCbG9ja051bWJlciArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnRvQmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGZpdGxlciByYW5nZXMgZnJvbSBncm93aW5nIHRvbyB3aWxkLCBzaW5jZSBpdCBpcyBxdWl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxpa2VseSB0aGVyZSBqdXN0IGhhdmVuJ3QgYmVlbiBhbnkgZXZlbnRzIHRvIG1vdmUgdGhlIGxhc3RCbG9ja051bWJlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5Gcm9tQmxvY2sgPSBmaWx0ZXIudG9CbG9jayAtIHRoaXMuX21heEZpbHRlckJsb2NrUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkZyb21CbG9jayA+IGZpbHRlci5mcm9tQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IG1pbkZyb21CbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5mcm9tQmxvY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5uZXIgPSB0aGlzLmdldExvZ3MoZmlsdGVyKS50aGVuKChsb2dzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBuZXh0IGdldExvZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHdoZW4gd2UgZ2V0IGFuIGV2ZW50IGZvciBhIGdpdmVuIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHdlIHRydXN0IHRoZSBldmVudHMgYXJlIGluZGV4ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2cuYmxvY2tOdW1iZXIgPiBldmVudC5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2xhc3RCbG9ja051bWJlciA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzdGFsbCByZXF1ZXN0cyB0byBmZXRjaCBibG9ja3MgYW5kIHR4c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcImI6XCIgKyBsb2cuYmxvY2tIYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoZmlsdGVyLCBsb2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyBhbm90aGVyIGdldExvZ3MgKHRoZSByYW5nZSB3YXMgbm90IHVwZGF0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Ll9pbmZsaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocnVubmVycykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGVkOyBkbyBub3QgdXNlIHRoaXNcbiAgICByZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcXVlcnkgdGhlIG5ldHdvcmsgaWYgdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgIC8vIGNhbiBjaGFuZ2UsIHN1Y2ggYXMgd2hlbiBjb25uZWN0ZWQgdG8gYSBKU09OLVJQQyBiYWNrZW5kXG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgbmV0d29yayBkZXRlY3Rpb25cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicHJvdmlkZXIuZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5fcmVhZHkoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgc3RpbGwgY29ubmVjdGVkIHRvIHRoZSBzYW1lIG5ldHdvcms7IHRoaXMgaXNcbiAgICAgICAgICAgIC8vIG9ubHkgYW4gZXh0ZXJuYWwgY2FsbCBmb3IgYmFja2VuZHMgd2hpY2ggY2FuIGhhdmUgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgY2hhbmdlIHNwb250YW5lb3VzbHlcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFsbG93aW5nIG5ldHdvcmsgY2hhbmdlcywgdGhpbmdzIGNhbiBnZXQgY29tcGxleCBmYXN0O1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgaWYgeW91IHVzZSBcImFueVwiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gY3VycmVudE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFsbCBpbnRlcm5hbCBibG9jayBudW1iZXIgZ3VhcmRzIGFuZCBjYWNoZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IC0yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJuZXR3b3JrXCIgZXZlbnQgTVVTVCBoYXBwZW4gYmVmb3JlIHRoaXMgbWV0aG9kIHJlc29sdmVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGFueSBldmVudHMgaGF2ZSBhIGNoYW5jZSB0byB1bnJlZ2lzdGVyLCBzbyB3ZSBzdGFsbCBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50IGxvb3AgYmVmb3JlIHJldHVybmluZyBmcm9tIC90aGlzLyBjYWxsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgY3VycmVudE5ldHdvcmssIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbG9nZ2VyLm1ha2VFcnJvcihcInVuZGVybHlpbmcgbmV0d29yayBjaGFuZ2VkXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGVkTmV0d29yazogY3VycmVudE5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBibG9ja051bWJlcigpIHtcbiAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyICE9IG51bGwpID8gdGhpcy5fZmFzdEJsb2NrTnVtYmVyIDogLTE7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm9vdHN0cmFwUG9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcG9sbGluZyB3YXMgZGlzYWJsZWQsIHNvbWV0aGluZyBtYXkgcmVxdWlyZSBhIHBva2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHN0YXJ0aW5nIHRoZSBib290c3RyYXAgcG9sbCBhbmQgaXQgd2FzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8PSAwIHx8IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEZhc3RCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFsZSBibG9jayBudW1iZXIsIHJlcXVlc3QgYSBuZXdlciB2YWx1ZVxuICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZTtcbiAgICB9XG4gICAgX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcikge1xuICAgICAgICAvLyBPbGRlciBibG9jaywgbWF5YmUgYSBzdGFsZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBOZXdlciBibG9jayBudW1iZXIsIHVzZSAgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCAoY29uZmlybWF0aW9ucyA9PSBudWxsKSA/IDEgOiBjb25maXJtYXRpb25zLCB0aW1lb3V0IHx8IDAsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQsIHJlcGxhY2VhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIC8vIFJlY2VpcHQgaXMgYWxyZWFkeSBnb29kXG4gICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb2xsIHVudGlsIHRoZSByZWNlaXB0IGlzIGdvb2QuLi5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsRnVuY3MgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbWluZWRIYW5kbGVyID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHsgdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIG1pbmVkSGFuZGxlcik7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEJsb2NrTnVtYmVyID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYW5uZWRCbG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VIYW5kbGVyID0gKGJsb2NrTnVtYmVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHRyYWRlIG9mZiBhIGxpdHRsZSBiaXQgb2YgbGF0ZW5jeSBmb3IgbW9yZSBjb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQocmVwbGFjZWFibGUuZnJvbSkudGhlbigobm9uY2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25jZSA8PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgbWluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluZWQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNjYW5uaW5nLiBXZSBzdGFydCBhIGxpdHRsZSBlYXJsaWVyIGZvciBzb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZ2dsZSByb29tIGhlcmUgdG8gaGFuZGxlIHRoZSBldmVudHVhbGx5IGNvbnNpc3RlbnQgbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJsb2NrY2hhaW4gKGUuZy4gdGhlIGdldFRyYW5zYWN0aW9uQ291bnQgd2FzIGZvciBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBibG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSBsYXN0QmxvY2tOdW1iZXIgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA8IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzY2FubmVkQmxvY2sgPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhzY2FubmVkQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1t0aV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IG1pbmVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSB0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIG91ciB0cmFuc2FjdGlvbiBmcm9tIGFuZCBub25jZTsgaXRzIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gcmVwbGFjZWFibGUuZnJvbSAmJiB0eC5ub25jZSA9PT0gcmVwbGFjZWFibGUubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZlZCBvciByZWplY3RlZCAocHJvbGx5IGEgdGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHJlcGxhY2VhYmxlLmRhdGEgJiYgdHgudG8gPT09IHJlcGxhY2VhYmxlLnRvICYmIHR4LnZhbHVlLmVxKHJlcGxhY2VhYmxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsYWluIHdoeSB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIExvZ2dlci5lcnJvcnMuVFJBTlNBQ1RJT05fUkVQTEFDRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXQgZXhjZWVkZWRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyLnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0R2FzUHJpY2VcIiwge30pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRHYXNQcmljZVwiLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCYWxhbmNlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmFsYW5jZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uQ291bnRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29kZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQcm9taXNlLnJlc29sdmUocG9zaXRpb24pLnRoZW4oKHApID0+IGhleFZhbHVlKHApKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYnkgYW55IHN1YmNsYXNzIHdyYXBwaW5nIGEgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgIF93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIHN0YXJ0QmxvY2spIHtcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBoZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIHNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0eDtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiB0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwgeyBleHBlY3RlZEhhc2g6IHR4Lmhhc2gsIHJldHVybmVkSGFzaDogaGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdCA9IChjb25maXJtcywgdGltZW91dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maXJtcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRldGFpbHMgdG8gZGV0ZWN0IHJlcGxhY2VtZW50XG4gICAgICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgIT09IDAgJiYgc3RhcnRCbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHR4LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0eC5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtcywgdGltZW91dCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCAmJiBjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbG9uZ2VyIHBlbmRpbmcsIGFsbG93IHRoZSBwb2xsaW5nIGxvb3AgdG8gZ2FyYmFnZSBjb2xsZWN0IHRoaXNcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4odCA9PiBoZXhsaWZ5KHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJzZW5kVHJhbnNhY3Rpb25cIiwgeyBzaWduZWRUcmFuc2FjdGlvbjogaGV4VHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSB0eC5oYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0geWllbGQgdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBjb25zdCB0eCA9IHt9O1xuICAgICAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyB0aGlzLl9nZXRBZGRyZXNzKHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICh2ID8gQmlnTnVtYmVyLmZyb20odikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcInR5cGVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAoKHYgIT0gbnVsbCkgPyB2IDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gdGhpcy5mb3JtYXR0ZXIuYWNjZXNzTGlzdCh2YWx1ZXMuYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBoZXhsaWZ5KHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXF1ZXN0KHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHR4KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZmlsdGVyID0geWllbGQgZmlsdGVyO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJibG9ja0hhc2hcIiwgXCJ0b3BpY3NcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJmcm9tQmxvY2tcIiwgXCJ0b0Jsb2NrXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXJba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5maWx0ZXIoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXMocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcsIGF0dGVtcHQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID49IE1BWF9DQ0lQX1JFRElSRUNUUykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCByZWFkIGV4Y2VlZGVkIG1heGltdW0gcmVkaXJlY3Rpb25zXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0czogYXR0ZW1wdCwgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4U2VuZGVyID0gdHJhbnNhY3Rpb24udG87XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHsgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0pO1xuICAgICAgICAgICAgLy8gQ0NJUCBSZWFkIHJlcXVlc3QgdmlhIE9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVxuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gMCAmJiBibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiAmJiB0eFNlbmRlciAhPSBudWxsICYmIHJlc3VsdC5zdWJzdHJpbmcoMCwgMTApID09PSBcIjB4NTU2ZjE4MzBcIiAmJiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICUgMzIgPT09IDQpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGhleERhdGFTbGljZShyZXN1bHQsIDQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgc2VuZGVyIG9mIHRoZSBPZmZjaGFpbkxvb2t1cCBtYXRjaGVzIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZW5kZXIgPSBoZXhEYXRhU2xpY2UoZGF0YSwgMCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUJpZ051bWJlci5mcm9tKHNlbmRlcikuZXEodHhTZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBzZW5kZXIgZGlkIG5vdCBtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIHRoZSBVUkxzIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc09mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCAzMiwgNjQpKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzTGVuZ3RoID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQsIHVybHNPZmZzZXQgKyAzMikpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNEYXRhID0gaGV4RGF0YVNsaWNlKGRhdGEsIHVybHNPZmZzZXQgKyAzMik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdXJsc0xlbmd0aDsgdSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBfcGFyc2VTdHJpbmcodXJsc0RhdGEsIHUgKiAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBjb250YWluZWQgY29ycnVwdCBVUkwgc3RyaW5nXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IFwiT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgQ0NJUCBjYWxsZGF0YSB0byBmb3J3YXJkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxkYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgNjQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhbGxiYWNrU2VsZWN0b3IgKGJ5dGVzNClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgMTAwLCAxMjgpKS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgY2FsbGJhY2sgc2VsZWN0b3IgaW5jbHVkZWQganVua1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja1NlbGVjdG9yID0gaGV4RGF0YVNsaWNlKGRhdGEsIDk2LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGV4dHJhIGRhdGEgdG8gc2VuZCBiYWNrIHRvIHRoZSBjb250cmFjdCBhcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhRGF0YSA9IF9wYXJzZUJ5dGVzKGRhdGEsIDEyOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNjaXBSZXN1bHQgPSB5aWVsZCB0aGlzLmNjaXBSZWFkRmV0Y2godHJhbnNhY3Rpb24sIGNhbGxkYXRhLCB1cmxzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNjaXBSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIFJlYWQgZGlzYWJsZWQgb3IgcHJvdmlkZWQgbm8gVVJMc1wiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJPZmZjaGFpbkxvb2t1cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0eFNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleENvbmNhdChbY2FsbGJhY2tTZWxlY3RvciwgZW5jb2RlQnl0ZXMoW2NjaXBSZXN1bHQsIGV4dHJhRGF0YV0pXSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGwodHgsIGJsb2NrVGFnLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImNhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IHRyYW5zYWN0aW9uLCBibG9ja1RhZyB9LCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogUHJvbWlzZS5yZXNvbHZlKHRyYW5zYWN0aW9uLmNjaXBSZWFkRW5hYmxlZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGwocmVzb2x2ZWQudHJhbnNhY3Rpb24sIHJlc29sdmVkLmJsb2NrVGFnLCByZXNvbHZlZC5jY2lwUmVhZEVuYWJsZWQgPyAwIDogLTEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImVzdGltYXRlR2FzXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImVzdGltYXRlR2FzXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzc09yTmFtZSA9IHlpZWxkIGFkZHJlc3NPck5hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JOYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IGByZXNvbHZlTmFtZSgke0pTT04uc3RyaW5naWZ5KGFkZHJlc3NPck5hbWUpfSlgXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGJsb2NrSGFzaE9yQmxvY2tUYWcgPSB5aWVsZCBibG9ja0hhc2hPckJsb2NrVGFnO1xuICAgICAgICAgICAgLy8gSWYgYmxvY2tUYWcgaXMgYSBudW1iZXIgKG5vdCBcImxhdGVzdFwiLCBldGMpLCB0aGlzIGlzIHRoZSBibG9jayBudW1iZXJcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IC0xMjg7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaW5jbHVkZVRyYW5zYWN0aW9uczogISFpbmNsdWRlVHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGJsb2NrSGFzaE9yQmxvY2tUYWcsIDMyKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5ibG9ja0hhc2ggPSBibG9ja0hhc2hPckJsb2NrVGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrVGFnID0geWllbGQgdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHBhcnNlSW50KHBhcmFtcy5ibG9ja1RhZy5zdWJzdHJpbmcoMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgd2FzIG5vdCBmb3VuZFxuICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9ja2hhc2hlcywgaWYgd2UgZGlkbid0IHNheSBpdCBleGlzdGVkLCB0aGF0IGJsb2NraGFzaCBtYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGV4aXN0LiBJZiB3ZSBkaWQgc2VlIGl0IHRob3VnaCwgcGVyaGFwcyBmcm9tIGEgbG9nLCB3ZSBrbm93XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrSGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcImI6XCIgKyBwYXJhbXMuYmxvY2tIYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NrIHRhZ3MsIGlmIHdlIGFyZSBhc2tpbmcgZm9yIGEgZnV0dXJlIGJsb2NrLCB3ZSByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+IHRoaXMuX2VtaXR0ZWQuYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXRyeSBvbiB0aGUgbmV4dCBibG9ja1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9jay50cmFuc2FjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tXaXRoVHhzID0gdGhpcy5mb3JtYXR0ZXIuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucyA9IGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBibG9ja1dpdGhUeHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayk7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCBmYWxzZSkpO1xuICAgIH1cbiAgICBnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIHRydWUpKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0cmFuc2FjdGlvbkhhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXNwb25zZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IHRyYW5zYWN0aW9uSGFzaDogdGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsIHRydWUpIH07XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gXCJnZXRoLWV0Y1wiIHJldHVybnMgcmVjZWlwdHMgYmVmb3JlIHRoZXkgYXJlIHJlYWR5XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY29uZmlybWF0aW9ucyA9IChibG9ja051bWJlciAtIHJlY2VpcHQuYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldExvZ3MoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxvZ3MgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRMb2dzXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICBsb2dzLmZvckVhY2goKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsb2cucmVtb3ZlZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmFycmF5T2YodGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nLmJpbmQodGhpcy5mb3JtYXR0ZXIpKShsb2dzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEV0aGVyUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm0oXCJnZXRFdGhlclByaWNlXCIsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRCbG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYmxvY2tUYWcgPSB5aWVsZCBibG9ja1RhZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiAmJiBibG9ja1RhZyA8IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tUYWcgJSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBcIlwiIHx8IGN1cnJlbnROYW1lID09PSBcIi5cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3B0aW1pemF0aW9uIHNpbmNlIHRoZSBldGggbm9kZSBjYW5ub3QgY2hhbmdlIGFuZCBkb2VzXG4gICAgICAgICAgICAgICAgLy8gbm90IGhhdmUgYSB3aWxkY2FyZCByZXNvbHZlclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImV0aFwiICYmIGN1cnJlbnROYW1lID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgY3VycmVudCBub2RlIGZvciBhIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKGN1cnJlbnROYW1lLCBcImdldFJlc29sdmVyXCIpO1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgcmVzb2x2ZXIhXG4gICAgICAgICAgICAgICAgaWYgKGFkZHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCBhZGRyLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVnYWN5IHJlc29sdmVyIGZvdW5kLCB1c2luZyBFSVAtMjU0NCBzbyBpdCBpc24ndCBzYWZlIHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgIT09IG5hbWUgJiYgISh5aWVsZCByZXNvbHZlci5zdXBwb3J0c1dpbGRjYXJkKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnNwbGl0KFwiLlwiKS5zbGljZSgxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRSZXNvbHZlcihuYW1lLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9IFwiRU5TXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbiwgbmV0d29yazogbmV0d29yay5uYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJyZXNvbHZlcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJEYXRhID0geWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ldHdvcmsuZW5zQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgbmFtZWhhc2gobmFtZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhhZGRyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFTlMgcmVnaXN0cnkgY2Fubm90IHRocm93IGVycm9ycyBvbiByZXNvbHZlcihieXRlczMyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBuYW1lID0geWllbGQgbmFtZTtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIGFscmVhZHkgYW4gYWRkcmVzcywgbm90aGluZyB0byByZXNvbHZlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpcyBpcyBhIGhleHN0cmluZywgdGhlIGFkZHJlc3MgaXMgYmFkIChTZWUgIzY5NClcbiAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGFkZHIgZnJvbSB0aGUgcmVzb2x2ZXJcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlci5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsb29rdXBBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSB5aWVsZCBhZGRyZXNzO1xuICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobm9kZSwgXCJsb29rdXBBZGRyZXNzXCIpO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVyQWRkciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsoXCJuYW1lKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICBjb25zdCBuYW1lID0gX3BhcnNlU3RyaW5nKHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgdG86IHJlc29sdmVyQWRkcixcbiAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDY5MWYzNDMxXCIgKyBuYW1laGFzaChub2RlKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyICE9IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QXZhdGFyKG5hbWVPckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZU9yQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzOyByZXZlcnNlIGxvb2t1cFxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXJBZGRyZXNzID0geWllbGQgdGhpcy5fZ2V0UmVzb2x2ZXIobm9kZSwgXCJnZXRBdmF0YXJcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSByZXNvbHZpbmcgdGhlIGF2YXRhciBhZ2FpbnN0IHRoZSBhZGRyLnJldmVyc2UgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IG5ldyBSZXNvbHZlcih0aGlzLCByZXNvbHZlckFkZHJlc3MsIG5vZGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhdGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRyeSBnZXR0aW5nIHRoZSBuYW1lIGFuZCBwZXJmb3JtaW5nIGZvcndhcmQgbG9va3VwOyBhbGxvd2luZyB3aWxkY2FyZHNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrZWNjYWsoXCJuYW1lKGJ5dGVzMzIpXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBfcGFyc2VTdHJpbmcoeWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDY5MWYzNDMxXCIgKyBuYW1laGFzaChub2RlKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgIT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEVOUyBuYW1lOyBmb3J3YXJkIGxvb2t1cCB3aXRoIHdpbGRjYXJkXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSB5aWVsZCB0aGlzLmdldFJlc29sdmVyKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgcmVzb2x2ZXIuZ2V0QXZhdGFyKCk7XG4gICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdmF0YXIudXJsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gZS5wb2xsYWJsZSgpKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgX3N0b3BFdmVudChldmVudCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gZS5wb2xsYWJsZSgpKS5sZW5ndGggPiAwKTtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChnZXRFdmVudFRhZyhldmVudE5hbWUpLCBsaXN0ZW5lciwgb25jZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9XG4gICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQubGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQub25jZSkge1xuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIWV2ZW50TmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgfVxuICAgIGxpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLm1hcCgoZXZlbnQpID0+IGV2ZW50Lmxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzXG4gICAgICAgICAgICAuZmlsdGVyKChldmVudCkgPT4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpKVxuICAgICAgICAgICAgLm1hcCgoZXZlbnQpID0+IGV2ZW50Lmxpc3RlbmVyKTtcbiAgICB9XG4gICAgb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZyB8fCBldmVudC5saXN0ZW5lciAhPSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpIHtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IFNpZ25lciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXJcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGhleGxpZnksIGhleFZhbHVlLCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgX1R5cGVkRGF0YUVuY29kZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsgY2hlY2tQcm9wZXJ0aWVzLCBkZWVwQ29weSwgZGVmaW5lUmVhZE9ubHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24sIHBvbGwgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBCYXNlUHJvdmlkZXIgfSBmcm9tIFwiLi9iYXNlLXByb3ZpZGVyXCI7XG5jb25zdCBlcnJvckdhcyA9IFtcImNhbGxcIiwgXCJlc3RpbWF0ZUdhc1wiXTtcbmZ1bmN0aW9uIHNwZWx1bmsodmFsdWUsIHJlcXVpcmVEYXRhKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIFRoZXNlICphcmUqIHRoZSBkcm9pZHMgd2UncmUgbG9va2luZyBmb3IuXG4gICAgaWYgKHR5cGVvZiAodmFsdWUubWVzc2FnZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubWVzc2FnZS5tYXRjaChcInJldmVydGVkXCIpKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpc0hleFN0cmluZyh2YWx1ZS5kYXRhKSA/IHZhbHVlLmRhdGEgOiBudWxsO1xuICAgICAgICBpZiAoIXJlcXVpcmVEYXRhIHx8IGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsIGRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTcGVsdW5rIGZ1cnRoZXIuLi5cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmsodmFsdWVba2V5XSwgcmVxdWlyZURhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIE1pZ2h0IGJlIGEgSlNPTiBzdHJpbmcgd2UgY2FuIGZ1cnRoZXIgZGVzY2VuZC4uLlxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNwZWx1bmsoSlNPTi5wYXJzZSh2YWx1ZSksIHJlcXVpcmVEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBwYXJhbXMudHJhbnNhY3Rpb24gfHwgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgIC8vIFVuZG8gdGhlIFwiY29udmVuaWVuY2VcIiBzb21lIG5vZGVzIGFyZSBhdHRlbXB0aW5nIHRvIHByZXZlbnQgYmFja3dhcmRzXG4gICAgLy8gaW5jb21wYXRpYmlsaXR5OyBtYXliZSBmb3IgdjYgY29uc2lkZXIgZm9yd2FyZGluZyByZXZlcnRzIGFzIGVycm9yc1xuICAgIGlmIChtZXRob2QgPT09IFwiY2FsbFwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNwZWx1bmsoZXJyb3IsIHRydWUpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90aGluZyBkZXNjcmlwdGl2ZS4uXG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXZlcnQgZGF0YSBpbiBjYWxsIGV4Y2VwdGlvbjsgVHJhbnNhY3Rpb24gcmV2ZXJ0ZWQgd2l0aG91dCBhIHJlYXNvbiBzdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgZGF0YTogXCIweFwiLCB0cmFuc2FjdGlvbiwgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBzb21ldGhpbmcsIHdpdGggYSBwcmVmZXJlbmNlIG9uIFNFUlZFUl9FUlJPUiBib2R5XG4gICAgICAgIGxldCByZXN1bHQgPSBzcGVsdW5rKGVycm9yLmJvZHksIGZhbHNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzcGVsdW5rKGVycm9yLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm91bmQgXCJyZXZlcnRlZFwiLCB0aGlzIGlzIGEgQ0FMTF9FWENFUFRJT05cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIExvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcbiAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5tZXNzYWdlLCBtZXRob2QsIHRyYW5zYWN0aW9uLCBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQFRPRE86IFNob3VsZCB3ZSBzcGVsdW5rIGZvciBtZXNzYWdlIHRvbz9cbiAgICBsZXQgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SICYmIGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLmJvZHk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgZ2FzICogcHJpY2UgKyB2YWx1ZSArIGNvc3QoZGF0YSlcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXR8SW5zdWZmaWNpZW50RnVuZHMvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJub25jZSB0b28gbG93XCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UgKGlzICk/dG9vIGxvdy9pKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWR8dHJhbnNhY3Rpb24gZ2FzIHByaWNlLip0b28gbG93L2kpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicmVwbGFjZW1lbnQgZmVlIHRvbyBsb3dcIiwgTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9vbmx5IHJlcGxheS1wcm90ZWN0ZWQvaSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3JHYXMuaW5kZXhPZihtZXRob2QpID49IDAgJiYgbWVzc2FnZS5tYXRjaCgvZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlfGFsd2F5cyBmYWlsaW5nIHRyYW5zYWN0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZHxyZXZlcnQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gdGltZXIodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC5lcnJvcikge1xuICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHByb3ZpZGVyLCBhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRvIG5vdCBjYWxsIHRoZSBKc29uUnBjU2lnbmVyIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgcHJvdmlkZXIuZ2V0U2lnbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICBpZiAoYWRkcmVzc09ySW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgYWRkcmVzc09ySW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWRkcmVzc1wiLCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3NPckluZGV4KSk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pbmRleFwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFkZHJlc3NPckluZGV4KSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWRkcmVzc1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3Mgb3IgaW5kZXhcIiwgXCJhZGRyZXNzT3JJbmRleFwiLCBhZGRyZXNzT3JJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgYWx0ZXIgSlNPTi1SUEMgU2lnbmVyIGNvbm5lY3Rpb25cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjb25uZWN0XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3RVbmNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5jaGVja2VkSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcy5wcm92aWRlciwgdGhpcy5fYWRkcmVzcyB8fCB0aGlzLl9pbmRleCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hZGRyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDw9IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiICsgdGhpcy5faW5kZXgsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRBZGRyZXNzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFjY291bnRzW3RoaXMuX2luZGV4XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBzaGFsbG93Q29weSh0cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGZyb21BZGRyZXNzID0gdGhpcy5nZXRBZGRyZXNzKCkudGhlbigoYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgSlNPTi1SUEMgZm9yIGV0aF9zZW5kVHJhbnNhY3Rpb24gdXNlcyA5MDAwMCBnYXM7IGlmIHRoZSB1c2VyXG4gICAgICAgIC8vIHdpc2hlcyB0byB1c2UgdGhpcywgaXQgaXMgZWFzeSB0byBzcGVjaWZ5IGV4cGxpY2l0bHksIG90aGVyd2lzZVxuICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGUgPSBzaGFsbG93Q29weSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBlc3RpbWF0ZS5mcm9tID0gZnJvbUFkZHJlc3M7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoZXN0aW1hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFByb21pc2UucmVzb2x2ZSh0cmFuc2FjdGlvbi50bykudGhlbigodG8pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUodG8pO1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVkIEVOUyBuYW1lIHJlc29sdmVzIHRvIG51bGxcIiwgXCJ0eC50b1wiLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICB0eDogcmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgc2VuZGVyOiBmcm9tQWRkcmVzc1xuICAgICAgICB9KS50aGVuKCh7IHR4LCBzZW5kZXIgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tLnRvTG93ZXJDYXNlKCkgIT09IHNlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR4LmZyb20gPSBzZW5kZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhUeCA9IHRoaXMucHJvdmlkZXIuY29uc3RydWN0b3IuaGV4bGlmeVRyYW5zYWN0aW9uKHR4LCB7IGZyb206IHRydWUgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKS50aGVuKChoYXNoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIiAmJiBlcnJvci5tZXNzYWdlLm1hdGNoKC91c2VyIGRlbmllZC9pKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZXIgcmVqZWN0ZWQgdHJhbnNhY3Rpb25cIiwgTG9nZ2VyLmVycm9ycy5BQ1RJT05fUkVKRUNURUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IoXCJzZW5kVHJhbnNhY3Rpb25cIiwgZXJyb3IsIGhleFR4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInNpZ25pbmcgdHJhbnNhY3Rpb25zIGlzIHVuc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnblRyYW5zYWN0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgbWluZWQgYW55IGVhcmxpZXIgdGhhbiBhbnkgcmVjZW50IGJsb2NrXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMucHJvdmlkZXIuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucHJvdmlkZXIucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgICAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcy5wcm92aWRlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKCh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF9zaWduXCIsIFtoZXhsaWZ5KGRhdGEpLCBhZGRyZXNzLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCBzaWduaW5nXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwic2lnbk1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YTogbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbGVnYWN5U2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2V0aF9zaWduXG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkoZGF0YSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCBzaWduaW5nXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiX2xlZ2FjeVNpZ25NZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURhdGE6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NpZ25UeXBlZERhdGEoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIGFueSBFTlMgbmFtZXMgKGluLXBsYWNlKVxuICAgICAgICAgICAgY29uc3QgcG9wdWxhdGVkID0geWllbGQgX1R5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoX1R5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiICYmIGVycm9yLm1lc3NhZ2UubWF0Y2goL3VzZXIgZGVuaWVkL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlciByZWplY3RlZCBzaWduaW5nXCIsIExvZ2dlci5lcnJvcnMuQUNUSU9OX1JFSkVDVEVELCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiX3NpZ25UeXBlZERhdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGF0YTogeyBkb21haW46IHBvcHVsYXRlZC5kb21haW4sIHR5cGVzLCB2YWx1ZTogcG9wdWxhdGVkLnZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5sb2NrKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXI7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW2FkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxdKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVW5jaGVja2VkSnNvblJwY1NpZ25lciBleHRlbmRzIEpzb25ScGNTaWduZXIge1xuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oKGhhc2gpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICBub25jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogbnVsbCxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogMCxcbiAgICAgICAgICAgICAgICBmcm9tOiBudWxsLFxuICAgICAgICAgICAgICAgIHdhaXQ6IChjb25maXJtYXRpb25zKSA9PiB7IHJldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBjb25maXJtYXRpb25zKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcbiAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdmFsdWU6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSwgYWNjZXNzTGlzdDogdHJ1ZSxcbiAgICBtYXhGZWVQZXJHYXM6IHRydWUsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cnVlXG59O1xuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrKSB7XG4gICAgICAgIGxldCBuZXR3b3JrT3JSZWFkeSA9IG5ldHdvcms7XG4gICAgICAgIC8vIFRoZSBuZXR3b3JrIGlzIHVua25vd24sIHF1ZXJ5IHRoZSBKU09OLVJQQyBmb3IgaXRcbiAgICAgICAgaWYgKG5ldHdvcmtPclJlYWR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRldGVjdE5ldHdvcmsoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29ya09yUmVhZHkpO1xuICAgICAgICAvLyBEZWZhdWx0IFVSTFxuICAgICAgICBpZiAoIXVybCkge1xuICAgICAgICAgICAgdXJsID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZGVmYXVsdFVybFwiKSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb25uZWN0aW9uXCIsIE9iamVjdC5mcmVlemUoc2hhbGxvd0NvcHkodXJsKSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25leHRJZCA9IDQyO1xuICAgIH1cbiAgICBnZXQgX2NhY2hlKCkge1xuICAgICAgICBpZiAodGhpcy5fZXZlbnRMb29wQ2FjaGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRMb29wQ2FjaGUgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRMb29wQ2FjaGU7XG4gICAgfVxuICAgIHN0YXRpYyBkZWZhdWx0VXJsKCkge1xuICAgICAgICByZXR1cm4gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuICAgIH1cbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdID0gdGhpcy5fdW5jYWNoZWREZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGlzIGNhY2hlIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5leHQgZXZlbnQgbG9vcFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl07XG4gICAgfVxuICAgIF91bmNhY2hlZERldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aW1lcigwKTtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHlpZWxkIHRoaXMuc2VuZChcImV0aF9jaGFpbklkXCIsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSB5aWVsZCB0aGlzLnNlbmQoXCJuZXRfdmVyc2lvblwiLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0TmV0d29yayA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldE5ldHdvcmtcIik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsoQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjb3VsZCBub3QgZGV0ZWN0IG5ldHdvcmtcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiaW52YWxpZE5ldHdvcmtcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJjb3VsZCBub3QgZGV0ZWN0IG5ldHdvcmtcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IFwibm9OZXR3b3JrXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcywgYWRkcmVzc09ySW5kZXgpO1xuICAgIH1cbiAgICBnZXRVbmNoZWNrZWRTaWduZXIoYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KS5jb25uZWN0VW5jaGVja2VkKCk7XG4gICAgfVxuICAgIGxpc3RBY2NvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSkudGhlbigoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50cy5tYXAoKGEpID0+IHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MoYSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGlkOiAodGhpcy5fbmV4dElkKyspLFxuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgY2FuIGV4cGFuZCB0aGlzIGluIHRoZSBmdXR1cmUgdG8gYW55IGNhbGwsIGJ1dCBmb3Igbm93IHRoZXNlXG4gICAgICAgIC8vIGFyZSB0aGUgYmlnZ2VzdCB3aW5zIGFuZCBkbyBub3QgcmVxdWlyZSBhbnkgc2VyaWFsaXppbmcgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgY2FjaGUgPSAoW1wiZXRoX2NoYWluSWRcIiwgXCJldGhfYmxvY2tOdW1iZXJcIl0uaW5kZXhPZihtZXRob2QpID49IDApO1xuICAgICAgICBpZiAoY2FjaGUgJiYgdGhpcy5fY2FjaGVbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW21ldGhvZF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGZldGNoLCBidXQgY2xlYXIgaXQgb24gdGhlIG5leHQgZXZlbnQgbG9vcFxuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSByZXN1bHQ7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2Jsb2NrTnVtYmVyXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2FzUHJpY2VcIiwgW11dO1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJhbGFuY2VcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uQ291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldENvZGVcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0U3RvcmFnZUF0XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBoZXhaZXJvUGFkKHBhcmFtcy5wb3NpdGlvbiwgMzIpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLCBbcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLCBbcGFyYW1zLmJsb2NrVGFnLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5SGFzaFwiLCBbcGFyYW1zLmJsb2NrSGFzaCwgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleGxpZnlUcmFuc2FjdGlvbiA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImhleGxpZnlUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2NhbGxcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleGxpZnlUcmFuc2FjdGlvbiA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImhleGxpZnlUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2VzdGltYXRlR2FzXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgJiYgcGFyYW1zLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHBhcmFtcy5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0TG9nc1wiLCBbcGFyYW1zLmZpbHRlcl1dO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiB8fCBtZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gcGFyYW1zLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgQmlnTnVtYmVyLmZyb20odHgudHlwZSkuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIG5vbi1FSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHlpZWxkIHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IGtub3cgYWJvdXQgRUlQLTE1NTkgKGFuZCBoZW5jZSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHNoYWxsb3dDb3B5KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudHJhbnNhY3Rpb24udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNlbmQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9zdGFydEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX3N0YXJ0UGVuZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBwZW5kaW5nRmlsdGVyID0gdGhpcy5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdGaWx0ZXIgPSBwZW5kaW5nRmlsdGVyO1xuICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2xsKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pLnRoZW4oZnVuY3Rpb24gKGhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYXQgc29tZSBwb2ludC4uLiBIb3c/IFdoZW4/XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcSA9IHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRUcmFuc2FjdGlvbihoYXNoKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBwb2xsKCk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICB9XG4gICAgX3N0b3BFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFnID09PSBcInBlbmRpbmdcIiAmJiB0aGlzLmxpc3RlbmVyQ291bnQoXCJwZW5kaW5nXCIpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RvcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBhbiBldGhlcnMuanMgdHJhbnNhY3Rpb24gaW50byBhIEpTT04tUlBDIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gZ2FzTGltaXQgPT4gZ2FzXG4gICAgLy8gIC0gQWxsIHZhbHVlcyBoZXhsaWZpZWRcbiAgICAvLyAgLSBBbGwgbnVtZXJpYyB2YWx1ZXMgemVyby1zdHJpcGVkXG4gICAgLy8gIC0gQWxsIGFkZHJlc3NlcyBhcmUgbG93ZXJjYXNlZFxuICAgIC8vIE5PVEU6IFRoaXMgYWxsb3dzIGEgVHJhbnNhY3Rpb25SZXF1ZXN0LCBidXQgYWxsIHZhbHVlcyBzaG91bGQgYmUgcmVzb2x2ZWRcbiAgICAvLyAgICAgICBiZWZvcmUgdGhpcyBpcyBjYWxsZWRcbiAgICAvLyBAVE9ETzogVGhpcyB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBhbmQgcHJlcGFyZVJlcXVlc3RcbiAgICAvLyAgICAgICAgd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZCBmb3IgdGhpcy5cbiAgICBzdGF0aWMgaGV4bGlmeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBhbGxvd0V4dHJhKSB7XG4gICAgICAgIC8vIENoZWNrIG9ubHkgYWxsb3dlZCBwcm9wZXJ0aWVzIGFyZSBnaXZlblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2hhbGxvd0NvcHkoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgICAgIGlmIChhbGxvd0V4dHJhKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxvd0V4dHJhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93RXh0cmFba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sIGFsbG93ZWQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGV4VmFsdWUoQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb25ba2V5XSkpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gXCJnYXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaGV4bGlmeSh0cmFuc2FjdGlvbltrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhY2Nlc3NMaXN0XCJdID0gYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tcnBjLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL2pzb24tcnBjLXByb3ZpZGVyXCI7XG5sZXQgX25leHRJZCA9IDE7XG5mdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuICAgIGNvbnN0IGZldGNoZXIgPSBcIldlYjNMZWdhY3lGZXRjaGVyXCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGlkOiAoX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZGVlcENvcHkocmVxdWVzdCksXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZEZ1bmMocmVxdWVzdCwgKGVycm9yLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihyZXNwb25zZS5lcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IHJlc3BvbnNlLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmRhdGEgPSByZXNwb25zZS5lcnJvci5kYXRhO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IG1ldGhvZCwgcGFyYW1zIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnQgY2xhc3MgV2ViM1Byb3ZpZGVyIGV4dGVuZHMgSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgbmV0d29yaykge1xuICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBsZXQganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG4gICAgICAgIGxldCBzdWJwcm92aWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHByb3ZpZGVyLmhvc3QgfHwgcHJvdmlkZXIucGF0aCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGF0aCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViMy1wcm92aWRlci5qcy5tYXAiLCIvLyBFdmVudHMgYmVpbmcgZW1pdHRlZCBieSBhbiBlaXAtMTE5MyBwcm92aWRlclxyXG4vLyBTZWUgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzI2V2ZW50c1xyXG5leHBvcnQgY29uc3QgRXRoZXJldW1FdmVudHMgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIENPTk5FQ1Q6ICdjb25uZWN0JyxcclxuICAgIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcclxuICAgIENIQUlOX0NIQU5HRUQ6ICdjaGFpbkNoYW5nZWQnLFxyXG4gICAgQUNDT1VOVFNfQ0hBTkdFRDogJ2FjY291bnRzQ2hhbmdlZCcsXHJcbn0pO1xyXG5cclxuLy8gRXZlbnRzIGVtaXR0ZWQgYnkgdGhlIGNvbm5lY3RvcnMsXHJcbi8vIFRoZSBJbnRlcm5hbFdlYjNQcm92aWRlciBvZiBNb3JhbGlzIHdpbGwgbGlzdGVuIHRvIHRoZXNlXHJcbmV4cG9ydCBjb25zdCBDb25uZWN0b3JFdmVudHMgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIENPTk5FQ1Q6ICdjb25uZWN0JyxcclxuICAgIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcclxuICAgIENIQUlOX0NIQU5HRUQ6ICdjaGFpbkNoYW5nZWQnLFxyXG4gICAgQUNDT1VOVF9DSEFOR0VEOiAnYWNjb3VudENoYW5nZWQnLFxyXG59KTtcclxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQge0Nvbm5lY3RvckV2ZW50cywgRXRoZXJldW1FdmVudHN9IGZyb20gJy4vZXZlbnRzJztcclxuaW1wb3J0IHtldGhlcnN9IGZyb20gXCJldGhlcnNcIjtcclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBjb25uZWN0b3IgdG8gY29ubmVjdCBFSVAtMTE5MyBwcm92aWRlcnMgdG8gTW9yYWxpc1xyXG4gKlxyXG4gKiBJdCBzaG91bGQgaW1wbGVtZW50IGF0IGxlYXN0OlxyXG4gKiAtIGFjdGl2YXRlKClcclxuICogLSBFbWl0IENvbm5lY3RvckV2ZW50LkNIQUlOX0NIQU5HRUQgd2hlbiB0aGUgY2hhaW4gaGFzIGNoYW5nZWQgKGlmIHBvc3NpYmxlKVxyXG4gKiAtIEVtaXQgQ29ubmVjdG9yRXZlbnQuQUNDT1VOVF9DSEFOR0VEIHdoZW4gdGhlIGFjY291bnQgaGFzIGNoYW5nZWQgKGlmIHBvc3NpYmxlKVxyXG4gKiAtIHR5cGU6IGEgbmFtZSB0byBpZGVudGlmeVxyXG4gKiAtIG5ldHdvcms6IHRoZSBuZXR3b3JrIHR5cGUgdGhhdCBpcyB1c2VkIChlZy4gJ2V2bScpXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFdlYjNDb25uZWN0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgdHlwZSA9ICdhYnN0cmFjdCc7XHJcbiAgICBuZXR3b3JrID0gJ2V2bSc7XHJcbiAgICBhY2NvdW50OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgIGNoYWluSWQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gICAgcHJvdmlkZXI/OiBldGhlcnMucHJvdmlkZXJzLkV4dGVybmFsUHJvdmlkZXIgfCBudWxsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVBY2NvdW50c0NoYW5nZWQgPSB0aGlzLmhhbmRsZUFjY291bnRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhaW5DaGFuZ2VkID0gdGhpcy5oYW5kbGVDaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZUNvbm5lY3QgPSB0aGlzLmhhbmRsZUNvbm5lY3QuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QgPSB0aGlzLmhhbmRsZURpc2Nvbm5lY3QuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBzdWJzY3JpYmVUb0V2ZW50cyhwcm92aWRlcjogYW55KSB7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyICYmIHByb3ZpZGVyLm9uKSB7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLm9uKEV0aGVyZXVtRXZlbnRzLkNIQUlOX0NIQU5HRUQsIHRoaXMuaGFuZGxlQ2hhaW5DaGFuZ2VkKTtcclxuICAgICAgICAgICAgcHJvdmlkZXIub24oRXRoZXJldW1FdmVudHMuQUNDT1VOVFNfQ0hBTkdFRCwgdGhpcy5oYW5kbGVBY2NvdW50c0NoYW5nZWQpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5vbihFdGhlcmV1bUV2ZW50cy5DT05ORUNULCB0aGlzLmhhbmRsZUNvbm5lY3QpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5vbihFdGhlcmV1bUV2ZW50cy5ESVNDT05ORUNULCB0aGlzLmhhbmRsZURpc2Nvbm5lY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1bnN1YnNjcmliZVRvRXZlbnRzKHByb3ZpZGVyOiBhbnkpIHtcclxuICAgICAgICBpZiAocHJvdmlkZXIgJiYgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoRXRoZXJldW1FdmVudHMuQ0hBSU5fQ0hBTkdFRCwgdGhpcy5oYW5kbGVDaGFpbkNoYW5nZWQpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcihFdGhlcmV1bUV2ZW50cy5BQ0NPVU5UU19DSEFOR0VELCB0aGlzLmhhbmRsZUFjY291bnRzQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKEV0aGVyZXVtRXZlbnRzLkNPTk5FQ1QsIHRoaXMuaGFuZGxlQ29ubmVjdCk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKEV0aGVyZXVtRXZlbnRzLkRJU0NPTk5FQ1QsIHRoaXMuaGFuZGxlRGlzY29ubmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGVzIHRoZSBwcm92aWRlci5cclxuICAgICAqIFNob3VsZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoOlxyXG4gICAgICogLSBwcm92aWRlcjogQSB2YWxpZCBFSVAtMTE5MyBwcm92aWRlclxyXG4gICAgICogLSBjaGFpbklkKG9wdGlvbmFsKTogdGhlIGNoYWluSWQgdGhhdCBoYXMgYmVlbiBjb25uZWN0ZWQgdG8gKGluIGhleCBmb3JtYXQpXHJcbiAgICAgKiAtIGFjY291bnQob3B0aW9uYWwpOiB0aGUgYWRkcmVzcyB0aGF0IGlzIGNvbm5lY3RlZCB0byB0aGUgcHJvdmlkZXJcclxuICAgICAqL1xyXG4gICAgYXN5bmMgYWN0aXZhdGUoKTogUHJvbWlzZTx7XHJcbiAgICAgICAgcHJvdmlkZXI6IGFueSxcclxuICAgICAgICBhY2NvdW50OiBhbnksXHJcbiAgICAgICAgY2hhaW5JZDogYW55XHJcbiAgICB9PiB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQ6IGFjdGl2YXRlKCknKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYWNjb3VudCBhbmQgZW1pdCBldmVudCwgb24gRUlQLTExOTMgYWNjb3VudHNDaGFuZ2VkIGV2ZW50c1xyXG4gICAgICovXHJcbiAgICBoYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHM6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50cyAmJiBhY2NvdW50c1swXSA/IGFjY291bnRzWzBdLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQ7XHJcbiAgICAgICAgdGhpcy5lbWl0KENvbm5lY3RvckV2ZW50cy5BQ0NPVU5UX0NIQU5HRUQsIGFjY291bnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBjaGFpbklkIGFuZCBlbWl0IGV2ZW50LCBvbiBFSVAtMTE5MyBhY2NvdW50c0NoYW5nZWQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUNoYWluQ2hhbmdlZChjaGFpbklkOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBuZXdDaGFpbklkID0gY2hhaW5JZDtcclxuICAgICAgICB0aGlzLmNoYWluSWQgPSBuZXdDaGFpbklkO1xyXG4gICAgICAgIHRoaXMuZW1pdChDb25uZWN0b3JFdmVudHMuQ0hBSU5fQ0hBTkdFRCwgbmV3Q2hhaW5JZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlQ29ubmVjdChjb25uZWN0SW5mbzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KENvbm5lY3RvckV2ZW50cy5DT05ORUNULCBjb25uZWN0SW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlRGlzY29ubmVjdChlcnJvcjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KENvbm5lY3RvckV2ZW50cy5ESVNDT05ORUNULCBlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbnMgYWxsIGFjdGl2ZSBsaXN0bmVycywgY29ubmVjdGlvbnMgYW5kIHN0YWxlIHJlZmVyZW5jZXNcclxuICAgICAqL1xyXG4gICAgYXN5bmMgZGVhY3RpdmF0ZSgpIHtcclxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9FdmVudHModGhpcy5wcm92aWRlcik7XHJcblxyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGFpbklkID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RXZWIzQ29ubmVjdG9yO1xyXG4iLCJ2YXIgYT0obj0+KG4uTWlzc2luZ0FwaUtleT1cIk1JU1NJTkdfQVBJX0tFWVwiLG4uTW9kYWxOb3RSZWFkeT1cIk1PREFMX05PVF9SRUFEWVwiLG4uTWFsZm9ybWVkUmVzcG9uc2U9XCJNQUxGT1JNRURfUkVTUE9OU0VcIixuLkludmFsaWRBcmd1bWVudD1cIklOVkFMSURfQVJHVU1FTlRcIixuLkV4dGVuc2lvbk5vdEluaXRpYWxpemVkPVwiRVhURU5TSU9OX05PVF9JTklUSUFMSVpFRFwiLG4uSW5jb21wYXRpYmxlRXh0ZW5zaW9ucz1cIklOQ09NUEFUSUJMRV9FWFRFTlNJT05TXCIsbikpKGF8fHt9KSxtPShfPT4oXy5TeW5jV2ViM01ldGhvZD1cIlNZTkNfV0VCM19NRVRIT0RcIixfLkR1cGxpY2F0ZUlmcmFtZT1cIkRVUExJQ0FURV9JRlJBTUVcIixfLlJlYWN0TmF0aXZlRW5kcG9pbnRDb25maWd1cmF0aW9uPVwiUkVBQ1RfTkFUSVZFX0VORFBPSU5UX0NPTkZJR1VSQVRJT05cIixfLkRlcHJlY2F0aW9uTm90aWNlPVwiREVQUkVDQVRJT05fTk9USUNFXCIsXykpKG18fHt9KSxwPShlPT4oZVtlLlBhcnNlRXJyb3I9LTMyNzAwXT1cIlBhcnNlRXJyb3JcIixlW2UuSW52YWxpZFJlcXVlc3Q9LTMyNjAwXT1cIkludmFsaWRSZXF1ZXN0XCIsZVtlLk1ldGhvZE5vdEZvdW5kPS0zMjYwMV09XCJNZXRob2ROb3RGb3VuZFwiLGVbZS5JbnZhbGlkUGFyYW1zPS0zMjYwMl09XCJJbnZhbGlkUGFyYW1zXCIsZVtlLkludGVybmFsRXJyb3I9LTMyNjAzXT1cIkludGVybmFsRXJyb3JcIixlW2UuTWFnaWNMaW5rRmFpbGVkVmVyaWZpY2F0aW9uPS0xZTRdPVwiTWFnaWNMaW5rRmFpbGVkVmVyaWZpY2F0aW9uXCIsZVtlLk1hZ2ljTGlua0V4cGlyZWQ9LTEwMDAxXT1cIk1hZ2ljTGlua0V4cGlyZWRcIixlW2UuTWFnaWNMaW5rUmF0ZUxpbWl0ZWQ9LTEwMDAyXT1cIk1hZ2ljTGlua1JhdGVMaW1pdGVkXCIsZVtlLk1hZ2ljTGlua0ludmFsaWRSZWRpcmVjdFVSTD0tMTAwMDZdPVwiTWFnaWNMaW5rSW52YWxpZFJlZGlyZWN0VVJMXCIsZVtlLlVzZXJBbHJlYWR5TG9nZ2VkSW49LTEwMDAzXT1cIlVzZXJBbHJlYWR5TG9nZ2VkSW5cIixlW2UuVXBkYXRlRW1haWxGYWlsZWQ9LTEwMDA0XT1cIlVwZGF0ZUVtYWlsRmFpbGVkXCIsZVtlLlVzZXJSZXF1ZXN0RWRpdEVtYWlsPS0xMDAwNV09XCJVc2VyUmVxdWVzdEVkaXRFbWFpbFwiLGVbZS5JbmFjdGl2ZVJlY2lwaWVudD0tMTAwMTBdPVwiSW5hY3RpdmVSZWNpcGllbnRcIixlW2UuQWNjZXNzRGVuaWVkVG9Vc2VyPS0xMDAxMV09XCJBY2Nlc3NEZW5pZWRUb1VzZXJcIixlKSkocHx8e30pO3ZhciB1PSh0PT4odC5Mb2dpbldpdGhTbXM9XCJtYWdpY19hdXRoX2xvZ2luX3dpdGhfc21zXCIsdC5Mb2dpbldpdGhFbWFpbE9UUD1cIm1hZ2ljX2F1dGhfbG9naW5fd2l0aF9lbWFpbF9vdHBcIix0LkxvZ2luV2l0aE1hZ2ljTGluaz1cIm1hZ2ljX2F1dGhfbG9naW5fd2l0aF9tYWdpY19saW5rXCIsdC5Mb2dpbldpdGhDcmVkZW50aWFsPVwibWFnaWNfYXV0aF9sb2dpbl93aXRoX2NyZWRlbnRpYWxcIix0LkdldElkVG9rZW49XCJtYWdpY19hdXRoX2dldF9pZF90b2tlblwiLHQuR2VuZXJhdGVJZFRva2VuPVwibWFnaWNfYXV0aF9nZW5lcmF0ZV9pZF90b2tlblwiLHQuR2V0TWV0YWRhdGE9XCJtYWdpY19hdXRoX2dldF9tZXRhZGF0YVwiLHQuSXNMb2dnZWRJbj1cIm1hZ2ljX2F1dGhfaXNfbG9nZ2VkX2luXCIsdC5Mb2dvdXQ9XCJtYWdpY19hdXRoX2xvZ291dFwiLHQuVXBkYXRlRW1haWw9XCJtYWdpY19hdXRoX3VwZGF0ZV9lbWFpbFwiLHQuVXNlclNldHRpbmdzPVwibWFnaWNfYXV0aF9zZXR0aW5nc1wiLHQuVXNlclNldHRpbmdzVGVzdE1vZGU9XCJtYWdpY19hdXRoX3NldHRpbmdzX3Rlc3RpbmdfbW9kZVwiLHQuTG9naW5XaXRoU21zVGVzdE1vZGU9XCJtYWdpY19hdXRoX2xvZ2luX3dpdGhfc21zX3Rlc3RpbmdfbW9kZVwiLHQuTG9naW5XaXRoRW1haWxPVFBUZXN0TW9kZT1cIm1hZ2ljX2F1dGhfbG9naW5fd2l0aF9lbWFpbF9vdHBfdGVzdGluZ19tb2RlXCIsdC5Mb2dpbldpdGhNYWdpY0xpbmtUZXN0TW9kZT1cIm1hZ2ljX2xvZ2luX3dpdGhfbWFnaWNfbGlua190ZXN0aW5nX21vZGVcIix0LkxvZ2luV2l0aENyZWRlbnRpYWxUZXN0TW9kZT1cIm1hZ2ljX2F1dGhfbG9naW5fd2l0aF9jcmVkZW50aWFsX3Rlc3RpbmdfbW9kZVwiLHQuR2V0SWRUb2tlblRlc3RNb2RlPVwibWFnaWNfYXV0aF9nZXRfaWRfdG9rZW5fdGVzdGluZ19tb2RlXCIsdC5HZW5lcmF0ZUlkVG9rZW5UZXN0TW9kZT1cIm1hZ2ljX2F1dGhfZ2VuZXJhdGVfaWRfdG9rZW5fdGVzdGluZ19tb2RlXCIsdC5HZXRNZXRhZGF0YVRlc3RNb2RlPVwibWFnaWNfYXV0aF9nZXRfbWV0YWRhdGFfdGVzdGluZ19tb2RlXCIsdC5Jc0xvZ2dlZEluVGVzdE1vZGU9XCJtYWdpY19hdXRoX2lzX2xvZ2dlZF9pbl90ZXN0aW5nX21vZGVcIix0LkxvZ291dFRlc3RNb2RlPVwibWFnaWNfYXV0aF9sb2dvdXRfdGVzdGluZ19tb2RlXCIsdC5VcGRhdGVFbWFpbFRlc3RNb2RlPVwibWFnaWNfYXV0aF91cGRhdGVfZW1haWxfdGVzdGluZ19tb2RlXCIsdC5JbnRlcm1lZGlhcnlFdmVudD1cIm1hZ2ljX2ludGVybWVkaWFyeV9ldmVudFwiLHQpKSh1fHx7fSk7dmFyIGc9KGk9PihpLk1BR0lDX0hBTkRMRV9SRVNQT05TRT1cIk1BR0lDX0hBTkRMRV9SRVNQT05TRVwiLGkuTUFHSUNfT1ZFUkxBWV9SRUFEWT1cIk1BR0lDX09WRVJMQVlfUkVBRFlcIixpLk1BR0lDX1NIT1dfT1ZFUkxBWT1cIk1BR0lDX1NIT1dfT1ZFUkxBWVwiLGkuTUFHSUNfSElERV9PVkVSTEFZPVwiTUFHSUNfSElERV9PVkVSTEFZXCIsaS5NQUdJQ19IQU5ETEVfRVZFTlQ9XCJNQUdJQ19IQU5ETEVfRVZFTlRcIixpKSkoZ3x8e30pLG89KHM9PihzLk1BR0lDX0hBTkRMRV9SRVFVRVNUPVwiTUFHSUNfSEFORExFX1JFUVVFU1RcIixzKSkob3x8e30pO3ZhciBsPShzPT4ocy5IYXJtb255PVwiSEFSTU9OWVwiLHMpKShsfHx7fSk7ZXhwb3J0e2wgYXMgRXRoQ2hhaW5UeXBlLGcgYXMgTWFnaWNJbmNvbWluZ1dpbmRvd01lc3NhZ2UsbyBhcyBNYWdpY091dGdvaW5nV2luZG93TWVzc2FnZSx1IGFzIE1hZ2ljUGF5bG9hZE1ldGhvZCxwIGFzIFJQQ0Vycm9yQ29kZSxhIGFzIFNES0Vycm9yQ29kZSxtIGFzIFNES1dhcm5pbmdDb2RlfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsInZhciB5dD1PYmplY3QuY3JlYXRlO3ZhciBVPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxSdD1PYmplY3QuZGVmaW5lUHJvcGVydGllcyxUdD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLHZ0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzLHh0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLCRlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsSXQ9T2JqZWN0LmdldFByb3RvdHlwZU9mLE1lPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksUHQ9T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTt2YXIgTmU9KHQsZSxuKT0+ZSBpbiB0P1UodCxlLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpufSk6dFtlXT1uLHo9KHQsZSk9Pntmb3IodmFyIG4gaW4gZXx8KGU9e30pKU1lLmNhbGwoZSxuKSYmTmUodCxuLGVbbl0pO2lmKCRlKWZvcih2YXIgbiBvZiAkZShlKSlQdC5jYWxsKGUsbikmJk5lKHQsbixlW25dKTtyZXR1cm4gdH0sd2U9KHQsZSk9PlJ0KHQsdnQoZSkpLGJ0PXQ9PlUodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgJHQ9KHQsZSk9PigpPT4oZXx8dCgoZT17ZXhwb3J0czp7fX0pLmV4cG9ydHMsZSksZS5leHBvcnRzKSxNdD0odCxlKT0+e2Zvcih2YXIgbiBpbiBlKVUodCxuLHtnZXQ6ZVtuXSxlbnVtZXJhYmxlOiEwfSl9LE50PSh0LGUsbixyKT0+e2lmKGUmJnR5cGVvZiBlPT1cIm9iamVjdFwifHx0eXBlb2YgZT09XCJmdW5jdGlvblwiKWZvcihsZXQgcyBvZiB4dChlKSkhTWUuY2FsbCh0LHMpJiYobnx8cyE9PVwiZGVmYXVsdFwiKSYmVSh0LHMse2dldDooKT0+ZVtzXSxlbnVtZXJhYmxlOiEocj1UdChlLHMpKXx8ci5lbnVtZXJhYmxlfSk7cmV0dXJuIHR9LHd0PSh0LGUpPT5OdChidChVKHQhPW51bGw/eXQoSXQodCkpOnt9LFwiZGVmYXVsdFwiLCFlJiZ0JiZ0Ll9fZXNNb2R1bGU/e2dldDooKT0+dC5kZWZhdWx0LGVudW1lcmFibGU6ITB9Ont2YWx1ZTp0LGVudW1lcmFibGU6ITB9KSksdCk7dmFyIEk9KHQsZSxuKT0+bmV3IFByb21pc2UoKHIscyk9Pnt2YXIgbz1jPT57dHJ5e2kobi5uZXh0KGMpKX1jYXRjaChwKXtzKHApfX0sYT1jPT57dHJ5e2kobi50aHJvdyhjKSl9Y2F0Y2gocCl7cyhwKX19LGk9Yz0+Yy5kb25lP3IoYy52YWx1ZSk6UHJvbWlzZS5yZXNvbHZlKGMudmFsdWUpLnRoZW4obyxhKTtpKChuPW4uYXBwbHkodCxlKSkubmV4dCgpKX0pO3ZhciBudD0kdCgoZ3IsZmUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGJuPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksVD1cIn5cIjtmdW5jdGlvbiBCKCl7fU9iamVjdC5jcmVhdGUmJihCLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKG51bGwpLG5ldyBCKCkuX19wcm90b19ffHwoVD0hMSkpO2Z1bmN0aW9uICRuKHQsZSxuKXt0aGlzLmZuPXQsdGhpcy5jb250ZXh0PWUsdGhpcy5vbmNlPW58fCExfWZ1bmN0aW9uIHR0KHQsZSxuLHIscyl7aWYodHlwZW9mIG4hPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTt2YXIgbz1uZXcgJG4obixyfHx0LHMpLGE9VD9UK2U6ZTtyZXR1cm4gdC5fZXZlbnRzW2FdP3QuX2V2ZW50c1thXS5mbj90Ll9ldmVudHNbYV09W3QuX2V2ZW50c1thXSxvXTp0Ll9ldmVudHNbYV0ucHVzaChvKToodC5fZXZlbnRzW2FdPW8sdC5fZXZlbnRzQ291bnQrKyksdH1mdW5jdGlvbiBvZSh0LGUpey0tdC5fZXZlbnRzQ291bnQ9PT0wP3QuX2V2ZW50cz1uZXcgQjpkZWxldGUgdC5fZXZlbnRzW2VdfWZ1bmN0aW9uIHkoKXt0aGlzLl9ldmVudHM9bmV3IEIsdGhpcy5fZXZlbnRzQ291bnQ9MH15LnByb3RvdHlwZS5ldmVudE5hbWVzPWZ1bmN0aW9uKCl7dmFyIGU9W10sbixyO2lmKHRoaXMuX2V2ZW50c0NvdW50PT09MClyZXR1cm4gZTtmb3IociBpbiBuPXRoaXMuX2V2ZW50cylibi5jYWxsKG4scikmJmUucHVzaChUP3Iuc2xpY2UoMSk6cik7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSk6ZX07eS5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciBuPVQ/VCtlOmUscj10aGlzLl9ldmVudHNbbl07aWYoIXIpcmV0dXJuW107aWYoci5mbilyZXR1cm5bci5mbl07Zm9yKHZhciBzPTAsbz1yLmxlbmd0aCxhPW5ldyBBcnJheShvKTtzPG87cysrKWFbc109cltzXS5mbjtyZXR1cm4gYX07eS5wcm90b3R5cGUubGlzdGVuZXJDb3VudD1mdW5jdGlvbihlKXt2YXIgbj1UP1QrZTplLHI9dGhpcy5fZXZlbnRzW25dO3JldHVybiByP3IuZm4/MTpyLmxlbmd0aDowfTt5LnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKGUsbixyLHMsbyxhKXt2YXIgaT1UP1QrZTplO2lmKCF0aGlzLl9ldmVudHNbaV0pcmV0dXJuITE7dmFyIGM9dGhpcy5fZXZlbnRzW2ldLHA9YXJndW1lbnRzLmxlbmd0aCxsLHU7aWYoYy5mbil7c3dpdGNoKGMub25jZSYmdGhpcy5yZW1vdmVMaXN0ZW5lcihlLGMuZm4sdm9pZCAwLCEwKSxwKXtjYXNlIDE6cmV0dXJuIGMuZm4uY2FsbChjLmNvbnRleHQpLCEwO2Nhc2UgMjpyZXR1cm4gYy5mbi5jYWxsKGMuY29udGV4dCxuKSwhMDtjYXNlIDM6cmV0dXJuIGMuZm4uY2FsbChjLmNvbnRleHQsbixyKSwhMDtjYXNlIDQ6cmV0dXJuIGMuZm4uY2FsbChjLmNvbnRleHQsbixyLHMpLCEwO2Nhc2UgNTpyZXR1cm4gYy5mbi5jYWxsKGMuY29udGV4dCxuLHIscyxvKSwhMDtjYXNlIDY6cmV0dXJuIGMuZm4uY2FsbChjLmNvbnRleHQsbixyLHMsbyxhKSwhMH1mb3IodT0xLGw9bmV3IEFycmF5KHAtMSk7dTxwO3UrKylsW3UtMV09YXJndW1lbnRzW3VdO2MuZm4uYXBwbHkoYy5jb250ZXh0LGwpfWVsc2V7dmFyIHY9Yy5sZW5ndGgsTTtmb3IodT0wO3U8djt1Kyspc3dpdGNoKGNbdV0ub25jZSYmdGhpcy5yZW1vdmVMaXN0ZW5lcihlLGNbdV0uZm4sdm9pZCAwLCEwKSxwKXtjYXNlIDE6Y1t1XS5mbi5jYWxsKGNbdV0uY29udGV4dCk7YnJlYWs7Y2FzZSAyOmNbdV0uZm4uY2FsbChjW3VdLmNvbnRleHQsbik7YnJlYWs7Y2FzZSAzOmNbdV0uZm4uY2FsbChjW3VdLmNvbnRleHQsbixyKTticmVhaztjYXNlIDQ6Y1t1XS5mbi5jYWxsKGNbdV0uY29udGV4dCxuLHIscyk7YnJlYWs7ZGVmYXVsdDppZighbClmb3IoTT0xLGw9bmV3IEFycmF5KHAtMSk7TTxwO00rKylsW00tMV09YXJndW1lbnRzW01dO2NbdV0uZm4uYXBwbHkoY1t1XS5jb250ZXh0LGwpfX1yZXR1cm4hMH07eS5wcm90b3R5cGUub249ZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0dCh0aGlzLGUsbixyLCExKX07eS5wcm90b3R5cGUub25jZT1mdW5jdGlvbihlLG4scil7cmV0dXJuIHR0KHRoaXMsZSxuLHIsITApfTt5LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihlLG4scixzKXt2YXIgbz1UP1QrZTplO2lmKCF0aGlzLl9ldmVudHNbb10pcmV0dXJuIHRoaXM7aWYoIW4pcmV0dXJuIG9lKHRoaXMsbyksdGhpczt2YXIgYT10aGlzLl9ldmVudHNbb107aWYoYS5mbilhLmZuPT09biYmKCFzfHxhLm9uY2UpJiYoIXJ8fGEuY29udGV4dD09PXIpJiZvZSh0aGlzLG8pO2Vsc2V7Zm9yKHZhciBpPTAsYz1bXSxwPWEubGVuZ3RoO2k8cDtpKyspKGFbaV0uZm4hPT1ufHxzJiYhYVtpXS5vbmNlfHxyJiZhW2ldLmNvbnRleHQhPT1yKSYmYy5wdXNoKGFbaV0pO2MubGVuZ3RoP3RoaXMuX2V2ZW50c1tvXT1jLmxlbmd0aD09PTE/Y1swXTpjOm9lKHRoaXMsbyl9cmV0dXJuIHRoaXN9O3kucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgbjtyZXR1cm4gZT8obj1UP1QrZTplLHRoaXMuX2V2ZW50c1tuXSYmb2UodGhpcyxuKSk6KHRoaXMuX2V2ZW50cz1uZXcgQix0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzfTt5LnByb3RvdHlwZS5vZmY9eS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7eS5wcm90b3R5cGUuYWRkTGlzdGVuZXI9eS5wcm90b3R5cGUub247eS5wcmVmaXhlZD1UO3kuRXZlbnRFbWl0dGVyPXk7dHlwZW9mIGZlIT1cInVuZGVmaW5lZFwiJiYoZmUuZXhwb3J0cz15KX0pO2Z1bmN0aW9uIEF0KHQpe2xldCBlPXtleHBvcnRzOnt9fTtyZXR1cm4gdChlLGUuZXhwb3J0cyksZS5leHBvcnRzfXZhciBMdD1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8OTAwNzE5OTI1NDc0MDk5MTt2YXIgbWU9e1NFTVZFUl9TUEVDX1ZFUlNJT046XCIyLjAuMFwiLE1BWF9MRU5HVEg6MjU2LE1BWF9TQUZFX0lOVEVHRVI6THQsTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSDoxNn0sU3Q9dHlwZW9mIHByb2Nlc3M9PVwib2JqZWN0XCImJnByb2Nlc3MuZW52JiZwcm9jZXNzLmVudi5OT0RFX0RFQlVHJiYvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKT8oLi4udCk9PmNvbnNvbGUuZXJyb3IoXCJTRU1WRVJcIiwuLi50KTooKT0+e30sZD1TdCxLPUF0KGZ1bmN0aW9uKHQsZSl7bGV0e01BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEg6bn09bWUscj0oZT10LmV4cG9ydHM9e30pLnJlPVtdLHM9ZS5zcmM9W10sbz1lLnQ9e30sYT0wLGk9KGMscCxsKT0+e2xldCB1PWErKztkKHUscCksb1tjXT11LHNbdV09cCxyW3VdPW5ldyBSZWdFeHAocCxsP1wiZ1wiOnZvaWQgMCl9O2koXCJOVU1FUklDSURFTlRJRklFUlwiLFwiMHxbMS05XVxcXFxkKlwiKSxpKFwiTlVNRVJJQ0lERU5USUZJRVJMT09TRVwiLFwiWzAtOV0rXCIpLGkoXCJOT05OVU1FUklDSURFTlRJRklFUlwiLFwiXFxcXGQqW2EtekEtWi1dW2EtekEtWjAtOS1dKlwiKSxpKFwiTUFJTlZFUlNJT05cIixgKCR7c1tvLk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC4oJHtzW28uTlVNRVJJQ0lERU5USUZJRVJdfSlcXFxcLigke3Nbby5OVU1FUklDSURFTlRJRklFUl19KWApLGkoXCJNQUlOVkVSU0lPTkxPT1NFXCIsYCgke3Nbby5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pXFxcXC4oJHtzW28uTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuKCR7c1tvLk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlgKSxpKFwiUFJFUkVMRUFTRUlERU5USUZJRVJcIixgKD86JHtzW28uTlVNRVJJQ0lERU5USUZJRVJdfXwke3Nbby5OT05OVU1FUklDSURFTlRJRklFUl19KWApLGkoXCJQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXCIsYCg/OiR7c1tvLk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXwke3Nbby5OT05OVU1FUklDSURFTlRJRklFUl19KWApLGkoXCJQUkVSRUxFQVNFXCIsYCg/Oi0oJHtzW28uUFJFUkVMRUFTRUlERU5USUZJRVJdfSg/OlxcXFwuJHtzW28uUFJFUkVMRUFTRUlERU5USUZJRVJdfSkqKSlgKSxpKFwiUFJFUkVMRUFTRUxPT1NFXCIsYCg/Oi0/KCR7c1tvLlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSg/OlxcXFwuJHtzW28uUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV19KSopKWApLGkoXCJCVUlMRElERU5USUZJRVJcIixcIlswLTlBLVphLXotXStcIiksaShcIkJVSUxEXCIsYCg/OlxcXFwrKCR7c1tvLkJVSUxESURFTlRJRklFUl19KD86XFxcXC4ke3Nbby5CVUlMRElERU5USUZJRVJdfSkqKSlgKSxpKFwiRlVMTFBMQUlOXCIsYHY/JHtzW28uTUFJTlZFUlNJT05dfSR7c1tvLlBSRVJFTEVBU0VdfT8ke3Nbby5CVUlMRF19P2ApLGkoXCJGVUxMXCIsYF4ke3Nbby5GVUxMUExBSU5dfSRgKSxpKFwiTE9PU0VQTEFJTlwiLGBbdj1cXFxcc10qJHtzW28uTUFJTlZFUlNJT05MT09TRV19JHtzW28uUFJFUkVMRUFTRUxPT1NFXX0/JHtzW28uQlVJTERdfT9gKSxpKFwiTE9PU0VcIixgXiR7c1tvLkxPT1NFUExBSU5dfSRgKSxpKFwiR1RMVFwiLFwiKCg/Ojx8Pik/PT8pXCIpLGkoXCJYUkFOR0VJREVOVElGSUVSTE9PU0VcIixgJHtzW28uTlVNRVJJQ0lERU5USUZJRVJMT09TRV19fHh8WHxcXFxcKmApLGkoXCJYUkFOR0VJREVOVElGSUVSXCIsYCR7c1tvLk5VTUVSSUNJREVOVElGSUVSXX18eHxYfFxcXFwqYCksaShcIlhSQU5HRVBMQUlOXCIsYFt2PVxcXFxzXSooJHtzW28uWFJBTkdFSURFTlRJRklFUl19KSg/OlxcXFwuKCR7c1tvLlhSQU5HRUlERU5USUZJRVJdfSkoPzpcXFxcLigke3Nbby5YUkFOR0VJREVOVElGSUVSXX0pKD86JHtzW28uUFJFUkVMRUFTRV19KT8ke3Nbby5CVUlMRF19Pyk/KT9gKSxpKFwiWFJBTkdFUExBSU5MT09TRVwiLGBbdj1cXFxcc10qKCR7c1tvLlhSQU5HRUlERU5USUZJRVJMT09TRV19KSg/OlxcXFwuKCR7c1tvLlhSQU5HRUlERU5USUZJRVJMT09TRV19KSg/OlxcXFwuKCR7c1tvLlhSQU5HRUlERU5USUZJRVJMT09TRV19KSg/OiR7c1tvLlBSRVJFTEVBU0VMT09TRV19KT8ke3Nbby5CVUlMRF19Pyk/KT9gKSxpKFwiWFJBTkdFXCIsYF4ke3Nbby5HVExUXX1cXFxccyoke3Nbby5YUkFOR0VQTEFJTl19JGApLGkoXCJYUkFOR0VMT09TRVwiLGBeJHtzW28uR1RMVF19XFxcXHMqJHtzW28uWFJBTkdFUExBSU5MT09TRV19JGApLGkoXCJDT0VSQ0VcIixgKF58W15cXFxcZF0pKFxcXFxkezEsJHtufX0pKD86XFxcXC4oXFxcXGR7MSwke259fSkpPyg/OlxcXFwuKFxcXFxkezEsJHtufX0pKT8oPzokfFteXFxcXGRdKWApLGkoXCJDT0VSQ0VSVExcIixzW28uQ09FUkNFXSwhMCksaShcIkxPTkVUSUxERVwiLFwiKD86fj4/KVwiKSxpKFwiVElMREVUUklNXCIsYChcXFxccyopJHtzW28uTE9ORVRJTERFXX1cXFxccytgLCEwKSxlLnRpbGRlVHJpbVJlcGxhY2U9XCIkMX5cIixpKFwiVElMREVcIixgXiR7c1tvLkxPTkVUSUxERV19JHtzW28uWFJBTkdFUExBSU5dfSRgKSxpKFwiVElMREVMT09TRVwiLGBeJHtzW28uTE9ORVRJTERFXX0ke3Nbby5YUkFOR0VQTEFJTkxPT1NFXX0kYCksaShcIkxPTkVDQVJFVFwiLFwiKD86XFxcXF4pXCIpLGkoXCJDQVJFVFRSSU1cIixgKFxcXFxzKikke3Nbby5MT05FQ0FSRVRdfVxcXFxzK2AsITApLGUuY2FyZXRUcmltUmVwbGFjZT1cIiQxXlwiLGkoXCJDQVJFVFwiLGBeJHtzW28uTE9ORUNBUkVUXX0ke3Nbby5YUkFOR0VQTEFJTl19JGApLGkoXCJDQVJFVExPT1NFXCIsYF4ke3Nbby5MT05FQ0FSRVRdfSR7c1tvLlhSQU5HRVBMQUlOTE9PU0VdfSRgKSxpKFwiQ09NUEFSQVRPUkxPT1NFXCIsYF4ke3Nbby5HVExUXX1cXFxccyooJHtzW28uTE9PU0VQTEFJTl19KSR8XiRgKSxpKFwiQ09NUEFSQVRPUlwiLGBeJHtzW28uR1RMVF19XFxcXHMqKCR7c1tvLkZVTExQTEFJTl19KSR8XiRgKSxpKFwiQ09NUEFSQVRPUlRSSU1cIixgKFxcXFxzKikke3Nbby5HVExUXX1cXFxccyooJHtzW28uTE9PU0VQTEFJTl19fCR7c1tvLlhSQU5HRVBMQUlOXX0pYCwhMCksZS5jb21wYXJhdG9yVHJpbVJlcGxhY2U9XCIkMSQyJDNcIixpKFwiSFlQSEVOUkFOR0VcIixgXlxcXFxzKigke3Nbby5YUkFOR0VQTEFJTl19KVxcXFxzKy1cXFxccysoJHtzW28uWFJBTkdFUExBSU5dfSlcXFxccyokYCksaShcIkhZUEhFTlJBTkdFTE9PU0VcIixgXlxcXFxzKigke3Nbby5YUkFOR0VQTEFJTkxPT1NFXX0pXFxcXHMrLVxcXFxzKygke3Nbby5YUkFOR0VQTEFJTkxPT1NFXX0pXFxcXHMqJGApLGkoXCJTVEFSXCIsXCIoPHw+KT89P1xcXFxzKlxcXFwqXCIpLGkoXCJHVEUwXCIsXCJeXFxcXHMqPj1cXFxccyowLjAuMFxcXFxzKiRcIiksaShcIkdURTBQUkVcIixcIl5cXFxccyo+PVxcXFxzKjAuMC4wLTBcXFxccyokXCIpfSksQWU9L15bMC05XSskLyxMZT0odCxlKT0+e2xldCBuPUFlLnRlc3QodCkscj1BZS50ZXN0KGUpO3JldHVybiBuJiZyJiYodD0rdCxlPStlKSx0PT09ZT8wOm4mJiFyPy0xOnImJiFuPzE6dDxlPy0xOjF9LE90PSh0LGUpPT5MZShlLHQpLEN0PXtjb21wYXJlSWRlbnRpZmllcnM6TGUscmNvbXBhcmVJZGVudGlmaWVyczpPdH0se01BWF9MRU5HVEg6U2UsTUFYX1NBRkVfSU5URUdFUjpZfT1tZSx7cmU6T2UsdDpDZX09Syx7Y29tcGFyZUlkZW50aWZpZXJzOkZ9PUN0LGg9Y2xhc3N7Y29uc3RydWN0b3IoZSxuKXtpZihuJiZ0eXBlb2Ygbj09XCJvYmplY3RcInx8KG49e2xvb3NlOiEhbixpbmNsdWRlUHJlcmVsZWFzZTohMX0pLGUgaW5zdGFuY2VvZiBoKXtpZihlLmxvb3NlPT09ISFuLmxvb3NlJiZlLmluY2x1ZGVQcmVyZWxlYXNlPT09ISFuLmluY2x1ZGVQcmVyZWxlYXNlKXJldHVybiBlO2U9ZS52ZXJzaW9ufWVsc2UgaWYodHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke2V9YCk7aWYoZS5sZW5ndGg+U2UpdGhyb3cgbmV3IFR5cGVFcnJvcihgdmVyc2lvbiBpcyBsb25nZXIgdGhhbiAke1NlfSBjaGFyYWN0ZXJzYCk7ZChcIlNlbVZlclwiLGUsbiksdGhpcy5vcHRpb25zPW4sdGhpcy5sb29zZT0hIW4ubG9vc2UsdGhpcy5pbmNsdWRlUHJlcmVsZWFzZT0hIW4uaW5jbHVkZVByZXJlbGVhc2U7bGV0IHI9ZS50cmltKCkubWF0Y2gobi5sb29zZT9PZVtDZS5MT09TRV06T2VbQ2UuRlVMTF0pO2lmKCFyKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHtlfWApO2lmKHRoaXMucmF3PWUsdGhpcy5tYWpvcj0rclsxXSx0aGlzLm1pbm9yPStyWzJdLHRoaXMucGF0Y2g9K3JbM10sdGhpcy5tYWpvcj5ZfHx0aGlzLm1ham9yPDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbWFqb3IgdmVyc2lvblwiKTtpZih0aGlzLm1pbm9yPll8fHRoaXMubWlub3I8MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBtaW5vciB2ZXJzaW9uXCIpO2lmKHRoaXMucGF0Y2g+WXx8dGhpcy5wYXRjaDwwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHBhdGNoIHZlcnNpb25cIik7cls0XT90aGlzLnByZXJlbGVhc2U9cls0XS5zcGxpdChcIi5cIikubWFwKHM9PntpZigvXlswLTldKyQvLnRlc3Qocykpe2xldCBvPStzO2lmKG8+PTAmJm88WSlyZXR1cm4gb31yZXR1cm4gc30pOnRoaXMucHJlcmVsZWFzZT1bXSx0aGlzLmJ1aWxkPXJbNV0/cls1XS5zcGxpdChcIi5cIik6W10sdGhpcy5mb3JtYXQoKX1mb3JtYXQoKXtyZXR1cm4gdGhpcy52ZXJzaW9uPWAke3RoaXMubWFqb3J9LiR7dGhpcy5taW5vcn0uJHt0aGlzLnBhdGNofWAsdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCYmKHRoaXMudmVyc2lvbis9YC0ke3RoaXMucHJlcmVsZWFzZS5qb2luKFwiLlwiKX1gKSx0aGlzLnZlcnNpb259dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy52ZXJzaW9ufWNvbXBhcmUoZSl7aWYoZChcIlNlbVZlci5jb21wYXJlXCIsdGhpcy52ZXJzaW9uLHRoaXMub3B0aW9ucyxlKSwhKGUgaW5zdGFuY2VvZiBoKSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCImJmU9PT10aGlzLnZlcnNpb24pcmV0dXJuIDA7ZT1uZXcgaChlLHRoaXMub3B0aW9ucyl9cmV0dXJuIGUudmVyc2lvbj09PXRoaXMudmVyc2lvbj8wOnRoaXMuY29tcGFyZU1haW4oZSl8fHRoaXMuY29tcGFyZVByZShlKX1jb21wYXJlTWFpbihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGh8fChlPW5ldyBoKGUsdGhpcy5vcHRpb25zKSksRih0aGlzLm1ham9yLGUubWFqb3IpfHxGKHRoaXMubWlub3IsZS5taW5vcil8fEYodGhpcy5wYXRjaCxlLnBhdGNoKX1jb21wYXJlUHJlKGUpe2lmKGUgaW5zdGFuY2VvZiBofHwoZT1uZXcgaChlLHRoaXMub3B0aW9ucykpLHRoaXMucHJlcmVsZWFzZS5sZW5ndGgmJiFlLnByZXJlbGVhc2UubGVuZ3RoKXJldHVybi0xO2lmKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoJiZlLnByZXJlbGVhc2UubGVuZ3RoKXJldHVybiAxO2lmKCF0aGlzLnByZXJlbGVhc2UubGVuZ3RoJiYhZS5wcmVyZWxlYXNlLmxlbmd0aClyZXR1cm4gMDtsZXQgbj0wO2Rve2xldCByPXRoaXMucHJlcmVsZWFzZVtuXSxzPWUucHJlcmVsZWFzZVtuXTtpZihkKFwicHJlcmVsZWFzZSBjb21wYXJlXCIsbixyLHMpLHI9PT12b2lkIDAmJnM9PT12b2lkIDApcmV0dXJuIDA7aWYocz09PXZvaWQgMClyZXR1cm4gMTtpZihyPT09dm9pZCAwKXJldHVybi0xO2lmKHIhPT1zKXJldHVybiBGKHIscyl9d2hpbGUoKytuKX1jb21wYXJlQnVpbGQoZSl7ZSBpbnN0YW5jZW9mIGh8fChlPW5ldyBoKGUsdGhpcy5vcHRpb25zKSk7bGV0IG49MDtkb3tsZXQgcj10aGlzLmJ1aWxkW25dLHM9ZS5idWlsZFtuXTtpZihkKFwicHJlcmVsZWFzZSBjb21wYXJlXCIsbixyLHMpLHI9PT12b2lkIDAmJnM9PT12b2lkIDApcmV0dXJuIDA7aWYocz09PXZvaWQgMClyZXR1cm4gMTtpZihyPT09dm9pZCAwKXJldHVybi0xO2lmKHIhPT1zKXJldHVybiBGKHIscyl9d2hpbGUoKytuKX1pbmMoZSxuKXtzd2l0Y2goZSl7Y2FzZVwicHJlbWFqb3JcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPTAsdGhpcy5wYXRjaD0wLHRoaXMubWlub3I9MCx0aGlzLm1ham9yKyssdGhpcy5pbmMoXCJwcmVcIixuKTticmVhaztjYXNlXCJwcmVtaW5vclwiOnRoaXMucHJlcmVsZWFzZS5sZW5ndGg9MCx0aGlzLnBhdGNoPTAsdGhpcy5taW5vcisrLHRoaXMuaW5jKFwicHJlXCIsbik7YnJlYWs7Y2FzZVwicHJlcGF0Y2hcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPTAsdGhpcy5pbmMoXCJwYXRjaFwiLG4pLHRoaXMuaW5jKFwicHJlXCIsbik7YnJlYWs7Y2FzZVwicHJlcmVsZWFzZVwiOnRoaXMucHJlcmVsZWFzZS5sZW5ndGg9PT0wJiZ0aGlzLmluYyhcInBhdGNoXCIsbiksdGhpcy5pbmMoXCJwcmVcIixuKTticmVhaztjYXNlXCJtYWpvclwiOnRoaXMubWlub3I9PT0wJiZ0aGlzLnBhdGNoPT09MCYmdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCE9PTB8fHRoaXMubWFqb3IrKyx0aGlzLm1pbm9yPTAsdGhpcy5wYXRjaD0wLHRoaXMucHJlcmVsZWFzZT1bXTticmVhaztjYXNlXCJtaW5vclwiOnRoaXMucGF0Y2g9PT0wJiZ0aGlzLnByZXJlbGVhc2UubGVuZ3RoIT09MHx8dGhpcy5taW5vcisrLHRoaXMucGF0Y2g9MCx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwicGF0Y2hcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCYmdGhpcy5wYXRjaCsrLHRoaXMucHJlcmVsZWFzZT1bXTticmVhaztjYXNlXCJwcmVcIjppZih0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCl0aGlzLnByZXJlbGVhc2U9WzBdO2Vsc2V7bGV0IHI9dGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtmb3IoOy0tcj49MDspdHlwZW9mIHRoaXMucHJlcmVsZWFzZVtyXT09XCJudW1iZXJcIiYmKHRoaXMucHJlcmVsZWFzZVtyXSsrLHI9LTIpO3I9PT0tMSYmdGhpcy5wcmVyZWxlYXNlLnB1c2goMCl9biYmKHRoaXMucHJlcmVsZWFzZVswXT09PW4/aXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSYmKHRoaXMucHJlcmVsZWFzZT1bbiwwXSk6dGhpcy5wcmVyZWxlYXNlPVtuLDBdKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICR7ZX1gKX1yZXR1cm4gdGhpcy5mb3JtYXQoKSx0aGlzLnJhdz10aGlzLnZlcnNpb24sdGhpc319LF90PSh0LGUsbik9Pm5ldyBoKHQsbikuY29tcGFyZShuZXcgaChlLG4pKSxrPV90LER0PSh0LGUsbik9PmsodCxlLG4pPT09MCxrdD1EdCxKdD0odCxlLG4pPT5rKHQsZSxuKSE9PTAscXQ9SnQsR3Q9KHQsZSxuKT0+ayh0LGUsbik+MCxVdD1HdCxLdD0odCxlLG4pPT5rKHQsZSxuKT49MCxGdD1LdCxqdD0odCxlLG4pPT5rKHQsZSxuKTwwLFd0PWp0LFh0PSh0LGUsbik9PmsodCxlLG4pPD0wLEJ0PVh0LEh0PSh0LGUsbixyKT0+e3N3aXRjaChlKXtjYXNlXCI9PT1cIjpyZXR1cm4gdHlwZW9mIHQ9PVwib2JqZWN0XCImJih0PXQudmVyc2lvbiksdHlwZW9mIG49PVwib2JqZWN0XCImJihuPW4udmVyc2lvbiksdD09PW47Y2FzZVwiIT09XCI6cmV0dXJuIHR5cGVvZiB0PT1cIm9iamVjdFwiJiYodD10LnZlcnNpb24pLHR5cGVvZiBuPT1cIm9iamVjdFwiJiYobj1uLnZlcnNpb24pLHQhPT1uO2Nhc2VcIlwiOmNhc2VcIj1cIjpjYXNlXCI9PVwiOnJldHVybiBrdCh0LG4scik7Y2FzZVwiIT1cIjpyZXR1cm4gcXQodCxuLHIpO2Nhc2VcIj5cIjpyZXR1cm4gVXQodCxuLHIpO2Nhc2VcIj49XCI6cmV0dXJuIEZ0KHQsbixyKTtjYXNlXCI8XCI6cmV0dXJuIFd0KHQsbixyKTtjYXNlXCI8PVwiOnJldHVybiBCdCh0LG4scik7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIG9wZXJhdG9yOiAke2V9YCl9fSxFZT1IdCxqPVN5bWJvbChcIlNlbVZlciBBTllcIiksTz1jbGFzc3tzdGF0aWMgZ2V0IEFOWSgpe3JldHVybiBqfWNvbnN0cnVjdG9yKGUsbil7aWYobiYmdHlwZW9mIG49PVwib2JqZWN0XCJ8fChuPXtsb29zZTohIW4saW5jbHVkZVByZXJlbGVhc2U6ITF9KSxlIGluc3RhbmNlb2YgTyl7aWYoZS5sb29zZT09PSEhbi5sb29zZSlyZXR1cm4gZTtlPWUudmFsdWV9ZChcImNvbXBhcmF0b3JcIixlLG4pLHRoaXMub3B0aW9ucz1uLHRoaXMubG9vc2U9ISFuLmxvb3NlLHRoaXMucGFyc2UoZSksdGhpcy5zZW12ZXI9PT1qP3RoaXMudmFsdWU9XCJcIjp0aGlzLnZhbHVlPXRoaXMub3BlcmF0b3IrdGhpcy5zZW12ZXIudmVyc2lvbixkKFwiY29tcFwiLHRoaXMpfXBhcnNlKGUpe2xldCBuPXRoaXMub3B0aW9ucy5sb29zZT9fZVtEZS5DT01QQVJBVE9STE9PU0VdOl9lW0RlLkNPTVBBUkFUT1JdLHI9ZS5tYXRjaChuKTtpZighcil0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGNvbXBhcmF0b3I6ICR7ZX1gKTt0aGlzLm9wZXJhdG9yPXJbMV0hPT12b2lkIDA/clsxXTpcIlwiLHRoaXMub3BlcmF0b3I9PT1cIj1cIiYmKHRoaXMub3BlcmF0b3I9XCJcIiksclsyXT90aGlzLnNlbXZlcj1uZXcgaChyWzJdLHRoaXMub3B0aW9ucy5sb29zZSk6dGhpcy5zZW12ZXI9an10b1N0cmluZygpe3JldHVybiB0aGlzLnZhbHVlfXRlc3QoZSl7aWYoZChcIkNvbXBhcmF0b3IudGVzdFwiLGUsdGhpcy5vcHRpb25zLmxvb3NlKSx0aGlzLnNlbXZlcj09PWp8fGU9PT1qKXJldHVybiEwO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXRyeXtlPW5ldyBoKGUsdGhpcy5vcHRpb25zKX1jYXRjaChuKXtyZXR1cm4hMX1yZXR1cm4gRWUoZSx0aGlzLm9wZXJhdG9yLHRoaXMuc2VtdmVyLHRoaXMub3B0aW9ucyl9aW50ZXJzZWN0cyhlLG4pe2lmKCEoZSBpbnN0YW5jZW9mIE8pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWRcIik7aWYobiYmdHlwZW9mIG49PVwib2JqZWN0XCJ8fChuPXtsb29zZTohIW4saW5jbHVkZVByZXJlbGVhc2U6ITF9KSx0aGlzLm9wZXJhdG9yPT09XCJcIilyZXR1cm4gdGhpcy52YWx1ZT09PVwiXCJ8fG5ldyBOKGUudmFsdWUsbikudGVzdCh0aGlzLnZhbHVlKTtpZihlLm9wZXJhdG9yPT09XCJcIilyZXR1cm4gZS52YWx1ZT09PVwiXCJ8fG5ldyBOKHRoaXMudmFsdWUsbikudGVzdChlLnNlbXZlcik7bGV0IHI9ISh0aGlzLm9wZXJhdG9yIT09XCI+PVwiJiZ0aGlzLm9wZXJhdG9yIT09XCI+XCJ8fGUub3BlcmF0b3IhPT1cIj49XCImJmUub3BlcmF0b3IhPT1cIj5cIikscz0hKHRoaXMub3BlcmF0b3IhPT1cIjw9XCImJnRoaXMub3BlcmF0b3IhPT1cIjxcInx8ZS5vcGVyYXRvciE9PVwiPD1cIiYmZS5vcGVyYXRvciE9PVwiPFwiKSxvPXRoaXMuc2VtdmVyLnZlcnNpb249PT1lLnNlbXZlci52ZXJzaW9uLGE9ISh0aGlzLm9wZXJhdG9yIT09XCI+PVwiJiZ0aGlzLm9wZXJhdG9yIT09XCI8PVwifHxlLm9wZXJhdG9yIT09XCI+PVwiJiZlLm9wZXJhdG9yIT09XCI8PVwiKSxpPUVlKHRoaXMuc2VtdmVyLFwiPFwiLGUuc2VtdmVyLG4pJiYodGhpcy5vcGVyYXRvcj09PVwiPj1cInx8dGhpcy5vcGVyYXRvcj09PVwiPlwiKSYmKGUub3BlcmF0b3I9PT1cIjw9XCJ8fGUub3BlcmF0b3I9PT1cIjxcIiksYz1FZSh0aGlzLnNlbXZlcixcIj5cIixlLnNlbXZlcixuKSYmKHRoaXMub3BlcmF0b3I9PT1cIjw9XCJ8fHRoaXMub3BlcmF0b3I9PT1cIjxcIikmJihlLm9wZXJhdG9yPT09XCI+PVwifHxlLm9wZXJhdG9yPT09XCI+XCIpO3JldHVybiByfHxzfHxvJiZhfHxpfHxjfX0se3JlOl9lLHQ6RGV9PUssTj1jbGFzc3tjb25zdHJ1Y3RvcihlLG4pe2lmKG4mJnR5cGVvZiBuPT1cIm9iamVjdFwifHwobj17bG9vc2U6ISFuLGluY2x1ZGVQcmVyZWxlYXNlOiExfSksZSBpbnN0YW5jZW9mIE4pcmV0dXJuIGUubG9vc2U9PT0hIW4ubG9vc2UmJmUuaW5jbHVkZVByZXJlbGVhc2U9PT0hIW4uaW5jbHVkZVByZXJlbGVhc2U/ZTpuZXcgTihlLnJhdyxuKTtpZihlIGluc3RhbmNlb2YgTylyZXR1cm4gdGhpcy5yYXc9ZS52YWx1ZSx0aGlzLnNldD1bW2VdXSx0aGlzLmZvcm1hdCgpLHRoaXM7aWYodGhpcy5vcHRpb25zPW4sdGhpcy5sb29zZT0hIW4ubG9vc2UsdGhpcy5pbmNsdWRlUHJlcmVsZWFzZT0hIW4uaW5jbHVkZVByZXJlbGVhc2UsdGhpcy5yYXc9ZSx0aGlzLnNldD1lLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChyPT50aGlzLnBhcnNlUmFuZ2Uoci50cmltKCkpKS5maWx0ZXIocj0+ci5sZW5ndGgpLCF0aGlzLnNldC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICR7ZX1gKTt0aGlzLmZvcm1hdCgpfWZvcm1hdCgpe3JldHVybiB0aGlzLnJhbmdlPXRoaXMuc2V0Lm1hcChlPT5lLmpvaW4oXCIgXCIpLnRyaW0oKSkuam9pbihcInx8XCIpLnRyaW0oKSx0aGlzLnJhbmdlfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMucmFuZ2V9cGFyc2VSYW5nZShlKXtsZXR7bG9vc2U6bn09dGhpcy5vcHRpb25zO2U9ZS50cmltKCk7bGV0IHI9bj9nW2YuSFlQSEVOUkFOR0VMT09TRV06Z1tmLkhZUEhFTlJBTkdFXTtlPWUucmVwbGFjZShyLGNuKHRoaXMub3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkpLGQoXCJoeXBoZW4gcmVwbGFjZVwiLGUpLGU9ZS5yZXBsYWNlKGdbZi5DT01QQVJBVE9SVFJJTV0sVnQpLGQoXCJjb21wYXJhdG9yIHRyaW1cIixlLGdbZi5DT01QQVJBVE9SVFJJTV0pLGU9KGU9KGU9ZS5yZXBsYWNlKGdbZi5USUxERVRSSU1dLHp0KSkucmVwbGFjZShnW2YuQ0FSRVRUUklNXSxZdCkpLnNwbGl0KC9cXHMrLykuam9pbihcIiBcIik7bGV0IHM9bj9nW2YuQ09NUEFSQVRPUkxPT1NFXTpnW2YuQ09NUEFSQVRPUl07cmV0dXJuIGUuc3BsaXQoXCIgXCIpLm1hcChvPT5adChvLHRoaXMub3B0aW9ucykpLmpvaW4oXCIgXCIpLnNwbGl0KC9cXHMrLykubWFwKG89PmFuKG8sdGhpcy5vcHRpb25zKSkuZmlsdGVyKHRoaXMub3B0aW9ucy5sb29zZT9vPT4hIW8ubWF0Y2gocyk6KCk9PiEwKS5tYXAobz0+bmV3IE8obyx0aGlzLm9wdGlvbnMpKX1pbnRlcnNlY3RzKGUsbil7aWYoIShlIGluc3RhbmNlb2YgTikpdGhyb3cgbmV3IFR5cGVFcnJvcihcImEgUmFuZ2UgaXMgcmVxdWlyZWRcIik7cmV0dXJuIHRoaXMuc2V0LnNvbWUocj0+a2UocixuKSYmZS5zZXQuc29tZShzPT5rZShzLG4pJiZyLmV2ZXJ5KG89PnMuZXZlcnkoYT0+by5pbnRlcnNlY3RzKGEsbikpKSkpfXRlc3QoZSl7aWYoIWUpcmV0dXJuITE7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpdHJ5e2U9bmV3IGgoZSx0aGlzLm9wdGlvbnMpfWNhdGNoKG4pe3JldHVybiExfWZvcihsZXQgbj0wO248dGhpcy5zZXQubGVuZ3RoO24rKylpZihsbih0aGlzLnNldFtuXSxlLHRoaXMub3B0aW9ucykpcmV0dXJuITA7cmV0dXJuITF9fSx7cmU6Zyx0OmYsY29tcGFyYXRvclRyaW1SZXBsYWNlOlZ0LHRpbGRlVHJpbVJlcGxhY2U6enQsY2FyZXRUcmltUmVwbGFjZTpZdH09SyxrZT0odCxlKT0+e2xldCBuPSEwLHI9dC5zbGljZSgpLHM9ci5wb3AoKTtmb3IoO24mJnIubGVuZ3RoOyluPXIuZXZlcnkobz0+cy5pbnRlcnNlY3RzKG8sZSkpLHM9ci5wb3AoKTtyZXR1cm4gbn0sWnQ9KHQsZSk9PihkKFwiY29tcFwiLHQsZSksdD10bih0LGUpLGQoXCJjYXJldFwiLHQpLHQ9UXQodCxlKSxkKFwidGlsZGVzXCIsdCksdD1ybih0LGUpLGQoXCJ4cmFuZ2VcIix0KSx0PW9uKHQsZSksZChcInN0YXJzXCIsdCksdCksUj10PT4hdHx8dC50b0xvd2VyQ2FzZSgpPT09XCJ4XCJ8fHQ9PT1cIipcIixRdD0odCxlKT0+dC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAobj0+ZW4obixlKSkuam9pbihcIiBcIiksZW49KHQsZSk9PntsZXQgbj1lLmxvb3NlP2dbZi5USUxERUxPT1NFXTpnW2YuVElMREVdO3JldHVybiB0LnJlcGxhY2UobiwocixzLG8sYSxpKT0+e2xldCBjO3JldHVybiBkKFwidGlsZGVcIix0LHIscyxvLGEsaSksUihzKT9jPVwiXCI6UihvKT9jPWA+PSR7c30uMC4wIDwkeytzKzF9LjAuMC0wYDpSKGEpP2M9YD49JHtzfS4ke299LjAgPCR7c30uJHsrbysxfS4wLTBgOmk/KGQoXCJyZXBsYWNlVGlsZGUgcHJcIixpKSxjPWA+PSR7c30uJHtvfS4ke2F9LSR7aX0gPCR7c30uJHsrbysxfS4wLTBgKTpjPWA+PSR7c30uJHtvfS4ke2F9IDwke3N9LiR7K28rMX0uMC0wYCxkKFwidGlsZGUgcmV0dXJuXCIsYyksY30pfSx0bj0odCxlKT0+dC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAobj0+bm4obixlKSkuam9pbihcIiBcIiksbm49KHQsZSk9PntkKFwiY2FyZXRcIix0LGUpO2xldCBuPWUubG9vc2U/Z1tmLkNBUkVUTE9PU0VdOmdbZi5DQVJFVF0scj1lLmluY2x1ZGVQcmVyZWxlYXNlP1wiLTBcIjpcIlwiO3JldHVybiB0LnJlcGxhY2UobiwocyxvLGEsaSxjKT0+e2xldCBwO3JldHVybiBkKFwiY2FyZXRcIix0LHMsbyxhLGksYyksUihvKT9wPVwiXCI6UihhKT9wPWA+PSR7b30uMC4wJHtyfSA8JHsrbysxfS4wLjAtMGA6UihpKT9wPW89PT1cIjBcIj9gPj0ke299LiR7YX0uMCR7cn0gPCR7b30uJHsrYSsxfS4wLTBgOmA+PSR7b30uJHthfS4wJHtyfSA8JHsrbysxfS4wLjAtMGA6Yz8oZChcInJlcGxhY2VDYXJldCBwclwiLGMpLHA9bz09PVwiMFwiP2E9PT1cIjBcIj9gPj0ke299LiR7YX0uJHtpfS0ke2N9IDwke299LiR7YX0uJHsraSsxfS0wYDpgPj0ke299LiR7YX0uJHtpfS0ke2N9IDwke299LiR7K2ErMX0uMC0wYDpgPj0ke299LiR7YX0uJHtpfS0ke2N9IDwkeytvKzF9LjAuMC0wYCk6KGQoXCJubyBwclwiKSxwPW89PT1cIjBcIj9hPT09XCIwXCI/YD49JHtvfS4ke2F9LiR7aX0ke3J9IDwke299LiR7YX0uJHsraSsxfS0wYDpgPj0ke299LiR7YX0uJHtpfSR7cn0gPCR7b30uJHsrYSsxfS4wLTBgOmA+PSR7b30uJHthfS4ke2l9IDwkeytvKzF9LjAuMC0wYCksZChcImNhcmV0IHJldHVyblwiLHApLHB9KX0scm49KHQsZSk9PihkKFwicmVwbGFjZVhSYW5nZXNcIix0LGUpLHQuc3BsaXQoL1xccysvKS5tYXAobj0+c24obixlKSkuam9pbihcIiBcIikpLHNuPSh0LGUpPT57dD10LnRyaW0oKTtsZXQgbj1lLmxvb3NlP2dbZi5YUkFOR0VMT09TRV06Z1tmLlhSQU5HRV07cmV0dXJuIHQucmVwbGFjZShuLChyLHMsbyxhLGksYyk9PntkKFwieFJhbmdlXCIsdCxyLHMsbyxhLGksYyk7bGV0IHA9UihvKSxsPXB8fFIoYSksdT1sfHxSKGkpLHY9dTtyZXR1cm4gcz09PVwiPVwiJiZ2JiYocz1cIlwiKSxjPWUuaW5jbHVkZVByZXJlbGVhc2U/XCItMFwiOlwiXCIscD9yPXM9PT1cIj5cInx8cz09PVwiPFwiP1wiPDAuMC4wLTBcIjpcIipcIjpzJiZ2PyhsJiYoYT0wKSxpPTAscz09PVwiPlwiPyhzPVwiPj1cIixsPyhvPStvKzEsYT0wLGk9MCk6KGE9K2ErMSxpPTApKTpzPT09XCI8PVwiJiYocz1cIjxcIixsP289K28rMTphPSthKzEpLHM9PT1cIjxcIiYmKGM9XCItMFwiKSxyPWAke3Mrb30uJHthfS4ke2l9JHtjfWApOmw/cj1gPj0ke299LjAuMCR7Y30gPCR7K28rMX0uMC4wLTBgOnUmJihyPWA+PSR7b30uJHthfS4wJHtjfSA8JHtvfS4keythKzF9LjAtMGApLGQoXCJ4UmFuZ2UgcmV0dXJuXCIscikscn0pfSxvbj0odCxlKT0+KGQoXCJyZXBsYWNlU3RhcnNcIix0LGUpLHQudHJpbSgpLnJlcGxhY2UoZ1tmLlNUQVJdLFwiXCIpKSxhbj0odCxlKT0+KGQoXCJyZXBsYWNlR1RFMFwiLHQsZSksdC50cmltKCkucmVwbGFjZShnW2UuaW5jbHVkZVByZXJlbGVhc2U/Zi5HVEUwUFJFOmYuR1RFMF0sXCJcIikpLGNuPXQ9PihlLG4scixzLG8sYSxpLGMscCxsLHUsdixNKT0+YCR7bj1SKHIpP1wiXCI6UihzKT9gPj0ke3J9LjAuMCR7dD9cIi0wXCI6XCJcIn1gOlIobyk/YD49JHtyfS4ke3N9LjAke3Q/XCItMFwiOlwiXCJ9YDphP2A+PSR7bn1gOmA+PSR7bn0ke3Q/XCItMFwiOlwiXCJ9YH0gJHtjPVIocCk/XCJcIjpSKGwpP2A8JHsrcCsxfS4wLjAtMGA6Uih1KT9gPCR7cH0uJHsrbCsxfS4wLTBgOnY/YDw9JHtwfS4ke2x9LiR7dX0tJHt2fWA6dD9gPCR7cH0uJHtsfS4keyt1KzF9LTBgOmA8PSR7Y31gfWAudHJpbSgpLGxuPSh0LGUsbik9Pntmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKylpZighdFtyXS50ZXN0KGUpKXJldHVybiExO2lmKGUucHJlcmVsZWFzZS5sZW5ndGgmJiFuLmluY2x1ZGVQcmVyZWxlYXNlKXtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKylpZihkKHRbcl0uc2VtdmVyKSx0W3JdLnNlbXZlciE9PU8uQU5ZJiZ0W3JdLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aD4wKXtsZXQgcz10W3JdLnNlbXZlcjtpZihzLm1ham9yPT09ZS5tYWpvciYmcy5taW5vcj09PWUubWlub3ImJnMucGF0Y2g9PT1lLnBhdGNoKXJldHVybiEwfXJldHVybiExfXJldHVybiEwfSxKZT0odCxlLG4pPT57dHJ5e2U9bmV3IE4oZSxuKX1jYXRjaChyKXtyZXR1cm4hMX1yZXR1cm4gZS50ZXN0KHQpfTt2YXJ7TUFYX0xFTkdUSDpwbn09bWUse3JlOnFlLHQ6R2V9PUssdW49KHQsZSk9PntpZihlJiZ0eXBlb2YgZT09XCJvYmplY3RcInx8KGU9e2xvb3NlOiEhZSxpbmNsdWRlUHJlcmVsZWFzZTohMX0pLHQgaW5zdGFuY2VvZiBoKXJldHVybiB0O2lmKHR5cGVvZiB0IT1cInN0cmluZ1wifHx0Lmxlbmd0aD5wbnx8IShlLmxvb3NlP3FlW0dlLkxPT1NFXTpxZVtHZS5GVUxMXSkudGVzdCh0KSlyZXR1cm4gbnVsbDt0cnl7cmV0dXJuIG5ldyBoKHQsZSl9Y2F0Y2gobil7cmV0dXJuIG51bGx9fSxkbj11bix7cmU6Wix0OlF9PUssVWU9KHQsZSk9PntpZih0IGluc3RhbmNlb2YgaClyZXR1cm4gdDtpZih0eXBlb2YgdD09XCJudW1iZXJcIiYmKHQ9U3RyaW5nKHQpKSx0eXBlb2YgdCE9XCJzdHJpbmdcIilyZXR1cm4gbnVsbDtsZXQgbj1udWxsO2lmKChlPWV8fHt9KS5ydGwpe2xldCByO2Zvcig7KHI9WltRLkNPRVJDRVJUTF0uZXhlYyh0KSkmJighbnx8bi5pbmRleCtuWzBdLmxlbmd0aCE9PXQubGVuZ3RoKTspbiYmci5pbmRleCtyWzBdLmxlbmd0aD09PW4uaW5kZXgrblswXS5sZW5ndGh8fChuPXIpLFpbUS5DT0VSQ0VSVExdLmxhc3RJbmRleD1yLmluZGV4K3JbMV0ubGVuZ3RoK3JbMl0ubGVuZ3RoO1pbUS5DT0VSQ0VSVExdLmxhc3RJbmRleD0tMX1lbHNlIG49dC5tYXRjaChaW1EuQ09FUkNFXSk7cmV0dXJuIG49PT1udWxsP251bGw6ZG4oYCR7blsyXX0uJHtuWzNdfHxcIjBcIn0uJHtuWzRdfHxcIjBcIn1gLGUpfTtmdW5jdGlvbiBtbih0KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0LnNsaWNlKDEpLDE2KSl9ZnVuY3Rpb24gRW4odCl7cmV0dXJuYCUke2AwMCR7dC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKX1gfWZ1bmN0aW9uIGhuKHQpe3JldHVybiBidG9hKGVuY29kZVVSSUNvbXBvbmVudCh0KS5yZXBsYWNlKC8lWzAtOUEtRl17Mn0vZyxtbikpfWZ1bmN0aW9uIGZuKHQpe3JldHVybiBkZWNvZGVVUklDb21wb25lbnQoQXJyYXkuZnJvbShhdG9iKHQpLEVuKS5qb2luKFwiXCIpKX1mdW5jdGlvbiBlZSh0KXtyZXR1cm4gaG4oSlNPTi5zdHJpbmdpZnkodCkpfWZ1bmN0aW9uIEtlKHQpe3JldHVybiBKU09OLnBhcnNlKGZuKHQpKX1pbXBvcnR7UlBDRXJyb3JDb2RlIGFzIHZuLFNES0Vycm9yQ29kZSBhcyBKLFNES1dhcm5pbmdDb2RlIGFzIHJlfWZyb21cIkBtYWdpYy1zZGsvdHlwZXNcIjtpbXBvcnR7TWFnaWNQYXlsb2FkTWV0aG9kIGFzIGduLFJQQ0Vycm9yQ29kZSBhcyB5bn1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7ZnVuY3Rpb24gYih0KXtyZXR1cm4gdHlwZW9mIHQ9PVwidW5kZWZpbmVkXCJ9ZnVuY3Rpb24gUm4odCl7cmV0dXJuIHQ9PT1udWxsfWZ1bmN0aW9uIHRlKHQpe3JldHVybiBSbih0KXx8Yih0KX1mdW5jdGlvbiB0cih0KXtyZXR1cm4gdGUodCk/ITE6IWIodC5qc29ucnBjKSYmIWIodC5pZCkmJiFiKHQubWV0aG9kKSYmIWIodC5wYXJhbXMpfWZ1bmN0aW9uIEZlKHQpe3JldHVybiB0ZSh0KT8hMTohYih0Lmpzb25ycGMpJiYhYih0LmlkKSYmKCFiKHQucmVzdWx0KXx8IWIodC5lcnJvcikpfWZ1bmN0aW9uIG5yKHQpe3JldHVybiB0ZSh0KT8hMTp0eXBlb2YgdD09XCJzdHJpbmdcIiYmT2JqZWN0LnZhbHVlcyhnbikuaW5jbHVkZXModCl9ZnVuY3Rpb24gamUodCl7cmV0dXJuIHRlKHQpPyExOnR5cGVvZiB0PT1cIm51bWJlclwiJiZPYmplY3QudmFsdWVzKHluKS5pbmNsdWRlcyh0KX1mdW5jdGlvbiBuZSh0KXtpZighdClyZXR1cm4hMDtmb3IobGV0IGUgaW4gdClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpKXJldHVybiExO3JldHVybiEwfXZhciBtPXt9O2Z1bmN0aW9uIFRuKHQsZSl7cmV0dXJuIE9iamVjdC5hc3NpZ24obSxlKSx0fXZhciBXZT17XCJtYWdpYy1zZGtcIjpcIm1hZ2ljLXNka1wiLFwiQG1hZ2ljLXNkay9yZWFjdC1uYXRpdmUtYmFyZVwiOlwibWFnaWMtc2RrLXJuLWJhcmVcIixcIkBtYWdpYy1zZGsvcmVhY3QtbmF0aXZlLWV4cG9cIjpcIm1hZ2ljLXNkay1ybi1leHBvXCJ9O3ZhciAkPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZSxuKXtzdXBlcihgTWFnaWMgU0RLIEVycm9yOiBbJHtlfV0gJHtufWApO3RoaXMuY29kZT1lO3RoaXMucmF3TWVzc2FnZT1uO3RoaXMuX19wcm90b19fPUVycm9yO09iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCQucHJvdG90eXBlKX19LHc9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlKXtzdXBlcigpO3RoaXMuX19wcm90b19fPUVycm9yO2xldCBuPU51bWJlcihlPT1udWxsP3ZvaWQgMDplLmNvZGUpO3RoaXMucmF3TWVzc2FnZT0oZT09bnVsbD92b2lkIDA6ZS5tZXNzYWdlKXx8XCJJbnRlcm5hbCBlcnJvclwiLHRoaXMuY29kZT1qZShuKT9uOnZuLkludGVybmFsRXJyb3IsdGhpcy5tZXNzYWdlPWBNYWdpYyBSUEMgRXJyb3I6IFske3RoaXMuY29kZX1dICR7dGhpcy5yYXdNZXNzYWdlfWAsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdy5wcm90b3R5cGUpfX0sVz1jbGFzc3tjb25zdHJ1Y3RvcihlLG4pe3RoaXMuY29kZT1lO3RoaXMucmF3TWVzc2FnZT1uO3RoaXMubWVzc2FnZT1gTWFnaWMgU0RLIFdhcm5pbmc6IFske2V9XSAke259YH1sb2coKXtjb25zb2xlLndhcm4odGhpcy5tZXNzYWdlKX19LFg9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlLG4scixzKXtzdXBlcihgTWFnaWMgRXh0ZW5zaW9uIEVycm9yICgke2UubmFtZX0pOiBbJHtufV0gJHtyfWApO3RoaXMuY29kZT1uO3RoaXMucmF3TWVzc2FnZT1yO3RoaXMuZGF0YT1zO3RoaXMuX19wcm90b19fPUVycm9yO09iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLFgucHJvdG90eXBlKX19LHNlPWNsYXNze2NvbnN0cnVjdG9yKGUsbixyKXt0aGlzLmNvZGU9bjt0aGlzLnJhd01lc3NhZ2U9cjt0aGlzLm1lc3NhZ2U9YE1hZ2ljIEV4dGVuc2lvbiBXYXJuaW5nICgke2UubmFtZX0pOiBbJHtufV0gJHtyfWB9bG9nKCl7Y29uc29sZS53YXJuKHRoaXMubWVzc2FnZSl9fTtmdW5jdGlvbiBYZSgpe3JldHVybiBuZXcgJChKLk1pc3NpbmdBcGlLZXksXCJQbGVhc2UgcHJvdmlkZSBhbiBBUEkga2V5IHRoYXQgeW91IGFjcXVpcmVkIGZyb20gdGhlIE1hZ2ljIGRldmVsb3BlciBkYXNoYm9hcmQuXCIpfWZ1bmN0aW9uIGxyKCl7cmV0dXJuIG5ldyAkKEouTW9kYWxOb3RSZWFkeSxcIk1vZGFsIGlzIG5vdCByZWFkeS5cIil9ZnVuY3Rpb24gQmUoKXtyZXR1cm4gbmV3ICQoSi5NYWxmb3JtZWRSZXNwb25zZSxcIlJlc3BvbnNlIGZyb20gdGhlIE1hZ2ljIGlmcmFtZSBpcyBtYWxmb3JtZWQuXCIpfWZ1bmN0aW9uIEhlKHQpe3JldHVybiBuZXcgJChKLkV4dGVuc2lvbk5vdEluaXRpYWxpemVkLGBFeHRlbnNpb25zIG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhIE1hZ2ljIFNESyBpbnN0YW5jZSBiZWZvcmUgXFxgRXh0ZW5zaW9uLiR7dH1cXGAgY2FuIGJlIGFjY2Vzc2VkLiBEbyBub3QgaW52b2tlIFxcYEV4dGVuc2lvbi4ke3R9XFxgIGluc2lkZSBhbiBleHRlbnNpb24gY29uc3RydWN0b3IuYCl9ZnVuY3Rpb24gVmUodCl7bGV0IGU9YFNvbWUgZXh0ZW5zaW9ucyBhcmUgaW5jb21wYXRpYmxlIHdpdGggXFxgJHttLnNka05hbWV9QCR7bS52ZXJzaW9ufVxcYDpgO3JldHVybiB0LmZpbHRlcihuPT50eXBlb2Ygbi5jb21wYXQhPVwidW5kZWZpbmVkXCImJm4uY29tcGF0IT09bnVsbCkuZm9yRWFjaChuPT57bGV0IHI9bi5jb21wYXRbbS5zZGtOYW1lXTt0eXBlb2Ygcj09XCJzdHJpbmdcIj9lKz1gXG4gIC0gRXh0ZW5zaW9uIFxcYCR7bi5uYW1lfVxcYCBzdXBwb3J0cyB2ZXJzaW9uKHMpIFxcYCR7cn1cXGBgOnJ8fChlKz1gXG4gIC0gRXh0ZW5zaW9uIFxcYCR7bi5uYW1lfVxcYCBkb2VzIG5vdCBzdXBwb3J0ICR7bS5wbGF0Zm9ybX0gZW52aXJvbm1lbnRzLmApfSksbmV3ICQoSi5JbmNvbXBhdGlibGVFeHRlbnNpb25zLGUpfWZ1bmN0aW9uIHplKHQpe2xldCBlPW49PntsZXQgcj1uKzEscz1yJTEwLG89ciUxMDA7cmV0dXJuIHM9PT0xJiZvIT09MTE/YCR7cn1zdGA6cz09PTImJm8hPT0xMj9gJHtyfW5kYDpzPT09MyYmbyE9PTEzP2Ake3J9cmRgOmAke3J9dGhgfTtyZXR1cm4gbmV3ICQoSi5JbnZhbGlkQXJndW1lbnQsYEludmFsaWQgJHtlKHQuYXJndW1lbnQpfSBhcmd1bWVudCBnaXZlbiB0byBcXGAke3QucHJvY2VkdXJlfVxcYC5cbiAgRXhwZWN0ZWQ6IFxcYCR7dC5leHBlY3RlZH1cXGBcbiAgUmVjZWl2ZWQ6IFxcYCR7dC5yZWNlaXZlZH1cXGBgKX1mdW5jdGlvbiBwcigpe3JldHVybiBuZXcgVyhyZS5EdXBsaWNhdGVJZnJhbWUsXCJEdXBsaWNhdGUgaWZyYW1lcyBmb3VuZC5cIil9ZnVuY3Rpb24gWWUoKXtyZXR1cm4gbmV3IFcocmUuU3luY1dlYjNNZXRob2QsXCJOb24tYXN5bmMgd2ViMyBtZXRob2RzIGFyZSBkZXByZWNhdGVkIGluIHdlYjMgPiAxLjAgYW5kIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBNYWdpYyB3ZWIzIHByb3ZpZGVyLiBQbGVhc2UgdXNlIGFuIGFzeW5jIG1ldGhvZCBpbnN0ZWFkLlwiKX1mdW5jdGlvbiBaZSgpe3JldHVybiBuZXcgVyhyZS5SZWFjdE5hdGl2ZUVuZHBvaW50Q29uZmlndXJhdGlvbixgQ1VTVE9NIERPTUFJTlMgQVJFIE5PVCBTVVBQT1JURUQgV0hFTiBVU0lORyBNQUdJQyBTREsgV0lUSCBSRUFDVCBOQVRJVkUhIFRoZSBcXGBlbmRwb2ludFxcYCBwYXJhbWV0ZXIgU0hPVUxEIE5PVCBiZSBwcm92aWRlZC4gVGhlIE1hZ2ljIFxcYDxpZnJhbWU+XFxgIGlzIGF1dG9tYXRpY2FsbHkgd3JhcHBlZCBieSBhIFdlYlZpZXcgcG9pbnRlZCBhdCBcXGAke20uZGVmYXVsdEVuZHBvaW50fVxcYC4gQ2hhbmdpbmcgdGhpcyBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgbGVhZCB0byB1bmV4cGVjdGVkIHJlc3VsdHMgYW5kIHBvdGVudGlhbGx5IHNlY3VyaXR5LXRocmVhdGVuaW5nIGJ1Z3MuYCl9ZnVuY3Rpb24gdXIodCl7bGV0e21ldGhvZDplLHJlbW92YWxWZXJzaW9uczpuLHVzZUluc3RlYWQ6cn09dCxzPW5bbS5zZGtOYW1lXSxvPXI/YCBVc2UgXFxgJHtyfVxcYCBpbnN0ZWFkLmA6XCJcIixhPWBcXGAke2V9XFxgIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIFxcYCR7bS5zZGtOYW1lfVxcYCBpbiB2ZXJzaW9uIFxcYCR7c31cXGAuJHtvfWA7cmV0dXJuIG5ldyBXKHJlLkRlcHJlY2F0aW9uTm90aWNlLGEpfWltcG9ydHtNYWdpY1BheWxvYWRNZXRob2QgYXMgQX1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7aW1wb3J0e01hZ2ljT3V0Z29pbmdXaW5kb3dNZXNzYWdlIGFzIE1uLE1hZ2ljSW5jb21pbmdXaW5kb3dNZXNzYWdlIGFzIE5uLE1hZ2ljUGF5bG9hZE1ldGhvZCBhcyB3bn1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7ZnVuY3Rpb24qeG4oKXtsZXQgdD0wO2Zvcig7Oyl0PE51bWJlci5NQVhfU0FGRV9JTlRFR0VSP3lpZWxkKyt0OnQ9MH12YXIgSW49eG4oKTtmdW5jdGlvbiBoZSgpe3JldHVybiBJbi5uZXh0KCkudmFsdWV9dmFyIFFlPVN5bWJvbChcIlBheWxvYWQgcHJlLXByb2Nlc3NlZCBieSBNYWdpYyBTREtcIik7ZnVuY3Rpb24gZXQodCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFFlLHt2YWx1ZTohMCxlbnVtZXJhYmxlOiExfSksdH1mdW5jdGlvbiBQbih0KXtyZXR1cm4hIXRbUWVdfWZ1bmN0aW9uIEModCl7dmFyIGUsbixyO3JldHVybiBQbih0KXx8KHQuanNvbnJwYz0oZT10Lmpzb25ycGMpIT1udWxsP2U6XCIyLjBcIix0LmlkPWhlKCksdC5tZXRob2Q9KG49dC5tZXRob2QpIT1udWxsP246XCJub29wXCIsdC5wYXJhbXM9KHI9dC5wYXJhbXMpIT1udWxsP3I6W10sZXQodCkpLHR9ZnVuY3Rpb24gRSh0LGU9W10pe3JldHVybiBldCh7cGFyYW1zOmUsbWV0aG9kOnQsanNvbnJwYzpcIjIuMFwiLGlkOmhlKCl9KX12YXIgXz1jbGFzc3tjb25zdHJ1Y3RvcihlKXtlIGluc3RhbmNlb2YgXz8odGhpcy5fanNvbnJwYz1lLnBheWxvYWQuanNvbnJwYyx0aGlzLl9pZD1lLnBheWxvYWQuaWQsdGhpcy5fcmVzdWx0PWUucGF5bG9hZC5yZXN1bHQsdGhpcy5fZXJyb3I9ZS5wYXlsb2FkLmVycm9yKTpGZShlKT8odGhpcy5fanNvbnJwYz1lLmpzb25ycGMsdGhpcy5faWQ9ZS5pZCx0aGlzLl9yZXN1bHQ9ZS5yZXN1bHQsdGhpcy5fZXJyb3I9ZS5lcnJvcik6KHRoaXMuX2pzb25ycGM9ZS5qc29ucnBjLHRoaXMuX2lkPWUuaWQsdGhpcy5fcmVzdWx0PXZvaWQgMCx0aGlzLl9lcnJvcj12b2lkIDApfWFwcGx5RXJyb3IoZSl7cmV0dXJuIHRoaXMuX2Vycm9yPWUsdGhpc31hcHBseVJlc3VsdChlKXtyZXR1cm4gdGhpcy5fcmVzdWx0PWUsdGhpc31nZXQgaGFzRXJyb3IoKXtyZXR1cm4gdHlwZW9mIHRoaXMuX2Vycm9yIT1cInVuZGVmaW5lZFwiJiZ0aGlzLl9lcnJvciE9PW51bGx9Z2V0IGhhc1Jlc3VsdCgpe3JldHVybiB0eXBlb2YgdGhpcy5fcmVzdWx0IT1cInVuZGVmaW5lZFwifWdldCBwYXlsb2FkKCl7cmV0dXJue2pzb25ycGM6dGhpcy5fanNvbnJwYyxpZDp0aGlzLl9pZCxyZXN1bHQ6dGhpcy5fcmVzdWx0LGVycm9yOnRoaXMuX2Vycm9yfX19O3ZhciBydD13dChudCgpKSxzdD1jbGFzcyBleHRlbmRzIHJ0LmRlZmF1bHR7fTtmdW5jdGlvbiBpZSgpe2xldCB0PW5ldyBzdDtyZXR1cm57ZW1pdHRlcjp0LGNyZWF0ZUNoYWluaW5nRW1pdHRlck1ldGhvZDoocixzKT0+KC4uLm8pPT4odFtyXS5hcHBseSh0LG8pLHMpLGNyZWF0ZUJvdW5kRW1pdHRlck1ldGhvZDpyPT4oLi4ucyk9PnRbcl0uYXBwbHkodCxzKX19dmFyIG90PVN5bWJvbChcImlzUHJvbWlFdmVudFwiKTtmdW5jdGlvbiBpdCh0KXtyZXR1cm4hIXRbb3RdfWZ1bmN0aW9uIGFlKHQpe2xldCBlPWdlKHQpLHtjcmVhdGVCb3VuZEVtaXR0ZXJNZXRob2Q6bixjcmVhdGVDaGFpbmluZ0VtaXR0ZXJNZXRob2Q6cn09aWUoKSxzPVN5bWJvbChcIlByb21pc2UudGhlblwiKSxvPVN5bWJvbChcIlByb21pc2UuY2F0Y2hcIiksYT1TeW1ib2woXCJQcm9taXNlLmZpbmFsbHlcIiksaT0obCx1KT0+KC4uLnYpPT57bGV0IE09dVtsXS5hcHBseSh1LHYpO3JldHVybiBjKE0pfSxjPWw9Pk9iamVjdC5hc3NpZ24obCx7W290XTohMCxbc106bFtzXXx8bC50aGVuLFtvXTpsW29dfHxsLmNhdGNoLFthXTpsW2FdfHxsLmZpbmFsbHksdGhlbjppKHMsbCksY2F0Y2g6aShvLGwpLGZpbmFsbHk6aShhLGwpLG9uOnIoXCJvblwiLGwpLG9uY2U6cihcIm9uY2VcIixsKSxhZGRMaXN0ZW5lcjpyKFwiYWRkTGlzdGVuZXJcIixsKSxvZmY6cihcIm9mZlwiLGwpLHJlbW92ZUxpc3RlbmVyOnIoXCJyZW1vdmVMaXN0ZW5lclwiLGwpLHJlbW92ZUFsbExpc3RlbmVyczpyKFwicmVtb3ZlQWxsTGlzdGVuZXJzXCIsbCksZW1pdDpuKFwiZW1pdFwiKSxldmVudE5hbWVzOm4oXCJldmVudE5hbWVzXCIpLGxpc3RlbmVyczpuKFwibGlzdGVuZXJzXCIpLGxpc3RlbmVyQ291bnQ6bihcImxpc3RlbmVyQ291bnRcIil9KSxwPWMoZS50aGVuKGw9PihwLmVtaXQoXCJkb25lXCIsbCkscC5lbWl0KFwic2V0dGxlZFwiKSxsKSxsPT57dGhyb3cgcC5lbWl0KFwiZXJyb3JcIixsKSxwLmVtaXQoXCJzZXR0bGVkXCIpLGx9KSk7cmV0dXJuIHB9ZnVuY3Rpb24gZ2UodCl7cmV0dXJuIG5ldyBQcm9taXNlKChlLG4pPT57bGV0IHI9dChlLG4pO1Byb21pc2UucmVzb2x2ZShyKS5jYXRjaChuKX0pfXZhciBQPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuc2RrPWV9Z2V0IG92ZXJsYXkoKXtyZXR1cm4gdGhpcy5zZGsub3ZlcmxheX1yZXF1ZXN0KGUpe2xldCBuPXRoaXMub3ZlcmxheS5wb3N0KE1uLk1BR0lDX0hBTkRMRV9SRVFVRVNULEMoZSkpLHI9YWUoKG8sYSk9PntuLnRoZW4oaT0+e2lmKHMoKSxpLmhhc0Vycm9yKWEobmV3IHcoaS5wYXlsb2FkLmVycm9yKSk7ZWxzZSBpZihpLmhhc1Jlc3VsdClvKGkucGF5bG9hZC5yZXN1bHQpO2Vsc2UgdGhyb3cgQmUoKX0pLmNhdGNoKGk9PntzKCksYShpKX0pfSkscz10aGlzLm92ZXJsYXkub24oTm4uTUFHSUNfSEFORExFX0VWRU5ULG89Pnt2YXIgaTtsZXR7cmVzcG9uc2U6YX09by5kYXRhO2lmKGEuaWQ9PT1lLmlkJiYoKGk9YS5yZXN1bHQpPT1udWxsP3ZvaWQgMDppLmV2ZW50KSl7bGV0e2V2ZW50OmMscGFyYW1zOnA9W119PWEucmVzdWx0O3IuZW1pdChjLC4uLnApfX0pO3JldHVybiByfWNyZWF0ZUludGVybWVkaWFyeUV2ZW50KGUsbil7cmV0dXJuIHM9PntsZXQgbz1FKHduLkludGVybWVkaWFyeUV2ZW50LFt7cGF5bG9hZElkOm4sZXZlbnRUeXBlOmUsYXJnczpzfV0pO3RoaXMucmVxdWVzdChvKX19fTt2YXIgeWU9Y2xhc3MgZXh0ZW5kcyBQe2xvZ2luV2l0aE1hZ2ljTGluayhlKXtsZXR7ZW1haWw6bixzaG93VUk6cj0hMCxyZWRpcmVjdFVSSTpzfT1lLG89RSh0aGlzLnNkay50ZXN0TW9kZT9BLkxvZ2luV2l0aE1hZ2ljTGlua1Rlc3RNb2RlOkEuTG9naW5XaXRoTWFnaWNMaW5rLFt7ZW1haWw6bixzaG93VUk6cixyZWRpcmVjdFVSSTpzfV0pO3JldHVybiB0aGlzLnJlcXVlc3Qobyl9bG9naW5XaXRoU01TKGUpe2xldHtwaG9uZU51bWJlcjpufT1lLHI9RSh0aGlzLnNkay50ZXN0TW9kZT9BLkxvZ2luV2l0aFNtc1Rlc3RNb2RlOkEuTG9naW5XaXRoU21zLFt7cGhvbmVOdW1iZXI6bixzaG93VUk6ITB9XSk7cmV0dXJuIHRoaXMucmVxdWVzdChyKX1sb2dpbldpdGhFbWFpbE9UUChlKXtsZXR7ZW1haWw6bn09ZSxyPUUodGhpcy5zZGsudGVzdE1vZGU/QS5Mb2dpbldpdGhFbWFpbE9UUFRlc3RNb2RlOkEuTG9naW5XaXRoRW1haWxPVFAsW3tlbWFpbDpuLHNob3dVSTohMH1dKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KHIpfWxvZ2luV2l0aENyZWRlbnRpYWwoZSl7bGV0IG49ZSE9bnVsbD9lOlwiXCI7aWYoIWUmJm0ucGxhdGZvcm09PT1cIndlYlwiKXtuPXdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7bGV0IHM9d2luZG93LmxvY2F0aW9uLm9yaWdpbit3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKG51bGwsXCJcIixzKX1sZXQgcj1FKHRoaXMuc2RrLnRlc3RNb2RlP0EuTG9naW5XaXRoQ3JlZGVudGlhbFRlc3RNb2RlOkEuTG9naW5XaXRoQ3JlZGVudGlhbCxbbl0pO3JldHVybiB0aGlzLnJlcXVlc3Qocil9fTtpbXBvcnR7TWFnaWNQYXlsb2FkTWV0aG9kIGFzIHh9ZnJvbVwiQG1hZ2ljLXNkay90eXBlc1wiO3ZhciBIPXt9O010KEgse2NsZWFyOigpPT5BbixnZXRJdGVtOigpPT5ELGl0ZXJhdGU6KCk9PkNuLGtleTooKT0+U24sa2V5czooKT0+T24sbGVuZ3RoOigpPT5MbixyZW1vdmVJdGVtOigpPT5sZSxzZXRJdGVtOigpPT5xfSk7dmFyIGNlO2Z1bmN0aW9uIEwodCl7cmV0dXJuKC4uLmUpPT5JKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtyZXR1cm4gY2V8fChjZT15aWVsZCBtLmNvbmZpZ3VyZVN0b3JhZ2UoKSkseWllbGQgY2UucmVhZHkoKSxjZVt0XSguLi5lKX0pfXZhciBEPUwoXCJnZXRJdGVtXCIpLHE9TChcInNldEl0ZW1cIiksbGU9TChcInJlbW92ZUl0ZW1cIiksQW49TChcImNsZWFyXCIpLExuPUwoXCJsZW5ndGhcIiksU249TChcImtleVwiKSxPbj1MKFwia2V5c1wiKSxDbj1MKFwiaXRlcmF0ZVwiKTtmdW5jdGlvbiBhdCgpe2xldCB0PXdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7dFs2XT10WzZdJjE1fDY0LHRbOF09dFs4XSYxOTF8MTI4O2xldCBlPVwiXCI7cmV0dXJuIGUrPXRbMF0udG9TdHJpbmcoMTYpLGUrPXRbMV0udG9TdHJpbmcoMTYpLGUrPXRbMl0udG9TdHJpbmcoMTYpLGUrPXRbM10udG9TdHJpbmcoMTYpLGUrPVwiLVwiLGUrPXRbNF0udG9TdHJpbmcoMTYpLGUrPXRbNV0udG9TdHJpbmcoMTYpLGUrPVwiLVwiLGUrPXRbNl0udG9TdHJpbmcoMTYpLGUrPXRbN10udG9TdHJpbmcoMTYpLGUrPVwiLVwiLGUrPXRbOF0udG9TdHJpbmcoMTYpLGUrPXRbOV0udG9TdHJpbmcoMTYpLGUrPVwiLVwiLGUrPXRbMTBdLnRvU3RyaW5nKDE2KSxlKz10WzExXS50b1N0cmluZygxNiksZSs9dFsxMl0udG9TdHJpbmcoMTYpLGUrPXRbMTNdLnRvU3RyaW5nKDE2KSxlKz10WzE0XS50b1N0cmluZygxNiksZSs9dFsxNV0udG9TdHJpbmcoMTYpLGV9dmFyIFJlPVwiU1RPUkVfS0VZX1BSSVZBVEVfS0VZXCIscGU9XCJTVE9SRV9LRVlfUFVCTElDX0pXS1wiLFRlPVwiRUNEU0FcIixjdD1cIlAtMjU2XCIsX249e25hbWU6VGUsbmFtZWRDdXJ2ZTpjdH0sRG49e25hbWU6VGUsbmFtZWRDdXJ2ZTpjdH07ZnVuY3Rpb24gbHQoKXtsZShwZSksbGUoUmUpfWZ1bmN0aW9uIHB0KCl7cmV0dXJuIEkodGhpcyxudWxsLGZ1bmN0aW9uKigpe2xldCB0PXlpZWxkIGtuKCk7aWYoIXQpe2NvbnNvbGUuaW5mbyhcInVuYWJsZSB0byBjcmVhdGUgcHVibGljIGtleSBvciB3ZWJjcnlwdG8gaXMgdW5zdXBwb3J0ZWRcIik7cmV0dXJufWxldHtzdWJ0bGU6ZX09d2luZG93LmNyeXB0byxuPXlpZWxkIEQoUmUpO2lmKCFufHwhZSl7Y29uc29sZS5pbmZvKFwidW5hYmxlIHRvIGZpbmQgcHJpdmF0ZSBrZXkgb3Igd2ViY3J5cHRvIHVuc3VwcG9ydGVkXCIpO3JldHVybn1sZXQgcj17aWF0Ok1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkvMWUzKSxqdGk6YXQoKX0scz17dHlwOlwiZHBvcCtqd3RcIixhbGc6XCJFUzI1NlwiLGp3azp0fSxvPXtwcm90ZWN0ZWQ6dXQoSlNPTi5zdHJpbmdpZnkocykpLGNsYWltczp1dChKU09OLnN0cmluZ2lmeShyKSl9LGE9R24oYCR7by5wcm90ZWN0ZWR9LiR7by5jbGFpbXN9YCksaT17bmFtZTpUZSxoYXNoOntuYW1lOlwiU0hBLTI1NlwifX0sYz1LbihuZXcgVWludDhBcnJheSh5aWVsZCBlLnNpZ24oaSxuLGEpKSk7cmV0dXJuYCR7by5wcm90ZWN0ZWR9LiR7by5jbGFpbXN9LiR7Y31gfSl9ZnVuY3Rpb24ga24oKXtyZXR1cm4gSSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7aWYoIXFuKCkpe2NvbnNvbGUuaW5mbyhcIndlYmNyeXB0byBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybn1yZXR1cm4oeWllbGQgRChwZSkpfHwoeWllbGQgSm4oKSksRChwZSl9KX1mdW5jdGlvbiBKbigpe3JldHVybiBJKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtsZXQgdD1udWxsLHtzdWJ0bGU6ZX09d2luZG93LmNyeXB0byxuPXlpZWxkIGUuZ2VuZXJhdGVLZXkoX24sITAsW1wic2lnblwiXSkscj15aWVsZCBlLmV4cG9ydEtleShcImp3a1wiLG4ucHJpdmF0ZUtleSk7dD15aWVsZCBlLmV4cG9ydEtleShcImp3a1wiLG4ucHVibGljS2V5KTtsZXQgcz15aWVsZCBlLmltcG9ydEtleShcImp3a1wiLHIsRG4sITEsW1wic2lnblwiXSk7eWllbGQgcShSZSxzKSx5aWVsZCBxKHBlLHQpfSl9ZnVuY3Rpb24gcW4oKXtsZXQgdD10eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiJiYhIXdpbmRvdy5jcnlwdG8sZT10JiYhIXdpbmRvdy5jcnlwdG8uc3VidGxlO3JldHVybiB0JiZlfWZ1bmN0aW9uIHV0KHQpe3JldHVybiBkdChVbih0KSl9ZnVuY3Rpb24gR24odCl7cmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0KX1mdW5jdGlvbiBkdCh0KXtyZXR1cm4gYnRvYSh0KS5yZXBsYWNlKC9cXCsvZyxcIi1cIikucmVwbGFjZSgvXFwvL2csXCJfXCIpLnJlcGxhY2UoLz0rL2csXCJcIil9ZnVuY3Rpb24gVW4odCl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0KS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLChuLHIpPT5TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHIsMTYpKSl9ZnVuY3Rpb24gS24odCl7bGV0IGU9XCJcIjtyZXR1cm4gdC5mb3JFYWNoKG49PntlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pfSksZHQoZSl9dmFyIHZlPWNsYXNzIGV4dGVuZHMgUHtnZXRJZFRva2VuKGUpe2xldCBuPUUodGhpcy5zZGsudGVzdE1vZGU/eC5HZXRJZFRva2VuVGVzdE1vZGU6eC5HZXRJZFRva2VuLFtlXSk7cmV0dXJuIHRoaXMucmVxdWVzdChuKX1nZW5lcmF0ZUlkVG9rZW4oZSl7bGV0IG49RSh0aGlzLnNkay50ZXN0TW9kZT94LkdlbmVyYXRlSWRUb2tlblRlc3RNb2RlOnguR2VuZXJhdGVJZFRva2VuLFtlXSk7cmV0dXJuIHRoaXMucmVxdWVzdChuKX1nZXRNZXRhZGF0YSgpe2xldCBlPUUodGhpcy5zZGsudGVzdE1vZGU/eC5HZXRNZXRhZGF0YVRlc3RNb2RlOnguR2V0TWV0YWRhdGEpO3JldHVybiB0aGlzLnJlcXVlc3QoZSl9dXBkYXRlRW1haWwoZSl7bGV0e2VtYWlsOm4sc2hvd1VJOnI9ITB9PWUscz1FKHRoaXMuc2RrLnRlc3RNb2RlP3guVXBkYXRlRW1haWxUZXN0TW9kZTp4LlVwZGF0ZUVtYWlsLFt7ZW1haWw6bixzaG93VUk6cn1dKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KHMpfWlzTG9nZ2VkSW4oKXtsZXQgZT1FKHRoaXMuc2RrLnRlc3RNb2RlP3guSXNMb2dnZWRJblRlc3RNb2RlOnguSXNMb2dnZWRJbik7cmV0dXJuIHRoaXMucmVxdWVzdChlKX1sb2dvdXQoKXtsdCgpO2xldCBlPUUodGhpcy5zZGsudGVzdE1vZGU/eC5Mb2dvdXRUZXN0TW9kZTp4LkxvZ291dCk7cmV0dXJuIHRoaXMucmVxdWVzdChlKX1zaG93U2V0dGluZ3MoKXtsZXQgZT1FKHRoaXMuc2RrLnRlc3RNb2RlP3guVXNlclNldHRpbmdzVGVzdE1vZGU6eC5Vc2VyU2V0dGluZ3MpO3JldHVybiB0aGlzLnJlcXVlc3QoZSl9fTtpbXBvcnR7TWFnaWNPdXRnb2luZ1dpbmRvd01lc3NhZ2UgYXMgbXR9ZnJvbVwiQG1hZ2ljLXNkay90eXBlc1wiO3ZhcntjcmVhdGVCb3VuZEVtaXR0ZXJNZXRob2Q6dWUsY3JlYXRlQ2hhaW5pbmdFbWl0dGVyTWV0aG9kOkd9PWllKCkseGU9Y2xhc3MgZXh0ZW5kcyBQe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKTt0aGlzLmlzTWFnaWM9ITA7dGhpcy5vbj1HKFwib25cIix0aGlzKTt0aGlzLm9uY2U9RyhcIm9uY2VcIix0aGlzKTt0aGlzLmFkZExpc3RlbmVyPUcoXCJhZGRMaXN0ZW5lclwiLHRoaXMpO3RoaXMub2ZmPUcoXCJvZmZcIix0aGlzKTt0aGlzLnJlbW92ZUxpc3RlbmVyPUcoXCJyZW1vdmVMaXN0ZW5lclwiLHRoaXMpO3RoaXMucmVtb3ZlQWxsTGlzdGVuZXJzPUcoXCJyZW1vdmVBbGxMaXN0ZW5lcnNcIix0aGlzKTt0aGlzLmVtaXQ9dWUoXCJlbWl0XCIpO3RoaXMuZXZlbnROYW1lcz11ZShcImV2ZW50TmFtZXNcIik7dGhpcy5saXN0ZW5lcnM9dWUoXCJsaXN0ZW5lcnNcIik7dGhpcy5saXN0ZW5lckNvdW50PXVlKFwibGlzdGVuZXJDb3VudFwiKX1zZW5kQXN5bmMoZSxuKXtpZighbil0aHJvdyB6ZSh7cHJvY2VkdXJlOlwiTWFnaWMucnBjUHJvdmlkZXIuc2VuZEFzeW5jXCIsYXJndW1lbnQ6MSxleHBlY3RlZDpcImZ1bmN0aW9uXCIscmVjZWl2ZWQ6bj09PW51bGw/XCJudWxsXCI6dHlwZW9mIG59KTtpZihBcnJheS5pc0FycmF5KGUpKXRoaXMub3ZlcmxheS5wb3N0KG10Lk1BR0lDX0hBTkRMRV9SRVFVRVNULGUubWFwKHI9PntsZXQgcz1DKHIpO3JldHVybiB0aGlzLnByZWZpeFBheWxvYWRNZXRob2RGb3JUZXN0TW9kZShzKSxzfSkpLnRoZW4ocj0+e24obnVsbCxyLm1hcChzPT53ZSh6KHt9LHMucGF5bG9hZCkse2Vycm9yOnMuaGFzRXJyb3I/bmV3IHcocy5wYXlsb2FkLmVycm9yKTpudWxsfSkpKX0pO2Vsc2V7bGV0IHI9QyhlKTt0aGlzLnByZWZpeFBheWxvYWRNZXRob2RGb3JUZXN0TW9kZShyKSx0aGlzLm92ZXJsYXkucG9zdChtdC5NQUdJQ19IQU5ETEVfUkVRVUVTVCxyKS50aGVuKHM9PntuKHMuaGFzRXJyb3I/bmV3IHcocy5wYXlsb2FkLmVycm9yKTpudWxsLHMucGF5bG9hZCl9KX19c2VuZChlLG4pe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXtsZXQgcz1FKGUsQXJyYXkuaXNBcnJheShuKT9uOltdKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KHMpfWlmKEFycmF5LmlzQXJyYXkoZSl8fCEhbil7dGhpcy5zZW5kQXN5bmMoZSxuKTtyZXR1cm59bGV0IHI9WWUoKTtyZXR1cm4gci5sb2coKSxuZXcgXyhlKS5hcHBseUVycm9yKHtjb2RlOi0zMjYwMyxtZXNzYWdlOnIucmF3TWVzc2FnZX0pLnBheWxvYWR9ZW5hYmxlKCl7bGV0IGU9RShcImV0aF9hY2NvdW50c1wiKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KGUpfXJlcXVlc3QoZSl7cmV0dXJuIHRoaXMucHJlZml4UGF5bG9hZE1ldGhvZEZvclRlc3RNb2RlKGUpLHN1cGVyLnJlcXVlc3QoZSl9cHJlZml4UGF5bG9hZE1ldGhvZEZvclRlc3RNb2RlKGUpe2xldCBuPVwidGVzdE1vZGUvZXRoL1wiO3RoaXMuc2RrLnRlc3RNb2RlJiYoZS5tZXRob2Q9YCR7bn0ke2UubWV0aG9kfWApfX07ZnVuY3Rpb24gSWUodCxlKXtyZXR1cm4gZT9uZXcgVVJMKHQsZSk6bmV3IFVSTCh0KX12YXIgRXQ9W1wicmVxdWVzdFwiLFwib3ZlcmxheVwiLFwic2RrXCJdO2Z1bmN0aW9uIEZuKHQpe2xldCBlPU9iamVjdC5nZXRQcm90b3R5cGVPZih0KSxuPVtlXTtmb3IoO2UhPT1QLnByb3RvdHlwZTspZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZSksbi5wdXNoKGUpO3JldHVybiBufXZhciBQZT1jbGFzcyBleHRlbmRzIFB7Y29uc3RydWN0b3IoKXtzdXBlcih2b2lkIDApO3RoaXMuX19zZGtfYWNjZXNzX2ZpZWxkX2Rlc2NyaXB0b3JzX189bmV3IE1hcDt0aGlzLl9faXNfaW5pdGlhbGl6ZWRfXz0hMTt0aGlzLnV0aWxzPXtjcmVhdGVQcm9taUV2ZW50OmFlLGlzUHJvbWlFdmVudDppdCxlbmNvZGVKU09OOmVlLGRlY29kZUpTT046S2UsY3JlYXRlSnNvblJwY1JlcXVlc3RQYXlsb2FkOkUsc3RhbmRhcmRpemVKc29uUnBjUmVxdWVzdFBheWxvYWQ6QyxzdG9yYWdlOkh9O2xldCBlPVt0aGlzLC4uLkZuKHRoaXMpXTtFdC5mb3JFYWNoKG49PntsZXQgcj1lLm1hcChpPT5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGksbikpLHM9ci5maW5kSW5kZXgoaT0+ISFpKSxvPXM+MCxhPXJbc107YSYmKHRoaXMuX19zZGtfYWNjZXNzX2ZpZWxkX2Rlc2NyaXB0b3JzX18uc2V0KG4se2Rlc2NyaXB0b3I6YSxpc1Byb3RvdHlwZUZpZWxkOm99KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxuLHtjb25maWd1cmFibGU6ITAsZ2V0OigpPT57dGhyb3cgSGUobil9fSkpfSl9aW5pdChlKXt0aGlzLl9faXNfaW5pdGlhbGl6ZWRfX3x8KEV0LmZvckVhY2gobj0+e2lmKHRoaXMuX19zZGtfYWNjZXNzX2ZpZWxkX2Rlc2NyaXB0b3JzX18uaGFzKG4pKXtsZXR7ZGVzY3JpcHRvcjpyLGlzUHJvdG90eXBlRmllbGQ6c309dGhpcy5fX3Nka19hY2Nlc3NfZmllbGRfZGVzY3JpcHRvcnNfXy5nZXQobik7cz9kZWxldGUgdGhpc1tuXTpPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxuLHIpfX0pLHRoaXMuc2RrPWUsdGhpcy5fX2lzX2luaXRpYWxpemVkX189ITApfWNyZWF0ZURlcHJlY2F0aW9uV2FybmluZyhlKXtsZXR7bWV0aG9kOm4scmVtb3ZhbFZlcnNpb246cix1c2VJbnN0ZWFkOnN9PWUsbz1zP2AgVXNlIFxcYCR7c31cXGAgaW5zdGVhZC5gOlwiXCIsYT1gXFxgJHtufVxcYCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGlzIEV4dGVuc2lvbiBpbiB2ZXJzaW9uIFxcYCR7cn1cXGAuJHtvfWA7cmV0dXJuIG5ldyBzZSh0aGlzLFwiREVQUkVDQVRJT05fTk9USUNFXCIsYSl9Y3JlYXRlV2FybmluZyhlLG4pe3JldHVybiBuZXcgc2UodGhpcyxlLG4pfWNyZWF0ZUVycm9yKGUsbixyKXtyZXR1cm4gbmV3IFgodGhpcyxlLG4scil9fSxodD1jbGFzcyBleHRlbmRzIFBle30sUz1jbGFzcyBleHRlbmRzIFBle307Uy5JbnRlcm5hbD1odCxTLkFub255bW91cz1cImFub255bW91cyBleHRlbnNpb25cIjtmdW5jdGlvbiBmdCh0KXtyZXR1cm4gdC5jb21wYXQmJnQuY29tcGF0W20uc2RrTmFtZV0hPW51bGw/dHlwZW9mIHQuY29tcGF0W20uc2RrTmFtZV09PVwic3RyaW5nXCI/SmUoVWUobS52ZXJzaW9uKSx0LmNvbXBhdFttLnNka05hbWVdKTohIXQuY29tcGF0W20uc2RrTmFtZV06ITB9ZnVuY3Rpb24gam4odCl7dmFyIHM7bGV0IGU9KHM9dD09bnVsbD92b2lkIDA6dC5leHRlbnNpb25zKSE9bnVsbD9zOltdLG49e30scj1bXTtpZihBcnJheS5pc0FycmF5KGUpP2UuZm9yRWFjaChvPT57ZnQobyk/KG8uaW5pdCh0aGlzKSwoby5uYW1lfHxvLm5hbWUhPT1TLkFub255bW91cykmJih0aGlzW28ubmFtZV09byksbyBpbnN0YW5jZW9mIFMuSW50ZXJuYWwmJihuZShvLmNvbmZpZyl8fChuW28ubmFtZV09by5jb25maWcpKSk6ci5wdXNoKG8pfSk6T2JqZWN0LmtleXMoZSkuZm9yRWFjaChvPT57aWYoZnQoZVtvXSkpe2Vbb10uaW5pdCh0aGlzKTtsZXQgYT1lW29dO3RoaXNbb109YSxhIGluc3RhbmNlb2YgUy5JbnRlcm5hbCYmKG5lKGEuY29uZmlnKXx8KG5bZVtvXS5uYW1lXT1hLmNvbmZpZykpfWVsc2Ugci5wdXNoKGVbb10pfSksci5sZW5ndGgpdGhyb3cgVmUocik7cmV0dXJuIG59dmFyIFY9Y2xhc3N7Y29uc3RydWN0b3IoZSxuKXt0aGlzLmFwaUtleT1lO3ZhciBhO2lmKCFlKXRocm93IFhlKCk7bS5wbGF0Zm9ybT09PVwicmVhY3QtbmF0aXZlXCImJihuPT1udWxsP3ZvaWQgMDpuLmVuZHBvaW50KSYmWmUoKS5sb2coKTtsZXR7ZGVmYXVsdEVuZHBvaW50OnIsdmVyc2lvbjpzfT1tO3RoaXMudGVzdE1vZGU9ISEobj09bnVsbD92b2lkIDA6bi50ZXN0TW9kZSksdGhpcy5lbmRwb2ludD1JZSgoYT1uPT1udWxsP3ZvaWQgMDpuLmVuZHBvaW50KSE9bnVsbD9hOnIpLm9yaWdpbix0aGlzLmF1dGg9bmV3IHllKHRoaXMpLHRoaXMudXNlcj1uZXcgdmUodGhpcyksdGhpcy5ycGNQcm92aWRlcj1uZXcgeGUodGhpcyk7bGV0IG89am4uY2FsbCh0aGlzLG4pO3RoaXMucGFyYW1ldGVycz1lZSh6KHtBUElfS0VZOnRoaXMuYXBpS2V5LERPTUFJTl9PUklHSU46d2luZG93LmxvY2F0aW9uP3dpbmRvdy5sb2NhdGlvbi5vcmlnaW46XCJcIixFVEhfTkVUV09SSzpuPT1udWxsP3ZvaWQgMDpuLm5ldHdvcmssaG9zdDpJZSh0aGlzLmVuZHBvaW50KS5ob3N0LHNkazpXZVttLnNka05hbWVdLHZlcnNpb246cyxleHQ6bmUobyk/dm9pZCAwOm8sbG9jYWxlOihuPT1udWxsP3ZvaWQgMDpuLmxvY2FsZSl8fFwiZW5fVVNcIn0sbS5idW5kbGVJZD97YnVuZGxlSWQ6bS5idW5kbGVJZH06e30pKX1nZXQgb3ZlcmxheSgpe2lmKCFWLl9fb3ZlcmxheXNfXy5oYXModGhpcy5wYXJhbWV0ZXJzKSl7bGV0IGU9bmV3IG0uVmlld0NvbnRyb2xsZXIodGhpcy5lbmRwb2ludCx0aGlzLnBhcmFtZXRlcnMpO2UuaW5pdCgpLFYuX19vdmVybGF5c19fLnNldCh0aGlzLnBhcmFtZXRlcnMsZSl9cmV0dXJuIFYuX19vdmVybGF5c19fLmdldCh0aGlzLnBhcmFtZXRlcnMpfXByZWxvYWQoKXtyZXR1cm4gSSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5vdmVybGF5LnJlYWR5fSl9fSxiZT1WO2JlLl9fb3ZlcmxheXNfXz1uZXcgTWFwO2ltcG9ydHtNYWdpY0luY29taW5nV2luZG93TWVzc2FnZSBhcyBkZX1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7ZnVuY3Rpb24gV24odCxlKXtyZXR1cm4gZSYmQXJyYXkuaXNBcnJheSh0KT90LmZpbmQobj0+bi5pZD09PWUpOnR9ZnVuY3Rpb24gWG4odCxlKXt2YXIgcztsZXQgbj0ocz1lLmRhdGEucmVzcG9uc2UpPT1udWxsP3ZvaWQgMDpzLmlkLHI9V24odCxuKTtpZihuJiZyKXtsZXQgbz1uZXcgXyhyKS5hcHBseVJlc3VsdChlLmRhdGEucmVzcG9uc2UucmVzdWx0KS5hcHBseUVycm9yKGUuZGF0YS5yZXNwb25zZS5lcnJvcik7cmV0dXJue2lkOm4scmVzcG9uc2U6b319cmV0dXJue319ZnVuY3Rpb24gQm4odCxlKXtyZXR1cm4gSSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7bGV0IG49eWllbGQgRChcInJ0XCIpLHI7aWYobS5wbGF0Zm9ybT09PVwid2ViXCIpdHJ5e3I9eWllbGQgcHQoKX1jYXRjaChzKXtjb25zb2xlLmVycm9yKFwid2ViY3J5cHRvIGVycm9yXCIscyl9cmV0dXJuIHI/bj97bXNnVHlwZTp0LHBheWxvYWQ6ZSxqd3Q6cixydDpufTp7bXNnVHlwZTp0LHBheWxvYWQ6ZSxqd3Q6cn06e21zZ1R5cGU6dCxwYXlsb2FkOmV9fSl9ZnVuY3Rpb24gSG4odCl7cmV0dXJuIEkodGhpcyxudWxsLGZ1bmN0aW9uKigpeyF0LmRhdGEucnR8fCh5aWVsZCBxKFwicnRcIix0LmRhdGEucnQpKX0pfXZhciBndD1jbGFzc3tjb25zdHJ1Y3RvcihlLG4pe3RoaXMuZW5kcG9pbnQ9ZTt0aGlzLnBhcmFtZXRlcnM9bjt0aGlzLm1lc3NhZ2VIYW5kbGVycz1uZXcgU2V0O3RoaXMucmVhZHk9dGhpcy53YWl0Rm9yUmVhZHkoKSx0aGlzLmxpc3RlbigpfXBvc3QoZSxuKXtyZXR1cm4gSSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7cmV0dXJuIGdlKHI9PkkodGhpcyxudWxsLGZ1bmN0aW9uKigpe3lpZWxkIHRoaXMucmVhZHk7bGV0IHM9W10sbz1BcnJheS5pc0FycmF5KG4pP24ubWFwKHA9PnAuaWQpOltdLGE9eWllbGQgQm4oYCR7ZX0tJHt0aGlzLnBhcmFtZXRlcnN9YCxuKTt5aWVsZCB0aGlzLl9wb3N0KGEpO2xldCBpPXA9Pmw9PntsZXR7aWQ6dSxyZXNwb25zZTp2fT1YbihuLGwpO0huKGwpLHUmJnYmJkFycmF5LmlzQXJyYXkobikmJm8uaW5jbHVkZXModSk/KHMucHVzaCh2KSxzLmxlbmd0aD09PW4ubGVuZ3RoJiYocCgpLHIocykpKTp1JiZ2JiYhQXJyYXkuaXNBcnJheShuKSYmdT09PW4uaWQmJihwKCkscih2KSl9LGM9dGhpcy5vbihkZS5NQUdJQ19IQU5ETEVfUkVTUE9OU0UsaSgoKT0+YygpKSl9KSl9KX1vbihlLG4pe2xldCByPW4uYmluZCh3aW5kb3cpLHM9bz0+e28uZGF0YS5tc2dUeXBlPT09YCR7ZX0tJHt0aGlzLnBhcmFtZXRlcnN9YCYmcihvKX07cmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXJzLmFkZChzKSwoKT0+dGhpcy5tZXNzYWdlSGFuZGxlcnMuZGVsZXRlKHMpfXdhaXRGb3JSZWFkeSgpe3JldHVybiBuZXcgUHJvbWlzZShlPT57dGhpcy5vbihkZS5NQUdJQ19PVkVSTEFZX1JFQURZLCgpPT5lKCkpfSl9bGlzdGVuKCl7dGhpcy5vbihkZS5NQUdJQ19ISURFX09WRVJMQVksKCk9Pnt0aGlzLmhpZGVPdmVybGF5KCl9KSx0aGlzLm9uKGRlLk1BR0lDX1NIT1dfT1ZFUkxBWSwoKT0+e3RoaXMuc2hvd092ZXJsYXkoKX0pfX07ZXhwb3J0e1MgYXMgRXh0ZW5zaW9uLFggYXMgTWFnaWNFeHRlbnNpb25FcnJvcixzZSBhcyBNYWdpY0V4dGVuc2lvbldhcm5pbmcsdyBhcyBNYWdpY1JQQ0Vycm9yLCQgYXMgTWFnaWNTREtFcnJvcixXIGFzIE1hZ2ljU0RLV2FybmluZyxiZSBhcyBTREtCYXNlLFJlIGFzIFNUT1JFX0tFWV9QUklWQVRFX0tFWSxwZSBhcyBTVE9SRV9LRVlfUFVCTElDX0pXSyxzdCBhcyBUeXBlZEVtaXR0ZXIsZ3QgYXMgVmlld0NvbnRyb2xsZXIsbHQgYXMgY2xlYXJLZXlzLHVyIGFzIGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZyxwciBhcyBjcmVhdGVEdXBsaWNhdGVJZnJhbWVXYXJuaW5nLEhlIGFzIGNyZWF0ZUV4dGVuc2lvbk5vdEluaXRpYWxpemVkRXJyb3IsVmUgYXMgY3JlYXRlSW5jb21wYXRpYmxlRXh0ZW5zaW9uc0Vycm9yLHplIGFzIGNyZWF0ZUludmFsaWRBcmd1bWVudEVycm9yLHB0IGFzIGNyZWF0ZUp3dCxCZSBhcyBjcmVhdGVNYWxmb3JtZWRSZXNwb25zZUVycm9yLFhlIGFzIGNyZWF0ZU1pc3NpbmdBcGlLZXlFcnJvcixsciBhcyBjcmVhdGVNb2RhbE5vdFJlYWR5RXJyb3IsYWUgYXMgY3JlYXRlUHJvbWlFdmVudCxnZSBhcyBjcmVhdGVQcm9taXNlLFplIGFzIGNyZWF0ZVJlYWN0TmF0aXZlRW5kcG9pbnRDb25maWd1cmF0aW9uV2FybmluZyxUbiBhcyBjcmVhdGVTREssWWUgYXMgY3JlYXRlU3luY2hyb25vdXNXZWIzTWV0aG9kV2FybmluZyxpZSBhcyBjcmVhdGVUeXBlZEVtaXR0ZXIsSWUgYXMgY3JlYXRlVVJMLEtlIGFzIGRlY29kZUpTT04sZWUgYXMgZW5jb2RlSlNPTixoZSBhcyBnZXRQYXlsb2FkSWQsbmUgYXMgaXNFbXB0eSxqZSBhcyBpc0pzb25ScGNFcnJvckNvZGUsdHIgYXMgaXNKc29uUnBjUmVxdWVzdFBheWxvYWQsRmUgYXMgaXNKc29uUnBjUmVzcG9uc2VQYXlsb2FkLG5yIGFzIGlzTWFnaWNQYXlsb2FkTWV0aG9kLGl0IGFzIGlzUHJvbWlFdmVudCxIIGFzIHN0b3JhZ2UsYXQgYXMgdXVpZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnR7RXh0ZW5zaW9uIGFzIG4sTWFnaWNTREtFcnJvciBhcyBvLE1hZ2ljRXh0ZW5zaW9uRXJyb3IgYXMgYSxNYWdpY0V4dGVuc2lvbldhcm5pbmcgYXMgdCxNYWdpY1JQQ0Vycm9yIGFzIHMsTWFnaWNTREtXYXJuaW5nIGFzIEUsaXNQcm9taUV2ZW50IGFzIGV9ZnJvbVwiQG1hZ2ljLXNkay9wcm92aWRlclwiO2V4cG9ydCpmcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7ZXhwb3J0e24gYXMgRXh0ZW5zaW9uLGEgYXMgRXh0ZW5zaW9uRXJyb3IsdCBhcyBFeHRlbnNpb25XYXJuaW5nLHMgYXMgUlBDRXJyb3IsbyBhcyBTREtFcnJvcixFIGFzIFNES1dhcm5pbmcsZSBhcyBpc1Byb21pRXZlbnR9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwidmFyIFpyPU9iamVjdC5jcmVhdGU7dmFyIERlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgcXI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIga3I9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIGV0PU9iamVjdC5nZXRQcm90b3R5cGVPZixydD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciB0dD1wPT5EZShwLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB2ZT0ocD0+dHlwZW9mIHJlcXVpcmUhPVwidW5kZWZpbmVkXCI/cmVxdWlyZTp0eXBlb2YgUHJveHkhPVwidW5kZWZpbmVkXCI/bmV3IFByb3h5KHAse2dldDooZyxPKT0+KHR5cGVvZiByZXF1aXJlIT1cInVuZGVmaW5lZFwiP3JlcXVpcmU6ZylbT119KTpwKShmdW5jdGlvbihwKXtpZih0eXBlb2YgcmVxdWlyZSE9XCJ1bmRlZmluZWRcIilyZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmUgb2YgXCInK3ArJ1wiIGlzIG5vdCBzdXBwb3J0ZWQnKX0pO3ZhciAkZT0ocCxnKT0+KCk9PihnfHxwKChnPXtleHBvcnRzOnt9fSkuZXhwb3J0cyxnKSxnLmV4cG9ydHMpO3ZhciBudD0ocCxnLE8sTCk9PntpZihnJiZ0eXBlb2YgZz09XCJvYmplY3RcInx8dHlwZW9mIGc9PVwiZnVuY3Rpb25cIilmb3IobGV0IE0gb2Yga3IoZykpIXJ0LmNhbGwocCxNKSYmKE98fE0hPT1cImRlZmF1bHRcIikmJkRlKHAsTSx7Z2V0OigpPT5nW01dLGVudW1lcmFibGU6IShMPXFyKGcsTSkpfHxMLmVudW1lcmFibGV9KTtyZXR1cm4gcH0sWmU9KHAsZyk9Pm50KHR0KERlKHAhPW51bGw/WnIoZXQocCkpOnt9LFwiZGVmYXVsdFwiLCFnJiZwJiZwLl9fZXNNb2R1bGU/e2dldDooKT0+cC5kZWZhdWx0LGVudW1lcmFibGU6ITB9Ont2YWx1ZTpwLGVudW1lcmFibGU6ITB9KSkscCk7dmFyIHNlPShwLGcsTyk9Pm5ldyBQcm9taXNlKChMLE0pPT57dmFyIFE9Uz0+e3RyeXtZKE8ubmV4dChTKSl9Y2F0Y2goUCl7TShQKX19LEM9Uz0+e3RyeXtZKE8udGhyb3coUykpfWNhdGNoKFApe00oUCl9fSxZPVM9PlMuZG9uZT9MKFMudmFsdWUpOlByb21pc2UucmVzb2x2ZShTLnZhbHVlKS50aGVuKFEsQyk7WSgoTz1PLmFwcGx5KHAsZykpLm5leHQoKSl9KTt2YXIga2U9JGUoKHFlLE5lKT0+eyhmdW5jdGlvbihwKXtpZih0eXBlb2YgcWU9PVwib2JqZWN0XCImJnR5cGVvZiBOZSE9XCJ1bmRlZmluZWRcIilOZS5leHBvcnRzPXAoKTtlbHNlIGlmKHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZClkZWZpbmUoW10scCk7ZWxzZXt2YXIgZzt0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiP2c9d2luZG93OnR5cGVvZiBnbG9iYWwhPVwidW5kZWZpbmVkXCI/Zz1nbG9iYWw6dHlwZW9mIHNlbGYhPVwidW5kZWZpbmVkXCI/Zz1zZWxmOmc9dGhpcyxnLmxvY2FsZm9yYWdlPXAoKX19KShmdW5jdGlvbigpe3ZhciBwLGcsTztyZXR1cm4gZnVuY3Rpb24gTChNLFEsQyl7ZnVuY3Rpb24gWShLLFope2lmKCFRW0tdKXtpZighTVtLXSl7dmFyIG09dHlwZW9mIHZlPT1cImZ1bmN0aW9uXCImJnZlO2lmKCFaJiZtKXJldHVybiBtKEssITApO2lmKFMpcmV0dXJuIFMoSywhMCk7dmFyIHc9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitLK1wiJ1wiKTt0aHJvdyB3LmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsd312YXIgTj1RW0tdPXtleHBvcnRzOnt9fTtNW0tdWzBdLmNhbGwoTi5leHBvcnRzLGZ1bmN0aW9uKHope3ZhciBxPU1bS11bMV1bel07cmV0dXJuIFkocXx8eil9LE4sTi5leHBvcnRzLEwsTSxRLEMpfXJldHVybiBRW0tdLmV4cG9ydHN9Zm9yKHZhciBTPXR5cGVvZiB2ZT09XCJmdW5jdGlvblwiJiZ2ZSxQPTA7UDxDLmxlbmd0aDtQKyspWShDW1BdKTtyZXR1cm4gWX0oezE6W2Z1bmN0aW9uKEwsTSxRKXsoZnVuY3Rpb24oQyl7XCJ1c2Ugc3RyaWN0XCI7dmFyIFk9Qy5NdXRhdGlvbk9ic2VydmVyfHxDLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsUztpZihZKXt2YXIgUD0wLEs9bmV3IFkoeiksWj1DLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO0sub2JzZXJ2ZShaLHtjaGFyYWN0ZXJEYXRhOiEwfSksUz1mdW5jdGlvbigpe1ouZGF0YT1QPSsrUCUyfX1lbHNlIGlmKCFDLnNldEltbWVkaWF0ZSYmdHlwZW9mIEMuTWVzc2FnZUNoYW5uZWwhPVwidW5kZWZpbmVkXCIpe3ZhciBtPW5ldyBDLk1lc3NhZ2VDaGFubmVsO20ucG9ydDEub25tZXNzYWdlPXosUz1mdW5jdGlvbigpe20ucG9ydDIucG9zdE1lc3NhZ2UoMCl9fWVsc2VcImRvY3VtZW50XCJpbiBDJiZcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gQy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpP1M9ZnVuY3Rpb24oKXt2YXIgRj1DLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Ri5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXt6KCksRi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbCxGLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoRiksRj1udWxsfSxDLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChGKX06Uz1mdW5jdGlvbigpe3NldFRpbWVvdXQoeiwwKX07dmFyIHcsTj1bXTtmdW5jdGlvbiB6KCl7dz0hMDtmb3IodmFyIEYsayxVPU4ubGVuZ3RoO1U7KXtmb3Ioaz1OLE49W10sRj0tMTsrK0Y8VTspa1tGXSgpO1U9Ti5sZW5ndGh9dz0hMX1NLmV4cG9ydHM9cTtmdW5jdGlvbiBxKEYpe04ucHVzaChGKT09PTEmJiF3JiZTKCl9fSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwhPVwidW5kZWZpbmVkXCI/Z2xvYmFsOnR5cGVvZiBzZWxmIT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7fV0sMjpbZnVuY3Rpb24oTCxNLFEpe1widXNlIHN0cmljdFwiO3ZhciBDPUwoMSk7ZnVuY3Rpb24gWSgpe312YXIgUz17fSxQPVtcIlJFSkVDVEVEXCJdLEs9W1wiRlVMRklMTEVEXCJdLFo9W1wiUEVORElOR1wiXTtNLmV4cG9ydHM9bTtmdW5jdGlvbiBtKGgpe2lmKHR5cGVvZiBoIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTt0aGlzLnN0YXRlPVosdGhpcy5xdWV1ZT1bXSx0aGlzLm91dGNvbWU9dm9pZCAwLGghPT1ZJiZxKHRoaXMsaCl9bS5wcm90b3R5cGUuY2F0Y2g9ZnVuY3Rpb24oaCl7cmV0dXJuIHRoaXMudGhlbihudWxsLGgpfSxtLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGgsUil7aWYodHlwZW9mIGghPVwiZnVuY3Rpb25cIiYmdGhpcy5zdGF0ZT09PUt8fHR5cGVvZiBSIT1cImZ1bmN0aW9uXCImJnRoaXMuc3RhdGU9PT1QKXJldHVybiB0aGlzO3ZhciBJPW5ldyB0aGlzLmNvbnN0cnVjdG9yKFkpO2lmKHRoaXMuc3RhdGUhPT1aKXt2YXIgQj10aGlzLnN0YXRlPT09Sz9oOlI7TihJLEIsdGhpcy5vdXRjb21lKX1lbHNlIHRoaXMucXVldWUucHVzaChuZXcgdyhJLGgsUikpO3JldHVybiBJfTtmdW5jdGlvbiB3KGgsUixJKXt0aGlzLnByb21pc2U9aCx0eXBlb2YgUj09XCJmdW5jdGlvblwiJiYodGhpcy5vbkZ1bGZpbGxlZD1SLHRoaXMuY2FsbEZ1bGZpbGxlZD10aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZCksdHlwZW9mIEk9PVwiZnVuY3Rpb25cIiYmKHRoaXMub25SZWplY3RlZD1JLHRoaXMuY2FsbFJlamVjdGVkPXRoaXMub3RoZXJDYWxsUmVqZWN0ZWQpfXcucHJvdG90eXBlLmNhbGxGdWxmaWxsZWQ9ZnVuY3Rpb24oaCl7Uy5yZXNvbHZlKHRoaXMucHJvbWlzZSxoKX0sdy5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkPWZ1bmN0aW9uKGgpe04odGhpcy5wcm9taXNlLHRoaXMub25GdWxmaWxsZWQsaCl9LHcucHJvdG90eXBlLmNhbGxSZWplY3RlZD1mdW5jdGlvbihoKXtTLnJlamVjdCh0aGlzLnByb21pc2UsaCl9LHcucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkPWZ1bmN0aW9uKGgpe04odGhpcy5wcm9taXNlLHRoaXMub25SZWplY3RlZCxoKX07ZnVuY3Rpb24gTihoLFIsSSl7QyhmdW5jdGlvbigpe3ZhciBCO3RyeXtCPVIoSSl9Y2F0Y2goSCl7cmV0dXJuIFMucmVqZWN0KGgsSCl9Qj09PWg/Uy5yZWplY3QoaCxuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKSk6Uy5yZXNvbHZlKGgsQil9KX1TLnJlc29sdmU9ZnVuY3Rpb24oaCxSKXt2YXIgST1GKHosUik7aWYoSS5zdGF0dXM9PT1cImVycm9yXCIpcmV0dXJuIFMucmVqZWN0KGgsSS52YWx1ZSk7dmFyIEI9SS52YWx1ZTtpZihCKXEoaCxCKTtlbHNle2guc3RhdGU9SyxoLm91dGNvbWU9Ujtmb3IodmFyIEg9LTEsaj1oLnF1ZXVlLmxlbmd0aDsrK0g8ajspaC5xdWV1ZVtIXS5jYWxsRnVsZmlsbGVkKFIpfXJldHVybiBofSxTLnJlamVjdD1mdW5jdGlvbihoLFIpe2guc3RhdGU9UCxoLm91dGNvbWU9Ujtmb3IodmFyIEk9LTEsQj1oLnF1ZXVlLmxlbmd0aDsrK0k8QjspaC5xdWV1ZVtJXS5jYWxsUmVqZWN0ZWQoUik7cmV0dXJuIGh9O2Z1bmN0aW9uIHooaCl7dmFyIFI9aCYmaC50aGVuO2lmKGgmJih0eXBlb2YgaD09XCJvYmplY3RcInx8dHlwZW9mIGg9PVwiZnVuY3Rpb25cIikmJnR5cGVvZiBSPT1cImZ1bmN0aW9uXCIpcmV0dXJuIGZ1bmN0aW9uKCl7Ui5hcHBseShoLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHEoaCxSKXt2YXIgST0hMTtmdW5jdGlvbiBCKCQpe0l8fChJPSEwLFMucmVqZWN0KGgsJCkpfWZ1bmN0aW9uIEgoJCl7SXx8KEk9ITAsUy5yZXNvbHZlKGgsJCkpfWZ1bmN0aW9uIGooKXtSKEgsQil9dmFyIEo9RihqKTtKLnN0YXR1cz09PVwiZXJyb3JcIiYmQihKLnZhbHVlKX1mdW5jdGlvbiBGKGgsUil7dmFyIEk9e307dHJ5e0kudmFsdWU9aChSKSxJLnN0YXR1cz1cInN1Y2Nlc3NcIn1jYXRjaChCKXtJLnN0YXR1cz1cImVycm9yXCIsSS52YWx1ZT1CfXJldHVybiBJfW0ucmVzb2x2ZT1rO2Z1bmN0aW9uIGsoaCl7cmV0dXJuIGggaW5zdGFuY2VvZiB0aGlzP2g6Uy5yZXNvbHZlKG5ldyB0aGlzKFkpLGgpfW0ucmVqZWN0PVU7ZnVuY3Rpb24gVShoKXt2YXIgUj1uZXcgdGhpcyhZKTtyZXR1cm4gUy5yZWplY3QoUixoKX1tLmFsbD1hZTtmdW5jdGlvbiBhZShoKXt2YXIgUj10aGlzO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChoKSE9PVwiW29iamVjdCBBcnJheV1cIilyZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcihcIm11c3QgYmUgYW4gYXJyYXlcIikpO3ZhciBJPWgubGVuZ3RoLEI9ITE7aWYoIUkpcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7Zm9yKHZhciBIPW5ldyBBcnJheShJKSxqPTAsSj0tMSwkPW5ldyB0aGlzKFkpOysrSjxJOyllZShoW0pdLEopO3JldHVybiAkO2Z1bmN0aW9uIGVlKG9lLGEpe1IucmVzb2x2ZShvZSkudGhlbihzLGZ1bmN0aW9uKHYpe0J8fChCPSEwLFMucmVqZWN0KCQsdikpfSk7ZnVuY3Rpb24gcyh2KXtIW2FdPXYsKytqPT09SSYmIUImJihCPSEwLFMucmVzb2x2ZSgkLEgpKX19fW0ucmFjZT1yZTtmdW5jdGlvbiByZShoKXt2YXIgUj10aGlzO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChoKSE9PVwiW29iamVjdCBBcnJheV1cIilyZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcihcIm11c3QgYmUgYW4gYXJyYXlcIikpO3ZhciBJPWgubGVuZ3RoLEI9ITE7aWYoIUkpcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7Zm9yKHZhciBIPS0xLGo9bmV3IHRoaXMoWSk7KytIPEk7KUooaFtIXSk7cmV0dXJuIGo7ZnVuY3Rpb24gSigkKXtSLnJlc29sdmUoJCkudGhlbihmdW5jdGlvbihlZSl7Qnx8KEI9ITAsUy5yZXNvbHZlKGosZWUpKX0sZnVuY3Rpb24oZWUpe0J8fChCPSEwLFMucmVqZWN0KGosZWUpKX0pfX19LHtcIjFcIjoxfV0sMzpbZnVuY3Rpb24oTCxNLFEpeyhmdW5jdGlvbihDKXtcInVzZSBzdHJpY3RcIjt0eXBlb2YgQy5Qcm9taXNlIT1cImZ1bmN0aW9uXCImJihDLlByb21pc2U9TCgyKSl9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCE9XCJ1bmRlZmluZWRcIj9nbG9iYWw6dHlwZW9mIHNlbGYhPVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIjJcIjoyfV0sNDpbZnVuY3Rpb24oTCxNLFEpe1widXNlIHN0cmljdFwiO3ZhciBDPXR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5pdGVyYXRvcj09XCJzeW1ib2xcIj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZ0eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9O2Z1bmN0aW9uIFkoZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfWZ1bmN0aW9uIFMoKXt0cnl7aWYodHlwZW9mIGluZGV4ZWREQiE9XCJ1bmRlZmluZWRcIilyZXR1cm4gaW5kZXhlZERCO2lmKHR5cGVvZiB3ZWJraXRJbmRleGVkREIhPVwidW5kZWZpbmVkXCIpcmV0dXJuIHdlYmtpdEluZGV4ZWREQjtpZih0eXBlb2YgbW96SW5kZXhlZERCIT1cInVuZGVmaW5lZFwiKXJldHVybiBtb3pJbmRleGVkREI7aWYodHlwZW9mIE9JbmRleGVkREIhPVwidW5kZWZpbmVkXCIpcmV0dXJuIE9JbmRleGVkREI7aWYodHlwZW9mIG1zSW5kZXhlZERCIT1cInVuZGVmaW5lZFwiKXJldHVybiBtc0luZGV4ZWREQn1jYXRjaHtyZXR1cm59fXZhciBQPVMoKTtmdW5jdGlvbiBLKCl7dHJ5e2lmKCFQfHwhUC5vcGVuKXJldHVybiExO3ZhciBlPXR5cGVvZiBvcGVuRGF0YWJhc2UhPVwidW5kZWZpbmVkXCImJi8oU2FmYXJpfGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmIS9CbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSksdD10eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmZmV0Y2gudG9TdHJpbmcoKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXCIpIT09LTE7cmV0dXJuKCFlfHx0KSYmdHlwZW9mIGluZGV4ZWREQiE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIElEQktleVJhbmdlIT1cInVuZGVmaW5lZFwifWNhdGNoe3JldHVybiExfX1mdW5jdGlvbiBaKGUsdCl7ZT1lfHxbXSx0PXR8fHt9O3RyeXtyZXR1cm4gbmV3IEJsb2IoZSx0KX1jYXRjaChuKXtpZihuLm5hbWUhPT1cIlR5cGVFcnJvclwiKXRocm93IG47Zm9yKHZhciByPXR5cGVvZiBCbG9iQnVpbGRlciE9XCJ1bmRlZmluZWRcIj9CbG9iQnVpbGRlcjp0eXBlb2YgTVNCbG9iQnVpbGRlciE9XCJ1bmRlZmluZWRcIj9NU0Jsb2JCdWlsZGVyOnR5cGVvZiBNb3pCbG9iQnVpbGRlciE9XCJ1bmRlZmluZWRcIj9Nb3pCbG9iQnVpbGRlcjpXZWJLaXRCbG9iQnVpbGRlcixvPW5ldyByLGk9MDtpPGUubGVuZ3RoO2krPTEpby5hcHBlbmQoZVtpXSk7cmV0dXJuIG8uZ2V0QmxvYih0LnR5cGUpfX10eXBlb2YgUHJvbWlzZT09XCJ1bmRlZmluZWRcIiYmTCgzKTt2YXIgbT1Qcm9taXNlO2Z1bmN0aW9uIHcoZSx0KXt0JiZlLnRoZW4oZnVuY3Rpb24ocil7dChudWxsLHIpfSxmdW5jdGlvbihyKXt0KHIpfSl9ZnVuY3Rpb24gTihlLHQscil7dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIiYmZS50aGVuKHQpLHR5cGVvZiByPT1cImZ1bmN0aW9uXCImJmUuY2F0Y2gocil9ZnVuY3Rpb24geihlKXtyZXR1cm4gdHlwZW9mIGUhPVwic3RyaW5nXCImJihjb25zb2xlLndhcm4oZStcIiB1c2VkIGFzIGEga2V5LCBidXQgaXQgaXMgbm90IGEgc3RyaW5nLlwiKSxlPVN0cmluZyhlKSksZX1mdW5jdGlvbiBxKCl7aWYoYXJndW1lbnRzLmxlbmd0aCYmdHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdPT1cImZ1bmN0aW9uXCIpcmV0dXJuIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdfXZhciBGPVwibG9jYWwtZm9yYWdlLWRldGVjdC1ibG9iLXN1cHBvcnRcIixrPXZvaWQgMCxVPXt9LGFlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcscmU9XCJyZWFkb25seVwiLGg9XCJyZWFkd3JpdGVcIjtmdW5jdGlvbiBSKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxyPW5ldyBBcnJheUJ1ZmZlcih0KSxvPW5ldyBVaW50OEFycmF5KHIpLGk9MDtpPHQ7aSsrKW9baV09ZS5jaGFyQ29kZUF0KGkpO3JldHVybiByfWZ1bmN0aW9uIEkoZSl7cmV0dXJuIG5ldyBtKGZ1bmN0aW9uKHQpe3ZhciByPWUudHJhbnNhY3Rpb24oRixoKSxvPVooW1wiXCJdKTtyLm9iamVjdFN0b3JlKEYpLnB1dChvLFwia2V5XCIpLHIub25hYm9ydD1mdW5jdGlvbihpKXtpLnByZXZlbnREZWZhdWx0KCksaS5zdG9wUHJvcGFnYXRpb24oKSx0KCExKX0sci5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7dmFyIGk9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyksbj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvLyk7dChufHwhaXx8cGFyc2VJbnQoaVsxXSwxMCk+PTQzKX19KS5jYXRjaChmdW5jdGlvbigpe3JldHVybiExfSl9ZnVuY3Rpb24gQihlKXtyZXR1cm4gdHlwZW9mIGs9PVwiYm9vbGVhblwiP20ucmVzb2x2ZShrKTpJKGUpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIGs9dCxrfSl9ZnVuY3Rpb24gSChlKXt2YXIgdD1VW2UubmFtZV0scj17fTtyLnByb21pc2U9bmV3IG0oZnVuY3Rpb24obyxpKXtyLnJlc29sdmU9byxyLnJlamVjdD1pfSksdC5kZWZlcnJlZE9wZXJhdGlvbnMucHVzaChyKSx0LmRiUmVhZHk/dC5kYlJlYWR5PXQuZGJSZWFkeS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHIucHJvbWlzZX0pOnQuZGJSZWFkeT1yLnByb21pc2V9ZnVuY3Rpb24gaihlKXt2YXIgdD1VW2UubmFtZV0scj10LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtpZihyKXJldHVybiByLnJlc29sdmUoKSxyLnByb21pc2V9ZnVuY3Rpb24gSihlLHQpe3ZhciByPVVbZS5uYW1lXSxvPXIuZGVmZXJyZWRPcGVyYXRpb25zLnBvcCgpO2lmKG8pcmV0dXJuIG8ucmVqZWN0KHQpLG8ucHJvbWlzZX1mdW5jdGlvbiAkKGUsdCl7cmV0dXJuIG5ldyBtKGZ1bmN0aW9uKHIsbyl7aWYoVVtlLm5hbWVdPVVbZS5uYW1lXXx8RygpLGUuZGIpaWYodClIKGUpLGUuZGIuY2xvc2UoKTtlbHNlIHJldHVybiByKGUuZGIpO3ZhciBpPVtlLm5hbWVdO3QmJmkucHVzaChlLnZlcnNpb24pO3ZhciBuPVAub3Blbi5hcHBseShQLGkpO3QmJihuLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihmKXt2YXIgdT1uLnJlc3VsdDt0cnl7dS5jcmVhdGVPYmplY3RTdG9yZShlLnN0b3JlTmFtZSksZi5vbGRWZXJzaW9uPD0xJiZ1LmNyZWF0ZU9iamVjdFN0b3JlKEYpfWNhdGNoKGMpe2lmKGMubmFtZT09PVwiQ29uc3RyYWludEVycm9yXCIpY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInK2UubmFtZSsnXCIgaGFzIGJlZW4gdXBncmFkZWQgZnJvbSB2ZXJzaW9uICcrZi5vbGRWZXJzaW9uK1wiIHRvIHZlcnNpb24gXCIrZi5uZXdWZXJzaW9uKycsIGJ1dCB0aGUgc3RvcmFnZSBcIicrZS5zdG9yZU5hbWUrJ1wiIGFscmVhZHkgZXhpc3RzLicpO2Vsc2UgdGhyb3cgY319KSxuLm9uZXJyb3I9ZnVuY3Rpb24oZil7Zi5wcmV2ZW50RGVmYXVsdCgpLG8obi5lcnJvcil9LG4ub25zdWNjZXNzPWZ1bmN0aW9uKCl7cihuLnJlc3VsdCksaihlKX19KX1mdW5jdGlvbiBlZShlKXtyZXR1cm4gJChlLCExKX1mdW5jdGlvbiBvZShlKXtyZXR1cm4gJChlLCEwKX1mdW5jdGlvbiBhKGUsdCl7aWYoIWUuZGIpcmV0dXJuITA7dmFyIHI9IWUuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhlLnN0b3JlTmFtZSksbz1lLnZlcnNpb248ZS5kYi52ZXJzaW9uLGk9ZS52ZXJzaW9uPmUuZGIudmVyc2lvbjtpZihvJiYoZS52ZXJzaW9uIT09dCYmY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInK2UubmFtZStgXCIgY2FuJ3QgYmUgZG93bmdyYWRlZCBmcm9tIHZlcnNpb24gYCtlLmRiLnZlcnNpb24rXCIgdG8gdmVyc2lvbiBcIitlLnZlcnNpb24rXCIuXCIpLGUudmVyc2lvbj1lLmRiLnZlcnNpb24pLGl8fHIpe2lmKHIpe3ZhciBuPWUuZGIudmVyc2lvbisxO24+ZS52ZXJzaW9uJiYoZS52ZXJzaW9uPW4pfXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIHMoZSl7cmV0dXJuIG5ldyBtKGZ1bmN0aW9uKHQscil7dmFyIG89bmV3IEZpbGVSZWFkZXI7by5vbmVycm9yPXIsby5vbmxvYWRlbmQ9ZnVuY3Rpb24oaSl7dmFyIG49YnRvYShpLnRhcmdldC5yZXN1bHR8fFwiXCIpO3Qoe19fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYjohMCxkYXRhOm4sdHlwZTplLnR5cGV9KX0sby5yZWFkQXNCaW5hcnlTdHJpbmcoZSl9KX1mdW5jdGlvbiB2KGUpe3ZhciB0PVIoYXRvYihlLmRhdGEpKTtyZXR1cm4gWihbdF0se3R5cGU6ZS50eXBlfSl9ZnVuY3Rpb24gYihlKXtyZXR1cm4gZSYmZS5fX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2J9ZnVuY3Rpb24gXyhlKXt2YXIgdD10aGlzLHI9dC5faW5pdFJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBvPVVbdC5fZGJJbmZvLm5hbWVdO2lmKG8mJm8uZGJSZWFkeSlyZXR1cm4gby5kYlJlYWR5fSk7cmV0dXJuIE4ocixlLGUpLHJ9ZnVuY3Rpb24gRShlKXtIKGUpO2Zvcih2YXIgdD1VW2UubmFtZV0scj10LmZvcmFnZXMsbz0wO288ci5sZW5ndGg7bysrKXt2YXIgaT1yW29dO2kuX2RiSW5mby5kYiYmKGkuX2RiSW5mby5kYi5jbG9zZSgpLGkuX2RiSW5mby5kYj1udWxsKX1yZXR1cm4gZS5kYj1udWxsLGVlKGUpLnRoZW4oZnVuY3Rpb24obil7cmV0dXJuIGUuZGI9bixhKGUpP29lKGUpOm59KS50aGVuKGZ1bmN0aW9uKG4pe2UuZGI9dC5kYj1uO2Zvcih2YXIgZj0wO2Y8ci5sZW5ndGg7ZisrKXJbZl0uX2RiSW5mby5kYj1ufSkuY2F0Y2goZnVuY3Rpb24obil7dGhyb3cgSihlLG4pLG59KX1mdW5jdGlvbiBEKGUsdCxyLG8pe289PT12b2lkIDAmJihvPTEpO3RyeXt2YXIgaT1lLmRiLnRyYW5zYWN0aW9uKGUuc3RvcmVOYW1lLHQpO3IobnVsbCxpKX1jYXRjaChuKXtpZihvPjAmJighZS5kYnx8bi5uYW1lPT09XCJJbnZhbGlkU3RhdGVFcnJvclwifHxuLm5hbWU9PT1cIk5vdEZvdW5kRXJyb3JcIikpcmV0dXJuIG0ucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtpZighZS5kYnx8bi5uYW1lPT09XCJOb3RGb3VuZEVycm9yXCImJiFlLmRiLm9iamVjdFN0b3JlTmFtZXMuY29udGFpbnMoZS5zdG9yZU5hbWUpJiZlLnZlcnNpb248PWUuZGIudmVyc2lvbilyZXR1cm4gZS5kYiYmKGUudmVyc2lvbj1lLmRiLnZlcnNpb24rMSksb2UoZSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEUoZSkudGhlbihmdW5jdGlvbigpe0QoZSx0LHIsby0xKX0pfSkuY2F0Y2gocik7cihuKX19ZnVuY3Rpb24gRygpe3JldHVybntmb3JhZ2VzOltdLGRiOm51bGwsZGJSZWFkeTpudWxsLGRlZmVycmVkT3BlcmF0aW9uczpbXX19ZnVuY3Rpb24gZmUoZSl7dmFyIHQ9dGhpcyxyPXtkYjpudWxsfTtpZihlKWZvcih2YXIgbyBpbiBlKXJbb109ZVtvXTt2YXIgaT1VW3IubmFtZV07aXx8KGk9RygpLFVbci5uYW1lXT1pKSxpLmZvcmFnZXMucHVzaCh0KSx0Ll9pbml0UmVhZHl8fCh0Ll9pbml0UmVhZHk9dC5yZWFkeSx0LnJlYWR5PV8pO3ZhciBuPVtdO2Z1bmN0aW9uIGYoKXtyZXR1cm4gbS5yZXNvbHZlKCl9Zm9yKHZhciB1PTA7dTxpLmZvcmFnZXMubGVuZ3RoO3UrKyl7dmFyIGM9aS5mb3JhZ2VzW3VdO2MhPT10JiZuLnB1c2goYy5faW5pdFJlYWR5KCkuY2F0Y2goZikpfXZhciBsPWkuZm9yYWdlcy5zbGljZSgwKTtyZXR1cm4gbS5hbGwobikudGhlbihmdW5jdGlvbigpe3JldHVybiByLmRiPWkuZGIsZWUocil9KS50aGVuKGZ1bmN0aW9uKGQpe3JldHVybiByLmRiPWQsYShyLHQuX2RlZmF1bHRDb25maWcudmVyc2lvbik/b2Uocik6ZH0pLnRoZW4oZnVuY3Rpb24oZCl7ci5kYj1pLmRiPWQsdC5fZGJJbmZvPXI7Zm9yKHZhciB5PTA7eTxsLmxlbmd0aDt5Kyspe3ZhciBBPWxbeV07QSE9PXQmJihBLl9kYkluZm8uZGI9ci5kYixBLl9kYkluZm8udmVyc2lvbj1yLnZlcnNpb24pfX0pfWZ1bmN0aW9uIGllKGUsdCl7dmFyIHI9dGhpcztlPXooZSk7dmFyIG89bmV3IG0oZnVuY3Rpb24oaSxuKXtyLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe0Qoci5fZGJJbmZvLHJlLGZ1bmN0aW9uKGYsdSl7aWYoZilyZXR1cm4gbihmKTt0cnl7dmFyIGM9dS5vYmplY3RTdG9yZShyLl9kYkluZm8uc3RvcmVOYW1lKSxsPWMuZ2V0KGUpO2wub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIGQ9bC5yZXN1bHQ7ZD09PXZvaWQgMCYmKGQ9bnVsbCksYihkKSYmKGQ9dihkKSksaShkKX0sbC5vbmVycm9yPWZ1bmN0aW9uKCl7bihsLmVycm9yKX19Y2F0Y2goZCl7bihkKX19KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIGNlKGUsdCl7dmFyIHI9dGhpcyxvPW5ldyBtKGZ1bmN0aW9uKGksbil7ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtEKHIuX2RiSW5mbyxyZSxmdW5jdGlvbihmLHUpe2lmKGYpcmV0dXJuIG4oZik7dHJ5e3ZhciBjPXUub2JqZWN0U3RvcmUoci5fZGJJbmZvLnN0b3JlTmFtZSksbD1jLm9wZW5DdXJzb3IoKSxkPTE7bC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgeT1sLnJlc3VsdDtpZih5KXt2YXIgQT15LnZhbHVlO2IoQSkmJihBPXYoQSkpO3ZhciBUPWUoQSx5LmtleSxkKyspO1QhPT12b2lkIDA/aShUKTp5LmNvbnRpbnVlKCl9ZWxzZSBpKCl9LGwub25lcnJvcj1mdW5jdGlvbigpe24obC5lcnJvcil9fWNhdGNoKHkpe24oeSl9fSl9KS5jYXRjaChuKX0pO3JldHVybiB3KG8sdCksb31mdW5jdGlvbiBucihlLHQscil7dmFyIG89dGhpcztlPXooZSk7dmFyIGk9bmV3IG0oZnVuY3Rpb24obixmKXt2YXIgdTtvLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3JldHVybiB1PW8uX2RiSW5mbyxhZS5jYWxsKHQpPT09XCJbb2JqZWN0IEJsb2JdXCI/Qih1LmRiKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBjP3Q6cyh0KX0pOnR9KS50aGVuKGZ1bmN0aW9uKGMpe0Qoby5fZGJJbmZvLGgsZnVuY3Rpb24obCxkKXtpZihsKXJldHVybiBmKGwpO3RyeXt2YXIgeT1kLm9iamVjdFN0b3JlKG8uX2RiSW5mby5zdG9yZU5hbWUpO2M9PT1udWxsJiYoYz12b2lkIDApO3ZhciBBPXkucHV0KGMsZSk7ZC5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7Yz09PXZvaWQgMCYmKGM9bnVsbCksbihjKX0sZC5vbmFib3J0PWQub25lcnJvcj1mdW5jdGlvbigpe3ZhciBUPUEuZXJyb3I/QS5lcnJvcjpBLnRyYW5zYWN0aW9uLmVycm9yO2YoVCl9fWNhdGNoKFQpe2YoVCl9fSl9KS5jYXRjaChmKX0pO3JldHVybiB3KGksciksaX1mdW5jdGlvbiBvcihlLHQpe3ZhciByPXRoaXM7ZT16KGUpO3ZhciBvPW5ldyBtKGZ1bmN0aW9uKGksbil7ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtEKHIuX2RiSW5mbyxoLGZ1bmN0aW9uKGYsdSl7aWYoZilyZXR1cm4gbihmKTt0cnl7dmFyIGM9dS5vYmplY3RTdG9yZShyLl9kYkluZm8uc3RvcmVOYW1lKSxsPWMuZGVsZXRlKGUpO3Uub25jb21wbGV0ZT1mdW5jdGlvbigpe2koKX0sdS5vbmVycm9yPWZ1bmN0aW9uKCl7bihsLmVycm9yKX0sdS5vbmFib3J0PWZ1bmN0aW9uKCl7dmFyIGQ9bC5lcnJvcj9sLmVycm9yOmwudHJhbnNhY3Rpb24uZXJyb3I7bihkKX19Y2F0Y2goZCl7bihkKX19KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIGlyKGUpe3ZhciB0PXRoaXMscj1uZXcgbShmdW5jdGlvbihvLGkpe3QucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7RCh0Ll9kYkluZm8saCxmdW5jdGlvbihuLGYpe2lmKG4pcmV0dXJuIGkobik7dHJ5e3ZhciB1PWYub2JqZWN0U3RvcmUodC5fZGJJbmZvLnN0b3JlTmFtZSksYz11LmNsZWFyKCk7Zi5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7bygpfSxmLm9uYWJvcnQ9Zi5vbmVycm9yPWZ1bmN0aW9uKCl7dmFyIGw9Yy5lcnJvcj9jLmVycm9yOmMudHJhbnNhY3Rpb24uZXJyb3I7aShsKX19Y2F0Y2gobCl7aShsKX19KX0pLmNhdGNoKGkpfSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIGFyKGUpe3ZhciB0PXRoaXMscj1uZXcgbShmdW5jdGlvbihvLGkpe3QucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7RCh0Ll9kYkluZm8scmUsZnVuY3Rpb24obixmKXtpZihuKXJldHVybiBpKG4pO3RyeXt2YXIgdT1mLm9iamVjdFN0b3JlKHQuX2RiSW5mby5zdG9yZU5hbWUpLGM9dS5jb3VudCgpO2Mub25zdWNjZXNzPWZ1bmN0aW9uKCl7byhjLnJlc3VsdCl9LGMub25lcnJvcj1mdW5jdGlvbigpe2koYy5lcnJvcil9fWNhdGNoKGwpe2kobCl9fSl9KS5jYXRjaChpKX0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiBmcihlLHQpe3ZhciByPXRoaXMsbz1uZXcgbShmdW5jdGlvbihpLG4pe2lmKGU8MCl7aShudWxsKTtyZXR1cm59ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtEKHIuX2RiSW5mbyxyZSxmdW5jdGlvbihmLHUpe2lmKGYpcmV0dXJuIG4oZik7dHJ5e3ZhciBjPXUub2JqZWN0U3RvcmUoci5fZGJJbmZvLnN0b3JlTmFtZSksbD0hMSxkPWMub3BlbktleUN1cnNvcigpO2Qub25zdWNjZXNzPWZ1bmN0aW9uKCl7dmFyIHk9ZC5yZXN1bHQ7aWYoIXkpe2kobnVsbCk7cmV0dXJufWU9PT0wfHxsP2koeS5rZXkpOihsPSEwLHkuYWR2YW5jZShlKSl9LGQub25lcnJvcj1mdW5jdGlvbigpe24oZC5lcnJvcil9fWNhdGNoKHkpe24oeSl9fSl9KS5jYXRjaChuKX0pO3JldHVybiB3KG8sdCksb31mdW5jdGlvbiB1cihlKXt2YXIgdD10aGlzLHI9bmV3IG0oZnVuY3Rpb24obyxpKXt0LnJlYWR5KCkudGhlbihmdW5jdGlvbigpe0QodC5fZGJJbmZvLHJlLGZ1bmN0aW9uKG4sZil7aWYobilyZXR1cm4gaShuKTt0cnl7dmFyIHU9Zi5vYmplY3RTdG9yZSh0Ll9kYkluZm8uc3RvcmVOYW1lKSxjPXUub3BlbktleUN1cnNvcigpLGw9W107Yy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZD1jLnJlc3VsdDtpZighZCl7byhsKTtyZXR1cm59bC5wdXNoKGQua2V5KSxkLmNvbnRpbnVlKCl9LGMub25lcnJvcj1mdW5jdGlvbigpe2koYy5lcnJvcil9fWNhdGNoKGQpe2koZCl9fSl9KS5jYXRjaChpKX0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiBzcihlLHQpe3Q9cS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHI9dGhpcy5jb25maWcoKTtlPXR5cGVvZiBlIT1cImZ1bmN0aW9uXCImJmV8fHt9LGUubmFtZXx8KGUubmFtZT1lLm5hbWV8fHIubmFtZSxlLnN0b3JlTmFtZT1lLnN0b3JlTmFtZXx8ci5zdG9yZU5hbWUpO3ZhciBvPXRoaXMsaTtpZighZS5uYW1lKWk9bS5yZWplY3QoXCJJbnZhbGlkIGFyZ3VtZW50c1wiKTtlbHNle3ZhciBuPWUubmFtZT09PXIubmFtZSYmby5fZGJJbmZvLmRiLGY9bj9tLnJlc29sdmUoby5fZGJJbmZvLmRiKTplZShlKS50aGVuKGZ1bmN0aW9uKHUpe3ZhciBjPVVbZS5uYW1lXSxsPWMuZm9yYWdlcztjLmRiPXU7Zm9yKHZhciBkPTA7ZDxsLmxlbmd0aDtkKyspbFtkXS5fZGJJbmZvLmRiPXU7cmV0dXJuIHV9KTtlLnN0b3JlTmFtZT9pPWYudGhlbihmdW5jdGlvbih1KXtpZighIXUub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhlLnN0b3JlTmFtZSkpe3ZhciBjPXUudmVyc2lvbisxO0goZSk7dmFyIGw9VVtlLm5hbWVdLGQ9bC5mb3JhZ2VzO3UuY2xvc2UoKTtmb3IodmFyIHk9MDt5PGQubGVuZ3RoO3krKyl7dmFyIEE9ZFt5XTtBLl9kYkluZm8uZGI9bnVsbCxBLl9kYkluZm8udmVyc2lvbj1jfXZhciBUPW5ldyBtKGZ1bmN0aW9uKHgsVil7dmFyIFc9UC5vcGVuKGUubmFtZSxjKTtXLm9uZXJyb3I9ZnVuY3Rpb24oWCl7dmFyIGRlPVcucmVzdWx0O2RlLmNsb3NlKCksVihYKX0sVy5vbnVwZ3JhZGVuZWVkZWQ9ZnVuY3Rpb24oKXt2YXIgWD1XLnJlc3VsdDtYLmRlbGV0ZU9iamVjdFN0b3JlKGUuc3RvcmVOYW1lKX0sVy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgWD1XLnJlc3VsdDtYLmNsb3NlKCkseChYKX19KTtyZXR1cm4gVC50aGVuKGZ1bmN0aW9uKHgpe2wuZGI9eDtmb3IodmFyIFY9MDtWPGQubGVuZ3RoO1YrKyl7dmFyIFc9ZFtWXTtXLl9kYkluZm8uZGI9eCxqKFcuX2RiSW5mbyl9fSkuY2F0Y2goZnVuY3Rpb24oeCl7dGhyb3coSihlLHgpfHxtLnJlc29sdmUoKSkuY2F0Y2goZnVuY3Rpb24oKXt9KSx4fSl9fSk6aT1mLnRoZW4oZnVuY3Rpb24odSl7SChlKTt2YXIgYz1VW2UubmFtZV0sbD1jLmZvcmFnZXM7dS5jbG9zZSgpO2Zvcih2YXIgZD0wO2Q8bC5sZW5ndGg7ZCsrKXt2YXIgeT1sW2RdO3kuX2RiSW5mby5kYj1udWxsfXZhciBBPW5ldyBtKGZ1bmN0aW9uKFQseCl7dmFyIFY9UC5kZWxldGVEYXRhYmFzZShlLm5hbWUpO1Yub25lcnJvcj1WLm9uYmxvY2tlZD1mdW5jdGlvbihXKXt2YXIgWD1WLnJlc3VsdDtYJiZYLmNsb3NlKCkseChXKX0sVi5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgVz1WLnJlc3VsdDtXJiZXLmNsb3NlKCksVChXKX19KTtyZXR1cm4gQS50aGVuKGZ1bmN0aW9uKFQpe2MuZGI9VDtmb3IodmFyIHg9MDt4PGwubGVuZ3RoO3grKyl7dmFyIFY9bFt4XTtqKFYuX2RiSW5mbyl9fSkuY2F0Y2goZnVuY3Rpb24oVCl7dGhyb3coSihlLFQpfHxtLnJlc29sdmUoKSkuY2F0Y2goZnVuY3Rpb24oKXt9KSxUfSl9KX1yZXR1cm4gdyhpLHQpLGl9dmFyIGNyPXtfZHJpdmVyOlwiYXN5bmNTdG9yYWdlXCIsX2luaXRTdG9yYWdlOmZlLF9zdXBwb3J0OksoKSxpdGVyYXRlOmNlLGdldEl0ZW06aWUsc2V0SXRlbTpucixyZW1vdmVJdGVtOm9yLGNsZWFyOmlyLGxlbmd0aDphcixrZXk6ZnIsa2V5czp1cixkcm9wSW5zdGFuY2U6c3J9O2Z1bmN0aW9uIGxyKCl7cmV0dXJuIHR5cGVvZiBvcGVuRGF0YWJhc2U9PVwiZnVuY3Rpb25cIn12YXIgdGU9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIsZHI9XCJ+fmxvY2FsX2ZvcmFnZV90eXBlflwiLHhlPS9efn5sb2NhbF9mb3JhZ2VfdHlwZX4oW15+XSspfi8saGU9XCJfX2xmc2NfXzpcIixnZT1oZS5sZW5ndGgsYmU9XCJhcmJmXCIsX2U9XCJibG9iXCIsT2U9XCJzaTA4XCIsQ2U9XCJ1aTA4XCIsTGU9XCJ1aWM4XCIsUGU9XCJzaTE2XCIsTWU9XCJzaTMyXCIsRmU9XCJ1cjE2XCIsVWU9XCJ1aTMyXCIsWWU9XCJmbDMyXCIsemU9XCJmbDY0XCIsV2U9Z2UrYmUubGVuZ3RoLEtlPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gSGUoZSl7dmFyIHQ9ZS5sZW5ndGgqLjc1LHI9ZS5sZW5ndGgsbyxpPTAsbixmLHUsYztlW2UubGVuZ3RoLTFdPT09XCI9XCImJih0LS0sZVtlLmxlbmd0aC0yXT09PVwiPVwiJiZ0LS0pO3ZhciBsPW5ldyBBcnJheUJ1ZmZlcih0KSxkPW5ldyBVaW50OEFycmF5KGwpO2ZvcihvPTA7bzxyO28rPTQpbj10ZS5pbmRleE9mKGVbb10pLGY9dGUuaW5kZXhPZihlW28rMV0pLHU9dGUuaW5kZXhPZihlW28rMl0pLGM9dGUuaW5kZXhPZihlW28rM10pLGRbaSsrXT1uPDwyfGY+PjQsZFtpKytdPShmJjE1KTw8NHx1Pj4yLGRbaSsrXT0odSYzKTw8NnxjJjYzO3JldHVybiBsfWZ1bmN0aW9uIHdlKGUpe3ZhciB0PW5ldyBVaW50OEFycmF5KGUpLHI9XCJcIixvO2ZvcihvPTA7bzx0Lmxlbmd0aDtvKz0zKXIrPXRlW3Rbb10+PjJdLHIrPXRlWyh0W29dJjMpPDw0fHRbbysxXT4+NF0scis9dGVbKHRbbysxXSYxNSk8PDJ8dFtvKzJdPj42XSxyKz10ZVt0W28rMl0mNjNdO3JldHVybiB0Lmxlbmd0aCUzPT09Mj9yPXIuc3Vic3RyaW5nKDAsci5sZW5ndGgtMSkrXCI9XCI6dC5sZW5ndGglMz09PTEmJihyPXIuc3Vic3RyaW5nKDAsci5sZW5ndGgtMikrXCI9PVwiKSxyfWZ1bmN0aW9uIHZyKGUsdCl7dmFyIHI9XCJcIjtpZihlJiYocj1LZS5jYWxsKGUpKSxlJiYocj09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cInx8ZS5idWZmZXImJktlLmNhbGwoZS5idWZmZXIpPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiKSl7dmFyIG8saT1oZTtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/KG89ZSxpKz1iZSk6KG89ZS5idWZmZXIscj09PVwiW29iamVjdCBJbnQ4QXJyYXldXCI/aSs9T2U6cj09PVwiW29iamVjdCBVaW50OEFycmF5XVwiP2krPUNlOnI9PT1cIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI/aSs9TGU6cj09PVwiW29iamVjdCBJbnQxNkFycmF5XVwiP2krPVBlOnI9PT1cIltvYmplY3QgVWludDE2QXJyYXldXCI/aSs9RmU6cj09PVwiW29iamVjdCBJbnQzMkFycmF5XVwiP2krPU1lOnI9PT1cIltvYmplY3QgVWludDMyQXJyYXldXCI/aSs9VWU6cj09PVwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI/aSs9WWU6cj09PVwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI/aSs9emU6dChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHR5cGUgZm9yIEJpbmFyeUFycmF5XCIpKSksdChpK3dlKG8pKX1lbHNlIGlmKHI9PT1cIltvYmplY3QgQmxvYl1cIil7dmFyIG49bmV3IEZpbGVSZWFkZXI7bi5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgZj1kcitlLnR5cGUrXCJ+XCIrd2UodGhpcy5yZXN1bHQpO3QoaGUrX2UrZil9LG4ucmVhZEFzQXJyYXlCdWZmZXIoZSl9ZWxzZSB0cnl7dChKU09OLnN0cmluZ2lmeShlKSl9Y2F0Y2goZil7Y29uc29sZS5lcnJvcihcIkNvdWxkbid0IGNvbnZlcnQgdmFsdWUgaW50byBhIEpTT04gc3RyaW5nOiBcIixlKSx0KG51bGwsZil9fWZ1bmN0aW9uIGhyKGUpe2lmKGUuc3Vic3RyaW5nKDAsZ2UpIT09aGUpcmV0dXJuIEpTT04ucGFyc2UoZSk7dmFyIHQ9ZS5zdWJzdHJpbmcoV2UpLHI9ZS5zdWJzdHJpbmcoZ2UsV2UpLG87aWYocj09PV9lJiZ4ZS50ZXN0KHQpKXt2YXIgaT10Lm1hdGNoKHhlKTtvPWlbMV0sdD10LnN1YnN0cmluZyhpWzBdLmxlbmd0aCl9dmFyIG49SGUodCk7c3dpdGNoKHIpe2Nhc2UgYmU6cmV0dXJuIG47Y2FzZSBfZTpyZXR1cm4gWihbbl0se3R5cGU6b30pO2Nhc2UgT2U6cmV0dXJuIG5ldyBJbnQ4QXJyYXkobik7Y2FzZSBDZTpyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobik7Y2FzZSBMZTpyZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG4pO2Nhc2UgUGU6cmV0dXJuIG5ldyBJbnQxNkFycmF5KG4pO2Nhc2UgRmU6cmV0dXJuIG5ldyBVaW50MTZBcnJheShuKTtjYXNlIE1lOnJldHVybiBuZXcgSW50MzJBcnJheShuKTtjYXNlIFVlOnJldHVybiBuZXcgVWludDMyQXJyYXkobik7Y2FzZSBZZTpyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShuKTtjYXNlIHplOnJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG4pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rb3duIHR5cGU6IFwiK3IpfX12YXIgRWU9e3NlcmlhbGl6ZTp2cixkZXNlcmlhbGl6ZTpocixzdHJpbmdUb0J1ZmZlcjpIZSxidWZmZXJUb1N0cmluZzp3ZX07ZnVuY3Rpb24gVmUoZSx0LHIsbyl7ZS5leGVjdXRlU3FsKFwiQ1JFQVRFIFRBQkxFIElGIE5PVCBFWElTVFMgXCIrdC5zdG9yZU5hbWUrXCIgKGlkIElOVEVHRVIgUFJJTUFSWSBLRVksIGtleSB1bmlxdWUsIHZhbHVlKVwiLFtdLHIsbyl9ZnVuY3Rpb24gbXIoZSl7dmFyIHQ9dGhpcyxyPXtkYjpudWxsfTtpZihlKWZvcih2YXIgbyBpbiBlKXJbb109dHlwZW9mIGVbb10hPVwic3RyaW5nXCI/ZVtvXS50b1N0cmluZygpOmVbb107dmFyIGk9bmV3IG0oZnVuY3Rpb24obixmKXt0cnl7ci5kYj1vcGVuRGF0YWJhc2Uoci5uYW1lLFN0cmluZyhyLnZlcnNpb24pLHIuZGVzY3JpcHRpb24sci5zaXplKX1jYXRjaCh1KXtyZXR1cm4gZih1KX1yLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKHUpe1ZlKHUscixmdW5jdGlvbigpe3QuX2RiSW5mbz1yLG4oKX0sZnVuY3Rpb24oYyxsKXtmKGwpfSl9LGYpfSk7cmV0dXJuIHIuc2VyaWFsaXplcj1FZSxpfWZ1bmN0aW9uIG5lKGUsdCxyLG8saSxuKXtlLmV4ZWN1dGVTcWwocixvLGksZnVuY3Rpb24oZix1KXt1LmNvZGU9PT11LlNZTlRBWF9FUlI/Zi5leGVjdXRlU3FsKFwiU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZSA9ID9cIixbdC5zdG9yZU5hbWVdLGZ1bmN0aW9uKGMsbCl7bC5yb3dzLmxlbmd0aD9uKGMsdSk6VmUoYyx0LGZ1bmN0aW9uKCl7Yy5leGVjdXRlU3FsKHIsbyxpLG4pfSxuKX0sbik6bihmLHUpfSxuKX1mdW5jdGlvbiB5cihlLHQpe3ZhciByPXRoaXM7ZT16KGUpO3ZhciBvPW5ldyBtKGZ1bmN0aW9uKGksbil7ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZj1yLl9kYkluZm87Zi5kYi50cmFuc2FjdGlvbihmdW5jdGlvbih1KXtuZSh1LGYsXCJTRUxFQ1QgKiBGUk9NIFwiK2Yuc3RvcmVOYW1lK1wiIFdIRVJFIGtleSA9ID8gTElNSVQgMVwiLFtlXSxmdW5jdGlvbihjLGwpe3ZhciBkPWwucm93cy5sZW5ndGg/bC5yb3dzLml0ZW0oMCkudmFsdWU6bnVsbDtkJiYoZD1mLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoZCkpLGkoZCl9LGZ1bmN0aW9uKGMsbCl7bihsKX0pfSl9KS5jYXRjaChuKX0pO3JldHVybiB3KG8sdCksb31mdW5jdGlvbiBwcihlLHQpe3ZhciByPXRoaXMsbz1uZXcgbShmdW5jdGlvbihpLG4pe3IucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGY9ci5fZGJJbmZvO2YuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odSl7bmUodSxmLFwiU0VMRUNUICogRlJPTSBcIitmLnN0b3JlTmFtZSxbXSxmdW5jdGlvbihjLGwpe2Zvcih2YXIgZD1sLnJvd3MseT1kLmxlbmd0aCxBPTA7QTx5O0ErKyl7dmFyIFQ9ZC5pdGVtKEEpLHg9VC52YWx1ZTtpZih4JiYoeD1mLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoeCkpLHg9ZSh4LFQua2V5LEErMSkseCE9PXZvaWQgMCl7aSh4KTtyZXR1cm59fWkoKX0sZnVuY3Rpb24oYyxsKXtuKGwpfSl9KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIEdlKGUsdCxyLG8pe3ZhciBpPXRoaXM7ZT16KGUpO3ZhciBuPW5ldyBtKGZ1bmN0aW9uKGYsdSl7aS5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt0PT09dm9pZCAwJiYodD1udWxsKTt2YXIgYz10LGw9aS5fZGJJbmZvO2wuc2VyaWFsaXplci5zZXJpYWxpemUodCxmdW5jdGlvbihkLHkpe3k/dSh5KTpsLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKEEpe25lKEEsbCxcIklOU0VSVCBPUiBSRVBMQUNFIElOVE8gXCIrbC5zdG9yZU5hbWUrXCIgKGtleSwgdmFsdWUpIFZBTFVFUyAoPywgPylcIixbZSxkXSxmdW5jdGlvbigpe2YoYyl9LGZ1bmN0aW9uKFQseCl7dSh4KX0pfSxmdW5jdGlvbihBKXtpZihBLmNvZGU9PT1BLlFVT1RBX0VSUil7aWYobz4wKXtmKEdlLmFwcGx5KGksW2UsYyxyLG8tMV0pKTtyZXR1cm59dShBKX19KX0pfSkuY2F0Y2godSl9KTtyZXR1cm4gdyhuLHIpLG59ZnVuY3Rpb24gZ3IoZSx0LHIpe3JldHVybiBHZS5hcHBseSh0aGlzLFtlLHQsciwxXSl9ZnVuY3Rpb24gYnIoZSx0KXt2YXIgcj10aGlzO2U9eihlKTt2YXIgbz1uZXcgbShmdW5jdGlvbihpLG4pe3IucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGY9ci5fZGJJbmZvO2YuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odSl7bmUodSxmLFwiREVMRVRFIEZST00gXCIrZi5zdG9yZU5hbWUrXCIgV0hFUkUga2V5ID0gP1wiLFtlXSxmdW5jdGlvbigpe2koKX0sZnVuY3Rpb24oYyxsKXtuKGwpfSl9KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIF9yKGUpe3ZhciB0PXRoaXMscj1uZXcgbShmdW5jdGlvbihvLGkpe3QucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIG49dC5fZGJJbmZvO24uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24oZil7bmUoZixuLFwiREVMRVRFIEZST00gXCIrbi5zdG9yZU5hbWUsW10sZnVuY3Rpb24oKXtvKCl9LGZ1bmN0aW9uKHUsYyl7aShjKX0pfSl9KS5jYXRjaChpKX0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiB3cihlKXt2YXIgdD10aGlzLHI9bmV3IG0oZnVuY3Rpb24obyxpKXt0LnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBuPXQuX2RiSW5mbztuLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKGYpe25lKGYsbixcIlNFTEVDVCBDT1VOVChrZXkpIGFzIGMgRlJPTSBcIituLnN0b3JlTmFtZSxbXSxmdW5jdGlvbih1LGMpe3ZhciBsPWMucm93cy5pdGVtKDApLmM7byhsKX0sZnVuY3Rpb24odSxjKXtpKGMpfSl9KX0pLmNhdGNoKGkpfSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIEVyKGUsdCl7dmFyIHI9dGhpcyxvPW5ldyBtKGZ1bmN0aW9uKGksbil7ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZj1yLl9kYkluZm87Zi5kYi50cmFuc2FjdGlvbihmdW5jdGlvbih1KXtuZSh1LGYsXCJTRUxFQ1Qga2V5IEZST00gXCIrZi5zdG9yZU5hbWUrXCIgV0hFUkUgaWQgPSA/IExJTUlUIDFcIixbZSsxXSxmdW5jdGlvbihjLGwpe3ZhciBkPWwucm93cy5sZW5ndGg/bC5yb3dzLml0ZW0oMCkua2V5Om51bGw7aShkKX0sZnVuY3Rpb24oYyxsKXtuKGwpfSl9KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIElyKGUpe3ZhciB0PXRoaXMscj1uZXcgbShmdW5jdGlvbihvLGkpe3QucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIG49dC5fZGJJbmZvO24uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24oZil7bmUoZixuLFwiU0VMRUNUIGtleSBGUk9NIFwiK24uc3RvcmVOYW1lLFtdLGZ1bmN0aW9uKHUsYyl7Zm9yKHZhciBsPVtdLGQ9MDtkPGMucm93cy5sZW5ndGg7ZCsrKWwucHVzaChjLnJvd3MuaXRlbShkKS5rZXkpO28obCl9LGZ1bmN0aW9uKHUsYyl7aShjKX0pfSl9KS5jYXRjaChpKX0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiBTcihlKXtyZXR1cm4gbmV3IG0oZnVuY3Rpb24odCxyKXtlLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKG8pe28uZXhlY3V0ZVNxbChcIlNFTEVDVCBuYW1lIEZST00gc3FsaXRlX21hc3RlciBXSEVSRSB0eXBlPSd0YWJsZScgQU5EIG5hbWUgPD4gJ19fV2ViS2l0RGF0YWJhc2VJbmZvVGFibGVfXydcIixbXSxmdW5jdGlvbihpLG4pe2Zvcih2YXIgZj1bXSx1PTA7dTxuLnJvd3MubGVuZ3RoO3UrKylmLnB1c2gobi5yb3dzLml0ZW0odSkubmFtZSk7dCh7ZGI6ZSxzdG9yZU5hbWVzOmZ9KX0sZnVuY3Rpb24oaSxuKXtyKG4pfSl9LGZ1bmN0aW9uKG8pe3Iobyl9KX0pfWZ1bmN0aW9uIEFyKGUsdCl7dD1xLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgcj10aGlzLmNvbmZpZygpO2U9dHlwZW9mIGUhPVwiZnVuY3Rpb25cIiYmZXx8e30sZS5uYW1lfHwoZS5uYW1lPWUubmFtZXx8ci5uYW1lLGUuc3RvcmVOYW1lPWUuc3RvcmVOYW1lfHxyLnN0b3JlTmFtZSk7dmFyIG89dGhpcyxpO3JldHVybiBlLm5hbWU/aT1uZXcgbShmdW5jdGlvbihuKXt2YXIgZjtlLm5hbWU9PT1yLm5hbWU/Zj1vLl9kYkluZm8uZGI6Zj1vcGVuRGF0YWJhc2UoZS5uYW1lLFwiXCIsXCJcIiwwKSxlLnN0b3JlTmFtZT9uKHtkYjpmLHN0b3JlTmFtZXM6W2Uuc3RvcmVOYW1lXX0pOm4oU3IoZikpfSkudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gbmV3IG0oZnVuY3Rpb24oZix1KXtuLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGwoVCl7cmV0dXJuIG5ldyBtKGZ1bmN0aW9uKHgsVil7Yy5leGVjdXRlU3FsKFwiRFJPUCBUQUJMRSBJRiBFWElTVFMgXCIrVCxbXSxmdW5jdGlvbigpe3goKX0sZnVuY3Rpb24oVyxYKXtWKFgpfSl9KX1mb3IodmFyIGQ9W10seT0wLEE9bi5zdG9yZU5hbWVzLmxlbmd0aDt5PEE7eSsrKWQucHVzaChsKG4uc3RvcmVOYW1lc1t5XSkpO20uYWxsKGQpLnRoZW4oZnVuY3Rpb24oKXtmKCl9KS5jYXRjaChmdW5jdGlvbihUKXt1KFQpfSl9LGZ1bmN0aW9uKGMpe3UoYyl9KX0pfSk6aT1tLnJlamVjdChcIkludmFsaWQgYXJndW1lbnRzXCIpLHcoaSx0KSxpfXZhciBScj17X2RyaXZlcjpcIndlYlNRTFN0b3JhZ2VcIixfaW5pdFN0b3JhZ2U6bXIsX3N1cHBvcnQ6bHIoKSxpdGVyYXRlOnByLGdldEl0ZW06eXIsc2V0SXRlbTpncixyZW1vdmVJdGVtOmJyLGNsZWFyOl9yLGxlbmd0aDp3cixrZXk6RXIsa2V5czpJcixkcm9wSW5zdGFuY2U6QXJ9O2Z1bmN0aW9uIERyKCl7dHJ5e3JldHVybiB0eXBlb2YgbG9jYWxTdG9yYWdlIT1cInVuZGVmaW5lZFwiJiZcInNldEl0ZW1cImluIGxvY2FsU3RvcmFnZSYmISFsb2NhbFN0b3JhZ2Uuc2V0SXRlbX1jYXRjaHtyZXR1cm4hMX19ZnVuY3Rpb24gamUoZSx0KXt2YXIgcj1lLm5hbWUrXCIvXCI7cmV0dXJuIGUuc3RvcmVOYW1lIT09dC5zdG9yZU5hbWUmJihyKz1lLnN0b3JlTmFtZStcIi9cIikscn1mdW5jdGlvbiBOcigpe3ZhciBlPVwiX2xvY2FsZm9yYWdlX3N1cHBvcnRfdGVzdFwiO3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oZSwhMCksbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZSksITF9Y2F0Y2h7cmV0dXJuITB9fWZ1bmN0aW9uIFRyKCl7cmV0dXJuIU5yKCl8fGxvY2FsU3RvcmFnZS5sZW5ndGg+MH1mdW5jdGlvbiBCcihlKXt2YXIgdD10aGlzLHI9e307aWYoZSlmb3IodmFyIG8gaW4gZSlyW29dPWVbb107cmV0dXJuIHIua2V5UHJlZml4PWplKGUsdC5fZGVmYXVsdENvbmZpZyksVHIoKT8odC5fZGJJbmZvPXIsci5zZXJpYWxpemVyPUVlLG0ucmVzb2x2ZSgpKTptLnJlamVjdCgpfWZ1bmN0aW9uIHhyKGUpe3ZhciB0PXRoaXMscj10LnJlYWR5KCkudGhlbihmdW5jdGlvbigpe2Zvcih2YXIgbz10Ll9kYkluZm8ua2V5UHJlZml4LGk9bG9jYWxTdG9yYWdlLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgbj1sb2NhbFN0b3JhZ2Uua2V5KGkpO24uaW5kZXhPZihvKT09PTAmJmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKG4pfX0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiBPcihlLHQpe3ZhciByPXRoaXM7ZT16KGUpO3ZhciBvPXIucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGk9ci5fZGJJbmZvLG49bG9jYWxTdG9yYWdlLmdldEl0ZW0oaS5rZXlQcmVmaXgrZSk7cmV0dXJuIG4mJihuPWkuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShuKSksbn0pO3JldHVybiB3KG8sdCksb31mdW5jdGlvbiBDcihlLHQpe3ZhciByPXRoaXMsbz1yLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe2Zvcih2YXIgaT1yLl9kYkluZm8sbj1pLmtleVByZWZpeCxmPW4ubGVuZ3RoLHU9bG9jYWxTdG9yYWdlLmxlbmd0aCxjPTEsbD0wO2w8dTtsKyspe3ZhciBkPWxvY2FsU3RvcmFnZS5rZXkobCk7aWYoZC5pbmRleE9mKG4pPT09MCl7dmFyIHk9bG9jYWxTdG9yYWdlLmdldEl0ZW0oZCk7aWYoeSYmKHk9aS5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHkpKSx5PWUoeSxkLnN1YnN0cmluZyhmKSxjKyspLHkhPT12b2lkIDApcmV0dXJuIHl9fX0pO3JldHVybiB3KG8sdCksb31mdW5jdGlvbiBMcihlLHQpe3ZhciByPXRoaXMsbz1yLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBpPXIuX2RiSW5mbyxuO3RyeXtuPWxvY2FsU3RvcmFnZS5rZXkoZSl9Y2F0Y2h7bj1udWxsfXJldHVybiBuJiYobj1uLnN1YnN0cmluZyhpLmtleVByZWZpeC5sZW5ndGgpKSxufSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIFByKGUpe3ZhciB0PXRoaXMscj10LnJlYWR5KCkudGhlbihmdW5jdGlvbigpe2Zvcih2YXIgbz10Ll9kYkluZm8saT1sb2NhbFN0b3JhZ2UubGVuZ3RoLG49W10sZj0wO2Y8aTtmKyspe3ZhciB1PWxvY2FsU3RvcmFnZS5rZXkoZik7dS5pbmRleE9mKG8ua2V5UHJlZml4KT09PTAmJm4ucHVzaCh1LnN1YnN0cmluZyhvLmtleVByZWZpeC5sZW5ndGgpKX1yZXR1cm4gbn0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiBNcihlKXt2YXIgdD10aGlzLHI9dC5rZXlzKCkudGhlbihmdW5jdGlvbihvKXtyZXR1cm4gby5sZW5ndGh9KTtyZXR1cm4gdyhyLGUpLHJ9ZnVuY3Rpb24gRnIoZSx0KXt2YXIgcj10aGlzO2U9eihlKTt2YXIgbz1yLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBpPXIuX2RiSW5mbztsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShpLmtleVByZWZpeCtlKX0pO3JldHVybiB3KG8sdCksb31mdW5jdGlvbiBVcihlLHQscil7dmFyIG89dGhpcztlPXooZSk7dmFyIGk9by5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt0PT09dm9pZCAwJiYodD1udWxsKTt2YXIgbj10O3JldHVybiBuZXcgbShmdW5jdGlvbihmLHUpe3ZhciBjPW8uX2RiSW5mbztjLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHQsZnVuY3Rpb24obCxkKXtpZihkKXUoZCk7ZWxzZSB0cnl7bG9jYWxTdG9yYWdlLnNldEl0ZW0oYy5rZXlQcmVmaXgrZSxsKSxmKG4pfWNhdGNoKHkpeyh5Lm5hbWU9PT1cIlF1b3RhRXhjZWVkZWRFcnJvclwifHx5Lm5hbWU9PT1cIk5TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEXCIpJiZ1KHkpLHUoeSl9fSl9KX0pO3JldHVybiB3KGksciksaX1mdW5jdGlvbiBZcihlLHQpe2lmKHQ9cS5hcHBseSh0aGlzLGFyZ3VtZW50cyksZT10eXBlb2YgZSE9XCJmdW5jdGlvblwiJiZlfHx7fSwhZS5uYW1lKXt2YXIgcj10aGlzLmNvbmZpZygpO2UubmFtZT1lLm5hbWV8fHIubmFtZSxlLnN0b3JlTmFtZT1lLnN0b3JlTmFtZXx8ci5zdG9yZU5hbWV9dmFyIG89dGhpcyxpO3JldHVybiBlLm5hbWU/aT1uZXcgbShmdW5jdGlvbihuKXtlLnN0b3JlTmFtZT9uKGplKGUsby5fZGVmYXVsdENvbmZpZykpOm4oZS5uYW1lK1wiL1wiKX0pLnRoZW4oZnVuY3Rpb24obil7Zm9yKHZhciBmPWxvY2FsU3RvcmFnZS5sZW5ndGgtMTtmPj0wO2YtLSl7dmFyIHU9bG9jYWxTdG9yYWdlLmtleShmKTt1LmluZGV4T2Yobik9PT0wJiZsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh1KX19KTppPW0ucmVqZWN0KFwiSW52YWxpZCBhcmd1bWVudHNcIiksdyhpLHQpLGl9dmFyIHpyPXtfZHJpdmVyOlwibG9jYWxTdG9yYWdlV3JhcHBlclwiLF9pbml0U3RvcmFnZTpCcixfc3VwcG9ydDpEcigpLGl0ZXJhdGU6Q3IsZ2V0SXRlbTpPcixzZXRJdGVtOlVyLHJlbW92ZUl0ZW06RnIsY2xlYXI6eHIsbGVuZ3RoOk1yLGtleTpMcixrZXlzOlByLGRyb3BJbnN0YW5jZTpZcn0sV3I9ZnVuY3Rpb24odCxyKXtyZXR1cm4gdD09PXJ8fHR5cGVvZiB0PT1cIm51bWJlclwiJiZ0eXBlb2Ygcj09XCJudW1iZXJcIiYmaXNOYU4odCkmJmlzTmFOKHIpfSxLcj1mdW5jdGlvbih0LHIpe2Zvcih2YXIgbz10Lmxlbmd0aCxpPTA7aTxvOyl7aWYoV3IodFtpXSxyKSlyZXR1cm4hMDtpKyt9cmV0dXJuITF9LFhlPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSk9PT1cIltvYmplY3QgQXJyYXldXCJ9LGxlPXt9LFFlPXt9LHVlPXtJTkRFWEVEREI6Y3IsV0VCU1FMOlJyLExPQ0FMU1RPUkFHRTp6cn0sSHI9W3VlLklOREVYRUREQi5fZHJpdmVyLHVlLldFQlNRTC5fZHJpdmVyLHVlLkxPQ0FMU1RPUkFHRS5fZHJpdmVyXSxtZT1bXCJkcm9wSW5zdGFuY2VcIl0sSWU9W1wiY2xlYXJcIixcImdldEl0ZW1cIixcIml0ZXJhdGVcIixcImtleVwiLFwia2V5c1wiLFwibGVuZ3RoXCIsXCJyZW1vdmVJdGVtXCIsXCJzZXRJdGVtXCJdLmNvbmNhdChtZSksVnI9e2Rlc2NyaXB0aW9uOlwiXCIsZHJpdmVyOkhyLnNsaWNlKCksbmFtZTpcImxvY2FsZm9yYWdlXCIsc2l6ZTo0OTgwNzM2LHN0b3JlTmFtZTpcImtleXZhbHVlcGFpcnNcIix2ZXJzaW9uOjF9O2Z1bmN0aW9uIEdyKGUsdCl7ZVt0XT1mdW5jdGlvbigpe3ZhciByPWFyZ3VtZW50cztyZXR1cm4gZS5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZVt0XS5hcHBseShlLHIpfSl9fWZ1bmN0aW9uIFNlKCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHQ9YXJndW1lbnRzW2VdO2lmKHQpZm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKFhlKHRbcl0pP2FyZ3VtZW50c1swXVtyXT10W3JdLnNsaWNlKCk6YXJndW1lbnRzWzBdW3JdPXRbcl0pfXJldHVybiBhcmd1bWVudHNbMF19dmFyIGpyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtZKHRoaXMsZSk7Zm9yKHZhciByIGluIHVlKWlmKHVlLmhhc093blByb3BlcnR5KHIpKXt2YXIgbz11ZVtyXSxpPW8uX2RyaXZlcjt0aGlzW3JdPWksbGVbaV18fHRoaXMuZGVmaW5lRHJpdmVyKG8pfXRoaXMuX2RlZmF1bHRDb25maWc9U2Uoe30sVnIpLHRoaXMuX2NvbmZpZz1TZSh7fSx0aGlzLl9kZWZhdWx0Q29uZmlnLHQpLHRoaXMuX2RyaXZlclNldD1udWxsLHRoaXMuX2luaXREcml2ZXI9bnVsbCx0aGlzLl9yZWFkeT0hMSx0aGlzLl9kYkluZm89bnVsbCx0aGlzLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKSx0aGlzLnNldERyaXZlcih0aGlzLl9jb25maWcuZHJpdmVyKS5jYXRjaChmdW5jdGlvbigpe30pfXJldHVybiBlLnByb3RvdHlwZS5jb25maWc9ZnVuY3Rpb24ocil7aWYoKHR5cGVvZiByPT1cInVuZGVmaW5lZFwiP1widW5kZWZpbmVkXCI6QyhyKSk9PT1cIm9iamVjdFwiKXtpZih0aGlzLl9yZWFkeSlyZXR1cm4gbmV3IEVycm9yKFwiQ2FuJ3QgY2FsbCBjb25maWcoKSBhZnRlciBsb2NhbGZvcmFnZSBoYXMgYmVlbiB1c2VkLlwiKTtmb3IodmFyIG8gaW4gcil7aWYobz09PVwic3RvcmVOYW1lXCImJihyW29dPXJbb10ucmVwbGFjZSgvXFxXL2csXCJfXCIpKSxvPT09XCJ2ZXJzaW9uXCImJnR5cGVvZiByW29dIT1cIm51bWJlclwiKXJldHVybiBuZXcgRXJyb3IoXCJEYXRhYmFzZSB2ZXJzaW9uIG11c3QgYmUgYSBudW1iZXIuXCIpO3RoaXMuX2NvbmZpZ1tvXT1yW29dfXJldHVyblwiZHJpdmVyXCJpbiByJiZyLmRyaXZlcj90aGlzLnNldERyaXZlcih0aGlzLl9jb25maWcuZHJpdmVyKTohMH1lbHNlIHJldHVybiB0eXBlb2Ygcj09XCJzdHJpbmdcIj90aGlzLl9jb25maWdbcl06dGhpcy5fY29uZmlnfSxlLnByb3RvdHlwZS5kZWZpbmVEcml2ZXI9ZnVuY3Rpb24ocixvLGkpe3ZhciBuPW5ldyBtKGZ1bmN0aW9uKGYsdSl7dHJ5e3ZhciBjPXIuX2RyaXZlcixsPW5ldyBFcnJvcihcIkN1c3RvbSBkcml2ZXIgbm90IGNvbXBsaWFudDsgc2VlIGh0dHBzOi8vbW96aWxsYS5naXRodWIuaW8vbG9jYWxGb3JhZ2UvI2RlZmluZWRyaXZlclwiKTtpZighci5fZHJpdmVyKXt1KGwpO3JldHVybn1mb3IodmFyIGQ9SWUuY29uY2F0KFwiX2luaXRTdG9yYWdlXCIpLHk9MCxBPWQubGVuZ3RoO3k8QTt5Kyspe3ZhciBUPWRbeV0seD0hS3IobWUsVCk7aWYoKHh8fHJbVF0pJiZ0eXBlb2YgcltUXSE9XCJmdW5jdGlvblwiKXt1KGwpO3JldHVybn19dmFyIFY9ZnVuY3Rpb24oKXtmb3IodmFyIGRlPWZ1bmN0aW9uKEpyKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgJHI9bmV3IEVycm9yKFwiTWV0aG9kIFwiK0pyK1wiIGlzIG5vdCBpbXBsZW1lbnRlZCBieSB0aGUgY3VycmVudCBkcml2ZXJcIiksSmU9bS5yZWplY3QoJHIpO3JldHVybiB3KEplLGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdKSxKZX19LEFlPTAsUXI9bWUubGVuZ3RoO0FlPFFyO0FlKyspe3ZhciBSZT1tZVtBZV07cltSZV18fChyW1JlXT1kZShSZSkpfX07VigpO3ZhciBXPWZ1bmN0aW9uKGRlKXtsZVtjXSYmY29uc29sZS5pbmZvKFwiUmVkZWZpbmluZyBMb2NhbEZvcmFnZSBkcml2ZXI6IFwiK2MpLGxlW2NdPXIsUWVbY109ZGUsZigpfTtcIl9zdXBwb3J0XCJpbiByP3IuX3N1cHBvcnQmJnR5cGVvZiByLl9zdXBwb3J0PT1cImZ1bmN0aW9uXCI/ci5fc3VwcG9ydCgpLnRoZW4oVyx1KTpXKCEhci5fc3VwcG9ydCk6VyghMCl9Y2F0Y2goWCl7dShYKX19KTtyZXR1cm4gTihuLG8saSksbn0sZS5wcm90b3R5cGUuZHJpdmVyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RyaXZlcnx8bnVsbH0sZS5wcm90b3R5cGUuZ2V0RHJpdmVyPWZ1bmN0aW9uKHIsbyxpKXt2YXIgbj1sZVtyXT9tLnJlc29sdmUobGVbcl0pOm0ucmVqZWN0KG5ldyBFcnJvcihcIkRyaXZlciBub3QgZm91bmQuXCIpKTtyZXR1cm4gTihuLG8saSksbn0sZS5wcm90b3R5cGUuZ2V0U2VyaWFsaXplcj1mdW5jdGlvbihyKXt2YXIgbz1tLnJlc29sdmUoRWUpO3JldHVybiBOKG8sciksb30sZS5wcm90b3R5cGUucmVhZHk9ZnVuY3Rpb24ocil7dmFyIG89dGhpcyxpPW8uX2RyaXZlclNldC50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG8uX3JlYWR5PT09bnVsbCYmKG8uX3JlYWR5PW8uX2luaXREcml2ZXIoKSksby5fcmVhZHl9KTtyZXR1cm4gTihpLHIsciksaX0sZS5wcm90b3R5cGUuc2V0RHJpdmVyPWZ1bmN0aW9uKHIsbyxpKXt2YXIgbj10aGlzO1hlKHIpfHwocj1bcl0pO3ZhciBmPXRoaXMuX2dldFN1cHBvcnRlZERyaXZlcnMocik7ZnVuY3Rpb24gdSgpe24uX2NvbmZpZy5kcml2ZXI9bi5kcml2ZXIoKX1mdW5jdGlvbiBjKHkpe3JldHVybiBuLl9leHRlbmQoeSksdSgpLG4uX3JlYWR5PW4uX2luaXRTdG9yYWdlKG4uX2NvbmZpZyksbi5fcmVhZHl9ZnVuY3Rpb24gbCh5KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgQT0wO2Z1bmN0aW9uIFQoKXtmb3IoO0E8eS5sZW5ndGg7KXt2YXIgeD15W0FdO3JldHVybiBBKyssbi5fZGJJbmZvPW51bGwsbi5fcmVhZHk9bnVsbCxuLmdldERyaXZlcih4KS50aGVuKGMpLmNhdGNoKFQpfXUoKTt2YXIgVj1uZXcgRXJyb3IoXCJObyBhdmFpbGFibGUgc3RvcmFnZSBtZXRob2QgZm91bmQuXCIpO3JldHVybiBuLl9kcml2ZXJTZXQ9bS5yZWplY3QoViksbi5fZHJpdmVyU2V0fXJldHVybiBUKCl9fXZhciBkPXRoaXMuX2RyaXZlclNldCE9PW51bGw/dGhpcy5fZHJpdmVyU2V0LmNhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIG0ucmVzb2x2ZSgpfSk6bS5yZXNvbHZlKCk7cmV0dXJuIHRoaXMuX2RyaXZlclNldD1kLnRoZW4oZnVuY3Rpb24oKXt2YXIgeT1mWzBdO3JldHVybiBuLl9kYkluZm89bnVsbCxuLl9yZWFkeT1udWxsLG4uZ2V0RHJpdmVyKHkpLnRoZW4oZnVuY3Rpb24oQSl7bi5fZHJpdmVyPUEuX2RyaXZlcix1KCksbi5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCksbi5faW5pdERyaXZlcj1sKGYpfSl9KS5jYXRjaChmdW5jdGlvbigpe3UoKTt2YXIgeT1uZXcgRXJyb3IoXCJObyBhdmFpbGFibGUgc3RvcmFnZSBtZXRob2QgZm91bmQuXCIpO3JldHVybiBuLl9kcml2ZXJTZXQ9bS5yZWplY3QoeSksbi5fZHJpdmVyU2V0fSksTih0aGlzLl9kcml2ZXJTZXQsbyxpKSx0aGlzLl9kcml2ZXJTZXR9LGUucHJvdG90eXBlLnN1cHBvcnRzPWZ1bmN0aW9uKHIpe3JldHVybiEhUWVbcl19LGUucHJvdG90eXBlLl9leHRlbmQ9ZnVuY3Rpb24ocil7U2UodGhpcyxyKX0sZS5wcm90b3R5cGUuX2dldFN1cHBvcnRlZERyaXZlcnM9ZnVuY3Rpb24ocil7Zm9yKHZhciBvPVtdLGk9MCxuPXIubGVuZ3RoO2k8bjtpKyspe3ZhciBmPXJbaV07dGhpcy5zdXBwb3J0cyhmKSYmby5wdXNoKGYpfXJldHVybiBvfSxlLnByb3RvdHlwZS5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5PWZ1bmN0aW9uKCl7Zm9yKHZhciByPTAsbz1JZS5sZW5ndGg7cjxvO3IrKylHcih0aGlzLEllW3JdKX0sZS5wcm90b3R5cGUuY3JlYXRlSW5zdGFuY2U9ZnVuY3Rpb24ocil7cmV0dXJuIG5ldyBlKHIpfSxlfSgpLFhyPW5ldyBqcjtNLmV4cG9ydHM9WHJ9LHtcIjNcIjozfV19LHt9LFs0XSkoNCl9KX0pO3ZhciBycj0kZSgoeWUsZXIpPT57KGZ1bmN0aW9uKHAsZyl7dHlwZW9mIHllPT1cIm9iamVjdFwiJiZ0eXBlb2YgZXIhPVwidW5kZWZpbmVkXCI/Zyh5ZSk6dHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kP2RlZmluZShcImxvY2FsZm9yYWdlLWRyaXZlci1tZW1vcnlcIixbXCJleHBvcnRzXCJdLGcpOmcocC5Mb2NhbGZvcmFnZURyaXZlck1lbW9yeT17fSl9KSh0eXBlb2Ygc2VsZiE9XCJ1bmRlZmluZWRcIj9zZWxmOnllLGZ1bmN0aW9uKHApe1widXNlIHN0cmljdFwiO3ZhciBnPVwibG9jYWxmb3JhZ2UtZHJpdmVyLW1lbW9yeVwiO2Z1bmN0aW9uIE8oYSl7dmFyIHM9dHlwZW9mIFN5bWJvbD09XCJmdW5jdGlvblwiJiZhW1N5bWJvbC5pdGVyYXRvcl0sdj0wO3JldHVybiBzP3MuY2FsbChhKTp7bmV4dDpmdW5jdGlvbigpe3JldHVybiBhJiZ2Pj1hLmxlbmd0aCYmKGE9dm9pZCAwKSx7dmFsdWU6YSYmYVt2KytdLGRvbmU6IWF9fX19ZnVuY3Rpb24gTChhLHMpe2E9YXx8W10scz1zfHx7fTt0cnl7cmV0dXJuIG5ldyBCbG9iKGEscyl9Y2F0Y2goRSl7aWYoRS5uYW1lIT09XCJUeXBlRXJyb3JcIil0aHJvdyBFO2Zvcih2YXIgdj10eXBlb2YgQmxvYkJ1aWxkZXIhPVwidW5kZWZpbmVkXCI/QmxvYkJ1aWxkZXI6dHlwZW9mIE1TQmxvYkJ1aWxkZXIhPVwidW5kZWZpbmVkXCI/TVNCbG9iQnVpbGRlcjp0eXBlb2YgTW96QmxvYkJ1aWxkZXIhPVwidW5kZWZpbmVkXCI/TW96QmxvYkJ1aWxkZXI6V2ViS2l0QmxvYkJ1aWxkZXIsYj1uZXcgdixfPTA7XzxhLmxlbmd0aDtfKz0xKWIuYXBwZW5kKGFbX10pO3JldHVybiBiLmdldEJsb2Iocy50eXBlKX19dmFyIE09L15+fmxvY2FsX2ZvcmFnZV90eXBlfihbXn5dKyl+LyxRPVwiX19sZnNjX186XCIubGVuZ3RoLEM9UStcImFyYmZcIi5sZW5ndGgsWT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2Z1bmN0aW9uIFMoYSl7dmFyIHM9YS5sZW5ndGgqLjc1LHY9YS5sZW5ndGg7YVthLmxlbmd0aC0xXT09PVwiPVwiJiYocy0tLGFbYS5sZW5ndGgtMl09PT1cIj1cIiYmcy0tKTtmb3IodmFyIGI9bmV3IEFycmF5QnVmZmVyKHMpLF89bmV3IFVpbnQ4QXJyYXkoYiksRT0wLEQ9MDtFPHY7RSs9NCl7dmFyIEc9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuaW5kZXhPZihhW0VdKSxmZT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5pbmRleE9mKGFbRSsxXSksaWU9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuaW5kZXhPZihhW0UrMl0pLGNlPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLmluZGV4T2YoYVtFKzNdKTtfW0QrK109Rzw8MnxmZT4+NCxfW0QrK109KGZlJjE1KTw8NHxpZT4+MixfW0QrK109KGllJjMpPDw2fGNlJjYzfXJldHVybiBifWZ1bmN0aW9uIFAoYSl7Zm9yKHZhciBzPW5ldyBVaW50OEFycmF5KGEpLHY9XCJcIixiPTA7YjxzLmxlbmd0aDtiKz0zKXYrPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiW3NbYl0+PjJdLHYrPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiWyhzW2JdJjMpPDw0fHNbYisxXT4+NF0sdis9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCJbKHNbYisxXSYxNSk8PDJ8c1tiKzJdPj42XSx2Kz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIltzW2IrMl0mNjNdO3JldHVybiBzLmxlbmd0aCUzPT09Mj92PXYuc3Vic3RyaW5nKDAsdi5sZW5ndGgtMSkrXCI9XCI6cy5sZW5ndGglMz09PTEmJih2PXYuc3Vic3RyaW5nKDAsdi5sZW5ndGgtMikrXCI9PVwiKSx2fWZ1bmN0aW9uIEsoYSxzKXt2YXIgdj1cIlwiO2lmKGEmJih2PVkuY2FsbChhKSksYSYmKHY9PT1cIltvYmplY3QgQXJyYXlCdWZmZXJdXCJ8fGEuYnVmZmVyJiZZLmNhbGwoYS5idWZmZXIpPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwiKSl7dmFyIGI9dm9pZCAwLF89XCJfX2xmc2NfXzpcIjthIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/KGI9YSxfKz1cImFyYmZcIik6KGI9YS5idWZmZXIsdj09PVwiW29iamVjdCBJbnQ4QXJyYXldXCI/Xys9XCJzaTA4XCI6dj09PVwiW29iamVjdCBVaW50OEFycmF5XVwiP18rPVwidWkwOFwiOnY9PT1cIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI/Xys9XCJ1aWM4XCI6dj09PVwiW29iamVjdCBJbnQxNkFycmF5XVwiP18rPVwic2kxNlwiOnY9PT1cIltvYmplY3QgVWludDE2QXJyYXldXCI/Xys9XCJ1cjE2XCI6dj09PVwiW29iamVjdCBJbnQzMkFycmF5XVwiP18rPVwic2kzMlwiOnY9PT1cIltvYmplY3QgVWludDMyQXJyYXldXCI/Xys9XCJ1aTMyXCI6dj09PVwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI/Xys9XCJmbDMyXCI6dj09PVwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI/Xys9XCJmbDY0XCI6cyhuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHR5cGUgZm9yIEJpbmFyeUFycmF5XCIpKSkscyhfK1AoYikpfWVsc2UgaWYodj09PVwiW29iamVjdCBCbG9iXVwiKXt2YXIgRT1uZXcgRmlsZVJlYWRlcjtFLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBEPVwifn5sb2NhbF9mb3JhZ2VfdHlwZX5cIithLnR5cGUrXCJ+XCIrUCh0aGlzLnJlc3VsdCk7cyhcIl9fbGZzY19fOmJsb2JcIitEKX0sRS5yZWFkQXNBcnJheUJ1ZmZlcihhKX1lbHNlIHRyeXtzKEpTT04uc3RyaW5naWZ5KGEpKX1jYXRjaChEKXtjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgY29udmVydCB2YWx1ZSBpbnRvIGEgSlNPTiBzdHJpbmc6IFwiLGEpLHMobnVsbCxEKX19ZnVuY3Rpb24gWihhKXtpZihhLnN1YnN0cmluZygwLFEpIT09XCJfX2xmc2NfXzpcIilyZXR1cm4gSlNPTi5wYXJzZShhKTt2YXIgcz1hLnN1YnN0cmluZyhDKSx2PWEuc3Vic3RyaW5nKFEsQyksYjtpZih2PT09XCJibG9iXCImJk0udGVzdChzKSl7dmFyIF89cy5tYXRjaChNKTtiPV9bMV0scz1zLnN1YnN0cmluZyhfWzBdLmxlbmd0aCl9dmFyIEU9UyhzKTtzd2l0Y2godil7Y2FzZVwiYXJiZlwiOnJldHVybiBFO2Nhc2VcImJsb2JcIjpyZXR1cm4gTChbRV0se3R5cGU6Yn0pO2Nhc2VcInNpMDhcIjpyZXR1cm4gbmV3IEludDhBcnJheShFKTtjYXNlXCJ1aTA4XCI6cmV0dXJuIG5ldyBVaW50OEFycmF5KEUpO2Nhc2VcInVpYzhcIjpyZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KEUpO2Nhc2VcInNpMTZcIjpyZXR1cm4gbmV3IEludDE2QXJyYXkoRSk7Y2FzZVwidXIxNlwiOnJldHVybiBuZXcgVWludDE2QXJyYXkoRSk7Y2FzZVwic2kzMlwiOnJldHVybiBuZXcgSW50MzJBcnJheShFKTtjYXNlXCJ1aTMyXCI6cmV0dXJuIG5ldyBVaW50MzJBcnJheShFKTtjYXNlXCJmbDMyXCI6cmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoRSk7Y2FzZVwiZmw2NFwiOnJldHVybiBuZXcgRmxvYXQ2NEFycmF5KEUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5rb3duIHR5cGU6IFwiK3YpfX1mdW5jdGlvbiBtKGEpe3ZhciBzLHY7aWYoYT09PW51bGx8fHR5cGVvZiBhIT1cIm9iamVjdFwifHxcImlzQWN0aXZlQ2xvbmVcImluIGEpcmV0dXJuIGE7dmFyIGI9YSBpbnN0YW5jZW9mIERhdGU/bmV3IERhdGUoYSk6YS5jb25zdHJ1Y3RvcigpO3RyeXtmb3IodmFyIF89TyhPYmplY3Qua2V5cyhhKSksRT1fLm5leHQoKTshRS5kb25lO0U9Xy5uZXh0KCkpe3ZhciBEPUUudmFsdWU7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsRCkmJihhLmlzQWN0aXZlQ2xvbmU9bnVsbCxiW0RdPW0oYVtEXSksZGVsZXRlIGEuaXNBY3RpdmVDbG9uZSl9fWNhdGNoKEcpe3M9e2Vycm9yOkd9fWZpbmFsbHl7dHJ5e0UmJiFFLmRvbmUmJih2PV8ucmV0dXJuKSYmdi5jYWxsKF8pfWZpbmFsbHl7aWYocyl0aHJvdyBzLmVycm9yfX1yZXR1cm4gYn1mdW5jdGlvbiB3KGEscyl7cmV0dXJuKGEubmFtZXx8cy5uYW1lKStcIi9cIisoYS5zdG9yZU5hbWV8fHMuc3RvcmVOYW1lKStcIi9cIn1mdW5jdGlvbiBOKGEscyl7cyYmYS50aGVuKGZ1bmN0aW9uKHYpe3MobnVsbCx2KX0sZnVuY3Rpb24odil7cyh2KX0pfWZ1bmN0aW9uIHooKXtmb3IodmFyIGE9W10scz0wO3M8YXJndW1lbnRzLmxlbmd0aDtzKyspYVtzXT1hcmd1bWVudHNbc107aWYoYXJndW1lbnRzLmxlbmd0aCYmdHlwZW9mIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdPT1cImZ1bmN0aW9uXCIpcmV0dXJuIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdfWZ1bmN0aW9uIHEoYSxzKXt2YXIgdj10aGlzO2lmKHM9ei5hcHBseSh0aGlzLGFyZ3VtZW50cyksYT10eXBlb2YgYSE9XCJmdW5jdGlvblwiJiZhfHx7fSwhYS5uYW1lKXt2YXIgYj10aGlzLmNvbmZpZygpO2EubmFtZT1hLm5hbWV8fGIubmFtZSxhLnN0b3JlTmFtZT1hLnN0b3JlTmFtZXx8Yi5zdG9yZU5hbWV9dmFyIF87cmV0dXJuIGEubmFtZT9fPW5ldyBQcm9taXNlKGZ1bmN0aW9uKEUpe2Euc3RvcmVOYW1lP0UodyhhLHYuX2RlZmF1bHRDb25maWcpKTpFKGEubmFtZStcIi9cIil9KTpfPVByb21pc2UucmVqZWN0KFwiSW52YWxpZCBhcmd1bWVudHNcIikse3Byb21pc2U6XyxjYWxsYmFjazpzfX1mdW5jdGlvbiBGKGEpe3JldHVybiB0eXBlb2YgYSE9XCJzdHJpbmdcIiYmKGNvbnNvbGUud2FybihhK1wiIHVzZWQgYXMgYSBrZXksIGJ1dCBpdCBpcyBub3QgYSBzdHJpbmcuXCIpLGE9U3RyaW5nKGEpKSxhfXZhciBrPXtidWZmZXJUb1N0cmluZzpQLGRlc2VyaWFsaXplOlosc2VyaWFsaXplOkssc3RyaW5nVG9CdWZmZXI6U30sVT17fSxhZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEocyl7dGhpcy5rcD1zLHRoaXMuZGF0YT17fX1yZXR1cm4gYS5yZXNvbHZlPWZ1bmN0aW9uKHMpe3JldHVybiBVW3NdfHwoVVtzXT1uZXcgYShzKSksVVtzXX0sYS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmRhdGE9e319LGEucHJvdG90eXBlLmRyb3A9ZnVuY3Rpb24oKXt0aGlzLmNsZWFyKCksZGVsZXRlIFVbdGhpcy5rcF19LGEucHJvdG90eXBlLmdldD1mdW5jdGlvbihzKXtyZXR1cm4gdGhpcy5kYXRhW3NdfSxhLnByb3RvdHlwZS5rZXk9ZnVuY3Rpb24ocyl7cmV0dXJuIHRoaXMua2V5cygpW3NdfSxhLnByb3RvdHlwZS5rZXlzPWZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGF0YSl9LGEucHJvdG90eXBlLnJtPWZ1bmN0aW9uKHMpe2RlbGV0ZSB0aGlzLmRhdGFbc119LGEucHJvdG90eXBlLnNldD1mdW5jdGlvbihzLHYpe3RoaXMuZGF0YVtzXT12fSxhfSgpO2Z1bmN0aW9uIHJlKGEpe3ZhciBzPWE/bShhKTp7fSx2PXcocyx0aGlzLl9kZWZhdWx0Q29uZmlnKSxiPWFlLnJlc29sdmUodik7cmV0dXJuIHRoaXMuX2RiSW5mbz1zLHRoaXMuX2RiSW5mby5zZXJpYWxpemVyPWssdGhpcy5fZGJJbmZvLmtleVByZWZpeD12LHRoaXMuX2RiSW5mby5tU3RvcmU9YixQcm9taXNlLnJlc29sdmUoKX1mdW5jdGlvbiBoKGEpe3ZhciBzPXRoaXMsdj10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3MuX2RiSW5mby5tU3RvcmUuY2xlYXIoKX0pO3JldHVybiBOKHYsYSksdn1mdW5jdGlvbiBSKGEscyl7dmFyIHY9cS5hcHBseSh0aGlzLGFyZ3VtZW50cyksYj12LnByb21pc2UsXz12LmNhbGxiYWNrLEU9Yi50aGVuKGZ1bmN0aW9uKEQpe2FlLnJlc29sdmUoRCkuZHJvcCgpfSk7cmV0dXJuIE4oRSxfKSxifWZ1bmN0aW9uIEkoYSxzKXt2YXIgdj10aGlzO2E9RihhKTt2YXIgYj10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBfPXYuX2RiSW5mby5tU3RvcmUuZ2V0KGEpO3JldHVybiBfPT1udWxsP251bGw6di5fZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoXyl9KTtyZXR1cm4gTihiLHMpLGJ9ZnVuY3Rpb24gQihhLHMpe3ZhciB2PXRoaXMsYj10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe2Zvcih2YXIgXz12Ll9kYkluZm8ubVN0b3JlLEU9Xy5rZXlzKCksRD0wO0Q8RS5sZW5ndGg7RCsrKXt2YXIgRz1fLmdldChFW0RdKTtpZihHJiYoRz12Ll9kYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShHKSksRz1hKEcsRVtEXSxEKzEpLEchPT12b2lkIDApcmV0dXJuIEd9fSk7cmV0dXJuIE4oYixzKSxifWZ1bmN0aW9uIEgoYSxzKXt2YXIgdj10aGlzLGI9dGhpcy5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgXzt0cnl7Xz12Ll9kYkluZm8ubVN0b3JlLmtleShhKSxfPT09dm9pZCAwJiYoXz1udWxsKX1jYXRjaHtfPW51bGx9cmV0dXJuIF99KTtyZXR1cm4gTihiLHMpLGJ9ZnVuY3Rpb24gaihhKXt2YXIgcz10aGlzLHY9dGhpcy5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcy5fZGJJbmZvLm1TdG9yZS5rZXlzKCl9KTtyZXR1cm4gTih2LGEpLHZ9ZnVuY3Rpb24gSihhKXt2YXIgcz10aGlzLmtleXMoKS50aGVuKGZ1bmN0aW9uKHYpe3JldHVybiB2Lmxlbmd0aH0pO3JldHVybiBOKHMsYSksc31mdW5jdGlvbiAkKGEscyl7dmFyIHY9dGhpczthPUYoYSk7dmFyIGI9dGhpcy5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2Ll9kYkluZm8ubVN0b3JlLnJtKGEpfSk7cmV0dXJuIE4oYixzKSxifWZ1bmN0aW9uIGVlKGEscyx2KXt2YXIgYj10aGlzO2E9RihhKTt2YXIgXz10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3M9PT12b2lkIDAmJihzPW51bGwpO3ZhciBFPXM7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKEQsRyl7Yi5fZGJJbmZvLnNlcmlhbGl6ZXIuc2VyaWFsaXplKHMsZnVuY3Rpb24oZmUsaWUpe2lmKGllKUcoaWUpO2Vsc2UgdHJ5e2IuX2RiSW5mby5tU3RvcmUuc2V0KGEsZmUpLEQoRSl9Y2F0Y2goY2Upe0coY2UpfX0pfSl9KTtyZXR1cm4gTihfLHYpLF99dmFyIG9lPSEwO3AuX3N1cHBvcnQ9b2UscC5fZHJpdmVyPWcscC5faW5pdFN0b3JhZ2U9cmUscC5jbGVhcj1oLHAuZHJvcEluc3RhbmNlPVIscC5nZXRJdGVtPUkscC5pdGVyYXRlPUIscC5rZXk9SCxwLmtleXM9aixwLmxlbmd0aD1KLHAucmVtb3ZlSXRlbT0kLHAuc2V0SXRlbT1lZSxPYmplY3QuZGVmaW5lUHJvcGVydHkocCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pfSk7dmFyIHBlPVplKGtlKCkpLEJlPVplKHJyKCkpO2ltcG9ydHtTREtCYXNlIGFzIGN0LGNyZWF0ZVNESyBhcyBsdH1mcm9tXCJAbWFnaWMtc2RrL3Byb3ZpZGVyXCI7aW1wb3J0e1ZpZXdDb250cm9sbGVyIGFzIG90LGNyZWF0ZUR1cGxpY2F0ZUlmcmFtZVdhcm5pbmcgYXMgaXQsY3JlYXRlVVJMIGFzIHRyLGNyZWF0ZU1vZGFsTm90UmVhZHlFcnJvciBhcyBhdH1mcm9tXCJAbWFnaWMtc2RrL3Byb3ZpZGVyXCI7dmFyIGZ0PXtkaXNwbGF5Olwibm9uZVwiLHBvc2l0aW9uOlwiZml4ZWRcIix0b3A6XCIwXCIscmlnaHQ6XCIwXCIsd2lkdGg6XCIxMDAlXCIsaGVpZ2h0OlwiMTAwJVwiLGJvcmRlclJhZGl1czpcIjBcIixib3JkZXI6XCJub25lXCIsekluZGV4OlwiMjE0NzQ4MzY0N1wifTtmdW5jdGlvbiB1dChwKXtmb3IobGV0W2csT11vZiBPYmplY3QuZW50cmllcyhmdCkpcC5zdHlsZVtnXT1PfWZ1bmN0aW9uIHN0KHApe2xldCBnPVtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5tYWdpYy1pZnJhbWVcIikpO3JldHVybiBCb29sZWFuKGcuZmluZChPPT5PLnNyYy5pbmNsdWRlcyhwKSkpfXZhciBUZT1jbGFzcyBleHRlbmRzIG90e2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKTt0aGlzLmFjdGl2ZUVsZW1lbnQ9bnVsbH1pbml0KCl7dGhpcy50ZXN0PVwiaGVsbG9cIix0aGlzLmlmcmFtZT1uZXcgUHJvbWlzZShnPT57bGV0IE89KCk9PntpZihzdChlbmNvZGVVUklDb21wb25lbnQodGhpcy5wYXJhbWV0ZXJzKSkpaXQoKS5sb2coKTtlbHNle2xldCBMPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7TC5jbGFzc0xpc3QuYWRkKFwibWFnaWMtaWZyYW1lXCIpLEwuZGF0YXNldC5tYWdpY0lmcmFtZUxhYmVsPXRyKHRoaXMuZW5kcG9pbnQpLmhvc3QsTC50aXRsZT1cIlNlY3VyZSBNb2RhbFwiLEwuc3JjPXRyKGAvc2VuZD9wYXJhbXM9JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5wYXJhbWV0ZXJzKX1gLHRoaXMuZW5kcG9pbnQpLmhyZWYsdXQoTCksZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChMKSxnKEwpfX07W1wibG9hZGVkXCIsXCJpbnRlcmFjdGl2ZVwiLFwiY29tcGxldGVcIl0uaW5jbHVkZXMoZG9jdW1lbnQucmVhZHlTdGF0ZSk/TygpOndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLE8sITEpfSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZz0+e3ZhciBPO2lmKGcub3JpZ2luPT09dGhpcy5lbmRwb2ludCYmZy5kYXRhJiZnLmRhdGEubXNnVHlwZSYmdGhpcy5tZXNzYWdlSGFuZGxlcnMuc2l6ZSl7Zy5kYXRhLnJlc3BvbnNlPShPPWcuZGF0YS5yZXNwb25zZSkhPW51bGw/Tzp7fTtmb3IobGV0IEwgb2YgdGhpcy5tZXNzYWdlSGFuZGxlcnMudmFsdWVzKCkpTChnKX19KX1zaG93T3ZlcmxheSgpe3JldHVybiBzZSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7bGV0IGc9eWllbGQgdGhpcy5pZnJhbWU7Zy5zdHlsZS5kaXNwbGF5PVwiYmxvY2tcIix0aGlzLmFjdGl2ZUVsZW1lbnQ9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxnLmZvY3VzKCl9KX1oaWRlT3ZlcmxheSgpe3JldHVybiBzZSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7dmFyIE87bGV0IGc9eWllbGQgdGhpcy5pZnJhbWU7Zy5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLCgoTz10aGlzLmFjdGl2ZUVsZW1lbnQpPT1udWxsP3ZvaWQgMDpPLmZvY3VzKSYmdGhpcy5hY3RpdmVFbGVtZW50LmZvY3VzKCksdGhpcy5hY3RpdmVFbGVtZW50PW51bGx9KX1fcG9zdChnKXtyZXR1cm4gc2UodGhpcyxudWxsLGZ1bmN0aW9uKigpe2xldCBPPXlpZWxkIHRoaXMuaWZyYW1lO2lmKE8mJk8uY29udGVudFdpbmRvdylPLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoZyx0aGlzLmVuZHBvaW50KTtlbHNlIHRocm93IGF0KCl9KX19O2V4cG9ydCpmcm9tXCJAbWFnaWMtc2RrL2NvbW1vbnNcIjt2YXIgX3Q9bHQoY3Qse3BsYXRmb3JtOlwid2ViXCIsc2RrTmFtZTpcIm1hZ2ljLXNka1wiLHZlcnNpb246XCIxMS4wLjBcIixkZWZhdWx0RW5kcG9pbnQ6XCJodHRwczovL2F1dGgubWFnaWMubGluay9cIixWaWV3Q29udHJvbGxlcjpUZSxjb25maWd1cmVTdG9yYWdlOigpPT5zZSh2b2lkIDAsbnVsbCxmdW5jdGlvbiooKXtsZXQgcD1wZS5kZWZhdWx0LmNyZWF0ZUluc3RhbmNlKHtuYW1lOlwiTWFnaWNBdXRoTG9jYWxTdG9yYWdlREJcIixzdG9yZU5hbWU6XCJNYWdpY0F1dGhMb2NhbFN0b3JhZ2VcIn0pO3JldHVybiB5aWVsZCBwLmRlZmluZURyaXZlcihCZSkseWllbGQgcC5zZXREcml2ZXIoW3BlLmRlZmF1bHQuSU5ERVhFRERCLHBlLmRlZmF1bHQuTE9DQUxTVE9SQUdFLEJlLl9kcml2ZXJdKSxwfSl9KTtleHBvcnR7X3QgYXMgTWFnaWN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0e0V4dGVuc2lvbiBhcyBvfWZyb21cIm1hZ2ljLXNka1wiO3ZhciBzPSh0PT4odC5HZXRXYWxsZXRJbmZvPVwibWNfZ2V0X3dhbGxldF9pbmZvXCIsdC5TaG93V2FsbGV0PVwibWNfd2FsbGV0XCIsdC5SZXF1ZXN0VXNlckluZm89XCJtY19yZXF1ZXN0X3VzZXJfaW5mb1wiLHQuRGlzY29ubmVjdD1cIm1jX2Rpc2Nvbm5lY3RcIix0KSkoc3x8e30pO3ZhciBsPWNsYXNzIGV4dGVuZHMgby5JbnRlcm5hbHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyk7dGhpcy5uYW1lPVwiY29ubmVjdFwiO3RoaXMuY29uZmlnPXttYzohMH19Z2V0V2FsbGV0SW5mbygpe2xldCBlPXRoaXMudXRpbHMuY3JlYXRlSnNvblJwY1JlcXVlc3RQYXlsb2FkKFwibWNfZ2V0X3dhbGxldF9pbmZvXCIpO3JldHVybiB0aGlzLnJlcXVlc3QoZSl9c2hvd1dhbGxldCgpe2xldCBlPXRoaXMudXRpbHMuY3JlYXRlSnNvblJwY1JlcXVlc3RQYXlsb2FkKFwibWNfd2FsbGV0XCIpO3JldHVybiB0aGlzLnJlcXVlc3QoZSl9cmVxdWVzdFVzZXJJbmZvKGUpe2xldCBuPXRoaXMudXRpbHMuY3JlYXRlSnNvblJwY1JlcXVlc3RQYXlsb2FkKFwibWNfcmVxdWVzdF91c2VyX2luZm9cIixlP1tlXTpbXSk7cmV0dXJuIHRoaXMucmVxdWVzdChuKX1kaXNjb25uZWN0KCl7bGV0IGU9dGhpcy51dGlscy5jcmVhdGVKc29uUnBjUmVxdWVzdFBheWxvYWQoXCJtY19kaXNjb25uZWN0XCIpO3JldHVybiB0aGlzLnJlcXVlc3QoZSl9fTtleHBvcnR7bCBhcyBDb25uZWN0RXh0ZW5zaW9uLHMgYXMgTWFnaWNDb25uZWN0UGF5bG9hZE1ldGhvZH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXHJcbmltcG9ydCB7ZXRoZXJzfSBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgQWJzdHJhY3RXZWIzQ29ubmVjdG9yIGZyb20gJy4vQWJzdHJhY3RXZWIzQ29ubmVjdG9yJztcclxuaW1wb3J0IHtNYWdpY30gZnJvbSBcIm1hZ2ljLXNka1wiO1xyXG5pbXBvcnQge0Nvbm5lY3RFeHRlbnNpb259IGZyb20gXCJAbWFnaWMtZXh0L2Nvbm5lY3RcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFnaWNXZWIzQ29ubmVjdG9yIGV4dGVuZHMgQWJzdHJhY3RXZWIzQ29ubmVjdG9yIHtcclxuICAgIHR5cGUgPSAnTWFnaWNMaW5rJztcclxuICAgIG1hZ2ljOiBhbnk7XHJcbiAgICBldGhlcjogZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBhc3luYyBhY3RpdmF0ZSgpIHtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBBcHAuTmV0d29yaztcclxuICAgICAgICBsZXQgbmV0d29yayA9IHtycGNVcmw6IG5ldHdvcmtJbmZvLlJwY1VybCwgY2hhaW5JZDogbmV0d29ya0luZm8uQ2hhaW5JZH0gYXMgYW55O1xyXG4gICAgICAgIHRoaXMubWFnaWMgPSBuZXcgTWFnaWMoJ3BrX2xpdmVfRUE5RERDNDU4RkUyMUIyNCcsIHtcclxuICAgICAgICAgICAgZXh0ZW5zaW9uczogW25ldyBDb25uZWN0RXh0ZW5zaW9uKCldLFxyXG4gICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuZXRoZXIgPSBuZXcgZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIodGhpcy5tYWdpYy5ycGNQcm92aWRlcik7XHJcbiAgICAgICAgbGV0IGFjY291bnRzID0gYXdhaXQgdGhpcy5ldGhlci5saXN0QWNjb3VudHMoKTtcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIENvbnN0YW50c1xyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnRzWzBdO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSB0aGlzLmV0aGVyLnByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG5ldHdvcmtJbmZvLkNoYWluSWQ7XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHModGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcclxuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbklkLFxyXG4gICAgICAgICAgICBldGhlcjogdGhpcy5ldGhlcixcclxuICAgICAgICAgICAgbWFnaWM6IHRoaXMubWFnaWMsXHJcbiAgICAgICAgICAgIHNpZ25lcjogdGhpcy5ldGhlci5nZXRTaWduZXIoKVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRlYWN0aXZhdGUgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVRvRXZlbnRzKHRoaXMucHJvdmlkZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLm1hZ2ljKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubWFnaWMuY29ubmVjdC5kaXNjb25uZWN0KCkuY2F0Y2goKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3IgdG8gZGlzY29ubmVjdDonLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGFpbklkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcclxuICAgIH07XHJcbn1cclxuIiwiZXhwb3J0IGVudW0gV2FsbGV0VHlwZSB7XHJcbiAgICBNZXRhbWFzayA9ICdtZXRhbWFzaycsXHJcbiAgICBXYWxsZXRDb25uZWN0ID0gJ3dhbGxldENvbm5lY3QnLFxyXG4gICAgQ29pbmJhc2VXYWxsZXQgPSAnY29pbmJhc2UnLFxyXG4gICAgV2ViM0F1dGggPSAnd2ViM0F1dGgnLFxyXG4gICAgTWFnaWNMaW5rID0gJ01hZ2ljTGluaycsXHJcbiAgICBVbmtub3duID0gJ3Vua25vd24nXHJcbn0iLCJpbXBvcnQge1dhbGxldFR5cGV9IGZyb20gXCIuLi9lbnVtcy9XYWxsZXRUeXBlXCI7XHJcbmltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3ZpZGVySW5mbyB7XHJcblxyXG4gICAgd2ViM1Byb3ZpZGVyOiBhbnk7XHJcblxyXG4gICAgUHJvdmlkZXJOYW1lOiBzdHJpbmcgPSAndW5rbm93bic7XHJcbiAgICBXYWxsZXROYW1lOiBzdHJpbmcgPSAnJztcclxuICAgIFdhbGxldFVybDogc3RyaW5nID0gJyc7XHJcbiAgICBXYWxsZXRUeXBlOiBXYWxsZXRUeXBlID0gV2FsbGV0VHlwZS5Vbmtub3duO1xyXG4gICAgVXNlckFkZHJlc3M6IHN0cmluZyA9ICcnO1xyXG4gICAgSW50ZXJuYWxXYWxsZXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBzdGF0aWMgSW5zdGFuY2U6IFByb3ZpZGVySW5mbztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih3ZWIzUHJvdmlkZXI6IGFueSkge1xyXG4gICAgICAgIGlmICghd2ViM1Byb3ZpZGVyIHx8ICF3ZWIzUHJvdmlkZXIucHJvdmlkZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy53ZWIzUHJvdmlkZXIgPSB3ZWIzUHJvdmlkZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLndlYjNQcm92aWRlci5jb25uZWN0aW9uICYmIHRoaXMud2ViM1Byb3ZpZGVyLmNvbm5lY3Rpb24udXJsID09ICdtZXRhbWFzaycpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkTWV0YW1hc2sod2ViM1Byb3ZpZGVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2ViM1Byb3ZpZGVyLnByb3ZpZGVyLndjKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFdhbGxldENvbm5lY3Qod2ViM1Byb3ZpZGVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2ViM1Byb3ZpZGVyLnByb3ZpZGVyLmlzTWFnaWMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkTWFnaWNDb25uZWN0KHdlYjNQcm92aWRlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQ3VzdG9tKHdlYjNQcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFByb3ZpZGVySW5mby5JbnN0YW5jZSA9IHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGxvYWRNZXRhbWFzayh3YWxsZXRDb25uZWN0aW9uSW5mbyA6IGFueSkge1xyXG4gICAgICAgIHRoaXMuUHJvdmlkZXJOYW1lID0gJ21ldGFtYXNrJztcclxuICAgICAgICB0aGlzLldhbGxldE5hbWUgPSBcIk1ldGFtYXNrXCI7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRVcmwgPSAnaHR0cHM6Ly9tZXRhbWFzay5pby8nO1xyXG4gICAgICAgIHRoaXMuV2FsbGV0VHlwZSA9IFdhbGxldFR5cGUuTWV0YW1hc2s7XHJcbiAgICAgICAgdGhpcy5Vc2VyQWRkcmVzcyA9IHdhbGxldENvbm5lY3Rpb25JbmZvLnByb3ZpZGVyLnNlbGVjdGVkQWRkcmVzcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxvYWRXYWxsZXRDb25uZWN0KHdhbGxldENvbm5lY3Rpb25JbmZvOiBhbnkpIHtcclxuICAgICAgICBsZXQgd2MgPSB3YWxsZXRDb25uZWN0aW9uSW5mby5wcm92aWRlci53YztcclxuXHJcbiAgICAgICAgdGhpcy5Qcm92aWRlck5hbWUgPSBcIndhbGxldENvbm5lY3RcIjtcclxuICAgICAgICB0aGlzLldhbGxldE5hbWUgPSB3Yy5fcGVlck1ldGEubmFtZTtcclxuICAgICAgICB0aGlzLldhbGxldFVybCA9IHdjLl9wZWVyTWV0YS51cmwgPz8gJyc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRUeXBlID0gV2FsbGV0VHlwZS5XYWxsZXRDb25uZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZEN1c3RvbShwcm92aWRlcjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5Qcm92aWRlck5hbWUgPSAnd2ViM2F1dGgnO1xyXG4gICAgICAgIHRoaXMuV2FsbGV0TmFtZSA9ICdUb3J1cyc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRVcmwgPSAnaHR0cHM6Ly9hcHAudG9yLnVzLyc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRUeXBlID0gV2FsbGV0VHlwZS5XZWIzQXV0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxvYWRNYWdpY0Nvbm5lY3Qod2FsbGV0Q29ubmVjdGlvbkluZm86IGFueSkge1xyXG4gICAgICAgIHRoaXMuUHJvdmlkZXJOYW1lID0gJ01hZ2ljTGluayc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXROYW1lID0gJ01hZ2ljTGluaydcclxuICAgICAgICB0aGlzLldhbGxldFR5cGUgPSBXYWxsZXRUeXBlLk1hZ2ljTGluaztcclxuICAgICAgICB0aGlzLkludGVybmFsV2FsbGV0ID0gdHJ1ZTtcclxuICAgIH1cclxufSIsImltcG9ydCBQcm92aWRlckluZm8gZnJvbSBcIi4uL3dhbGxldC9Qcm92aWRlckluZm9cIjtcclxuaW1wb3J0IENvb2tpZUhlbHBlciBmcm9tIFwiLi4vdXRpbC9Db29raWVIZWxwZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZXIge1xyXG4gICAgcHJvdmlkZXI6IGFueTtcclxuICAgIGNoYWluSWQ6IG51bWJlcjtcclxuICAgIGV0aGVyOiBhbnk7XHJcbiAgICBlbWFpbDogc3RyaW5nO1xyXG4gICAgcHJvdmlkZXJJbmZvOiBhbnk7XHJcbiAgICBhbHBhY2FJZD86IHN0cmluZztcclxuICAgIGFkZHJlc3M6IHN0cmluZztcclxuICAgIG1hZ2ljOiBhbnk7XHJcbiAgICBjb25uZWN0b3I6IGFueTtcclxuICAgIF90b2tlbjogc3RyaW5nID0gJyc7XHJcbiAgICBpc0xvZ2dlZEluOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBzaWduZXI6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcjogYW55LCBhZGRyZXNzOiBzdHJpbmcsIGNoYWluSWQ6IG51bWJlciwgZXRoZXI6IGFueSkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFkZHJlc3MgPSBhZGRyZXNzO1xyXG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XHJcbiAgICAgICAgdGhpcy5ldGhlciA9IGV0aGVyO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJbmZvID0gbmV3IFByb3ZpZGVySW5mbyhwcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5lbWFpbCA9ICcnO1xyXG5cclxuICAgICAgICBsZXQgY29va2llSGVscGVyID0gbmV3IENvb2tpZUhlbHBlcigpO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuID0gY29va2llSGVscGVyLmdldENvb2tpZVZhbHVlKCd0b2tlbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdG9rZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXQgdG9rZW4odmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX3Rva2VuID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VmFsaWRhdGUodmFsaWRhdGU6IGFueSkge1xyXG4gICAgICAgIGxldCBiYXNlNjQgPSBidG9hKEpTT04uc3RyaW5naWZ5KHZhbGlkYXRlKSlcclxuICAgICAgICBsZXQgY29va2llSGVscGVyID0gbmV3IENvb2tpZUhlbHBlcigpO1xyXG4gICAgICAgIGNvb2tpZUhlbHBlci5zZXRDb29raWUoJ3ZhbGlkYXRlJywgYmFzZTY0KTtcclxuICAgIH1cclxuXHJcbn0iLCIvKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbnZhclxyXG4gIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgdG9vTWFueURpZ2l0cyA9IGJpZ251bWJlckVycm9yICsgJ051bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6ICcsXHJcblxyXG4gIEJBU0UgPSAxZTE0LFxyXG4gIExPR19CQVNFID0gMTQsXHJcbiAgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmYsICAgICAgICAgLy8gMl41MyAtIDFcclxuICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgU1FSVF9CQVNFID0gMWU3LFxyXG5cclxuICAvLyBFRElUQUJMRVxyXG4gIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gIC8vIHRoZSBhcmd1bWVudHMgdG8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQsIGFuZCB0b1ByZWNpc2lvbi5cclxuICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbi8qXHJcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnTnVtYmVyIGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgdmFyIGRpdiwgY29udmVydEJhc2UsIHBhcnNlTnVtZXJpYyxcclxuICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUQUJMRSBDT05GSUcgREVGQVVMVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGZvciBvcGVyYXRpb25zIGludm9sdmluZyBkaXZpc2lvbi5cclxuICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgLy8gdG9FeHBvbmVudGlhbCwgdG9GaXhlZCwgdG9Gb3JtYXQgYW5kIHRvUHJlY2lzaW9uLCBhbmQgcm91bmQgKGRlZmF1bHQgdmFsdWUpLlxyXG4gICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgIC8vIENFSUwgICAgICAgMiBUb3dhcmRzICtJbmZpbml0eS5cclxuICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAvLyBIQUxGX0RPV04gIDUgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIGRvd24uXHJcbiAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gSEFMRl9GTE9PUiA4IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gUkFOR0UgOiBbTUlOX0VYUCwgTUFYX0VYUF1cclxuXHJcbiAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgIE1JTl9FWFAgPSAtMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLTEgdG8gLU1BWFxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgLy8gRm9yIE1BWF9FWFAgPiAxZTcsIGUuZy4gbmV3IEJpZ051bWJlcignMWUxMDAwMDAwMDAnKS5wbHVzKDEpIG1heSBiZSBzbG93LlxyXG4gICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAvL1xyXG4gICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAvLyBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgIC8vIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgLy8gICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgIC8vIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiB0aGUgZXhwb25lbnRpYXRlZEJ5IG9wZXJhdGlvbi5cclxuICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFRoZSBmb3JtYXQgc3BlY2lmaWNhdGlvbiB1c2VkIGJ5IHRoZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0IG1ldGhvZC5cclxuICAgIEZPUk1BVCA9IHtcclxuICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgc3VmZml4OiAnJ1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgIC8vICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB0cnVlO1xyXG5cclxuXHJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgKlxyXG4gICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgIGlmIChiID09IG51bGwpIHtcclxuXHJcbiAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICBpZiAoIXYuYyB8fCB2LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICB4LmMgPSB2LmMuc2xpY2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHYgPSAtdiwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICBmb3IgKGUgPSAwLCBpID0gdjsgaSA+PSAxMDsgaSAvPSAxMCwgZSsrKTtcclxuXHJcbiAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICBlID0gc3RyLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAvLyBhbHNvIHJvdW5kaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFzIHdpdGggb3RoZXIgYmFzZXMuXHJcbiAgICAgIGlmIChiID09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgIHJldHVybiByb3VuZCh4LCBERUNJTUFMX1BMQUNFUyArIHguZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICBpZiAoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgIHgucyA9IDEgLyB2IDwgMCA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYWxwaGFiZXQgPSBBTFBIQUJFVC5zbGljZSgwLCBiKTtcclxuICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAvLyBEb24ndCB1c2UgUmVnRXhwLCBzbyBhbHBoYWJldCBjYW4gY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgaWYgKGMgPT0gJy4nKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICBlID0gbGVuO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjYXNlQ2hhbmdlZCkge1xyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICBzdHIgPT0gc3RyLnRvTG93ZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b1VwcGVyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgZSA9IDA7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHN0ciwgYiwgMTAsIHgucyk7XHJcblxyXG4gICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgZWxzZSBlID0gc3RyLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICBpZiAoc3RyID0gc3RyLnNsaWNlKGksICsrbGVuKSkge1xyXG4gICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgIGlmIChpc051bSAmJiBCaWdOdW1iZXIuREVCVUcgJiZcclxuICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAodG9vTWFueURpZ2l0cyArICh4LnMgKiB2KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gZSAtIGkgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgIHguYyA9IFtdO1xyXG5cclxuICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgY29lZmZpY2llbnQgYXJyYXkuXHJcbiAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICB4LmMucHVzaCgrc3RyLnNsaWNlKGksIGkgKz0gTE9HX0JBU0UpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgQmlnTnVtYmVyLmNsb25lID0gY2xvbmU7XHJcblxyXG4gIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAqXHJcbiAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgKiBhIG51bWJlciwgaXQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIHN0YXRlZCk6XHJcbiAgICpcclxuICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICogICBST1VORElOR19NT0RFICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDhcclxuICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAqICAgQ1JZUFRPICAgICAgICAgICB7Ym9vbGVhbn0gICAgICAgICAgdHJ1ZSBvciBmYWxzZVxyXG4gICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAqICAgQUxQSEFCRVQgICAgICAgICB7c3RyaW5nfSAgICAgICAgICAgQSBzdHJpbmcgb2YgdHdvIG9yIG1vcmUgdW5pcXVlIGNoYXJhY3RlcnMgd2hpY2ggZG9lc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICogICAgIHByZWZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIGdyb3VwU2VwYXJhdG9yICAgICAgICAge3N0cmluZ31cclxuICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3Ige3N0cmluZ31cclxuICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAqXHJcbiAgICogKFRoZSB2YWx1ZXMgYXNzaWduZWQgdG8gdGhlIGFib3ZlIEZPUk1BVCBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90IGNoZWNrZWQgZm9yIHZhbGlkaXR5LilcclxuICAgKlxyXG4gICAqIEUuZy5cclxuICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgKlxyXG4gICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5jb25maWcgPSBCaWdOdW1iZXIuc2V0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgdmFyIHAsIHY7XHJcblxyXG4gICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9iaiA9PSAnb2JqZWN0Jykge1xyXG5cclxuICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnREVDSU1BTF9QTEFDRVMnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICBERUNJTUFMX1BMQUNFUyA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJPVU5ESU5HX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCA4LCBwKTtcclxuICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQge251bWJlcnxudW1iZXJbXX1cclxuICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBFWFBPTkVOVElBTF9BVCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgVE9fRVhQX05FRyA9IHZbMF07XHJcbiAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFJBTkdFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZXxjYW5ub3QgYmUgemVyb306IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgTUlOX0VYUCA9IHZbMF07XHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgLU1BWCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENSWVBUTyB7Ym9vbGVhbn0gdHJ1ZSBvciBmYWxzZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQ1JZUFRPJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTU9EVUxPX01PREUge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgOSwgcCk7XHJcbiAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBQT1dfUFJFQ0lTSU9OIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdGT1JNQVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgIGVsc2UgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBTFBIQUJFVCB7c3RyaW5nfVxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcblxyXG4gICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ3N0cmluZycgJiYgIS9eLj8kfFsrXFwtLlxcc118KC4pLipcXDEvLnRlc3QodikpIHtcclxuICAgICAgICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdi5zbGljZSgwLCAxMCkgPT0gJzAxMjM0NTY3ODknO1xyXG4gICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgKlxyXG4gICAqIHYge2FueX1cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAqL1xyXG4gIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB2YXIgaSwgbixcclxuICAgICAgYyA9IHYuYyxcclxuICAgICAgZSA9IHYuZSxcclxuICAgICAgcyA9IHYucztcclxuXHJcbiAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgRXJyb3JcclxuICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgKi9cclxuICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGMgPSBbXSxcclxuICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByYW5kLmUgPSBlO1xyXG4gICAgICByYW5kLmMgPSBjO1xyXG4gICAgICByZXR1cm4gcmFuZDtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gICAvKlxyXG4gICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSA9IDEsXHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgIHJldHVybiBzdW07XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgIHZhciBqLFxyXG4gICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICBhcnJMLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIC0tZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgciA9IHgucjtcclxuICAgICAgICBlID0geC5lO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBjbXA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcTtcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAqXHJcbiAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgYzAgPSBuLmNbMF07XHJcbiAgICBuZSA9IG4uZTtcclxuXHJcbiAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICB2YXIgbixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgIG0gPSBuO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgbSA9IG47XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3c/XHJcbiAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuLmUgPSBlO1xyXG4gICAgICBuLmMgPSBjO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgIH1cclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgbmktLTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICBlID0gbi5lO1xyXG5cclxuICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgKi9cclxuICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuXHJcbiAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgKi9cclxuICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAqXHJcbiAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKi9cclxuICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICByZXR1cm4gbjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiAvIDAgPSBJXHJcbiAgICogIG4gLyBOID0gTlxyXG4gICAqICBuIC8gSSA9IDBcclxuICAgKiAgMCAvIG4gPSAwXHJcbiAgICogIDAgLyAwID0gTlxyXG4gICAqICAwIC8gTiA9IE5cclxuICAgKiAgMCAvIEkgPSAwXHJcbiAgICogIE4gLyBuID0gTlxyXG4gICAqICBOIC8gMCA9IE5cclxuICAgKiAgTiAvIE4gPSBOXHJcbiAgICogIE4gLyBJID0gTlxyXG4gICAqICBJIC8gbiA9IElcclxuICAgKiAgSSAvIDAgPSBJXHJcbiAgICogIEkgLyBOID0gTlxyXG4gICAqICBJIC8gSSA9IE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgKi9cclxuICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAqL1xyXG4gIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICpcclxuICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgKlxyXG4gICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgKlxyXG4gICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgKi9cclxuICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IG4ucyAqICgyIC0gaXNPZGQobikpIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICB9XHJcblxyXG4gICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICBpZiAobSkge1xyXG5cclxuICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgIH1cclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgaWYgKGspIHtcclxuICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgKi9cclxuICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiAtIDAgPSBuXHJcbiAgICogIG4gLSBOID0gTlxyXG4gICAqICBuIC0gSSA9IC1JXHJcbiAgICogIDAgLSBuID0gLW5cclxuICAgKiAgMCAtIDAgPSAwXHJcbiAgICogIDAgLSBOID0gTlxyXG4gICAqICAwIC0gSSA9IC1JXHJcbiAgICogIE4gLSBuID0gTlxyXG4gICAqICBOIC0gMCA9IE5cclxuICAgKiAgTiAtIE4gPSBOXHJcbiAgICogIE4gLSBJID0gTlxyXG4gICAqICBJIC0gbiA9IElcclxuICAgKiAgSSAtIDAgPSBJXHJcbiAgICogIEkgLSBOID0gTlxyXG4gICAqICBJIC0gSSA9IE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYSA9IHgucztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgIGIgPSB5LnM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgIHkucyA9IC1iO1xyXG4gICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgfVxyXG5cclxuICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICB0LnJldmVyc2UoKTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBxLCBzLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgIHMgPSB5LnM7XHJcbiAgICAgIHkucyA9IDE7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgIHkucyA9IHM7XHJcbiAgICAgIHEucyAqPSBzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeS5zICo9IHgucztcclxuICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgYmFzZSA9IEJBU0U7XHJcbiAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICBjID0gMDtcclxuICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB6Y1tqXSA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGMpIHtcclxuICAgICAgKytlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAqL1xyXG4gIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICsgMCA9IG5cclxuICAgKiAgbiArIE4gPSBOXHJcbiAgICogIG4gKyBJID0gSVxyXG4gICAqICAwICsgbiA9IG5cclxuICAgKiAgMCArIDAgPSAwXHJcbiAgICogIDAgKyBOID0gTlxyXG4gICAqICAwICsgSSA9IElcclxuICAgKiAgTiArIG4gPSBOXHJcbiAgICogIE4gKyAwID0gTlxyXG4gICAqICBOICsgTiA9IE5cclxuICAgKiAgTiArIEkgPSBOXHJcbiAgICogIEkgKyBuID0gSVxyXG4gICAqICBJICsgMCA9IElcclxuICAgKiAgSSArIE4gPSBOXHJcbiAgICogIEkgKyBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYSA9IHgucztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgIGIgPSB5LnM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYztcclxuXHJcbiAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgfVxyXG5cclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYSkge1xyXG4gICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICArK3llO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAqXHJcbiAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgKi9cclxuICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICB2YXIgYywgbiwgdixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICByZXR1cm4gbjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAqXHJcbiAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICovXHJcbiAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICogIHNxcnQoTikgPSAgTlxyXG4gICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAqICBzcXJ0KDApID0gIDBcclxuICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAqL1xyXG4gIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBjID0geC5jLFxyXG4gICAgICBzID0geC5zLFxyXG4gICAgICBlID0geC5lLFxyXG4gICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgaWYgKHIuY1swXSkge1xyXG4gICAgICBlID0gci5lO1xyXG4gICAgICBzID0gZSArIGRwO1xyXG4gICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgIHQgPSByO1xyXG4gICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKi9cclxuICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgZHArKztcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgKlxyXG4gICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgKlxyXG4gICAqIEZPUk1BVCA9IHtcclxuICAgKiAgIHByZWZpeDogJycsXHJcbiAgICogICBncm91cFNpemU6IDMsXHJcbiAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAqICAgc3VmZml4OiAnJ1xyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICovXHJcbiAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgIH1cclxuXHJcbiAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICBpZiAoeC5jKSB7XHJcbiAgICAgIHZhciBpLFxyXG4gICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAqXHJcbiAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgKi9cclxuICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jO1xyXG5cclxuICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgZXhwID0gTUFYX0VYUDtcclxuICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICBmb3IgKDsgOykgIHtcclxuICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICBkMCA9IGQxO1xyXG4gICAgICBkMSA9IGQyO1xyXG4gICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgIG4wID0gZDI7XHJcbiAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgIG4gPSBkMjtcclxuICAgIH1cclxuXHJcbiAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgKi9cclxuICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgKi9cclxuICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAqL1xyXG4gIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgbiA9IHRoaXMsXHJcbiAgICAgIHMgPSBuLnMsXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgaWYgKHMpIHtcclxuICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICogbmVnYXRpdmUgemVyby5cclxuICAgKi9cclxuICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gIFBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdCaWdOdW1iZXInO1xyXG5cclxuICAvLyBOb2RlLmpzIHYxMC4xMi4wK1xyXG4gIFBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnZhbHVlT2Y7XHJcblxyXG4gIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICByZXR1cm4gQmlnTnVtYmVyO1xyXG59XHJcblxyXG5cclxuLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4vLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4vLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gIHZhciBpID0gbiB8IDA7XHJcbiAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbn1cclxuXHJcblxyXG4vLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgdmFyIHMsIHosXHJcbiAgICBpID0gMSxcclxuICAgIGogPSBhLmxlbmd0aCxcclxuICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gIGZvciAoOyBpIDwgajspIHtcclxuICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgciArPSBzO1xyXG4gIH1cclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbn1cclxuXHJcblxyXG4vLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbmZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gIHZhciBhLCBiLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5YyA9IHkuYyxcclxuICAgIGkgPSB4LnMsXHJcbiAgICBqID0geS5zLFxyXG4gICAgayA9IHguZSxcclxuICAgIGwgPSB5LmU7XHJcblxyXG4gIC8vIEVpdGhlciBOYU4/XHJcbiAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgYSA9IHhjICYmICF4Y1swXTtcclxuICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz9cclxuICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gIGEgPSBpIDwgMDtcclxuICBiID0gayA9PSBsO1xyXG5cclxuICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICovXHJcbmZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgIHRocm93IEVycm9yXHJcbiAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbmZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICB2YXIgbGVuLCB6cztcclxuXHJcbiAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgfSBlbHNlIHtcclxuICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciArPSB6cztcclxuICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59XHJcblxyXG5cclxuLy8gRVhQT1JUXHJcblxyXG5cclxuZXhwb3J0IHZhciBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmlnTnVtYmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhaZXJvUGFkLCBpc0J5dGVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBCaWdOdW1iZXIsIGlzQmlnTnVtYmVyaXNoIH0gZnJvbSBcIi4vYmlnbnVtYmVyXCI7XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuY29uc3QgWmVybyA9IEJpZ051bWJlci5mcm9tKDApO1xuY29uc3QgTmVnYXRpdmVPbmUgPSBCaWdOdW1iZXIuZnJvbSgtMSk7XG5mdW5jdGlvbiB0aHJvd0ZhdWx0KG1lc3NhZ2UsIGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG4gICAgY29uc3QgcGFyYW1zID0geyBmYXVsdDogZmF1bHQsIG9wZXJhdGlvbjogb3BlcmF0aW9uIH07XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG59XG4vLyBDb25zdGFudCB0byBwdWxsIHplcm9zIGZyb20gZm9yIG11bHRpcGxpZXJzXG5sZXQgemVyb3MgPSBcIjBcIjtcbndoaWxlICh6ZXJvcy5sZW5ndGggPCAyNTYpIHtcbiAgICB6ZXJvcyArPSB6ZXJvcztcbn1cbi8vIFJldHVybnMgYSBzdHJpbmcgXCIxXCIgZm9sbG93ZWQgYnkgZGVjaW1hbCBcIjBcInNcbmZ1bmN0aW9uIGdldE11bHRpcGxpZXIoZGVjaW1hbHMpIHtcbiAgICBpZiAodHlwZW9mIChkZWNpbWFscykgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gQmlnTnVtYmVyLmZyb20oZGVjaW1hbHMpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIChkZWNpbWFscykgPT09IFwibnVtYmVyXCIgJiYgZGVjaW1hbHMgPj0gMCAmJiBkZWNpbWFscyA8PSAyNTYgJiYgIShkZWNpbWFscyAlIDEpKSB7XG4gICAgICAgIHJldHVybiAoXCIxXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgc2l6ZVwiLCBcImRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgfVxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcbiAgICAvLyBNYWtlIHN1cmUgd2VpIGlzIGEgYmlnIG51bWJlciAoY29udmVydCBhcyBuZWNlc3NhcnkpXG4gICAgdmFsdWUgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSB2YWx1ZS5sdChaZXJvKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5tdWwoTmVnYXRpdmVPbmUpO1xuICAgIH1cbiAgICBsZXQgZnJhY3Rpb24gPSB2YWx1ZS5tb2QobXVsdGlwbGllcikudG9TdHJpbmcoKTtcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgbXVsdGlwbGllci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGZyYWN0aW9uID0gXCIwXCIgKyBmcmFjdGlvbjtcbiAgICB9XG4gICAgLy8gU3RyaXAgdHJhaW5pbmcgMFxuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ubWF0Y2goL14oWzAtOV0qWzEtOV18MCkoMCopLylbMV07XG4gICAgY29uc3Qgd2hvbGUgPSB2YWx1ZS5kaXYobXVsdGlwbGllcikudG9TdHJpbmcoKTtcbiAgICBpZiAobXVsdGlwbGllci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFsdWUgPSB3aG9sZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gd2hvbGUgKyBcIi5cIiArIGZyYWN0aW9uO1xuICAgIH1cbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgdmFsdWUgPSBcIi1cIiArIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgfVxuICAgIGNvbnN0IG11bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eLT9bMC05Ll0rJC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIElzIGl0IG5lZ2F0aXZlP1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gKHZhbHVlLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIpO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBcIi5cIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU3BsaXQgaXQgaW50byBhIHdob2xlIGFuZCBmcmFjdGlvbmFsIHBhcnRcbiAgICBjb25zdCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9vIG1hbnkgZGVjaW1hbCBwb2ludHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGxldCB3aG9sZSA9IGNvbXBzWzBdLCBmcmFjdGlvbiA9IGNvbXBzWzFdO1xuICAgIGlmICghd2hvbGUpIHtcbiAgICAgICAgd2hvbGUgPSBcIjBcIjtcbiAgICB9XG4gICAgaWYgKCFmcmFjdGlvbikge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBUcmltIHRyYWlsaW5nIHplcm9zXG4gICAgd2hpbGUgKGZyYWN0aW9uW2ZyYWN0aW9uLmxlbmd0aCAtIDFdID09PSBcIjBcIikge1xuICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLnN1YnN0cmluZygwLCBmcmFjdGlvbi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhlIGZyYWN0aW9uIGRvZXNuJ3QgZXhjZWVkIG91ciBkZWNpbWFscyBzaXplXG4gICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvd0ZhdWx0KFwiZnJhY3Rpb25hbCBjb21wb25lbnQgZXhjZWVkcyBkZWNpbWFsc1wiLCBcInVuZGVyZmxvd1wiLCBcInBhcnNlRml4ZWRcIik7XG4gICAgfVxuICAgIC8vIElmIGRlY2ltYWxzIGlzIDAsIHdlIGhhdmUgYW4gZW1wdHkgc3RyaW5nIGZvciBmcmFjdGlvblxuICAgIGlmIChmcmFjdGlvbiA9PT0gXCJcIikge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiO1xuICAgIH1cbiAgICAvLyBGdWxseSBwYWQgdGhlIHN0cmluZyB3aXRoIHplcm9zIHRvIGdldCB0byB3ZWlcbiAgICB3aGlsZSAoZnJhY3Rpb24ubGVuZ3RoIDwgbXVsdGlwbGllci5sZW5ndGggLSAxKSB7XG4gICAgICAgIGZyYWN0aW9uICs9IFwiMFwiO1xuICAgIH1cbiAgICBjb25zdCB3aG9sZVZhbHVlID0gQmlnTnVtYmVyLmZyb20od2hvbGUpO1xuICAgIGNvbnN0IGZyYWN0aW9uVmFsdWUgPSBCaWdOdW1iZXIuZnJvbShmcmFjdGlvbik7XG4gICAgbGV0IHdlaSA9ICh3aG9sZVZhbHVlLm11bChtdWx0aXBsaWVyKSkuYWRkKGZyYWN0aW9uVmFsdWUpO1xuICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICB3ZWkgPSB3ZWkubXVsKE5lZ2F0aXZlT25lKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlaTtcbn1cbmV4cG9ydCBjbGFzcyBGaXhlZEZvcm1hdCB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWRGb3JtYXQgY29uc3RydWN0b3I7IHVzZSBGaXhlZEZvcm1hdC5mcm9tXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGaXhlZEZvcm1hdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpZ25lZCA9IHNpZ25lZDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmRlY2ltYWxzID0gZGVjaW1hbHM7XG4gICAgICAgIHRoaXMubmFtZSA9IChzaWduZWQgPyBcIlwiIDogXCJ1XCIpICsgXCJmaXhlZFwiICsgU3RyaW5nKHdpZHRoKSArIFwieFwiICsgU3RyaW5nKGRlY2ltYWxzKTtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IGdldE11bHRpcGxpZXIoZGVjaW1hbHMpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGaXhlZEZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFsdWUgPSBgZml4ZWQxMjh4JHt2YWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduZWQgPSB0cnVlO1xuICAgICAgICBsZXQgd2lkdGggPSAxMjg7XG4gICAgICAgIGxldCBkZWNpbWFscyA9IDE4O1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBcInVmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKHU/KWZpeGVkKFswLTldKyl4KFswLTldKykkLyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWduZWQgPSAobWF0Y2hbMV0gIT09IFwidVwiKTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcbiAgICAgICAgICAgICAgICBkZWNpbWFscyA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSAoa2V5LCB0eXBlLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlW2tleV0pICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2YWx1ZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2lnbmVkID0gY2hlY2soXCJzaWduZWRcIiwgXCJib29sZWFuXCIsIHNpZ25lZCk7XG4gICAgICAgICAgICB3aWR0aCA9IGNoZWNrKFwid2lkdGhcIiwgXCJudW1iZXJcIiwgd2lkdGgpO1xuICAgICAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggJSA4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjaW1hbHMgPiA4MCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChkZWNpbWFscyB0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZpeGVkRm9ybWF0KF9jb25zdHJ1Y3Rvckd1YXJkLCBzaWduZWQsIHdpZHRoLCBkZWNpbWFscyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZpeGVkTnVtYmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCB1c2UgRml4ZWROdW1iZXIgY29uc3RydWN0b3I7IHVzZSBGaXhlZE51bWJlci5mcm9tXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGaXhlZEZvcm1hdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9pc0ZpeGVkTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgX2NoZWNrRm9ybWF0KG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdC5uYW1lICE9PSBvdGhlci5mb3JtYXQubmFtZSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLCBcIm90aGVyXCIsIG90aGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5hZGQoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIHN1YlVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLnN1YihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgbXVsVW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEubXVsKGIpLmRpdih0aGlzLmZvcm1hdC5fbXVsdGlwbGllciksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIGRpdlVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bCh0aGlzLmZvcm1hdC5fbXVsdGlwbGllcikuZGl2KGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBmbG9vcigpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gRml4ZWROdW1iZXIuZnJvbShjb21wc1swXSwgdGhpcy5mb3JtYXQpO1xuICAgICAgICBjb25zdCBoYXNGcmFjdGlvbiA9ICFjb21wc1sxXS5tYXRjaCgvXigwKikkLyk7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YlVuc2FmZShPTkUudG9Gb3JtYXQocmVzdWx0LmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNlaWxpbmcoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgaGFzRnJhY3Rpb24gPSAhY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO1xuICAgICAgICBpZiAoIXRoaXMuaXNOZWdhdGl2ZSgpICYmIGhhc0ZyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkVW5zYWZlKE9ORS50b0Zvcm1hdChyZXN1bHQuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gQFRPRE86IFN1cHBvcnQgb3RoZXIgcm91bmRpbmcgYWxnb3JpdGhtc1xuICAgIHJvdW5kKGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gcmFuZ2UsIHdlJ3JlIGRvbmVcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb21wcy5wdXNoKFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjaW1hbHMgPCAwIHx8IGRlY2ltYWxzID4gODAgfHwgKGRlY2ltYWxzICUgMSkpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGRlY2ltYWwgY291bnRcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBzWzFdLmxlbmd0aCA8PSBkZWNpbWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yID0gRml4ZWROdW1iZXIuZnJvbShcIjFcIiArIHplcm9zLnN1YnN0cmluZygwLCBkZWNpbWFscyksIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgYnVtcCA9IEJVTVAudG9Gb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWxVbnNhZmUoZmFjdG9yKS5hZGRVbnNhZmUoYnVtcCkuZmxvb3IoKS5kaXZVbnNhZmUoZmFjdG9yKTtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlID09PSBcIjAuMFwiIHx8IHRoaXMuX3ZhbHVlID09PSBcIjBcIik7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWVbMF0gPT09IFwiLVwiKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl92YWx1ZTsgfVxuICAgIHRvSGV4U3RyaW5nKHdpZHRoKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCAlIDgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGUgd2lkdGhcIiwgXCJ3aWR0aFwiLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4ID0gQmlnTnVtYmVyLmZyb20odGhpcy5faGV4KS5mcm9tVHdvcyh0aGlzLmZvcm1hdC53aWR0aCkudG9Ud29zKHdpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZChoZXgsIHdpZHRoIC8gOCk7XG4gICAgfVxuICAgIHRvVW5zYWZlRmxvYXQoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSk7IH1cbiAgICB0b0Zvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy5fdmFsdWUsIGZvcm1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVmFsdWUodmFsdWUsIGRlY2ltYWxzLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgZGVjaW1hbHMgbG9va3MgbW9yZSBsaWtlIGEgZm9ybWF0LCBhbmQgdGhlcmUgaXMgbm8gZm9ybWF0LCBzaGlmdCB0aGUgcGFyYW1ldGVyc1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwgJiYgZGVjaW1hbHMgIT0gbnVsbCAmJiAhaXNCaWdOdW1iZXJpc2goZGVjaW1hbHMpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBkZWNpbWFscztcbiAgICAgICAgICAgIGRlY2ltYWxzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKGZvcm1hdEZpeGVkKHZhbHVlLCBkZWNpbWFscyksIEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZml4ZWRGb3JtYXQgPSBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7XG4gICAgICAgIGNvbnN0IG51bWVyaWMgPSBwYXJzZUZpeGVkKHZhbHVlLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGlmICghZml4ZWRGb3JtYXQuc2lnbmVkICYmIG51bWVyaWMubHQoWmVybykpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bnNpZ25lZCB2YWx1ZSBjYW5ub3QgYmUgbmVnYXRpdmVcIiwgXCJvdmVyZmxvd1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKGZpeGVkRm9ybWF0LnNpZ25lZCkge1xuICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b1R3b3MoZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZXggPSBudW1lcmljLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICBoZXggPSBoZXhaZXJvUGFkKGhleCwgZml4ZWRGb3JtYXQud2lkdGggLyA4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuICAgICAgICBpZiAoYXJyYXlpZnkodmFsdWUpLmxlbmd0aCA+IGZpeGVkRm9ybWF0LndpZHRoIC8gOCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3ZlcmZsb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bWVyaWMgPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIG51bWVyaWMgPSBudW1lcmljLmZyb21Ud29zKGZpeGVkRm9ybWF0LndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXggPSBudW1lcmljLnRvVHdvcygoZml4ZWRGb3JtYXQuc2lnbmVkID8gMCA6IDEpICsgZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGRlY2ltYWwgPSBmb3JtYXRGaXhlZChudW1lcmljLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodmFsdWUsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbUJ5dGVzKHZhbHVlLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKHZhbHVlLCAwLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQWxsb3cgTlVNRVJJQ19GQVVMVCB0byBidWJibGUgdXBcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRml4ZWROdW1iZXIgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0ZpeGVkTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNGaXhlZE51bWJlcik7XG4gICAgfVxufVxuY29uc3QgT05FID0gRml4ZWROdW1iZXIuZnJvbSgxKTtcbmNvbnN0IEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zml4ZWRudW1iZXIuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInVuaXRzLzUuNy4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGZvcm1hdEZpeGVkLCBwYXJzZUZpeGVkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgbmFtZXMgPSBbXG4gICAgXCJ3ZWlcIixcbiAgICBcImt3ZWlcIixcbiAgICBcIm13ZWlcIixcbiAgICBcImd3ZWlcIixcbiAgICBcInN6YWJvXCIsXG4gICAgXCJmaW5uZXlcIixcbiAgICBcImV0aGVyXCIsXG5dO1xuLy8gU29tZSBlbnZpcm9ubWVudHMgaGF2ZSBpc3N1ZXMgd2l0aCBSZWdFeCB0aGF0IGNvbnRhaW4gYmFjay10cmFja2luZywgc28gd2UgY2Fubm90XG4vLyB1c2UgdGhlbS5cbmV4cG9ydCBmdW5jdGlvbiBjb21taWZ5KHZhbHVlKSB7XG4gICAgY29uc3QgY29tcHMgPSBTdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAoY29tcHMubGVuZ3RoID4gMiB8fCAhY29tcHNbMF0ubWF0Y2goL14tP1swLTldKiQvKSB8fCAoY29tcHNbMV0gJiYgIWNvbXBzWzFdLm1hdGNoKC9eWzAtOV0qJC8pKSB8fCB2YWx1ZSA9PT0gXCIuXCIgfHwgdmFsdWUgPT09IFwiLS5cIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lIHdob2xlIGRpZ2l0ICgwIGlmIG5vbmUpXG4gICAgbGV0IHdob2xlID0gY29tcHNbMF07XG4gICAgbGV0IG5lZ2F0aXZlID0gXCJcIjtcbiAgICBpZiAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIikge1xuICAgICAgICBuZWdhdGl2ZSA9IFwiLVwiO1xuICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYXQgbGVhc3QgMSB3aG9sZSBkaWdpdCB3aXRoIG5vIGxlYWRpbmcgemVyb3NcbiAgICB3aGlsZSAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIjBcIikge1xuICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgaWYgKHdob2xlID09PSBcIlwiKSB7XG4gICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgfVxuICAgIGxldCBzdWZmaXggPSBcIlwiO1xuICAgIGlmIChjb21wcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgc3VmZml4ID0gXCIuXCIgKyAoY29tcHNbMV0gfHwgXCIwXCIpO1xuICAgIH1cbiAgICB3aGlsZSAoc3VmZml4Lmxlbmd0aCA+IDIgJiYgc3VmZml4W3N1ZmZpeC5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgc3VmZml4ID0gc3VmZml4LnN1YnN0cmluZygwLCBzdWZmaXgubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IFtdO1xuICAgIHdoaWxlICh3aG9sZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHdob2xlLmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gd2hvbGUubGVuZ3RoIC0gMztcbiAgICAgICAgICAgIGZvcm1hdHRlZC51bnNoaWZ0KHdob2xlLnN1YnN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWdhdGl2ZSArIGZvcm1hdHRlZC5qb2luKFwiLFwiKSArIHN1ZmZpeDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcbiAgICBpZiAodHlwZW9mICh1bml0TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXROYW1lKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdW5pdE5hbWUgPSAzICogaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdEZpeGVkKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHVuaXROYW1lID0gMyAqIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUZpeGVkKHZhbHVlLCAodW5pdE5hbWUgIT0gbnVsbCkgPyB1bml0TmFtZSA6IDE4KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFdGhlcih3ZWkpIHtcbiAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCAxOCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VFdGhlcihldGhlcikge1xuICAgIHJldHVybiBwYXJzZVVuaXRzKGV0aGVyLCAxOCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcclxuaW1wb3J0IHtldGhlcnN9IGZyb20gXCJldGhlcnNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBzaG93Q29udGFpbmVyID0gZnVuY3Rpb24oaWQgOiBzdHJpbmcpIHtcclxuICAgIGxldCBjb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbnRhaW5lcicpO1xyXG4gICAgZm9yIChsZXQgaT0wO2k8Y29udGFpbmVycy5sZW5ndGg7aSsrKSB7XHJcblx0XHRsZXQgZWxlbWVudCA9IGNvbnRhaW5lcnNbaV0gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaWQgPT0gaWQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuXHRcdFx0ZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB9IGVsc2Uge1xyXG5cdFx0XHRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgcm91bmROdW1iZXIgPSBmdW5jdGlvbiAobnVtYmVyOiBudW1iZXIpIHtcclxuXHRyZXR1cm4gTWF0aC5yb3VuZChudW1iZXIgKiAxMDApIC8gMTAwO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgcm91bmROdW1iZXJEZWNpbWFsID0gZnVuY3Rpb24gKG51bWJlcjogbnVtYmVyLCBkZWNpbWFsOiBudW1iZXIpIHtcclxuXHRsZXQgaHVuZHJlZCA9IHBhcnNlSW50KCcxJyArICcwJy5yZXBlYXQoZGVjaW1hbCkpO1xyXG5cdHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIGh1bmRyZWQpIC8gaHVuZHJlZDtcclxufVxyXG5leHBvcnQgY29uc3QgZm9ybWF0V2VpQXNDdXJyZW5jeSA9IGZ1bmN0aW9uIChudW1iZXI6IEJpZ051bWJlcik6IHN0cmluZyB7XHJcblx0cmV0dXJuICckJyArIGV0aGVycy51dGlscy5mb3JtYXRFdGhlcihudW1iZXIudG9TdHJpbmcoKSlcclxufVxyXG5leHBvcnQgY29uc3QgZm9ybWF0V2VpID0gZnVuY3Rpb24gKG51bWJlcjogQmlnTnVtYmVyKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gZXRoZXJzLnV0aWxzLmZvcm1hdEV0aGVyKG51bWJlci50b1N0cmluZygpKVxyXG59XHJcbmV4cG9ydCBjb25zdCByb3VuZEJpZ051bWJlciA9IGZ1bmN0aW9uIChudW1iZXI6IEJpZ051bWJlcik6IEJpZ051bWJlciB7XHJcblx0cmV0dXJuIG5ldyBCaWdOdW1iZXIoTWF0aC5yb3VuZChudW1iZXIudG9OdW1iZXIoKSAqIDEwMCkgLyAxMDApO1xyXG59XHJcbmV4cG9ydCBjb25zdCByb3VuZEJpZ051bWJlckRlY2ltYWwgPSBmdW5jdGlvbiAobnVtYmVyOiBCaWdOdW1iZXIsIGRlY2ltYWw6IG51bWJlcik6IEJpZ051bWJlciB7XHJcblx0bGV0IGh1bmRyZWQgPSBwYXJzZUludCgnMScgKyAnMCcucmVwZWF0KGRlY2ltYWwpKTtcclxuXHRyZXR1cm4gbmV3IEJpZ051bWJlcihNYXRoLnJvdW5kKG51bWJlci50b051bWJlcigpICogaHVuZHJlZCkgLyBodW5kcmVkKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEFkZHJlc3NaZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0pTT04gPSBmdW5jdGlvbiAoc3RyOiBzdHJpbmcpOiBhbnkge1xyXG5cdHRyeSB7XHJcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBldGhlcmV1bUluc3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcclxuXHR0cnkge1xyXG5cdFx0cmV0dXJuICh0eXBlb2YgZXRoZXJldW0gIT09ICd1bmRlZmluZWQnKTtcclxuXHR9IGNhdGNoIChlOiBhbnkpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn1cclxuZXhwb3J0IGNvbnN0IHNob3J0RXRoID0gZnVuY3Rpb24gKGV0aEFkZHJlc3M6IHN0cmluZykge1xyXG5cdGlmICghZXRoQWRkcmVzcykgcmV0dXJuICcnO1xyXG5cclxuXHRyZXR1cm4gZXRoQWRkcmVzcy5zdWJzdHJpbmcoMCwgNikgKyBcIi4uLlwiICsgZXRoQWRkcmVzcy5zdWJzdHJpbmcoZXRoQWRkcmVzcy5sZW5ndGggLSA0KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCB1cHBlckZpcnN0TGV0dGVyID0gZnVuY3Rpb24gKHRleHQ6IHN0cmluZykge1xyXG5cdHJldHVybiB0ZXh0WzBdLnRvVXBwZXJDYXNlKCkgKyB0ZXh0LnN1YnN0cmluZygxKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IHNob3dCYXIgPSBmdW5jdGlvbiAodGV4dDogc3RyaW5nKSB7XHJcblx0bGV0IGhlYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWRlcicpO1xyXG5cdGlmICghaGVhZGVyKSByZXR1cm47XHJcblx0bGV0IHdhcm5pbmdIdG1sID0gJzxkaXYgY2xhc3M9XCJlcnJvckJhclwiPicgKyB0ZXh0ICsgJzwvZGl2Pic7XHJcblx0aGVhZGVyLmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlYmVnaW4nLCB3YXJuaW5nSHRtbCk7XHJcbn1cclxuIiwiaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgU3dpdGNoTmV0d29ya01vZGFsIGZyb20gXCIuLi8uLi91aS9tb2RhbHMvU3dpdGNoTmV0d29ya01vZGFsXCI7XHJcbmltcG9ydCBNYWdpY1dlYjNDb25uZWN0b3IgZnJvbSBcIi4uLy4uL3dhbGxldC9NYWdpY1dlYjNDb25uZWN0b3JcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQgQmFzZVNlcnZpY2UgZnJvbSBcIi4vQmFzZVNlcnZpY2VcIjtcclxuaW1wb3J0IENvb2tpZUhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9Db29raWVIZWxwZXJcIjtcclxuaW1wb3J0IFVzZXIgZnJvbSBcIi4uLy4uL2R0by9Vc2VyXCI7XHJcbmltcG9ydCB7c2hvd0Jhcn0gZnJvbSBcIi4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRoZW50aWNhdGVTZXJ2aWNlIGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZW5hYmxlV2ViMygpIHtcclxuICAgICAgICBpZiAoQXBwLlVzZXIuY29ubmVjdG9yKSByZXR1cm4gQXBwLlVzZXIuY29ubmVjdG9yO1xyXG5cclxuICAgICAgICBsZXQgbWFnaWNXZWIzQ29ubmVjdG9yID0gbmV3IE1hZ2ljV2ViM0Nvbm5lY3RvcigpO1xyXG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBhd2FpdCBtYWdpY1dlYjNDb25uZWN0b3IuYWN0aXZhdGUoKTtcclxuICAgICAgICBBcHAuVXNlci5jb25uZWN0b3IgPSBjb25uZWN0b3I7XHJcbiAgICAgICAgQXBwLlVzZXIubWFnaWMgPSBjb25uZWN0b3IubWFnaWM7XHJcbiAgICAgICAgQXBwLlVzZXIucHJvdmlkZXIgPSBjb25uZWN0b3IucHJvdmlkZXI7XHJcbiAgICAgICAgQXBwLlVzZXIuZXRoZXIgPSBjb25uZWN0b3IuZXRoZXI7XHJcbiAgICAgICAgQXBwLlVzZXIuc2lnbmVyID0gY29ubmVjdG9yLnNpZ25lcjtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9nT3V0KCkge1xyXG4gICAgICAgIGxldCBjb29raWVIZWxwZXIgPSBuZXcgQ29va2llSGVscGVyKGRvY3VtZW50KTtcclxuICAgICAgICBjb29raWVIZWxwZXIuZGVsZXRlQ29va2llKCd2YWxpZGF0ZScpO1xyXG4gICAgICAgIGlmICghQXBwLlVzZXIuZXRoZXIpIHtcclxuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjMoKTtcclxuICAgICAgICAgICAgQXBwLlVzZXIubWFnaWMgPSBjb25uZWN0aW9uLm1hZ2ljO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBcHAuVXNlci5tYWdpYy5jb25uZWN0LmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICBBcHAuVXNlciA9IG5ldyBVc2VyKG51bGwsICcnLCBBcHAuTmV0d29yay5DaGFpbklkLCAnJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvZ2luKCkge1xyXG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjMoKTtcclxuICAgICAgICBBcHAuVXNlciA9IG5ldyBVc2VyKGNvbm5lY3Rvci5wcm92aWRlciwgY29ubmVjdG9yLmFjY291bnQsIGNvbm5lY3Rvci5jaGFpbklkLCBjb25uZWN0b3IuZXRoZXIpO1xyXG4gICAgICAgIEFwcC5Vc2VyLm1hZ2ljID0gY29ubmVjdG9yLm1hZ2ljO1xyXG4gICAgICAgIEFwcC5Vc2VyLnNpZ25lciA9IGNvbm5lY3Rvci5zaWduZXI7XHJcbiAgICAgICAgQXBwLlVzZXIuaXNMb2dnZWRJbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGlzQXV0aGVudGljYXRlZCgpIHtcclxuICAgICAgICBsZXQgY29va2llSGVscGVyID0gbmV3IENvb2tpZUhlbHBlcigpO1xyXG4gICAgICAgIGxldCB2YWxpZGF0ZSA9IGNvb2tpZUhlbHBlci5nZXRDb29raWVWYWx1ZSgndmFsaWRhdGUnKTtcclxuICAgICAgICBpZiAoIXZhbGlkYXRlKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKGF0b2IodmFsaWRhdGUpKTtcclxuICAgICAgICAgICAgQXBwLlVzZXIudG9rZW4gPSBvYmoudG9rZW47XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5wb3N0KCcvbWUvand0Jyk7XHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0Lmp3dCkge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2dPdXQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXdhaXQgQXV0aGVudGljYXRlU2VydmljZS5lbmFibGVXZWIzKCk7XHJcblxyXG4gICAgICAgICAgICBBcHAuVXNlci5hZGRyZXNzID0gb2JqLmFkZHJlc3M7XHJcbiAgICAgICAgICAgIEFwcC5Vc2VyLmFscGFjYUlkID0gb2JqLmFscGFjYUlkO1xyXG4gICAgICAgICAgICBBcHAuVXNlci5jaGFpbklkID0gb2JqLmNoYWluSWQ7XHJcbiAgICAgICAgICAgIEFwcC5Vc2VyLmlzTG9nZ2VkSW4gPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XHJcbiAgICAgICAgICAgIGNvb2tpZUhlbHBlci5kZWxldGVDb29raWUoJ3ZhbGlkYXRlJyk7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBhdXRoZW50aWNhdGVVc2VyKGVuYWJsZVdlYjNDYWxsYmFjaz86ICh3YWxsZXRDb25uZWN0aW9uSW5mbzogYW55KSA9PiB2b2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRlZENhbGxiYWNrPzogKCkgPT4gdm9pZFxyXG4gICAgKSB7XHJcblxyXG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjMoKTtcclxuXHJcbiAgICAgICAgaWYgKGVuYWJsZVdlYjNDYWxsYmFjayAmJiBjb25uZWN0b3IucHJvdmlkZXIpIHtcclxuICAgICAgICAgICAgZW5hYmxlV2ViM0NhbGxiYWNrKGNvbm5lY3Rvci5wcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY29ubmVjdG9yLmNoYWluSWQgIT0gQXBwLk5ldHdvcmsuQ2hhaW5JZCkge1xyXG4gICAgICAgICAgICBsZXQgdXNlck5ldHdvcmsgPSBOZXR3b3JrSW5mby5nZXROZXR3b3JrSW5mb0J5Q2hhaW5JZChjb25uZWN0b3IuY2hhaW5JZCk7XHJcbiAgICAgICAgICAgIGlmICh1c2VyTmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgTmV0d29ya0luZm8uc2V0TmV0d29ya0J5Q2hhaW5JZChjb25uZWN0b3IuY2hhaW5JZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbW9kYWwgPSBuZXcgU3dpdGNoTmV0d29ya01vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdDxhbnk+KCcvbWUvbm9uY2UnLCB7YWRkcmVzczogY29ubmVjdG9yLmFjY291bnR9KVxyXG5cclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIHNpZ25pbmdNZXNzYWdlOiBcIllvdSBhcmUgbG9nZ2luZyBpbnRvIExpbWluYWwubWFya2V0Llxcblxcbk5vbmNlOlwiICsgcmVzcG9uc2Uubm9uY2UsXHJcbiAgICAgICAgICAgIGNvbm5lY3RvcjogTWFnaWNXZWIzQ29ubmVjdG9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZygnaXNXZWJ2aWV3JywgV2FsbGV0SGVscGVyLmlzV2VidmlldygpKTtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgY29uc29sZS5sb2coJ0V0aGVyZXVtJywgd2luZG93LmV0aGVyZXVtKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ2Nvbm5lY3Rvci5ldGhlcicsIGNvbm5lY3Rvci5ldGhlcik7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ25ldHdvcmsnLCBBcHAuTmV0d29yayk7XHJcblxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBpZiAod2luZG93LmV0aGVyZXVtKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0V0aGVyZXVtJywgd2luZG93LmV0aGVyZXVtLm5ldHdvcmtWZXJzaW9uLCB3aW5kb3cuZXRoZXJldW0uY2hhaW5JZCwgQXBwLk5ldHdvcmsuQ2hhaW5JZEhleCk7XHJcbiAgICAgICAgICAgIGlmIChXYWxsZXRIZWxwZXIuaXNXZWJ2aWV3KCkpIHtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjYWxsaW5nIHNpZ25NZXNzYWdlJyk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVkTWVzc2FnZSA9IGF3YWl0IGNvbm5lY3Rvci5ldGhlci5nZXRTaWduZXIoKVxyXG4gICAgICAgICAgICAuc2lnbk1lc3NhZ2Uob2JqLnNpZ25pbmdNZXNzYWdlKVxyXG4gICAgICAgICAgICAuY2F0Y2goKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5tZXNzYWdlICYmIGUubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dyb25nIG5ldHdvcmsnKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3dCYXIoJ1lvdXIgd2FsbGV0IGlzIG9uIHdyb25nIG5ldHdvcmsuIEkgZXhwZWN0IHlvdSB0byBiZSBvbiAnICsgQXBwLk5ldHdvcmsuTmFtZSArICcoY2hhaW5JZDonICsgQXBwLk5ldHdvcmsuQ2hhaW5JZCArICcpIG5ldHdvcmsnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvd0JhcignRXJyb3Igc2lnbmluZyBpbjonICsgZS5tZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXNpZ25lZE1lc3NhZ2UpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGxvZ2luUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3Q8YW55PignbWUvdmFsaWRhdGUnLCB7YWRkcmVzczogY29ubmVjdG9yLmFjY291bnQsIHNpZ25lZE1lc3NhZ2V9KTtcclxuXHJcbiAgICAgICAgaWYgKCFsb2dpblJlc3BvbnNlLmFkZHJlc3MpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2dPdXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgQXBwLlVzZXIuc2V0VmFsaWRhdGUobG9naW5SZXNwb25zZSk7XHJcbiAgICAgICAgQXBwLlVzZXIudG9rZW4gPSBsb2dpblJlc3BvbnNlLnRva2VuO1xyXG4gICAgICAgIEFwcC5Vc2VyLmFscGFjYUlkID0gbG9naW5SZXNwb25zZS5hbHBhY2FJZDtcclxuICAgICAgICBBcHAuVXNlci5hZGRyZXNzID0gbG9naW5SZXNwb25zZS5hZGRyZXNzO1xyXG4gICAgICAgIEFwcC5Vc2VyLmlzTG9nZ2VkSW4gPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoYXV0aGVudGljYXRlZENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0ZWRDYWxsYmFjaygpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59IiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFiaS81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgY2xhc3MgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICAvLyBAVE9ETzogZGVmaW5lUmVhZE9ubHkgdGhlc2VcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE5hbWU7XG4gICAgICAgIHRoaXMuZHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkU2l6ZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KHdvcmRTaXplKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLl9kYXRhTGVuZ3RoOyB9XG4gICAgX3dyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhcHBlbmRXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoY29uY2F0KHdyaXRlci5fZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtczsgcGFkZGVkIG9uIHRoZSByaWdodCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBjb25zdCBwYWRkaW5nT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gY29uY2F0KFtieXRlcywgdGhpcy5fcGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoYnl0ZXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odmFsdWUpKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMud29yZFNpemUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLndvcmRTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuICAgICAgICAgICAgYnl0ZXMgPSBjb25jYXQoW3RoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSksIGJ5dGVzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvLyBCaWdOdW1iZXJpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgbGVmdCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YSh0aGlzLl9nZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICB3cml0ZVVwZGF0YWJsZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKHRoaXMuX3BhZGRpbmcpO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IHRoaXMud29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbb2Zmc2V0XSA9IHRoaXMuX2dldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB3b3JkU2l6ZSwgY29lcmNlRnVuYywgYWxsb3dMb29zZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9kYXRhXCIsIGFycmF5aWZ5KGRhdGEpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxsb3dMb29zZVwiLCBhbGxvd0xvb3NlKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuX2RhdGEpOyB9XG4gICAgZ2V0IGNvbnN1bWVkKCkgeyByZXR1cm4gdGhpcy5fb2Zmc2V0OyB9XG4gICAgLy8gVGhlIGRlZmF1bHQgQ29lcmNlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGNvZXJjZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBuYW1lLm1hdGNoKFwiXnU/aW50KFswLTldKykkXCIpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0pIDw9IDQ4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb2VyY2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvZXJjZUZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhZGVyLmNvZXJjZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIF9wZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMud29yZFNpemUpICogdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLl9vZmZzZXQgKyBsZW5ndGggPD0gdGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy53b3JkU2l6ZSwgdGhpcy5fY29lcmNlRnVuYywgdGhpcy5hbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy5fcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMucmVhZEJ5dGVzKHRoaXMud29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgaGV4WmVyb1BhZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGhleFplcm9QYWQocmVhZGVyLnJlYWRWYWx1ZSgpLnRvSGV4U3RyaW5nKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbi8vIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCB1bmRlZmluZWQsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQ29kZXIsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91c1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIG5hbWVzXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pcXVlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGlmIChjb2RlcnMubGVuZ3RoICE9PSBhcnJheVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzL3ZhbHVlIGxlbmd0aCBtaXNtYXRjaFwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGxldCBzdGF0aWNXcml0ZXIgPSBuZXcgV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xuICAgIC8vIEFkZCBhbnkgbmFtZWQgcGFyYW1ldGVycyAoaS5lLiB0dXBsZXMpXG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgdmFsdWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIGksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4geyB0aHJvdyB2YWx1ZTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbn1cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAvLyBWZXJpZmllcyB0aGUgY2hpbGQgY29kZXIgaXMgdmFsaWQgKGV2ZW4gaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMgb3IgMC1sZW5ndGgpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzICpyb3VnaGx5KiBlbm91Z2ggZGF0YSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIHN0cmF5IHJhbmRvbSBkYXRhIGlzIG5vdCBiZWluZyByZWFkIGFzIGEgbGVuZ3RoLiBFYWNoXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcbiAgICAgICAgICAgIC8vIGJ5dGVzIGFzIGEgbGluayB0byB0aGUgZGF0YSkuIFRoaXMgY291bGQgdXNlIGEgbXVjaFxuICAgICAgICAgICAgLy8gdGlnaHRlciBib3VuZCwgYnV0IHdlIGFyZSBlcnJvcmluZyBvbiB0aGUgc2lkZSBvZiBzYWZldHkuXG4gICAgICAgICAgICBpZiAoY291bnQgKiAzMiA+IHJlYWRlci5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcmVhZGVyLl9kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKG5ldyBBbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB1bnBhY2socmVhZGVyLCBjb2RlcnMpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy50eXBlLCAhcmVhZGVyLnJlYWRWYWx1ZSgpLmlzWmVybygpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4bGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuLy8gQFRPRE86IE1lcmdlIHRoaXMgd2l0aCBieXRlc1xuZXhwb3J0IGNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIE51bGxDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoW10pO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZWFkQnl0ZXMoMCk7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbnVsbCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IE1heFVpbnQyNTYsIE5lZ2F0aXZlT25lLCBPbmUsIFplcm8gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5zaWduZWQgPSBzaWduZWQ7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCB2ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBNYXhVaW50MjU2Lm1hc2sod3JpdGVyLndvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDggLSAxKTtcbiAgICAgICAgICAgIGlmICh2Lmd0KGJvdW5kcykgfHwgdi5sdChib3VuZHMuYWRkKE9uZSkubXVsKE5lZ2F0aXZlT25lKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodi5sdChaZXJvKSB8fCB2Lmd0KG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDgpKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHYgPSB2LnRvVHdvcyh0aGlzLnNpemUgKiA4KS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHYgPSB2LmZyb21Ud29zKHRoaXMuc2l6ZSAqIDgpLnRvVHdvcyg4ICogd3JpdGVyLndvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodik7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcmVhZGVyLnJlYWRWYWx1ZSgpLm1hc2sodGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXNcIjtcbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKHZhbHVlKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXlcIjtcbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgc3VwZXIoXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVycyA9IGNvZGVycztcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB1bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuO1xuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmxldCBNb2RpZmllcnNCeXRlcyA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSwgc3RvcmFnZTogdHJ1ZSB9O1xubGV0IE1vZGlmaWVyc05lc3QgPSB7IGNhbGxkYXRhOiB0cnVlLCBtZW1vcnk6IHRydWUgfTtcbmZ1bmN0aW9uIGNoZWNrTW9kaWZpZXIodHlwZSwgbmFtZSkge1xuICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoTW9kaWZpZXJzQnl0ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcInBheWFibGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5pbmRleE9mKFwiW1wiKSA+PSAwIHx8IHR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICBpZiAoTW9kaWZpZXJzTmVzdFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdIHx8IG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1vZGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGF0IGNoaWxkcmVuIG9mIGFuIGluZGV4ZWQgdHVwbGUgYXJlIG1hcmtlZCB3aXRoIGEgbnVsbCBpbmRleGVkXG5mdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSwgYWxsb3dJbmRleGVkKSB7XG4gICAgbGV0IG9yaWdpbmFsUGFyYW0gPSBwYXJhbTtcbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKGkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gJHtpfWAsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgIH1cbiAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG4gICAgZnVuY3Rpb24gbmV3Tm9kZShwYXJlbnQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHBhcmVudDogcGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuICAgICAgICBpZiAoYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICBub2RlLmluZGV4ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHsgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gcGFyYW1baV07XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUgJiYgbm9kZS50eXBlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5vZGUuc3RhdGUuYWxsb3dQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1R5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jb21wb25lbnRzID0gW25ld05vZGUobm9kZSldO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNvbXBvbmVudHNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nID0gbmV3Tm9kZShub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgLy97IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHBhcmVudDogbm9kZS5wYXJlbnQsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEhpdCBhIHNwYWNlLi4uXG4gICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgdHlwZSwgdGhlIHR5cGUgaXMgZG9uZSBhbmQgbWF5IHJlYWQgYSBwYXJhbSBvciBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgbmFtZSwgdGhlIG5hbWUgaXMgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXRlLmFsbG93QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLnJlYWRBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5yZWFkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5hbGxvd05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIGVvZlwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZGVsZXRlIHBhcmVudC5zdGF0ZTtcbiAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGggLSA3KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBwYXJlbnQudHlwZSA9IHZlcmlmeVR5cGUocGFyZW50LnR5cGUpO1xuICAgIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QsIHBhcmFtcykge1xuICAgIGZvciAobGV0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBrZXksIHBhcmFtc1trZXldKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgRm9ybWF0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvLyBCYXJlIGZvcm1hdHRpbmcsIGFzIGlzIG5lZWRlZCBmb3IgY29tcHV0aW5nIGEgc2lnaGFzaCBvZiBhbiBldmVudCBvciBmdW5jdGlvblxuICAgIHNpZ2hhc2g6IFwic2lnaGFzaFwiLFxuICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggTWluaW1hbCBzcGFjaW5nIGFuZCB3aXRob3V0IG5hbWVzIChjb21wYWN0IGh1bWFuLXJlYWRhYmxlKVxuICAgIG1pbmltYWw6IFwibWluaW1hbFwiLFxuICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggbmljZSBzcGFjaW5nLCBpbmNsdWRpbmcgYWxsIG5hbWVzXG4gICAgZnVsbDogXCJmdWxsXCIsXG4gICAgLy8gSlNPTi1mb3JtYXQgYSBsYSBTb2xpZGl0eVxuICAgIGpzb246IFwianNvblwiXG59KTtcbmNvbnN0IHBhcmFtVHlwZUFycmF5ID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFBhcmFtVHlwZSgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMudHlwZS5tYXRjaChwYXJhbVR5cGVBcnJheSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBwYXJzZUludChtYXRjaFsyXSB8fCBcIi0xXCIpLFxuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMuY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGJhc2VUeXBlOiBcImFycmF5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBudWxsLFxuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICAgICAgYmFzZVR5cGU6ICgodGhpcy5jb21wb25lbnRzICE9IG51bGwpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXJhbVR5cGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgdGhlIHBhcmFtZXRlciBmcmFnbWVudFxuICAgIC8vICAgLSBzaWdoYXNoOiBcIih1aW50MjU2LGFkZHJlc3MpXCJcbiAgICAvLyAgIC0gbWluaW1hbDogXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcIlxuICAgIC8vICAgLSBmdWxsOiAgICBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcIlxuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lIHx8IHVuZGVmaW5lZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gSlNPTi5wYXJzZShjb21wLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArICh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUsIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyh2YWx1ZSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9jb25zdHJ1Y3Rvckd1YXJkLCB7XG4gICAgICAgICAgICBuYW1lOiAodmFsdWUubmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgIHR5cGU6IHZlcmlmeVR5cGUodmFsdWUudHlwZSksXG4gICAgICAgICAgICBpbmRleGVkOiAoKHZhbHVlLmluZGV4ZWQgPT0gbnVsbCkgPyBudWxsIDogISF2YWx1ZS5pbmRleGVkKSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6ICh2YWx1ZS5jb21wb25lbnRzID8gdmFsdWUuY29tcG9uZW50cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1UeXBpZnkobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IG5vZGUuaW5kZXhlZCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBub2RlLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJhbVR5cGlmeShwYXJzZVBhcmFtVHlwZSh2YWx1ZSwgISFhbGxvd0luZGV4ZWQpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9pc1BhcmFtVHlwZSk7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gcGFyc2VQYXJhbXModmFsdWUsIGFsbG93SW5kZXgpIHtcbiAgICByZXR1cm4gc3BsaXROZXN0aW5nKHZhbHVlKS5tYXAoKHBhcmFtKSA9PiBQYXJhbVR5cGUuZnJvbVN0cmluZyhwYXJhbSwgYWxsb3dJbmRleCkpO1xufVxuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBhIHN0YXRpYyBmcm9tIG1ldGhvZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRnJhZ21lbnQoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBTb21ldGhpbmc/IE1heWJlIHJldHVybiBhIEZ1bmN0aW9uRnJhZ21lbnQ/IEEgY3VzdG9tIERlZmF1bHRGdW5jdGlvbkZyYWdtZW50P1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmcmFnbWVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgXCJyZXR1cm5zXCIgaXMgc3Vycm91bmRlZCBieSBhIHNwYWNlIGFuZCBhbGwgd2hpdGVzcGFjZSBpcyBleGFjdGx5IG9uZSBzcGFjZVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwoL2csIFwiIChcIikucmVwbGFjZSgvXFwpL2csIFwiKSBcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDgpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBmcmFnbWVudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcImV2ZW50IFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLm5hbWUgKyBcIihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJhbm9ueW1vdXMgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgIGFub255bW91czogdmFsdWUuYW5vbnltb3VzLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXZlbnQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hbM10uc3BsaXQoXCIgXCIpLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIjpcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcInVua25vd24gbW9kaWZpZXI6IFwiICsgbW9kaWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBtYXRjaFsxXS50cmltKCksXG4gICAgICAgICAgICBhbm9ueW1vdXM6IGFub255bW91cyxcbiAgICAgICAgICAgIGlucHV0czogcGFyc2VQYXJhbXMobWF0Y2hbMl0sIHRydWUpLFxuICAgICAgICAgICAgdHlwZTogXCJldmVudFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFdmVudEZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJldmVudFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmdhcyA9IG51bGw7XG4gICAgbGV0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCJAXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wc1sxXS5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZSBnYXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmdhcyA9IEJpZ051bWJlci5mcm9tKGNvbXBzWzFdKTtcbiAgICAgICAgcmV0dXJuIGNvbXBzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcbiAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgdmFsdWUuc3BsaXQoXCIgXCIpLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RhbnRcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBheWFibGVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vbnBheWFibGVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwdXJlXCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJwdXJlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmlld1wiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImV4dGVybmFsXCI6XG4gICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgICAgICBwYXlhYmxlOiB0cnVlLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiXG4gICAgfTtcbiAgICBpZiAodmFsdWUuc3RhdGVNdXRhYmlsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IHZhbHVlLnN0YXRlTXV0YWJpbGl0eTtcbiAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgY29uc3RhbnQgcHJvcGVydHlcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoISF2YWx1ZS5jb25zdGFudCkgIT09IHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIgKyByZXN1bHQuc3RhdGVNdXRhYmlsaXR5LCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBwYXlhYmxlIHByb3BlcnR5XG4gICAgICAgIHJlc3VsdC5wYXlhYmxlID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCghIXZhbHVlLnBheWFibGUpICE9PSByZXN1bHQucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBwYXlhYmxlIGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucGF5YWJsZSA9ICEhdmFsdWUucGF5YWJsZTtcbiAgICAgICAgLy8gSWYgcGF5YWJsZSB3ZSBjYW4gYXNzdW1lIG5vbi1jb25zdGFudDsgb3RoZXJ3aXNlIHdlIGNhbid0IGFzc3VtZVxuICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgPT0gbnVsbCAmJiAhcmVzdWx0LnBheWFibGUgJiYgdmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcbiAgICAgICAgaWYgKHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucGF5YWJsZSAmJiByZXN1bHQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBwYXlhYmxlIGZ1bmN0aW9uXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcbiAgICAgICAgcmVzdWx0LnBheWFibGUgPSAhcmVzdWx0LmNvbnN0YW50O1xuICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5jb25zdGFudCA/IFwidmlld1wiIDogXCJwYXlhYmxlXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJjb25zdHJ1Y3RvcihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgJiYgdGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zdGF0ZU11dGFiaWxpdHkgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB2ZXJpZnlTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5jb25zdGFudCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjb25zdGFudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJjb25zdHJ1Y3RvclwiIH07XG4gICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIGxldCBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMgfHwgcGFyZW5zWzFdLnRyaW0oKSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXS50cmltKCksIGZhbHNlKTtcbiAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIENvbnN0cnVjdG9yRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAodGhpcy5nYXMgPyB0aGlzLmdhcy50b051bWJlcigpIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvdXRwdXQpID0+IEpTT04ucGFyc2Uob3V0cHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZnVuY3Rpb24gXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICh0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwidmlldyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInJldHVybnMgKFwiICsgdGhpcy5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBvdXRwdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oXCIsIFwiKSArIFwiKSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiQFwiICsgdGhpcy5nYXMudG9TdHJpbmcoKSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG4gICAgICAgICAgICBjb25zdGFudDogc3RhdGUuY29uc3RhbnQsXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIG91dHB1dHM6ICh2YWx1ZS5vdXRwdXRzID8gdmFsdWUub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJmdW5jdGlvblwiIH07XG4gICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIGxldCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiIHJldHVybnMgXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnMgPSBjb21wc1swXS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXSwgZmFsc2UpO1xuICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuICAgICAgICAvLyBXZSBoYXZlIG91dHB1dHNcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXR1cm5zID0gY29tcHNbMV0ubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgICAgICBpZiAocmV0dXJuc1sxXS50cmltKCkgIT0gXCJcIiB8fCByZXR1cm5zWzNdLnRyaW0oKSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5zXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLm91dHB1dHMgPSBwYXJzZVBhcmFtcyhyZXR1cm5zWzJdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfVxufVxuLy9leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4vL31cbmZ1bmN0aW9uIGNoZWNrRm9yYmlkZGVuKGZyYWdtZW50KSB7XG4gICAgY29uc3Qgc2lnID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgaWYgKHNpZyA9PT0gXCJFcnJvcihzdHJpbmcpXCIgfHwgc2lnID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2Fubm90IHNwZWNpZnkgdXNlciBkZWZpbmVkICR7c2lnfSBlcnJvcmAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZXJyb3IgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0Vycm9yRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRm9yYmlkZGVuKG5ldyBFcnJvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJlcnJvclwiIH07XG4gICAgICAgIGxldCBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGVycm9yIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JiaWRkZW4oRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFcnJvckZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlUeXBlKHR5cGUpIHtcbiAgICAvLyBUaGVzZSBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkIHRvIHRoZWlyIGZ1bGwgZGVzY3JpcHRpb25cbiAgICBpZiAodHlwZS5tYXRjaCgvXnVpbnQoJHxbXjEtOV0pLykpIHtcbiAgICAgICAgdHlwZSA9IFwidWludDI1NlwiICsgdHlwZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykpIHtcbiAgICAgICAgdHlwZSA9IFwiaW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZygzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IG1vcmUgdmVyaWZpY2F0aW9uXG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9zb2xpZGl0eS9ibG9iLzFmOGYxYTNkYjkzYTU0OGQwNTU1ZTNlMTRjZmM1NWExMGUyNWI2MGUvZG9jcy9ncmFtbWFyL1NvbGlkaXR5TGV4ZXIuZzQjTDIzNFxuY29uc3QgcmVnZXhJZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSokXCIpO1xuZnVuY3Rpb24gdmVyaWZ5SWRlbnRpZmllcih2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLm1hdGNoKHJlZ2V4SWRlbnRpZmllcikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyIFwiJHt2YWx1ZX1cImAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCByZWdleFBhcmVuID0gbmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpO1xuZnVuY3Rpb24gc3BsaXROZXN0aW5nKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBhY2N1bSA9IFwiXCI7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCB2YWx1ZS5sZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGxldCBjID0gdmFsdWVbb2Zmc2V0XTtcbiAgICAgICAgaWYgKGMgPT09IFwiLFwiICYmIGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhY2N1bSk7XG4gICAgICAgICAgICBhY2N1bSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bSArPSBjO1xuICAgICAgICAgICAgaWYgKGMgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWNjdW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0V0aGVyZXVtLUNvbnRyYWN0LUFCSVxuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFJlYWRlciwgV3JpdGVyIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBBZGRyZXNzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQXJyYXlDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hcnJheVwiO1xuaW1wb3J0IHsgQm9vbGVhbkNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2Jvb2xlYW5cIjtcbmltcG9ydCB7IEJ5dGVzQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYnl0ZXNcIjtcbmltcG9ydCB7IEZpeGVkQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9maXhlZC1ieXRlc1wiO1xuaW1wb3J0IHsgTnVsbENvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bGxcIjtcbmltcG9ydCB7IE51bWJlckNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL251bWJlclwiO1xuaW1wb3J0IHsgU3RyaW5nQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvc3RyaW5nXCI7XG5pbXBvcnQgeyBUdXBsZUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL3R1cGxlXCI7XG5pbXBvcnQgeyBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHNcIjtcbmNvbnN0IHBhcmFtVHlwZUJ5dGVzID0gbmV3IFJlZ0V4cCgvXmJ5dGVzKFswLTldKikkLyk7XG5jb25zdCBwYXJhbVR5cGVOdW1iZXIgPSBuZXcgUmVnRXhwKC9eKHU/aW50KShbMC05XSopJC8pO1xuZXhwb3J0IGNsYXNzIEFiaUNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2VyY2VGdW5jKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29lcmNlRnVuY1wiLCBjb2VyY2VGdW5jIHx8IG51bGwpO1xuICAgIH1cbiAgICBfZ2V0Q29kZXIocGFyYW0pIHtcbiAgICAgICAgc3dpdGNoIChwYXJhbS5iYXNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZHJlc3NDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlDb2Rlcih0aGlzLl9nZXRDb2RlcihwYXJhbS5hcnJheUNoaWxkcmVuKSwgcGFyYW0uYXJyYXlMZW5ndGgsIHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcInR1cGxlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXBsZUNvZGVyKChwYXJhbS5jb21wb25lbnRzIHx8IFtdKS5tYXAoKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29kZXIoY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KSwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdWxsQ29kZXIocGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdT9pbnRbMC05XSpcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVOdW1iZXIpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMjU2IHx8IChzaXplICUgOCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBcIiArIG1hdGNoWzFdICsgXCIgYml0IGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5dGVzWzAtOV0rXG4gICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMzIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlcyBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZpeGVkQnl0ZXNDb2RlcihzaXplLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG4gICAgfVxuICAgIF9nZXRXb3JkU2l6ZSgpIHsgcmV0dXJuIDMyOyB9XG4gICAgX2dldFJlYWRlcihkYXRhLCBhbGxvd0xvb3NlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGRhdGEsIHRoaXMuX2dldFdvcmRTaXplKCksIHRoaXMuY29lcmNlRnVuYywgYWxsb3dMb29zZSk7XG4gICAgfVxuICAgIF9nZXRXcml0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JpdGVyKHRoaXMuX2dldFdvcmRTaXplKCkpO1xuICAgIH1cbiAgICBnZXREZWZhdWx0VmFsdWUodHlwZXMpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh0eXBlcywgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidHlwZXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogeyB0eXBlczogdHlwZXMubGVuZ3RoLCB2YWx1ZXM6IHZhbHVlcy5sZW5ndGggfSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlczogdHlwZXMsIHZhbHVlczogdmFsdWVzIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSAobmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIikpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSB0aGlzLl9nZXRXcml0ZXIoKTtcbiAgICAgICAgY29kZXIuZW5jb2RlKHdyaXRlciwgdmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5kYXRhO1xuICAgIH1cbiAgICBkZWNvZGUodHlwZXMsIGRhdGEsIGxvb3NlKSB7XG4gICAgICAgIGNvbnN0IGNvZGVycyA9IHR5cGVzLm1hcCgodHlwZSkgPT4gdGhpcy5fZ2V0Q29kZXIoUGFyYW1UeXBlLmZyb20odHlwZSkpKTtcbiAgICAgICAgY29uc3QgY29kZXIgPSBuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKTtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmRlY29kZSh0aGlzLl9nZXRSZWFkZXIoYXJyYXlpZnkoZGF0YSksIGxvb3NlKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGRlZmF1bHRBYmlDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWJpLWNvZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhEYXRhU2xpY2UsIGhleGxpZnksIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgRGVzY3JpcHRpb24sIGdldFN0YXRpYyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBkZWZhdWx0QWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXJcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGb3JtYXRUeXBlcywgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50c1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMgfTtcbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9uIHtcbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb24ge1xufVxuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG59XG5leHBvcnQgY2xhc3MgSW5kZXhlZCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG59XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7IHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsIG5hbWU6IFwiRXJyb3JcIiwgaW5wdXRzOiBbXCJzdHJpbmdcIl0sIHJlYXNvbjogdHJ1ZSB9LFxuICAgIFwiMHg0ZTQ4N2I3MVwiOiB7IHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLCBuYW1lOiBcIlBhbmljXCIsIGlucHV0czogW1widWludDI1NlwiXSB9XG59O1xuZnVuY3Rpb24gd3JhcEFjY2Vzc0Vycm9yKHByb3BlcnR5LCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXAgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke3Byb3BlcnR5fWApO1xuICAgIHdyYXAuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gd3JhcDtcbn1cbi8qXG5mdW5jdGlvbiBjaGVja05hbWVzKGZyYWdtZW50OiBGcmFnbWVudCwgdHlwZTogXCJpbnB1dFwiIHwgXCJvdXRwdXRcIiwgcGFyYW1zOiBBcnJheTxQYXJhbVR5cGU+KTogdm9pZCB7XG4gICAgcGFyYW1zLnJlZHVjZSgoYWNjdW0sIHBhcmFtKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoYWNjdW1bcGFyYW0ubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgJHsgdHlwZSB9IHBhcmFtZXRlciAkeyBKU09OLnN0cmluZ2lmeShwYXJhbS5uYW1lKSB9IGluICR7IGZyYWdtZW50LmZvcm1hdChcImZ1bGxcIikgfWAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW1bcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCA8eyBbIG5hbWU6IHN0cmluZyBdOiBib29sZWFuIH0+eyB9KTtcbn1cbiovXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbGV0IGFiaSA9IFtdO1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudHMpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhYmkgPSBKU09OLnBhcnNlKGZyYWdtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhYmkgPSBmcmFnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmcmFnbWVudHNcIiwgYWJpLm1hcCgoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKGZyYWdtZW50KTtcbiAgICAgICAgfSkuZmlsdGVyKChmcmFnbWVudCkgPT4gKGZyYWdtZW50ICE9IG51bGwpKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FiaUNvZGVyXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEFiaUNvZGVyXCIpKCkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXJyb3JzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJldmVudHNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInN0cnVjdHNcIiwge30pO1xuICAgICAgICAvLyBBZGQgYWxsIGZyYWdtZW50cyBieSB0aGVpciBzaWduYXR1cmVcbiAgICAgICAgdGhpcy5mcmFnbWVudHMuZm9yRWFjaCgoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidWNrZXQgPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChmcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbnN0cnVjdG9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlcGxveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJvdXRwdXRcIiwgKDxGdW5jdGlvbkZyYWdtZW50PmZyYWdtZW50KS5vdXRwdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5mdW5jdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5ldmVudHM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgICBidWNrZXQgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNpZ25hdHVyZSA9IGZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICAgICAgaWYgKGJ1Y2tldFtzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIFwiICsgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWNrZXRbc2lnbmF0dXJlXSA9IGZyYWdtZW50O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZGVwbG95XCIsIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbSh7XG4gICAgICAgICAgICAgICAgcGF5YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNJbnRlcmZhY2VcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLmZ1bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludGVyZmFjZSBkb2VzIG5vdCBzdXBwb3J0IGZvcm1hdHRpbmcgc2lnaGFzaFwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IHRoaXMuZnJhZ21lbnRzLm1hcCgoZnJhZ21lbnQpID0+IGZyYWdtZW50LmZvcm1hdChmb3JtYXQpKTtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZS1idW5kbGUgdGhlIEpTT04gZnJhZ21lbnRzIGEgYml0XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKChqKSA9PiBKU09OLnBhcnNlKGopKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFiaTtcbiAgICB9XG4gICAgLy8gU3ViLWNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoZXNlIHRvIGhhbmRsZSBvdGhlciBibG9ja2NoYWluc1xuICAgIHN0YXRpYyBnZXRBYmlDb2RlcigpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBYmlDb2RlcjtcbiAgICB9XG4gICAgc3RhdGljIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFNpZ2hhc2goZnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhleERhdGFTbGljZShpZChmcmFnbWVudC5mb3JtYXQoKSksIDAsIDQpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBpZChldmVudEZyYWdtZW50LmZvcm1hdCgpKTtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICBnZXRGdW5jdGlvbihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2ggPT09IHRoaXMuZ2V0U2lnaGFzaChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwic2lnaGFzaFwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2guaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5mdW5jdGlvbnMpLmZpbHRlcigoZikgPT4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZnVuY3Rpb25zXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1ttYXRjaGluZ1swXV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5mdW5jdGlvbnNbRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGZ1bmN0aW9uXCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRmluZCBhbiBldmVudCBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RXZlbnQobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykge1xuICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljaGFzaCA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIGlmICh0b3BpY2hhc2ggPT09IHRoaXMuZ2V0RXZlbnRUb3BpYyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwidG9waWNoYXNoXCIsIHRvcGljaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXQgaXMgYSBiYXJlIG5hbWUsIGxvb2sgdXAgdGhlIGZ1bmN0aW9uICh3aWxsIHJldHVybiBudWxsIGlmIGFtYmlndW91cylcbiAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yVG9waWMuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGV2ZW50c1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXZlbnRzW0V2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclRvcGljKS5mb3JtYXQoKV07XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJzaWduYXR1cmVcIiwgbmFtZU9yU2lnbmF0dXJlT3JUb3BpYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRmluZCBhIGZ1bmN0aW9uIGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcbiAgICBnZXRFcnJvcihuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGdldFNpZ2hhc2ggPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRTaWdoYXNoXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmVycm9yc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSBnZXRTaWdoYXNoKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwic2lnaGFzaFwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2guaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5lcnJvcnMpLmZpbHRlcigoZikgPT4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZXJyb3JzXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yc1ttYXRjaGluZ1swXV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5lcnJvcnNbRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGVycm9yXCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBzaWdoYXNoICh0aGUgYnl0ZXM0IHNlbGVjdG9yKSB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cbiAgICBnZXRTaWdoYXNoKGZyYWdtZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRTaWdoYXNoXCIpKGZyYWdtZW50KTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSB0b3BpYyAodGhlIGJ5dGVzMzIgaGFzaCkgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhbiBldmVudFxuICAgIGdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldEV2ZW50VG9waWNcIikoZXZlbnRGcmFnbWVudCk7XG4gICAgfVxuICAgIF9kZWNvZGVQYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUocGFyYW1zLCBkYXRhKTtcbiAgICB9XG4gICAgX2VuY29kZVBhcmFtcyhwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZW5jb2RlKHBhcmFtcywgdmFsdWVzKTtcbiAgICB9XG4gICAgZW5jb2RlRGVwbG95KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlUGFyYW1zKHRoaXMuZGVwbG95LmlucHV0cywgdmFsdWVzIHx8IFtdKTtcbiAgICB9XG4gICAgZGVjb2RlRXJyb3JSZXN1bHQoZnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSAhPT0gdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZXJyb3IgJHtmcmFnbWVudC5uYW1lfS5gLCBcImRhdGFcIiwgaGV4bGlmeShieXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnJhZ21lbnQuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgfVxuICAgIGVuY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8vIERlY29kZSB0aGUgZGF0YSBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIHR4LmRhdGEpXG4gICAgZGVjb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgIGlmIChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDQpKSAhPT0gdGhpcy5nZXRTaWdoYXNoKGZ1bmN0aW9uRnJhZ21lbnQpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkYXRhIHNpZ25hdHVyZSBkb2VzIG5vdCBtYXRjaCBmdW5jdGlvbiAke2Z1bmN0aW9uRnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGhleGxpZnkoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZ1bmN0aW9uRnJhZ21lbnQuaW5wdXRzLCBieXRlcy5zbGljZSg0KSk7XG4gICAgfVxuICAgIC8vIEVuY29kZSB0aGUgZGF0YSBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIHR4LmRhdGEpXG4gICAgZW5jb2RlRnVuY3Rpb25EYXRhKGZ1bmN0aW9uRnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSxcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgdmFsdWVzIHx8IFtdKVxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIC8vIERlY29kZSB0aGUgcmVzdWx0IGZyb20gYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZyb20gZXRoX2NhbGwpXG4gICAgZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnVuY3Rpb25GcmFnbWVudCwgZGF0YSkge1xuICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgIGxldCByZWFzb24gPSBudWxsO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIGxldCBlcnJvckFyZ3MgPSBudWxsO1xuICAgICAgICBsZXQgZXJyb3JOYW1lID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yU2lnbmF0dXJlID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChieXRlcy5sZW5ndGggJSB0aGlzLl9hYmlDb2Rlci5fZ2V0V29yZFNpemUoKSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnVuY3Rpb25GcmFnbWVudC5vdXRwdXRzLCBieXRlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1aWx0aW4gPSBCdWlsdGluRXJyb3JzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvckFyZ3MgPSB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoYnVpbHRpbi5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JOYW1lID0gYnVpbHRpbi5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZSA9IGJ1aWx0aW4uc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVpbHRpbi5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IGVycm9yQXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JOYW1lID09PSBcIkVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgOyBWTSBFeGNlcHRpb24gd2hpbGUgcHJvY2Vzc2luZyB0cmFuc2FjdGlvbjogcmV2ZXJ0ZWQgd2l0aCByZWFzb24gc3RyaW5nICR7SlNPTi5zdHJpbmdpZnkoZXJyb3JBcmdzWzBdKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yTmFtZSA9PT0gXCJQYW5pY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYDsgVk0gRXhjZXB0aW9uIHdoaWxlIHByb2Nlc3NpbmcgdHJhbnNhY3Rpb246IHJldmVydGVkIHdpdGggcGFuaWMgY29kZSAke2Vycm9yQXJnc1swXX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQXJncyA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShlcnJvci5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGVycm9yLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZSA9IGVycm9yLmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiICsgbWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbkZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgZGF0YTogaGV4bGlmeShkYXRhKSwgZXJyb3JBcmdzLCBlcnJvck5hbWUsIGVycm9yU2lnbmF0dXJlLCByZWFzb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEVuY29kZSB0aGUgcmVzdWx0IGZvciBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gZm9yIGV0aF9jYWxsKVxuICAgIGVuY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkodGhpcy5fYWJpQ29kZXIuZW5jb2RlKGZ1bmN0aW9uRnJhZ21lbnQub3V0cHV0cywgdmFsdWVzIHx8IFtdKSk7XG4gICAgfVxuICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG4gICAgZW5jb2RlRmlsdGVyVG9waWNzKGV2ZW50RnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiBldmVudEZyYWdtZW50LmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzIGZvciBcIiArIGV2ZW50RnJhZ21lbnQuZm9ybWF0KCksIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0b3BpY3MgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVUb3BpYyA9IChwYXJhbSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYm9vbFwiICYmIHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlID8gXCIweDAxXCIgOiBcIjB4MDBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZS5tYXRjaCgvXnU/aW50LykpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgYWRkcmVzc2VzIGFyZSB2YWxpZFxuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtcImFkZHJlc3NcIl0sIFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoaGV4bGlmeSh2YWx1ZSksIDMyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhcmFtID0gZXZlbnRGcmFnbWVudC5pbnB1dHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNhbm5vdCBmaWx0ZXIgbm9uLWluZGV4ZWQgcGFyYW1ldGVyczsgbXVzdCBiZSBudWxsXCIsIChcImNvbnRyYWN0LlwiICsgcGFyYW0ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoKHZhbHVlKSA9PiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG4gICAgICAgIHdoaWxlICh0b3BpY3MubGVuZ3RoICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWNzO1xuICAgIH1cbiAgICBlbmNvZGVFdmVudExvZyhldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVHlwZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlcyA9IFtdO1xuICAgICAgICBpZiAoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBldmVudEZyYWdtZW50LmlucHV0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGlkKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIikge1xuICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChrZWNjYWsyNTYodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwidHVwbGVcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEBUT0RPXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuX2FiaUNvZGVyLmVuY29kZShbcGFyYW0udHlwZV0sIFt2YWx1ZV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB0aGlzLl9hYmlDb2Rlci5lbmNvZGUoZGF0YVR5cGVzLCBkYXRhVmFsdWVzKSxcbiAgICAgICAgICAgIHRvcGljczogdG9waWNzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIERlY29kZSBhIGZpbHRlciBmb3IgdGhlIGV2ZW50IGFuZCB0aGUgc2VhcmNoIGNyaXRlcmlhXG4gICAgZGVjb2RlRXZlbnRMb2coZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9waWNzICE9IG51bGwgJiYgIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICBsZXQgdG9waWNIYXNoID0gdGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyh0b3BpY3NbMF0sIDMyKSB8fCB0b3BpY3NbMF0udG9Mb3dlckNhc2UoKSAhPT0gdG9waWNIYXNoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmcmFnbWVudC90b3BpYyBtaXNtYXRjaFwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwidG9waWNzWzBdXCIsIGV4cGVjdGVkOiB0b3BpY0hhc2gsIHZhbHVlOiB0b3BpY3NbMF0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ZWQgPSBbXTtcbiAgICAgICAgbGV0IG5vbkluZGV4ZWQgPSBbXTtcbiAgICAgICAgbGV0IGR5bmFtaWMgPSBbXTtcbiAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcInN0cmluZ1wiIHx8IHBhcmFtLnR5cGUgPT09IFwiYnl0ZXNcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKFBhcmFtVHlwZS5mcm9tT2JqZWN0KHsgdHlwZTogXCJieXRlczMyXCIsIG5hbWU6IHBhcmFtLm5hbWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2gocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vbkluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXN1bHRJbmRleGVkID0gKHRvcGljcyAhPSBudWxsKSA/IHRoaXMuX2FiaUNvZGVyLmRlY29kZShpbmRleGVkLCBjb25jYXQodG9waWNzKSkgOiBudWxsO1xuICAgICAgICBsZXQgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZEluZGV4ID0gMCwgaW5kZXhlZEluZGV4ID0gMDtcbiAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaCgocGFyYW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRJbmRleGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHluYW1pY1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdEluZGV4ZWRbaW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IHJlc3VsdE5vbkluZGV4ZWRbbm9uSW5kZXhlZEluZGV4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUga2V5d29yZCBhcmd1bWVudCBpZiBuYW1lZCBhbmQgc2FmZVxuICAgICAgICAgICAgaWYgKHBhcmFtLm5hbWUgJiYgcmVzdWx0W3BhcmFtLm5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgICAgICAgICAgLy8gTWFrZSBlcnJvciBuYW1lZCB2YWx1ZXMgdGhyb3cgb24gYWNjZXNzXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgcGFyYW0ubmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4geyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoYHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSl9YCwgdmFsdWUpOyB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3BhcmFtLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTWFrZSBhbGwgZXJyb3IgaW5kZXhlZCB2YWx1ZXMgdGhyb3cgb24gYWNjZXNzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgaSwge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgd3JhcEFjY2Vzc0Vycm9yKGBpbmRleCAke2l9YCwgdmFsdWUpOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSB0cmFuc2FjdGlvbiwgZmluZCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gZnJhZ21lbnQgKGlmIGFueSkgYW5kXG4gICAgLy8gZGV0ZXJtaW5lIGFsbCBpdHMgcHJvcGVydGllcyBhbmQgY2FsbCBwYXJhbWV0ZXJzXG4gICAgcGFyc2VUcmFuc2FjdGlvbih0eCkge1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKHR4LmRhdGEuc3Vic3RyaW5nKDAsIDEwKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIHR4LmRhdGEuc3Vic3RyaW5nKDEwKSksXG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgc2lnaGFzaDogdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgICAgIHZhbHVlOiBCaWdOdW1iZXIuZnJvbSh0eC52YWx1ZSB8fCBcIjBcIiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBAVE9ET1xuICAgIC8vcGFyc2VDYWxsUmVzdWx0KGRhdGE6IEJ5dGVzTGlrZSk6ID8/XG4gICAgLy8gR2l2ZW4gYW4gZXZlbnQgbG9nLCBmaW5kIHRoZSBtYXRjaGluZyBldmVudCBmcmFnbWVudCAoaWYgYW55KSBhbmRcbiAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICBwYXJzZUxvZyhsb2cpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcbiAgICAgICAgaWYgKCFmcmFnbWVudCB8fCBmcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEBUT0RPOiBJZiBhbm9ueW1vdXMsIGFuZCB0aGUgb25seSBtZXRob2QsIGFuZCB0aGUgaW5wdXQgY291bnQgbWF0Y2hlcywgc2hvdWxkIHdlIHBhcnNlP1xuICAgICAgICAvLyAgICAgICAgUHJvYmFibHkgbm90LCBiZWNhdXNlIGp1c3QgYmVjYXVzZSBpdCBpcyB0aGUgb25seSBldmVudCBpbiB0aGUgQUJJIGRvZXNcbiAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqdXN0IGEgZnJhZ21lbnQ/XG4gICAgICAgIHJldHVybiBuZXcgTG9nRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIHRvcGljOiB0aGlzLmdldEV2ZW50VG9waWMoZnJhZ21lbnQpLFxuICAgICAgICAgICAgYXJnczogdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZUVycm9yKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaGV4RGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IHRoaXMuZ2V0RXJyb3IoaGV4RGF0YS5zdWJzdHJpbmcoMCwgMTApLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgYXJnczogdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgXCIweFwiICsgaGV4RGF0YS5zdWJzdHJpbmcoMTApKSxcbiAgICAgICAgICAgIGVycm9yRnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICBzaWdoYXNoOiB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLypcbiAgICBzdGF0aWMgZnJvbSh2YWx1ZTogQXJyYXk8RnJhZ21lbnQgfCBzdHJpbmcgfCBKc29uQWJpPiB8IHN0cmluZyB8IEludGVyZmFjZSkge1xuICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbnRlcmZhY2UodmFsdWUpO1xuICAgIH1cbiAgICAqL1xuICAgIHN0YXRpYyBpc0ludGVyZmFjZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW50ZXJmYWNlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImNvbnRyYWN0cy81LjcuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJpXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU2lnbmVyLCBWb2lkU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnksIGlzQnl0ZXMsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZGVlcENvcHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGZyb206IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLCBhY2Nlc3NMaXN0OiB0cnVlLFxuICAgIG1heEZlZVBlckdhczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsXG4gICAgY3VzdG9tRGF0YTogdHJ1ZSxcbiAgICBjY2lwUmVhZEVuYWJsZWQ6IHRydWVcbn07XG5mdW5jdGlvbiByZXNvbHZlTmFtZShyZXNvbHZlciwgbmFtZU9yUHJvbWlzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB5aWVsZCBuYW1lT3JQcm9taXNlO1xuICAgICAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBqdXN0IHVzZSBpdCAoYWZ0ZXIgYWRkaW5nIGNoZWNrc3VtKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJhIHByb3ZpZGVyIG9yIHNpZ25lciBpcyBuZWVkZWQgdG8gcmVzb2x2ZSBFTlMgbmFtZXNcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHJlc29sdmVyLnJlc29sdmVOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicmVzb2x2ZXIgb3IgYWRkciBpcyBub3QgY29uZmlndXJlZCBmb3IgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH0pO1xufVxuLy8gUmVjdXJzaXZlbHkgcmVwbGFjZXMgRU5TIG5hbWVzIHdpdGggcHJvbWlzZXMgdG8gcmVzb2x2ZSB0aGUgbmFtZSBhbmQgcmVzb2x2ZXMgYWxsIHByb3BlcnRpZXNcbmZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwocGFyYW1UeXBlLm1hcCgocGFyYW1UeXBlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCAoKEFycmF5LmlzQXJyYXkodmFsdWUpKSA/IHZhbHVlW2luZGV4XSA6IHZhbHVlW3BhcmFtVHlwZS5uYW1lXSksIHBhcmFtVHlwZSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcImFkZHJlc3NcIikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVOYW1lKHJlc29sdmVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2YWx1ZSwgcGFyYW1UeXBlLmNvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbVR5cGUuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChsb2dnZXIubWFrZUVycm9yKFwiaW52YWxpZCB2YWx1ZSBmb3IgYXJyYXlcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIFByb21pc2UuYWxsKHZhbHVlLm1hcCgodikgPT4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdiwgcGFyYW1UeXBlLmFycmF5Q2hpbGRyZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBJZiBhbiBleHRyYSBhcmd1bWVudCBpcyBnaXZlbiwgaXQgaXMgb3ZlcnJpZGVzXG4gICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyYW1ldGVyIGNvdW50IG1hdGNoZXNcbiAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCwgXCJwYXNzZWQgdG8gY29udHJhY3RcIik7XG4gICAgICAgIC8vIFBvcHVsYXRlIFwiZnJvbVwiIG92ZXJyaWRlIChhbGxvdyBwcm9taXNlcylcbiAgICAgICAgaWYgKGNvbnRyYWN0LnNpZ25lcikge1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGggYSBTaWduZXIgYXJlIGZyb20gdGhlIFNpZ25lcidzIGZyYW1lLW9mLXJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgYWxsb3cgb3ZlcnJpZGluZyBcImZyb21cIiBpZiBpdCBtYXRjaGVzIHRoZSBzaWduZXJcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGU6IHJlc29sdmVOYW1lKGNvbnRyYWN0LnNpZ25lciwgb3ZlcnJpZGVzLmZyb20pLFxuICAgICAgICAgICAgICAgICAgICBzaWduZXI6IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgICAgICB9KS50aGVuKChjaGVjaykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QWRkcmVzcyhjaGVjay5zaWduZXIpICE9PSBjaGVjay5vdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDb250cmFjdCB3aXRoIGEgU2lnbmVyIGNhbm5vdCBvdmVycmlkZSBmcm9tXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy5mcm9tXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVjay5vdmVycmlkZTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMuZnJvbSA9IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZU5hbWUoY29udHJhY3QucHJvdmlkZXIsIG92ZXJyaWRlcy5mcm9tKTtcbiAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnRyYWN0cyB3aXRob3V0IGEgc2lnbmVyIGNhbiBvdmVycmlkZSBcImZyb21cIiwgYW5kIGlmXG4gICAgICAgICAgICAvLyB1bnNwZWNpZmllZCB0aGUgemVybyBhZGRyZXNzIGlzIHVzZWRcbiAgICAgICAgICAgIC8vb3ZlcnJpZGVzLmZyb20gPSBBZGRyZXNzWmVybztcbiAgICAgICAgfVxuICAgICAgICAvLyBXYWl0IGZvciBhbGwgZGVwZW5kZW5jaWVzIHRvIGJlIHJlc29sdmVkIChwcmVmZXIgdGhlIHNpZ25lciBvdmVyIHRoZSBwcm92aWRlcilcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICBhcmdzOiByZXNvbHZlQWRkcmVzc2VzKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlciwgYXJncywgZnJhZ21lbnQuaW5wdXRzKSxcbiAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0LnJlc29sdmVkQWRkcmVzcyxcbiAgICAgICAgICAgIG92ZXJyaWRlczogKHJlc29sdmVQcm9wZXJ0aWVzKG92ZXJyaWRlcykgfHwge30pXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGUgQUJJIGNvZGVkIHRyYW5zYWN0aW9uXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjb250cmFjdC5pbnRlcmZhY2UuZW5jb2RlRnVuY3Rpb25EYXRhKGZyYWdtZW50LCByZXNvbHZlZC5hcmdzKTtcbiAgICAgICAgY29uc3QgdHggPSB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgdG86IHJlc29sdmVkLmFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVzb2x2ZWQgT3ZlcnJpZGVzXG4gICAgICAgIGNvbnN0IHJvID0gcmVzb2x2ZWQub3ZlcnJpZGVzO1xuICAgICAgICAvLyBQb3B1bGF0ZSBzaW1wbGUgb3ZlcnJpZGVzXG4gICAgICAgIGlmIChyby5ub25jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5ub25jZSA9IEJpZ051bWJlci5mcm9tKHJvLm5vbmNlKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5nYXNMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5nYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKHJvLmdhc0xpbWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBCaWdOdW1iZXIuZnJvbShyby5nYXNQcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLm1heEZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbShyby5tYXhGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gcm8uZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8udHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC50eXBlID0gcm8udHlwZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gYWNjZXNzTGlzdGlmeShyby5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gXCJnYXNMaW1pdFwiIG92ZXJyaWRlLCBidXQgdGhlIEFCSSBzcGVjaWZpZXMgYSBkZWZhdWx0LCB1c2UgaXRcbiAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwgJiYgZnJhZ21lbnQuZ2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGludHJpbnNpYyBnYXMgY29zdCBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgaXMgYmFzZWQgb24gdGhlIHllbGxvdyBwYXBlciBhcyBvZiBQZXRlcnNidXJnOyB0aGlzIGlzIHNvbWV0aGluZ1xuICAgICAgICAgICAgLy8gd2UgbWF5IHdpc2ggdG8gcGFyYW1ldGVyaXplIGluIHY2IGFzIHBhcnQgb2YgdGhlIE5ldHdvcmsgb2JqZWN0LiBTaW5jZSB0aGlzXG4gICAgICAgICAgICAvLyBpcyBhbHdheXMgYSBub24tbmlsIHRvIGFkZHJlc3MsIHdlIGNhbiBpZ25vcmUgR19jcmVhdGUsIGJ1dCBtYXkgd2lzaCB0byBhZGRcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgbG9naWMgdG8gdGhlIENvbnRyYWN0RmFjdG9yeS5cbiAgICAgICAgICAgIGxldCBpbnRyaW5zaWMgPSAyMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW50cmluc2ljICs9IDQ7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGludHJpbnNpYyArPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eC5nYXNMaW1pdCA9IEJpZ051bWJlci5mcm9tKGZyYWdtZW50LmdhcykuYWRkKGludHJpbnNpYyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wdWxhdGUgXCJ2YWx1ZVwiIG92ZXJyaWRlXG4gICAgICAgIGlmIChyby52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgcm9WYWx1ZSA9IEJpZ051bWJlci5mcm9tKHJvLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghcm9WYWx1ZS5pc1plcm8oKSAmJiAhZnJhZ21lbnQucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uLXBheWFibGUgbWV0aG9kIGNhbm5vdCBvdmVycmlkZSB2YWx1ZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLnZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZXMudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4LnZhbHVlID0gcm9WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8uY3VzdG9tRGF0YSkge1xuICAgICAgICAgICAgdHguY3VzdG9tRGF0YSA9IHNoYWxsb3dDb3B5KHJvLmN1c3RvbURhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5jY2lwUmVhZEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHR4LmNjaXBSZWFkRW5hYmxlZCA9ICEhcm8uY2NpcFJlYWRFbmFibGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgb3ZlcnJpZGVzXG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubm9uY2U7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzTGltaXQ7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzUHJpY2U7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZnJvbTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy52YWx1ZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy50eXBlO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmFjY2Vzc0xpc3Q7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmN1c3RvbURhdGE7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuY2NpcFJlYWRFbmFibGVkO1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIHN0cmF5IG92ZXJyaWRlcywgd2hpY2ggbWF5IGluZGljYXRlIGFcbiAgICAgICAgLy8gdHlwbyBvciB1c2luZyBhbiB1bnN1cHBvcnRlZCBrZXkuXG4gICAgICAgIGNvbnN0IGxlZnRvdmVycyA9IE9iamVjdC5rZXlzKG92ZXJyaWRlcykuZmlsdGVyKChrZXkpID0+IChvdmVycmlkZXNba2V5XSAhPSBudWxsKSk7XG4gICAgICAgIGlmIChsZWZ0b3ZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgY2Fubm90IG92ZXJyaWRlICR7bGVmdG92ZXJzLm1hcCgobCkgPT4gSlNPTi5zdHJpbmdpZnkobCkpLmpvaW4oXCIsXCIpfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlc1wiLFxuICAgICAgICAgICAgICAgIG92ZXJyaWRlczogbGVmdG92ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFBvcHVsYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuICAgIGNvbnN0IHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXN0aW1hdGUgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIHNpZ25lclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgc2lnbmVyT3JQcm92aWRlci5lc3RpbWF0ZUdhcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KSB7XG4gICAgY29uc3Qgd2FpdCA9IHR4LndhaXQuYmluZCh0eCk7XG4gICAgdHgud2FpdCA9IChjb25maXJtYXRpb25zKSA9PiB7XG4gICAgICAgIHJldHVybiB3YWl0KGNvbmZpcm1hdGlvbnMpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzID0gcmVjZWlwdC5sb2dzLm1hcCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZGVlcENvcHkobG9nKTtcbiAgICAgICAgICAgICAgICBsZXQgcGFyc2VkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQgPSBjb250cmFjdC5pbnRlcmZhY2UucGFyc2VMb2cobG9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIGV2ZW50IGxvZzsgaW5jbHVkZSBpdFxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHBhcnNlZC5ldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHBhcnNlZC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVzZWZ1bCBvcGVyYXRpb25zXG4gICAgICAgICAgICAgICAgZXZlbnQucmVtb3ZlTGlzdGVuZXIgPSAoKSA9PiB7IHJldHVybiBjb250cmFjdC5wcm92aWRlcjsgfTtcbiAgICAgICAgICAgICAgICBldmVudC5nZXRCbG9jayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldEJsb2NrKHJlY2VpcHQuYmxvY2tIYXNoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udHJhY3QucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24ocmVjZWlwdC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG4gICAgY29uc3Qgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgXCJibG9ja1RhZ1wiIG92ZXJyaWRlIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGxldCBibG9ja1RhZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnJpZGVzID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcy5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnID0geWllbGQgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvdmVycmlkZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRyYWN0IHdhcyBqdXN0IGRlcGxveWVkLCB3YWl0IHVudGlsIGl0IGlzIG1pbmVkXG4gICAgICAgICAgICBpZiAoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbnRyYWN0Ll9kZXBsb3llZChibG9ja1RhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYWxsIGEgbm9kZSBhbmQgZ2V0IHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgc2lnbmVyT3JQcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVGdW5jdGlvblJlc3VsdChmcmFnbWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoY29sbGFwc2VTaW1wbGUgJiYgZnJhZ21lbnQub3V0cHV0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkcmVzcyA9IGNvbnRyYWN0LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkU2VuZChjb250cmFjdCwgZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghY29udHJhY3Quc2lnbmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb24gcmVxdWlyZXMgYSBzaWduZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNlbmRUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udHJhY3Qgd2FzIGp1c3QgZGVwbG95ZWQsIHdhaXQgdW50aWwgaXQgaXMgbWluZWRcbiAgICAgICAgICAgIGlmIChjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgY29udHJhY3QuX2RlcGxveWVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0eFJlcXVlc3QgPSB5aWVsZCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyk7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIGNvbnRyYWN0LnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIFR3ZWFrIHRoZSB0eC53YWl0IHNvIHRoZSByZWNlaXB0IGhhcyBleHRyYSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBhZGRDb250cmFjdFdhaXQoY29udHJhY3QsIHR4KTtcbiAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRGVmYXVsdChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG4gICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG4gICAgICAgIHJldHVybiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50VGFnKGZpbHRlcikge1xuICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAmJiAoZmlsdGVyLnRvcGljcyA9PSBudWxsIHx8IGZpbHRlci50b3BpY3MubGVuZ3RoID09PSAwKSkge1xuICAgICAgICByZXR1cm4gXCIqXCI7XG4gICAgfVxuICAgIHJldHVybiAoZmlsdGVyLmFkZHJlc3MgfHwgXCIqXCIpICsgXCJAXCIgKyAoZmlsdGVyLnRvcGljcyA/IGZpbHRlci50b3BpY3MubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIHJldHVybiB0b3BpYy5qb2luKFwifFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9waWM7XG4gICAgfSkuam9pbihcIjpcIikgOiBcIlwiKTtcbn1cbmNsYXNzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IodGFnLCBmaWx0ZXIpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaWx0ZXJcIiwgZmlsdGVyKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgfVxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXI6IGxpc3RlbmVyLCBvbmNlOiBvbmNlIH0pO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSB8fCBpdGVtLmxpc3RlbmVyICE9PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubWFwKChpKSA9PiBpLmxpc3RlbmVyKTtcbiAgICB9XG4gICAgbGlzdGVuZXJDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuICAgIHJ1bihhcmdzKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyQ291bnQgPSB0aGlzLmxpc3RlbmVyQ291bnQoKTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXJnc0NvcHkgPSBhcmdzLnNsaWNlKCk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayBpbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3NDb3B5KTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgLy8gUmVzY2hlZHVsZSBpdCBpZiBpdCBub3QgXCJvbmNlXCJcbiAgICAgICAgICAgIHJldHVybiAhKGl0ZW0ub25jZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXJDb3VudDtcbiAgICB9XG4gICAgcHJlcGFyZUV2ZW50KGV2ZW50KSB7XG4gICAgfVxuICAgIC8vIFJldHVybnMgdGhlIGFycmF5IHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIGFuIGVtaXRcbiAgICBnZXRFbWl0KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBbZXZlbnRdO1xuICAgIH1cbn1cbmNsYXNzIEVycm9yUnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJlcnJvclwiLCBudWxsKTtcbiAgICB9XG59XG4vLyBAVE9ETyBGcmFnbWVudCBzaG91bGQgaW5oZXJpdCBXaWxkY2FyZD8gYW5kIGp1c3Qgb3ZlcnJpZGUgZ2V0RW1pdD9cbi8vICAgICAgIG9yIGhhdmUgYSBjb21tb24gYWJzdHJhY3Qgc3VwZXIgY2xhc3MsIHdpdGggZW5vdWdoIGNvbnN0cnVjdG9yXG4vLyAgICAgICBvcHRpb25zIHRvIGNvbmZpZ3VyZSBib3RoLlxuLy8gQSBGcmFnbWVudCBFdmVudCB3aWxsIHBvcHVsYXRlIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IFdpbGRjYXJkXG4vLyB3aWxsLCBhbmQgYWRkaXRpb25hbGx5IGRlcmVmZXJlbmNlIHRoZSBhcmd1bWVudHMgd2hlbiBlbWl0dGluZ1xuY2xhc3MgRnJhZ21lbnRSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBmcmFnbWVudCwgdG9waWNzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3NcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHRvcGljID0gY29udHJhY3RJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCk7XG4gICAgICAgIGlmICh0b3BpY3MpIHtcbiAgICAgICAgICAgIGlmICh0b3BpYyAhPT0gdG9waWNzWzBdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvcGljIG1pc21hdGNoXCIsIFwidG9waWNzXCIsIHRvcGljcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gW3RvcGljXTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihnZXRFdmVudFRhZyhmaWx0ZXIpLCBmaWx0ZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmcmFnbWVudFwiLCBmcmFnbWVudCk7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgICAgICBzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuICAgICAgICBldmVudC5ldmVudCA9IHRoaXMuZnJhZ21lbnQubmFtZTtcbiAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSB0aGlzLmZyYWdtZW50LmZvcm1hdCgpO1xuICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2codGhpcy5mcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSB0aGlzLmludGVyZmFjZS5kZWNvZGVFdmVudExvZyh0aGlzLmZyYWdtZW50LCBldmVudC5kYXRhLCBldmVudC50b3BpY3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IG51bGw7XG4gICAgICAgICAgICBldmVudC5kZWNvZGVFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVtaXQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnMoZXZlbnQuYXJncyk7XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF0uZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IChldmVudC5hcmdzIHx8IFtdKS5zbGljZSgpO1xuICAgICAgICBhcmdzLnB1c2goZXZlbnQpO1xuICAgICAgICByZXR1cm4gYXJncztcbiAgICB9XG59XG4vLyBBIFdpbGRjYXJkIEV2ZW50IHdpbGwgYXR0ZW1wdCB0byBwb3B1bGF0ZTpcbi8vICAtIGV2ZW50ICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IG5hbWVcbi8vICAtIGV2ZW50U2lnbmF0dXJlICAgVGhlIGZ1bGwgc2lnbmF0dXJlIG9mIHRoZSBldmVudFxuLy8gIC0gZGVjb2RlICAgICAgICAgICBBIGZ1bmN0aW9uIHRvIGRlY29kZSBkYXRhIGFuZCB0b3BpY3Ncbi8vICAtIGFyZ3MgICAgICAgICAgICAgVGhlIGRlY29kZWQgZGF0YSBhbmQgdG9waWNzXG5jbGFzcyBXaWxkY2FyZFJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UpIHtcbiAgICAgICAgc3VwZXIoXCIqXCIsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgICAgICBzdXBlci5wcmVwYXJlRXZlbnQoZXZlbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5pbnRlcmZhY2UucGFyc2VMb2coZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQuZXZlbnQgPSBwYXJzZWQubmFtZTtcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcbiAgICAgICAgICAgIGV2ZW50LmRlY29kZSA9IChkYXRhLCB0b3BpY3MpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gbWF0Y2hpbmcgZXZlbnRcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCYXNlQ29udHJhY3Qge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3NPck5hbWUsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKSB7XG4gICAgICAgIC8vIEBUT0RPOiBNYXliZSBzdGlsbCBjaGVjayB0aGUgYWRkcmVzc09yTmFtZSBsb29rcyBsaWtlIGEgdmFsaWQgYWRkcmVzcyBvciBuYW1lP1xuICAgICAgICAvL2FkZHJlc3MgPSBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRJbnRlcmZhY2VcIikoY29udHJhY3RJbnRlcmZhY2UpKTtcbiAgICAgICAgaWYgKHNpZ25lck9yUHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBudWxsKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFNpZ25lci5pc1NpZ25lcihzaWduZXJPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyLnByb3ZpZGVyIHx8IG51bGwpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUHJvdmlkZXIuaXNQcm92aWRlcihzaWduZXJPclByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsIFwic2lnbmVyT3JQcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNhbGxTdGF0aWNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVzdGltYXRlR2FzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInBvcHVsYXRlVHJhbnNhY3Rpb25cIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlcnNcIiwge30pO1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVGaWx0ZXJzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5ldmVudHMpLmZvckVhY2goKGV2ZW50U2lnbmF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLmludGVyZmFjZS5ldmVudHNbZXZlbnRTaWduYXR1cmVdO1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycywgZXZlbnRTaWduYXR1cmUsICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BpY3M6IHRoaXMuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhldmVudCwgYXJncylcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdLnB1c2goZXZlbnRTaWduYXR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVGaWx0ZXJzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVycyA9IHVuaXF1ZUZpbHRlcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZmlsdGVycywgbmFtZSwgdGhpcy5maWx0ZXJzW2ZpbHRlcnNbMF1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiAke25hbWV9ICgke2ZpbHRlcnMuam9pbihcIiwgXCIpfSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9ydW5uaW5nRXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfd3JhcHBlZEVtaXRzXCIsIHt9KTtcbiAgICAgICAgaWYgKGFkZHJlc3NPck5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29udHJhY3QgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcImFkZHJlc3NPck5hbWVcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJyZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZU5hbWUodGhpcy5wcm92aWRlciwgYWRkcmVzc09yTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCBQcm9taXNlLnJlc29sdmUoZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCBhIHByb3ZpZGVyLCB3ZSBjYW5ub3QgdXNlIEVOUyBuYW1lc1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgaXMgcmVxdWlyZWQgdG8gdXNlIEVOUyBuYW1lIGFzIGNvbnRyYWN0IGFkZHJlc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBDb250cmFjdFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3dhbGxvdyBiYWQgRU5TIG5hbWVzIHRvIHByZXZlbnQgVW5oYW5kbGVkIEV4Y2VwdGlvbnNcbiAgICAgICAgdGhpcy5yZXNvbHZlZEFkZHJlc3MuY2F0Y2goKGUpID0+IHsgfSk7XG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgIGNvbnN0IHVuaXF1ZVNpZ25hdHVyZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKChzaWduYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduYXR1cmUgaXMgdW5pcXVlOyBpZiBub3QgdGhlIEFCSSBnZW5lcmF0aW9uIGhhc1xuICAgICAgICAgICAgLy8gbm90IGJlZW4gY2xlYW5lZCBvciBtYXkgYmUgaW5jb3JyZWN0bHkgZ2VuZXJhdGVkXG4gICAgICAgICAgICBpZiAodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYER1cGxpY2F0ZSBBQkkgZW50cnkgZm9yICR7SlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gVHJhY2sgdW5pcXVlIG5hbWVzOyB3ZSBvbmx5IGV4cG9zZSBiYXJlIG5hbWVkIGZ1bmN0aW9ucyBpZiB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgYW1iaWd1b3VzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXS5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IGNvbGxhcHNlIHNpbXBsZSBjYWxscyBvbiB0aGlzIGJ1Y2tldCwgd2hpY2ggYWxsb3dzXG4gICAgICAgICAgICAvLyBmcmFtZXdvcmtzIHRvIHNhZmVseSB1c2UgdGhpcyB3aXRob3V0IGludHJvc3BlY3Rpb24gYXMgd2VsbCBhc1xuICAgICAgICAgICAgLy8gYWxsb3dzIGRlY29kaW5nIGVycm9yIHJlY292ZXJ5LlxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIGJ1aWxkQ2FsbCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgYnVpbGRQb3B1bGF0ZSh0aGlzLCBmcmFnbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5lc3RpbWF0ZUdhcywgc2lnbmF0dXJlLCBidWlsZEVzdGltYXRlKHRoaXMsIGZyYWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVOYW1lcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gQW1iaWd1b3VzIG5hbWVzIHRvIG5vdCBnZXQgYXR0YWNoZWQgYXMgYmFyZSBuYW1lc1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHVuaXF1ZU5hbWVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbGVhZGluZyBcIiVcIiB1c2VkIGZvciBwcm90b3R5cGUgcHJvdGVjdGlvblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgIC8vIElmIG92ZXJ3cml0aW5nIGEgbWVtYmVyIHByb3BlcnR5IHRoYXQgaXMgbnVsbCwgc3dhbGxvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBuYW1lLCB0aGlzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsIG5hbWUsIHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YXRpY1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBuYW1lLCB0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIG5hbWUsIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVzdGltYXRlR2FzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLCBuYW1lLCB0aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSkge1xuICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW50ZXJmYWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFsbG93IHRpbWVvdXQ/XG4gICAgZGVwbG95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBsb3llZCgpO1xuICAgIH1cbiAgICBfZGVwbG95ZWQoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3llZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUganVzdCBkZXBsb3llZCwgd2Uga25vdyB0aGUgdHJhbnNhY3Rpb24gd2Ugc2hvdWxkIG9jY3VyIGluXG4gICAgICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMuZGVwbG95VHJhbnNhY3Rpb24ud2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBPbmNlIHdlIGFsbG93IGEgdGltZW91dCB0byBiZSBwYXNzZWQgaW4sIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoYXQgbWFueSBibG9ja3MgZm9yIGdldENvZGVcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHBvbGwgZm9yIG91ciBjb2RlIHRvIGJlIGRlcGxveWVkXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuYWRkcmVzcywgYmxvY2tUYWcpLnRoZW4oKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gQFRPRE86XG4gICAgLy8gZXN0aW1hdGVGYWxsYmFjayhvdmVycmlkZXM/OiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPEJpZ051bWJlcj5cbiAgICAvLyBAVE9ETzpcbiAgICAvLyBlc3RpbWF0ZURlcGxveShieXRlY29kZTogc3RyaW5nLCAuLi5hcmdzKTogUHJvbWlzZTxCaWdOdW1iZXI+XG4gICAgZmFsbGJhY2sob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBzaGFsbG93Q29weShvdmVycmlkZXMgfHwge30pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHgudG8gPSB0aGlzLnJlc29sdmVkQWRkcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwbG95ZWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVjb25uZWN0IHRvIGEgZGlmZmVyZW50IHNpZ25lciBvciBwcm92aWRlclxuICAgIGNvbm5lY3Qoc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChzaWduZXJPclByb3ZpZGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2lnbmVyT3JQcm92aWRlciA9IG5ldyBWb2lkU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG4gICAgLy8gUmUtYXR0YWNoIHRvIGEgZGlmZmVyZW50IG9uLWNoYWluIGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3RcbiAgICBhdHRhY2goYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShhZGRyZXNzT3JOYW1lLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIgfHwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWQuaXNJbmRleGVkKHZhbHVlKTtcbiAgICB9XG4gICAgX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoaXMgZXZlbnQgcnVubmluZzsgd2UgY2FuIHJlLXVzZSBpdFxuICAgICAgICBpZiAodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdFdmVudDtcbiAgICB9XG4gICAgX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBcImVycm9yXCIgZXZlbnRzIChpZiB5b3VyIGNvbnRyYWN0IGhhcyBhbiBlcnJvciBldmVudCwgaW5jbHVkZVxuICAgICAgICAgICAgLy8gdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIGJ5cGFzcyB0aGlzIHNwZWNpYWwgZXZlbnQga2V5d29yZClcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEVycm9yUnVubmluZ0V2ZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnQgdGhhdCBpcyByZWdpc3RlcmVkXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoXCJldmVudFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudFxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGV2ZW50IEZyYWdtZW50ICh0aHJvd3MgaWYgYW1iaWd1b3VzL3Vua25vd24gZXZlbnQpXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgdG9waWNzIHRvIGZpbHRlciBieS4uLlxuICAgICAgICBpZiAoZXZlbnROYW1lLnRvcGljcyAmJiBldmVudE5hbWUudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElzIGl0IGEga25vd24gdG9waWNoYXNoPyAodGhyb3dzIGlmIG5vIG1hdGNoaW5nIHRvcGljaGFzaClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9waWMgPSBldmVudE5hbWUudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRvcGljXCIpOyAvLyBAVE9ETzogTWF5IGhhcHBlbiBmb3IgYW5vbnltb3VzIGV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KHRvcGljKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCwgZXZlbnROYW1lLnRvcGljcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aGUgdW5rbm93biB0b3BpY2hhc2hcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9waWNzOiBldmVudE5hbWUudG9waWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcbiAgICB9XG4gICAgX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvbGxlciBmb3IgdGhpcywgcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb25zdCBlbWl0ID0gdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgaWYgKGVtaXQgJiYgcnVubmluZ0V2ZW50LmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub2ZmKHJ1bm5pbmdFdmVudC5maWx0ZXIsIGVtaXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBncmFjZWZ1bGx5IHJlY292ZXJcbiAgICAvLyBmcm9tIHBhcnNlIGVycm9ycyBpZiB0aGV5IHdpc2hcbiAgICBfd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBldmVudCA9IGRlZXBDb3B5KGxvZyk7XG4gICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSAoKSA9PiB7IHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGxvZy5ibG9ja0hhc2gpOyB9O1xuICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24obG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG4gICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGxvZy50cmFuc2FjdGlvbkhhc2gpOyB9O1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdyBpZiB0aGUgdG9waWNzIGFuZCBkYXRhIG1pc21hdGNoIHRoZSBzaWduYXR1cmVcbiAgICAgICAgcnVubmluZ0V2ZW50LnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIocnVubmluZ0V2ZW50LCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIm9uY2VcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5uaW5nRXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpO1xuICAgICAgICAvLyBUcmFjayB0aGlzIHJ1bm5pbmcgZXZlbnQgYW5kIGl0cyBsaXN0ZW5lcnMgKG1heSBhbHJlYWR5IGJlIHRoZXJlOyBidXQgbm8gaGFyZCBpbiB1cGRhdGluZylcbiAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSA9IHJ1bm5pbmdFdmVudDtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBwb2xsaW5nIHRoZSBwcm92aWRlciwgc3RhcnQgcG9sbGluZ1xuICAgICAgICBpZiAoIXRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVtaXQgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhlIHJlc3VsdCBmb3IgdGhlIHBhcmFtZXRlcml6ZWQgZXZlbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHJ1bm5pbmdFdmVudC5nZXRFbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChydW5uaW5nRXZlbnQuZmlsdGVyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVtaXQgXCJldmVudFwiIGZvciBmcmFnbWVudC1iYXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nRXZlbnQuZmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbWl0IFwiZXJyb3JcIiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBldmVudC5kZWNvZGVFcnJvciwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10gPSB3cmFwcGVkRW1pdDtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgZXZlbnRzLCBsaWtlIFwiZXJyb3JcIiBkbyBub3QgaGF2ZSBhIGZpbHRlclxuICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24ocnVubmluZ0V2ZW50LmZpbHRlciwgd3JhcHBlZEVtaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2tPckJsb2NraGFzaCwgdG9CbG9jaykge1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBzaGFsbG93Q29weShydW5uaW5nRXZlbnQuZmlsdGVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJvbUJsb2NrT3JCbG9ja2hhc2gpID09PSBcInN0cmluZ1wiICYmIGlzSGV4U3RyaW5nKGZyb21CbG9ja09yQmxvY2toYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGlmICh0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLCBcInRvQmxvY2tcIiwgdG9CbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gZnJvbUJsb2NrT3JCbG9ja2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gKChmcm9tQmxvY2tPckJsb2NraGFzaCAhPSBudWxsKSA/IGZyb21CbG9ja09yQmxvY2toYXNoIDogMCk7XG4gICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9ICgodG9CbG9jayAhPSBudWxsKSA/IHRvQmxvY2sgOiBcImxhdGVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcikudGhlbigobG9ncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ3MubWFwKChsb2cpID0+IHRoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChydW5uaW5nRXZlbnQucnVuKGFyZ3MpID4gMCk7XG4gICAgICAgIC8vIE1heSBoYXZlIGRyYWluZWQgYWxsIHRoZSBcIm9uY2VcIiBldmVudHM7IGNoZWNrIGZvciBsaXZpbmcgZXZlbnRzXG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3J1bm5pbmdFdmVudHMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIHRoaXMuX3J1bm5pbmdFdmVudHNba2V5XS5saXN0ZW5lckNvdW50KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJDb3VudCgpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXS5saXN0ZW5lcnMoKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgYW55IGxpc3RlbmVyc1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbn1cbmV4cG9ydCBjbGFzcyBDb250cmFjdEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0SW50ZXJmYWNlLCBieXRlY29kZSwgc2lnbmVyKSB7XG4gICAgICAgIGxldCBieXRlY29kZUhleCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0J5dGVzKGJ5dGVjb2RlKSkge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBoZXhsaWZ5KGJ5dGVjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlY29kZSAmJiB0eXBlb2YgKGJ5dGVjb2RlLm9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBieXRlY29kZSBvYmplY3QgZnJvbSB0aGUgU29saWRpdHkgY29tcGlsZXJcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gYnl0ZWNvZGUub2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3Jhc2ggaW4gdGhlIG5leHQgdmVyaWZpY2F0aW9uIHN0ZXBcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gXCIhXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGl0IGlzIDB4IHByZWZpeGVkXG4gICAgICAgIGlmIChieXRlY29kZUhleC5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIjB4XCIgKyBieXRlY29kZUhleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbmFsIHJlc3VsdCBpcyB2YWxpZCBieXRlY29kZVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJ5dGVjb2RlSGV4KSB8fCAoYnl0ZWNvZGVIZXgubGVuZ3RoICUgMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVjb2RlXCIsIFwiYnl0ZWNvZGVcIiwgYnl0ZWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBzaWduZXIsIG1ha2Ugc3VyZSBpdCBpcyB2YWxpZFxuICAgICAgICBpZiAoc2lnbmVyICYmICFTaWduZXIuaXNTaWduZXIoc2lnbmVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsIFwic2lnbmVyXCIsIHNpZ25lcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJieXRlY29kZVwiLCBieXRlY29kZUhleCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXIgfHwgbnVsbCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBGdXR1cmU7IHJlbmFtZSB0byBwb3B1bGF0ZVRyYW5zYWN0aW9uP1xuICAgIGdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHR4ID0ge307XG4gICAgICAgIC8vIElmIHdlIGhhdmUgMSBhZGRpdGlvbmFsIGFyZ3VtZW50LCB3ZSBhbGxvdyB0cmFuc2FjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0eCA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWRUcmFuc2FjdGlvbktleXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IHRoZXNlIHRvIGJlIG92ZXJyaWRkZW4gaW4gYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIFtcImRhdGFcIiwgXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR4LnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHR4LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUuaXNaZXJvKCkgJiYgIXRoaXMuaW50ZXJmYWNlLmRlcGxveS5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBjb25zdHJ1Y3RvciBjYW5ub3Qgb3ZlcnJpZGUgdmFsdWVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy52YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG4gICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgLy8gU2V0IHRoZSBkYXRhIHRvIHRoZSBieXRlY29kZSArIHRoZSBlbmNvZGVkIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICAgICAgICB0eC5kYXRhID0gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5ieXRlY29kZSxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShhcmdzKVxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIElmIDEgZXh0cmEgcGFyYW1ldGVyIHdhcyBwYXNzZWQgaW4sIGl0IGNvbnRhaW5zIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYWxsIG1hdGNoZXMgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBFTlMgbmFtZXMgYW5kIHByb21pc2VzIGluIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVBZGRyZXNzZXModGhpcy5zaWduZXIsIGFyZ3MsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAod2l0aCBvcHRpb25hbCBvdmVycmlkZXMpXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZFR4ID0gdGhpcy5nZXREZXBsb3lUcmFuc2FjdGlvbiguLi5wYXJhbXMpO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RBZGRyZXNzXCIpKHR4KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RcIikoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbW9kaWZpZWQgd2FpdCB0aGF0IHdyYXBzIGV2ZW50c1xuICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShjb250cmFjdCwgXCJkZXBsb3lUcmFuc2FjdGlvblwiLCB0eCk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2goYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29uc3RydWN0b3IpLmdldENvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lcik7XG4gICAgfVxuICAgIGNvbm5lY3Qoc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNvbGlkaXR5KGNvbXBpbGVyT3V0cHV0LCBzaWduZXIpIHtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBjb21waWxlciBvdXRwdXRcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcImNvbXBpbGVyT3V0cHV0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoY29tcGlsZXJPdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb21waWxlck91dHB1dCA9IEpTT04ucGFyc2UoY29tcGlsZXJPdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IGNvbXBpbGVyT3V0cHV0LmFiaTtcbiAgICAgICAgbGV0IGJ5dGVjb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBpbGVyT3V0cHV0LmV2bSAmJiBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIHJldHVybiBDb250cmFjdC5nZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHR4KSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi9Db250cmFjdEFkZHJlc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgbG9jYWxob3N0Q29udHJhY3RBZGRyZXNzZXMgaW1wbGVtZW50cyBDb250cmFjdEFkZHJlc3NlcyB7XHJcblxyXG4gICAgS1lDX0FERFJFU1MgPSBcIjB4QTcwMDUyOGEyQjlCZDMxMjZjOTYzNzhiNzZmMmM5OWY1RjBlMEY3NlwiO1xyXG4gICAgQVVTRF9BRERSRVNTID0gXCIweDdhZDE2MzBiMkU5RjBlNTQwMWYyMjBBMzNCNDczQzdFNTU1MWRkM2VcIjtcclxuICAgIExJTUlOQUxfTUFSS0VUX0FERFJFU1MgPSBcIjB4MTlkNUFCRTc4NTRiMDE5NjBENDkxMWU2NTM2YjI2RjhBMzhDM2ExOFwiO1xyXG4gICAgTUFSS0VUX0NBTEVOREFSX0FERFJFU1MgPSBcIjB4MTJiQTIyMTA2MTI1NWMxMUVBNDg5NUMzNjM2MzNiRDQzRjI4RjljM1wiO1xyXG5cclxufSIsImltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi9Db250cmFjdEFkZHJlc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgbXVtYmFpQ29udHJhY3RBZGRyZXNzZXMgaW1wbGVtZW50cyBDb250cmFjdEFkZHJlc3NlcyB7XHJcblxyXG4gICAgS1lDX0FERFJFU1MgPSBcIjB4OWUyQjI4RDlGODQxMzAwYkUzQjY0ZTUwNWRFY0EzNmMzNTI1MDYwOVwiO1xyXG4gICAgQVVTRF9BRERSRVNTID0gXCIweDM4RjJCMUU5RjExOTM3ZEQyNzZENjQ1MjE1MzViMTUyODBBN0YxMzdcIjtcclxuICAgIExJTUlOQUxfTUFSS0VUX0FERFJFU1MgPSBcIjB4NmU5QzI5ZTQxNmRjOUY3QTZBMDNmZmViYUIzZjAyRWY2MmExYmFFNFwiO1xyXG4gICAgTUFSS0VUX0NBTEVOREFSX0FERFJFU1MgPSBcIjB4YzZCMjlkZmQ0RkQ3NTZFRjk0YjNBM0ZGN2E1MzFGNDQ2N0JEREE3NVwiO1xyXG5cclxufSIsImltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi9Db250cmFjdEFkZHJlc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZnVqaUNvbnRyYWN0QWRkcmVzc2VzIGltcGxlbWVudHMgQ29udHJhY3RBZGRyZXNzZXMge1xyXG5cclxuICAgIEtZQ19BRERSRVNTID0gXCIweDA1OTREMDRGREI1Qzk4RmI3Rjc3N2E3OTkxMzk0MjRBZTI0MTRBYURcIjtcclxuICAgIEFVU0RfQUREUkVTUyA9IFwiMHhiQWM0ODJhRTBiMGQ2NTI4NTRkZjM3N2JlNTY2NDQ1OTg0QTAyMUVEXCI7XHJcbiAgICBMSU1JTkFMX01BUktFVF9BRERSRVNTID0gXCIweDA5OEE1MTJCMDE3NDA4MDA4YTIzRUNlMjI4NDM3ODg3OTlDRGViRmRcIjtcclxuICAgIE1BUktFVF9DQUxFTkRBUl9BRERSRVNTID0gXCIweDc3RTZBNjJCZTgzOThCMThkMmRBODFDREI2RWIwOTdiRDgxMzJjY0JcIjtcclxuXHJcbn0iLCJpbXBvcnQgQ29udHJhY3RBZGRyZXNzZXMgZnJvbSBcIi4vQ29udHJhY3RBZGRyZXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHBvbHlnb25Db250cmFjdEFkZHJlc3NlcyBpbXBsZW1lbnRzIENvbnRyYWN0QWRkcmVzc2VzIHtcclxuXHJcbiAgICBLWUNfQUREUkVTUyA9IFwiMHhjN2RBOThFMjgyY2MzMEJENGZlMGE3ZEUzODM3MkY4NzZEQjU3N0U0XCI7XHJcbiAgICBBVVNEX0FERFJFU1MgPSBcIjB4OUI3ODBlNzFDMmE4NDkyRTgwNWUxNzYxNkVCODc4ZjJlMzg3NEUyMVwiO1xyXG4gICAgTElNSU5BTF9NQVJLRVRfQUREUkVTUyA9IFwiMHg4QjRmYzBiY2FFRDc2YTY1Njk1MjVkOEZlNTFFNTdjQWQzMkZEZDk0XCI7XHJcbiAgICBNQVJLRVRfQ0FMRU5EQVJfQUREUkVTUyA9IFwiMHg3N2I1NENiRjNlMTM3MGFmMTNkYTQxMTk2QjRkOTljZDAyZUJjQzQ0XCI7XHJcblxyXG59IiwiaW1wb3J0IGxvY2FsaG9zdENvbnRyYWN0QWRkcmVzc2VzIGZyb20gJy4vbG9jYWxob3N0LWNvbnRyYWN0LWFkZHJlc3Nlcyc7XHJcbmltcG9ydCBtdW1iYWlDb250cmFjdEFkZHJlc3NlcyBmcm9tICcuL211bWJhaS1jb250cmFjdC1hZGRyZXNzZXMnO1xyXG5pbXBvcnQgZnVqaUNvbnRyYWN0QWRkcmVzc2VzIGZyb20gJy4vZnVqaS1jb250cmFjdC1hZGRyZXNzZXMnO1xyXG5pbXBvcnQgQ29udHJhY3RBZGRyZXNzZXMgZnJvbSBcIi4vQ29udHJhY3RBZGRyZXNzZXNcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgcG9seWdvbkNvbnRyYWN0QWRkcmVzc2VzIGZyb20gXCIuL3BvbHlnb24tY29udHJhY3QtYWRkcmVzc2VzXCI7XHJcbmltcG9ydCBBcHAgZnJvbSBcIi4uL21haW5cIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250cmFjdEluZm8ge1xyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldENvbnRyYWN0SW5mbyhuZXR3b3JrTmFtZT86IHN0cmluZyk6IENvbnRyYWN0QWRkcmVzc2VzIHtcclxuICAgICAgICBsZXQgY29udHJhY3RJbmZvczogYW55ID0ge1xyXG4gICAgICAgICAgICBsb2NhbGhvc3RDb250cmFjdEFkZHJlc3NlcywgbXVtYmFpQ29udHJhY3RBZGRyZXNzZXMsIGZ1amlDb250cmFjdEFkZHJlc3NlcyxcclxuICAgICAgICAgICAgcG9seWdvbkNvbnRyYWN0QWRkcmVzc2VzXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYgKCFuZXR3b3JrTmFtZSkge1xyXG4gICAgICAgICAgICBuZXR3b3JrTmFtZSA9IEFwcC5OZXR3b3JrLk5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0SW5mb1R5cGUgPSBjb250cmFjdEluZm9zW25ldHdvcmtOYW1lICsgJ0NvbnRyYWN0QWRkcmVzc2VzJ107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb250cmFjdEluZm9UeXBlKCk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQge2V0aGVyc30gZnJvbSBcImV0aGVyc1wiO1xyXG5pbXBvcnQgQXBwIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcbmltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi4vLi4vY29udHJhY3RzL0NvbnRyYWN0QWRkcmVzc2VzXCI7XHJcbmltcG9ydCBDb250cmFjdEluZm8gZnJvbSBcIi4uLy4uL2NvbnRyYWN0cy9Db250cmFjdEluZm9cIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudFNlcnZpY2Uge1xyXG4gICAgY29udHJhY3RzOiBDb250cmFjdEFkZHJlc3NlcztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvbnRyYWN0cyA9IENvbnRyYWN0SW5mby5nZXRDb250cmFjdEluZm8oQXBwLk5ldHdvcmsuTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN1YnNjcmliZVRvQnV5KGhhc2g6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMubGlzdGVuKGhhc2gsICdCdXlXaXRoQVVzZCcpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN1YnNjcmliZVRvU2VsbChoYXNoOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmxpc3RlbihoYXNoLCAnU2VsbFNlY3VyaXR5VG9rZW4nKVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbGlzdGVuKGhhc2g6IHN0cmluZywgZXZlbnROYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnN0b3JlKGhhc2gpO1xyXG5cclxuICAgICAgICBjb25zdCBsbUNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdCh0aGlzLmNvbnRyYWN0cy5MSU1JTkFMX01BUktFVF9BRERSRVNTLCB0aGlzLmxtQWJpLCBBcHAuVXNlci5zaWduZXIpO1xyXG5cclxuICAgICAgICBsZXQgbGlzdGVuZXJzID0gbG1Db250cmFjdC5saXN0ZW5lcnMoZXZlbnROYW1lKTtcclxuICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbG1Db250cmFjdC5vbihldmVudE5hbWUsICh3YWxsZXRBZGRyZXNzOiBzdHJpbmcsIGFtb3VudDogQmlnTnVtYmVyLCBhY2NvdW50SWQ6IHN0cmluZywgc3ltYm9sOiBzdHJpbmcsIHRva2VuQWRkcmVzczogc3RyaW5nLCBzcGVuZGVyOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXZlbnROYW1lICsgJyBldmVudCcpO1xyXG4gICAgICAgICAgICBsbUNvbnRyYWN0Lm9mZihldmVudE5hbWUsIEFwcC5Vc2VyLnByb3ZpZGVyKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaGFzaCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RvcmUoaGFzaDogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCF3aW5kb3cubG9jYWxTdG9yYWdlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBoYXNoZXM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IG9iaiA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGFzaGVzJyk7XHJcbiAgICAgICAgaWYgKG9iaikge1xyXG4gICAgICAgICAgICBoYXNoZXMgPSBKU09OLnBhcnNlKG9iaikgYXMgc3RyaW5nW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhc2hlcy5wdXNoKGhhc2gpO1xyXG4gICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnaGFzaGVzJywgSlNPTi5zdHJpbmdpZnkoaGFzaGVzKSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVtb3ZlKGhhc2g6IHN0cmluZykge1xyXG4gICAgICAgIGlmICghd2luZG93LmxvY2FsU3RvcmFnZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQganNvbiA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnaGFzaGVzJyk7XHJcbiAgICAgICAgaWYgKCFqc29uKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBoYXNoZXMgPSBKU09OLnBhcnNlKGpzb24pIGFzIHN0cmluZ1tdO1xyXG4gICAgICAgIGxldCBpZHggPSBoYXNoZXMuaW5kZXhPZihoYXNoKTtcclxuICAgICAgICBoYXNoZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICAgICAgaWYgKGhhc2hlcy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2hhc2hlcycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnaGFzaGVzJywgSlNPTi5zdHJpbmdpZnkoaGFzaGVzKSlcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbG1BYmkgPSBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBcImFub255bW91c1wiOiBmYWxzZSxcclxuICAgICAgICAgICAgXCJpbnB1dHNcIjogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcImFkZHJlc3NcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJ3YWxsZXRBZGRyZXNzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhbW91bnRcIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwic3ltYm9sXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInRva2VuQWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJhZGRyZXNzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwic3BlbmRlclwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCdXlXaXRoQVVzZFwiLFxyXG4gICAgICAgICAgICBcInR5cGVcIjogXCJldmVudFwiXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIFwiYW5vbnltb3VzXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICBcImlucHV0c1wiOiBbXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudElkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcIndhbGxldEFkZHJlc3NcIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcImFVc2RBZGRyZXNzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcInN0cmluZ1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInN5bWJvbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBcImludGVybmFsVHlwZVwiOiBcInVpbnQyNTZcIixcclxuICAgICAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJhbW91bnRcIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInNwZW5kZXJcIixcclxuICAgICAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2VsbFNlY3VyaXR5VG9rZW5cIixcclxuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXHJcblxyXG59IiwiaW1wb3J0IEVycm9ySW5mbyBmcm9tIFwiLi4vLi4vZXJyb3JzL0Vycm9ySW5mb1wiO1xyXG5pbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuLi8uLi9lcnJvcnMvR2VuZXJhbEVycm9yXCI7XHJcbmltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuaW1wb3J0IEF1dGhlbnRpY2F0ZVNlcnZpY2UgZnJvbSBcIi4uL2JhY2tlbmQvQXV0aGVudGljYXRlU2VydmljZVwiO1xyXG5pbXBvcnQgQmFzZVNlcnZpY2UgZnJvbSBcIi4uL2JhY2tlbmQvQmFzZVNlcnZpY2VcIjtcclxuaW1wb3J0IFVzZXIgZnJvbSBcIi4uLy4uL2R0by9Vc2VyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgQXBwIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcbmltcG9ydCB7ZXRoZXJzfSBmcm9tIFwiZXRoZXJzXCI7XHJcbmltcG9ydCBDb250cmFjdEluZm8gZnJvbSBcIi4uLy4uL2NvbnRyYWN0cy9Db250cmFjdEluZm9cIjtcclxuaW1wb3J0IE5ldHdvcmsgZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtcIjtcclxuaW1wb3J0IENvbnRyYWN0QWRkcmVzc2VzIGZyb20gXCIuLi8uLi9jb250cmFjdHMvQ29udHJhY3RBZGRyZXNzZXNcIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbmltcG9ydCBFdmVudFNlcnZpY2UgZnJvbSBcIi4vRXZlbnRTZXJ2aWNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCbG9ja2NoYWluU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcclxuXHJcbiAgICBuZXR3b3JrOiBOZXR3b3JrO1xyXG4gICAgY29udHJhY3RzOiBDb250cmFjdEFkZHJlc3NlcztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubmV0d29yayA9IEFwcC5OZXR3b3JrO1xyXG4gICAgICAgIHRoaXMuY29udHJhY3RzID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbyh0aGlzLm5ldHdvcmsuTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGFzeW5jIGdldEJhbGFuY2VPZih0b2tlbkFkZHJlc3M6IGFueSwgZXRoQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRFdGhlcigpO1xyXG5cclxuICAgICAgICBpZiAoIUFwcC5Vc2VyLmV0aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KHRva2VuQWRkcmVzcywgdGhpcy5iYWxhbmNlT2ZBYmksIEFwcC5Vc2VyLmV0aGVyKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKGV0aEFkZHJlc3MpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgdHJhbnNmZXJJbm5lcih0b2tlbkFkZHJlc3M6IHN0cmluZywgdG86IHN0cmluZywgcXR5OiBCaWdOdW1iZXIpIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRFdGhlcigpO1xyXG5cclxuICAgICAgICBsZXQgcXR5V2VpID0gZXRoZXJzLnV0aWxzLnBhcnNlVW5pdHMocXR5LnRvU3RyaW5nKCksICdldGhlcicpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygndHJhbnNmZXJJbm5lcicsIHF0eVdlaS50b1N0cmluZygpLCB0b2tlbkFkZHJlc3MsIHRvKTtcclxuICAgICAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QodG9rZW5BZGRyZXNzLCB0aGlzLnRyYW5zZmVyQWJpLCBBcHAuVXNlci5zaWduZXIpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC50cmFuc2Zlcih0bywgcXR5V2VpKTtcclxuXHJcbiAgICAgICAgbGV0IGV2ZW50U2VydmljZSA9IG5ldyBFdmVudFNlcnZpY2UoKTtcclxuICAgICAgICBpZiAodG9rZW5BZGRyZXNzID09IHRoaXMuY29udHJhY3RzLkFVU0RfQUREUkVTUykge1xyXG4gICAgICAgICAgICBldmVudFNlcnZpY2Uuc3Vic2NyaWJlVG9CdXkocmVzdWx0Lmhhc2gpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50U2VydmljZS5zdWJzY3JpYmVUb1NlbGwocmVzdWx0Lmhhc2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ3RyYW5zZmVyIHJlc3VsdCcsIHJlc3VsdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgYXN5bmMgbG9hZEV0aGVyKCkge1xyXG4gICAgICAgIGlmIChBcHAuVXNlci5ldGhlcikgcmV0dXJuO1xyXG4gICAgICAgIGF3YWl0IEF1dGhlbnRpY2F0ZVNlcnZpY2UuZW5hYmxlV2ViMygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXROYXRpdmVCYWxhbmNlKCkge1xyXG4gICAgICAgIGNvbnN0IGJhbGFuY2VJbldlaSA9IGF3YWl0IEFwcC5Vc2VyLmV0aGVyLmdldEJhbGFuY2UoQXBwLlVzZXIuYWRkcmVzcyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJhbGFuY2VJbkV0aGVyID0gZXRoZXJzLnV0aWxzLmZvcm1hdEV0aGVyKGJhbGFuY2VJbldlaSk7XHJcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VJbkV0aGVyXHJcbiAgICB9XHJcblxyXG4gICAgYmFsYW5jZU9mQWJpID0gW3tcclxuICAgICAgICBcImlucHV0c1wiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiYWNjb3VudFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwibmFtZVwiOiBcImJhbGFuY2VPZlwiLFxyXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwidWludDI1NlwiLFxyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxyXG4gICAgfV1cclxuICAgIHRyYW5zZmVyQWJpID0gW1wiZnVuY3Rpb24gdHJhbnNmZXIoYWRkcmVzcyB0bywgdWludCBhbW91bnQpXCJdO1xyXG59IiwiaW1wb3J0IEJsb2NrY2hhaW5FcnJvciBmcm9tIFwiLi4vLi4vZXJyb3JzL0Jsb2NrY2hhaW5FcnJvclwiO1xyXG5pbXBvcnQgQmxvY2tjaGFpblNlcnZpY2UgZnJvbSBcIi4vQmxvY2tjaGFpblNlcnZpY2VcIjtcclxuaW1wb3J0IHtldGhlcnN9IGZyb20gXCJldGhlcnNcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGltaW5hbE1hcmtldFNlcnZpY2UgZXh0ZW5kcyBCbG9ja2NoYWluU2VydmljZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgTGltaW5hbE1hcmtldEluZm86IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRTeW1ib2xDb250cmFjdEFkZHJlc3Moc3ltYm9sOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZEV0aGVyKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdCh0aGlzLmNvbnRyYWN0cy5MSU1JTkFMX01BUktFVF9BRERSRVNTLCB0aGlzLmdldFNlY3VyaXR5VG9rZW5BYmksIEFwcC5Vc2VyLmV0aGVyKTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgY29udHJhY3QuZ2V0U2VjdXJpdHlUb2tlbihzeW1ib2wpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlVG9rZW4oc3ltYm9sOiBzdHJpbmcsIGNyZWF0aW5nVG9rZW46ICgpID0+IHZvaWQpOiBQcm9taXNlPHN0cmluZyB8IEJsb2NrY2hhaW5FcnJvcj4ge1xyXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdCh0aGlzLmNvbnRyYWN0cy5MSU1JTkFMX01BUktFVF9BRERSRVNTLCB0aGlzLmNyZWF0ZVRva2VuQWJpLCBBcHAuVXNlci5zaWduZXIpO1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5jcmVhdGVUb2tlbihzeW1ib2wpO1xyXG5cclxuICAgICAgICBjcmVhdGluZ1Rva2VuKCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdjcmVhdGVUb2tlbiByZXN1bHQ6JywgcmVzdWx0KVxyXG4gICAgICAgIGF3YWl0IHJlc3VsdC53YWl0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFNlY3VyaXR5VG9rZW5BYmkgPSBbe1xyXG4gICAgICAgIFwiaW5wdXRzXCI6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJzdHJpbmdcIixcclxuICAgICAgICAgICAgICAgIFwibmFtZVwiOiBcInN5bWJvbFwiLFxyXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJuYW1lXCI6IFwiZ2V0U2VjdXJpdHlUb2tlblwiLFxyXG4gICAgICAgIFwib3V0cHV0c1wiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwiYWRkcmVzc1wiLFxyXG4gICAgICAgICAgICAgICAgXCJuYW1lXCI6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzdGF0ZU11dGFiaWxpdHlcIjogXCJ2aWV3XCIsXHJcbiAgICAgICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxyXG4gICAgfV1cclxuICAgIGNyZWF0ZVRva2VuQWJpID0gW3tcclxuICAgICAgICBcImlucHV0c1wiOiBbXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIFwiaW50ZXJuYWxUeXBlXCI6IFwic3RyaW5nXCIsXHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJzeW1ib2xcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwibmFtZVwiOiBcImNyZWF0ZVRva2VuXCIsXHJcbiAgICAgICAgXCJvdXRwdXRzXCI6IFtcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgXCJpbnRlcm5hbFR5cGVcIjogXCJjb250cmFjdCBTZWN1cml0eVRva2VuXCIsXHJcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJcIixcclxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInN0YXRlTXV0YWJpbGl0eVwiOiBcIm5vbnBheWFibGVcIixcclxuICAgICAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXHJcbiAgICB9XVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZ3VyZT5cXHJcXG4gICAgPHRhYmxlIGlkPVxcXCJsaW1pbmFsX21hcmtldF9zZWN1cml0aWVzX3RhYmxlXFxcIiByb2xlPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgPHRoZWFkPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGggY29sc3Bhbj1cXFwiMlxcXCI+PGlucHV0IGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiB0eXBlPVxcXCJzZWFyY2hcXFwiIGlkPVxcXCJzZWFyY2hfZm9yX3N5bWJvbFxcXCIgcGxhY2Vob2xkZXI9XFxcIlNlYXJjaCBmb3IgbmFtZSBvciBzeW1ib2wgaW4ge3tzZWN1cml0aWVzQ291bnR9fSBzdG9ja3NcXFwiPjwvdGg+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIDwvdGhlYWQ+XFxyXFxuICAgIDx0Ym9keSBpZD1cXFwie3t0Ym9keUlkfX1cXFwiPlxcclxcbiAgICB7ez5zZWN1cml0aWVzfX1cXHJcXG4gICAgPC90Ym9keT5cXHJcXG48L3RhYmxlPlxcclxcbjxzcGFuIGlkPVxcXCJsaW1pbmFsX21hcmtldF9sb2FkX21vcmVcXFwiPjwvc3Bhbj5cXHJcXG48L2ZpZ3VyZT5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwie3sjZWFjaCBzZWN1cml0aWVzfX1cXHJcXG48dHIgZGF0YS1zeW1ib2w9XFxcInt7e1N5bWJvbH19fVxcXCIgZGF0YS1sb2dvPVxcXCJ7e0xvZ29QYXRofX17e0xvZ299fVxcXCIgZGF0YS1uYW1lPVxcXCJ7e05hbWV9fVxcXCI+XFxyXFxuICAgIDx0ZCBjbGFzcz1cXFwic3ltYm9sX2xvZ29cXFwiPjxpbWcgc3JjPVxcXCJ7e0xvZ29QYXRofX17e0xvZ299fVxcXCIvPjwvdGQ+XFxyXFxuICAgIDx0ZCBjbGFzcz1cXFwic2VjdXJpdHlfaW5mb3JtYXRpb25cXFwiPlxcclxcbiAgICAgICAgPHN0cm9uZz57e05hbWV9fTwvc3Ryb25nPjxici8+XFxyXFxuICAgICAgICA8bmF2IGNsYXNzPVxcXCJzZWN1cml0eV9leHRyYVxcXCI+XFxyXFxuICAgICAgICAgICAgPHVsPlxcclxcbiAgICAgICAgICAgICAgICA8bGk+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJodHRwczovL3N0cmlrZS5tYXJrZXQvc3RvY2tzL3t7U3ltYm9sfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57e1N5bWJvbH19PC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgICAgIDwvdWw+XFxyXFxuICAgICAgICAgICAgPHVsPlxcclxcbiAgICAgICAgICAgICAgICA8bGk+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8YSBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJnZXRBZGRyZXNzXFxcIiBkYXRhLXN5bWJvbD1cXFwie3tTeW1ib2x9fVxcXCI+R2V0IGFkZHJlc3M8L2E+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgPC91bD5cXHJcXG4gICAgICAgICAgICA8dWw+XFxyXFxuICAgICAgICAgICAgICAgIDxsaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImFkZFRvV2FsbGV0XFxcIiBkYXRhLXN5bWJvbD1cXFwie3tTeW1ib2x9fVxcXCI+QWRkIHRvIHdhbGxldDwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgPC9uYXY+XFxyXFxuICAgIDwvdGQ+XFxyXFxuPC90cj5cXHJcXG57ey9lYWNofX1cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29weUhlbHBlciB7XHJcblxyXG4gICAgcHVibGljIGZhbGxiYWNrQ29weVRleHRUb0NsaXBib2FyZCh0ZXh0IDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHRleHRBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xyXG4gICAgICAgIHRleHRBcmVhLnZhbHVlID0gdGV4dDtcclxuXHJcbiAgICAgICAgLy8gQXZvaWQgc2Nyb2xsaW5nIHRvIGJvdHRvbVxyXG4gICAgICAgIHRleHRBcmVhLnN0eWxlLnRvcCA9IFwiMFwiO1xyXG4gICAgICAgIHRleHRBcmVhLnN0eWxlLmxlZnQgPSBcIjBcIjtcclxuICAgICAgICB0ZXh0QXJlYS5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXh0QXJlYSk7XHJcbiAgICAgICAgdGV4dEFyZWEuZm9jdXMoKTtcclxuICAgICAgICB0ZXh0QXJlYS5zZWxlY3QoKTtcclxuXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbGV0IHN1Y2Nlc3NmdWwgPSBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xyXG4gICAgICAgICAgICByZXR1cm4gc3VjY2Vzc2Z1bDtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGNvcHlUZXh0VG9DbGlwYm9hcmQodGV4dCA6IHN0cmluZykge1xyXG4gICAgICAgIGlmICghbmF2aWdhdG9yLmNsaXBib2FyZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mYWxsYmFja0NvcHlUZXh0VG9DbGlwYm9hcmQodGV4dCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihibGUgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYmxlJywgYmxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWVcclxuICAgICAgICB9KS5cclxuICAgICAgICBjYXRjaChmdW5jdGlvbihlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS5pbmZvKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGFydGljbGUgaWQ9XFxcInN5bWJvbEluZm9Ub0NvcHlcXFwiPlxcclxcbiAgICBUaGlzIGlzIHRoZSBhZGRyZXNzIGZvciB0aGUgc3ltYm9sIHt7c3ltYm9sfX0uXFxyXFxuICAgIDxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwie3thZGRyZXNzfX1cXFwiLz5cXHJcXG48L2FydGljbGU+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjx0ciBpZD1cXFwic3ltYm9sSW5mb1RvQ29weVxcXCI+XFxyXFxuICAgIDx0ZCBjb2xzcGFuPVxcXCI0XFxcIj5cXHJcXG4gICAgICAgIDxhcnRpY2xlPlxcclxcbiAgICAgICAgVGhpcyBzeW1ib2wgaGFzIG5ldmVyIGJlZW4gYm91Z2h0IGFuZCBkb2VzIG5vdCBleGlzdC4gQnV5IHRoaXMgc3ltYm9sIGFuZCBhZGRyZXNzIHdpbGwgYmVjb21lIGF2YWlsYWJsZS5cXHJcXG4gICAgICAgIDwvYXJ0aWNsZT5cXHJcXG4gICAgPC90ZD5cXHJcXG48L3RyPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YXJ0aWNsZT5cXHJcXG4gICAgU29tZSB3YWxsZXRzIGRldGVjdCBhdXRvbWF0aWNhbGx5IHRoZSBjb2lucyB0aGF0IGFyZSByZWdpc3RlcmVkIHRvIHlvdXIgYWRkcmVzcy5cXHJcXG4gICAgVGhvc2UgdGhhdCBkb24ndCBkbyBhdXRvbWF0aWMgZGV0ZWN0aW9uLCB5b3UgbmVlZCB0byBhZGQgdGhlbSBtYW51YWxseS5cXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICBUaGlzIGlzIHRoZSBhZGRyZXNzIGZvciB0aGUgc3ltYm9sIHt7c3ltYm9sfX0sXFxyXFxuICAgIHlvdSBuZWVkIHRvIGNvcHkgaXQgYW5kIGltcG9ydCB0aGUgdG9rZW4gaW4geW91ciB3YWxsZXRcXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICBDb250cmFjdCBhZGRyZXNzOjxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwie3thZGRyZXNzfX1cXFwiLz5cXHJcXG4gICAgU3ltYm9sOjxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwie3tzeW1ib2x9fVxcXCIvPlxcclxcbiAgICBEZWNpbWFsOjxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwiMThcXFwiLz5cXHJcXG48L2FydGljbGU+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImV4cG9ydCBlbnVtIEluZm9CYXJUeXBlIHtcclxuICAgIEluZm8gPSAnaW5mb0JhcicsXHJcbiAgICBXYXJuaW5nID0gJ3dhcm5pbmdCYXInLFxyXG4gICAgRXJyb3IgPSAnZXJyb3JCYXInXHJcbn0iLCJpbXBvcnQge0luZm9CYXJUeXBlfSBmcm9tIFwiLi9JbmZvQmFyVHlwZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mb0JhciB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzaG93KG1lc3NhZ2UgOiBzdHJpbmcsIHR5cGUgOiBJbmZvQmFyVHlwZSwgdGltZW91dEluU2Vjb25kcyA6IG51bWJlciA9IDQpIHtcclxuICAgICAgICBsZXQgaW5mb0JhciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbmZvQmFyJyk7XHJcbiAgICAgICAgaWYgKCFpbmZvQmFyKSB7XHJcbiAgICAgICAgICAgIGluZm9CYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgaW5mb0Jhci5jbGFzc0xpc3QuYWRkKCdub3RpZmljYXRpb25CYXInKTtcclxuICAgICAgICAgICAgaW5mb0Jhci5pZCA9ICdpbmZvQmFyJztcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2FmdGVyYmVnaW4nLCBpbmZvQmFyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluZm9CYXIuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICAgICAgICBpbmZvQmFyLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgIGluZm9CYXIuY2xhc3NMaXN0LnJlbW92ZShJbmZvQmFyVHlwZS5JbmZvKTtcclxuICAgICAgICBpbmZvQmFyLmNsYXNzTGlzdC5yZW1vdmUoSW5mb0JhclR5cGUuV2FybmluZyk7XHJcbiAgICAgICAgaW5mb0Jhci5jbGFzc0xpc3QucmVtb3ZlKEluZm9CYXJUeXBlLkVycm9yKTtcclxuICAgICAgICBpbmZvQmFyLmNsYXNzTGlzdC5hZGQodHlwZSlcclxuICAgICAgICBpZiAodGltZW91dEluU2Vjb25kcyA+IDApIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpbmZvQmFyPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgfSwgdGltZW91dEluU2Vjb25kcyAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIlxcclxcbllvdSBuZWVkIHRvIHNldCB1cCBhIHdhbGxldCBpbiB5b3VyIGJyb3dzZXIgYmVmb3JlIHlvdSBjYW4gdXNlIGxpbWluYWwubWFya2V0Llxcclxcbjxici8+PGJyLz5cXHJcXG5UbyBtYWtlIGl0IHNpbXBsZSwgd2Ugd291bGQgbGlrZSB0byBzdWdnZXN0IHR3byBvcHRpb25zLiBJbiB5b3VyIGJyb3dzZXIgb3IgeW91ciBwaG9uZS5cXHJcXG48dWw+XFxyXFxuICAgIDxsaT5Gb3IgdGhlIGJyb3dzZXIgd2UgcmVjb21tZW5kIDxhIGhyZWY9XFxcImh0dHBzOi8vbWV0YW1hc2suaW8vZG93bmxvYWQvXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+TWV0YW1hc2s8L2E+LlxcclxcbiAgICA8L2xpPlxcclxcbiAgICA8bGk+XFxyXFxuICAgICAgICBGb3IgeW91ciBwaG9uZSwgd2UgbGlrZSA8YSBocmVmPVxcXCJodHRwczovL3d3dy50b2tlbnBvY2tldC5wcm8vZW4vZG93bmxvYWQvYXBwXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+VG9rZW4gUG9rZXQ8L2E+XFxyXFxuICAgIDwvbGk+XFxyXFxuPC91bD5cXHJcXG48YnIvPlxcclxcbkJ1dCwgeW91IGhhdmUgPGEgaHJlZj1cXFwiaHR0cHM6Ly9ldGhlcmV1bS5vcmcvZW4vd2FsbGV0cy9cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5tYW55IG9wdGlvbnM8L2E+IGlmIHlvdSB3YW50IHRvIGxlYXJuIG1vcmUuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBJbmZvQmFyIGZyb20gXCIuLi91aS9lbGVtZW50cy9JbmZvQmFyXCI7XHJcbmltcG9ydCB7SW5mb0JhclR5cGV9IGZyb20gXCIuLi91aS9lbGVtZW50cy9JbmZvQmFyVHlwZVwiO1xyXG5pbXBvcnQgV2FsbGV0TWlzc2luZ0h0bWwgZnJvbSAnLi4vaHRtbC9tb2RhbC9XYWxsZXRNaXNzaW5nLmh0bWwnO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL3VpL21vZGFscy9Nb2RhbFwiO1xyXG5pbXBvcnQgU3dpdGNoTmV0d29ya01vZGFsIGZyb20gXCIuLi91aS9tb2RhbHMvU3dpdGNoTmV0d29ya01vZGFsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVkZWZpbmVkRXJyb3JIYW5kbGVycyB7XHJcblxyXG4gICAgZXJyb3JNZXNzYWdlTWFwcGluZyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XHJcbiAgICBTZW50TG9naW5SZXF1ZXN0ID0gXCJXZSBoYXZlIHNlbnQgcmVxdWVzdCB0byB5b3Ugd2FsbGV0IHRvIGxvZ2luLiBPcGVuIHlvdXIgd2FsbGV0IHRvIGxvZ2luXCI7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ2NoYWluIG5vdCBzdXBwb3J0ZWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkaXYgPSAnTmV0d29yayBpcyBub3Qgc3VwcG9ydGVkLiA8YSBocmVmPVwiXCIgaWQ9XCJzd2l0Y2hOZXR3b3JrTGlua1wiPkNsaWNrIG1lIHRvIHN3aXRjaCB0byBzdXBwb3J0ZWQgbmV0d29yazwvYT4nO1xyXG5cclxuICAgICAgICAgICAgSW5mb0Jhci5zaG93KGRpdiwgSW5mb0JhclR5cGUuV2FybmluZywgMTIwKVxyXG5cclxuICAgICAgICAgICAgbGV0IHN3aXRjaE5ldHdvcmtMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N3aXRjaE5ldHdvcmtMaW5rJyk7XHJcbiAgICAgICAgICAgIHN3aXRjaE5ldHdvcmtMaW5rPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IFN3aXRjaE5ldHdvcmtNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuc2hvdygpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ2FscmVhZHkgcHJvY2Vzc2luZyBldGhfcmVxdWVzdGFjY291bnRzJywgdGhpcy5TZW50TG9naW5SZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZU1hcHBpbmcuc2V0KCdyZXF1ZXN0IG9mIHR5cGUgXFwnd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9uc1xcJyBhbHJlYWR5IHBlbmRpbmcnLCB0aGlzLlNlbnRMb2dpblJlcXVlc3QpO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ2FscmVhZHkgaGFzIGJlZW4gY2FsbGVkLCBidXQgaXMgbm90IGZpbmlzaGVkIHlldCcsIHRoaXMuU2VudExvZ2luUmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VNYXBwaW5nLnNldCgncmVxdWVzdCBpcyBhbHJlYWR5IGluIHByb2dyZXNzJywgdGhpcy5TZW50TG9naW5SZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZU1hcHBpbmcuc2V0KCd3ZWIzIGluc3RhbmNlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmxpbWluYWxfbWFya2V0X2Nvbm5lY3Rfd2FsbGV0XCIpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNbMF0uZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnY2xpY2snKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ3VzZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3QnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIE1vcmFsaXMuVXNlci5sb2dPdXQoKTtcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ05vbiBldGhlcmV1bSBlbmFibGVkIGJyb3dzZXInLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoV2FsbGV0TWlzc2luZ0h0bWwpO1xyXG4gICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ05ldyB0byBibG9ja2NoYWluPycsIHRlbXBsYXRlKG51bGwpLCBmYWxzZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy93aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGhhbmRsZShtZXNzYWdlIDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZU1hcHBpbmcuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZWQgJiYgbWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgSW5mb0Jhci5zaG93KHZhbHVlLnRvU3RyaW5nKCksIEluZm9CYXJUeXBlLldhcm5pbmcsIDEwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIHJldHVybiBoYW5kbGVkO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi9HZW5lcmFsRXJyb3JcIjtcclxuaW1wb3J0IFByZWRlZmluZWRFcnJvckhhbmRsZXJzIGZyb20gXCIuL1ByZWRlZmluZWRFcnJvckhhbmRsZXJzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFcnJvckluZm8ge1xyXG5cclxuICAgIGVycm9ySW5mbzogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGVycm9ySW5mbzogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5lcnJvckluZm8gPSBlcnJvckluZm87XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEVycm9ySW5mbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckluZm87XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZXBvcnQoZXJyb3I6IEdlbmVyYWxFcnJvcikge1xyXG4gICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgIGlmICghZXJyb3IpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGVycm9ySGFuZGxlciA9IG5ldyBQcmVkZWZpbmVkRXJyb3JIYW5kbGVycygpO1xyXG4gICAgICAgIGlmIChlcnJvckhhbmRsZXIuaGFuZGxlKGVycm9yLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlcnJvci5jYWxsYmFjaykge1xyXG4gICAgICAgICAgICBlcnJvci5jYWxsYmFjaygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL0luZm9CYXIuc2hvdyhlcnJvci5tZXNzYWdlLCBJbmZvQmFyVHlwZS5FcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBsb2cob2JqOiBhbnkpIHtcclxuICAgICAgICBFcnJvckluZm8ucmVwb3J0KG5ldyBHZW5lcmFsRXJyb3Iob2JqKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBpbmZvKG9iajogYW55KSB7XHJcbiAgICAgICAgRXJyb3JJbmZvLnJlcG9ydChuZXcgR2VuZXJhbEVycm9yKG9iaikpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZXJyb3Iob2JqOiBhbnkpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhvYmopO1xyXG4gICAgICAgIEVycm9ySW5mby5yZXBvcnQobmV3IEdlbmVyYWxFcnJvcihvYmopKTtcclxuICAgIH1cclxufSIsImltcG9ydCBTZWN1cml0aWVzU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYnJva2VyL1NlY3VyaXRpZXNTZXJ2aWNlXCI7XHJcbmltcG9ydCBTZWN1cml0aWVzTGlzdEh0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9TZWN1cml0aWVzTGlzdC5odG1sJ1xyXG5pbXBvcnQgU2VjdXJpdHlIdG1sIGZyb20gJy4uLy4uL2h0bWwvZWxlbWVudHMvU2VjdXJpdGllcy5odG1sJztcclxuaW1wb3J0IFNlY3VyaXR5IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9icm9rZXIvU2VjdXJpdHlcIjtcclxuaW1wb3J0IExpbWluYWxNYXJrZXRTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0xpbWluYWxNYXJrZXRTZXJ2aWNlXCI7XHJcbmltcG9ydCBDb3B5SGVscGVyIGZyb20gXCIuLi8uLi91dGlsL0NvcHlIZWxwZXJcIjtcclxuaW1wb3J0IEFkZHJlc3NJbmZvSHRtbCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL0FkZHJlc3NJbmZvLmh0bWwnO1xyXG5pbXBvcnQgQ29udHJhY3RBZGRyZXNzTm90Rm91bmQgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9Db250cmFjdEFkZHJlc3NOb3RGb3VuZC5odG1sJztcclxuaW1wb3J0IHtBZGRyZXNzWmVyb30gZnJvbSBcIi4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCBBZGRUb1dhbGxldEh0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9BZGRUb1dhbGxldC5odG1sJztcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBHZW5lcmFsRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9HZW5lcmFsRXJyb3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3VyaXRpZXNMaXN0IHtcclxuICAgIHBhZ2U6IG51bWJlcjtcclxuICAgIHRib2R5SWQgPSAnbGltaW5hbF9tYXJrZXRfc2VjdXJpdGllc19saXN0JztcclxuICAgIGxvYWRtb3JlOiBib29sZWFuO1xyXG4gICAgb25TZWxlY3RTeW1ib2w/OiAoc3ltYm9sOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbG9nbzogc3RyaW5nKSA9PiB2b2lkID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2FkbW9yZSA9IHRydWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXIoKSB7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXNTZXJ2aWNlID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXNDb3VudCA9IHNlY3VyaXRpZXNTZXJ2aWNlLnNlY3VyaXRpZXNBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXMgPSBhd2FpdCBzZWN1cml0aWVzU2VydmljZS5nZXRQYWdpbmF0aW5nU2VjdXJpdGllcyh0aGlzLnBhZ2UrKyk7XHJcblxyXG4gICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJQYXJ0aWFsKFxyXG4gICAgICAgICAgICBcInNlY3VyaXRpZXNcIixcclxuICAgICAgICAgICAgU2VjdXJpdHlIdG1sXHJcbiAgICAgICAgKVxyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU2VjdXJpdGllc0xpc3RIdG1sKTtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIHRib2R5SWQ6IHRoaXMudGJvZHlJZCxcclxuICAgICAgICAgICAgc2VjdXJpdGllczogc2VjdXJpdGllcyxcclxuICAgICAgICAgICAgc2VjdXJpdGllc0NvdW50OiBzZWN1cml0aWVzQ291bnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKG9iaik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGJpbmRFdmVudHMob25TZWxlY3RTeW1ib2w6IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICB0aGlzLmJpbmRPbkNsaWNrRXZlbnQob25TZWxlY3RTeW1ib2wpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYmluZFNlYXJjaEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5iaW5kTG9hZE1vcmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJpbmRPbkNsaWNrRXZlbnQob25TZWxlY3RTeW1ib2w6IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfc2VjdXJpdGllc190YWJsZScpO1xyXG5cclxuICAgICAgICBpZiAoIXRhYmxlKSB7XHJcbiAgICAgICAgICAgIEVycm9ySW5mby5yZXBvcnQobmV3IEdlbmVyYWxFcnJvcihcIlBhZ2UgY291bGQgbm90IGxvYWQgY29ycmVjdGx5LCB0cnkgcmVsb2FkaW5nXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uU2VsZWN0U3ltYm9sID0gb25TZWxlY3RTeW1ib2w7XHJcblxyXG4gICAgICAgIHRhYmxlLm9uY2xpY2sgPSBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlQ2xpY2soZXZ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGhhbmRsZUNsaWNrKGV2dDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gKGV2dC50YXJnZXQhIGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09ICdhJykge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFRvV2FsbGV0T3JHZXRBZGRyZXNzKGV2dCwgZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwYXJlbnRUciA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICAgICAgICBpZiAoIXBhcmVudFRyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChwYXJlbnRUci50YWdOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgIT09ICd0cicpIHtcclxuICAgICAgICAgICAgcGFyZW50VHIgPSBwYXJlbnRUci5wYXJlbnRFbGVtZW50ITtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzeW1ib2wgPSBwYXJlbnRUci5kYXRhc2V0LnN5bWJvbDtcclxuICAgICAgICBpZiAoIXN5bWJvbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgbmFtZSA9IHBhcmVudFRyLmRhdGFzZXQubmFtZSFcclxuICAgICAgICBsZXQgbG9nbyA9IHBhcmVudFRyLmRhdGFzZXQubG9nbyE7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uU2VsZWN0U3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3RTeW1ib2woc3ltYm9sLCBuYW1lLCBsb2dvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBiaW5kU2VhcmNoRXZlbnQoKSB7XHJcbiAgICAgICAgbGV0IHNlYXJjaEZvclN5bWJvbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2hfZm9yX3N5bWJvbCcpO1xyXG4gICAgICAgIGlmICghc2VhcmNoRm9yU3ltYm9sKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0aWVzU2VydmljZSA9IGF3YWl0IFNlY3VyaXRpZXNTZXJ2aWNlLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICAgIGxldCB0aW1lb3V0OiBhbnkgPSBudWxsO1xyXG4gICAgICAgIHNlYXJjaEZvclN5bWJvbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzZWFyY2ggPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghc2VhcmNoIHx8IHNlYXJjaC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkbW9yZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zaG93VG9wU2VjdXJpdGllcyhzZWN1cml0aWVzU2VydmljZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkbW9yZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgc2VjdXJpdGllc1NlcnZpY2UuZmluZChzZWFyY2gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkU2VjdXJpdGllc1RvRG9tKHNlY3VyaXRpZXMpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93VG9wU2VjdXJpdGllcyhzZWN1cml0aWVzU2VydmljZTogU2VjdXJpdGllc1NlcnZpY2UpIHtcclxuICAgICAgICBsZXQgc2VjdXJpdGllcyA9IGF3YWl0IHNlY3VyaXRpZXNTZXJ2aWNlLmdldFRvcFNlY3VyaXRpZXMoKTtcclxuICAgICAgICB0aGlzLmxvYWRTZWN1cml0aWVzVG9Eb20oc2VjdXJpdGllcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBsb2FkU2VjdXJpdGllc1RvRG9tKHNlY3VyaXRpZXM6IEFycmF5PFNlY3VyaXR5Pikge1xyXG4gICAgICAgIGxldCB0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudGJvZHlJZCk7XHJcbiAgICAgICAgaWYgKCF0Ym9keSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU2VjdXJpdHlIdG1sKTtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIHNlY3VyaXRpZXM6IHNlY3VyaXRpZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZShvYmopO1xyXG4gICAgICAgIHRib2R5LmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kTG9hZE1vcmUoKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpbWluYWxfbWFya2V0X2xvYWRfbW9yZScpITtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoYXN5bmMgKFtlbnRyeV0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogMC4xLCAvLyBzZXQgb2Zmc2V0IDAuMSBtZWFucyB0cmlnZ2VyIGlmIGF0bGVhc3QgMTAlIG9mIGVsZW1lbnQgaW4gdmlld3BvcnRcclxuICAgICAgICB9KTtcclxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZE1vcmUodGhpczogU2VjdXJpdGllc0xpc3QpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIXRoaXMubG9hZG1vcmUpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy50Ym9keUlkKTtcclxuICAgICAgICBpZiAoIXRib2R5KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0aWVzU2VydmljZSA9IGF3YWl0IFNlY3VyaXRpZXNTZXJ2aWNlLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXMgPSBhd2FpdCBzZWN1cml0aWVzU2VydmljZS5nZXRQYWdpbmF0aW5nU2VjdXJpdGllcyh0aGlzLnBhZ2UrKyk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShTZWN1cml0eUh0bWwpO1xyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgc2VjdXJpdGllczogc2VjdXJpdGllc1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKG9iaik7XHJcblxyXG4gICAgICAgIHRib2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgY29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBhZGRUb1dhbGxldE9yR2V0QWRkcmVzcyhldmVudDogTW91c2VFdmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSAnZ2V0QWRkcmVzcycgJiYgY2xhc3NOYW1lICE9ICdhZGRUb1dhbGxldCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgbGV0IHN5bWJvbCA9IGVsZW1lbnQuZGF0YXNldC5zeW1ib2w7XHJcbiAgICAgICAgaWYgKCFzeW1ib2wpIHJldHVybjtcclxuXHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgYWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG5cclxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdnZXRBZGRyZXNzJykge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNob3dHZXRBZGRyZXNzKGVsZW1lbnQsIHN5bWJvbCwgYWRkcmVzcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaG93QWRkVG9XYWxsZXQoZWxlbWVudCwgc3ltYm9sLCBhZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzaG93R2V0QWRkcmVzcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgc3ltYm9sOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgICAgIGlmIChhZGRyZXNzICE9PSBBZGRyZXNzWmVybykge1xyXG4gICAgICAgICAgICBsZXQgY29weUhlbHBlciA9IG5ldyBDb3B5SGVscGVyKCk7XHJcbiAgICAgICAgICAgIGxldCBzdWNjZXNzID0gYXdhaXQgY29weUhlbHBlci5jb3B5VGV4dFRvQ2xpcGJvYXJkKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSAnQ29waWVkJztcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckNvbnRyYWN0SW5mb1RvU3RyaW5nKGVsZW1lbnQsIGFkZHJlc3MsIHN5bWJvbCwgQWRkcmVzc0luZm9IdG1sKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93QWRkVG9XYWxsZXQoZWxlbWVudDogSFRNTEVsZW1lbnQsIHN5bWJvbDogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoYWRkcmVzcyAhPT0gQWRkcmVzc1plcm8pIHtcclxuICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhZGRlZCA9IGF3YWl0IHdhbGxldEhlbHBlci5hZGRUb2tlblRvV2FsbGV0KGFkZHJlc3MsIHN5bWJvbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNvbnRyYWN0SW5mb1RvU3RyaW5nKGVsZW1lbnQsIGFkZHJlc3MsIHN5bWJvbCwgQWRkVG9XYWxsZXRIdG1sKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChhZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckNvbnRyYWN0SW5mb1RvU3RyaW5nKGVsZW1lbnQsIGFkZHJlc3MsIHN5bWJvbCwgQWRkVG9XYWxsZXRIdG1sKTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyQ29udHJhY3RJbmZvVG9TdHJpbmcoZWxlbWVudDogSFRNTEVsZW1lbnQsIGFkZHJlc3M6IHN0cmluZywgc3ltYm9sOiBzdHJpbmcsIHRlbXBsYXRlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgc3ltYm9sSW5mb1RvQ29weSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW1ib2xJbmZvVG9Db3B5Jyk7XHJcbiAgICAgICAgaWYgKHN5bWJvbEluZm9Ub0NvcHkpIHN5bWJvbEluZm9Ub0NvcHkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICAgICAgaWYgKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShDb250cmFjdEFkZHJlc3NOb3RGb3VuZCk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0ZW1wbGF0ZShudWxsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoQWRkcmVzc0luZm9IdG1sKTtcclxuICAgICAgICAgICAgbGV0IG9iajogYW55ID0ge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBzeW1ib2wsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGVudCA9IHRlbXBsYXRlKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGNvbnRlbnQpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IEJhc2VTZXJ2aWNlIGZyb20gXCIuLi9iYWNrZW5kL0Jhc2VTZXJ2aWNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYXJrZXRTZXJ2aWNlIGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBpc01hcmtldE9wZW4oKTogUHJvbWlzZTxhbnk+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoJ2lzT3BlbicpO1xyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBNYXJrZXRTZXJ2aWNlIGZyb20gXCIuLi9icm9rZXIvTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQgQXV0aGVudGljYXRlU2VydmljZSBmcm9tIFwiLi9BdXRoZW50aWNhdGVTZXJ2aWNlXCI7XHJcbmltcG9ydCBQcm92aWRlckluZm8gZnJvbSBcIi4uLy4uL3dhbGxldC9Qcm92aWRlckluZm9cIjtcclxuaW1wb3J0IEt5Y1Jlc3VsdCBmcm9tIFwiLi4vLi4vZHRvL0t5Y1Jlc3VsdFwiO1xyXG5pbXBvcnQge0JhbmtSZWxhdGlvbnNoaXB9IGZyb20gXCIuLi8uLi9kdG8vYWxwYWNhL0JhbmtSZWxhdGlvbnNoaXBcIjtcclxuaW1wb3J0IHtUcmFuc2Zlcn0gZnJvbSBcIi4uLy4uL2R0by9hbHBhY2EvVHJhbnNmZXJcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuaW1wb3J0IENvb2tpZUhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9Db29raWVIZWxwZXJcIjtcclxuaW1wb3J0IFVzZXJJbmZvIGZyb20gXCIuLi8uLi91aS9lbGVtZW50cy9Vc2VySW5mb1wiO1xyXG5pbXBvcnQgVXNlciBmcm9tIFwiLi4vLi4vZHRvL1VzZXJcIjtcclxuaW1wb3J0IHtldGhlcnN9IGZyb20gXCJldGhlcnNcIjtcclxuaW1wb3J0IE5ldHdvcmsgZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtcIjtcclxuaW1wb3J0IEJhc2VTZXJ2aWNlIGZyb20gXCIuL0Jhc2VTZXJ2aWNlXCI7XHJcbmltcG9ydCBBcHAgZnJvbSBcIi4uLy4uL21haW5cIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVc2VyU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcclxuICAgIHN0YXRpYyByZWFkb25seSBzaWduZWRNZXNzYWdlID0gJ3NpZ25lZE1lc3NhZ2UnXHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBpc01hcmtldE9wZW5PclVzZXJPZmZIb3VycygpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBsZXQgbWFya2V0U2VydmljZSA9IG5ldyBNYXJrZXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgbWFya2V0U2VydmljZS5pc01hcmtldE9wZW4oKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UubWFya2V0SXNPcGVuO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRVc2VyKCkge1xyXG4gICAgICAgIGxldCBjb29raWVIZWxwZXIgPSBuZXcgQ29va2llSGVscGVyKGRvY3VtZW50KTtcclxuICAgICAgICBsZXQgc2lnbmVkTWVzc2FnZSA9IGNvb2tpZUhlbHBlci5nZXRDb29raWVWYWx1ZSgnc2lnbmVkTWVzc2FnZScpO1xyXG5cclxuICAgICAgICBpZiAoIXNpZ25lZE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgQXBwLlVzZXIgPSBuZXcgVXNlcihudWxsLCAnJywgQXBwLk5ldHdvcmsuQ2hhaW5JZCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBBcHAuVXNlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2lnbmluZ0FkZHJlc3MgPSBldGhlcnMudXRpbHMucmVjb3ZlckFkZHJlc3MoJycsIHNpZ25lZE1lc3NhZ2UpXHJcbiAgICAgICAgQXBwLlVzZXIgPSBuZXcgVXNlcihudWxsLCBzaWduaW5nQWRkcmVzcywgQXBwLk5ldHdvcmsuQ2hhaW5JZCwgbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIEFwcC5Vc2VyO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKGFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvdXNlcicsIHtib2R5OiBhZGRyZXNzfSk7XHJcbiAgICAgICAgbGV0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKClcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QWxwYWNhSWQoKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICBsZXQgdXNlciA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xyXG4gICAgICAgIGlmICh1c2VyLmFscGFjYUlkKSByZXR1cm4gdXNlci5hbHBhY2FJZDtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGZldGNoKCcnLCkgYXMgYW55O1xyXG4gICAgICAgIHVzZXIuYWxwYWNhSWQgPSByZXN1bHQuYWxwYWNhSWQ7XHJcbiAgICAgICAgcmV0dXJuIHVzZXIuYWxwYWNhSWQhO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBY2NvdW50KCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldCgnYWNjb3VudCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEV0aEFkZHJlc3MoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgICAgICByZXR1cm4gQXBwLlVzZXIuYWRkcmVzcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMga3ljQWN0aW9uUmVxdWlyZWQoKTogUHJvbWlzZTxLeWNSZXN1bHQ+IHtcclxuICAgICAgICBsZXQga3ljUmVzdWx0cyA9IGF3YWl0IHRoaXMuZ2V0KCdreWNBY3Rpb25SZXF1aXJlZCcpIGFzIEt5Y1Jlc3VsdDtcclxuICAgICAgICByZXR1cm4ga3ljUmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlTmFtZShnaXZlbl9uYW1lOiBzdHJpbmcsIG1pZGRsZV9uYW1lOiBzdHJpbmcsIGZhbWlseV9uYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0KCd1cGRhdGVOYW1lJywge1xyXG4gICAgICAgICAgICBnaXZlbl9uYW1lOiBnaXZlbl9uYW1lLFxyXG4gICAgICAgICAgICBtaWRkbGVfbmFtZTogbWlkZGxlX25hbWUsXHJcbiAgICAgICAgICAgIGZhbWlseV9uYW1lOiBmYW1pbHlfbmFtZVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZUNvbnRhY3QoZGF0YTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdCgndXBkYXRlQ29udGFjdCcsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB1cGRhdGVUcnVzdGVkQ29udGFjdChkYXRhOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0KCd1cGRhdGVUcnVzdGVkQ29udGFjdCcsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVBY2hSZWxhdGlvbnNoaXAoYWNjb3VudF9vd25lcl9uYW1lOiBzdHJpbmcsIGJhbmtfYWNjb3VudF90eXBlOiBzdHJpbmcsIGJhbmtfYWNjb3VudF9udW1iZXI6IHN0cmluZywgYmFua19yb3V0aW5nX251bWJlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdDxCYW5rUmVsYXRpb25zaGlwPignY3JlYXRlQWNoUmVsYXRpb25zaGlwJywge1xyXG4gICAgICAgICAgICBhY2NvdW50X293bmVyX25hbWUsIGJhbmtfYWNjb3VudF90eXBlLCBiYW5rX2FjY291bnRfbnVtYmVyLCBiYW5rX3JvdXRpbmdfbnVtYmVyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldEJhbmtSZWxhdGlvbnNoaXAoKTogUHJvbWlzZTxCYW5rUmVsYXRpb25zaGlwPiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0KCdnZXRCYW5rUmVsYXRpb25zaGlwJykgYXMgQmFua1JlbGF0aW9uc2hpcFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRMYXRlc3RUcmFuc2ZlcnMoZGlyZWN0aW9uOiBUcmFuc2ZlckRpcmVjdGlvbkVudW0pIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoJ2dldFRyYW5zZmVycycsIHtkaXJlY3Rpb246IGRpcmVjdGlvbn0pIGFzIFRyYW5zZmVyW107XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGNyZWF0ZVRyYW5zZmVyKGFtb3VudDogc3RyaW5nLCBkaXJlY3Rpb246IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3QoJ2NyZWF0ZVRyYW5zZmVyJyxcclxuICAgICAgICAgICAge2Ftb3VudDogYW1vdW50LCBkaXJlY3Rpb246IGRpcmVjdGlvbn0pXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGVsZXRlVHJhbnNmZXIoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3QoJ2RlbGV0ZVRyYW5zZmVyJywge2lkOiBpZH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZWdpc3RlcldpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcChwYXJhbXM6IGFueSkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBvc3Q8QmFua1JlbGF0aW9uc2hpcD4oJ2NyZWF0ZVdpcmVSZWxhdGlvbnNoaXAnLCBwYXJhbXMpO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBpZD1cXFwidXNlck1lbnVQYW5lbFxcXCI+XFxyXFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ1c2VySW5mb0FjdGlvblxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiPlxcclxcbiAgICAgICAgPGltZyBzcmM9XFxcImh0dHBzOi8vZWZmaWd5LmltL2Eve3tldGhBZGRyZXNzfX0ucG5nXFxcIiB3aWR0aD1cXFwiMjRcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gaWQ9XFxcInVzZXJfaW5mb19ldGhBZGRyZXNzXFxcIj57e3Nob3J0RXRoQWRkcmVzc319PC9zcGFuPlxcclxcbiAgICA8L2E+XFxyXFxuXFxyXFxuICAgIDxkaXYgaWQ9XFxcInVzZXJJbmZvRHJvcGRvd25cXFwiIGNsYXNzPVxcXCJkLW5vbmVcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZCBhY2NvdW50X2luZm9cXFwiPlxcclxcbiAgICAgICAgICAgIDxoNj5BY2NvdW50PC9oNj5cXHJcXG4gICAgICAgICAgICA8YSBpZD1cXFwiZGlzY29ubmVjdEZyb21OZXR3b3JrXFxcIiBocmVmPVxcXCIjXFxcIj5EaXNjb25uZWN0PC9hPlxcclxcblxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlZGl0X2FjY291bnRcXFwiPlxcclxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJlZGl0TmFtZVxcXCIgaHJlZj1cXFwiI1xcXCI+RWRpdCBuYW1lPC9hPjxici8+XFxyXFxuICAgICAgICAgICAgPGEgaWQ9XFxcImVkaXRDb250YWN0XFxcIiBocmVmPVxcXCIjXFxcIj5FZGl0IGNvbnRhY3QgaW5mbzwvYT48YnIvPlxcclxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJlZGl0VHJ1c3RlZENvbnRhY3RcXFwiIGhyZWY9XFxcIiNcXFwiPkVkaXQgdHJ1c3RlZCBjb250YWN0PC9hPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8aHIvPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcImh0dHBzOi8vZWZmaWd5LmltL2Eve3tldGhBZGRyZXNzfX0ucG5nXFxcIj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVxcXCJkLWJsb2NrXFxcIj48YSBocmVmPVxcXCJ7e2Jsb2NrY2hhaW5FeHBsb3Jlcn19e3tldGhBZGRyZXNzfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57e3Nob3J0RXRoQWRkcmVzc319PC9hPjwvc3Ryb25nPlxcclxcbiAgICAgICAgICAgICAgICA8YnIvPlxcclxcbiAgICAgICAgICAgICAgICB7eyNpZiBpc01hZ2ljfX1cXHJcXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcIndhbGxldFxcXCI+T3BlbiBteSB3YWxsZXQ8L2E+XFxyXFxuICAgICAgICAgICAgICAgIHt7L2lmfX1cXHJcXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9pbmZvLmxpbWluYWwubWFya2V0LyMvY2hhaW4ve3tjaGFpbklkfX0ve3tldGhBZGRyZXNzfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5WaWV3XFxyXFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM8L2E+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxoci8+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ1c2VySW5mb0FVc2RCYWxhbmNlXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdj48aW1nIHNyYz1cXFwiaHR0cHM6Ly9hcHAubGltaW5hbC5tYXJrZXQvaW1nL2F1c2QucG5nXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmcgY2xhc3M9XFxcImQtYmxvY2tcXFwiPmFVU0QgPHNwYW4gaWQ9XFxcInVzZXJfaW5mb19hdXNkX2JhbGFuY2VcXFwiPjwvc3Bhbj48L3N0cm9uZz5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImFkZF9hVVNEX3RvX3dhbGxldFxcXCI+QWRkIGFVU0QgdG8gd2FsbGV0PC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJmdW5kX2FjY291bnRfb3B0aW9uc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxoNj5GdW5kIHlvdXIgYWNjb3VudDwvaDY+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImZ1bmRfYWNjb3VudFxcXCI+RnVuZCBteSBhY2NvdW50PC9hPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcIndpdGhkcmF3X2Zyb21fYWNjb3VudFxcXCI+V2l0aGRyYXcgZnJvbSBhY2NvdW50PC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8aHIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVxcXCJkLWJsb2NrXFxcIj5OZXR3b3JrPC9zdHJvbmc+XFxyXFxuICAgICAgICAgICAgPHNtYWxsPnt7bmV0d29ya05hbWV9fTxici8+XFxyXFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJzd2l0Y2hfbmV0d29ya1xcXCI+Q2hhbmdlIG5ldHdvcms8L2E+XFxyXFxuICAgICAgICAgICAgPC9zbWFsbD5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8L2Rpdj5cXHJcXG5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGlkPVxcXCJreWNFZGl0TmFtZVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcIndhcm5pbmdCYXJcXFwiPlxcclxcbiAgICAgICAgPHN0cm9uZz5XYXJuaW5nPC9zdHJvbmc+PGJyLz5cXHJcXG4gICAgICAgIFlvdSBjYW4gb25seSBjaGFuZ2UgdGhlIG5hbWUgb25jZS4gQmUgY2FyZWZ1bCBvZiB3aGF0IHlvdSBjaGFuZ2UuXFxyXFxuICAgICAgICA8YnIvPjxici8+XFxyXFxuICAgICAgICBBZnRlciB5b3UgY2hhbmdlIHRoaXMgaW5mb3JtYXRpb24gYSBuZXcgS1lDIHByb2Nlc3Mgd2lsbCBiZSBzdGFydGVkLCBhbmQgeW91IHdpbGwgTk9UIGJlIGFibGUgdG8gZG8gYW55XFxyXFxuICAgICAgICB0cmFkZXNcXHJcXG4gICAgICAgIHVudGlsIGl0IGhhcyBiZWVuIGFwcHJvdmVkLlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImdpdmVuX25hbWVcXFwiPkxlZ2FsIEZpcnN0IG5hbWU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJnaXZlbl9uYW1lXFxcIiBuYW1lPVxcXCJnaXZlbl9uYW1lXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJSb25cXFwiXFxyXFxuICAgICAgICAgICAgICAgdmFsdWU9XFxcInt7Z2l2ZW5fbmFtZX19XFxcIiBhdXRvY29tcGxldGU9XFxcImdpdmVuLW5hbWVcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcIm1pZGRsZV9uYW1lXFxcIj5MZWdhbCBNaWRkbGUgbmFtZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcIm1pZGRsZV9uYW1lXFxcIiBuYW1lPVxcXCJtaWRkbGVfbmFtZVxcXCJcXHJcXG4gICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJ7e21pZGRsZV9uYW1lfX1cXFwiIGF1dG9jb21wbGV0ZT1cXFwiYWRkaXRpb25hbC1uYW1lXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJmYW1pbHlfbmFtZVxcXCI+TGVnYWwgTGFzdCBuYW1lPC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCByZXF1aXJlZCBpZD1cXFwiZmFtaWx5X25hbWVcXFwiIG5hbWU9XFxcImZhbWlseV9uYW1lXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJTd2Fuc29uXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJ7e2ZhbWlseV9uYW1lfX1cXFwiIGF1dG9jb21wbGV0ZT1cXFwiZmFtaWx5LW5hbWVcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIGlkPVxcXCJreWNFZGl0TmFtZUNvbmZpcm1cXFwiPkNvbmZpcm08L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cXHJcXG5cXHJcXG48ZmllbGRzZXQgY2xhc3M9XFxcImhpZGRlblxcXCIgaWQ9XFxcImNvbmZpcm1OYW1lRmllbGRzZXRcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb25maXJtX25hbWVcXFwiPlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29uZmlybV9uYW1lXFxcIiBpZD1cXFwibGFiZWxfY29uZmlybV9uYW1lXFxcIj5QbGVhc2UgdHlwZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiY29uZmlybV9uYW1lXFxcIiBpZD1cXFwiY29uZmlybV9uYW1lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcImt5Y0VkaXROYW1lRXJyb3JcXFwiPjwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b25zIGdyaWRcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiBpZD1cXFwia3ljRWRpdE5hbWVCYWNrXFxcIj5CYWNrPC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgaWQ9XFxcImt5Y0VkaXROYW1lU2F2ZVxcXCI+Q29uZmlybTwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdIZWxwZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBpc051bGxPckVtcHR5KHN0cjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICFzdHIgfHwgc3RyLnRvU3RyaW5nKCkudHJpbSgpLmxlbmd0aCA9PSAwO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgS3ljRWRpdE5hbWVIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0VkaXROYW1lLmh0bWwnO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRWRpdE5hbWVGb3JtIHtcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IGt5Y0VkaXROYW1lRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljRWRpdE5hbWVFcnJvcicpO1xyXG4gICAgICAgIGlmIChreWNFZGl0TmFtZUVycm9yKSBreWNFZGl0TmFtZUVycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSgpO1xyXG4gICAgICAgIGxldCBhY2NvdW50ID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0QWNjb3VudCgpXHJcblxyXG4gICAgICAgIGxldCBnaXZlbl9uYW1lID0gYWNjb3VudC5pZGVudGl0eS5naXZlbl9uYW1lIGFzIHN0cmluZztcclxuICAgICAgICBsZXQgbWlkZGxlX25hbWUgPSBhY2NvdW50LmlkZW50aXR5Lm1pZGRsZV9uYW1lIGFzIHN0cmluZztcclxuICAgICAgICBsZXQgZmFtaWx5X25hbWUgPSBhY2NvdW50LmlkZW50aXR5LmZhbWlseV9uYW1lO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljRWRpdE5hbWVIdG1sKVxyXG4gICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGUoe2dpdmVuX25hbWU6IGdpdmVuX25hbWUsIG1pZGRsZV9uYW1lOiBtaWRkbGVfbmFtZSwgZmFtaWx5X25hbWU6IGZhbWlseV9uYW1lfSk7XHJcblxyXG4gICAgICAgIHRoaXMubW9kYWwuc2hvd01vZGFsKCdFZGl0IG5hbWUnLCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kRXZlbnRzKCkge1xyXG5cclxuICAgICAgICBsZXQga3ljRWRpdE5hbWVDb25maXJtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0VkaXROYW1lQ29uZmlybScpO1xyXG4gICAgICAgIGt5Y0VkaXROYW1lQ29uZmlybT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICBsZXQgZ2l2ZW5fbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaXZlbl9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IG1pZGRsZV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pZGRsZV9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IGZhbWlseV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZhbWlseV9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkoZ2l2ZW5fbmFtZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKCdHaXZlbiBuYW1lIGNhbm5vdCBiZSBlbXB0eScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkoZmFtaWx5X25hbWUudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcignRmFtaWx5IG5hbWUgY2Fubm90IGJlIGVtcHR5JylcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGZ1bGxfbmFtZSA9IHRoaXMuZ2V0RnVsbE5hbWUoKTtcclxuICAgICAgICAgICAgbGV0IGxhYmVsX2NvbmZpcm1fbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYWJlbF9jb25maXJtX25hbWUnKTtcclxuICAgICAgICAgICAgaWYgKCFsYWJlbF9jb25maXJtX25hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0IGVycm9yIGluIGZvcm1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGFiZWxfY29uZmlybV9uYW1lLmlubmVySFRNTCA9ICdQbGVhc2UgdHlwZSBpbiB0aGUgZnVsbCBuYW1lIFwiJyArIGZ1bGxfbmFtZSArICdcIiBpbiB0aGUgYm94IGJlbG93IHRvIGNvbmZpcm0uIFlvdSBXSUxMIE5PVCBiZSBhYmxlIHRvIGNoYW5nZSBpdCBhZ2Fpbi4nO1xyXG5cclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm1OYW1lRmllbGRzZXQnKT8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0VkaXROYW1lJyk/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IGt5Y0VkaXROYW1lQmFjayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0TmFtZUJhY2snKTtcclxuICAgICAgICBreWNFZGl0TmFtZUJhY2s/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZmlybU5hbWVGaWVsZHNldCcpPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljRWRpdE5hbWUnKT8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgY29uZmlybV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm1fbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFjb25maXJtX25hbWUpIHtcclxuICAgICAgICAgICAgLy9UT0RPOiByZXBvcnQgZXJyb3IgaW4gZm9ybVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQga3ljRWRpdE5hbWVTYXZlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0VkaXROYW1lU2F2ZScpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xyXG4gICAgICAgIGt5Y0VkaXROYW1lU2F2ZS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgY29uZmlybV9uYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICBjb25maXJtX25hbWUuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjb25maXJtX25hbWUudmFsdWUgPT0gdGhpcy5nZXRGdWxsTmFtZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25maXJtX25hbWUuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcclxuICAgICAgICAgICAgICAgIGt5Y0VkaXROYW1lU2F2ZS5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlybV9uYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICAgICAgICAgIGt5Y0VkaXROYW1lU2F2ZS5kaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBreWNFZGl0TmFtZVNhdmU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29uZmlybV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm1fbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChjb25maXJtX25hbWUgJiYgY29uZmlybV9uYW1lLnZhbHVlICE9IHRoaXMuZ2V0RnVsbE5hbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgYWxlcnQoY29uZmlybV9uYW1lLnZhbHVlICsgJyBpcyBub3Qgc2FtZSBhcyAnICsgdGhpcy5nZXRGdWxsTmFtZSgpICsgJy4gR28gb3ZlciB0aGUgbmFtZSBhbmQgbWFrZSBzdXJlIGl0IGlzIGlkZW50aWNhbCcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgZ2l2ZW5fbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaXZlbl9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IG1pZGRsZV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pZGRsZV9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IGZhbWlseV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZhbWlseV9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKGt5Y0VkaXROYW1lU2F2ZSk7XHJcbiAgICAgICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSgpO1xyXG4gICAgICAgICAgICBhd2FpdCB1c2VyU2VydmljZS51cGRhdGVOYW1lKGdpdmVuX25hbWUudmFsdWUsIG1pZGRsZV9uYW1lLnZhbHVlLCBmYW1pbHlfbmFtZS52YWx1ZSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChyZXNwb25zZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IocmVzcG9uc2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RhbC5oaWRlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKEpTT04ucGFyc2UocmVhc29uLm1lc3NhZ2UpLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNob3dFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQga3ljRWRpdE5hbWVFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0TmFtZUVycm9yJyk7XHJcbiAgICAgICAgaWYgKCFreWNFZGl0TmFtZUVycm9yKSByZXR1cm47XHJcblxyXG4gICAgICAgIGt5Y0VkaXROYW1lRXJyb3IuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICAgICAgICBreWNFZGl0TmFtZUVycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RnVsbE5hbWUoKSB7XHJcbiAgICAgICAgbGV0IGdpdmVuX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2l2ZW5fbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IG1pZGRsZV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pZGRsZV9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBsZXQgZmFtaWx5X25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmFtaWx5X25hbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICByZXR1cm4gZ2l2ZW5fbmFtZS52YWx1ZSArICcgJyArICghU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkobWlkZGxlX25hbWUudmFsdWUpID8gbWlkZGxlX25hbWUudmFsdWUgKyAnICcgOiAnJykgKyBmYW1pbHlfbmFtZS52YWx1ZTtcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBpZD1cXFwia3ljRWRpdENvbnRhY3RGaWVsZHNldFxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcIndhcm5pbmdCYXJcXFwiPlxcclxcbiAgICAgICAgPHN0cm9uZz5XYXJuaW5nPC9zdHJvbmc+PGJyLz5cXHJcXG4gICAgICAgIEFmdGVyIHlvdSBjaGFuZ2UgdGhpcyBpbmZvcm1hdGlvbiBhIG5ldyBLWUMgcHJvY2VzcyB3aWxsIGJlIHN0YXJ0ZWQsIGFuZCB5b3Ugd2lsbCBOT1QgYmUgYWJsZSB0byBkbyBhbnlcXHJcXG4gICAgICAgIHRyYWRlcyB1bnRpbCBpdCBoYXMgYmVlbiBhcHByb3ZlZC5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxmb3JtIGlkPVxcXCJreWNFZGl0Q29udGFjdEZvcm1cXFwiPlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbWFpbF9hZGRyZXNzXFxcIj5FbWFpbDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiByZXF1aXJlZCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwiZW1haWxfYWRkcmVzc1xcXCIgbmFtZT1cXFwiZW1haWxfYWRkcmVzc1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIm5hbWVAZXhhbXBsZS5jb21cXFwiIGF1dG9jb21wbGV0ZT1cXFwiZW1haWxcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInBob25lX251bWJlclxcXCI+UGhvbmU8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJwaG9uZV9udW1iZXJcXFwiIG5hbWU9XFxcInBob25lX251bWJlclxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIisxLTU1NS02NjYtNzc4OFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJ0ZWxcXFwiIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInN0cmVldF9hZGRyZXNzXFxcIj5QZXJtYW5lbnQgUmVzaWRlbnRpYWwgQWRkcmVzczwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZXhwbGFpblxcXCI+SXQgbXVzdCBiZSBhIHBoeXNpY2FsIGFkZHJlc3MsIG5vdCBhIFBPIGJveC48L2Rpdj5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcInN0cmVldF9hZGRyZXNzXFxcIiBuYW1lPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIjIwIE4gU2FuIE1hdGVvIERyXFxcIiB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZHJlc3MtbGluZTFcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInVuaXRcXFwiPlVuaXQgLyBBcHQgIzwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJ1bml0XFxcIiBuYW1lPVxcXCJ1bml0XFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjaXR5XFxcIj5DaXR5PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImNpdHlcXFwiIG5hbWU9XFxcImNpdHlcXFwiIHBsYWNlaG9sZGVyPVxcXCJQYXduZWVcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiIGF1dG9jb21wbGV0ZT1cXFwiYWRkcmVzcy1sZXZlbDJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInBvc3RhbF9jb2RlXFxcIj5Qb3N0YWwgY29kZTwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJwb3N0YWxfY29kZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJwb3N0YWwtY29kZVxcXCIgbmFtZT1cXFwicG9zdGFsX2NvZGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCI5NDQwMVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgdmFsdWU9XFxcIlxcXCI+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIHt7I2lmIHVzYX19XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJzdGF0ZV9kaXZcXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInN0YXRlXFxcIj5TdGF0ZSAoMiBsZXR0ZXJzKTwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHJlcXVpcmVkIG1heGxlbmd0aD1cXFwiMlxcXCIgaWQ9XFxcInN0YXRlXFxcIiBuYW1lPVxcXCJzdGF0ZVxcXCIgcGxhY2Vob2xkZXI9XFxcIk5ZXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZHJlc3MtbGV2ZWwxXFxcIj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAge3svaWZ9fVxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJreWNFZGl0Q29udGFjdEVycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBpZD1cXFwia3ljRWRpdENvbnRhY3RTYXZlXFxcIj5TYXZlPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9mb3JtPlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSBcIi4vU3RyaW5nSGVscGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtSGVscGVyIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFBhcmFtcyhzZWxlY3Rvcjogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSBhcyBIVE1MRm9ybUVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFmb3JtKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBkYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZShkYXRhKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2VyaWFsaXplKGRhdGE6IGFueSkge1xyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZmlsbElucHV0cyhwcm9wZXJ0aWVzOiBzdHJpbmdbXSwgaXRlbTogYW55KSB7XHJcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT0nICsgdmFsdWUgKyAnXScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT0gJ3JhZGlvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGVja2JveCcsIGlucHV0LCBpdGVtW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBpdGVtW3ZhbHVlXVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGl0ZW1bdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBzZWxlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzZWxlY3RbbmFtZT0nICsgdmFsdWUgKyAnXScpIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdC52YWx1ZSA9IGl0ZW1bdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHZhbGlkYXRlKHNlbGVjdG9yOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciArICcgaW5wdXRbcmVxdWlyZWRdLCAnICsgc2VsZWN0b3IgKyAnIHNlbGVjdFtyZXF1aXJlZF0nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaV0gYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKVxyXG4gICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgS3ljRWRpdENvbnRhY3RGb3JtSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNFZGl0Q29udGFjdEZvcm0uaHRtbCdcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBGb3JtSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0Zvcm1IZWxwZXJcIjtcclxuaW1wb3J0IEt5Y1ZhbGlkYXRvckVycm9yIGZyb20gXCIuLi8uLi8uLi9lcnJvcnMvY2xvdWQvS3ljVmFsaWRhdG9yRXJyb3JcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IHtBY2NvdW50SW5mb30gZnJvbSBcIi4uLy4uLy4uL2R0by9hbHBhY2EvQWNjb3VudEluZm9cIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRWRpdENvbnRhY3RGb3JtIHtcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGFjY291bnQgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRBY2NvdW50KCk7XHJcbiAgICAgICAgbGV0IHVzYSA9IGFjY291bnQuaWRlbnRpdHkuY291bnRyeV9vZl90YXhfcmVzaWRlbmNlID09ICdVU0EnXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y0VkaXRDb250YWN0Rm9ybUh0bWwpO1xyXG4gICAgICAgIHRoaXMubW9kYWwuc2hvd01vZGFsKCdFZGl0IGNvbnRhY3QgaW5mb3JtYXRpb24nLCB0ZW1wbGF0ZSh7dXNhOiB1c2F9KSlcclxuXHJcbiAgICAgICAgbGV0IGNvbnRhY3RQcm9wZXJ0aWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWNjb3VudC5jb250YWN0KTtcclxuICAgICAgICBGb3JtSGVscGVyLmZpbGxJbnB1dHMoY29udGFjdFByb3BlcnRpZXMsIGFjY291bnQuY29udGFjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IGt5Y0VkaXRDb250YWN0U2F2ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0Q29udGFjdFNhdmUnKTtcclxuICAgICAgICBreWNFZGl0Q29udGFjdFNhdmU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZSgpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcoa3ljRWRpdENvbnRhY3RTYXZlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gRm9ybUhlbHBlci5nZXRQYXJhbXMoJyNreWNFZGl0Q29udGFjdEZvcm0nKTtcclxuICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVzZXJTZXJ2aWNlLnVwZGF0ZUNvbnRhY3QoZGF0YSkudGhlbigocmVzcG9uc2U6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcihyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgYWNjb3VudEluZm8gPSByZXNwb25zZSBhcyBBY2NvdW50SW5mbztcclxuICAgICAgICAgICAgICAgIGxldCBlbWFpbF9hZGRyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VtYWlsX2FkZHJlc3MnKSBhcyBIVE1MSW5wdXRFbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudEluZm8uY29udGFjdC5lbWFpbF9hZGRyZXNzICE9IGVtYWlsX2FkZHJlc3M/LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoJ0VtYWlsIHdhcyBub3QgY2hhbmdlZC4gVGhlIGVtYWlsICcgKyBlbWFpbF9hZGRyZXNzPy52YWx1ZSArICcgaXMgYWxyZWFkeSByZWdpc3RlcmVkIHVuZGVyIGRpZmZlcmVudCBhY2NvdW50LicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMubW9kYWwuaGlkZU1vZGFsKCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVhc29uLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcihKU09OLnBhcnNlKHJlYXNvbi5tZXNzYWdlKS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBMb2FkaW5nSGVscGVyLnJlbW92ZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNob3dFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQga3ljRWRpdE5hbWVFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0Q29udGFjdEVycm9yJyk7XHJcbiAgICAgICAgaWYgKCFreWNFZGl0TmFtZUVycm9yKSByZXR1cm47XHJcblxyXG4gICAgICAgIGt5Y0VkaXROYW1lRXJyb3IuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICAgICAgICBreWNFZGl0TmFtZUVycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgbGV0IGlucHV0cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNreWNFZGl0Q29udGFjdEZpZWxkc2V0IGlucHV0W3JlcXVpcmVkXScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGlucHV0c1tpXSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkoaW5wdXQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJylcclxuICAgICAgICAgICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIVN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KGlucHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICdmYWxzZScpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNUcnVzdGVkQ29udGFjdFxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcIndhcm5pbmdCYXJcXFwiPlxcclxcbiAgICAgICAgPHN0cm9uZz5XYXJuaW5nPC9zdHJvbmc+PGJyLz5cXHJcXG4gICAgICAgIEFmdGVyIHlvdSBjaGFuZ2UgdGhpcyBpbmZvcm1hdGlvbiBhIG5ldyBLWUMgcHJvY2VzcyB3aWxsIGJlIHN0YXJ0ZWQsIGFuZCB5b3Ugd2lsbCBOT1QgYmUgYWJsZSB0byBkbyBhbnlcXHJcXG4gICAgICAgIHRyYWRlcyB1bnRpbCBpdCBoYXMgYmVlbiBhcHByb3ZlZC5cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxmb3JtIGlkPVxcXCJreWNUcnVzdGVkQ29udGFjdEZvcm1cXFwiIG1ldGhvZD1cXFwicG9zdFxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJleHBsYWluXFxcIj5cXHJcXG4gICAgICAgICAgICBBIHRydXN0ZWQgY29udGFjdCBpcyBhIHBlcnNvbiB5b3UgYXV0aG9yaXplIHlvdXIgZmluYW5jaWFsIGZpcm0gdG8gY29udGFjdCBpbiBsaW1pdGVkIGNpcmN1bXN0YW5jZXMsXFxyXFxuICAgICAgICAgICAgc3VjaCBhcyBpZiB0aGVyZSBpcyBhIGNvbmNlcm4gYWJvdXQgYWN0aXZpdHkgaW4geW91ciBhY2NvdW50IGFuZCB0aGV5IGhhdmUgYmVlbiB1bmFibGUgdG8gZ2V0IGluIHRvdWNoIHdpdGhcXHJcXG4gICAgICAgICAgICB5b3UuXFxyXFxuICAgICAgICAgICAgPGJyLz48YnIvPlxcclxcbiAgICAgICAgICAgIEEgdHJ1c3RlZCBjb250YWN0IG1heSBiZSBhIGZhbWlseSBtZW1iZXIsIGF0dG9ybmV5LCBhY2NvdW50YW50IG9yIGFub3RoZXIgdGhpcmQtcGFydHkgd2hvIHlvdSBiZWxpZXZlIHdvdWxkXFxyXFxuICAgICAgICAgICAgcmVzcGVjdCB5b3VyIHByaXZhY3kgYW5kIGtub3cgaG93IHRvIGhhbmRsZSB0aGUgcmVzcG9uc2liaWxpdHkuXFxyXFxuICAgICAgICAgICAgVGhlIHRydXN0ZWQgcGVyc29uIHNob3VsZCBiZSAxOCB5ZWFycyBvbGQgb3Igb2xkZXIuXFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiZ2l2ZW5fbmFtZVxcXCI+TGVnYWwgZ2l2ZW4gbmFtZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZCBpZD1cXFwiZ2l2ZW5fbmFtZVxcXCIgbmFtZT1cXFwiZ2l2ZW5fbmFtZVxcXCIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImZhbWlseV9uYW1lXFxcIj5MZWdhbCBmYW1pbHkgbmFtZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZCBpZD1cXFwiZmFtaWx5X25hbWVcXFwiIG5hbWU9XFxcImZhbWlseV9uYW1lXFxcIi8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgSWYgeW91IGZpbGwgaW4gbmFtZSwgeW91IGFyZSByZXF1aXJlZCB0byBmaWxsIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nLCBlbWFpbCwgcGhvbmUgb3IgYWRkcmVzc1xcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcImNvbnRhY3RfbWlzc2luZ19pbmZvXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiZW1haWxfYWRkcmVzc1xcXCI+RW1haWwgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImVtYWlsX2FkZHJlc3NcXFwiIHR5cGU9XFxcImVtYWlsXFxcIiBuYW1lPVxcXCJlbWFpbF9hZGRyZXNzXFxcIi8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwicGhvbmVfbnVtYmVyXFxcIj5QaG9uZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwicGhvbmVfbnVtYmVyXFxcIiB0eXBlPVxcXCJ0ZWxcXFwiIG5hbWU9XFxcInBob25lX251bWJlclxcXCIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInN0cmVldF9hZGRyZXNzXFxcIj5BZGRyZXNzIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCIgbmFtZT1cXFwic3RyZWV0X2FkZHJlc3NcXFwiLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjaXR5XFxcIj5DaXR5IG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJjaXR5XFxcIiBuYW1lPVxcXCJjaXR5XFxcIi8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwic3RhdGVcXFwiPlN0YXRlIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJzdGF0ZVxcXCIgbmFtZT1cXFwic3RhdGVcXFwiLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJwb3N0YWxfY29kZVxcXCI+UG9zdGFsIGNvZGUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInBvc3RhbF9jb2RlXFxcIiBuYW1lPVxcXCJwb3N0YWxfY29kZVxcXCIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImNvdW50cnlcXFwiPkNvdW50cnkgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8c2VsZWN0IHJlcXVpcmVkIGlkPVxcXCJjb3VudHJ5XFxcIiByZXF1aXJlZCBuYW1lPVxcXCJjb3VudHJ5XFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj48L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAge3sjZWFjaCBjb3VudHJpZXN9fVxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2NvZGV9fVxcXCI+e3tuYW1lfX08L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAge3svZWFjaH19XFxyXFxuICAgICAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwia3ljRWRpdE5hbWVFcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b25zXFxcIj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgaWQ9XFxcInRydXN0ZWRDb250YWN0U3VibWl0XFxcIj5TdWJtaXQ8L2J1dHRvbj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Zvcm0+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ291bnRyeUhlbHBlciB7XHJcbiAgICBzdGF0aWMgQ291bnRyaWVzID0gW1xyXG4gICAgICAgIHtcIm5hbWVcIjogXCJVbml0ZWQgU3RhdGVzIG9mIEFtZXJpY2FcIiwgXCJjb2RlXCI6IFwiVVNBXCJ9LFxyXG4gICAgICAgIHtcIm5hbWVcIjogXCJVbml0ZWQgS2luZ2RvbVwiLCBcImNvZGVcIjogXCJHQlJcIn0sXHJcbiAgICAgICAge1wibmFtZVwiOiBcIkFmZ2hhbmlzdGFuXCIsIFwiY29kZVwiOiBcIkFGR1wifSwge1wibmFtZVwiOiBcIkFsYmFuaWFcIiwgXCJjb2RlXCI6IFwiQUxCXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFsZ2VyaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiRFpBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQW1lcmljYW4gU2Ftb2FcIiwgXCJjb2RlXCI6IFwiQVNNXCJ9LCB7XCJuYW1lXCI6IFwiQW5kb3JyYVwiLCBcImNvZGVcIjogXCJBTkRcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQW5nb2xhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkFHT1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkFuZ3VpbGxhXCIsIFwiY29kZVwiOiBcIkFJQVwifSwge1wibmFtZVwiOiBcIkFudGFyY3RpY2FcIiwgXCJjb2RlXCI6IFwiQVRBXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFudGlndWEgYW5kIEJhcmJ1ZGFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQVRHXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQXJnZW50aW5hXCIsIFwiY29kZVwiOiBcIkFSR1wifSwge1wibmFtZVwiOiBcIkFybWVuaWFcIiwgXCJjb2RlXCI6IFwiQVJNXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFydWJhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkFCV1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkF1c3RyYWxpYVwiLCBcImNvZGVcIjogXCJBVVNcIn0sIHtcIm5hbWVcIjogXCJBdXN0cmlhXCIsIFwiY29kZVwiOiBcIkFVVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBemVyYmFpamFuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkFaRVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIsOFbGFuZCBJc2xhbmRzXCIsIFwiY29kZVwiOiBcIkFMQVwifSwge1wibmFtZVwiOiBcIkJhaGFtYXNcIiwgXCJjb2RlXCI6IFwiQkhTXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkJhaHJhaW5cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQkhSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQmFuZ2xhZGVzaFwiLCBcImNvZGVcIjogXCJCR0RcIn0sIHtcIm5hbWVcIjogXCJCYXJiYWRvc1wiLCBcImNvZGVcIjogXCJCUkJcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmVsYXJ1c1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJCTFJcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJCZWxnaXVtXCIsIFwiY29kZVwiOiBcIkJFTFwifSwge1wibmFtZVwiOiBcIkJlbGl6ZVwiLCBcImNvZGVcIjogXCJCTFpcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmVuaW5cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQkVOXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQmVybXVkYVwiLCBcImNvZGVcIjogXCJCTVVcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQmh1dGFuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkJUTlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkJvbGl2aWEgKFBsdXJpbmF0aW9uYWwgU3RhdGUgb2YpXCIsIFwiY29kZVwiOiBcIkJPTFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCb25haXJlLCBTaW50IEV1c3RhdGl1cyBhbmQgU2FiYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJCRVNcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJCb3NuaWEgYW5kIEhlcnplZ292aW5hXCIsIFwiY29kZVwiOiBcIkJJSFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCb3Rzd2FuYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJCV0FcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJCb3V2ZXQgSXNsYW5kXCIsIFwiY29kZVwiOiBcIkJWVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCcmF6aWxcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQlJBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQnJpdGlzaCBJbmRpYW4gT2NlYW4gVGVycml0b3J5XCIsIFwiY29kZVwiOiBcIklPVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCcnVuZWkgRGFydXNzYWxhbVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJCUk5cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJCdWxnYXJpYVwiLCBcImNvZGVcIjogXCJCR1JcIn0sIHtcIm5hbWVcIjogXCJCdXJraW5hIEZhc29cIiwgXCJjb2RlXCI6IFwiQkZBXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkJ1cnVuZGlcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQkRJXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ2FibyBWZXJkZVwiLCBcImNvZGVcIjogXCJDUFZcIn0sIHtcIm5hbWVcIjogXCJDYW1ib2RpYVwiLCBcImNvZGVcIjogXCJLSE1cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2FtZXJvb25cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQ01SXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ2FuYWRhXCIsIFwiY29kZVwiOiBcIkNBTlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJDYXltYW4gSXNsYW5kc1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJDWU1cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJDZW50cmFsIEFmcmljYW4gUmVwdWJsaWNcIiwgXCJjb2RlXCI6IFwiQ0FGXCJ9LCB7XCJuYW1lXCI6IFwiQ2hhZFwiLCBcImNvZGVcIjogXCJUQ0RcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2hpbGVcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQ0hMXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ2hpbmFcIiwgXCJjb2RlXCI6IFwiQ0hOXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkNocmlzdG1hcyBJc2xhbmRcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQ1hSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ29jb3MgKEtlZWxpbmcpIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiQ0NLXCJ9LCB7XCJuYW1lXCI6IFwiQ29sb21iaWFcIiwgXCJjb2RlXCI6IFwiQ09MXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkNvbW9yb3NcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQ09NXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ29uZ28gKHRoZSBEZW1vY3JhdGljIFJlcHVibGljIG9mIHRoZSlcIiwgXCJjb2RlXCI6IFwiQ09EXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkNvbmdvXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkNPR1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkNvb2sgSXNsYW5kc1wiLCBcImNvZGVcIjogXCJDT0tcIn0sIHtcIm5hbWVcIjogXCJDb3N0YSBSaWNhXCIsIFwiY29kZVwiOiBcIkNSSVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJDcm9hdGlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkhSVlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkN1YmFcIiwgXCJjb2RlXCI6IFwiQ1VCXCJ9LCB7XCJuYW1lXCI6IFwiQ3VyYcOnYW9cIiwgXCJjb2RlXCI6IFwiQ1VXXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkN5cHJ1c1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJDWVBcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJDemVjaGlhXCIsIFwiY29kZVwiOiBcIkNaRVwifSwge1wibmFtZVwiOiBcIkPDtHRlIGQnSXZvaXJlXCIsIFwiY29kZVwiOiBcIkNJVlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJEZW5tYXJrXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkROS1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkRqaWJvdXRpXCIsIFwiY29kZVwiOiBcIkRKSVwifSwge1wibmFtZVwiOiBcIkRvbWluaWNhXCIsIFwiY29kZVwiOiBcIkRNQVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJEb21pbmljYW4gUmVwdWJsaWNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiRE9NXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiRWN1YWRvclwiLCBcImNvZGVcIjogXCJFQ1VcIn0sIHtcIm5hbWVcIjogXCJFZ3lwdFwiLCBcImNvZGVcIjogXCJFR1lcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRWwgU2FsdmFkb3JcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU0xWXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiRXF1YXRvcmlhbCBHdWluZWFcIiwgXCJjb2RlXCI6IFwiR05RXCJ9LCB7XCJuYW1lXCI6IFwiRXJpdHJlYVwiLCBcImNvZGVcIjogXCJFUklcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRXN0b25pYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJFU1RcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJFc3dhdGluaVwiLCBcImNvZGVcIjogXCJTV1pcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRXRoaW9waWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiRVRIXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiRmFsa2xhbmQgSXNsYW5kcyBbTWFsdmluYXNdXCIsIFwiY29kZVwiOiBcIkZMS1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJGYXJvZSBJc2xhbmRzXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkZST1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkZpamlcIiwgXCJjb2RlXCI6IFwiRkpJXCJ9LCB7XCJuYW1lXCI6IFwiRmlubGFuZFwiLCBcImNvZGVcIjogXCJGSU5cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRnJhbmNlXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkZSQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkZyZW5jaCBHdWlhbmFcIiwgXCJjb2RlXCI6IFwiR1VGXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkZyZW5jaCBQb2x5bmVzaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiUFlGXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiRnJlbmNoIFNvdXRoZXJuIFRlcnJpdG9yaWVzXCIsIFwiY29kZVwiOiBcIkFURlwifSwge1wibmFtZVwiOiBcIkdhYm9uXCIsIFwiY29kZVwiOiBcIkdBQlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJHYW1iaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiR01CXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiR2VvcmdpYVwiLCBcImNvZGVcIjogXCJHRU9cIn0sIHtcIm5hbWVcIjogXCJHZXJtYW55XCIsIFwiY29kZVwiOiBcIkRFVVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJHaGFuYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJHSEFcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJHaWJyYWx0YXJcIiwgXCJjb2RlXCI6IFwiR0lCXCJ9LCB7XCJuYW1lXCI6IFwiR3JlZWNlXCIsIFwiY29kZVwiOiBcIkdSQ1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJHcmVlbmxhbmRcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiR1JMXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiR3JlbmFkYVwiLCBcImNvZGVcIjogXCJHUkRcIn0sIHtcIm5hbWVcIjogXCJHdWFkZWxvdXBlXCIsIFwiY29kZVwiOiBcIkdMUFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJHdWFtXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkdVTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkd1YXRlbWFsYVwiLCBcImNvZGVcIjogXCJHVE1cIn0sIHtcIm5hbWVcIjogXCJHdWVybnNleVwiLCBcImNvZGVcIjogXCJHR1lcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiR3VpbmVhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkdJTlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkd1aW5lYS1CaXNzYXVcIiwgXCJjb2RlXCI6IFwiR05CXCJ9LCB7XCJuYW1lXCI6IFwiR3V5YW5hXCIsIFwiY29kZVwiOiBcIkdVWVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJIYWl0aVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJIVElcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJIZWFyZCBJc2xhbmQgYW5kIE1jRG9uYWxkIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiSE1EXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkhvbHkgU2VlXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlZBVFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkhvbmR1cmFzXCIsIFwiY29kZVwiOiBcIkhORFwifSwge1wibmFtZVwiOiBcIkhvbmcgS29uZ1wiLCBcImNvZGVcIjogXCJIS0dcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiSHVuZ2FyeVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJIVU5cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJJY2VsYW5kXCIsIFwiY29kZVwiOiBcIklTTFwifSwge1wibmFtZVwiOiBcIkluZGlhXCIsIFwiY29kZVwiOiBcIklORFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJJbmRvbmVzaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiSUROXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiSXJhbiAoSXNsYW1pYyBSZXB1YmxpYyBvZilcIiwgXCJjb2RlXCI6IFwiSVJOXCJ9LCB7XCJuYW1lXCI6IFwiSXJhcVwiLCBcImNvZGVcIjogXCJJUlFcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiSXJlbGFuZFwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJJUkxcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJJc2xlIG9mIE1hblwiLCBcImNvZGVcIjogXCJJTU5cIn0sIHtcIm5hbWVcIjogXCJJc3JhZWxcIiwgXCJjb2RlXCI6IFwiSVNSXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkl0YWx5XCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIklUQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkphbWFpY2FcIiwgXCJjb2RlXCI6IFwiSkFNXCJ9LCB7XCJuYW1lXCI6IFwiSmFwYW5cIiwgXCJjb2RlXCI6IFwiSlBOXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkplcnNleVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJKRVlcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJKb3JkYW5cIiwgXCJjb2RlXCI6IFwiSk9SXCJ9LCB7XCJuYW1lXCI6IFwiS2F6YWtoc3RhblwiLCBcImNvZGVcIjogXCJLQVpcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiS2VueWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiS0VOXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiS2lyaWJhdGlcIiwgXCJjb2RlXCI6IFwiS0lSXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIktvcmVhICh0aGUgRGVtb2NyYXRpYyBQZW9wbGUncyBSZXB1YmxpYyBvZilcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiUFJLXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiS29yZWEgKHRoZSBSZXB1YmxpYyBvZilcIiwgXCJjb2RlXCI6IFwiS09SXCJ9LCB7XCJuYW1lXCI6IFwiS3V3YWl0XCIsIFwiY29kZVwiOiBcIktXVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJLeXJneXpzdGFuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIktHWlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkxhbyBQZW9wbGUncyBEZW1vY3JhdGljIFJlcHVibGljXCIsIFwiY29kZVwiOiBcIkxBT1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJMYXR2aWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTFZBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTGViYW5vblwiLCBcImNvZGVcIjogXCJMQk5cIn0sIHtcIm5hbWVcIjogXCJMZXNvdGhvXCIsIFwiY29kZVwiOiBcIkxTT1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJMaWJlcmlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkxCUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkxpYnlhXCIsIFwiY29kZVwiOiBcIkxCWVwifSwge1wibmFtZVwiOiBcIkxpZWNodGVuc3RlaW5cIiwgXCJjb2RlXCI6IFwiTElFXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkxpdGh1YW5pYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJMVFVcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJMdXhlbWJvdXJnXCIsIFwiY29kZVwiOiBcIkxVWFwifSwge1wibmFtZVwiOiBcIk1hY2FvXCIsIFwiY29kZVwiOiBcIk1BQ1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJNYWRhZ2FzY2FyXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk1ER1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk1hbGF3aVwiLCBcImNvZGVcIjogXCJNV0lcIn0sIHtcIm5hbWVcIjogXCJNYWxheXNpYVwiLCBcImNvZGVcIjogXCJNWVNcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWFsZGl2ZXNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTURWXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTWFsaVwiLCBcImNvZGVcIjogXCJNTElcIn0sIHtcIm5hbWVcIjogXCJNYWx0YVwiLCBcImNvZGVcIjogXCJNTFRcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWFyc2hhbGwgSXNsYW5kc1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJNSExcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJNYXJ0aW5pcXVlXCIsIFwiY29kZVwiOiBcIk1UUVwifSwge1wibmFtZVwiOiBcIk1hdXJpdGFuaWFcIiwgXCJjb2RlXCI6IFwiTVJUXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk1hdXJpdGl1c1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJNVVNcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJNYXlvdHRlXCIsIFwiY29kZVwiOiBcIk1ZVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJNZXhpY29cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTUVYXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTWljcm9uZXNpYSAoRmVkZXJhdGVkIFN0YXRlcyBvZilcIiwgXCJjb2RlXCI6IFwiRlNNXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk1vbGRvdmEgKHRoZSBSZXB1YmxpYyBvZilcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTURBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTW9uYWNvXCIsIFwiY29kZVwiOiBcIk1DT1wifSwge1wibmFtZVwiOiBcIk1vbmdvbGlhXCIsIFwiY29kZVwiOiBcIk1OR1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJNb250ZW5lZ3JvXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk1ORVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk1vbnRzZXJyYXRcIiwgXCJjb2RlXCI6IFwiTVNSXCJ9LCB7XCJuYW1lXCI6IFwiTW9yb2Njb1wiLCBcImNvZGVcIjogXCJNQVJcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTW96YW1iaXF1ZVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJNT1pcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJNeWFubWFyXCIsIFwiY29kZVwiOiBcIk1NUlwifSwge1wibmFtZVwiOiBcIk5hbWliaWFcIiwgXCJjb2RlXCI6IFwiTkFNXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk5hdXJ1XCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk5SVVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk5lcGFsXCIsIFwiY29kZVwiOiBcIk5QTFwifSwge1wibmFtZVwiOiBcIk5ldGhlcmxhbmRzXCIsIFwiY29kZVwiOiBcIk5MRFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJOZXcgQ2FsZWRvbmlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk5DTFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk5ldyBaZWFsYW5kXCIsIFwiY29kZVwiOiBcIk5aTFwifSwge1wibmFtZVwiOiBcIk5pY2FyYWd1YVwiLCBcImNvZGVcIjogXCJOSUNcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTmlnZXJcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTkVSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTmlnZXJpYVwiLCBcImNvZGVcIjogXCJOR0FcIn0sIHtcIm5hbWVcIjogXCJOaXVlXCIsIFwiY29kZVwiOiBcIk5JVVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJOb3Jmb2xrIElzbGFuZFwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJORktcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJOb3J0aGVybiBNYXJpYW5hIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiTU5QXCJ9LCB7XCJuYW1lXCI6IFwiTm9yd2F5XCIsIFwiY29kZVwiOiBcIk5PUlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJPbWFuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk9NTlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlBha2lzdGFuXCIsIFwiY29kZVwiOiBcIlBBS1wifSwge1wibmFtZVwiOiBcIlBhbGF1XCIsIFwiY29kZVwiOiBcIlBMV1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJQYWxlc3RpbmUsIFN0YXRlIG9mXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlBTRVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlBhbmFtYVwiLCBcImNvZGVcIjogXCJQQU5cIn0sIHtcIm5hbWVcIjogXCJQYXB1YSBOZXcgR3VpbmVhXCIsIFwiY29kZVwiOiBcIlBOR1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJQYXJhZ3VheVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJQUllcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJQZXJ1XCIsIFwiY29kZVwiOiBcIlBFUlwifSwge1wibmFtZVwiOiBcIlBoaWxpcHBpbmVzXCIsIFwiY29kZVwiOiBcIlBITFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJQaXRjYWlyblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJQQ05cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJQb2xhbmRcIiwgXCJjb2RlXCI6IFwiUE9MXCJ9LCB7XCJuYW1lXCI6IFwiUG9ydHVnYWxcIiwgXCJjb2RlXCI6IFwiUFJUXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlB1ZXJ0byBSaWNvXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlBSSVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlFhdGFyXCIsIFwiY29kZVwiOiBcIlFBVFwifSwge1wibmFtZVwiOiBcIlJlcHVibGljIG9mIE5vcnRoIE1hY2Vkb25pYVwiLCBcImNvZGVcIjogXCJNS0RcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiUm9tYW5pYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJST1VcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJSdXNzaWFuIEZlZGVyYXRpb25cIiwgXCJjb2RlXCI6IFwiUlVTXCJ9LCB7XCJuYW1lXCI6IFwiUndhbmRhXCIsIFwiY29kZVwiOiBcIlJXQVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJSw6l1bmlvblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJSRVVcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTYWludCBCYXJ0aMOpbGVteVwiLCBcImNvZGVcIjogXCJCTE1cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2FpbnQgSGVsZW5hLCBBc2NlbnNpb24gYW5kIFRyaXN0YW4gZGEgQ3VuaGFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU0hOXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2FpbnQgS2l0dHMgYW5kIE5ldmlzXCIsIFwiY29kZVwiOiBcIktOQVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTYWludCBMdWNpYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJMQ0FcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTYWludCBNYXJ0aW4gKEZyZW5jaCBwYXJ0KVwiLCBcImNvZGVcIjogXCJNQUZcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2FpbnQgUGllcnJlIGFuZCBNaXF1ZWxvblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJTUE1cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTYWludCBWaW5jZW50IGFuZCB0aGUgR3JlbmFkaW5lc1wiLCBcImNvZGVcIjogXCJWQ1RcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2Ftb2FcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiV1NNXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2FuIE1hcmlub1wiLCBcImNvZGVcIjogXCJTTVJcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2FvIFRvbWUgYW5kIFByaW5jaXBlXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNUUFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlNhdWRpIEFyYWJpYVwiLCBcImNvZGVcIjogXCJTQVVcIn0sIHtcIm5hbWVcIjogXCJTZW5lZ2FsXCIsIFwiY29kZVwiOiBcIlNFTlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTZXJiaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU1JCXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2V5Y2hlbGxlc1wiLCBcImNvZGVcIjogXCJTWUNcIn0sIHtcIm5hbWVcIjogXCJTaWVycmEgTGVvbmVcIiwgXCJjb2RlXCI6IFwiU0xFXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNpbmdhcG9yZVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJTR1BcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTaW50IE1hYXJ0ZW4gKER1dGNoIHBhcnQpXCIsIFwiY29kZVwiOiBcIlNYTVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTbG92YWtpYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJTVktcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTbG92ZW5pYVwiLCBcImNvZGVcIjogXCJTVk5cIn0sIHtcIm5hbWVcIjogXCJTb2xvbW9uIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiU0xCXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNvbWFsaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU09NXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU291dGggQWZyaWNhXCIsIFwiY29kZVwiOiBcIlpBRlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTb3V0aCBHZW9yZ2lhIGFuZCB0aGUgU291dGggU2FuZHdpY2ggSXNsYW5kc1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJTR1NcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTb3V0aCBTdWRhblwiLCBcImNvZGVcIjogXCJTU0RcIn0sIHtcIm5hbWVcIjogXCJTcGFpblwiLCBcImNvZGVcIjogXCJFU1BcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3JpIExhbmthXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkxLQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlN1ZGFuXCIsIFwiY29kZVwiOiBcIlNETlwifSwge1wibmFtZVwiOiBcIlN1cmluYW1lXCIsIFwiY29kZVwiOiBcIlNVUlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTdmFsYmFyZCBhbmQgSmFuIE1heWVuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNKTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlN3ZWRlblwiLCBcImNvZGVcIjogXCJTV0VcIn0sIHtcIm5hbWVcIjogXCJTd2l0emVybGFuZFwiLCBcImNvZGVcIjogXCJDSEVcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3lyaWFuIEFyYWIgUmVwdWJsaWNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU1lSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVGFpd2FuIChQcm92aW5jZSBvZiBDaGluYSlcIiwgXCJjb2RlXCI6IFwiVFdOXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlRhamlraXN0YW5cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVEpLXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVGFuemFuaWEsIFVuaXRlZCBSZXB1YmxpYyBvZlwiLCBcImNvZGVcIjogXCJUWkFcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVGhhaWxhbmRcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVEhBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVGltb3ItTGVzdGVcIiwgXCJjb2RlXCI6IFwiVExTXCJ9LCB7XCJuYW1lXCI6IFwiVG9nb1wiLCBcImNvZGVcIjogXCJUR09cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVG9rZWxhdVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJUS0xcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJUb25nYVwiLCBcImNvZGVcIjogXCJUT05cIn0sIHtcIm5hbWVcIjogXCJUcmluaWRhZCBhbmQgVG9iYWdvXCIsIFwiY29kZVwiOiBcIlRUT1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJUdW5pc2lhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlRVTlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlR1cmtleVwiLCBcImNvZGVcIjogXCJUVVJcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVHVya21lbmlzdGFuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlRLTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlR1cmtzIGFuZCBDYWljb3MgSXNsYW5kc1wiLCBcImNvZGVcIjogXCJUQ0FcIn0sIHtcIm5hbWVcIjogXCJUdXZhbHVcIiwgXCJjb2RlXCI6IFwiVFVWXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlVnYW5kYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJVR0FcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJVa3JhaW5lXCIsIFwiY29kZVwiOiBcIlVLUlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJVbml0ZWQgQXJhYiBFbWlyYXRlc1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJBUkVcIlxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVW5pdGVkIEtpbmdkb20gb2YgR3JlYXQgQnJpdGFpbiBhbmQgTm9ydGhlcm4gSXJlbGFuZFwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJHQlJcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJVbml0ZWQgU3RhdGVzIE1pbm9yIE91dGx5aW5nIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiVU1JXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlVuaXRlZCBTdGF0ZXMgb2YgQW1lcmljYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJVU0FcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJVcnVndWF5XCIsIFwiY29kZVwiOiBcIlVSWVwifSwge1wibmFtZVwiOiBcIlV6YmVraXN0YW5cIiwgXCJjb2RlXCI6IFwiVVpCXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlZhbnVhdHVcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVlVUXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVmVuZXp1ZWxhIChCb2xpdmFyaWFuIFJlcHVibGljIG9mKVwiLCBcImNvZGVcIjogXCJWRU5cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVmlldCBOYW1cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVk5NXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVmlyZ2luIElzbGFuZHMgKEJyaXRpc2gpXCIsIFwiY29kZVwiOiBcIlZHQlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJWaXJnaW4gSXNsYW5kcyAoVS5TLilcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVklSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiV2FsbGlzIGFuZCBGdXR1bmFcIiwgXCJjb2RlXCI6IFwiV0xGXCJ9LCB7XCJuYW1lXCI6IFwiV2VzdGVybiBTYWhhcmFcIiwgXCJjb2RlXCI6IFwiRVNIXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlllbWVuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIllFTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlphbWJpYVwiLCBcImNvZGVcIjogXCJaTUJcIn0sIHtcIm5hbWVcIjogXCJaaW1iYWJ3ZVwiLCBcImNvZGVcIjogXCJaV0VcIn1cclxuICAgIF07XHJcbn0iLCJpbXBvcnQgTW9kYWwgZnJvbSBcIi4uL01vZGFsXCI7XHJcbmltcG9ydCBLeWNFZGl0VHJ1c3RlZENvbnRhY3RIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0VkaXRUcnVzdGVkQ29udGFjdC5odG1sJztcclxuaW1wb3J0IENvdW50cnlIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvQ291bnRyeUhlbHBlclwiO1xyXG5pbXBvcnQgRm9ybUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Gb3JtSGVscGVyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLeWNFZGl0VHJ1c3RlZENvbnRhY3Qge1xyXG5cclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGFjY291bnQgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRBY2NvdW50KCk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNFZGl0VHJ1c3RlZENvbnRhY3RIdG1sKTtcclxuICAgICAgICB0aGlzLm1vZGFsLnNob3dNb2RhbCgnRWRpdCB0cnVzdGVkIGNvbnRhY3QnLCB0ZW1wbGF0ZSh7Y291bnRyaWVzOiBDb3VudHJ5SGVscGVyLkNvdW50cmllc30pKVxyXG5cclxuICAgICAgICBpZiAoYWNjb3VudC50cnVzdGVkX2NvbnRhY3QpIHtcclxuICAgICAgICAgICAgbGV0IGNvbnRhY3RQcm9wZXJ0aWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWNjb3VudC50cnVzdGVkX2NvbnRhY3QpO1xyXG4gICAgICAgICAgICBGb3JtSGVscGVyLmZpbGxJbnB1dHMoY29udGFjdFByb3BlcnRpZXMsIGFjY291bnQudHJ1c3RlZF9jb250YWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcblxyXG5cclxuICAgICAgICBsZXQgdHJ1c3RlZENvbnRhY3RTdWJtaXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJ1c3RlZENvbnRhY3RTdWJtaXQnKTtcclxuICAgICAgICB0cnVzdGVkQ29udGFjdFN1Ym1pdD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFGb3JtSGVscGVyLnZhbGlkYXRlKCcja3ljVHJ1c3RlZENvbnRhY3RGb3JtJykpIHJldHVybjtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKHRydXN0ZWRDb250YWN0U3VibWl0KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBGb3JtSGVscGVyLmdldFBhcmFtcygnI2t5Y1RydXN0ZWRDb250YWN0Rm9ybScpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVzZXJTZXJ2aWNlLnVwZGF0ZVRydXN0ZWRDb250YWN0KHBhcmFtcykudGhlbigocmVzcG9uc2U6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcihyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoSlNPTi5wYXJzZShyZWFzb24ubWVzc2FnZSkubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2hvd0Vycm9yKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBreWNFZGl0TmFtZUVycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0VkaXROYW1lRXJyb3InKTtcclxuICAgICAgICBpZiAoIWt5Y0VkaXROYW1lRXJyb3IpIHJldHVybjtcclxuXHJcbiAgICAgICAga3ljRWRpdE5hbWVFcnJvci5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG4gICAgICAgIGt5Y0VkaXROYW1lRXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICB9XHJcblxyXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZUhlbHBlciB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBpc09sZGVyVGhlbihkYXRlIDogRGF0ZSwgbWludXRlcyA6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHJldHVybiAoY3VycmVudFRpbWUgPiAoZGF0ZS5nZXRUaW1lKCkgKyBtaW51dGVzICogNjAgKiAxMDAwKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0V2Vla2RheSgpIHtcclxuICAgICAgICBjb25zdCB3ZWVrZGF5ID0gW1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl07XHJcblxyXG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB3ZWVrZGF5W2QuZ2V0RGF5KCldO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0T3BlbkFuZENsb3NlSG91cnMoKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgIGxldCBvcGVuSG91ciA9IDkgKyA0ICsgKC0xICogKGQuZ2V0VGltZXpvbmVPZmZzZXQoKS82MCkpO1xyXG4gICAgICAgIGxldCBjbG9zZUhvdXIgPSAxNiArIDQgKyAoLTEgKiAoZC5nZXRUaW1lem9uZU9mZnNldCgpLzYwKSk7XHJcbiAgICAgICAgcmV0dXJuIFtvcGVuSG91ciArICc6MzAnLCBjbG9zZUhvdXIgKyAnOjAwJ11cclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcclxuaW1wb3J0IERhdGVIZWxwZXIgZnJvbSAnLi4vLi4vdXRpbC9EYXRlSGVscGVyJztcclxuaW1wb3J0IEJsb2NrY2hhaW5TZXJ2aWNlIGZyb20gXCIuL0Jsb2NrY2hhaW5TZXJ2aWNlXCI7XHJcbmltcG9ydCB7ZXRoZXJzfSBmcm9tIFwiZXRoZXJzXCI7XHJcblxyXG50eXBlIExpc3RlbmVyQWN0aW9uID0gKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IHZvaWQ7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVVTRFNlcnZpY2UgZXh0ZW5kcyBCbG9ja2NoYWluU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBBVVNESW5mbzogYW55O1xyXG4gICAgcHVibGljIHN0YXRpYyBsYXN0VXBkYXRlPzogRGF0ZTtcclxuICAgIHByaXZhdGUgc3RhdGljIGFVU0RBbW91bnQ/OiBCaWdOdW1iZXI7XHJcbiAgICBzdGF0aWMgb25BVXNkTG9hZDogQXJyYXk8TGlzdGVuZXJBY3Rpb24+ID0gW107XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0QVVTREJhbGFuY2VPZihldGhBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xyXG4gICAgICAgIGlmIChBVVNEU2VydmljZS5sYXN0VXBkYXRlICYmIEFVU0RTZXJ2aWNlLmFVU0RBbW91bnQgJiZcclxuICAgICAgICAgICAgIURhdGVIZWxwZXIuaXNPbGRlclRoZW4oQVVTRFNlcnZpY2UubGFzdFVwZGF0ZSwgNSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEFVU0RTZXJ2aWNlLmFVU0RBbW91bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYmFsYW5jZU9mID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlT2YodGhpcy5jb250cmFjdHMuQVVTRF9BRERSRVNTLCBldGhBZGRyZXNzKVxyXG5cclxuICAgICAgICBsZXQgYW1vdW50ID0gZXRoZXJzLnV0aWxzLmZvcm1hdEV0aGVyKGJhbGFuY2VPZi50b1N0cmluZygpKVxyXG4gICAgICAgIEFVU0RTZXJ2aWNlLmFVU0RBbW91bnQgPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XHJcbiAgICAgICAgQVVTRFNlcnZpY2UubGFzdFVwZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBBVVNEU2VydmljZS5vbkFVc2RMb2FkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEFVU0RTZXJ2aWNlLm9uQVVzZExvYWRbaV0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEFVU0RTZXJ2aWNlLmFVU0RBbW91bnQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB0cmFuc2ZlcihzeW1ib2xBZGRyZXNzOiBzdHJpbmcsIHF0eTogQmlnTnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHN1cGVyLnRyYW5zZmVySW5uZXIodGhpcy5jb250cmFjdHMuQVVTRF9BRERSRVNTLCBzeW1ib2xBZGRyZXNzLCBxdHkpO1xyXG5cclxuICAgICAgICBBVVNEU2VydmljZS5hVVNEQW1vdW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIEFVU0RTZXJ2aWNlLmxhc3RVcGRhdGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldEFVc2RBYmkoKSB7XHJcbiAgICAgICAgaWYgKEFVU0RTZXJ2aWNlLkFVU0RJbmZvKSByZXR1cm4gQVVTRFNlcnZpY2UuQVVTREluZm8uYWJpO1xyXG5cclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnLi4vYWJpL2FVU0QuanNvbicpO1xyXG4gICAgICAgIEFVU0RTZXJ2aWNlLkFVU0RJbmZvID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiBBVVNEU2VydmljZS5BVVNESW5mby5hYmk7XHJcbiAgICB9XHJcblxyXG5cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxhcnRpY2xlPlxcclxcbiAgICA8ZGl2IGlkPVxcXCJiZWZvcmVGdW5kaW5nXFxcIj5cXHJcXG4gICAgICAgIFRvIHVzZSBsaW1pbmFsLm1hcmtldCB5b3UgbmVlZCBzb21lIGFVU0QuIGFVU0QgaXMgdGhlIHNhbWUgdmFsdWUgYXMgVVNELlxcclxcbiAgICAgICAgV2UgY2FuIGdpdmUgeW91IHNvbWUgYVVTRCAodGhpcyBpcyBhbGwgZmFrZSBtb25leSksIHNvIHlvdSBjYW4gcGxheSB3aXRoIHRoZSBzeXN0ZW0uXFxyXFxuXFxyXFxuICAgICAgICBGaXJzdCwgeW91IG5lZWQgdG8gYWRkIGFVU0QgdG8geW91IHdhbGxldC5cXHJcXG5cXHJcXG4gICAgICAgIDxidXR0b24gaWQ9XFxcImFkZFRva2VuVG9XYWxsZXRcXFwiPkFkZCBhVVNEIHRvIHdhbGxldDwvYnV0dG9uPlxcclxcbiAgICAgICAgPGJsb2NrcXVvdGUgaWQ9XFxcIm5lZWRUb0NvcHlcXFwiIGNsYXNzPVxcXCJkLW5vbmVcXFwiPlxcclxcbiAgICAgICAgICAgIElmIHRoZSBidXR0b24gZGlkbid0IHdvcmssIHlvdSBjYW4gY29weSB0aGUgYWRkcmVzcyBoZXJlIGFuZCBpbXBvcnQgaXQgaW50byB5b3VyIHdhbGxldFxcclxcbiAgICAgICAgICAgIDxpbnB1dCB2YWx1ZT1cXFwie3thVVNEQWRkcmVzc319XFxcIi8+XFxyXFxuICAgICAgICA8L2Jsb2NrcXVvdGU+XFxyXFxuICAgICAgICBXaGVuIHlvdSBoYXZlIGFVU0QgdG8geW91IHdhbGxldCwgeW91IGNhbiByZXF1ZXN0IHNvbWUgbW9uZXkgdG8gdHJhZGUgd2l0aC5cXHJcXG5cXHJcXG4gICAgICAgIDxidXR0b24gaWQ9XFxcInJlcXVlc3RGYWtlQVVTRFxcXCI+UmVxdWVzdCBzb21lIGFVU0Q8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcIndhcm5pbmdCYXIgbm90aWZpY2F0aW9uQmFyIGQtbm9uZVxcXCIgaWQ9XFxcImZ1bmRpbmdFcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGlkPVxcXCJhZnRlckZ1bmRpbmdcXFwiIGNsYXNzPVxcXCJkLW5vbmUgY2VudGVyXFxcIj5cXHJcXG4gICAgICAgIFdlIGhhdmUgbm93IHNlbmRpbmcgYVVTRCB0byB5b3VyIHdhbGxldC4gVGhpcyB1c3VhbGx5IHRha2VzIGZldyBtaW51dGVzLCBzbyBsZXRzIHdhaXQuXFxyXFxuPGJyIC8+PGJyIC8+XFxyXFxuICAgICAgICBXaGVuIHlvdSBoYXZlIHRoZSBhVVNEIGluIHlvdSB3YWxsZXQsIHdlIHdpbGwgdGVsbCB5b3UuXFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxoMz5DdXJyZW50IGFVU0QgYmFsYW5jZTwvaDM+XFxyXFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwiY3VycmVudEFVU0RCYWxhbmNlXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwiZXJyb3JBZnRlclRyeUZ1bmRpbmdcXFwiIGNsYXNzPVxcXCJkLW5vbmVcXFwiPlxcclxcbiAgICAgICAgV2UgaGFkIGFuIGVycm9yIHdoaWxlIHRyeWluZyB0byBmdW5kIHlvdS4gV2UnbGwgYmUgY3JhY2tpbmcgYXQgdGhlIGlzc3VlIHNvb24gdG8gZml4IGl0LlxcclxcbiAgICAgICAgVHJ5IGFnYWluIGluIGZldyBtaW51dGVzLiBJZiBub3QsIHRyeSBhZ2FpbiBpbiBmZXcgaG91cnMuXFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8YSBocmVmPVxcXCIjXFxcIiBpZD1cXFwicmVnaXN0ZXJCYW5rSW5mb1xcXCI+UmVnaXN0ZXIgYmFuayBpbmZvcm1hdGlvbiAobm90IG5lZWRlZCBmb3IgU2FuZGJveCk8L2E+XFxyXFxuPC9hcnRpY2xlPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBCYXNlU2VydmljZSBmcm9tIFwiLi4vYmFja2VuZC9CYXNlU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVuZGluZ1NlcnZpY2UgZXh0ZW5kcyBCYXNlU2VydmljZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZXF1ZXN0RmFrZUZ1bmRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdCgnZnVuZFVzZXInKTtcclxuICAgIH1cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8cD5TZXR1cCB5b3VyIGJhbmsgcmVsYXRpb25zaGlwIHdpdGggTGltaW5hbC5tYXJrZXQuIFBsZWFzZSBjaG9vc2UgdGhlIHR5cGUgb2YgdHJhbnNmZXIgeW91IHdhbnQgdG8gbWFrZTwvcD5cXHJcXG48dWwgY2xhc3M9XFxcImZ1bmRpbmdfdHlwZVxcXCI+XFxyXFxuICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJiYW5rX3RyYW5zZmVyXFxcIiBpZD1cXFwiYWNoX3RyYW5zZmVyXFxcIiB2YWx1ZT1cXFwiMVxcXCIvPiBBQ0ggYmFuayB0cmFuc2ZlciAoVVMpPC9sYWJlbD5cXHJcXG4gICAgPC9saT5cXHJcXG4gICAgPGxpPjxsYWJlbD48aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIG5hbWU9XFxcImJhbmtfdHJhbnNmZXJcXFwiIGlkPVxcXCJ3aXJlX3RyYW5zZmVyXFxcIiB2YWx1ZT1cXFwiMlxcXCIvPiBXaXJlIHRyYW5zZmVyXFxyXFxuICAgICAgICAoSW50ZXJuYXRpb25hbCk8L2xhYmVsPjwvbGk+XFxyXFxuPC91bD5cXHJcXG48ZGl2IGlkPVxcXCJzZWxlY3RGdW5kaW5nVHlwZUVycm9yXFxcIiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiPjwvZGl2PlxcclxcbjxidXR0b24gaWQ9XFxcIm5leHRfYmFua19pbmZvcm1hdGlvblxcXCI+TmV4dDogQmFuayBpbmZvcm1hdGlvbjwvYnV0dG9uPlxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4uL0FVU0RGdW5kXCI7XHJcbmltcG9ydCBTZWxlY3RGdW5kaW5nVHlwZUh0bWwgZnJvbSAnLi4vLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9TZWxlY3RGdW5kaW5nVHlwZS5odG1sJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdEZ1bmRpbmdUeXBlIHtcclxuXHJcbiAgICBhVXNkRnVuZDogQVVTREZ1bmRcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICB0aGlzLmFVc2RGdW5kID0gYVVzZEZ1bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFNlbGVjdEZ1bmRpbmdUeXBlSHRtbCk7XHJcblxyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQubW9kYWwuc2hvd01vZGFsKCdTZWxlY3QgZnVuZGluZyB0eXBlJywgdGVtcGxhdGUoe30pKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnQoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJpbmRFdmVudCgpIHtcclxuICAgICAgICBsZXQgbmV4dF9iYW5rX2luZm9ybWF0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHRfYmFua19pbmZvcm1hdGlvbicpO1xyXG4gICAgICAgIG5leHRfYmFua19pbmZvcm1hdGlvbj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQuaGlkZUVycm9yKCdzZWxlY3RGdW5kaW5nVHlwZUVycm9yJyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgYWNoX3RyYW5zZmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjaF90cmFuc2ZlcicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChhY2hfdHJhbnNmZXI/LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQuYWNoUmVsYXRpb25zaGlwLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgd2lyZV90cmFuc2ZlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aXJlX3RyYW5zZmVyJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHdpcmVfdHJhbnNmZXI/LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQud2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5hVXNkRnVuZC5zaG93RXJyb3IoJ3NlbGVjdEZ1bmRpbmdUeXBlRXJyb3InLCAnUGxlYXNlIHNlbGVjdCBmdW5kaW5nIHR5cGUnKVxyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICA8cD5CZWZvcmUgeW91IGNhbiB0cmFuc2ZlciwgeW91IG5lZWQgdG8gc2V0IHVwIHlvdXIgYmFuayBpbmZvcm1hdGlvbjwvcD5cXHJcXG5cXHJcXG4gICAgPGZvcm0gaWQ9XFxcImFjaEZvcm1cXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGxhYmVsPlxcclxcbiAgICAgICAgICAgICAgICBBY2NvdW50IG93bmVyIG5hbWVcXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcImFjY291bnRfb3duZXJfbmFtZVxcXCIgcmVxdWlyZWQgaWQ9XFxcImFjY291bnRfb3duZXJfbmFtZVxcXCIvPlxcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGxhYmVsPkJhbmsgQWNjb3VudCBUeXBlXFxyXFxuICAgICAgICAgICAgICAgIDxzZWxlY3QgbmFtZT1cXFwiYmFua19hY2NvdW50X3R5cGVcXFwiIGlkPVxcXCJiYW5rX2FjY291bnRfdHlwZVxcXCIgcmVxdWlyZWQ+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQ0hFQ0tJTkdcXFwiPkNoZWNraW5nPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTQVZJTkdTXFxcIj5TYXZpbmdzPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgQmFuayBhY2NvdW50IG51bWJlclxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYmFua19hY2NvdW50X251bWJlclxcXCIgaWQ9XFxcImJhbmtfYWNjb3VudF9udW1iZXJcXFwiIHJlcXVpcmVkLz5cXHJcXG4gICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgQmFuayByb3V0aW5nIG51bWJlclxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYmFua19yb3V0aW5nX251bWJlclxcXCIgaWQ9XFxcImJhbmtfcm91dGluZ19udW1iZXJcXFwiIHJlcXVpcmVkLz5cXHJcXG4gICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcInJlbGF0aW9uc2hpcEVycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcImFjaF9wcmV2aW91c1xcXCI+UHJldmlvdXM6IEZ1bmRpbmcgdHlwZTwvYnV0dG9uPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcImFjaF9uZXh0XFxcIj5OZXh0OiBTYXZlIGJhbmsgaW5mb3JtYXRpb248L2J1dHRvbj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8L2Zvcm0+XFxyXFxuXFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiZXhwb3J0IGVudW0gVHJhbnNmZXJEaXJlY3Rpb25FbnVtIHtcclxuICAgIEluY29taW5nID0gJ0lOQ09NSU5HJyxcclxuICAgIE91dGdvaW5nID0gJ09VVEdPSU5HJ1xyXG59IiwiaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi8uLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFJlbGF0aW9uc2hpcEJhc2Uge1xyXG4gICAgcHJvdGVjdGVkIGFVc2RGdW5kOiBBVVNERnVuZFxyXG5cclxuICAgIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICB0aGlzLmFVc2RGdW5kID0gYVVzZEZ1bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgYWJzdHJhY3QgYmluZEV2ZW50cygpOiB2b2lkO1xyXG5cclxuICAgIGFic3RyYWN0IHZhbGlkYXRlKCk6IGJvb2xlYW47XHJcblxyXG4gICAgcHVibGljIHNob3codGl0bGU6IHN0cmluZywgaHRtbDogc3RyaW5nLCBwYXJhbT86IGFueSkge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShodG1sKTtcclxuXHJcbiAgICAgICAgdGhpcy5hVXNkRnVuZC5tb2RhbC5zaG93TW9kYWwodGl0bGUsIHRlbXBsYXRlKHBhcmFtKSk7XHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGhhbmRsZUVycm9yUmVzcG9uc2UocmVhc29uOiBhbnkpIHtcclxuICAgICAgICBpZiAoIXJlYXNvbi5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGFsZXJ0KHJlYXNvbilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2UocmVhc29uLm1lc3NhZ2UpO1xyXG4gICAgICAgIGxldCBlcnJvckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVsYXRpb25zaGlwRXJyb3InKTtcclxuICAgICAgICBpZiAoIWVycm9yRWxlbWVudCkge1xyXG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IChvYmouc2VydmVyRXJyb3IpID8gb2JqLnNlcnZlckVycm9yLm1lc3NhZ2UgOiByZWFzb24ubWVzc2FnZVxyXG4gICAgICAgICAgICBhbGVydChtZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9iai5zZXJ2ZXJFcnJvci5tZXNzYWdlLmluZGV4T2YoJ29ubHkgb25lIGJhbmsgYXNzb2NpYXRpb24nKSAhPSAtMSkge1xyXG4gICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICAgICAgbGV0IGJhbmtSZWxhdGlvbnNoaXAgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRCYW5rUmVsYXRpb25zaGlwKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWJhbmtSZWxhdGlvbnNoaXApIHtcclxuICAgICAgICAgICAgICAgIGVycm9yRWxlbWVudC5pbm5lclRleHQgPSAnV2UgY2Fubm90IGNyZWF0ZSB0aGUgYmFuayBjb25uZWN0aW9uLiBTb21ldGhpbmcgaXMgbm90IHdvcmtpbmcgYXMgaXQgc2hvdWxkLiBQbGVhc2UgY29udGFjdCB1cyBhdCA8YSBocmVmPVwibWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXRcIj5pbmZvQGxpbWluYWwubWFya2V0PC9hPic7XHJcbiAgICAgICAgICAgICAgICBlcnJvckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB0cmFuc2ZlcnMgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRMYXRlc3RUcmFuc2ZlcnMoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLkluY29taW5nKVxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hVXNkRnVuZC50cmFuc2Zlck5vdGlmaWNhdGlvbi5zaG93KGJhbmtSZWxhdGlvbnNoaXAsIHRyYW5zZmVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvckVsZW1lbnQuaW5uZXJUZXh0ID0gb2JqLnNlcnZlckVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGVycm9yRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4uL0FVU0RGdW5kXCI7XHJcbmltcG9ydCBBQ0hSZWxhdGlvbnNoaXBIdG1sIGZyb20gJy4uLy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9SZWxhdGlvbnNoaXAvQUNIUmVsYXRpb25zaGlwLmh0bWwnO1xyXG5pbXBvcnQgRm9ybUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Gb3JtSGVscGVyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcbmltcG9ydCBSZWxhdGlvbnNoaXBCYXNlIGZyb20gXCIuL1JlbGF0aW9uc2hpcEJhc2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFDSFJlbGF0aW9uc2hpcCBleHRlbmRzIFJlbGF0aW9uc2hpcEJhc2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCkge1xyXG4gICAgICAgIHN1cGVyKGFVc2RGdW5kKVxyXG4gICAgfVxyXG5cclxuICAgIHNob3coKSB7XHJcbiAgICAgICAgc3VwZXIuc2hvdygnQmFuayBpbmZvcm1hdGlvbicsIEFDSFJlbGF0aW9uc2hpcEh0bWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBhY2hfbmV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY2hfbmV4dCcpO1xyXG4gICAgICAgIGFjaF9uZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEZvcm1IZWxwZXIuZ2V0UGFyYW1zKCcjYWNoRm9ybScpO1xyXG4gICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICAgICAgdXNlclNlcnZpY2UuY3JlYXRlQWNoUmVsYXRpb25zaGlwKHBhcmFtcy5hY2NvdW50X293bmVyX25hbWUsIHBhcmFtcy5iYW5rX2FjY291bnRfdHlwZSwgcGFyYW1zLmJhbmtfYWNjb3VudF9udW1iZXIsIHBhcmFtcy5iYW5rX3JvdXRpbmdfbnVtYmVyKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFVc2RGdW5kLmZpcnN0VHJhbnNmZXJTZXR1cC5zaG93KHJlc3VsdClcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goYXN5bmMgKHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBhY2hfcHJldmlvdXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWNoX3ByZXZpb3VzJyk7XHJcbiAgICAgICAgYWNoX3ByZXZpb3VzPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFVc2RGdW5kLnNlbGVjdEZ1bmRpbmdUeXBlLnNob3coKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIUZvcm1IZWxwZXIudmFsaWRhdGUoJyNhY2hGb3JtJykpIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuXFxyXFxuXFxyXFxuICAgIDxwPlxcclxcbiAgICAgICAgVG8gZmlsbCB1cCB5b3VyIGJyb2tlciBhY2NvdW50LCB5b3UgbmVlZCB0byBub3RpZnkgTGltaW5hbC5tYXJrZXQgZmlyc3QgYWJvdXQgeW91ciB0cmFuc2ZlcixcXHJcXG4gICAgICAgIHdlIGNhbiB0aGVuIG1hdGNoIGl0IHdpdGggeW91ciBhY2NvdW50LlxcclxcbiAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcImZpcnN0X3RyYW5zZmVyX3NldHVwXFxcIj5OZWVkIGJhbmsgaW5mb3JtYXRpb24/IENsaWNrIGhlcmU8L2E+XFxyXFxuICAgIDwvcD5cXHJcXG4gICAgPGJyLz5cXHJcXG5cXHJcXG4gICAge3t7bW9uZXlUcmFuc2ZlcnJlZH19fVxcclxcblxcclxcbiAgICB7e3t0cmFuc2ZlcnN9fX1cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8aHIvPlxcclxcbjxoMz57e0RpcmVjdGlvbn19IHRyYW5zZmVyczwvaDM+XFxyXFxue3sjaWYgdHJhbnNmZXJzLmxlbmd0aH19XFxyXFxuPHA+QmVsb3cgaXMgYSBsaXN0IG9mIHRyYW5zZmVycywgY29uZmlybWVkIGFuZCBub3QgY29uZmlybWVkLjwvcD5cXHJcXG48dGFibGU+XFxyXFxuICAgIDx0aGVhZD5cXHJcXG4gICAgPHRyPlxcclxcbiAgICAgICAgPHRoPkFtb3VudDwvdGg+XFxyXFxuICAgICAgICA8dGg+U3RhdHVzPC90aD5cXHJcXG4gICAgICAgIDx0aD5DcmVhdGVkPC90aD5cXHJcXG4gICAgICAgIDx0aD5FeHBpcmVzPC90aD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAgPC90aGVhZD5cXHJcXG4gICAgPHRib2R5PlxcclxcbiAgICB7eyNlYWNoIHRyYW5zZmVyc319XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD4ke3thbW91bnR9fTwvdGQ+XFxyXFxuICAgICAgICA8dGQgaWQ9XFxcInN0YXR1c197e2lkfX1cXFwiPnt7c3RhdHVzfX08L3RkPlxcclxcbiAgICAgICAgPHRkPnt7ZGF0ZVRpbWVGb3JtYXQgY3JlYXRlZF9hdH19PC90ZD5cXHJcXG4gICAgICAgIDx0ZD57e2RhdGVUaW1lRm9ybWF0IGV4cGlyZXNfYXR9fTwvdGQ+XFxyXFxuICAgICAgICA8dGQgaWQ9XFxcImRlbGV0ZV97e2lkfX1cXFwiIGNsYXNzPVxcXCJ7e2NsYXNzQnlTdGF0dXMgc3RhdHVzfX1cXFwiPjxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJkZWxldGVUcmFuc2ZlclxcXCIgZGF0YS1pZD1cXFwie3tpZH19XFxcIj5DYW5jZWw8L2E+XFxyXFxuICAgICAgICA8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICB7ey9lYWNofX1cXHJcXG4gICAgPC90Ym9keT5cXHJcXG48L3RhYmxlPlxcclxcbnt7ZWxzZX19XFxyXFxuPHA+Tm8gdHJhbnNmZXJzIHJlZ2lzdGVyZWQ8L3A+XFxyXFxue3svaWZ9fVwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBIYW5kbGViYXJIZWxwZXJzIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVySGVscGVycygpIHtcclxuICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdwZXJjJywgZnVuY3Rpb24gKG51bWJlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtYmVyKSAqIDEwMDAwKSAvIDEwMCArICclJztcclxuICAgICAgICB9KTtcclxuICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdyb3VuZCcsIGZ1bmN0aW9uIChudW1iZXI6IHN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG51bWJlcikgKiAxMDApIC8gMTAwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdyb3VuZDInLCBmdW5jdGlvbiAobnVtYmVyOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChudW1iZXIpICogMTAwMDApIC8gMTAwMDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignY2xhc3NDb2xvcicsIGZ1bmN0aW9uIChudW1iZXI6IG51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gKG51bWJlciA+IDApID8gXCJncmVlblwiIDogXCJyZWRcIjtcclxuICAgICAgICB9KTtcclxuICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdkYXRlVGltZUZvcm1hdCcsIGZ1bmN0aW9uIChzdHJEYXRlOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzdHJEYXRlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUudG9Mb2NhbGVTdHJpbmcoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoJ2NsYXNzQnlTdGF0dXMnLCBmdW5jdGlvbiAoc3RhdHVzOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChzdGF0dXMgPT0gJ1FVRVVFRCcgfHwgc3RhdHVzID09ICdBUFBST1ZBTF9QRU5ESU5HJykgPyAnJyA6ICdoaWRkZW4nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgVHJhbnNmZXJzTGlzdEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL1RyYW5zZmVyc0xpc3QuaHRtbCdcclxuaW1wb3J0IEhhbmRsZWJhckhlbHBlcnMgZnJvbSBcIi4uLy4uLy4uL3V0aWwvSGFuZGxlYmFySGVscGVyc1wiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuaW1wb3J0IHtUcmFuc2Zlcn0gZnJvbSBcIi4uLy4uLy4uL2R0by9hbHBhY2EvVHJhbnNmZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZmVyc0xpc3Qge1xyXG4gICAgcHJpdmF0ZSB1c2VyU2VydmljZTogVXNlclNlcnZpY2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy51c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVuZGVyKGRpcmVjdGlvbjogVHJhbnNmZXJEaXJlY3Rpb25FbnVtLCB0cmFuc2ZlcnM6IFRyYW5zZmVyW10pIHtcclxuXHJcbiAgICAgICAgSGFuZGxlYmFySGVscGVycy5yZWdpc3RlckhlbHBlcnMoKTtcclxuXHJcbiAgICAgICAgbGV0IHRyYW5zZmVyc1RlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFRyYW5zZmVyc0xpc3RIdG1sKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyc1RlbXBsYXRlKHtEaXJlY3Rpb246IGRpcmVjdGlvbiwgdHJhbnNmZXJzOiB0cmFuc2ZlcnN9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBkZWxldGVUcmFuc2ZlcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZGVsZXRlVHJhbnNmZXInKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZVRyYW5zZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkZWxldGVUcmFuc2ZlcnNbaV0/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb25maXJtKCdBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gY2FuY2VsIHRoaXMgd2l0aGRyYXcgcmVxdWVzdD8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaWQgPSAoZGVsZXRlVHJhbnNmZXJzW2ldIGFzIEhUTUxFbGVtZW50KS5kYXRhc2V0WydpZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdXNlclNlcnZpY2UuZGVsZXRlVHJhbnNmZXIoaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHVzVGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdHVzXycgKyBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNUZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGQuaW5uZXJUZXh0ID0gJ0NBTkNFTEVEJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVsZXRlVGQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVsZXRlXycgKyBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVRkPy5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vQVVTREZ1bmRcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIEZpcnN0VHJhbnNmZXJTZXR1cEJhc2Uge1xyXG4gICAgYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcDtcclxuICAgIGFVc2RGdW5kOiBBVVNERnVuZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYVVzZEZ1bmQ6IEFVU0RGdW5kLCBiYW5rUmVsYXRpb25zaGlwOiBCYW5rUmVsYXRpb25zaGlwKSB7XHJcbiAgICAgICAgdGhpcy5hVXNkRnVuZCA9IGFVc2RGdW5kO1xyXG4gICAgICAgIHRoaXMuYmFua1JlbGF0aW9uc2hpcCA9IGJhbmtSZWxhdGlvbnNoaXA7XHJcbiAgICB9XHJcblxyXG4gICAgYWJzdHJhY3Qgc2hvdygpOiB2b2lkO1xyXG5cclxuICAgIGFic3RyYWN0IGJpbmRFdmVudHMoKTogdm9pZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyKGh0bWw6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2h0bWxfdG9fZmlsbCcpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZvcm0+XFxyXFxuICAgIDxsYWJlbD5UeXBlIGluIHRoZSBhbW91bnQgaW4gVVMgRG9sbGFycyAoJCkgdGhhdCB5b3UgdHJhbnNmZXJyZWRcXHJcXG4gICAgICAgIDxpbnB1dCBuYW1lPVxcXCJhbW91bnRcXFwiIGNsYXNzPVxcXCJhbW91bnRcXFwiIHR5cGU9XFxcInRlbFxcXCIgaWQ9XFxcImFtb3VudFxcXCIgbWlubGVuZ3RoPVxcXCIxXFxcIiByZXF1aXJlZC8+XFxyXFxuICAgIDwvbGFiZWw+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwidHJhbnNmZXJFcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgIDxidXR0b24gaWQ9XFxcIm5vdGlmeVRyYW5zZmVyXFxcIj5Ob3RpZnkgTGltaW5hbC5tYXJrZXQgb2YgaW5jb21pbmcgdHJhbnNmZXI8L2J1dHRvbj5cXHJcXG5cXHJcXG4gICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwidHJhbnNmZXJfdHlwZVxcXCIgaWQ9XFxcInRyYW5zZmVyX3R5cGVcXFwiIHZhbHVlPVxcXCJ7e3RyYW5zZmVyX3R5cGV9fVxcXCIvPlxcclxcbiAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBuYW1lPVxcXCJyZWxhdGlvbnNoaXBfaWRcXFwiIGlkPVxcXCJyZWxhdGlvbnNoaXBfaWRcXFwiIHZhbHVlPVxcXCJ7e3JlbGF0aW9uc2hpcElkfX1cXFwiLz5cXHJcXG4gICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwiZGlyZWN0aW9uXFxcIiBpZD1cXFwiZGlyZWN0aW9uXFxcIiB2YWx1ZT1cXFwiSU5DT01JTkdcXFwiLz5cXHJcXG48L2Zvcm0+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXBQYWdlIGZyb20gXCIuL0ZpcnN0VHJhbnNmZXJTZXR1cEJhc2VcIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBNb25leVRyYW5zZmVycmVkSHRtbCBmcm9tIFwiLi4vLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9Nb25leVRyYW5zZmVycmVkLmh0bWxcIjtcclxuaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgU3RyaW5nSGVscGVyIGZyb20gXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0hlbHBlclwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9uZXlUcmFuc2ZlcnJlZCBleHRlbmRzIEZpcnN0VHJhbnNmZXJTZXR1cFBhZ2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCwgYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCkge1xyXG4gICAgICAgIHN1cGVyKGFVc2RGdW5kLCBiYW5rUmVsYXRpb25zaGlwKTtcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCk6IHZvaWQge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShNb25leVRyYW5zZmVycmVkSHRtbCk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRlbXBsYXRlKHt9KSk7XHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCk6IHN0cmluZyB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKE1vbmV5VHJhbnNmZXJyZWRIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe1xyXG4gICAgICAgICAgICB0cmFuc2Zlcl90eXBlOiB0aGlzLmJhbmtSZWxhdGlvbnNoaXAudHJhbnNmZXJfdHlwZSxcclxuICAgICAgICAgICAgcmVsYXRpb25zaGlwSWQ6IHRoaXMuYmFua1JlbGF0aW9uc2hpcC5pZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGJpbmRFdmVudHMoKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGxldCBub3RpZnlUcmFuc2ZlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub3RpZnlUcmFuc2ZlcicpO1xyXG4gICAgICAgIG5vdGlmeVRyYW5zZmVyPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQuaGlkZUVycm9yKCd0cmFuc2ZlckVycm9yJyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Ftb3VudCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShhbW91bnQudmFsdWUpIHx8IHBhcnNlRmxvYXQoYW1vdW50LnZhbHVlKSA8IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFVc2RGdW5kLnNob3dFcnJvcignYW1vdW50RXJyb3InLCAnQW1vdW50IGNhbm5vdCBiZSBlbXB0eSBvciBiZWxvdyAkMTAnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyhub3RpZnlUcmFuc2Zlcik7XHJcblxyXG4gICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICAgICAgYXdhaXQgdXNlclNlcnZpY2UuY3JlYXRlVHJhbnNmZXIoYW1vdW50LnZhbHVlLCAnSU5DT01JTkcnKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQudHJhbnNmZXJOb3RpZmllZC5zaG93KHRoaXMuYmFua1JlbGF0aW9uc2hpcCEsIGFtb3VudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGh0dHBFcnJvciA9IEpTT04ucGFyc2UocmVhc29uLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQuc2hvd0Vycm9yKCd0cmFuc2ZlckVycm9yJywgaHR0cEVycm9yLnNlcnZlckVycm9yLm1lc3NhZ2UpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG5cclxufSIsImltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgVHJhbnNmZXJOb3RpZmljYXRpb25IdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9UcmFuc2Zlck5vdGlmaWNhdGlvbi5odG1sJ1xyXG5pbXBvcnQgTW9uZXlUcmFuc2ZlcnJlZEh0bWwgZnJvbSBcIi4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvTW9uZXlUcmFuc2ZlcnJlZC5odG1sXCI7XHJcbmltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgU3RyaW5nSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL1N0cmluZ0hlbHBlclwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQge1RyYW5zZmVyRGlyZWN0aW9uRW51bX0gZnJvbSBcIi4uLy4uLy4uL2VudW1zL1RyYW5zZmVyRGlyZWN0aW9uRW51bVwiO1xyXG5pbXBvcnQgVHJhbnNmZXJzTGlzdCBmcm9tIFwiLi9UcmFuc2ZlcnNMaXN0XCI7XHJcbmltcG9ydCB7VHJhbnNmZXJ9IGZyb20gXCIuLi8uLi8uLi9kdG8vYWxwYWNhL1RyYW5zZmVyXCI7XHJcbmltcG9ydCBNb25leVRyYW5zZmVycmVkIGZyb20gXCIuL0ZpcnN0VHJhbnNmZXJTZXR1cC9Nb25leVRyYW5zZmVycmVkXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2Zlck5vdGlmaWNhdGlvbiB7XHJcblxyXG4gICAgYVVzZEZ1bmQ6IEFVU0RGdW5kXHJcbiAgICBiYW5rUmVsYXRpb25zaGlwPzogQmFua1JlbGF0aW9uc2hpcDtcclxuICAgIHByaXZhdGUgdHJhbnNmZXJzTGlzdDogVHJhbnNmZXJzTGlzdDtcclxuICAgIG1vbmV5VHJhbnNmZXJyZWQ/OiBNb25leVRyYW5zZmVycmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCkge1xyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQgPSBhVXNkRnVuZDtcclxuICAgICAgICB0aGlzLnRyYW5zZmVyc0xpc3QgPSBuZXcgVHJhbnNmZXJzTGlzdCgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvdyhiYW5rUmVsYXRpb25zaGlwOiBCYW5rUmVsYXRpb25zaGlwLCB0cmFuc2ZlcnM6IFRyYW5zZmVyW10pIHtcclxuICAgICAgICB0aGlzLmJhbmtSZWxhdGlvbnNoaXAgPSBiYW5rUmVsYXRpb25zaGlwO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVHJhbnNmZXJOb3RpZmljYXRpb25IdG1sKVxyXG4gICAgICAgIGxldCB0cmFuc2ZlcnNMaXN0SHRtbCA9IGF3YWl0IHRoaXMudHJhbnNmZXJzTGlzdC5yZW5kZXIoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLkluY29taW5nLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgIHRoaXMubW9uZXlUcmFuc2ZlcnJlZCA9IG5ldyBNb25leVRyYW5zZmVycmVkKHRoaXMuYVVzZEZ1bmQsIHRoaXMuYmFua1JlbGF0aW9uc2hpcCk7XHJcblxyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQubW9kYWwuc2hvd01vZGFsKCdDcmVhdGUgdHJhbnNmZXIgbm90aWZpY2F0aW9uJywgdGVtcGxhdGUoe1xyXG4gICAgICAgICAgICBtb25leVRyYW5zZmVycmVkOiB0aGlzLm1vbmV5VHJhbnNmZXJyZWQucmVuZGVyKCksXHJcbiAgICAgICAgICAgIHRyYW5zZmVyczogdHJhbnNmZXJzTGlzdEh0bWxcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMubW9uZXlUcmFuc2ZlcnJlZD8uYmluZEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJzTGlzdC5iaW5kRXZlbnRzKCk7XHJcblxyXG4gICAgICAgIGxldCBmaXJzdF90cmFuc2Zlcl9zZXR1cCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaXJzdF90cmFuc2Zlcl9zZXR1cCcpO1xyXG4gICAgICAgIGZpcnN0X3RyYW5zZmVyX3NldHVwPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFVc2RGdW5kLmZpcnN0VHJhbnNmZXJTZXR1cC5zaG93KHRoaXMuYmFua1JlbGF0aW9uc2hpcCEpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICA8cD5CZWZvcmUgeW91IGNhbiB0cmFuc2ZlciwgeW91IG5lZWQgdG8gc2V0IHVwIHlvdXIgYmFuayBpbmZvcm1hdGlvbjwvcD5cXHJcXG4gICAgPGZvcm0gaWQ9XFxcIndpcmVUcmFuc2ZlckZvcm1cXFwiPlxcclxcbiAgICAgICAgPGxhYmVsPkJhbmsgbmFtZVxcclxcbiAgICAgICAgICAgIDxpbnB1dCBuYW1lPVxcXCJuYW1lXFxcIiByZXF1aXJlZCBpZD1cXFwibmFtZVxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwic3dpZnRfZXJyb3JcXFwiPkJJQy9TV0lGVCBjb2RlIHNob3VsZCBiZSA4IG9yIDExIGNoYXJhY3RlcnM8L2Rpdj5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBCYW5rIGNvZGUgKEJJQy9TV0lGVClcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYmFua19jb2RlXFxcIiBtYXhsZW5ndGg9XFxcIjExXFxcIiBpZD1cXFwiYmFua19jb2RlXFxcIiByZXF1aXJlZC8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGxhYmVsPlxcclxcbiAgICAgICAgICAgIEJhbmsgU3RyZWV0IGFkZHJlc3NcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwic3RyZWV0X2FkZHJlc3NcXFwiIGlkPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCIgcmVxdWlyZWQvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBCYW5rIFBvc3RhbCBjb2RlXFxyXFxuICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcInBvc3RhbF9jb2RlXFxcIiBpZD1cXFwicG9zdGFsX2NvZGVcXFwiIHJlcXVpcmVkLz5cXHJcXG4gICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8bGFiZWw+XFxyXFxuICAgICAgICAgICAgQmFuayBDaXR5XFxyXFxuICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcImNpdHlcXFwiIGlkPVxcXCJjaXR5XFxcIiByZXF1aXJlZC8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcblxcclxcbiAgICAgICAgPGxhYmVsPkJhbmsgU3RhdGVcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwic3RhdGVfcHJvdmluY2VcXFwiIGlkPVxcXCJzdGF0ZV9wcm92aW5jZVxcXCIgcmVxdWlyZWQvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBDb3VudHJ5IHdoZXJlIGJhbmsgYWNjb3VudCBpcyBsb2NhdGVkXFxyXFxuICAgICAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiY291bnRyeVxcXCIgcmVxdWlyZWQgbmFtZT1cXFwiY291bnRyeVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwie3tjb2RlfX1cXFwiPnt7bmFtZX19PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBBY2NvdW50IG51bWJlciAoSUJBTilcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYWNjb3VudF9udW1iZXJcXFwiIGlkPVxcXCJhY2NvdW50X251bWJlclxcXCIgcmVxdWlyZWQvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcImJhbmtfY29kZV90eXBlXFxcIiB2YWx1ZT1cXFwiQklDXFxcIi8+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJyZWxhdGlvbnNoaXBFcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcIndpcmVfdHJhbnNmZXJfcHJldmlvdXNcXFwiPlByZXZpb3VzOiBGdW5kaW5nIHR5cGU8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGlkPVxcXCJzYXZlX2ludGVybmF0aW9uYWxfYmFua19pbmZvcm1hdGlvblxcXCI+TmV4dDogVHJhbnNmZXI8L2J1dHRvbj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Zvcm0+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgV2lyZVRyYW5zZmVySHRtbCBmcm9tIFwiLi4vLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9XaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAuaHRtbFwiO1xyXG5pbXBvcnQgRm9ybUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Gb3JtSGVscGVyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgQ291bnRyeUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Db3VudHJ5SGVscGVyXCI7XHJcbmltcG9ydCBSZWxhdGlvbnNoaXBCYXNlIGZyb20gXCIuL1JlbGF0aW9uc2hpcEJhc2VcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi8uLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAgZXh0ZW5kcyBSZWxhdGlvbnNoaXBCYXNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICBzdXBlcihhVXNkRnVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgc3VwZXIuc2hvdygnQ3JlYXRlIGJhbmsgaW5mb3JtYXRpb24nLCBXaXJlVHJhbnNmZXJIdG1sLCB7Y291bnRyaWVzOiBDb3VudHJ5SGVscGVyLkNvdW50cmllc30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCB3aXJlX3RyYW5zZmVyX3ByZXZpb3VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpcmVfdHJhbnNmZXJfcHJldmlvdXMnKTtcclxuICAgICAgICB3aXJlX3RyYW5zZmVyX3ByZXZpb3VzPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hVXNkRnVuZC5zZWxlY3RGdW5kaW5nVHlwZS5zaG93KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBzYXZlX2ludGVybmF0aW9uYWxfYmFua19pbmZvcm1hdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYXZlX2ludGVybmF0aW9uYWxfYmFua19pbmZvcm1hdGlvbicpO1xyXG4gICAgICAgIHNhdmVfaW50ZXJuYXRpb25hbF9iYW5rX2luZm9ybWF0aW9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEZvcm1IZWxwZXIuZ2V0UGFyYW1zKCcjd2lyZVRyYW5zZmVyRm9ybScpO1xyXG4gICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICAgICAgYXdhaXQgdXNlclNlcnZpY2UucmVnaXN0ZXJXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAocGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKGJhbmtSZWxhdGlvbnNoaXA6IEJhbmtSZWxhdGlvbnNoaXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmZXJzID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0TGF0ZXN0VHJhbnNmZXJzKFRyYW5zZmVyRGlyZWN0aW9uRW51bS5JbmNvbWluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hVXNkRnVuZC50cmFuc2Zlck5vdGlmaWNhdGlvbi5zaG93KGJhbmtSZWxhdGlvbnNoaXAsIHRyYW5zZmVycylcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goYXN5bmMgKHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgbGV0IHN3aWZ0X2Vycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N3aWZ0X2Vycm9yJyk7XHJcbiAgICAgICAgaWYgKHN3aWZ0X2Vycm9yKSBzd2lmdF9lcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGxldCB3cml0ZVRyYW5zZmVyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JpdGVUcmFuc2ZlckVycm9yJyk7XHJcbiAgICAgICAgaWYgKHdyaXRlVHJhbnNmZXJFcnJvcikgd3JpdGVUcmFuc2ZlckVycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmICghRm9ybUhlbHBlci52YWxpZGF0ZSgnI3dpcmVUcmFuc2ZlckZvcm0nKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgYmFua19jb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbmtfY29kZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGJhbmtfY29kZS52YWx1ZS5sZW5ndGggIT0gOCAmJiBiYW5rX2NvZGUudmFsdWUubGVuZ3RoICE9IDExKSB7XHJcbiAgICAgICAgICAgIGJhbmtfY29kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgIGxldCBzd2lmdF9lcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2lmdF9lcnJvcicpO1xyXG4gICAgICAgICAgICBpZiAoc3dpZnRfZXJyb3IpIHN3aWZ0X2Vycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxoMj5Zb3Ugc2hvdWxkIHRyYW5zZmVyIHlvdXIgbW9uZXkgbm93PC9oMj5cXHJcXG5cXHJcXG48dWw+XFxyXFxuICAgIDxsaT5BbW91bnQ6IHt7YW1vdW50fX08L2xpPlxcclxcbiAgICA8bGk+RnJvbSBBY2NvdW50OiB7e2FjY291bnRfbnVtYmVyfX08L2xpPlxcclxcbjwvdWw+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgVHJhbnNmZXJJbmZvSHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL1RyYW5zZmVySW5mby5odG1sXCJcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2Zlck5vdGlmaWVkIHtcclxuXHJcbiAgICBhVXNkRnVuZDogQVVTREZ1bmQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYVVzZEZ1bmQ6IEFVU0RGdW5kKSB7XHJcbiAgICAgICAgdGhpcy5hVXNkRnVuZCA9IGFVc2RGdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KGJhbmtSZWxhdGlvbnNoaXA6IEJhbmtSZWxhdGlvbnNoaXAsIGFtb3VudDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFRyYW5zZmVySW5mb0h0bWwpO1xyXG4gICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgIGFtb3VudCxcclxuICAgICAgICAgICAgYWNjb3VudF9udW1iZXI6IGJhbmtSZWxhdGlvbnNoaXAuYWxwYWNhX2FjY291bnRfbnVtYmVyLFxyXG4gICAgICAgICAgICB3aXJlOiAoYmFua1JlbGF0aW9uc2hpcC50cmFuc2Zlcl90eXBlID09ICd3aXJlJylcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQubW9kYWwuc2hvd01vZGFsKCdUcmFuc2ZlciBpbmZvcm1hdGlvbicsIHRlbXBsYXRlKG9iaikpO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBpZD1cXFwiaHRtbF90b19maWxsXFxcIj5cXHJcXG4gICAge3t7aHRtbH19fVxcclxcbjwvZGl2PlxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJDcmVhdGUgdGhlIGJhbmsgaW5mb3JtYXRpb24geW91IG5lZWQgaW4geW91ciBpbnRlcm5ldCBiYW5rXFxyXFxuPHRhYmxlPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+QmFuayBuYW1lPC90ZD5cXHJcXG4gICAgICAgIDx0ZD5CTU8gSGFycmlzIEJhbmsgTkE8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+QmFuayBhZGRyZXNzPC90ZD5cXHJcXG4gICAgICAgIDx0ZD5CTU8gSGFycmlzIEJhbmtcXHJcXG4gICAgICAgICAgICAxMTEuIFcuIE1vbnJvZSBTdHJlZXRcXHJcXG4gICAgICAgICAgICBDaGljYWdvLCBJTCA2MDYwMywgVVNBXFxyXFxuICAgICAgICA8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+UmVjaXBpZW50IC0gQWNjb3VudCBuYW1lPC90ZD5cXHJcXG4gICAgICAgIDx0ZD5BbHBhY2EgU2VjdXJpdGllcyBMTEM8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+QWxwYWNhIGFkZHJlc3M8L3RkPlxcclxcbiAgICAgICAgPHRkPkFscGFjYSBTZWN1cml0aWVzIExMQ1xcclxcbiAgICAgICAgICAgIDMgRWFzdCBUaGlyZCBBdmUsIFN1aXRlIDIzM1xcclxcbiAgICAgICAgICAgIFNhbiBNYXRlbywgQ0EgOTQ0MDEsIFVTQVxcclxcbiAgICAgICAgPC90ZD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAgPHRyPlxcclxcbiAgICAgICAgPHRkPkFjY291bnQgbnVtYmVyIC8gSUJBTjwvdGQ+XFxyXFxuICAgICAgICA8dGQ+MTYzNjg3NzwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIHt7I2lmIHdpcmV9fVxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+U1dJRlQgQ09ERTwvdGQ+XFxyXFxuICAgICAgICA8dGQ+SEFUUlVTNDQ8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICB7e159fVxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+QUJBIFJPVVRJTkcgTlVNQkVSIChBQ0gpPC90ZD5cXHJcXG4gICAgICAgIDx0ZD4wNzEwMDAyODg8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICB7ey9pZn19XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5QbGVhc2Ugc3BlY2lmeSB0aGUgZm9sbG93aW5nIGluIHRoZSByZWZlcmVuY2Ugb2YgdGhlIHdpcmU6PC90ZD5cXHJcXG4gICAgICAgIDx0ZD5GRkMgTE1LVC17e2FjY291bnRfbnVtYmVyfX08L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbjwvdGFibGU+XFxyXFxuPGJ1dHRvbiBpZD1cXFwiYmFua19pbmZvX25leHRcXFwiPk5leHQ6IEkgc2V0IHVwIHRoZSBpbmZvcm1hdGlvbiBpbiBteSBiYW5rPC9idXR0b24+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxoMz5UcmFuc2ZlciBtb25leTwvaDM+XFxyXFxuWW91IGNhbiBub3cgbG9nIGluIHRvIHlvdXIgaW50ZXJuZXQgYmFuayBhbmQgdHJhbnNmZXIgdGhlIG1vbmV5IHRvIEFscGFjYS5cXHJcXG48YnIvPjxici8+XFxyXFxuQWZ0ZXIgeW91IGhhdmUgdHJhbnNmZXJyZWQgdGhlIG1vbmV5LCB5b3UgbmVlZCB0byBsZXQgdXMga25vdyB0aGUgYW1vdW50IHRoYXQgeW91IHRyYW5zZmVycmVkLlxcclxcblxcclxcbjxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICA8YnV0dG9uIGlkPVxcXCJwcmV2X3dpcmVfdHJhbnNmZXJfbW9uZXlcXFwiPlByZXZpb3VzOiBTZWUgYmFuayBpbmZvcm1hdGlvbjwvYnV0dG9uPlxcclxcbiAgICA8YnV0dG9uIGlkPVxcXCJuZXh0X3dpcmVfdHJhbnNmZXJfbW9uZXlcXFwiPk5leHQ6IEkgaGF2ZSB0cmFuc2ZlcnJlZCB0aGUgbW9uZXk8L2J1dHRvbj5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IFdpcmVUcmFuc2Zlck1vbmV5SHRtbCBmcm9tICcuLi8uLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL1dpcmVUcmFuc2Zlck1vbmV5Lmh0bWwnO1xyXG5pbXBvcnQgRmlyc3RUcmFuc2ZlclNldHVwQmFzZSBmcm9tIFwiLi9GaXJzdFRyYW5zZmVyU2V0dXBCYXNlXCI7XHJcbmltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uLy4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgTW9uZXlUcmFuc2ZlcnJlZCBmcm9tIFwiLi9Nb25leVRyYW5zZmVycmVkXCI7XHJcbmltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vQVVTREZ1bmRcIjtcclxuaW1wb3J0IGRvYyA9IE1vY2hhLnJlcG9ydGVycy5kb2M7XHJcbmltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXAgZnJvbSBcIi4vRmlyc3RUcmFuc2ZlclNldHVwXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2lyZVRyYW5zZmVyTW9uZXkgZXh0ZW5kcyBGaXJzdFRyYW5zZmVyU2V0dXBCYXNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQsIGJhbmtSZWxhdGlvbnNoaXA6IEJhbmtSZWxhdGlvbnNoaXApIHtcclxuICAgICAgICBzdXBlcihhVXNkRnVuZCwgYmFua1JlbGF0aW9uc2hpcCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFdpcmVUcmFuc2Zlck1vbmV5SHRtbCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGVtcGxhdGUoe30pKTtcclxuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYmluZEV2ZW50cygpIHtcclxuICAgICAgICBsZXQgbmV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0X3dpcmVfdHJhbnNmZXJfbW9uZXknKTtcclxuICAgICAgICBuZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbW9uZXlUcmFuc2ZlcnJlZCA9IG5ldyBNb25leVRyYW5zZmVycmVkKHRoaXMuYVVzZEZ1bmQsIHRoaXMuYmFua1JlbGF0aW9uc2hpcClcclxuICAgICAgICAgICAgbW9uZXlUcmFuc2ZlcnJlZC5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IHByZXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJldl93aXJlX3RyYW5zZmVyX21vbmV5Jyk7XHJcbiAgICAgICAgcHJldj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHRyYW5zZmVyU2V0dXAgPSBuZXcgRmlyc3RUcmFuc2ZlclNldHVwKHRoaXMuYVVzZEZ1bmQpO1xyXG4gICAgICAgICAgICB0cmFuc2ZlclNldHVwLnNob3codGhpcy5iYW5rUmVsYXRpb25zaGlwKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJUaGUgbW9uZXkgc2hvdWxkIGNvbWUgZnJvbSBiYW5rIGFjY291bnQgbnVtYmVyIDxzdHJvbmc+e3tiYW5rX2FjY291bnRfbnVtYmVyfX08L3N0cm9uZz5cXHJcXG48ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgPGJ1dHRvbiBpZD1cXFwibmV4dF9hY2hfYWNjb3VudF9udW1iZXJcXFwiPlllcywgaXQncyBjb21pbmcgZnJvbSB7e2JhbmtfYWNjb3VudF9udW1iZXJ9fTwvYnV0dG9uPlxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgQUNIVHJhbnNmZXJBY2NvdW50TnVtYmVySHRtbFxyXG4gICAgZnJvbSAnLi4vLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9BQ0hUcmFuc2ZlckFjY291bnROdW1iZXIuaHRtbCc7XHJcbmltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXBCYXNlIGZyb20gXCIuL0ZpcnN0VHJhbnNmZXJTZXR1cEJhc2VcIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBNb25leVRyYW5zZmVycmVkIGZyb20gXCIuL01vbmV5VHJhbnNmZXJyZWRcIjtcclxuaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFDSFRyYW5zZmVyQWNjb3VudE51bWJlciBleHRlbmRzIEZpcnN0VHJhbnNmZXJTZXR1cEJhc2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCwgYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCkge1xyXG4gICAgICAgIHN1cGVyKGFVc2RGdW5kLCBiYW5rUmVsYXRpb25zaGlwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoQUNIVHJhbnNmZXJBY2NvdW50TnVtYmVySHRtbCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGVtcGxhdGUoe2JhbmtfYWNjb3VudF9udW1iZXI6IHRoaXMuYmFua1JlbGF0aW9uc2hpcC5hbHBhY2FfYWNjb3VudF9udW1iZXJ9KSk7XHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IG5leHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV4dF9hY2hfYWNjb3VudF9udW1iZXInKTtcclxuICAgICAgICBuZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbW9uZXlUcmFuc2ZlcnJlZCA9IG5ldyBNb25leVRyYW5zZmVycmVkKHRoaXMuYVVzZEZ1bmQsIHRoaXMuYmFua1JlbGF0aW9uc2hpcClcclxuICAgICAgICAgICAgbW9uZXlUcmFuc2ZlcnJlZC5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsImltcG9ydCBCYW5rSW5mb0h0bWwgZnJvbSAnLi4vLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9CYW5rSW5mby5odG1sJ1xyXG5pbXBvcnQge0JhbmtSZWxhdGlvbnNoaXB9IGZyb20gXCIuLi8uLi8uLi8uLi9kdG8vYWxwYWNhL0JhbmtSZWxhdGlvbnNoaXBcIjtcclxuaW1wb3J0IFdpcmVUcmFuc2Zlck1vbmV5IGZyb20gXCIuL1dpcmVUcmFuc2Zlck1vbmV5XCI7XHJcbmltcG9ydCBBQ0hUcmFuc2ZlckFjY291bnROdW1iZXIgZnJvbSAnLi9BQ0hUcmFuc2ZlckFjY291bnROdW1iZXInO1xyXG5pbXBvcnQgRmlyc3RUcmFuc2ZlclNldHVwQmFzZSBmcm9tIFwiLi9GaXJzdFRyYW5zZmVyU2V0dXBCYXNlXCI7XHJcbmltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vQVVTREZ1bmRcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhbmtJbmZvIGV4dGVuZHMgRmlyc3RUcmFuc2ZlclNldHVwQmFzZSB7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCwgYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCkge1xyXG4gICAgICAgIHN1cGVyKGFVc2RGdW5kLCBiYW5rUmVsYXRpb25zaGlwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBsZXQgYmFua0luZm9UZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShCYW5rSW5mb0h0bWwpO1xyXG4gICAgICAgIGxldCBiYW5rSW5mb0h0bWwgPSBiYW5rSW5mb1RlbXBsYXRlKHtcclxuICAgICAgICAgICAgd2lyZTogdGhpcy5iYW5rUmVsYXRpb25zaGlwLnRyYW5zZmVyX3R5cGUgPT0gJ3dpcmUnLFxyXG4gICAgICAgICAgICBhY2NvdW50X251bWJlcjogdGhpcy5iYW5rUmVsYXRpb25zaGlwLmFscGFjYV9hY2NvdW50X251bWJlclxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnJlbmRlcihiYW5rSW5mb0h0bWwpO1xyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBuZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbmtfaW5mb19uZXh0Jyk7XHJcbiAgICAgICAgbmV4dD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuYmFua1JlbGF0aW9uc2hpcC50cmFuc2Zlcl90eXBlID09ICd3aXJlJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHdpcmVUcmFuc2Zlck1vbmV5ID0gbmV3IFdpcmVUcmFuc2Zlck1vbmV5KHRoaXMuYVVzZEZ1bmQsIHRoaXMuYmFua1JlbGF0aW9uc2hpcCk7XHJcbiAgICAgICAgICAgICAgICB3aXJlVHJhbnNmZXJNb25leS5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWNoID0gbmV3IEFDSFRyYW5zZmVyQWNjb3VudE51bWJlcih0aGlzLmFVc2RGdW5kLCB0aGlzLmJhbmtSZWxhdGlvbnNoaXApO1xyXG4gICAgICAgICAgICAgICAgYWNoLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4uL0FVU0RGdW5kXCI7XHJcbmltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uLy4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgRmlyc3RUcmFuc2ZlclNldHVwSHRtbCBmcm9tICcuLi8uLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0ZpcnN0VHJhbnNmZXJTZXR1cC5odG1sJ1xyXG5pbXBvcnQgQmFua0luZm8gZnJvbSBcIi4uL0ZpcnN0VHJhbnNmZXJTZXR1cC9CYW5rSW5mb1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlyc3RUcmFuc2ZlclNldHVwIHtcclxuXHJcbiAgICBhVXNkRnVuZDogQVVTREZ1bmRcclxuICAgIGJhbmtSZWxhdGlvbnNoaXA/OiBCYW5rUmVsYXRpb25zaGlwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCkge1xyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQgPSBhVXNkRnVuZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdyhiYW5rUmVsYXRpb25zaGlwOiBCYW5rUmVsYXRpb25zaGlwKSB7XHJcbiAgICAgICAgdGhpcy5iYW5rUmVsYXRpb25zaGlwID0gYmFua1JlbGF0aW9uc2hpcDtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEZpcnN0VHJhbnNmZXJTZXR1cEh0bWwpO1xyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQubW9kYWwuc2hvd01vZGFsKCdTZXR1cCB0cmFuc2ZlcicsIHRlbXBsYXRlKHt9KSk7XHJcblxyXG4gICAgICAgIGxldCBiYW5rSW5mbyA9IG5ldyBCYW5rSW5mbyh0aGlzLmFVc2RGdW5kLCBiYW5rUmVsYXRpb25zaGlwKTtcclxuICAgICAgICBiYW5rSW5mby5zaG93KCk7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgU2VsZWN0RnVuZGluZ1R5cGUgZnJvbSBcIi4vUmVsYXRpb25zaGlwL1NlbGVjdEZ1bmRpbmdUeXBlXCI7XHJcbmltcG9ydCBBQ0hSZWxhdGlvbnNoaXAgZnJvbSBcIi4vUmVsYXRpb25zaGlwL0FDSFJlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgVHJhbnNmZXJOb3RpZmljYXRpb24gZnJvbSBcIi4vVHJhbnNmZXJOb3RpZmljYXRpb25cIjtcclxuaW1wb3J0IFdpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcCBmcm9tIFwiLi9SZWxhdGlvbnNoaXAvV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgVHJhbnNmZXJOb3RpZmllZCBmcm9tIFwiLi9UcmFuc2Zlck5vdGlmaWVkXCI7XHJcbmltcG9ydCB7VHJhbnNmZXJEaXJlY3Rpb25FbnVtfSBmcm9tIFwiLi4vLi4vLi4vZW51bXMvVHJhbnNmZXJEaXJlY3Rpb25FbnVtXCI7XHJcbmltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXAgZnJvbSBcIi4vRmlyc3RUcmFuc2ZlclNldHVwL0ZpcnN0VHJhbnNmZXJTZXR1cFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVVTREZ1bmQge1xyXG5cclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBzZWxlY3RGdW5kaW5nVHlwZTogU2VsZWN0RnVuZGluZ1R5cGU7XHJcbiAgICBhY2hSZWxhdGlvbnNoaXA6IEFDSFJlbGF0aW9uc2hpcDtcclxuICAgIHdpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcDogV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwO1xyXG5cclxuICAgIGZpcnN0VHJhbnNmZXJTZXR1cDogRmlyc3RUcmFuc2ZlclNldHVwO1xyXG4gICAgdHJhbnNmZXJOb3RpZmljYXRpb246IFRyYW5zZmVyTm90aWZpY2F0aW9uO1xyXG4gICAgdHJhbnNmZXJOb3RpZmllZDogVHJhbnNmZXJOb3RpZmllZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0RnVuZGluZ1R5cGUgPSBuZXcgU2VsZWN0RnVuZGluZ1R5cGUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hY2hSZWxhdGlvbnNoaXAgPSBuZXcgQUNIUmVsYXRpb25zaGlwKHRoaXMpO1xyXG4gICAgICAgIHRoaXMud2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwID0gbmV3IFdpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcCh0aGlzKTtcclxuXHJcbiAgICAgICAgdGhpcy5maXJzdFRyYW5zZmVyU2V0dXAgPSBuZXcgRmlyc3RUcmFuc2ZlclNldHVwKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJOb3RpZmljYXRpb24gPSBuZXcgVHJhbnNmZXJOb3RpZmljYXRpb24odGhpcyk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zlck5vdGlmaWVkID0gbmV3IFRyYW5zZmVyTm90aWZpZWQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGJhbmtSZWxhdGlvbnNoaXAgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRCYW5rUmVsYXRpb25zaGlwKCk7XHJcbiAgICAgICAgaWYgKGJhbmtSZWxhdGlvbnNoaXApIHtcclxuICAgICAgICAgICAgbGV0IHRyYW5zZmVycyA9IGF3YWl0IHVzZXJTZXJ2aWNlLmdldExhdGVzdFRyYW5zZmVycyhUcmFuc2ZlckRpcmVjdGlvbkVudW0uSW5jb21pbmcpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhbnNmZXJOb3RpZmljYXRpb24uc2hvdyhiYW5rUmVsYXRpb25zaGlwLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFRyYW5zZmVyU2V0dXAuc2hvdyhiYW5rUmVsYXRpb25zaGlwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RnVuZGluZ1R5cGUuc2hvdygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3dFcnJvcihlbGVtZW50SWQ6IHN0cmluZywgcmVhc29uOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSByZWFzb247XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBoaWRlRXJyb3IoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBGYWtlRnVuZGluZ0h0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9mdW5kaW5nL0Zha2VGdW5kaW5nLmh0bWwnO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL01vZGFsXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCBDb250cmFjdEluZm8gZnJvbSBcIi4uLy4uLy4uL2NvbnRyYWN0cy9Db250cmFjdEluZm9cIjtcclxuaW1wb3J0IEZ1bmRpbmdTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9icm9rZXIvRnVuZGluZ1NlcnZpY2VcIjtcclxuaW1wb3J0IEFVU0RTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0FVU0RTZXJ2aWNlXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQge3JvdW5kQmlnTnVtYmVyfSBmcm9tIFwiLi4vLi4vLi4vdXRpbC9IZWxwZXJcIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbmltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBBcHAgZnJvbSBcIi4uLy4uLy4uL21haW5cIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWtlQVVTREZ1bmQge1xyXG4gICAgY3VycmVudEJhbGFuY2U6IEJpZ051bWJlcjtcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYWxhbmNlID0gbmV3IEJpZ051bWJlcigtMSk7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93QVVTREZ1bmQoKSB7XHJcbiAgICAgICAgbGV0IGFVc2RGdW5kID0gbmV3IEFVU0RGdW5kKCk7XHJcbiAgICAgICAgYVVzZEZ1bmQuc2hvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93QVVTREZha2VGdW5kKCkge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IEFwcC5OZXR3b3JrO1xyXG4gICAgICAgIGlmICghbmV0d29ya0luZm8uVGVzdE5ldHdvcmspIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93QVVTREZ1bmQoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoRmFrZUZ1bmRpbmdIdG1sKTtcclxuXHJcbiAgICAgICAgbGV0IGNvbnRyYWN0SW5mbyA9IENvbnRyYWN0SW5mby5nZXRDb250cmFjdEluZm8oKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKHthVVNEQWRkcmVzczogY29udHJhY3RJbmZvLkFVU0RfQUREUkVTU30pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5tb2RhbC5zaG93TW9kYWwoJ0Z1bmQgbXkgYWNjb3VudCAoRmFrZSBtb25leSknLCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgbGV0IGFkZFRvV2FsbGV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFRva2VuVG9XYWxsZXQnKTtcclxuICAgICAgICBpZiAoIWFkZFRvV2FsbGV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGFkZFRvV2FsbGV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbygpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIoKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdhbGxldEhlbHBlci5hZGRUb2tlblRvV2FsbGV0KGNvbnRyYWN0SW5mby5BVVNEX0FERFJFU1MsICdhVVNEJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Q29weUZpZWxkKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB0aGlzLnNob3dDb3B5RmllbGQoKTtcclxuXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IHJlZ2lzdGVyQmFua0luZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVnaXN0ZXJCYW5rSW5mbycpO1xyXG4gICAgICAgIHJlZ2lzdGVyQmFua0luZm8/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFVc2RGdW5kID0gbmV3IEFVU0RGdW5kKCk7XHJcbiAgICAgICAgICAgIGFVc2RGdW5kLnNob3coKTtcclxuICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgbGV0IHJlcXVlc3RGYWtlQVVTRCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXF1ZXN0RmFrZUFVU0QnKTtcclxuICAgICAgICByZXF1ZXN0RmFrZUFVU0Q/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0RmFrZUFVU0QhLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBmdW5kaW5nU2VydmljZSA9IG5ldyBGdW5kaW5nU2VydmljZSgpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZnVuZGluZ1NlcnZpY2UucmVxdWVzdEZha2VGdW5kaW5nKClcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcldoaWxlRnVuZGluZyh7fSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZ1bmRpbmdFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmdW5kaW5nRXJyb3InKTtcclxuICAgICAgICAgICAgICAgIGlmIChmdW5kaW5nRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RmFrZUFVU0QhLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1idXN5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuZGluZ0Vycm9yLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmRpbmdFcnJvci5pbm5lckhUTUwgPSByZXN1bHQubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuZGluZ0Vycm9yIS5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKVxyXG4gICAgICAgICAgICAgICAgICAgIH0sIDEwICogMTAwMClcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJlZm9yZUZ1bmRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmVmb3JlRnVuZGluZycpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGFmdGVyRnVuZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZnRlckZ1bmRpbmcnKTtcclxuICAgICAgICAgICAgICAgIGlmICghYmVmb3JlRnVuZGluZyB8fCAhYWZ0ZXJGdW5kaW5nKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkQVVTREJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGJlZm9yZUZ1bmRpbmcuY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XHJcbiAgICAgICAgICAgICAgICBhZnRlckZ1bmRpbmcuY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yV2hpbGVGdW5kaW5nKHJlc3VsdCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vY2FsbGJhY2soKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgbG9hZEFVU0RCYWxhbmNlKCkge1xyXG4gICAgICAgIGxldCBjdXJyZW50QVVTREJhbGFuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudEFVU0RCYWxhbmNlJylcclxuICAgICAgICBpZiAoIWN1cnJlbnRBVVNEQmFsYW5jZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgYVVTRFNlcnZpY2UgPSBuZXcgQVVTRFNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgZXRoQWRkcmVzcyA9IHVzZXJTZXJ2aWNlLmdldEV0aEFkZHJlc3MoKTtcclxuXHJcbiAgICAgICAgbGV0IGFtb3VudCA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcbiAgICAgICAgaWYgKGV0aEFkZHJlc3MpIHtcclxuICAgICAgICAgICAgQVVTRFNlcnZpY2UubGFzdFVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgYW1vdW50ID0gYXdhaXQgYVVTRFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZihldGhBZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEFVU0RCYWxhbmNlLmlubmVySFRNTCA9ICckJyArIHJvdW5kQmlnTnVtYmVyKGFtb3VudCkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhbGFuY2UuZXEoLTEpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhbGFuY2UgPSBhbW91bnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmFsYW5jZS5lcShhbW91bnQpKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkQVVTREJhbGFuY2UoKTtcclxuICAgICAgICAgICAgfSwgNSAqIDEwMDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzaG93Q29weUZpZWxkKCkge1xyXG5cclxuICAgICAgICBsZXQgbmVlZFRvQ29weSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZWVkVG9Db3B5Jyk7XHJcbiAgICAgICAgaWYgKCFuZWVkVG9Db3B5KSByZXR1cm47XHJcblxyXG4gICAgICAgIG5lZWRUb0NvcHkuY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBlcnJvcldoaWxlRnVuZGluZyhyZXN1bHQ6IGFueSkge1xyXG4gICAgICAgIGxldCBiZWZvcmVGdW5kaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JlZm9yZUZ1bmRpbmcnKTtcclxuICAgICAgICBsZXQgZXJyb3JBZnRlckZ1bmRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JBZnRlclRyeUZ1bmRpbmcnKTtcclxuICAgICAgICBpZiAoIWJlZm9yZUZ1bmRpbmcgfHwgIWVycm9yQWZ0ZXJGdW5kaW5nKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQubWVzc2FnZSkge1xyXG4gICAgICAgICAgICBlcnJvckFmdGVyRnVuZGluZy5pbm5lckhUTUwgPSByZXN1bHQubWVzc2FnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmVmb3JlRnVuZGluZy5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcclxuICAgICAgICBlcnJvckFmdGVyRnVuZGluZy5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBpZD1cXFwid2l0aGRyYXdJbnB1dFxcXCI+XFxyXFxuXFxyXFxuICAgIHt7I2lmIGJhbmsuYmFua19jb2RlX3R5cGV9fVxcclxcbiAgICBZb3VyIG1vbmV5IHdpbGwgYmUgc2VudCB0byB7e2JhbmsubmFtZX19IHRvIGFjY291bnQgbnVtYmVyIHt7YmFuay5hY2NvdW50X251bWJlcn19LlxcclxcbiAgICA8YnIvPjxici8+XFxyXFxuICAgIE91dGdvaW5nIEludGVybmF0aW9uYWwgV2lyZSBUcmFuc2ZlcnMgY29zdCBpcyAke3t0cmFuc2ZlckNvc3R9fS48YnIvPlxcclxcbiAgICBGZWVzIHdpbGwgYmUgZGVkdWN0ZWQgZnJvbSB0aGUgYW1vdW50LlxcclxcbiAgICB7ey9pZn19XFxyXFxuICAgIHt7I3VubGVzcyBiYW5rLmJhbmtfY29kZV90eXBlfX1cXHJcXG4gICAgWW91ciBtb25leSB3aWxsIGJlIHNlbnQgdG8gYWNjb3VudCBudW1iZXIge3tiYW5rLmJhbmtfYWNjb3VudF9udW1iZXJ9fS5cXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICBBQ0ggdHJhbnNmZXIgY29zdHMgaXMgJHt7dHJhbnNmZXJDb3N0fX0uIEZlZXMgd2lsbCBiZSBkZWR1Y3RlZCBmcm9tIHRoZSBhbW91bnQuXFxyXFxuICAgIHt7L3VubGVzc319XFxyXFxuICAgIDxmb3JtIGlkPVxcXCJ3aXRoZHJhd0Zvcm1cXFwiPlxcclxcbiAgICAgICAgPGxhYmVsPkFtb3VudCB0byB3aXRoZHJhd1xcclxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZWxcXFwiIG5hbWU9XFxcImFtb3VudFxcXCIgaWQ9XFxcImFtb3VudFxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwid2l0aGRyYXdBbW91bnRFcnJvclxcXCI+VGhlIGFtb3VudCBpcyBsb3dlciB0aGFuIHRoZSBjb3N0IG9mIHRyYW5zZmVyPC9kaXY+XFxyXFxuICAgICAgICA8YnV0dG9uIGlkPVxcXCJjb25maXJtV2l0aGRyYXdcXFwiPkNvbmZpcm0gd2l0aGRyYXc8L2J1dHRvbj5cXHJcXG4gICAgPC9mb3JtPlxcclxcbiAgICB7e3tUcmFuc2ZlcnN9fX1cXHJcXG48L2ZpZWxkc2V0PlxcclxcblxcclxcbjxmaWVsZHNldCBpZD1cXFwid2l0aGRyYXdDb25maXJtXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXHJcXG4gICAgWW91IGFyZSBhYm91dCB0byB3aXRoZHJhdyAkPHNwYW4gaWQ9XFxcIndpdGhkcmF3QW1vdW50VGV4dFxcXCI+PC9zcGFuPiBmcm9tIHlvdXIgYWNjb3VudFxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ3YXJuaW5nQmFyXFxcIj5cXHJcXG4gICAgICAgIFdhcm5pbmc6IFRoZSBmZWUgb2YgdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGJlICQ8c3BhbiBpZD1cXFwiZmVlV2FybmluZ1xcXCI+PC9zcGFuPlxcclxcbiAgICAgICAgYW5kIGlzIDxzcGFuIGlkPVxcXCJmZWVQZXJjZW50YWdlXFxcIj48L3NwYW4+JSBvZiB0aGUgYW1vdW50LlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJ3aXRoZHJhd0Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgPGJ1dHRvbiBpZD1cXFwiY29uZmlybVdpdGhkcmF3QnV0dG9uXFxcIj5FeGVjdXRlIHRyYW5zZmVyPC9idXR0b24+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IFdpdGhkcmF3TW9kYWxIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9XaXRoZHJhd01vZGFsLmh0bWwnXHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vTW9kYWxcIjtcclxuaW1wb3J0IEFVU0RTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0FVU0RTZXJ2aWNlXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQge0JhbmtSZWxhdGlvbnNoaXB9IGZyb20gXCIuLi8uLi8uLi9kdG8vYWxwYWNhL0JhbmtSZWxhdGlvbnNoaXBcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IHtpc0pTT04sIHJvdW5kTnVtYmVyfSBmcm9tIFwiLi4vLi4vLi4vdXRpbC9IZWxwZXJcIjtcclxuaW1wb3J0IFRyYW5zZmVyc0xpc3QgZnJvbSBcIi4vVHJhbnNmZXJzTGlzdFwiO1xyXG5pbXBvcnQge1RyYW5zZmVyRGlyZWN0aW9uRW51bX0gZnJvbSBcIi4uLy4uLy4uL2VudW1zL1RyYW5zZmVyRGlyZWN0aW9uRW51bVwiO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdpdGhkcmF3TW9kYWwge1xyXG5cclxuICAgIHByaXZhdGUgdXNlclNlcnZpY2U6IFVzZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBiYW5rSW5mbz86IEJhbmtSZWxhdGlvbnNoaXA7XHJcbiAgICBwcml2YXRlIHdpcmVUcmFuc2ZlckNvc3QgPSA1MDtcclxuICAgIHByaXZhdGUgYWNoVHJhbnNmZXJDb3N0ID0gMjU7XHJcbiAgICBwcml2YXRlIHRyYW5zZmVyQ29zdDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50QmFsYW5jZT86IEJpZ051bWJlcjtcclxuICAgIHByaXZhdGUgdHJhbnNmZXJzTGlzdDogVHJhbnNmZXJzTGlzdDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgdGhpcy50cmFuc2ZlckNvc3QgPSB0aGlzLndpcmVUcmFuc2ZlckNvc3Q7XHJcblxyXG4gICAgICAgIHRoaXMudHJhbnNmZXJzTGlzdCA9IG5ldyBUcmFuc2ZlcnNMaXN0KClcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvdygpIHtcclxuICAgICAgICBsZXQgbW9kYWwgPSBuZXcgTW9kYWwoKTtcclxuICAgICAgICBsZXQgYmFua1JlbGF0aW9uc2hpcHMgPSBhd2FpdCB0aGlzLnVzZXJTZXJ2aWNlLmdldEJhbmtSZWxhdGlvbnNoaXAoKTtcclxuICAgICAgICBpZiAoIWJhbmtSZWxhdGlvbnNoaXBzKSB7XHJcbiAgICAgICAgICAgIG1vZGFsLnNob3dNb2RhbCgnV2l0aGRyYXcgaW5mb3JtYXRpb24nLCBcIllvdSBoYXZlbid0IHNldHVwIGJhbmsgY29ubmVjdGlvbi4gWW91IGNhbm5vdCB3aXRoZHJhdyBmcm9tIHdpdGhvdXQgYmFuayBjb25uZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdHJhbnNmZXJzID0gYXdhaXQgdGhpcy51c2VyU2VydmljZS5nZXRMYXRlc3RUcmFuc2ZlcnMoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLk91dGdvaW5nKVxyXG4gICAgICAgIGxldCB0cmFuc2ZlcnNIdG1sID0gYXdhaXQgdGhpcy50cmFuc2ZlcnNMaXN0LnJlbmRlcihUcmFuc2ZlckRpcmVjdGlvbkVudW0uT3V0Z29pbmcsIHRyYW5zZmVycyk7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSB0aGlzLnVzZXJTZXJ2aWNlLmdldEV0aEFkZHJlc3MoKTtcclxuXHJcbiAgICAgICAgbGV0IGF1c2RTZXJ2aWNlID0gbmV3IEFVU0RTZXJ2aWNlKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50QmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcbiAgICAgICAgaWYgKGV0aEFkZHJlc3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFsYW5jZSA9IGF3YWl0IGF1c2RTZXJ2aWNlLmdldEFVU0RCYWxhbmNlT2YoZXRoQWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50QmFsYW5jZS5lcSgwKSkge1xyXG4gICAgICAgICAgICBsZXQgdG1wID0gSGFuZGxlYmFycy5jb21waWxlKFwiWW91ciBjdXJyZW50IGJhbGFuY2UgaXMgJDAuIFRoZXJlIGlzIG5vdGhpbmcgdG8gd2l0aGRyYXcuIHt7e3RyYW5zZmVyc319fVwiKTtcclxuICAgICAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdXaXRoZHJhdyBpbmZvcm1hdGlvbicsIHRtcCh7dHJhbnNmZXJzOiB0cmFuc2ZlcnNIdG1sfSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB3aXRoZHJhd1RlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFdpdGhkcmF3TW9kYWxIdG1sKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYW5rSW5mbyA9IGJhbmtSZWxhdGlvbnNoaXBzO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJDb3N0ID0gKHRoaXMuYmFua0luZm8uYmFua19jb2RlX3R5cGUpID8gdGhpcy53aXJlVHJhbnNmZXJDb3N0IDogdGhpcy5hY2hUcmFuc2ZlckNvc3Q7XHJcblxyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgYW1vdW50OiB0aGlzLmN1cnJlbnRCYWxhbmNlLFxyXG4gICAgICAgICAgICB0cmFuc2ZlckNvc3Q6IHRoaXMudHJhbnNmZXJDb3N0LFxyXG4gICAgICAgICAgICBUcmFuc2ZlcnM6IHRyYW5zZmVyc0h0bWwsXHJcbiAgICAgICAgICAgIGJhbms6IHRoaXMuYmFua0luZm8hXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdXaXRoZHJhdyBpbmZvcm1hdGlvbicsIHdpdGhkcmF3VGVtcGxhdGUob2JqKSk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJzTGlzdC5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBjb25maXJtV2l0aGRyYXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZmlybVdpdGhkcmF3Jyk7XHJcbiAgICAgICAgY29uZmlybVdpdGhkcmF3Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5iYW5rSW5mbykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFtb3VudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbW91bnQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkoYW1vdW50LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgYW1vdW50LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KGFtb3VudC52YWx1ZSkgPD0gdGhpcy50cmFuc2ZlckNvc3QpIHtcclxuICAgICAgICAgICAgICAgIGxldCB3aXRoZHJhd0Ftb3VudEVycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpdGhkcmF3QW1vdW50RXJyb3InKTtcclxuICAgICAgICAgICAgICAgIHdpdGhkcmF3QW1vdW50RXJyb3IhLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgYW1vdW50LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhbW91bnQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5zaG93V2l0aGRyYXdDb25maXJtYXRpb24oKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2hvd1dpdGhkcmF3Q29uZmlybWF0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5iYW5rSW5mbykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgYW1vdW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Ftb3VudCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGxldCB3aXRoZHJhd0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpdGhkcmF3SW5wdXQnKTtcclxuICAgICAgICB3aXRoZHJhd0lucHV0Py5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuXHJcbiAgICAgICAgbGV0IHdpdGhkcmF3Q29uZmlybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aXRoZHJhd0NvbmZpcm0nKTtcclxuICAgICAgICB3aXRoZHJhd0NvbmZpcm0/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcblxyXG4gICAgICAgIGxldCB3aXRoZHJhd0Ftb3VudFRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2l0aGRyYXdBbW91bnRUZXh0Jyk7XHJcbiAgICAgICAgbGV0IGZlZVdhcm5pbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmVlV2FybmluZycpO1xyXG4gICAgICAgIGxldCBmZWVQZXJjZW50YWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZlZVBlcmNlbnRhZ2UnKTtcclxuXHJcbiAgICAgICAgd2l0aGRyYXdBbW91bnRUZXh0IS5pbm5lclRleHQgPSBhbW91bnQudmFsdWU7XHJcbiAgICAgICAgZmVlV2FybmluZyEuaW5uZXJUZXh0ID0gdGhpcy50cmFuc2ZlckNvc3QudG9TdHJpbmcoKTtcclxuICAgICAgICBmZWVQZXJjZW50YWdlIS5pbm5lclRleHQgPSByb3VuZE51bWJlcigodGhpcy50cmFuc2ZlckNvc3QgLyBwYXJzZUZsb2F0KGFtb3VudC52YWx1ZSkpICogMTAwKS50b1N0cmluZygpO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IGNvbmZpcm1XaXRoZHJhd0J1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25maXJtV2l0aGRyYXdCdXR0b24nKTtcclxuICAgICAgICBjb25maXJtV2l0aGRyYXdCdXR0b24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlclNlcnZpY2UuY3JlYXRlVHJhbnNmZXIoYW1vdW50LnZhbHVlLCBUcmFuc2ZlckRpcmVjdGlvbkVudW0uT3V0Z29pbmcpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmZXJzID0gYXdhaXQgdGhpcy51c2VyU2VydmljZS5nZXRMYXRlc3RUcmFuc2ZlcnMoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLk91dGdvaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB3aXRoZHJhd0NvbmZpcm0hLmlubmVySFRNTCA9IGF3YWl0IHRoaXMudHJhbnNmZXJzTGlzdC5yZW5kZXIoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLk91dGdvaW5nLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmZXJzTGlzdC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHdpdGhkcmF3RXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2l0aGRyYXdFcnJvcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2l0aGRyYXdFcnJvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAod2l0aGRyYXdFcnJvciAmJiBpc0pTT04ocmVhc29uLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvciA9IEpTT04ucGFyc2UocmVhc29uLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aXRoZHJhd0Vycm9yLmlubmVyVGV4dCA9IGVycm9yLnNlcnZlckVycm9yLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGRyYXdFcnJvci5pbm5lclRleHQgPSByZWFzb24udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHdpdGhkcmF3RXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxufSIsImltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQge3JvdW5kQmlnTnVtYmVyfSBmcm9tIFwiLi4vLi4vdXRpbC9IZWxwZXJcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgRmFrZUFVU0RGdW5kIGZyb20gXCIuLi9tb2RhbHMvRnVuZGluZy9GYWtlQVVTREZ1bmRcIjtcclxuaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9tb2RhbHMvRnVuZGluZy9BVVNERnVuZFwiO1xyXG5pbXBvcnQgV2l0aGRyYXdNb2RhbCBmcm9tIFwiLi4vbW9kYWxzL0Z1bmRpbmcvV2l0aGRyYXdNb2RhbFwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9XYWxsZXRIZWxwZXJcIjtcclxuaW1wb3J0IENvbnRyYWN0SW5mbyBmcm9tIFwiLi4vLi4vY29udHJhY3RzL0NvbnRyYWN0SW5mb1wiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL21vZGFscy9Nb2RhbFwiO1xyXG5pbXBvcnQgQWRkVG9XYWxsZXRIdG1sIGZyb20gJy4uLy4uL2h0bWwvZWxlbWVudHMvQWRkVG9XYWxsZXQuaHRtbCc7XHJcbmltcG9ydCBVc2VyIGZyb20gXCIuLi8uLi9kdG8vVXNlclwiO1xyXG5pbXBvcnQgQXBwIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFVc2RCYWxhbmNlIHtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZm9yY2VMb2FkQVVTREJhbGFuY2VVSSgpIHtcclxuICAgICAgICBsZXQgdWkgPSBuZXcgQVVzZEJhbGFuY2UoKVxyXG4gICAgICAgIEFVU0RTZXJ2aWNlLmxhc3RVcGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgYXdhaXQgdWkubG9hZEFVU0RCYWxhbmNlVUkoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZEFVU0RCYWxhbmNlVUkoKSB7XHJcbiAgICAgICAgaWYgKCFBcHAuVXNlci5ldGhlcikge1xyXG4gICAgICAgICAgICBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjMoKTtcclxuICAgICAgICAgICAgaWYgKCFBcHAuVXNlci5ldGhlcikgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHVzZXJJbmZvQVVzZEJhbGFuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlckluZm9BVXNkQmFsYW5jZScpO1xyXG4gICAgICAgIGxldCBmcm9udHBhZ2VBVXNkQmFsYW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcm9udHBhZ2VBVXNkQmFsYW5jZScpO1xyXG5cclxuICAgICAgICBpZiAoIUFwcC5Vc2VyLmFscGFjYUlkKSB7XHJcbiAgICAgICAgICAgIGZyb250cGFnZUFVc2RCYWxhbmNlPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgdXNlckluZm9BVXNkQmFsYW5jZT8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIC8vcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZyb250cGFnZUFVc2RCYWxhbmNlPy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgdXNlckluZm9BVXNkQmFsYW5jZT8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYVVTRFNlcnZpY2UgPSBuZXcgQVVTRFNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgYVVzZFZhbHVlV2VpID0gYXdhaXQgYVVTRFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZihBcHAuVXNlci5hZGRyZXNzKTtcclxuICAgICAgICBsZXQgYVVzZFZhbHVlID0gcm91bmRCaWdOdW1iZXIoYVVzZFZhbHVlV2VpKTtcclxuXHJcbiAgICAgICAgbGV0IGZyb250cGFnZUFVU0RCYWxhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zyb250X3BhZ2VfYVVTRF9iYWxhbmNlJyk7XHJcbiAgICAgICAgaWYgKGZyb250cGFnZUFVU0RCYWxhbmNlKSBmcm9udHBhZ2VBVVNEQmFsYW5jZS5pbm5lckhUTUwgPSAnJCcgKyBhVXNkVmFsdWU7XHJcblxyXG4gICAgICAgIGxldCB1c2VyX2luZm9fYXVzZF9iYWxhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXJfaW5mb19hdXNkX2JhbGFuY2UnKVxyXG4gICAgICAgIGlmICh1c2VyX2luZm9fYXVzZF9iYWxhbmNlKSB1c2VyX2luZm9fYXVzZF9iYWxhbmNlLmlubmVySFRNTCA9ICckJyArIGFVc2RWYWx1ZTtcclxuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuXHJcbiAgICAgICAgbGV0IGJhbGFuY2VfdmFsdWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYmFsYW5jZV92YWx1ZScpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmIChiYWxhbmNlX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgIGJhbGFuY2VfdmFsdWUuaW5uZXJIVE1MID0gJyQnICsgYVVzZFZhbHVlLnRvRml4ZWQoKTtcclxuICAgICAgICAgICAgYmFsYW5jZV92YWx1ZS50aXRsZSA9IGFVc2RWYWx1ZVdlaS50b0ZpeGVkKCk7XHJcbiAgICAgICAgICAgIGJhbGFuY2VfdmFsdWUuZGF0YXNldFsndG9vbHRpcCddID0gYVVzZFZhbHVlV2VpLnRvRml4ZWQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChhVXNkVmFsdWUuaXNMZXNzVGhhbigxMCkpIHtcclxuICAgICAgICAgICAgbGV0IGZyb250cGFnZV9mdW5kX2FjY291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJvbnRwYWdlX2Z1bmRfYWNjb3VudCcpO1xyXG4gICAgICAgICAgICBmcm9udHBhZ2VfZnVuZF9hY2NvdW50Py5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IEFwcC5OZXR3b3JrO1xyXG4gICAgICAgIGxldCBhZGRfYVVTRF90b193YWxsZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWRkX2FVU0RfdG9fd2FsbGV0Jyk7XHJcbiAgICAgICAgYWRkX2FVU0RfdG9fd2FsbGV0LmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbyhuZXR3b3JrSW5mby5OYW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB3YWxsZXRIZWxwZXIuYWRkVG9rZW5Ub1dhbGxldChjb250cmFjdEluZm8uQVVTRF9BRERSRVNTLCAnYVVTRCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoQWRkVG9XYWxsZXRIdG1sKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2JqID0ge3N5bWJvbDogJ2FVU0QnLCBhZGRyZXNzOiBjb250cmFjdEluZm8uQVVTRF9BRERSRVNTfTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbW9kYWwgPSBuZXcgTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ0FkZCBhVVNEIHRva2VuJywgdGVtcGxhdGUob2JqKSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgbGV0IGZ1bmRfYWNjb3VudEJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZnVuZF9hY2NvdW50Jyk7XHJcbiAgICAgICAgZnVuZF9hY2NvdW50QnV0dG9ucy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYVVTREZ1bmRpbmdNb2RhbCA9IG5ldyBGYWtlQVVTREZ1bmQoKTtcclxuICAgICAgICAgICAgaWYgKG5ldHdvcmtJbmZvLlRlc3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICdDbGljayBmb3Igc29tZSBhVVNEJztcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYVVTREZ1bmRpbmdNb2RhbC5zaG93QVVTREZha2VGdW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFVc2RGdW5kID0gbmV3IEFVU0RGdW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYVVzZEZ1bmQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCB3aXRoZHJhd19mcm9tX2FjY291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2l0aGRyYXdfZnJvbV9hY2NvdW50Jyk7XHJcbiAgICAgICAgd2l0aGRyYXdfZnJvbV9hY2NvdW50Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgd2l0aGRyYXdNb2RhbCA9IG5ldyBXaXRoZHJhd01vZGFsKCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHdpdGhkcmF3TW9kYWwuc2hvdygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxkaXYgY2xhc3M9XFxcImVycm9yQmFyXFxcIj5Zb3UgYXJlIHJ1bm5pbmcgb24gdGVzdG5ldC4gTm8gcmVhbCB0cmFkZXMgd2lsbCBiZSBleGVjdXRlZC4gPGEgaHJlZj1cXFwiI1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVxcXCJzd2l0Y2hfZnJvbV90ZXN0X25ldHdvcmtcXFwiPlN3aXRjaFxcclxcbiAgICB0byBtYWlubmV0PC9hPjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IFVzZXJJbmZvRWxlbWVudCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL1VzZXJJbmZvLmh0bWwnXHJcbmltcG9ydCB7c2hvcnRFdGh9IGZyb20gXCIuLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgUHJvdmlkZXJJbmZvIGZyb20gXCIuLi8uLi93YWxsZXQvUHJvdmlkZXJJbmZvXCI7XHJcbmltcG9ydCBLeWNFZGl0TmFtZUZvcm0gZnJvbSBcIi4uL21vZGFscy9LWUMvS3ljRWRpdE5hbWVGb3JtXCI7XHJcbmltcG9ydCBLeWNFZGl0Q29udGFjdEZvcm0gZnJvbSBcIi4uL21vZGFscy9LWUMvS3ljRWRpdENvbnRhY3RGb3JtXCI7XHJcbmltcG9ydCBLeWNFZGl0VHJ1c3RlZENvbnRhY3QgZnJvbSBcIi4uL21vZGFscy9LWUMvS3ljRWRpdFRydXN0ZWRDb250YWN0XCI7XHJcbmltcG9ydCBBVXNkQmFsYW5jZSBmcm9tIFwiLi9BVXNkQmFsYW5jZVwiO1xyXG5pbXBvcnQgVGVzdE5ldHdvcmtCYW5uZXJIdG1sIGZyb20gXCIuLi8uLi9odG1sL2VsZW1lbnRzL1Rlc3ROZXR3b3JrQmFubmVyLmh0bWxcIjtcclxuaW1wb3J0IFN3aXRjaE5ldHdvcmtNb2RhbCBmcm9tIFwiLi4vbW9kYWxzL1N3aXRjaE5ldHdvcmtNb2RhbFwiO1xyXG5pbXBvcnQgRXhlY3V0ZU9yZGVyQnV0dG9uIGZyb20gXCIuL3RyYWRlcGFuZWwvRXhlY3V0ZU9yZGVyQnV0dG9uXCI7XHJcbmltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi8uLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9XYWxsZXRIZWxwZXJcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQgQXV0aGVudGljYXRlU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9BdXRoZW50aWNhdGVTZXJ2aWNlXCI7XHJcblxyXG50eXBlIExpc3RlbmVyQWN0aW9uID0gKC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVc2VySW5mbyB7XHJcbiAgICBhdXRoZW50aWNhdGlvblNlcnZpY2U6IEF1dGhlbnRpY2F0ZVNlcnZpY2U7XHJcbiAgICB1c2VyU2VydmljZTogVXNlclNlcnZpY2U7XHJcbiAgICBwcm92aWRlckluZm86IFByb3ZpZGVySW5mbztcclxuICAgIHdhbGxldEhlbHBlcjogV2FsbGV0SGVscGVyO1xyXG4gICAgd2FsbGV0TG9hZGVkID0gZmFsc2U7XHJcbiAgICBzdGF0aWMgb25Vc2VyTG9nZ2VkSW46IEFycmF5PExpc3RlbmVyQWN0aW9uPiA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcm92aWRlckluZm86IFByb3ZpZGVySW5mbykge1xyXG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25TZXJ2aWNlID0gbmV3IEF1dGhlbnRpY2F0ZVNlcnZpY2UoKTtcclxuICAgICAgICB0aGlzLnVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlckluZm8gPSBwcm92aWRlckluZm87XHJcbiAgICAgICAgdGhpcy53YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHJlbmRlcihlbGVtZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCB1c2VyX2hlYWRlcl9pbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXJfaGVhZGVyX2luZm8nKTtcclxuICAgICAgICBpZiAodXNlcl9oZWFkZXJfaW5mbykgdXNlcl9oZWFkZXJfaW5mby5pbm5lckhUTUwgPSAnTG9hZGluZyB3YWxsZXQuLic7XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKHVzZXJfaGVhZGVyX2luZm8pO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbkZvcldhbGxldENoYW5nZXMoKTtcclxuICAgICAgICB0aGlzLmxvYWRVc2VyTWVudVVJKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkSWZUZXN0TmV0d29yaygpO1xyXG4gICAgICAgIHRoaXMuaWZUcmFkZVBhZ2UoKTtcclxuXHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcblxyXG4gICAgICAgIGxldCBhVXNkQmFsYW5jZSA9IG5ldyBBVXNkQmFsYW5jZSgpO1xyXG4gICAgICAgIGF3YWl0IGFVc2RCYWxhbmNlLmxvYWRBVVNEQmFsYW5jZVVJKCk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxpc3RlbkZvcldhbGxldENoYW5nZXMoKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICBUT0RPOiBuZWVkIGZpeGluZ1xyXG4gICAgICAgIHRoaXMubW9yYWxpcy5vbkNoYWluQ2hhbmdlZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubW9yYWxpcy5vbkFjY291bnRDaGFuZ2VkKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzLm9uRGlzY29ubmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubW9yYWxpcy5vbkNvbm5lY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBsb2FkVXNlck1lbnVVSShlbGVtZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCB1c2VySW5mb0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgaWYgKCF1c2VySW5mb0RpdikgcmV0dXJuO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdsb2FkVXNlck1lbnVVSSBVc2VyOicsIEFwcC5Vc2VyKTtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBBcHAuTmV0d29yaztcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIGV0aEFkZHJlc3M6IEFwcC5Vc2VyLmFkZHJlc3MsXHJcbiAgICAgICAgICAgIHNob3J0RXRoQWRkcmVzczogc2hvcnRFdGgoQXBwLlVzZXIuYWRkcmVzcyksXHJcbiAgICAgICAgICAgIHdhbGxldE5hbWU6IHRoaXMucHJvdmlkZXJJbmZvLldhbGxldE5hbWUsXHJcbiAgICAgICAgICAgIG5ldHdvcmtOYW1lOiBuZXR3b3JrSW5mby5DaGFpbk5hbWUgKyAoKG5ldHdvcmtJbmZvLlRlc3ROZXR3b3JrKSA/ICcgLSAoVGVzdCBuZXR3b3JrKScgOiAnJyksXHJcbiAgICAgICAgICAgIGJsb2NrY2hhaW5FeHBsb3JlcjogbmV0d29ya0luZm8uQmxvY2tFeHBsb3JlciArICcvYWRkcmVzcy8nLFxyXG4gICAgICAgICAgICBpc01hZ2ljOiBhd2FpdCB0aGlzLndhbGxldEhlbHBlci5pc01hZ2ljKCksXHJcbiAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmtJbmZvLkNoYWluSWRcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShVc2VySW5mb0VsZW1lbnQpO1xyXG4gICAgICAgIGxldCBodG1sID0gdGVtcGxhdGUob2JqKTtcclxuXHJcbiAgICAgICAgdXNlckluZm9EaXYuaW5uZXJIVE1MID0gaHRtbDtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5iaW5kVXNlckFjdGlvbkV2ZW50cygpO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFVzZXJJbmZvLm9uVXNlckxvZ2dlZEluLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIFVzZXJJbmZvLm9uVXNlckxvZ2dlZEluW2ldKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYmluZFVzZXJBY3Rpb25FdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IGVkaXROYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXROYW1lJyk7XHJcbiAgICAgICAgZWRpdE5hbWU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBreWNNb2RhbCA9IG5ldyBLeWNFZGl0TmFtZUZvcm0oKTtcclxuICAgICAgICAgICAgYXdhaXQga3ljTW9kYWwuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBlZGl0Q29udGFjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0Q29udGFjdCcpO1xyXG4gICAgICAgIGVkaXRDb250YWN0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGxldCBreWNNb2RhbCA9IG5ldyBLeWNFZGl0Q29udGFjdEZvcm0oKTtcclxuICAgICAgICAgICAgYXdhaXQga3ljTW9kYWwuc2hvdygpO1xyXG5cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgZWRpdFRydXN0ZWRDb250YWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkaXRUcnVzdGVkQ29udGFjdCcpO1xyXG4gICAgICAgIGVkaXRUcnVzdGVkQ29udGFjdD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBsZXQga3ljTW9kYWwgPSBuZXcgS3ljRWRpdFRydXN0ZWRDb250YWN0KCk7XHJcbiAgICAgICAgICAgIGF3YWl0IGt5Y01vZGFsLnNob3coKTtcclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IHVzZXJJbmZvRHJvcGRvd24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlckluZm9Ecm9wZG93bicpO1xyXG4gICAgICAgIGlmICghdXNlckluZm9Ecm9wZG93bikgcmV0dXJuO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodXNlckluZm9Ecm9wZG93biAmJiAhdXNlckluZm9Ecm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoJ2Qtbm9uZScpKSB7XHJcbiAgICAgICAgICAgICAgICB1c2VySW5mb0Ryb3Bkb3duLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgbGV0IHVzZXJJbmZvQWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXJJbmZvQWN0aW9uJyk7XHJcbiAgICAgICAgdXNlckluZm9BY3Rpb24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgdXNlckluZm9Ecm9wZG93bj8uY2xhc3NMaXN0LnRvZ2dsZSgnZC1ub25lJyk7XHJcbiAgICAgICAgICAgIHVzZXJJbmZvRHJvcGRvd24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgV2FsbGV0SGVscGVyLmhpZGVNYWdpY1dhbGxldCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgZGlzY29ubmVjdEZyb21OZXR3b3JrID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc2Nvbm5lY3RGcm9tTmV0d29yaycpO1xyXG4gICAgICAgIGRpc2Nvbm5lY3RGcm9tTmV0d29yaz8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGlvblNlcnZpY2UubG9nT3V0KClcclxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgd2FsbGV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhbGxldCcpO1xyXG5cclxuICAgICAgICB3YWxsZXQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMud2FsbGV0TG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFnaWNJZnJhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFnaWMtaWZyYW1lJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFnaWNJZnJhbWUpIG1hZ2ljSWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXHJcbiAgICAgICAgICAgICAgICBMb2FkaW5nSGVscGVyLnJlbW92ZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIHVzZXJJbmZvRHJvcGRvd24/LmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBBcHAuVXNlci5wcm92aWRlci5tYWdpYy5jb25uZWN0LnNob3dXYWxsZXQoKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGFzeW5jIChlOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldExvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UuaW5kZXhPZignVXNlciBkZW5pZWQgYWNjb3VudCBhY2Nlc3MnKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmF1dGhlbnRpY2F0aW9uU2VydmljZS5sb2dPdXQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydCgnWW91IGhhdmUgYmVlbiBsb2dnZWQgb3V0IG9mIHlvdSB3YWxsZXQgYW5kIG5lZWQgdG8gbG9nIGJhY2sgaW4uIFdlIHdpbGwgbm93IHJlbG9hZCB0aGUgcGFnZSBhbmQgeW91IGNhbiBsb2cgaW4uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjbG9zZU1lbnVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBtYWdpY0lmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWdpYy1pZnJhbWUnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghbWFnaWNJZnJhbWUpIGNsZWFySW50ZXJ2YWwoY2xvc2VNZW51SW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYWdpY0lmcmFtZSAmJiBtYWdpY0lmcmFtZS5zdHlsZS5kaXNwbGF5ID09ICdibG9jaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2FkaW5nSGVscGVyLnJlbW92ZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB1c2VySW5mb0Ryb3Bkb3duPy5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldExvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjbG9zZU1lbnVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMDApO1xyXG5cclxuXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGxldCBzd2l0Y2hfbmV0d29yayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hfbmV0d29yaycpO1xyXG4gICAgICAgIHN3aXRjaF9uZXR3b3JrPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc3dpdGNoTmV0d29ya01vZGFsID0gbmV3IFN3aXRjaE5ldHdvcmtNb2RhbCgpO1xyXG4gICAgICAgICAgICBzd2l0Y2hOZXR3b3JrTW9kYWwuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGxvYWRJZlRlc3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGlmICghQXBwLlVzZXIucHJvdmlkZXIpIHJldHVybjtcclxuICAgICAgICBpZiAoIUFwcC5OZXR3b3JrLlRlc3ROZXR3b3JrKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBoZWFkZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkZXInKTtcclxuICAgICAgICBpZiAoIWhlYWRlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVGVzdE5ldHdvcmtCYW5uZXJIdG1sKVxyXG4gICAgICAgIGhlYWRlci5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWJlZ2luJywgdGVtcGxhdGUoe30pKTtcclxuXHJcbiAgICAgICAgbGV0IHN3aXRjaF9mcm9tX3Rlc3RfbmV0d29yayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hfZnJvbV90ZXN0X25ldHdvcmsnKVxyXG4gICAgICAgIHN3aXRjaF9mcm9tX3Rlc3RfbmV0d29yaz8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzd2l0Y2hOZXR3b3JrTW9kYWwgPSBuZXcgU3dpdGNoTmV0d29ya01vZGFsKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaE5ldHdvcmtNb2RhbC5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGlmVHJhZGVQYWdlKCkge1xyXG4gICAgICAgIGxldCBidG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZScpO1xyXG4gICAgICAgIGlmICghYnRuKSByZXR1cm47XHJcblxyXG4gICAgICAgIEV4ZWN1dGVPcmRlckJ1dHRvbi5JbnN0YW5jZS5yZW5kZXJCdXR0b24oKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YnV0dG9uIGNsYXNzPVxcXCJsaW1pbmFsX21hcmtldF9jb25uZWN0X3dhbGxldCBvdXRsaW5lXFxcIj5Db25uZWN0IHdhbGxldDwvYnV0dG9uPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgVXNlckluZm8gZnJvbSBcIi4uL2VsZW1lbnRzL1VzZXJJbmZvXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IHdhbGxldEJ1dHRvbiBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL0Nvbm5lY3RXYWxsZXRCdXR0b24uaHRtbCc7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi9Nb2RhbFwiO1xyXG5pbXBvcnQgUHJvdmlkZXJJbmZvIGZyb20gXCIuLi8uLi93YWxsZXQvUHJvdmlkZXJJbmZvXCI7XHJcbmltcG9ydCBFcnJvckluZm8gZnJvbSBcIi4uLy4uL2Vycm9ycy9FcnJvckluZm9cIjtcclxuaW1wb3J0IFRyYWRlUGFnZSBmcm9tIFwiLi4vcGFnZXMvVHJhZGVQYWdlXCI7XHJcbmltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi8uLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbm5lY3RXYWxsZXQge1xyXG4gICAgcHVibGljIHN0YXRpYyBQcm92aWRlcjogc3RyaW5nO1xyXG4gICAgcHJvdmlkZXJJbmZvOiBQcm92aWRlckluZm87XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJbmZvID0gbmV3IFByb3ZpZGVySW5mbyhudWxsKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyQnV0dG9uKGVsZW1lbnRJZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpKSByZXR1cm47XHJcblxyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkhLmlubmVySFRNTCA9IHdhbGxldEJ1dHRvbjtcclxuXHJcbiAgICAgICAgbGV0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5saW1pbmFsX21hcmtldF9jb25uZWN0X3dhbGxldFwiKTtcclxuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGFzeW5jIChlbCkgPT4ge1xyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0V2FsbGV0KGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY29ubmVjdFdhbGxldChidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKGJ1dHRvbik7XHJcblxyXG4gICAgICAgIGxldCBhdXRoZW50aWNhdGlvblNlcnZpY2UgPSBuZXcgQXV0aGVudGljYXRlU2VydmljZSgpO1xyXG4gICAgICAgIGF3YWl0IGF1dGhlbnRpY2F0aW9uU2VydmljZS5hdXRoZW50aWNhdGVVc2VyKFxyXG4gICAgICAgICAgICAod2FsbGV0Q29ubmVjdGlvbkluZm86IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy53ZWIzRW5hYmxlZFJlc3VsdCh3YWxsZXRDb25uZWN0aW9uSW5mbyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB1c2VySW5mbyA9IG5ldyBVc2VySW5mbyh0aGlzLnByb3ZpZGVySW5mbyk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB1c2VySW5mby5yZW5kZXIoJ3VzZXJfaGVhZGVyX2luZm8nKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X2V4ZWN1dGVfdHJhZGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWdlID0gbmV3IFRyYWRlUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHBhZ2UubG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgRXJyb3JJbmZvLnJlcG9ydChyZWFzb24pO1xyXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHdlYjNFbmFibGVkUmVzdWx0KHdhbGxldENvbm5lY3Rpb25JbmZvOiBhbnkpIHtcclxuICAgICAgICB0aGlzLnByb3ZpZGVySW5mbyA9IG5ldyBQcm92aWRlckluZm8od2FsbGV0Q29ubmVjdGlvbkluZm8pO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBjbGFzcz1cXFwiY2VudGVyXFxcIj5cXHJcXG4gICAgVGhlIHN0b2NrIG1hcmtldCBpcyBjdXJyZW50bHkgY2xvc2VkLjxici8+XFxyXFxuSXQgaXMgdXN1YWxseSBvcGVuIG1vbmRheSB0byBmcmlkYXkgYmV0d2VlbiA5OjMwIEFNIGFuZCA0OjAwIFBNIEVTVCAoOTozMCAtIDE2OjAwIEVTVCkuXFxyXFxuICAgIDxici8+PGJyLz5cXHJcXG5Ub2RheSBpcyB7e2RheU9mV2Vla319XFxyXFxuPGJyIC8+PGJyLz5cXHJcXG5Zb3VyIGN1cnJlbnQgdGltZSBpcyB7e2N1cnJlbnRUaW1lfX0gKHt7R01UfX0pXFxyXFxuICAgIDxici8+PGJyLz5cXHJcXG5UaGF0IG1lYW5zIHRoZSBtYXJrZXQgaXMgb3BlbiB5b3VyIHRpbWUgYmV0d2Vlblxcclxcbnt7b3BlbkZyb219fSAtIHt7b3BlblRvfX1cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi9HZW5lcmFsRXJyb3JcIjtcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi91aS9tb2RhbHMvTW9kYWxcIjtcclxuaW1wb3J0IE1hcmtldElzQ2xvc2VkSHRtbCBmcm9tIFwiLi4vaHRtbC9tb2RhbC9NYXJrZXRJc0Nsb3NlZC5odG1sXCI7XHJcbmltcG9ydCBEYXRlSGVscGVyIGZyb20gXCIuLi91dGlsL0RhdGVIZWxwZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2NrY2hhaW5FcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XHJcbiAgICBzdGF0aWMgRXJyb3JGcm9tQ29udHJhY3QgPSAtMTtcclxuICAgIHN0YXRpYyBVc2VyQ2FuY2VsbGVkID0gMTtcclxuICAgIHN0YXRpYyBBZGRyZXNzSXNOb3RWYWxpZEtZQyA9IDI7XHJcbiAgICBzdGF0aWMgTWFya2V0SXNDbG9zZWQgPSAzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGUgOiBhbnkpIHtcclxuICAgICAgICBzdXBlcihlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnVzZXJEZW5pZWRUcmFuc2FjdGlvblNpZ25hdHVyZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IEJsb2NrY2hhaW5FcnJvci5Vc2VyQ2FuY2VsbGVkO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5hZGRyZXNzSXNOb3RWYWxpZEtZQygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IEJsb2NrY2hhaW5FcnJvci5BZGRyZXNzSXNOb3RWYWxpZEtZQztcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXJrZXRDbG9zZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBCbG9ja2NoYWluRXJyb3IuTWFya2V0SXNDbG9zZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSB0aGlzLm1hcmtldElzQ2xvc2VkTW9kYWw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGxldCBtc2cgOiBzdHJpbmcgPSBlLmRhdGEubWVzc2FnZTtcclxuICAgICAgICAgICAgbGV0IHNlYXJjaFN0ciA9ICdyZXZlcnRlZCB3aXRoIHJlYXNvbiBzdHJpbmcnO1xyXG4gICAgICAgICAgICBsZXQgaWR4ID0gbXNnLmluZGV4T2Yoc2VhcmNoU3RyKSArIHNlYXJjaFN0ci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChpZHggIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZy5zdWJzdHJpbmcoaWR4KS50cmltKCkucmVwbGFjZSgvJy9nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvZGUgPSBCbG9ja2NoYWluRXJyb3IuRXJyb3JGcm9tQ29udHJhY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVzZXJEZW5pZWRUcmFuc2FjdGlvblNpZ25hdHVyZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlLmluZGV4T2YoJ2RlbmllZCB0cmFuc2FjdGlvbiBzaWduYXR1cmUnKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZHJlc3NJc05vdFZhbGlkS1lDKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UuaW5kZXhPZignYWRkcmVzcyBpcyBub3Qga3ljIHZhbGlkJykgIT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc01hcmtldENsb3NlZCgpIHtcclxuICAgICAgICBsZXQgc2VhcmNoU3RyID0gJ01hcmtldCBpcyBjbG9zZWQnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UuaW5kZXhPZihzZWFyY2hTdHIpICE9PSAtMTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbWFya2V0SXNDbG9zZWRNb2RhbCgpIHtcclxuICAgICAgICBsZXQgW29wZW5Ib3VyLCBjbG9zZUhvdXJdID0gRGF0ZUhlbHBlci5nZXRPcGVuQW5kQ2xvc2VIb3VycygpO1xyXG4gICAgICAgIGxldCB0aW1lID0gbmV3IERhdGUoKS50b1RpbWVTdHJpbmcoKS5zcGxpdCgnICcpO1xyXG4gICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lOiB0aW1lWzBdLFxyXG4gICAgICAgICAgICBHTVQ6IHRpbWVbMV0sXHJcbiAgICAgICAgICAgIGRheU9mV2VlayA6IERhdGVIZWxwZXIuZ2V0V2Vla2RheSgpLFxyXG4gICAgICAgICAgICBvcGVuRnJvbSA6IG9wZW5Ib3VyLFxyXG4gICAgICAgICAgICBvcGVuVG8gOiBjbG9zZUhvdXJcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShNYXJrZXRJc0Nsb3NlZEh0bWwpO1xyXG4gICAgICAgIG1vZGFsLnNob3dNb2RhbCgnTWFya2V0IGlzIGNsb3NlZCcsIHRlbXBsYXRlKG9iaikpXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBCbG9ja2NoYWluRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9CbG9ja2NoYWluRXJyb3JcIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi4vLi4vZXJyb3JzL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgS3ljU3RhdHVzIGZyb20gXCIuLi8uLi9kdG8vS3ljU3RhdHVzXCI7XHJcbmltcG9ydCBBVXNkQmFsYW5jZSBmcm9tIFwiLi4vLi4vdWkvZWxlbWVudHMvQVVzZEJhbGFuY2VcIjtcclxuaW1wb3J0IEJsb2NrY2hhaW5TZXJ2aWNlIGZyb20gXCIuL0Jsb2NrY2hhaW5TZXJ2aWNlXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgQXBwIGZyb20gXCIuLi8uLi9tYWluXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLWUNTZXJ2aWNlIGV4dGVuZHMgQmxvY2tjaGFpblNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgS1lDSW5mbzogYW55O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgS3ljUmVzcG9uc2U6IEt5Y1N0YXR1cztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldEtZQ0FiaSgpIHtcclxuICAgICAgICBpZiAoS1lDU2VydmljZS5LWUNJbmZvKSByZXR1cm4gS1lDU2VydmljZS5LWUNJbmZvLmFiaTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi4uL2FiaS9LWUMuanNvblwiKTtcclxuICAgICAgICBLWUNTZXJ2aWNlLktZQ0luZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIEtZQ1NlcnZpY2UuS1lDSW5mby5hYmk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBoYXNWYWxpZEtZQygpOiBQcm9taXNlPEt5Y1N0YXR1cz4ge1xyXG4gICAgICAgIGlmIChLWUNTZXJ2aWNlLkt5Y1Jlc3BvbnNlICYmIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2UuaXNWYWxpZEt5YykgcmV0dXJuIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2U7XHJcblxyXG4gICAgICAgIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldCgnaXNWYWxpZEt5YycpXHJcbiAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrY2hhaW5FcnJvciA9IG5ldyBCbG9ja2NoYWluRXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja2NoYWluRXJyb3IuYWRkcmVzc0lzTm90VmFsaWRLWUMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEVycm9ySW5mby5yZXBvcnQoYmxvY2tjaGFpbkVycm9yKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KSBhcyBLeWNTdGF0dXM7XHJcblxyXG4gICAgICAgIGlmIChLWUNTZXJ2aWNlLkt5Y1Jlc3BvbnNlLmFscGFjYUlkKSB7XHJcbiAgICAgICAgICAgIEFwcC5Vc2VyLmFscGFjYUlkID0gS1lDU2VydmljZS5LeWNSZXNwb25zZS5hbHBhY2FJZDtcclxuXHJcbiAgICAgICAgICAgIGxldCBhVXNkQmFsYW5jZSA9IG5ldyBBVXNkQmFsYW5jZSgpO1xyXG4gICAgICAgICAgICBhd2FpdCBhVXNkQmFsYW5jZS5sb2FkQVVTREJhbGFuY2VVSSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gS1lDU2VydmljZS5LeWNSZXNwb25zZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2F2ZUtZQ0luZm8oZGF0YTogYW55KTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0KFwia3ljUmVnaXN0cmF0aW9uXCIsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB1cGRhdGVLWUNJbmZvKGRhdGE6IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucG9zdChcInVwZGF0ZUFjY291bnRcIiwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzVmFsaWRBY2NvdW50SWQoc3RyOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC01XVswLTlhLWZdezN9LVswODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn0kJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3Qoc3RyKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyB1cGRhdGVEb2N1bWVudHMocGFyYW1zOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wb3N0KFwia3ljQWN0aW9uUmVxdWlyZWRVcGRhdGVcIiwgcGFyYW1zKTtcclxuICAgIH1cclxufSIsImltcG9ydCBMaW1pbmFsTWFya2V0U2VydmljZSBmcm9tIFwiLi9MaW1pbmFsTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQge0FkZHJlc3NaZXJvfSBmcm9tIFwiLi4vLi4vdXRpbC9IZWxwZXJcIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbmltcG9ydCBCbG9ja2NoYWluU2VydmljZSBmcm9tIFwiLi9CbG9ja2NoYWluU2VydmljZVwiO1xyXG5pbXBvcnQge2V0aGVyc30gZnJvbSBcImV0aGVyc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VjdXJpdHlUb2tlblNlcnZpY2UgZXh0ZW5kcyBCbG9ja2NoYWluU2VydmljZSB7XHJcblxyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIFNlY3VyaXR5VG9rZW5JbmZvOiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFF1YW50aXR5QnlBZGRyZXNzKHN5bWJvbDogc3RyaW5nLCBldGhBZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPEJpZ051bWJlcj4ge1xyXG4gICAgICAgIGxldCBsaW1pbmFsTWFya2V0U2VydmljZSA9IG5ldyBMaW1pbmFsTWFya2V0U2VydmljZSgpO1xyXG4gICAgICAgIGxldCBzeW1ib2xBZGRyZXNzID0gYXdhaXQgbGltaW5hbE1hcmtldFNlcnZpY2UuZ2V0U3ltYm9sQ29udHJhY3RBZGRyZXNzKHN5bWJvbCk7XHJcbiAgICAgICAgaWYgKHN5bWJvbEFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSByZXR1cm4gbmV3IEJpZ051bWJlcigwKTtcclxuXHJcbiAgICAgICAgbGV0IHF0eSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZU9mKHN5bWJvbEFkZHJlc3MsIGV0aEFkZHJlc3MpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGV0aGVycy51dGlscy5mb3JtYXRFdGhlcihxdHkudG9TdHJpbmcoKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB0cmFuc2ZlcihzeW1ib2xBZGRyZXNzOiBzdHJpbmcsIHF0eTogQmlnTnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN1cGVyLnRyYW5zZmVySW5uZXIoc3ltYm9sQWRkcmVzcywgdGhpcy5jb250cmFjdHMuQVVTRF9BRERSRVNTLCBxdHkpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGJ1dHRvbiBpZD1cXFwibGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZVxcXCI+PC9idXR0b24+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIllvdSBuZWVkIHRvIGhhdmUge3tzeW1ib2x9fSBjdXJyZW5jeSBpbiB5b3VyIHdhbGxldC4gWW91IHVzZSB7e3N5bWJvbH19IHRvIHBheSBmb3IgdXNpbmcgdGhlIGJsb2NrY2hhaW4uXFxyXFxuXFxyXFxuVG8gZ2V0IHNvbWUge3tzeW1ib2x9fSBjdXJyZW5jeVxcclxcbjxvbD5cXHJcXG4gICAgPGxpPkNvcHkgeW91ciBhZGRyZXNzIHNob3duIGJlbG93XFxyXFxuICAgICAgICA8aW5wdXQgdmFsdWU9XFxcInt7ZXRoQWRkcmVzc319XFxcIiAvPlxcclxcbiAgICA8L2xpPlxcclxcbiAgICA8bGk+T3BlbiA8YSBocmVmPVxcXCJ7e2ZhdWNldFVybH19XFxcIiBpZD1cXFwiZ2V0TmF0aXZlVG9rZW5zXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+e3tmYXVjZXRVcmx9fTwvYT48L2xpPlxcclxcbiAgICA8bGk+UGFzdGUgaW4geW91ciBhZGRyZXNzIHlvdSBqdXN0IGNvcGllZCBhbmQgY2xpY2sgdGhlIHN1Ym1pdCBidXR0b248L2xpPlxcclxcbjwvb2w+XFxyXFxuXFxyXFxuPGRpdiBjbGFzcz1cXFwiaW5mb0JhciBkLW5vbmVcXFwiIGlkPVxcXCJ3YWl0aW5nRm9yTmF0aXZlVG9rZW5cXFwiPldhaXRpbmcgZm9yIHt7c3ltYm9sfX0uIFdpbmRvdyB3aWxsIGNsb3NlIHdoZW4geW91IGhhdmUgc29tZSBpblxcclxcbiAgICB5b3Ugd2FsbGV0LlxcclxcbiAgICBJdCBtaWdodCB0YWtlIGZldyBtaW51dGVzIGFmdGVyIHlvdSByZXF1ZXN0ZWQgaXQuXFxyXFxuICAgIDxwcm9ncmVzcz48L3Byb2dyZXNzPlxcclxcbjwvZGl2PlxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJZb3UgbmVlZCB0byBoYXZlIHt7c3ltYm9sfX0gY3VycmVuY3kgaW4geW91ciB3YWxsZXQuIFlvdSB1c2Uge3tzeW1ib2x9fSB0byBwYXkgZm9yIHVzaW5nIHRoZSBibG9ja2NoYWluLlxcclxcblxcclxcblRvIGdldCBzb21lIHt7c3ltYm9sfX0gY3VycmVuY3lcXHJcXG48b2w+XFxyXFxuICAgIDxsaT5Db3B5IHlvdXIgYWRkcmVzcyBzaG93biBiZWxvd1xcclxcbiAgICAgICAgPGlucHV0IHZhbHVlPVxcXCJ7e2V0aEFkZHJlc3N9fVxcXCIgLz5cXHJcXG4gICAgPC9saT5cXHJcXG4gICAgPGxpPk9wZW4gPGEgaHJlZj1cXFwie3tidXlVcmx9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPnt7YnV5VXJsfX08L2E+PC9saT5cXHJcXG4gICAgPGxpPlBhc3RlIGluIHlvdXIgYWRkcmVzcyB5b3UganVzdCBjb3BpZWQgYW5kIGNsaWNrIHRoZSBzdWJtaXQgYnV0dG9uPC9saT5cXHJcXG48L29sPlxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBGYWtlTmF0aXZlVG9rZW5OZWVkZWRIdG1sIGZyb20gJy4uLy4uL2h0bWwvbW9kYWwvRmFrZU5hdGl2ZVRva2VuTmVlZGVkLmh0bWwnO1xyXG5pbXBvcnQgTmF0aXZlVG9rZW5OZWVkZWRIdG1sIGZyb20gJy4uLy4uL2h0bWwvbW9kYWwvTmF0aXZlVG9rZW5OZWVkZWQuaHRtbCc7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi9Nb2RhbFwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF0aXZlVG9rZW5OZWVkZWQge1xyXG4gICAgb25OYXRpdmVUb2tlbkFycml2ZWQgOiAoKSA9PiB2b2lkO1xyXG4gICAgdGltZU91dD86IGFueSA9IHVuZGVmaW5lZDtcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihvbk5hdGl2ZVRva2VuQXJyaXZlZDogKCkgPT4gdm9pZCkge1xyXG4gICAgICAgIHRoaXMub25OYXRpdmVUb2tlbkFycml2ZWQgPSBvbk5hdGl2ZVRva2VuQXJyaXZlZDtcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gQXBwLk5ldHdvcms7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSB1c2VyU2VydmljZS5nZXRFdGhBZGRyZXNzKCk7XHJcblxyXG4gICAgICAgIGlmIChuZXR3b3JrSW5mby5UZXN0TmV0d29yaykge1xyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoRmFrZU5hdGl2ZVRva2VuTmVlZGVkSHRtbCk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGUoe3N5bWJvbDpuZXR3b3JrSW5mby5OYXRpdmVTeW1ib2wsIGZhdWNldFVybDpuZXR3b3JrSW5mby5GYXVjZXRVcmwsIGV0aEFkZHJlc3M6ZXRoQWRkcmVzc30pXHJcbiAgICAgICAgICAgIHRoaXMubW9kYWwuc2hvd01vZGFsKCdHZXQgc29tZSAnICsgbmV0d29ya0luZm8uTmF0aXZlU3ltYm9sLCBjb250ZW50LCBmYWxzZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxUaW1lcigpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShOYXRpdmVUb2tlbk5lZWRlZEh0bWwpO1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKHtzeW1ib2w6bmV0d29ya0luZm8uTmF0aXZlU3ltYm9sLCBidXlVcmw6bmV0d29ya0luZm8uQnV5VXJsLCBldGhBZGRyZXNzOmV0aEFkZHJlc3N9KVxyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLnNob3dNb2RhbCgnR2V0IHNvbWUgJyArIG5ldHdvcmtJbmZvLk5hdGl2ZVN5bWJvbCwgY29udGVudCwgZmFsc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsVGltZXIoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dldE5hdGl2ZVRva2VucycpO1xyXG4gICAgICAgIGlmICghbGluaykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgd2FpdGluZ0Zvck5hdGl2ZVRva2VuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRpbmdGb3JOYXRpdmVUb2tlbicpO1xyXG4gICAgICAgICAgICB3YWl0aW5nRm9yTmF0aXZlVG9rZW4/LmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0Zvck5hdGl2ZVRva2VucygpO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lT3V0KSBjbGVhclRpbWVvdXQodGhpcy50aW1lT3V0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY2hlY2tGb3JOYXRpdmVUb2tlbnMoKSB7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gQXBwLk5ldHdvcms7XHJcbiAgICAgICAgbGV0IGhhc0Vub3VnaE5hdGl2ZVRva2VucyA9IGF3YWl0IG5ldHdvcmtJbmZvLmhhc0Vub3VnaE5hdGl2ZVRva2VucygpO1xyXG4gICAgICAgIGlmIChoYXNFbm91Z2hOYXRpdmVUb2tlbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RhbC5oaWRlTW9kYWwoKTtcclxuICAgICAgICAgICAgdGhpcy5vbk5hdGl2ZVRva2VuQXJyaXZlZCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZU91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jaGVja0Zvck5hdGl2ZVRva2VucygpLCA1ICogMTAwMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBpZD1cXFwia3ljQWN0aW9uUmVxdWlyZWREaXZcXFwiPlxcclxcblxcclxcbiAgICB7eyNpZiBPdGhlcn19XFxyXFxuICAgIDxzdHJvbmc+VGhpcyBpcyB0aGUgbWVzc2FnZSBmcm9tIEtZQyBwcm9jZXNzb3Igd2UgcmVjZWl2ZWQ8L3N0cm9uZz5cXHJcXG4gICAgPGJsb2NrcXVvdGU+XFxyXFxuICAgICAgICB7e090aGVyfX1cXHJcXG4gICAgPC9ibG9ja3F1b3RlPlxcclxcbiAgICB7ey9pZn19XFxyXFxuICAgIDxmb3JtIG5vdmFsaWRhdGUgaWQ9XFxcImt5Y0FjdGlvblJlcXVpcmVkRm9ybVxcXCIgbmFtZT1cXFwia3ljQWN0aW9uUmVxdWlyZWRGb3JtXFxcIiBvbnN1Ym1pdD1cXFwicmV0dXJuIGZhbHNlO1xcXCI+XFxyXFxuICAgICAgICB7e3tLeWNJbmZvfX19XFxyXFxuICAgICAgICB7eyNpZiBTdWJtaXREYXRhfX1cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwia3ljQWN0aW9uUmVxdWlyZWRFcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b25zXFxcIj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgaWQ9XFxcImt5Y0FjdGlvblJlcXVpcmVkU3VibWl0XFxcIj5TZW5kIG5ldyBpbmZvcm1hdGlvbjwvYnV0dG9uPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICB7ey9pZn19XFxyXFxuICAgIDwvZm9ybT5cXHJcXG48L2Rpdj5cXHJcXG5cXHJcXG48ZGl2IGlkPVxcXCJreWNBY3Rpb25SZXF1aXJlZFN1Ym1pdHRlZERpdlxcXCIgY2xhc3M9XFxcImhpZGRlbiBjZW50ZXJcXFwiPlxcclxcbiAgICA8aDM+WW91IGRvY3VtZW50cyBoYXZlIGJlZW4gc3VibWl0dGVkLjxici8+V2Ugd2lsbCBlbWFpbCB5b3Ugd2hlbiB5b3VyIGFjY291bnQgaXMgcmVhZHkuPC9oMz5cXHJcXG4gICAgWW91IGNhbiBjbG9zZSB0aGlzIHdpbmRvdy5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICBZb3VyIGFwcGxpY2F0aW9uIGhhcyBiZWVuIHJlamVjdGVkIGR1cmluZyBLWUMgcHJvY2Vzcy48YnIvPjxici8+XFxyXFxuICAgIFdlIGRvbid0IGhhdmUgdGhlIGluZm9ybWF0aW9uIG9uIHdoeSB0aGF0IGhhcHBlbmVkLCBidXQgeW91IGNhbiBlbWFpbCB1cyBhdFxcclxcbiAgICA8YSBocmVmPSdtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldD9zdWJqZWN0PU15IGFwcGxpY2F0aW9uIHdhcyByZWplY3RlZCZib2R5PUhpLCBjYW4geW91IGhlbHAgbWUgdG8gZmluZCBvdXQgd2hhdCB0aGUgcHJvYmxlbSBpcz8gTXkgbmFtZSBpcyBfX19fX19fIGFuZCBJIHVzZWQgdGhlIGVtYWlsIF9fX19fX18gdG8gcmVnaXN0ZXIgYXQgbGltaW5hbC5tYXJrZXQnPmluZm9AbGltaW5hbC5tYXJrZXQ8L2E+XFxyXFxuICAgIGFuZCB3ZSBjYW4gZmluZCBvdXQsIGFuZCB3ZSBzaG91bGQgYmUgYWJsZSB0byBzb2x2ZSBpdCB0b2dldGhlci5cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIDxwPlxcclxcbiAgICAgICAgSWRlbnRpdHkgbmVlZHMgdG8gYmUgdmVyaWZpZWQuXFxyXFxuICAgICAgICBUaGlzIG1lYW5zIHlvdSBuZWVkIHRvIHVwbG9hZFxcclxcbiAgICAgICAgYSBuZXcgcGhvdG8gb2YgeW91ciBpZC4gWW91IG1pZ2h0IHRyeSBhbm90aGVyIHR5cGUgb2YgSUQsIHN1Y2ggYXNcXHJcXG4gICAgICAgIGRyaXZlcidzIGxpY2Vuc2UgaWYgeW91IHRyaWVkIHBhc3Nwb3J0IGJlZm9yZVxcclxcbiAgICA8L3A+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXFxcIiBcXFwiUGhvdG8gSUQgRnJvbnQgKEZyb250IG9mIHBhc3Nwb3J0KVxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXzJcXFwiIFxcXCJQaG90byBJRCBCYWNrIChQYXNzcG9ydCBwaWN0dXJlIG9mIElEKSBcXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgPHA+XFxyXFxuICAgICAgICBBZGRyZXNzIG5lZWRzIHRvIGJlIHZlcmlmaWVkLiBQbGVhc2UgdXBsb2FkIGRvY3VtZW50IHRoYXQgY29uZmlybXMgeW91ciBhZGRyZXNzLlxcclxcbiAgICAgICAgQSBiaWxsIGZyb20gdGhlIGdvdmVybm1lbnQgb3IgdXRpbGl0eSBjb21wYW55IGluIHRoYXQgbGFzdCAzMCBkYXlzIHdpdGggeW91ciBuYW1lIGl0IHNob3VsZCB3b3JrLlxcclxcbiAgICA8L3A+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiYWRkcmVzc192ZXJpZmljYXRpb25cXFwiIFxcXCJQaWN0dXJlIG9mIGFkZHJlc3MgdmVyaWZpY2F0aW9uXFxcIn19fVxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIEZ1cnRoZXIgaW5mb3JtYXRpb24gbmVlZHMgdG8gYmUgc3VibWl0dGVkIGlmIGFjY291bnQgb3duZXIgaXMgYWZmaWxpYXRlZCB0byBmaW5yYSBvciBhbiBleGNoYW5nZVxcclxcbiAgICA8YnIvPlxcclxcbiAgICBQbGVhc2UgY29udGFjdCB1cyBhdCA8YSBocmVmPVxcXCJtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldFxcXCI+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT4gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb25cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIEZ1cnRoZXIgaW5mb3JtYXRpb24gbmVlZHMgdG8gYmUgc3VibWl0dGVkIGlmIGFjY291bnQgb3duZXIgaXMgYSBjb250cm9sIHBlcnNvblxcclxcbiAgICA8YnIvPlxcclxcbiAgICBQbGVhc2UgY29udGFjdCB1cyBhdCA8YSBocmVmPVxcXCJtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldFxcXCI+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT4gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb25cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIFRoZSBhY2NvdW50IG93bmVy4oCZcyBjb3VudHJ5IG9mIHRheCByZXNpZGVuY2UgaXMgbm90IHN1cHBvcnRlZCBieSBvdXIgS1lDIHByb3ZpZGVycy5cXHJcXG4gICAgSW4gdGhpcyBjYXNlLCB3ZeKAmWxsIG1hbnVhbGx5IHBlcmZvcm0gS1lDIG9uIHRoZSB1c2VyXFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICBEYXRlIG9mIGJpcnRoIG5lZWRzIHRvIGJlIHZlcmlmaWVkLiBQbGVhc2UgdXBsb2FkIGRvY3VtZW50IHRoYXQgY29uZmlybXMgeW91ciBkYXRlIG9mIGJpcnRoLlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgIHt7e2ZpbGVVcGxvYWQgXFxcImRhdGVfb2ZfYmlydGhfdmVyaWZpY2F0aW9uXFxcIiBcXFwiRGF0ZSBvZiBiaXJ0aCB2ZXJpZmljYXRpb25cXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgRnVydGhlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBzdWJtaXR0ZWQgaWYgZmFtaWx5IG1lbWJlciBpcyBhIHBvbGl0aWNhbGx5IGV4cG9zZWQgcGVyc29uXFxyXFxuICAgIDxici8+XFxyXFxuICAgIFBsZWFzZSBjb250YWN0IHVzIGF0IDxhIGhyZWY9XFxcIm1haWx0bzppbmZvQGxpbWluYWwubWFya2V0XFxcIj5pbmZvQGxpbWluYWwubWFya2V0PC9hPiBmb3IgZnVydGhlciBpbmZvcm1hdGlvblxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgSWRlbnRpdHkgbmVlZHMgdG8gYmUgdmVyaWZpZWQgdmlhIGEgZ292ZXJubWVudCBpc3N1ZWQgSUQuXFxyXFxuXFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXFxcIiBcXFwiUGhvdG8gSUQgRnJvbnQgKEZyb250IG9mIHBhc3Nwb3J0KVxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXzJcXFwiIFxcXCJQaG90byBJRCBCYWNrIChQYXNzcG9ydCBwaWN0dXJlIG9mIElEKSBcXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgRnVydGhlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBzdWJtaXR0ZWQgaWYgYWNjb3VudCBvd25lciBpcyBwb2xpdGljYWxseSBleHBvc2VkIHBlcnNvblxcclxcbiAgICA8YnIvPlxcclxcbiAgICBQbGVhc2UgY29udGFjdCB1cyBhdCA8YSBocmVmPVxcXCJtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldFxcXCI+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT4gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb25cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIElkZW50aXR5IG5lZWRzIHRvIGJlIHZlcmlmaWVkIHZpYSBhIGxpdmUgc2VsZmllIG9mIHRoZSBhY2NvdW50IG93bmVyXFxyXFxuXFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXFxcIiBcXFwiTGl2ZSBzZWxmaWUgdmVyaWZpY2F0aW9uXFxcIn19fVxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIFRheCBJRCBudW1iZXIgbmVlZHMgdG8gYmUgdmVyaWZpZWQuIFBsZWFzZSB1cGxvYWQgZG9jdW1lbnQgdGhhdCBjb25maXJtcyB5b3VyIFRheCBJZFxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgIHt7e2ZpbGVVcGxvYWQgXFxcInRheF9pZF92ZXJpZmljYXRpb25cXFwiIFxcXCJUYXggaWQgdmVyaWZpY2F0aW9uXFxcIn19fVxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIEZ1cnRoZXIgaW5mb3JtYXRpb24gbmVlZHMgdG8gYmUgc3VibWl0dGVkIGFib3V0IGFjY291bnQgb3duZXLigJlzIHZpc2FcXHJcXG4gICAgPGJyLz5cXHJcXG4gICAgUGxlYXNlIGNvbnRhY3QgdXMgYXQgPGEgaHJlZj1cXFwibWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXRcXFwiPmluZm9AbGltaW5hbC5tYXJrZXQ8L2E+IGZvciBmdXJ0aGVyIGluZm9ybWF0aW9uXFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICBJZGVudGlmeWluZyBpbmZvcm1hdGlvbiBzdWJtaXR0ZWQgYnkgdGhlIHVzZXIgd2FzIGluY29ycmVjdCBzbyBhIG5ldywgY29ycmVjdGVkLCBXOEJFTiBuZWVkcyB0byBiZSBzdWJtaXR0ZWRcXHJcXG4gICAgPGJyLz5cXHJcXG4gICAgUGxlYXNlIGNvbnRhY3QgdXMgYXQgPGEgaHJlZj1cXFwibWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXRcXFwiPmluZm9AbGltaW5hbC5tYXJrZXQ8L2E+IGZvciBmdXJ0aGVyIGluZm9ybWF0aW9uXFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdj5cXHJcXG4gICAgPGxhYmVsIGZvcj1cXFwie3tpbnB1dElkfX1cXFwiPnt7bGFiZWx9fTwvbGFiZWw+XFxyXFxuICAgIDxpbnB1dCB0eXBlPVxcXCJmaWxlXFxcIiByZXF1aXJlZCBpZD1cXFwie3tpbnB1dElkfX1cXFwiIGFjY2VwdD1cXFwie3thY2NlcHR9fVxcXCIgY2FwdHVyZT1cXFwie3tjYXB0dXJlfX1cXFwiLz5cXHJcXG4gICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgaWQ9XFxcInt7aW5wdXRJZH19X2Jhc2U2NFxcXCIgbmFtZT1cXFwie3tpbnB1dElkfX1fYmFzZTY0XFxcIi8+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImVycm9yIGhpZGRlblxcXCIgaWQ9XFxcInt7aW5wdXRJZH19X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG48L2Rpdj5cXHJcXG48ZGl2IGlkPVxcXCJ7e2lucHV0SWR9fV9wcmV2aWV3XFxcIj5cXHJcXG5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEZpbGVVcGxvYWRIdG1sIGZyb20gJy4uLy4uL2h0bWwvZWxlbWVudHMvRmlsZVVwbG9hZC5odG1sJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVVcGxvYWQge1xyXG5cclxuICAgIHByaXZhdGUgbWF4RmlsZVNpemU6IG51bWJlciA9IDggKiAxMDI0ICogMTAyNCAqIDEwOyAvLzEwTUJcclxuICAgIGlucHV0SWQ6IHN0cmluZztcclxuICAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICBhY2NlcHQgPSBcImltYWdlLyosLnBkZlwiO1xyXG4gICAgY2FwdHVyZSA9ICdlbnZpcm9ubWVudCc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaW5wdXRJZDogc3RyaW5nLCBsYWJlbDogc3RyaW5nLCBhY2NlcHQgPSBcImltYWdlL3BuZyxpbWFnZS9qcGVnLC5wZGZcIiwgY2FwdHVyZSA9ICdlbnZpcm9ubWVudCcpIHtcclxuICAgICAgICB0aGlzLmlucHV0SWQgPSBpbnB1dElkO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcclxuICAgICAgICB0aGlzLmFjY2VwdCA9IGFjY2VwdDtcclxuICAgICAgICB0aGlzLmNhcHR1cmUgPSBjYXB0dXJlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW5kZXIoKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEZpbGVVcGxvYWRIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUodGhpcylcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYmluZEV2ZW50cygpIHtcclxuICAgICAgICBsZXQgZmlsZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pbnB1dElkKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGZpbGVJbnB1dD8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NGaWxlKGZpbGVJbnB1dCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByb3RlY3RlZCBwcm9jZXNzRmlsZShlbGVtZW50OiBIVE1MSW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5oaWRlRmlsZVJlbGF0ZWRJbmZvKGVsZW1lbnQuaWQpO1xyXG5cclxuICAgICAgICBsZXQgZmlsZXMgPSBlbGVtZW50LmZpbGVzO1xyXG4gICAgICAgIGlmICghZmlsZXMpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGZpbGUgPSBmaWxlc1swXTtcclxuICAgICAgICBpZiAoIWZpbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93RmlsZVJlbGF0ZWRJbmZvKGVsZW1lbnQuaWQsICdObyBmaWxlIHNlbGVjdGVkLiBQbGVhc2Ugc2VsZWN0IGZpbGUuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZTY0SW5wdXQoZWxlbWVudC5pZCwgJycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZmlsZS5zaXplID4gdGhpcy5tYXhGaWxlU2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dGaWxlUmVsYXRlZEluZm8oZWxlbWVudC5pZCwgJ0ZpbGUgJyArIGZpbGUubmFtZSArICcgaXMgdG8gbGFyZ2UuIEZpbGVzIGNhbm5vdCBiZSBsYXJnZXIgdGhlbiAxME1CLiBZb3UgbmVlZCB0byBtYWtlIGl0IHNtYWxsZXIgYmVmb3JlIHN1Ym1pdHRpbmcgeW91ciBhcHBsaWNhdGlvbicpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEJhc2U2NElucHV0KGVsZW1lbnQuaWQsICcnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZTY0SW5wdXQoZWxlbWVudC5pZCwgcmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0ZpbGVSZWxhdGVkSW5mbyhlbGVtZW50LmlkLCAnQ291bGQgbm90IHJlYWQgZmlsZSAnICsgZmlsZS5uYW1lICsgJy4gRWl0aGVyIHRoZSBmaWxlIGlzIGNvcnJ1cHQgb3IgeW91ciBicm93c2VyIGRvZXMgbm90IGFsbG93IHVzIHRvIHJlYWQgaXQnKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0QmFzZTY0SW5wdXQoZWxlbWVudElkOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgYmFzZTY0SW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQgKyAnX2Jhc2U2NCcpISBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGJhc2U2NElucHV0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgbGV0IHByZXZpZXdFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkICsgJ19wcmV2aWV3Jyk7XHJcbiAgICAgICAgaWYgKCFwcmV2aWV3RWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZignZGF0YTppbWFnZScpICE9IC0xKSB7XHJcbiAgICAgICAgICAgIHByZXZpZXdFbGVtZW50LmlubmVySFRNTCA9ICc8aW1nIHNyYz1cIicgKyBiYXNlNjRJbnB1dC52YWx1ZSArICdcIiAvPidcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcmV2aWV3RWxlbWVudC5pbm5lckhUTUwgPSAnJ1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIHNob3dGaWxlUmVsYXRlZEluZm8oZWxlbWVudElkOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBmaWxlUmVsYXRlZEluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQgKyAnX2Vycm9yJykhIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghZmlsZVJlbGF0ZWRJbmZvKSByZXR1cm47XHJcblxyXG4gICAgICAgIGZpbGVSZWxhdGVkSW5mby5pbm5lckhUTUwgPSB0ZXh0O1xyXG4gICAgICAgIGZpbGVSZWxhdGVkSW5mby5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBoaWRlRmlsZVJlbGF0ZWRJbmZvKGVsZW1lbnRJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGZpbGVSZWxhdGVkSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCArICdfZXJyb3InKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAoIWZpbGVSZWxhdGVkSW5mbykgcmV0dXJuO1xyXG5cclxuICAgICAgICBmaWxlUmVsYXRlZEluZm8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZpbGVVcGxvYWRzOiBGaWxlVXBsb2FkW10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVySGFuZGxlcigpIHtcclxuICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdmaWxlVXBsb2FkJywgKGlkLCBsYWJlbCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZmlsZVVwbG9hZCA9IG5ldyBGaWxlVXBsb2FkKGlkLCBsYWJlbCk7XHJcbiAgICAgICAgICAgIEZpbGVVcGxvYWQuZmlsZVVwbG9hZHMucHVzaChmaWxlVXBsb2FkKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmaWxlVXBsb2FkLnJlbmRlcigpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgS3ljVmFsaWRhdG9yRXJyb3IgZnJvbSBcIi4uL2Vycm9ycy9jbG91ZC9LeWNWYWxpZGF0b3JFcnJvclwiO1xyXG5pbXBvcnQgU3RyaW5nSGVscGVyIGZyb20gXCIuL1N0cmluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybVZhbGlkYXRvciB7XHJcbiAgICBzZWxlY3Rvcjogc3RyaW5nO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzZWxlY3Rvcjogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGVSZXF1aXJlZEZpZWxkcygpIHtcclxuICAgICAgICBsZXQgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLnNlbGVjdG9yICsgJyBpbnB1dFtyZXF1aXJlZF0sICcgKyB0aGlzLnNlbGVjdG9yICsgJyBzZWxlY3RbcmVxdWlyZWRdJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gaW5wdXRzW2ldIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5pc01pc3NpbmdJbnB1dEZyb21Vc2VyKGlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnWW91IG11c3QgZmlsbCBpbnRvIHRoaXMgZmllbGQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0TmFtZTogaW5wdXQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9JyArIGlucHV0LmlkICsgJ10nKSEuaW5uZXJIVE1MLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGlucHV0LnBhdHRlcm5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZShvYmopO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5wdXQucGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBhdHRlcm4gPSBpbnB1dC5wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBpbnB1dC52YWx1ZS5tYXRjaChwYXR0ZXJuKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBpcyBub3QgdmFsaWQgZGF0ZSBmb3JtYXQsIHBsZWFzZSB1c2UgWVlZWS1NTS1ERCAoeWVhci1tb250aC1kYXRlKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0TmFtZTogaW5wdXQuaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPScgKyBpbnB1dC5pZCArICddJykhLmlubmVySFRNTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogaW5wdXQucGF0dGVyblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGUob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgaXNNaXNzaW5nSW5wdXRGcm9tVXNlcihpbnB1dDogSFRNTElucHV0RWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiAoKGlucHV0LnR5cGUgPT0gJ2NoZWNrYm94JyAmJiAhaW5wdXQuY2hlY2tlZCkgfHwgU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkoaW5wdXQudmFsdWUpKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlTWlzc2luZ0luZm8oZXJyb3JEaXZJZDogc3RyaW5nLCBmb2N1c0VsZW1lbnRJZD86IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZXJyb3JEaXZJZCk7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XHJcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG5cclxuICAgICAgICBpZiAoIWZvY3VzRWxlbWVudElkKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBmb2N1c0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk7XHJcbiAgICAgICAgaWYgKGZvY3VzRWxlbWVudCkge1xyXG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHNldE1pc3NpbmdJbmZvKGVycm9yRGl2SWQ6IHN0cmluZywgdGV4dDogc3RyaW5nLCBmb2N1c0VsZW1lbnRJZD86IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZXJyb3JEaXZJZCk7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gdGV4dDtcclxuICAgICAgICBpZiAodGV4dCA9PSAnJykge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXHJcbiAgICAgICAgICAgIGlmIChmb2N1c0VsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9jdXNFbGVtZW50SWQpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9jdXNFbGVtZW50SWQpPy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYW5kbGUob2JqOiB7IGxhYmVsVGV4dDogc3RyaW5nOyBtZXNzYWdlOiBzdHJpbmc7IHBhdHRlcm46IHN0cmluZzsgaW5wdXROYW1lOiBzdHJpbmcgfSkge1xyXG4gICAgICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iai5pbnB1dE5hbWUpO1xyXG4gICAgICAgIGlmICghaW5wdXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGlucHV0RXJyb3IgPSBpbnB1dC5wYXJlbnRFbGVtZW50IS5xdWVyeVNlbGVjdG9yKCcuaW5wdXRfZXJyb3InKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAoaW5wdXRFcnJvcikge1xyXG4gICAgICAgICAgICBpbnB1dEVycm9yLnNjcm9sbEludG9WaWV3KHtibG9jazogJ2NlbnRlcid9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgaW5wdXQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlYmVnaW5cIiwgJzxkaXYgY2xhc3M9XCJpbnB1dF9lcnJvclwiIHN0eWxlPVwiZGlzcGxheTogYmxvY2tcIiBpZD1cImlucHV0X2Vycm9yXycgKyBvYmouaW5wdXROYW1lICsgJ1wiPicgKyBvYmoubWVzc2FnZSArICc8L2Rpdj4nKTtcclxuICAgICAgICBpbnB1dC5mb2N1cygpO1xyXG4gICAgICAgIGlmIChvYmoucGF0dGVybikge1xyXG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3BhdHRlcm4nLCBvYmoucGF0dGVybik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IGlucHV0LmdldEF0dHJpYnV0ZSgncGF0dGVybicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgocGF0dGVybiAmJiBpbnB1dC52YWx1ZS5tYXRjaChwYXR0ZXJuKSkgfHwgKGlucHV0LnJlcXVpcmVkICYmIGlucHV0LnZhbHVlKSB8fCBpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0X2Vycm9yXycgKyBvYmouaW5wdXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSBlcnJvck1lc3NhZ2UucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDgwMCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTW9kYWwgZnJvbSBcIi4uL01vZGFsXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgS3ljQWN0aW9uUmVxdWlyZWRIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0FjdGlvblJlcXVpcmVkLmh0bWwnO1xyXG5pbXBvcnQgV2VEb250S25vd1doeUh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvV2VEb250S25vd1doeS5odG1sJ1xyXG5pbXBvcnQgS3ljUmVzdWx0TWVzc2FnZSBmcm9tIFwiLi4vLi4vLi4vZHRvL0t5Y1Jlc3VsdE1lc3NhZ2VcIjtcclxuXHJcblxyXG5pbXBvcnQgSURFTlRJVFlfVkVSSUZJQ0FUSU9OIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0lERU5USVRZX1ZFUklGSUNBVElPTi5odG1sJ1xyXG5pbXBvcnQgQUREUkVTU19WRVJJRklDQVRJT04gZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvQUREUkVTU19WRVJJRklDQVRJT04uaHRtbCdcclxuaW1wb3J0IEFGRklMSUFURUQgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvQUZGSUxJQVRFRC5odG1sJ1xyXG5pbXBvcnQgQ09OVFJPTF9QRVJTT04gZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvQ09OVFJPTF9QRVJTT04uaHRtbCdcclxuaW1wb3J0IENPVU5UUllfTk9UX1NVUFBPUlRFRCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9DT1VOVFJZX05PVF9TVVBQT1JURUQuaHRtbCdcclxuaW1wb3J0IERBVEVfT0ZfQklSVEggZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvREFURV9PRl9CSVJUSC5odG1sJ1xyXG5pbXBvcnQgRkFNSUxZX01FTUJFUl9QRVAgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvRkFNSUxZX01FTUJFUl9QRVAuaHRtbCdcclxuaW1wb3J0IElOVkFMSURfSURFTlRJVFlfUEFTU1BPUlQgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvSU5WQUxJRF9JREVOVElUWV9QQVNTUE9SVC5odG1sJ1xyXG5pbXBvcnQgUEVQIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1BFUC5odG1sJ1xyXG5pbXBvcnQgU0VMRklFX1ZFUklGSUNBVElPTiBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9TRUxGSUVfVkVSSUZJQ0FUSU9OLmh0bWwnXHJcbmltcG9ydCBUQVhfSURFTlRJRklDQVRJT04gZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvVEFYX0lERU5USUZJQ0FUSU9OLmh0bWwnXHJcbmltcG9ydCBWSVNBX1RZUEVfT1RIRVIgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvVklTQV9UWVBFX09USEVSLmh0bWwnXHJcbmltcG9ydCBXOEJFTl9DT1JSRUNUSU9OIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1c4QkVOX0NPUlJFQ1RJT04uaHRtbCdcclxuaW1wb3J0IEZvcm1IZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvRm9ybUhlbHBlclwiO1xyXG5pbXBvcnQgRmlsZVVwbG9hZCBmcm9tIFwiLi4vLi4vZWxlbWVudHMvRmlsZVVwbG9hZFwiO1xyXG5pbXBvcnQgS3ljVmFsaWRhdG9yRXJyb3IgZnJvbSBcIi4uLy4uLy4uL2Vycm9ycy9jbG91ZC9LeWNWYWxpZGF0b3JFcnJvclwiO1xyXG5pbXBvcnQgRm9ybVZhbGlkYXRvciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Gb3JtVmFsaWRhdG9yXCI7XHJcbmltcG9ydCBLWUNTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0tZQ1NlcnZpY2VcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgRXhlY3V0ZU9yZGVyQnV0dG9uIGZyb20gXCIuLi8uLi9lbGVtZW50cy90cmFkZXBhbmVsL0V4ZWN1dGVPcmRlckJ1dHRvblwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0FjdGlvblJlcXVpcmVkIHtcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuICAgIHRlbXBsYXRlczogTWFwPHN0cmluZywgc3RyaW5nPjtcclxuICAgIGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZU9yZGVyQnV0dG9uO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZU9yZGVyQnV0dG9uKSB7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZVRyYWRlQnV0dG9uID0gZXhlY3V0ZVRyYWRlQnV0dG9uO1xyXG5cclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ1dlRG9udEtub3dXaHlIdG1sJywgV2VEb250S25vd1doeUh0bWwpO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzLnNldCgnQUREUkVTU19WRVJJRklDQVRJT04nLCBBRERSRVNTX1ZFUklGSUNBVElPTik7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdBRkZJTElBVEVEJywgQUZGSUxJQVRFRCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdDT05UUk9MX1BFUlNPTicsIENPTlRST0xfUEVSU09OKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ0NPVU5UUllfTk9UX1NVUFBPUlRFRCcsIENPVU5UUllfTk9UX1NVUFBPUlRFRCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdEQVRFX09GX0JJUlRIJywgREFURV9PRl9CSVJUSCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdGQU1JTFlfTUVNQkVSX1BFUCcsIEZBTUlMWV9NRU1CRVJfUEVQKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ0lERU5USVRZX1ZFUklGSUNBVElPTicsIElERU5USVRZX1ZFUklGSUNBVElPTik7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdJTlZBTElEX0lERU5USVRZX1BBU1NQT1JUJywgSU5WQUxJRF9JREVOVElUWV9QQVNTUE9SVCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdQRVAnLCBQRVApO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzLnNldCgnU0VMRklFX1ZFUklGSUNBVElPTicsIFNFTEZJRV9WRVJJRklDQVRJT04pO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzLnNldCgnVEFYX0lERU5USUZJQ0FUSU9OJywgVEFYX0lERU5USUZJQ0FUSU9OKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ1ZJU0FfVFlQRV9PVEhFUicsIFZJU0FfVFlQRV9PVEhFUik7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdXOEJFTl9DT1JSRUNUSU9OJywgVzhCRU5fQ09SUkVDVElPTik7XHJcblxyXG4gICAgICAgIEZpbGVVcGxvYWQucmVnaXN0ZXJIYW5kbGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGt5Y1Jlc3VsdCA9IGF3YWl0IHVzZXJTZXJ2aWNlLmt5Y0FjdGlvblJlcXVpcmVkKClcclxuICAgICAgICBpZiAoIWt5Y1Jlc3VsdCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQga3ljSW5mbyA9IHRoaXMuZ2V0S3ljTWVzc2FnZXMoa3ljUmVzdWx0Lm1lc3NhZ2VzKTtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y0FjdGlvblJlcXVpcmVkSHRtbCk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZSh7XHJcbiAgICAgICAgICAgIGpzb246IEpTT04uc3RyaW5naWZ5KGt5Y1Jlc3VsdCksXHJcbiAgICAgICAgICAgIEt5Y0luZm86IGt5Y0luZm8sXHJcbiAgICAgICAgICAgIE90aGVyOiBreWNSZXN1bHQuYWRkaXRpb25hbF9pbmZvcm1hdGlvbixcclxuICAgICAgICAgICAgU3VibWl0RGF0YToga3ljSW5mby5pbmRleE9mKCc8aW5wdXQnKSAhPSAtMVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMubW9kYWwuc2hvd01vZGFsKCdBY3Rpb24gcmVxdWlyZWQnLCBjb250ZW50LCBmYWxzZSwgKCkgPT4ge1xyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNBY3Rpb25SZXF1aXJlZEZvcm0nKTtcclxuICAgICAgICBreWNBY3Rpb25SZXF1aXJlZEZvcm0/LmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUVycm9yKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc3VibWl0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0FjdGlvblJlcXVpcmVkU3VibWl0JykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyhzdWJtaXRCdG4pO1xyXG5cclxuICAgICAgICAgICAgbGV0IGZvcm1WYWxpZGF0b3IgPSBuZXcgRm9ybVZhbGlkYXRvcignI2t5Y0FjdGlvblJlcXVpcmVkRm9ybScpXHJcbiAgICAgICAgICAgIGlmICghZm9ybVZhbGlkYXRvci52YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBGb3JtSGVscGVyLmdldFBhcmFtcygnI2t5Y0FjdGlvblJlcXVpcmVkRm9ybScpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGt5Y1NlcnZpY2UgPSBuZXcgS1lDU2VydmljZSgpO1xyXG4gICAgICAgICAgICBhd2FpdCBreWNTZXJ2aWNlLnVwZGF0ZURvY3VtZW50cyhwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0FjdGlvblJlcXVpcmVkRGl2JykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAga3ljQWN0aW9uUmVxdWlyZWREaXY/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQga3ljQWN0aW9uUmVxdWlyZWRTdWJtaXR0ZWREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWRTdWJtaXR0ZWREaXYnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBreWNBY3Rpb25SZXF1aXJlZFN1Ym1pdHRlZERpdj8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlVHJhZGVCdXR0b24ucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRmlsZVVwbG9hZC5maWxlVXBsb2Fkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBGaWxlVXBsb2FkLmZpbGVVcGxvYWRzW2ldLmJpbmRFdmVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0S3ljTWVzc2FnZXMobWVzc2FnZXM6IEt5Y1Jlc3VsdE1lc3NhZ2VbXSkge1xyXG4gICAgICAgIGxldCBreWNJbmZvID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaHRtbFRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZXMuZ2V0KG1lc3NhZ2VzW2ldLmtleSk7XHJcbiAgICAgICAgICAgIGlmICghaHRtbFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IEhlcmUgd2Ugc2hvdWxkIHRvIGxvZ2dlciwgY3JpdGljYWwgdGhhdCB3ZSBkb250IGtub3cgd2h5XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoaHRtbFRlbXBsYXRlKVxyXG4gICAgICAgICAgICBreWNJbmZvICs9IHRlbXBsYXRlKHttZXNzYWdlOiBtZXNzYWdlc1tpXS5tZXNzYWdlfSlcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAoa3ljSW5mbyA9PSAnJykge1xyXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHRoaXMudGVtcGxhdGVzLmdldCgnV2VEb250S25vd1doeUh0bWwnKTtcclxuICAgICAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKGh0bWwpO1xyXG4gICAgICAgICAgICBreWNJbmZvID0gdGVtcGxhdGUoe30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGt5Y0luZm87XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoaWRlRXJyb3IoKSB7XHJcbiAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWRFcnJvcicpO1xyXG4gICAgICAgIGlmICgha3ljQWN0aW9uUmVxdWlyZWRFcnJvcikgcmV0dXJuO1xyXG4gICAgICAgIGt5Y0FjdGlvblJlcXVpcmVkRXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2hvd0Vycm9yKHJlYXNvbjogYW55KSB7XHJcbiAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWRFcnJvcicpO1xyXG4gICAgICAgIGlmICgha3ljQWN0aW9uUmVxdWlyZWRFcnJvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBreWNBY3Rpb25SZXF1aXJlZEVycm9yLmlubmVySFRNTCA9ICdFcnJvciBvY2N1cnJlZCB3aGlsZSBzYXZpbmcgeW91ciBkb2N1bWVudHMuIFJlYXNvbjonICsgcmVhc29uO1xyXG4gICAgICAgIGt5Y0FjdGlvblJlcXVpcmVkRXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxkaXYgaWQ9XFxcImt5Y19yZWdcXFwiPlxcclxcblxcclxcbiAgICA8Zm9ybSBpZD1cXFwia3ljX3dpemFyZF9mb3JtXFxcIiBuYW1lPVxcXCJreWNfd2l6YXJkX2Zvcm1cXFwiIG5vdmFsaWRhdGUgb25zdWJtaXQ9XFxcInJldHVybiBmYWxzZVxcXCI+XFxyXFxuICAgICAgICB7e3tLeWNDb250YWN0SHRtbH19fVxcclxcbiAgICAgICAge3t7S3ljSWRlbnRpdHlIdG1sfX19XFxyXFxuICAgICAgICB7e3tLeWNUcnVzdGVkQ29udGFjdEh0bWx9fX1cXHJcXG4gICAgICAgIHt7e0t5Y0Rpc2Nsb3N1cmVIdG1sfX19XFxyXFxuICAgICAgICB7e3tLeWNVcGxvYWRIdG1sfX19XFxyXFxuICAgICAgICB7e3tLeWNBY2NvdW50QWdyZWVtZW50SHRtbH19fVxcclxcbiAgICA8L2Zvcm0+XFxyXFxuPC9kaXY+XFxyXFxuXFxyXFxuPGRpdiBpZD1cXFwid2FpdGluZ19mb3Jfa3ljX3JlZ1xcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxyXFxuICAgIEtZQyBpcyBiZWluZyBwcm9jZXNzZWQuIFRoaXMgbWF5IHRha2UgYWJvdXQgNC01IG1pbnV0ZXMuIFdpbmRvdyB3aWxsIGNsb3NlIHdoZW4gaXQncyBkb25lLlxcclxcbiAgICA8YnIvPjxici8+XFxyXFxuICAgIFlvdSBjYW4gY2xvc2UgdGhlIHdpbmRvdywgd2Ugd2lsbCBlbWFpbCB5b3Ugd2hlbiBLWUMgaXMgZmluaXNoZWQuXFxyXFxuXFxyXFxuICAgIDxwcm9ncmVzcz48L3Byb2dyZXNzPlxcclxcblxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQgY2xhc3M9XFxcImt5Y0NvbnRhY3QgaGlkZGVuXFxcIiBkYXRhLWZvcm09XFxcIjFcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJleHBsYWluXFxcIj5cXHJcXG4gICAgICAgIFRvIGJlIGFibGUgdG8gdHJhZGUgb24gdGhlIHN0b2NrIG1hcmtldCwgd2UgbmVlZCB0byBnZXQgeW91ciBpbmZvcm1hdGlvbi5cXHJcXG4gICAgICAgIFRoaXMgaXMgYSByZXF1aXJlbWVudCBmcm9tIHRoZSBmaW5hbmNpYWwgcmVndWxhdG9ycy5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbWFpbF9hZGRyZXNzXFxcIj5FbWFpbDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZW1haWxcXFwiIHJlcXVpcmVkIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJlbWFpbF9hZGRyZXNzXFxcIiBuYW1lPVxcXCJlbWFpbF9hZGRyZXNzXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJuYW1lQGV4YW1wbGUuY29tXFxcIiBhdXRvY29tcGxldGU9XFxcImVtYWlsXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInBob25lX251bWJlclxcXCI+UGhvbmU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRlbFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcInBob25lX251bWJlclxcXCIgbmFtZT1cXFwicGhvbmVfbnVtYmVyXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCIrMS01NTUtNjY2LTc3ODhcXFwiIGF1dG9jb21wbGV0ZT1cXFwidGVsXFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCI+UGVybWFuZW50IFJlc2lkZW50aWFsIEFkZHJlc3M8L2xhYmVsPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZXhwbGFpblxcXCI+SXQgbXVzdCBiZSBhIHBoeXNpY2FsIGFkZHJlc3MsIG5vdCBhIFBPIGJveC48L2Rpdj5cXHJcXG4gICAgICAgIDxpbnB1dCByZXF1aXJlZCBpZD1cXFwic3RyZWV0X2FkZHJlc3NcXFwiIG5hbWU9XFxcInN0cmVldF9hZGRyZXNzXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCIyMCBOIFNhbiBNYXRlbyBEclxcXCIgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJhZGRyZXNzLWxpbmUxXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ1bml0XFxcIj5Vbml0IC8gQXB0ICM8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ1bml0XFxcIiBuYW1lPVxcXCJ1bml0XFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJjaXR5XFxcIj5DaXR5PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwiY2l0eVxcXCIgbmFtZT1cXFwiY2l0eVxcXCIgcGxhY2Vob2xkZXI9XFxcIlBhd25lZVxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZHJlc3MtbGV2ZWwyXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJwb3N0YWxfY29kZVxcXCI+UG9zdGFsIGNvZGU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJwb3N0YWxfY29kZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJwb3N0YWwtY29kZVxcXCIgbmFtZT1cXFwicG9zdGFsX2NvZGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIjk0NDAxXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwic3RhdGVfZGl2XFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInN0YXRlXFxcIj5TdGF0ZSAoMiBsZXR0ZXJzKTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbWF4bGVuZ3RoPVxcXCIyXFxcIiBpZD1cXFwic3RhdGVcXFwiIG5hbWU9XFxcInN0YXRlXFxcIiBwbGFjZWhvbGRlcj1cXFwiTllcXFwiXFxyXFxuICAgICAgICAgICAgICAgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJhZGRyZXNzLWxldmVsMVxcXCI+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY291bnRyeV9vZl90YXhfcmVzaWRlbmNlXFxcIj5Db3VudHJ5IG9mIHRheCByZXNpZGVuY2U8L2xhYmVsPlxcclxcbiAgICAgICAge3sjaWYgZWRpdH19XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiY291bnRyeV9vZl90YXhfcmVzaWRlbmNlXFxcIiByZWFkb25seSBpZD1cXFwiY291bnRyeV9vZl90YXhfcmVzaWRlbmNlXFxcIi8+XFxyXFxuICAgICAgICB7ey9pZn19XFxyXFxuICAgICAgICB7eyN1bmxlc3MgZWRpdH19XFxyXFxuICAgICAgICA8c2VsZWN0IHJlcXVpcmVkIGlkPVxcXCJjb3VudHJ5X29mX3RheF9yZXNpZGVuY2VcXFwiIG5hbWU9XFxcImNvdW50cnlfb2ZfdGF4X3Jlc2lkZW5jZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJjb3VudHJ5XFxcIj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2NvZGV9fVxcXCI+e3tuYW1lfX08L29wdGlvbj5cXHJcXG4gICAgICAgICAgICB7ey9lYWNofX1cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAge3svdW5sZXNzfX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJjb250YWN0X25leHRcXFwiPk5leHQ6IElkZW50aXR5PC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi8uLi91aS9tb2RhbHMvS1lDRm9ybVwiO1xyXG5pbXBvcnQgU3RyaW5nSGVscGVyIGZyb20gXCIuLi8uLi91dGlsL1N0cmluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljVmFsaWRhdG9yRXJyb3Ige1xyXG4gICAgdmFsaWRWYWx1ZXM6IHN0cmluZyB8IHN0cmluZ1tdID0gJyc7XHJcbiAgICBpbnB1dE5hbWU6IHN0cmluZyA9ICcnO1xyXG4gICAgbGFiZWxUZXh0OiBzdHJpbmcgPSAnJztcclxuICAgIG1lc3NhZ2U6IHN0cmluZztcclxuICAgIHBhdHRlcm46IHN0cmluZyA9ICcnO1xyXG4gICAgb25zaG93OiBhbnk7XHJcbiAgICBreWNGb3JtOiBLWUNGb3JtO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGVycm9yOiBhbnksIGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7fTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoIWVycm9yLmlucHV0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShlcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmogPSBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gb2JqLm1lc3NhZ2U/LnJlcGxhY2UoL18vZywgJyAnKTtcclxuICAgICAgICAgICAgdGhpcy52YWxpZFZhbHVlcyA9IG9iai52YWxpZFZhbHVlcz8ucmVwbGFjZSgvXy9nLCAnICcpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0TmFtZSA9IG9iai5pbnB1dE5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxUZXh0ID0gb2JqLmxhYmVsVGV4dDtcclxuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gb2JqLnBhdHRlcm47XHJcbiAgICAgICAgICAgIHRoaXMub25zaG93ID0gb2JqLm9uc2hvdztcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc3NhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmt5Y0Zvcm0gPSBreWNGb3JtO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodGhpcy5pbnB1dE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCBhY3RpdmVGaWVsZHNldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5reWNGb3JtLmFjdGl2ZUZpZWxkc2V0U2VsZWN0b3IpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgaW5wdXRFcnJvciA9IGFjdGl2ZUZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3IoJy5pbnB1dF9lcnJvcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEVycm9yLmlubmVySFRNTCA9IHRoaXMudmFsaWRWYWx1ZXMudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVzc2FnZSAmJiB0aGlzLm1lc3NhZ2UuaW5kZXhPZignSW52YWxpZCBmdW5jdGlvbicpICE9IC0xIHx8IHRoaXMubWVzc2FnZS5pbmRleE9mKCdVbmFibGUgdG8gY29ubmVjdCB0byB0aGUgUGFyc2UgQVBJJykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRFcnJvci5pbm5lckhUTUwgPSAnV2UganVzdCBkZXBsb3llZCBuZXcgdmVyc2lvbiBvZiBvdXIgd2Vic2l0ZS4gVGhpcyBjYW4gY2F1c2UgaW50ZXJydXB0aW9uLiBQbGVhc2Ugd2FpdCAzMCBzZWNvbmRzIGFuZCBzdWJtaXQgYWdhaW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RXJyb3IuaW5uZXJIVE1MID0gdGhpcy5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlucHV0RXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgICAgICBpbnB1dEVycm9yLnNjcm9sbEludG9WaWV3KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaW5wdXROYW1lKTtcclxuICAgICAgICBpZiAoIWlucHV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBpbnB1dEVycm9yID0gaW5wdXQucGFyZW50RWxlbWVudCEucXVlcnlTZWxlY3RvcignLmlucHV0X2Vycm9yJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGlucHV0RXJyb3IpIHtcclxuICAgICAgICAgICAgaW5wdXRFcnJvci5zY3JvbGxJbnRvVmlldyh7YmxvY2s6ICdjZW50ZXInfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xyXG4gICAgICAgIGxldCBlcnJvcklucHV0ID0gJzxkaXYgY2xhc3M9XCJpbnB1dF9lcnJvclwiIHN0eWxlPVwiZGlzcGxheTogYmxvY2tcIiBpZD1cImlucHV0X2Vycm9yXycgKyB0aGlzLmlucHV0TmFtZSArICdcIj4nICsgdGhpcy5tZXNzYWdlICsgJzwvZGl2Pic7XHJcbiAgICAgICAgaWYgKGlucHV0LmNsaWVudFdpZHRoIDwgMzAwKSB7XHJcbiAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLmdldERpdlRvRGlzcGxheUVycm9yTWVzc2FnZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGRpdi5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBlcnJvcklucHV0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBlcnJvcklucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcclxuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgncGF0dGVybicsIHRoaXMucGF0dGVybik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IGlucHV0LmdldEF0dHJpYnV0ZSgncGF0dGVybicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgocGF0dGVybiAmJiBpbnB1dC52YWx1ZS5tYXRjaChwYXR0ZXJuKSkgfHwgKGlucHV0LnR5cGUgIT0gJ2NoZWNrYm94JyAmJiBpbnB1dC50eXBlICE9ICdyYWRpbycgJiYgaW5wdXQucmVxdWlyZWQgJiYgaW5wdXQudmFsdWUpIHx8IGlucHV0LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRfZXJyb3JfJyArIHRoaXMuaW5wdXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSBlcnJvck1lc3NhZ2UucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDgwMCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IGZpZWxkc2V0RWxlbWVudCA9IGlucHV0LmNsb3Nlc3QoJ2ZpZWxkc2V0W2RhdGEtZm9ybT1cIjFcIl0nKTtcclxuICAgICAgICBpZiAoZmllbGRzZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBmaWVsZHNldEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoJ2hpZGRlbicsICcnKS50cmltKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5zaG93KGNsYXNzTmFtZSk7XHJcblxyXG4gICAgICAgICAgICBpbnB1dC5zY3JvbGxJbnRvVmlldyhmYWxzZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uc2hvdykge1xyXG4gICAgICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub25zaG93LmlkKTtcclxuICAgICAgICAgICAgaWYgKCFsaW5rKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBNb3JhbGlzLkNsb3VkLnJ1bih0aGlzLm9uc2hvdy5mdW5jdGlvbk5hbWUsIHRoaXMub25zaG93LnBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0X2Vycm9yXycgKyB0aGlzLmlucHV0TmFtZSkhLmlubmVySFRNTCA9ICdFbWFpbCBoYXMgYmVlbiBzZW50IHRvICcgKyB0aGlzLm9uc2hvdy5wYXJhbXMuZW1haWw7XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0RGl2VG9EaXNwbGF5RXJyb3JNZXNzYWdlKGlucHV0OiBIVE1MRWxlbWVudCwgY291bnRlciA9IDEpOiBIVE1MRWxlbWVudCB7XHJcblxyXG4gICAgICAgIGxldCBkaXYgPSBpbnB1dC5wYXJlbnRFbGVtZW50IS5jbG9zZXN0KCdkaXYnKTtcclxuICAgICAgICBpZiAoIWRpdikgcmV0dXJuIGlucHV0O1xyXG5cclxuICAgICAgICBpZiAoZGl2LmNsaWVudFdpZHRoID4gMzAwIHx8IGNvdW50ZXIgPiA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXZUb0Rpc3BsYXlFcnJvck1lc3NhZ2UoZGl2LCArK2NvdW50ZXIpO1xyXG5cclxuICAgIH1cclxufSIsImltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvU3RyaW5nSGVscGVyXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcbmltcG9ydCBGaWxlVXBsb2FkIGZyb20gXCIuLi8uLi9lbGVtZW50cy9GaWxlVXBsb2FkXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljQmFzZSB7XHJcbiAgICBreWNGb3JtOiBLWUNGb3JtO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICB0aGlzLmt5Y0Zvcm0gPSBreWNGb3JtO1xyXG5cclxuICAgICAgICBGaWxlVXBsb2FkLnJlZ2lzdGVySGFuZGxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93RmllbGRzZXQoc2VsZWN0b3I6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmhpZGVGaWVsZHNldHMoKTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNsaW1pbmFsX21hcmtldF9tb2RhbF9kaXYgPiBhcnRpY2xlID4gaGVhZGVyID4gc3BhbicpIS5pbm5lckhUTUwgPSBoZWFkZXJcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbGltaW5hbF9tYXJrZXRfbW9kYWxfZGl2ID4gYXJ0aWNsZScpIS5zY3JvbGxUb3AgPSAwXHJcbiAgICAgICAgdGhpcy5reWNGb3JtLmFjdGl2ZUZpZWxkc2V0U2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvd1JlcXVpcmVkTWFya2VyKCkge1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgc2VsZWN0Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gaW5wdXRzW2ldIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICghaW5wdXQuaWQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9JyArIGlucHV0LmlkICsgJ10nKTtcclxuICAgICAgICAgICAgaWYgKCFsYWJlbCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5wdXQucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbC5pbm5lckhUTUwuaW5kZXhPZignKicpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MICs9ICcqJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbC5pbm5lckhUTUwuaW5kZXhPZignKicpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gbGFiZWwuaW5uZXJIVE1MLnJlcGxhY2UoJyonLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFJlcXVpcmVkKGlucHV0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0SWQpPy5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJywgJ3JlcXVpcmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbW92ZVJlcXVpcmVkKGlucHV0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0SWQpPy5yZW1vdmVBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmQoc2VsZWN0b3I6IHN0cmluZywgZXZlbnROYW1lOiBzdHJpbmcsIGFjdGlvbjogKGV2dDogRXZlbnQpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzW2ldLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb24oZXZ0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRmlsZVVwbG9hZHMoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBGaWxlVXBsb2FkLmZpbGVVcGxvYWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEZpbGVVcGxvYWQuZmlsZVVwbG9hZHNbaV0uYmluZEV2ZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGlkZUZpZWxkc2V0cygpIHtcclxuICAgICAgICBsZXQgZmllbGRzZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2t5Y193aXphcmRfZm9ybSA+IGZpZWxkc2V0Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZmllbGRzZXRzW2ldLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlUmVxdWlyZWRGaWVsZHMoc2VsZWN0b3I6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yICsgJyBpbnB1dFtyZXF1aXJlZF0sICcgKyBzZWxlY3RvciArICcgc2VsZWN0W3JlcXVpcmVkXScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGlucHV0c1tpXSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNaXNzaW5nSW5wdXRGcm9tVXNlcihpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1lvdSBtdXN0IGZpbGwgaW50byB0aGlzIGZpZWxkJyxcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dE5hbWU6IGlucHV0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPScgKyBpbnB1dC5pZCArICddJykhLmlubmVySFRNTCxcclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBpbnB1dC5wYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGt5Y1ZhbGlkYXRpb25FcnJvciA9IG5ldyBLeWNWYWxpZGF0b3JFcnJvcihvYmosIHRoaXMua3ljRm9ybSk7XHJcbiAgICAgICAgICAgICAgICBreWNWYWxpZGF0aW9uRXJyb3IuaGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IGlucHV0LnBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGlucHV0LnZhbHVlLm1hdGNoKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIG5vdCB2YWxpZCBkYXRlIGZvcm1hdCwgcGxlYXNlIHVzZSBZWVlZLU1NLUREICh5ZWFyLW1vbnRoLWRhdGUpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lOiBpbnB1dC5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9JyArIGlucHV0LmlkICsgJ10nKSEuaW5uZXJIVE1MLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBpbnB1dC5wYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQga3ljVmFsaWRhdGlvbkVycm9yID0gbmV3IEt5Y1ZhbGlkYXRvckVycm9yKG9iaiwgdGhpcy5reWNGb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICBreWNWYWxpZGF0aW9uRXJyb3IuaGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc2hvd0VsZW1lbnQoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpPy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGlkZUVsZW1lbnQoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0TGFiZWwoZWxlbWVudElkOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RheF9pZF9sYWJlbCcpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc01pc3NpbmdJbnB1dEZyb21Vc2VyKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICgoaW5wdXQudHlwZSA9PSAnY2hlY2tib3gnICYmICFpbnB1dC5jaGVja2VkKSB8fCBTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZW1vdmVNaXNzaW5nSW5mbyhlcnJvckRpdklkOiBzdHJpbmcsIGZvY3VzRWxlbWVudElkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlcnJvckRpdklkKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmICghZm9jdXNFbGVtZW50SWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGZvY3VzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvY3VzRWxlbWVudElkKTtcclxuICAgICAgICBpZiAoZm9jdXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0TWlzc2luZ0luZm8oZXJyb3JEaXZJZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcsIGZvY3VzRWxlbWVudElkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlcnJvckRpdklkKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0ZXh0O1xyXG4gICAgICAgIGlmICh0ZXh0ID09ICcnKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgICAgICAgICAgaWYgKGZvY3VzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk/LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk/LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IEt5Y0NvbnRhY3RIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0NvbnRhY3QuaHRtbCc7XHJcbmltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEtZQ0Zvcm0gZnJvbSBcIi4uL0tZQ0Zvcm1cIjtcclxuaW1wb3J0IENvdW50cnlIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvQ291bnRyeUhlbHBlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0NvbnRhY3QgZXh0ZW5kcyBLeWNCYXNlIHtcclxuXHJcbiAgICB1c1RheFJlc2lkZW5jZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljQ29udGFjdEh0bWwpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXQsIGNvdW50cmllczogQ291bnRyeUhlbHBlci5Db3VudHJpZXN9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICB0aGlzLnNob3dGaWVsZHNldCgnLmt5Y0NvbnRhY3QnLCAnQ29udGFjdCBpbmZvcm1hdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuYmluZCgnI2NvdW50cnlfb2ZfdGF4X3Jlc2lkZW5jZScsICdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy51c1RheFJlc2lkZW5jZSA9IChpbnB1dC52YWx1ZS50b1VwcGVyQ2FzZSgpID09ICdVU0EnKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGVfZGl2Jyk/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0uc2V0U3RlcHMoNSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ3N0YXRlJylcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0uc2V0U3RlcHMoNilcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVxdWlyZWQoJ3N0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGVfZGl2Jyk/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHNob3dJZGVudGl0eUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWN0X25leHQnKTtcclxuICAgICAgICBpZiAoc2hvd0lkZW50aXR5QnV0dG9uKSB7XHJcbiAgICAgICAgICAgIHNob3dJZGVudGl0eUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCcua3ljQ29udGFjdCcpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y0lkZW50aXR5LnNob3coKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQgY2xhc3M9XFxcImt5Y0lkZW50aXR5IGhpZGRlblxcXCIgZGF0YS1mb3JtPVxcXCIxXFxcIj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImdpdmVuX25hbWVcXFwiPkxlZ2FsIEZpcnN0IG5hbWU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJnaXZlbl9uYW1lXFxcIiBuYW1lPVxcXCJnaXZlbl9uYW1lXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJSb25cXFwiXFxyXFxuICAgICAgICAgICAgICAgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJnaXZlbi1uYW1lXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJtaWRkbGVfbmFtZVxcXCI+TGVnYWwgTWlkZGxlIG5hbWU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJtaWRkbGVfbmFtZVxcXCIgbmFtZT1cXFwibWlkZGxlX25hbWVcXFwiXFxyXFxuICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIlxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZGl0aW9uYWwtbmFtZVxcXCI+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZmFtaWx5X25hbWVcXFwiPkxlZ2FsIExhc3QgbmFtZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcImZhbWlseV9uYW1lXFxcIiBuYW1lPVxcXCJmYW1pbHlfbmFtZVxcXCJcXHJcXG4gICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiU3dhbnNvblxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImZhbWlseS1uYW1lXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIHt7I3VubGVzcyBlZGl0fX1cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImRhdGVfb2ZfYmlydGhcXFwiPkRhdGUgb2YgYmlydGg8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcImRhdGVcXFwiIHJlcXVpcmVkIGlkPVxcXCJkYXRlX29mX2JpcnRoXFxcIiBuYW1lPVxcXCJkYXRlX29mX2JpcnRoXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCIxOTc4LTExLTI0XFxcIiBwYXR0ZXJuPVxcXCJcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVxcXCIgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJiZGF5XFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxkaXYgaWQ9XFxcImNpdGl6ZW5fb2ZfdXNhX3F1ZXN0aW9uXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNpdGl6ZW5feWVzXFxcIj5BcmUgeW91IGEgY2l0aXplbiBvZiB0aGUgVW5pdGVkIFN0YXRlcz88L2xhYmVsPlxcclxcbiAgICAgICAgPGZpZWxkc2V0PlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBpZD1cXFwiY2l0aXplbl95ZXNcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJjaXRpemVuXFxcIiB2YWx1ZT1cXFwiMVxcXCI+IFllc1xcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGxhYmVsPlxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIGlkPVxcXCJjaXRpemVuX25vXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwiY2l0aXplblxcXCIgdmFsdWU9XFxcIjBcXFwiPiBOb1xcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGZpZWxkc2V0IGlkPVxcXCJjaXRpemVuX25vX3R5cGVfb3B0aW9uc1xcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwicGVybWFuZW50X3Jlc2lkZW50XFxcIiBpZD1cXFwiY2l0aXplbl9ub190eXBlX29wdGlvbnNfMVxcXCIgdmFsdWU9XFxcIjFcXFwiLz4gR3JlZW4gQ2FyZFxcclxcbiAgICAgICAgICAgICAgICAgICAgLyBQZXJtYW5lbnQgUmVzaWRlbnRcXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwicGVybWFuZW50X3Jlc2lkZW50XFxcIiBpZD1cXFwiY2l0aXplbl9ub190eXBlX29wdGlvbnNfMlxcXCIgdmFsdWU9XFxcIjBcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgICAgIFZpc2E8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICA8L2ZpZWxkc2V0PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwidGF4X2lkX3R5cGVfb3B0aW9uc1xcXCI+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0YXhfaWRfdHlwZVxcXCI+VGF4IElkIFR5cGU8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwidGF4X2lkX3R5cGVcXFwiIG5hbWU9XFxcInRheF9pZF90eXBlXFxcIiBwbGFjZWhvbGRlcj1cXFwiVVNBX1NTTlxcXCI+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVVNBX1NTTlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVJHX0FSX0NVSVRcXFwiPkFyZ2VudGluYSBDVUlUPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVVTX1RGTlxcXCI+QXVzdHJhbGlhbiBUYXggRmlsZSBOdW1iZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBVVNfQUJOXFxcIj5BdXN0cmFsaWFuIEJ1c2luZXNzIE51bWJlcjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJPTF9OSVRcXFwiPkJvbGl2aWEgTklUPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQlJBX0NQRlxcXCI+QnJhemlsIENQRjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNITF9SVVRcXFwiPkNoaWxlIFJVVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNPTF9OSVRcXFwiPkNvbG9tYmlhIE5JVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNSSV9OSVRFXFxcIj5Db3N0YSBSaWNhIE5JVEU8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJERVVfVEFYX0lEXFxcIj5HZXJtYW55IFRheCBJRCAoSWRlbnRpZmlrYXRpb25zbnVtbWVyKTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkRPTV9STkNcXFwiPkRvbWluaWNhbiBSZXB1YmxpYyBSTkM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJFQ1VfUlVDXFxcIj5FY3VhZG9yIFJVQzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkZSQV9TUElcXFwiPkZyYW5jZSBTUEkgKFJlZmVyZW5jZSBUYXggTnVtYmVyKTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdCUl9VVFJcXFwiPlVLIFVUUiAoVW5pcXVlIFRheHBheWVyIFJlZmVyZW5jZSk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHQlJfTklOT1xcXCI+VUsgTklOTyAoTmF0aW9uYWwgSW5zdXJhbmNlIE51bWJlcik8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHVE1fTklUXFxcIj5HdWF0ZW1hbGEgTklUPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSE5EX1JUTlxcXCI+SG9uZHVyYXMgUlROPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSFVOX1RJTlxcXCI+SHVuZ2FyeSBUSU4gTnVtYmVyPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSUROX0tUUFxcXCI+SW5kb25lc2lhIEtUUDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklORF9QQU5cXFwiPkluZGlhIFBBTiBOdW1iZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJU1JfVEFYX0lEXFxcIj5Jc3JhZWwgVGF4IElEIChUZXVkYXQgWmVodXQpPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSVRBX1RBWF9JRFxcXCI+SXRhbHkgVGF4IElEIChDb2RpY2UgRmlzY2FsZSk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJKUE5fVEFYX0lEXFxcIj5KYXBhbiBUYXggSUQgKEtvaWppbiBCYW5nbyk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNRVhfUkZDXFxcIj5NZXhpY28gUkZDPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTklDX1JVQ1xcXCI+TmljYXJhZ3VhIFJVQzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5MRF9USU5cXFwiPk5ldGhlcmxhbmRzIFRJTiBOdW1iZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQQU5fUlVDXFxcIj5QYW5hbWEgUlVDPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUEVSX1JVQ1xcXCI+UGVydSBSVUM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQUllfUlVDXFxcIj5QYXJhZ3VheSBSVUM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTR1BfTlJJQ1xcXCI+U2luZ2Fwb3JlIE5SSUM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTR1BfRklOXFxcIj5TaW5nYXBvcmUgRklOPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0dQX0FTR0RcXFwiPlNpbmdhcG9yZSBBU0dEPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0dQX0lUUlxcXCI+U2luZ2Fwb3JlIElUUjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNMVl9OSVRcXFwiPkVsIFNhbHZhZG9yIE5JVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNXRV9UQVhfSURcXFwiPlN3ZWRlbiBUYXggSUQgKFBlcnNvbm51bW1lcik8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVUllfUlVUXFxcIj5VcnVndWF5IFJVVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZFTl9SSUZcXFwiPlZlbmV6dWVsYSBSSUY8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOT1RfU1BFQ0lGSUVEXFxcIj5PdGhlciBUYXggSURzPC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgaWQ9XFxcInRheF9pZF9sYWJlbFxcXCIgZm9yPVxcXCJ0YXhfaWRcXFwiPlRheCBJZCAoU1NOKTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcInRheF9pZFxcXCIgbmFtZT1cXFwidGF4X2lkXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCI2NjYtNTUtNDMyMVxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgaWQ9XFxcImNvdW50cnlfb2ZfYmlydGhfb3B0aW9uXFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvdW50cnlfb2ZfYmlydGhcXFwiPkNvdW50cnkgb2YgYmlydGg8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCBpZD1cXFwiY291bnRyeV9vZl9iaXJ0aFxcXCIgbmFtZT1cXFwiY291bnRyeV9vZl9iaXJ0aFxcXCI+XFxyXFxuICAgICAgICAgICAge3sjZWFjaCBjb3VudHJpZXN9fVxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7Y29kZX19XFxcIj57e25hbWV9fTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGlkPVxcXCJjb3VudHJ5X29mX2NpdGl6ZW5zaGlwX29wdGlvblxcXCI+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb3VudHJ5X29mX2NpdGl6ZW5zaGlwXFxcIj5Db3VudHJ5IG9mIGNpdGl6ZW5zaGlwPC9sYWJlbD5cXHJcXG4gICAgICAgIDxzZWxlY3QgcmVxdWlyZWQgaWQ9XFxcImNvdW50cnlfb2ZfY2l0aXplbnNoaXBcXFwiIG5hbWU9XFxcImNvdW50cnlfb2ZfY2l0aXplbnNoaXBcXFwiPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAge3sjZWFjaCBjb3VudHJpZXN9fVxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7Y29kZX19XFxcIj57e25hbWV9fTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGlkPVxcXCJ2aXNhX3R5cGVfb3B0aW9uXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidmlzYV90eXBlXFxcIj5WaXNhIHR5cGUgLSA8YVxcclxcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cXFwiaHR0cHM6Ly90cmF2ZWwuc3RhdGUuZ292L2NvbnRlbnQvdHJhdmVsL2VuL3VzLXZpc2FzL3Zpc2EtaW5mb3JtYXRpb24tcmVzb3VyY2VzL2FsbC12aXNhLWNhdGVnb3JpZXMuaHRtbFxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5WaXNhXFxyXFxuICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uPC9hPjwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cXFwidmlzYV90eXBlXFxcIiBuYW1lPVxcXCJ2aXNhX3R5cGVcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCMVxcXCIgc2VsZWN0ZWQ+VVNBIFZpc2EgQ2F0ZWdvcnkgQi0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkIyXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBCLTI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREFDQVxcXCI+VVNBIFZpc2EgQ2F0ZWdvcnkgREFDQTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJFMVxcXCI+VVNBIFZpc2EgQ2F0ZWdvcnkgRS0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkUyXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBFLTI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRTNcXFwiPlVTQSBWaXNhIENhdGVnb3J5IEUtMzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJGMVxcXCI+VVNBIFZpc2EgQ2F0ZWdvcnkgRi0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkc0XFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBHLTQ8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSDFCXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBILTFCPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkoxXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBKLTE8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTDFcXFwiPlVTQSBWaXNhIENhdGVnb3J5IEwtMTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPVEhFUlxcXCI+QW55IG90aGVyIFVTQSBWaXNhIENhdGVnb3J5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk8xXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBPLTE8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVE4xXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBUTi0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcInZpc2FfZXhwaXJhdGlvbl9kYXRlX29wdGlvblxcXCI+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidmlzYV9leHBpcmF0aW9uX2RhdGVcXFwiPlZpc2EgZXhwaXJhdGlvbiBkYXRlPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZGF0ZVxcXCIgaWQ9XFxcInZpc2FfZXhwaXJhdGlvbl9kYXRlXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJ2aXNhX2V4cGlyYXRpb25fZGF0ZVxcXCIgcGxhY2Vob2xkZXI9XFxcIjIwMjgtMDUtMDFcXFwiIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYV9vcHRpb25cXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImRhdGVfb2ZfZGVwYXJ0dXJlX2Zyb21fdXNhXFxcIj5EYXRlIG9mIGRlcGFydHVyZSBmcm9tIFVTQTwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImRhdGVcXFwiIGlkPVxcXCJkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgbmFtZT1cXFwiZGF0ZV9vZl9kZXBhcnR1cmVfZnJvbV91c2FcXFwiIHBsYWNlaG9sZGVyPVxcXCIyMDI4LTA1LTAxXFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImFubnVhbF9pbmNvbWVcXFwiPkFubnVhbCBIb3VzZWhvbGQgSW5jb21lPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgICAgIEFubnVhbCBob3VzZWhvbGQgaW5jb21lIGluY2x1ZGVzIGluY29tZSBmcm9tIHNvdXJjZXMgc3VjaCBhcyBlbXBsb3ltZW50LCBhbGltb255LCBzb2NpYWwgc2VjdXJpdHksXFxyXFxuICAgICAgICAgICAgaW52ZXN0bWVudCBpbmNvbWUsIGV0Yy5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPHNlbGVjdCBuYW1lPVxcXCJhbm51YWxfaW5jb21lXFxcIiBpZD1cXFwiYW5udWFsX2luY29tZVxcXCI+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj48L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCIxXFxcIj4wIC0gJDIwLDAwMDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjJcXFwiPiQyMCwwMDAgLSAkNDksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiM1xcXCI+JDUwLDAwMCAtICQ5OSw5OTk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI0XFxcIj4kMTAwLDAwMCAtICQ0OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiNVxcXCI+JDUwMCwwMDAgLSAkOTk5LDk5OTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjZcXFwiPiQxLDAwMCwwMDAgLSAkOSw5OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJsaXF1aWRfbmV0X3dvcnRoXFxcIj5MaXF1aWQgQXNzZXRzPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPkxpcXVpZCBhc3NldHMgaXMgeW91ciBuZXQgd29ydGggbWludXMgYXNzZXRzIHRoYXQgY2Fubm90IGJlXFxyXFxuICAgICAgICAgICAgY29udmVydGVkIHF1aWNrbHkgYW5kIGVhc2lseSBpbnRvIGNhc2gsIHN1Y2ggYXMgcmVhbCBlc3RhdGUsIGJ1c2luZXNzIGVxdWl0eSxcXHJcXG4gICAgICAgICAgICBwZXJzb25hbCBwcm9wZXJ0eSBhbmQgYXV0b21vYmlsZXMsIGV4cGVjdGVkIGluaGVyaXRhbmNlcywgYXNzZXRzIGVhcm1hcmtlZCBmb3JcXHJcXG4gICAgICAgICAgICBvdGhlciBwdXJwb3NlcywgYW5kIGludmVzdG1lbnRzIG9yIGFjY291bnRzIHN1YmplY3QgdG8gc3Vic3RhbnRpYWwgcGVuYWx0aWVzXFxyXFxuICAgICAgICAgICAgaWYgdGhleSB3ZXJlIHNvbGQgb3IgaWYgYXNzZXRzIHdlcmUgd2l0aGRyYXduIGZyb20gdGhlbS5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPHNlbGVjdCBuYW1lPVxcXCJsaXF1aWRfbmV0X3dvcnRoXFxcIiByZXF1aXJlZCBpZD1cXFwibGlxdWlkX25ldF93b3J0aFxcXCI+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj48L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCIxXFxcIj4wIC0gJDIwLDAwMDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjJcXFwiPiQyMCwwMDAgLSAkNDksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiM1xcXCI+JDUwLDAwMCAtICQ5OSw5OTk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI0XFxcIj4kMTAwLDAwMCAtICQ0OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiNVxcXCI+JDUwMCwwMDAgLSAkOTk5LDk5OTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjFcXFwiPiQxLDAwMCwwMDAgLSAkOSw5OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJmdW5kaW5nX3NvdXJjZVxcXCI+RnVuZGluZyBzb3VyY2U8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiZnVuZGluZ19zb3VyY2VcXFwiIG5hbWU9XFxcImZ1bmRpbmdfc291cmNlXFxcIlxcclxcbiAgICAgICAgICAgICAgICBtdWx0aXBsZSBzaXplPVxcXCI0XFxcIiBhcmlhLWxhYmVsPVxcXCJzaXplIDMgc2VsZWN0XFxcIj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJlbXBsb3ltZW50X2luY29tZVxcXCI+RW1wbG95bWVudCBpbmNvbWU8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJpbnZlc3RtZW50c1xcXCI+SW52ZXN0bWVudHM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJpbmhlcml0YW5jZVxcXCI+SW5oZXJpdGFuY2U8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJidXNpbmVzc19pbmNvbWVcXFwiPkJ1c2luZXNzIGluY29tZTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInNhdmluZ3NcXFwiPlNhdmluZ3M8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJmYW1pbHlcXFwiPkZhbWlseTwvb3B0aW9uPlxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICB7ey91bmxlc3N9fVxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJpZGVudGl0eV9wcmV2XFxcIj5QcmV2aW91czogQ29udGFjdDwvYnV0dG9uPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJpZGVudGl0eV9uZXh0XFxcIj5OZXh0OiBUcnVzdGVkIGNvbnRhY3RzPC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcbmltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEt5Y0lkZW50aXR5SHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljSWRlbnRpdHkuaHRtbFwiO1xyXG5pbXBvcnQgQ291bnRyeUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Db3VudHJ5SGVscGVyXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljSWRlbnRpdHkgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGVkaXQgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihreWNGb3JtOiBLWUNGb3JtKSB7XHJcbiAgICAgICAgc3VwZXIoa3ljRm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmVkaXQgPSBlZGl0O1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljSWRlbnRpdHlIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXQsIGNvdW50cmllczogQ291bnRyeUhlbHBlci5Db3VudHJpZXN9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5reWNDb250YWN0LnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0VsZW1lbnQoJ2NpdGl6ZW5fb2ZfdXNhX3F1ZXN0aW9uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ3RheF9pZF90eXBlX29wdGlvbnMnKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRMYWJlbCgndGF4X2lkX2xhYmVsJywgJ1NTTicpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ2NpdGl6ZW5fb2ZfdXNhX3F1ZXN0aW9uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TGFiZWwoJ3RheF9pZF9sYWJlbCcsICdOYXRpb25hbCBUYXggSWQgKFNTTiknKTtcclxuICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgndGF4X2lkX3R5cGVfb3B0aW9ucycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2hvd0ZpZWxkc2V0KCcua3ljSWRlbnRpdHknLCAnSWRlbnRpdHknKTtcclxuICAgICAgICB0aGlzLnNob3dFbGVtZW50KCdjb3VudHJ5X29mX2NpdGl6ZW5zaGlwX29wdGlvbicpO1xyXG4gICAgICAgIGxldCBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvdW50cnlfb2ZfY2l0aXplbnNoaXAnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICBpZiAoY291bnRyeV9vZl9jaXRpemVuc2hpcCkge1xyXG4gICAgICAgICAgICBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwLm9wdGlvbnNbMV0uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgnI2NpdGl6ZW5feWVzJywgJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGF4SWRUeXBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RheF9pZF90eXBlJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGF4SWRUeXBlKSB0YXhJZFR5cGUudmFsdWUgPSAnVVNBX1NTTic7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNvdW50cnlfb2ZfY2l0aXplbnNoaXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY291bnRyeV9vZl9jaXRpemVuc2hpcCcpIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgY291bnRyeV9vZl9jaXRpemVuc2hpcC5vcHRpb25zWzFdLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwLnZhbHVlID0gJ1VTQSc7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlRWxlbWVudCgnY2l0aXplbl9ub190eXBlX29wdGlvbnMnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ3Zpc2FfdHlwZV9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ2NvdW50cnlfb2ZfY2l0aXplbnNoaXBfb3B0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdjb3VudHJ5X29mX2JpcnRoJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCd2aXNhX3R5cGUnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVxdWlyZWQoJ3Zpc2FfZXhwaXJhdGlvbl9kYXRlJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYScpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RheF9pZF9sYWJlbCcpIS5pbm5lckhUTUwgPSAnU1NOJ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQ2l0aXplbkVycm9yTWVzc2FnZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgICAgICB0aGlzLmJpbmQoJyNjaXRpemVuX25vJywgJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFbGVtZW50KCdjaXRpemVuX25vX3R5cGVfb3B0aW9ucycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgnY291bnRyeV9vZl9jaXRpemVuc2hpcF9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ2NvdW50cnlfb2ZfYmlydGgnKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YXhfaWRfbGFiZWwnKSEuaW5uZXJIVE1MID0gJ1NTTidcclxuICAgICAgICAgICAgICAgIGxldCBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvdW50cnlfb2ZfY2l0aXplbnNoaXAnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGNvdW50cnlfb2ZfY2l0aXplbnNoaXAub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwLm9wdGlvbnNbMV0uZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNpdGl6ZW5FcnJvck1lc3NhZ2UoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKCcjY2l0aXplbl9ub190eXBlX29wdGlvbnNfMScsICdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgnY291bnRyeV9vZl9jaXRpemVuc2hpcF9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ3Zpc2FfdHlwZV9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ2NvdW50cnlfb2ZfYmlydGgnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVxdWlyZWQoJ3Zpc2FfdHlwZScpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCd2aXNhX2V4cGlyYXRpb25fZGF0ZScpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLmJpbmQoJyNjaXRpemVuX25vX3R5cGVfb3B0aW9uc18yJywgJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFbGVtZW50KCd2aXNhX3R5cGVfb3B0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFbGVtZW50KCdjb3VudHJ5X29mX2NpdGl6ZW5zaGlwX29wdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1aXJlZCgnY291bnRyeV9vZl9iaXJ0aCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1aXJlZCgnY291bnRyeV9vZl9jaXRpemVuc2hpcCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1aXJlZCgndmlzYV90eXBlJylcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ3Zpc2FfZXhwaXJhdGlvbl9kYXRlJylcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ2RhdGVfb2ZfZGVwYXJ0dXJlX2Zyb21fdXNhJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgnI3Zpc2FfdHlwZScsICdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlID09ICdCMScgfHwgaW5wdXQudmFsdWUgPT0gJ0IyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgnZGF0ZV9vZl9kZXBhcnR1cmVfZnJvbV91c2Ffb3B0aW9uJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVFbGVtZW50KCdkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYV9vcHRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuYmluZEJ1dHRvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhpZGVDaXRpemVuRXJyb3JNZXNzYWdlKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaXRpemVuX3llcycpIS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRfZXJyb3JfY2l0aXplbl95ZXMnKTtcclxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSBlcnJvck1lc3NhZ2UucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kQnV0dG9ucygpIHtcclxuICAgICAgICBsZXQgc2hvd0NvbnRhY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWRlbnRpdHlfcHJldicpO1xyXG4gICAgICAgIHNob3dDb250YWN0QnV0dG9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y0NvbnRhY3Quc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBzaG93RGlzY2xvc3VyZXNCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWRlbnRpdHlfbmV4dCcpO1xyXG4gICAgICAgIHNob3dEaXNjbG9zdXJlc0J1dHRvbj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cygpKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCcua3ljSWRlbnRpdHknKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y1RydXN0ZWRDb250YWN0LnNob3coKTtcclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlSW5wdXRzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVkaXQpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBsZXQgY2l0aXplbl95ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2l0aXplbl95ZXMnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBjaXRpemVuX25vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NpdGl6ZW5fbm8nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMua3ljRm9ybS5reWNDb250YWN0LnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgIGNpdGl6ZW5feWVzLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2l0aXplbl9uby5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaXRpemVuX3llcy5jaGVja2VkICYmICFjaXRpemVuX25vLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgbXVzdCBzZWxlY3QgZWl0aGVyIG9wdGlvbicsXHJcbiAgICAgICAgICAgICAgICBpbnB1dE5hbWU6ICdjaXRpemVuX3llcycsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsW2Zvcj1jaXRpemVuX3llc10nKSEuaW5uZXJIVE1MXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBreWNWYWxpZGF0aW9uRXJyb3IgPSBuZXcgS3ljVmFsaWRhdG9yRXJyb3Iob2JqLCB0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgICAgICAgICBreWNWYWxpZGF0aW9uRXJyb3IuaGFuZGxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBncmVlbkNhcmRPcHRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2l0aXplbl9ub190eXBlX29wdGlvbnNfMScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IHZpc2FPcHRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2l0aXplbl9ub190eXBlX29wdGlvbnNfMicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGNpdGl6ZW5fbm8uY2hlY2tlZCAmJiAhZ3JlZW5DYXJkT3B0aW9uLmNoZWNrZWQgJiYgIXZpc2FPcHRpb24uY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBsZXQgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1lvdSBtdXN0IHNlbGVjdCBlaXRoZXIgb3B0aW9uLCBcIkdyZWVuIENhcmQgLyBQZXJtYW5lbnQgUmVzaWRlbnRcIiBvciBcIlZpc2FcIicsXHJcbiAgICAgICAgICAgICAgICBpbnB1dE5hbWU6ICdjaXRpemVuX25vJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJydcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGt5Y1ZhbGlkYXRpb25FcnJvciA9IG5ldyBLeWNWYWxpZGF0b3JFcnJvcihvYmosIHRoaXMua3ljRm9ybSk7XHJcbiAgICAgICAgICAgIGt5Y1ZhbGlkYXRpb25FcnJvci5oYW5kbGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNEaXNjbG9zdXJlcyBoaWRkZW5cXFwiIGRhdGEtZm9ybT1cXFwiMVxcXCI+XFxyXFxuICAgIHt7I3VubGVzcyBlZGl0fX1cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImVtcGxveW1lbnRfc3RhdHVzXFxcIj5FbXBsb3ltZW50IHN0YXR1czwvbGFiZWw+XFxyXFxuICAgICAgICA8c2VsZWN0IGlkPVxcXCJlbXBsb3ltZW50X3N0YXR1c1xcXCIgcmVxdWlyZWQgbmFtZT1cXFwiZW1wbG95bWVudF9zdGF0dXNcXFwiPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiZW1wbG95ZWRcXFwiPkVtcGxveWVkPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwidW5lbXBsb3llZFxcXCI+VW5lbXBsb3llZDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInJldGlyZWRcXFwiPlJldGlyZWQ8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJzdHVkZW50XFxcIj5TdHVkZW50PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbXBsb3llcl9uYW1lXFxcIj5FbXBsb3llciBuYW1lPC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBuYW1lPVxcXCJlbXBsb3llcl9uYW1lXFxcIiBpZD1cXFwiZW1wbG95ZXJfbmFtZVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImVtcGxveWVyX2FkZHJlc3NcXFwiPkVtcGxveWVyIGFkZHJlc3M8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImVtcGxveWVyX2FkZHJlc3NcXFwiIGlkPVxcXCJlbXBsb3llcl9hZGRyZXNzXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZW1wbG95bWVudF9wb3NpdGlvblxcXCI+T2NjdXBhdGlvbiAvIEpvYiB0aXRsZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiZW1wbG95bWVudF9wb3NpdGlvblxcXCIgaWQ9XFxcImVtcGxveW1lbnRfcG9zaXRpb25cXFwiIGF1dG9jb21wbGV0ZT1cXFwib3JnYW5pemF0aW9uLXRpdGxlXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICB7ey91bmxlc3N9fVxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkaXNjbG9zdXJlX3NlbGVjdGlvbnNcXFwiPlxcclxcbiAgICAgICAgRG8gYW55IG9mIHRoZSBmb2xsb3dpbmcgYXBwbHkgdG8geW91IG9yIGEgbWVtYmVyIG9mIHlvdXIgaW1tZWRpYXRlIGZhbWlseT9cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImlzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmFcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBpZD1cXFwiaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYVxcXCIgbmFtZT1cXFwiaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVxcXCJzd2l0Y2hcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIEFmZmlsaWF0ZWQgb3Igd29yayB3aXRoIGEgVVMgcmVnaXN0ZXJlZCBicm9rZXItZGVhbGVyIG9yXFxyXFxuICAgICAgICAgICAgICAgIEZJTlJBLlxcclxcbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImV4cGxhaW5cXFwiPkFyZSB5b3Ugb3IgYW4gaW1tZWRpYXRlIGZhbWlseSBtZW1iZXIgYWZmaWxpYXRlZCB3aXRoIG9yIGVtcGxveWVkIGJ5IGEgc3RvY2tcXHJcXG4gICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLCByZWd1bGF0b3J5IGJvZHksIG1lbWJlciBmaXJtIG9mIGFuIGV4Y2hhbmdlLCBGSU5SQSBvciBhIG11bmljaXBhbCBzZWN1cml0aWVzXFxyXFxuICAgICAgICAgICAgICAgICAgICBicm9rZXItZGVhbGVyPzwvc21hbGw+XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImlzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmFfZXh0cmFcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJpc19jb250cm9sX3BlcnNvblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJpc19jb250cm9sX3BlcnNvblxcXCIgbmFtZT1cXFwiaXNfY29udHJvbF9wZXJzb25cXFwiIHJvbGU9XFxcInN3aXRjaFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgU2VuaW9yIGV4ZWN1dGl2ZSBhdCBvciBhIDEwJSBvciBncmVhdGVyIHNoYXJlaG9sZGVyIG9mIGEgcHVibGljbHkgdHJhZGVkIGNvbXBhbnkuXFxyXFxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cXFwiZXhwbGFpblxcXCI+QXJlIHlvdSBvciBhbiBpbW1lZGlhdGUgZmFtaWx5IG1lbWJlciBhbiBvZmZpY2VyIG9yIDEwJSBvciBncmVhdGVyIHNoYXJlaG9sZGVyIG9mXFxyXFxuICAgICAgICAgICAgICAgICAgICBhIHB1YmxpY2x5IHRyYWRlZCBjb21wYW55LCBzdWJqZWN0IHRvIHRoZSBVUyBTZWN1cml0aWVzIEV4Y2hhbmdlIEFjdCAxOTM0Pzwvc21hbGw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImlzX2NvbnRyb2xfcGVyc29uX2V4dHJhXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiaXNfcG9saXRpY2FsbHlfZXhwb3NlZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJpc19wb2xpdGljYWxseV9leHBvc2VkXFxcIiBuYW1lPVxcXCJpc19wb2xpdGljYWxseV9leHBvc2VkXFxcIiByb2xlPVxcXCJzd2l0Y2hcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIEkgYW0gYSBzZW5pb3IgcG9saXRpY2FsIGZpZ3VyZS5cXHJcXG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVxcXCJleHBsYWluXFxcIj5BcmUgeW91IGN1cnJlbnRseSBvciBmb3JtZXJseSBhIFBvbGl0aWNhbGx5IEV4cG9zZWQgUGVyc29uIG9yIFB1YmxpYyBPZmZpY2lhbFxcclxcbiAgICAgICAgICAgICAgICAgICAgKFBFUCk/IDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9JUUyJTgwJTlDUG9saXRpY2FsbHkrRXhwb3NlZCtQZXJzb24lRTIlODAlOUQrKFBFUClcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPldoYXQgaXMgUEVQPzwvYT4gPC9hPjwvc21hbGw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImlzX3BvbGl0aWNhbGx5X2V4cG9zZWRfZXh0cmFcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWRcXFwiIG5hbWU9XFxcImltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZFxcXCIgcm9sZT1cXFwic3dpdGNoXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICBJIGFtIGEgZmFtaWx5IG1lbWJlciBvciByZWxhdGl2ZSBvZiBhIHNlbmlvciBwb2xpdGljYWwgZmlndXJlLlxcclxcbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImV4cGxhaW5cXFwiPkFyZSB5b3UgYW4gaW1tZWRpYXRlIGZhbWlseSBtZW1iZXIgY3VycmVudGx5IG9yIGZvcm1lcmx5IGEgUG9saXRpY2FsbHkgRXhwb3NlZFxcclxcbiAgICAgICAgICAgICAgICAgICAgUGVyc29uIG9yIFB1YmxpYyBPZmZpY2lhbCAoUEVQKT8gPGFcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lRTIlODAlOUNQb2xpdGljYWxseStFeHBvc2VkK1BlcnNvbiVFMiU4MCU5RCsoUEVQKVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPldoYXQgaXMgUEVQPzwvYT48L3NtYWxsPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWRfZXh0cmFcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJub25lX2Fib3ZlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcIm5vbmVfYWJvdmVcXFwiIG5hbWU9XFxcIm5vbmVfYWJvdmVcXFwiIHJvbGU9XFxcInN3aXRjaFxcXCI+PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICBOb25lIG9mIHRoZSBhYm92ZSBhcHBseSB0byBtZSBvciBteSBmYW1pbHkuXFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwibm9uZV9hYm92ZV9lcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJkaXNjbG9zdXJlc19wcmV2XFxcIj5QcmV2aW91czogVHJ1c3RlZCBjb250YWN0PC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcImRpc2Nsb3N1cmVzX25leHRcXFwiPk5leHQ6IEFncmVlbWVudHM8L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGlkPVxcXCJhZmZpbGlhdGVfb3JfY29udHJvbGxlZFxcXCI+XFxyXFxuICAgIDxkaXY+WW91IG5lZWQgdG8gZmlsbCBpbiB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb21wYW55X25hbWVcXFwiPkNvbXBhbnkgbmFtZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiY29tcGFueV9uYW1lXFxcIiByZXF1aXJlZCBpZD1cXFwiY29tcGFueV9uYW1lXFxcIiBhdXRvY29tcGxldGU9XFxcIm9yZ2FuaXphdGlvblxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlfc3RyZWV0X2FkZHJlc3NcXFwiPkNvbXBhbnkgc3RyZWV0IGFkZHJlc3M8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfc3RyZWV0X2FkZHJlc3NcXFwiIHJlcXVpcmVkIGlkPVxcXCJjb21wYW55X3N0cmVldF9hZGRyZXNzXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29tcGFueV9jaXR5XFxcIj5Db21wYW55IGNpdHk8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfY2l0eVxcXCIgcmVxdWlyZWQgaWQ9XFxcImNvbXBhbnlfY2l0eVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlfc3RhdGVcXFwiPkNvbXBhbnkgc3RhdGU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfc3RhdGVcXFwiIHJlcXVpcmVkIGlkPVxcXCJjb21wYW55X3N0YXRlXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29tcGFueV9jb3VudHJ5XFxcIj5Db21wYW55IGNvdW50cnk8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiY29tcGFueV9jb3VudHJ5XFxcIiByZXF1aXJlZCBuYW1lPVxcXCJjb21wYW55X2NvdW50cnlcXFwiPlxcclxcbiAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2NvZGV9fVxcXCI+e3tuYW1lfX08L29wdGlvbj5cXHJcXG4gICAgICAgICAgICB7ey9lYWNofX1cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlfY29tcGxpYW5jZV9lbWFpbFxcXCI+Q29tcGFueSBjb21wbGlhbmNlIG9mZmljZXIgZW1haWw8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfY29tcGxpYW5jZV9lbWFpbFxcXCIgcmVxdWlyZWQgaWQ9XFxcImNvbXBhbnlfY29tcGxpYW5jZV9lbWFpbFxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgICAgIEluIGFjY29yZGFuY2Ugd2l0aCBhcHBsaWNhYmxlIEZJTlJBIHJ1bGVzLCB1c2VyIHdpbGwgbmVlZCB0byBvYnRhaW4gYSBsZXR0ZXIgd3JpdHRlblxcclxcbiAgICAgICAgICAgIGFuZCBzaWduZWQgYnkgYSBjb21wbGlhbmNlIG9mZmljZXIgb24gY29tcGFueSBsZXR0ZXJoZWFkIGV4cGxpY2l0bHkgZ3JhbnRpbmcgcGVybWlzc2lvbiBmb3JcXHJcXG4gICAgICAgICAgICB0aGUgYXBwbGljYW50IHRvIGNhcnJ5IHRoZSBhY2NvdW50IGFuZCBleHBsaWNpdGx5IHN0YXRpbmcgd2hldGhlciBvciBub3QgdGhlIGZpcm0gcmVxdWlyZXNcXHJcXG4gICAgICAgICAgICBhY2Nlc3MgdG8gZHVwbGljYXRlIGFjY291bnQgc3RhdGVtZW50cyBhbmQvb3IgdHJhZGUgY29uZmlybWF0aW9ucy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBJZiB0aGUgZmlybSB3b3VsZCBsaWtlIG9ubGluZSBhY2Nlc3MgeW91ciBkdXBsaWNhdGUgYWNjb3VudCBzdGF0ZW1lbnRzIGFuZC9vciB0cmFkZSBjb25maXJtYXRpb25zLFxcclxcbiAgICAgICAgICAgIGluY2x1ZGUgaW4gdGhlIGxldHRlciB0aGUgYXBwbGljYW50J3MgZnVsbCBuYW1lIGFuZCB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGZvciB0aGUgaW50ZXJlc3RlZFxcclxcbiAgICAgICAgICAgIHBhcnR5OiBGaXJzdCBhbmQgbGFzdCBuYW1lLCB0aXRsZSwgZW1haWwgYWRkcmVzcywgdGVsZXBob25lIG51bWJlci5cXHJcXG5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiYWNjb3VudF9hcHByb3ZhbF9sZXR0ZXJcXFwiIFxcXCJBY2NvdW50IGFwcHJvdmFsIGxldHRlclxcXCJ9fX1cXHJcXG5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cXHJcXG5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5pbXBvcnQgS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkSHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkLmh0bWxcIjtcclxuaW1wb3J0IENvdW50cnlIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvQ291bnRyeUhlbHBlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZCBleHRlbmRzIEt5Y0Jhc2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCBreWNBZmZpbGlhdGVPckNvbnRyb2xsZWRUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNBZmZpbGlhdGVPckNvbnRyb2xsZWRIdG1sKVxyXG4gICAgICAgIHJldHVybiBreWNBZmZpbGlhdGVPckNvbnRyb2xsZWRUZW1wbGF0ZSh7Y291bnRyaWVzOiBDb3VudHJ5SGVscGVyLkNvdW50cmllc30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuYmluZEZpbGVVcGxvYWRzKCk7XHJcblxyXG4gICAgICAgIGxldCBjb21wYW55X2NvdW50cnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29tcGFueV9jb3VudHJ5JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBjb21wYW55X2NvdW50cnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdCA9IGV2dC50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3QudmFsdWUgPT09ICdVU0EnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlcXVpcmVkKCdjb21wYW55X3N0YXRlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdjb21wYW55X3N0YXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZSgpIHtcclxuICAgICAgICBsZXQgY29tcGFueV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbXBhbnlfbmFtZScpO1xyXG4gICAgICAgIGlmICghY29tcGFueV9uYW1lKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVSZXF1aXJlZEZpZWxkcygnI2FmZmlsaWF0ZV9vcl9jb250cm9sbGVkJylcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBpZD1cXFwiaW1tZWRpYXRlX2ZhbWlseVxcXCI+XFxyXFxuICAgIDxkaXY+U2luY2UgeW91IGNob3NlIHRoYXQgeW91ciBpbW1lZGlhdGUgZmFtaWx5IG1lbWJlciwgeW91IG5lZWQgdG8gZmlsbCBpbiB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJkaXNjbG9zdXJlX2dpdmVuX25hbWVcXFwiPkdpdmVuIG5hbWUgb2YgcG9saXRpY2FsIHBlcnNvbjwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiZGlzY2xvc3VyZV9naXZlbl9uYW1lXFxcIiBpZD1cXFwiZGlzY2xvc3VyZV9naXZlbl9uYW1lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZGlzY2xvc3VyZV9mYW1pbHlfbmFtZVxcXCI+RmFtaWx5IG5hbWUgb2YgcG9saXRpY2FsIHBlcnNvbjwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiZGlzY2xvc3VyZV9mYW1pbHlfbmFtZVxcXCIgaWQ9XFxcImRpc2Nsb3N1cmVfZmFtaWx5X25hbWVcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5pbXBvcnQgS3ljSW1tZWRpYXRlRmFtaWx5SHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljSW1tZWRpYXRlRmFtaWx5Lmh0bWxcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLeWNJbW1lZGlhdGVGYW1pbHkgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCBreWNJbW1lZGlhdGVGYW1pbHlUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNJbW1lZGlhdGVGYW1pbHlIdG1sKTtcclxuICAgICAgICByZXR1cm4ga3ljSW1tZWRpYXRlRmFtaWx5VGVtcGxhdGUoe30pXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKCkge1xyXG4gICAgICAgIGxldCBkaXNjbG9zdXJlX2dpdmVuX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlzY2xvc3VyZV9naXZlbl9uYW1lJylcclxuICAgICAgICBpZiAoIWRpc2Nsb3N1cmVfZ2l2ZW5fbmFtZSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUmVxdWlyZWRGaWVsZHMoJyNpbW1lZGlhdGVfZmFtaWx5JylcclxuICAgIH1cclxufSIsImltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEtZQ0Zvcm0gZnJvbSBcIi4uL0tZQ0Zvcm1cIjtcclxuaW1wb3J0IEt5Y0Rpc2Nsb3N1cmVIdG1sIGZyb20gXCIuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNEaXNjbG9zdXJlcy5odG1sXCI7XHJcbmltcG9ydCBLeWNBZmZpbGlhdGVPckNvbnRyb2xsZWQgZnJvbSBcIi4vS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkXCI7XHJcbmltcG9ydCBLeWNJbW1lZGlhdGVGYW1pbHkgZnJvbSBcIi4vS3ljSW1tZWRpYXRlRmFtaWx5XCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRGlzY2xvc3VyZXMgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGt5Y0FmZmlsaWF0ZWRPckNvbnRyb2xsZWQ6IEt5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZDtcclxuICAgIGt5Y0ltbWVkaWF0ZUZhbWlseTogS3ljSW1tZWRpYXRlRmFtaWx5O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuXHJcbiAgICAgICAgdGhpcy5reWNBZmZpbGlhdGVkT3JDb250cm9sbGVkID0gbmV3IEt5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZCh0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgICAgIHRoaXMua3ljSW1tZWRpYXRlRmFtaWx5ID0gbmV3IEt5Y0ltbWVkaWF0ZUZhbWlseSh0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW5kZXIoZWRpdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y0Rpc2Nsb3N1cmVIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXR9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBpZiAodGhpcy5reWNGb3JtLnN0ZXBzID09IDUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc2Nsb3N1cmVzX25leHQnKSEuaW5uZXJUZXh0ID0gJ05leHQ6IEFncmVlbWVudHMnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXNjbG9zdXJlc19uZXh0JykhLmlubmVyVGV4dCA9ICdOZXh0OiBVcGxvYWQgZG9jdW1lbnRzJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaG93RmllbGRzZXQoJy5reWNEaXNjbG9zdXJlcycsICdEaXNjbG9zdXJlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG5cclxuICAgICAgICBsZXQgaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQWZmaWxpYXRlZE9yQ29udHJvbENvbXBvbmVudCgnaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgaXNfY29udHJvbF9wZXJzb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaXNfY29udHJvbF9wZXJzb24nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlzX2NvbnRyb2xfcGVyc29uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQWZmaWxpYXRlZE9yQ29udHJvbENvbXBvbmVudCgnaXNfY29udHJvbF9wZXJzb24nKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFBlcCgnaW1tZWRpYXRlX2ZhbWlseV9leHBvc2VkJylcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgaXNfcG9saXRpY2FsbHlfZXhwb3NlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpc19wb2xpdGljYWxseV9leHBvc2VkJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpc19wb2xpdGljYWxseV9leHBvc2VkPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51bmNoZWNrKCdpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWQnKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBub25lX2Fib3ZlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vbmVfYWJvdmUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIG5vbmVfYWJvdmU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1pc3NpbmdJbmZvKCdub25lX2Fib3ZlX2Vycm9yJyk7XHJcbiAgICAgICAgICAgIG5vbmVfYWJvdmUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgcHJldiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXNjbG9zdXJlc19wcmV2Jyk7XHJcbiAgICAgICAgcHJldj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNUcnVzdGVkQ29udGFjdC5zaG93KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBuZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc2Nsb3N1cmVzX25leHQnKTtcclxuICAgICAgICBuZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlRmllbGRzKCkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5zdGVwcyA9PSA1KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljQWNjb3VudEFncmVlbWVudC5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljVXBsb2FkLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZEFmZmlsaWF0ZWRPckNvbnRyb2xDb21wb25lbnQoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoZWxlbWVudElkID09ICdpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhJykge1xyXG4gICAgICAgICAgICB0aGlzLnVuY2hlY2soJ2lzX2NvbnRyb2xfcGVyc29uJylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVuY2hlY2soJ2lzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmEnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGV4dHJhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkICsgJ19leHRyYScpO1xyXG4gICAgICAgIGlmICghZXh0cmEpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBleHRyYS5pbm5lckhUTUwgPSB0aGlzLmt5Y0FmZmlsaWF0ZWRPckNvbnRyb2xsZWQucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljQWZmaWxpYXRlZE9yQ29udHJvbGxlZC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXh0cmEuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZFBlcChlbGVtZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQgPT0gJ2ltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCcpIHtcclxuICAgICAgICAgICAgdGhpcy51bmNoZWNrKCdpc19wb2xpdGljYWxseV9leHBvc2VkJylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVuY2hlY2soJ2ltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBsZXQgZXh0cmEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQgKyAnX2V4dHJhJyk7XHJcbiAgICAgICAgaWYgKCFleHRyYSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGV4dHJhLmlubmVySFRNTCA9IHRoaXMua3ljSW1tZWRpYXRlRmFtaWx5LnJlbmRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmt5Y0ltbWVkaWF0ZUZhbWlseS5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXh0cmEuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdW5jaGVjayhlbGVtZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBleHRyYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCArICdfZXh0cmEnKSE7XHJcbiAgICAgICAgZXh0cmEuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUZpZWxkcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVSZXF1aXJlZEZpZWxkcygnLmt5Y0Rpc2Nsb3N1cmVzJykpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMua3ljSW1tZWRpYXRlRmFtaWx5LnZhbGlkYXRlKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMua3ljQWZmaWxpYXRlZE9yQ29udHJvbGxlZC52YWxpZGF0ZSgpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCBpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmEnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBpc19jb250cm9sX3BlcnNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpc19jb250cm9sX3BlcnNvbicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGlzX3BvbGl0aWNhbGx5X2V4cG9zZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaXNfcG9saXRpY2FsbHlfZXhwb3NlZCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBub25lX2Fib3ZlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vbmVfYWJvdmUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoIW5vbmVfYWJvdmUuY2hlY2tlZCAmJiAhaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYS5jaGVja2VkICYmICFpc19jb250cm9sX3BlcnNvbi5jaGVja2VkXHJcbiAgICAgICAgICAgICYmICFpc19wb2xpdGljYWxseV9leHBvc2VkLmNoZWNrZWQgJiYgIWltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZC5jaGVja2VkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ25vbmVfYWJvdmVfZXJyb3InLCAnWW91IG11c3Qgc2VsZWN0LCBcIk5vbmUgb2YgdGhlIGFib3ZlIGFwcGx5IHRvIG1lIG9yIG15IGZhbWlseS5cIiBpZiBub3RoaW5nIGlzIHNlbGVjdGVkJywgJ25vbmVfYWJvdmUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vbmVfYWJvdmUuY2hlY2tlZCAmJiAoaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYS5jaGVja2VkIHx8IGlzX2NvbnRyb2xfcGVyc29uLmNoZWNrZWRcclxuICAgICAgICAgICAgfHwgaXNfcG9saXRpY2FsbHlfZXhwb3NlZC5jaGVja2VkIHx8IGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZC5jaGVja2VkXHJcbiAgICAgICAgKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE1pc3NpbmdJbmZvKCdub25lX2Fib3ZlX2Vycm9yJywgJ1lvdSBjYW5ub3QgaGF2ZSBcIk5vbmUgb2YgdGhlIGFib3ZlIGFwcGx5IHRvIG1lIG9yIG15IGZhbWlseS5cIiBzZWxlY3RlZCBhbmQgb3RoZXIgb3B0aW9ucyBzZWxlY3RlZC4gUGxlYXNlIHNlbGVjdCBvbmx5IG9uZScsICdub25lX2Fib3ZlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNBY2NvdW50QWdyZWVtZW50IGhpZGRlblxcXCIgZGF0YS1mb3JtPVxcXCIxXFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwia3ljQWNjb3VudEFncmVlbWVudEdyaWRcXFwiPlxcclxcbiAgICAgICAgPGRpdiBpZD1cXFwiYWNjb3VudF9hZ3JlZW1lbnRfZXJyb3JcXFwiIGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJhY2NvdW50X2FncmVlbWVudFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcImFjY291bnRfYWdyZWVtZW50XFxcIiBpZD1cXFwiYWNjb3VudF9hZ3JlZW1lbnRcXFwiIHZhbHVlPVxcXCIxXFxcIi8+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYWNjb3VudF9hZ3JlZW1lbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgSSBhZ3JlZSB0byA8YSBocmVmPVxcXCJodHRwczovL2ZpbGVzLmFscGFjYS5tYXJrZXRzL2Rpc2Nsb3N1cmVzL2xpYnJhcnkvQWNjdEFwcE1hcmdpbkFuZEN1c3RBZ210LnBkZlxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPkFscGFjYSBDdXN0b21lciBBZ3JlZW1lbnQ8L2E+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcImN1c3RvbWVyX2FncmVlbWVudF9lcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImN1c3RvbWVyX2FncmVlbWVudFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcImN1c3RvbWVyX2FncmVlbWVudFxcXCIgaWQ9XFxcImN1c3RvbWVyX2FncmVlbWVudFxcXCIgdmFsdWU9XFxcIjFcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjdXN0b21lcl9hZ3JlZW1lbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tZXIgQWdyZWVtZW50IEFja25vd2xlZGdlbWVudDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgSSBoYXZlIHJlYWQsIHVuZGVyc3Rvb2QsIGFuZCBhZ3JlZSB0byBiZSBib3VuZCBieSBBbHBhY2EgU2VjdXJpdGllcyBMTEMgYW5kIExpbWluYWwubWFya2V0IEluYy5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRlcm1zLFxcclxcbiAgICAgICAgICAgICAgICAgICAgYW5kIGFsbCBvdGhlciB0ZXJtcywgZGlzY2xvc3VyZXMgYW5kIGRpc2NsYWltZXJzIGFwcGxpY2FibGUgdG8gbWUsIGFzIHJlZmVyZW5jZWQgaW4gdGhlIEFscGFjYVxcclxcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tZXJcXHJcXG4gICAgICAgICAgICAgICAgICAgIEFncmVlbWVudC5cXHJcXG4gICAgICAgICAgICAgICAgICAgIEkgYWxzbyBhY2tub3dsZWRnZSB0aGF0IHRoZSBBbHBhY2EgQ3VzdG9tZXIgQWdyZWVtZW50IGNvbnRhaW5zIGEgcHJlLWRpc3B1dGUgYXJiaXRyYXRpb24gY2xhdXNlXFxyXFxuICAgICAgICAgICAgICAgICAgICBpblxcclxcbiAgICAgICAgICAgICAgICAgICAgU2VjdGlvblxcclxcbiAgICAgICAgICAgICAgICAgICAgNDMuXFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJkaWdpdGFsX3NpZ25hdHVyZV9lcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImRpZ2l0YWxfc2lnbmF0dXJlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwiZGlnaXRhbF9zaWduYXR1cmVcXFwiIGlkPVxcXCJkaWdpdGFsX3NpZ25hdHVyZVxcXCIgdmFsdWU9XFxcIjFcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJkaWdpdGFsX3NpZ25hdHVyZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICBEaWdpdGFsIFNpZ25hdHVyZSBBY2tub3dsZWRnZW1lbnQ8L2xhYmVsPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJleHBsYWluXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIEkgdW5kZXJzdGFuZCBJIGFtIHNpZ25pbmcgdGhpcyBhZ3JlZW1lbnQgZWxlY3Ryb25pY2FsbHksXFxyXFxuICAgICAgICAgICAgICAgICAgICBhbmQgdGhhdCBteSBlbGVjdHJvbmljIHNpZ25hdHVyZSB3aWxsIGhhdmUgdGhlIHNhbWUgZWZmZWN0IGFzIHBoeXNpY2FsbHkgc2lnbmluZyBhbmQgcmV0dXJuaW5nXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGVcXHJcXG4gICAgICAgICAgICAgICAgICAgIEFwcGxpY2F0aW9uIEFncmVlbWVudC5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgaGlkZGVuXFxcIiBpZD1cXFwidzhkaXNjbG9zdXJlX2RpdlxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidzhkaXNjbG9zdXJlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwidzhkaXNjbG9zdXJlXFxcIiBpZD1cXFwidzhkaXNjbG9zdXJlXFxcIiB2YWx1ZT1cXFwiMVxcXCIvPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXY+PGxhYmVsIGZvcj1cXFwidzhkaXNjbG9zdXJlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgSSBjZXJ0aWZ5IHRoYXQgSSBhbSBub3QgYSBVUyBjaXRpemVuLCBVUyByZXNpZGVudCBhbGllbiBvciBvdGhlciBVUyBwZXJzb24gZm9yIFVTIHRheCBwdXJwb3NlcyxcXHJcXG4gICAgICAgICAgICAgICAgYW5kIEkgYW0gc3VibWl0dGluZyB0aGUgYXBwbGljYWJsZSBGb3JtIFctOCBCRU4gd2l0aCB0aGlzIGZvcm0gdG8gY2VydGlmeSBteSBmb3JlaWduIHN0YXR1cyBhbmQsXFxyXFxuICAgICAgICAgICAgICAgIGlmIGFwcGxpY2FibGUsIGNsYWltIHRheCB0cmVhdHkgYmVuZWZpdHMuIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcImFjY291bnRfYWdyZWVtZW50X3ByZXZcXFwiPlByZXZpb3VzOiBVcGxvYWQgZG9jdW1lbnRzPC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgaWQ9XFxcInN1Ym1pdEtZQ1xcXCI+Q29uZmlybSBpZGVudGl0eTwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiBpZD1cXFwia3ljRXJyb3JcXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj48L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgS3ljQmFzZSBmcm9tIFwiLi9LeWNCYXNlXCI7XHJcbmltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcbmltcG9ydCBLeWNBY2NvdW50QWdyZWVtZW50SHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljQWNjb3VudEFncmVlbWVudC5odG1sXCI7XHJcbmltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgS1lDU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9LWUNTZXJ2aWNlXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBGb3JtSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0Zvcm1IZWxwZXJcIjtcclxuaW1wb3J0IEV4ZWN1dGVPcmRlckJ1dHRvbiBmcm9tIFwiLi4vLi4vZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlT3JkZXJCdXR0b25cIjtcclxuaW1wb3J0IEZha2VBVVNERnVuZCBmcm9tIFwiLi4vRnVuZGluZy9GYWtlQVVTREZ1bmRcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vLi4vbWFpblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljQWNjb3VudEFncmVlbWVudCBleHRlbmRzIEt5Y0Jhc2Uge1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihreWNGb3JtOiBLWUNGb3JtKSB7XHJcbiAgICAgICAgc3VwZXIoa3ljRm9ybSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKGVkaXQgPSBmYWxzZSkge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNBY2NvdW50QWdyZWVtZW50SHRtbCk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHtlZGl0OiBlZGl0fSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5zaG93RmllbGRzZXQoJy5reWNBY2NvdW50QWdyZWVtZW50JywgJ0FncmVlbWVudHMnKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5zdGVwcyA9PSA1KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY2NvdW50X2FncmVlbWVudF9wcmV2JykhLmlubmVyVGV4dCA9ICdQcmV2aW91czogRGlzY2xvc3VyZSc7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjY291bnRfYWdyZWVtZW50X3ByZXYnKSEuaW5uZXJUZXh0ID0gJ1ByZXZpb3VzOiBVcGxvYWQgZG9jdW1lbnRzJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5reWNDb250YWN0LnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3OGRpc2Nsb3N1cmVfZGl2Jyk/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3c4ZGlzY2xvc3VyZV9kaXYnKT8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJylcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcblxyXG4gICAgICAgIGxldCBhY2NvdW50X2FncmVlbWVudF9wcmV2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjY291bnRfYWdyZWVtZW50X3ByZXYnKVxyXG4gICAgICAgIGFjY291bnRfYWdyZWVtZW50X3ByZXY/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5reWNGb3JtLnN0ZXBzID09IDUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNEaXNjbG9zdXJlcy5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljVXBsb2FkLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuYmluZFN1Ym1pdEt5YygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgYmluZFN1Ym1pdEt5YyhlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgc3VibWl0S1lDID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1Ym1pdEtZQycpO1xyXG4gICAgICAgIGlmICghc3VibWl0S1lDKSByZXR1cm47XHJcblxyXG4gICAgICAgIHN1Ym1pdEtZQy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWVkaXQgJiYgIXRoaXMudmFsaWRhdGUoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFjY291bnRfYWdyZWVtZW50X3ByZXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWNjb3VudF9hZ3JlZW1lbnRfcHJldicpO1xyXG4gICAgICAgICAgICAvL2lmIChhY2NvdW50X2FncmVlbWVudF9wcmV2KSBhY2NvdW50X2FncmVlbWVudF9wcmV2LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlJyk7XHJcbiAgICAgICAgICAgIC8vIGlmIChsaW1pbmFsX21hcmtldF9tb2RhbF9jbG9zZSkgbGltaW5hbF9tYXJrZXRfbW9kYWxfY2xvc2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHJcbiAgICAgICAgICAgIGxldCBzdWJtaXRCdG4gPSAoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyhzdWJtaXRCdG4pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEZvcm1IZWxwZXIuZ2V0UGFyYW1zKCcja3ljX3dpemFyZF9mb3JtJyk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBBcHAuTmV0d29yaztcclxuICAgICAgICAgICAgcGFyYW1zLmNoYWluSWQgPSBuZXR3b3JrSW5mby5DaGFpbklkO1xyXG5cclxuICAgICAgICAgICAgbGV0IGt5Y1NlcnZpY2UgPSBuZXcgS1lDU2VydmljZSgpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQga3ljU2VydmljZS5zYXZlS1lDSW5mbyhwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goKHJlYXNvbjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY291bnRfYWdyZWVtZW50X3ByZXYpIGFjY291bnRfYWdyZWVtZW50X3ByZXYuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWFzb24ubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQga3ljRXJyb3IgPSBuZXcgS3ljVmFsaWRhdG9yRXJyb3IoSlNPTi5wYXJzZShyZWFzb24ubWVzc2FnZSksIHRoaXMua3ljRm9ybSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGt5Y0Vycm9yLmhhbmRsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXVzZEZ1bmQgPSBuZXcgRmFrZUFVU0RGdW5kKCk7XHJcbiAgICAgICAgICAgICAgICBhdXNkRnVuZC5zaG93QVVTREZha2VGdW5kKCk7XHJcbiAgICAgICAgICAgICAgICBFeGVjdXRlT3JkZXJCdXR0b24uSW5zdGFuY2UucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWNjb3VudF9hZ3JlZW1lbnRfcHJldikgYWNjb3VudF9hZ3JlZW1lbnRfcHJldi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZSgpIHtcclxuICAgICAgICBsZXQgYWNjb3VudF9hZ3JlZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWNjb3VudF9hZ3JlZW1lbnQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICghYWNjb3VudF9hZ3JlZW1lbnQ/LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRNaXNzaW5nSW5mbygnYWNjb3VudF9hZ3JlZW1lbnRfZXJyb3InLCAnWW91IG5lZWQgdG8gYWdyZWUgdG8gYWdyZWVtZW50cycsICdhY2NvdW50X2FncmVlbWVudCcpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1pc3NpbmdJbmZvKCdhY2NvdW50X2FncmVlbWVudF9lcnJvcicsICdhY2NvdW50X2FncmVlbWVudCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGN1c3RvbWVyX2FncmVlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXN0b21lcl9hZ3JlZW1lbnQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICghY3VzdG9tZXJfYWdyZWVtZW50Py5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ2N1c3RvbWVyX2FncmVlbWVudF9lcnJvcicsICdZb3UgbmVlZCB0byBhZ3JlZSB0byBjdXN0b21lciBhZ3JlbWVudCcsICdjdXN0b21lcl9hZ3JlZW1lbnQnKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVNaXNzaW5nSW5mbygnY3VzdG9tZXJfYWdyZWVtZW50X2Vycm9yJywgJ2N1c3RvbWVyX2FncmVlbWVudCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGlnaXRhbF9zaWduYXR1cmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlnaXRhbF9zaWduYXR1cmUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICghZGlnaXRhbF9zaWduYXR1cmU/LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRNaXNzaW5nSW5mbygnZGlnaXRhbF9zaWduYXR1cmVfZXJyb3InLCAnWW91IG5lZWQgdG8gc2lnbicsICdkaWdpdGFsX3NpZ25hdHVyZScpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1pc3NpbmdJbmZvKCdkaWdpdGFsX3NpZ25hdHVyZV9lcnJvcicsICdkaWdpdGFsX3NpZ25hdHVyZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNUcnVzdGVkQ29udGFjdCBoaWRkZW5cXFwiIGRhdGEtZm9ybT1cXFwiMVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgQSB0cnVzdGVkIGNvbnRhY3QgaXMgYSBwZXJzb24geW91IGF1dGhvcml6ZSB5b3VyIGZpbmFuY2lhbCBmaXJtIHRvIGNvbnRhY3QgaW4gbGltaXRlZCBjaXJjdW1zdGFuY2VzLFxcclxcbiAgICAgICAgc3VjaCBhcyBpZiB0aGVyZSBpcyBhIGNvbmNlcm4gYWJvdXQgYWN0aXZpdHkgaW4geW91ciBhY2NvdW50IGFuZCB0aGV5IGhhdmUgYmVlbiB1bmFibGUgdG8gZ2V0IGluIHRvdWNoIHdpdGggeW91LlxcclxcbiAgICAgICAgPGJyLz48YnIvPlxcclxcbiAgICAgICAgQSB0cnVzdGVkIGNvbnRhY3QgbWF5IGJlIGEgZmFtaWx5IG1lbWJlciwgYXR0b3JuZXksIGFjY291bnRhbnQgb3IgYW5vdGhlciB0aGlyZC1wYXJ0eSB3aG8geW91IGJlbGlldmUgd291bGRcXHJcXG4gICAgICAgIHJlc3BlY3QgeW91ciBwcml2YWN5IGFuZCBrbm93IGhvdyB0byBoYW5kbGUgdGhlIHJlc3BvbnNpYmlsaXR5LlxcclxcbiAgICAgICAgVGhlIHRydXN0ZWQgcGVyc29uIHNob3VsZCBiZSAxOCB5ZWFycyBvbGQgb3Igb2xkZXIuXFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9maXJzdF9uYW1lXFxcIj5MZWdhbCBmaXJzdCBuYW1lIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcInRydXN0ZWRfZmlyc3RfbmFtZVxcXCIgbmFtZT1cXFwidHJ1c3RlZF9maXJzdF9uYW1lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9sYXN0X25hbWVcXFwiPkxlZ2FsIGxhc3QgbmFtZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0cnVzdGVkX2xhc3RfbmFtZVxcXCIgbmFtZT1cXFwidHJ1c3RlZF9sYXN0X25hbWVcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICBJZiB5b3UgZmlsbCBpbiBuYW1lLCB5b3UgYXJlIHJlcXVpcmVkIHRvIGZpbGwgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcsIGVtYWlsLCBwaG9uZSBvciBhZGRyZXNzXFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcInRydXN0ZWRfY29udGFjdF9taXNzaW5nX2luZm9cXFwiPjwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9lbWFpbFxcXCI+RW1haWwgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidHJ1c3RlZF9lbWFpbFxcXCIgdHlwZT1cXFwiZW1haWxcXFwiIG5hbWU9XFxcInRydXN0ZWRfZW1haWxcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0cnVzdGVkX3Bob25lXFxcIj5QaG9uZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0cnVzdGVkX3Bob25lXFxcIiB0eXBlPVxcXCJ0ZWxcXFwiIG5hbWU9XFxcInRydXN0ZWRfcGhvbmVcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0cnVzdGVkX3N0cmVldF9hZGRyZXNzXFxcIj5BZGRyZXNzIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcInRydXN0ZWRfc3RyZWV0X2FkZHJlc3NcXFwiIG5hbWU9XFxcInRydXN0ZWRfc3RyZWV0X2FkZHJlc3NcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0cnVzdGVkX2NpdHlcXFwiPkNpdHkgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidHJ1c3RlZF9jaXR5XFxcIiBuYW1lPVxcXCJ0cnVzdGVkX2NpdHlcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0cnVzdGVkX3N0YXRlXFxcIj5TdGF0ZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0cnVzdGVkX3N0YXRlXFxcIiBuYW1lPVxcXCJ0cnVzdGVkX3N0YXRlXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9wb3N0YWxfY29kZVxcXCI+UG9zdGFsIGNvZGUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidHJ1c3RlZF9wb3N0YWxfY29kZVxcXCIgbmFtZT1cXFwidHJ1c3RlZF9wb3N0YWxfY29kZVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRydXN0ZWRfY291bnRyeVxcXCI+Q291bnRyeSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwidHJ1c3RlZF9jb3VudHJ5XFxcIiByZXF1aXJlZCBuYW1lPVxcXCJ0cnVzdGVkX2NvdW50cnlcXFwiPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAge3sjZWFjaCBjb3VudHJpZXN9fVxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7Y29kZX19XFxcIj57e25hbWV9fTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICB7eyN1bmxlc3MgZWRpdH19XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcInRydXN0ZWRDb250YWN0X3ByZXZcXFwiPlByZXZpb3VzOiBJZGVudGl0eTwvYnV0dG9uPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJ0cnVzdGVkQ29udGFjdF9uZXh0XFxcIj5OZXh0OiBEaXNjbG9zdXJlczwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAge3svdW5sZXNzfX1cXHJcXG4gICAge3sjaWYgZWRpdH19XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcInRydXN0ZWRDb250YWN0X3ByZXZcXFwiPlByZXZpb3VzOiBJZGVudGl0eTwvYnV0dG9uPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGlkPVxcXCJzdWJtaXRLWUNcXFwiPlVwZGF0ZSBhY2NvdW50PC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJhbGVydCBhbGVydC1kYW5nZXJcXFwiIGlkPVxcXCJreWNFcnJvclxcXCIgcm9sZT1cXFwiYWxlcnRcXFwiPjwvZGl2PlxcclxcbiAgICB7ey9pZn19XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5pbXBvcnQgS3ljVHJ1c3RlZENvbnRhY3RIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y1RydXN0ZWRDb250YWN0Lmh0bWwnO1xyXG5pbXBvcnQgU3RyaW5nSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL1N0cmluZ0hlbHBlclwiO1xyXG5pbXBvcnQgQ291bnRyeUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Db3VudHJ5SGVscGVyXCI7XHJcblxyXG5pbXBvcnQgS3ljQWNjb3VudEFncmVlbWVudCBmcm9tIFwiLi9LeWNBY2NvdW50QWdyZWVtZW50XCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljVHJ1c3RlZENvbnRhY3QgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGVkaXQgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihreWNGb3JtOiBLWUNGb3JtKSB7XHJcbiAgICAgICAgc3VwZXIoa3ljRm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmVkaXQgPSBlZGl0O1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljVHJ1c3RlZENvbnRhY3RIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXQsIGNvdW50cmllczogQ291bnRyeUhlbHBlci5Db3VudHJpZXN9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICB0aGlzLnNob3dGaWVsZHNldCgnLmt5Y1RydXN0ZWRDb250YWN0JywgJ1RydXN0ZWQgY29udGFjdCcpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IHNob3dQcmV2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRDb250YWN0X3ByZXYnKTtcclxuICAgICAgICBzaG93UHJldj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNJZGVudGl0eS5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IHNob3dOZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRDb250YWN0X25leHQnKTtcclxuICAgICAgICBzaG93TmV4dD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZSgpKSByZXR1cm47XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNEaXNjbG9zdXJlcy5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZWRpdCkge1xyXG4gICAgICAgICAgICBsZXQga3ljQWNjb3VudCA9IG5ldyBLeWNBY2NvdW50QWdyZWVtZW50KHRoaXMua3ljRm9ybSk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZSgpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBreWNBY2NvdW50LmJpbmRTdWJtaXRLeWModGhpcy5lZGl0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnNldE1pc3NpbmdJbmZvKCd0cnVzdGVkX2NvbnRhY3RfbWlzc2luZ19pbmZvJywgJycpO1xyXG5cclxuICAgICAgICBsZXQgdHJ1c3RlZF9maXJzdF9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRfZmlyc3RfbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHRydXN0ZWRfZmlyc3RfbmFtZSAmJiAhU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9maXJzdF9uYW1lLnZhbHVlKSkge1xyXG4gICAgICAgICAgICBsZXQgdHJ1c3RlZF9lbWFpbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkX2VtYWlsJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IHRydXN0ZWRfcGhvbmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJ1c3RlZF9waG9uZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCB0cnVzdGVkX3N0cmVldF9hZGRyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRfc3RyZWV0X2FkZHJlc3MnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgdHJ1c3RlZF9jaXR5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRfY2l0eScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCB0cnVzdGVkX3Bvc3RhbF9jb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRfcG9zdGFsX2NvZGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgdHJ1c3RlZF9jb3VudHJ5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRfY291bnRyeScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9lbWFpbC52YWx1ZSkgJiYgU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9waG9uZS52YWx1ZSlcclxuICAgICAgICAgICAgICAgICYmIFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfc3RyZWV0X2FkZHJlc3MudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1pc3NpbmdJbmZvKCd0cnVzdGVkX2NvbnRhY3RfbWlzc2luZ19pbmZvJywgJ1lvdSBuZWVkIHRvIGZpbGwgaW4gZWl0aGVyIGVtYWlsLCBwaG9uZSBvciBhZGRyZXNzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9lbWFpbC52YWx1ZSkgJiYgdHJ1c3RlZF9lbWFpbC52YWx1ZS5pbmRleE9mKCdAJykgPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ3RydXN0ZWRfY29udGFjdF9taXNzaW5nX2luZm8nLCAnRW1haWwgaXMgbm90IHZhbGlkLiBJdCBtdXN0IGNvbnRhaW4gQCBzaWduJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9zdHJlZXRfYWRkcmVzcy52YWx1ZSkgJiZcclxuICAgICAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgICAgICBTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eSh0cnVzdGVkX2NpdHkudmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9wb3N0YWxfY29kZS52YWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eSh0cnVzdGVkX2NvdW50cnkudmFsdWUpXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNaXNzaW5nSW5mbygndHJ1c3RlZF9jb250YWN0X21pc3NpbmdfaW5mbycsICdZb3UgbmVlZCBmaWxsIGlubiBpbnRvIENpdHksIFBvc3RhbCBjb2RlIGFuZCBDb3VudHJ5IHdoZW4gZmlsbGluZyB0aGUgc3RyZWV0IGFkZHJlc3MnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQgY2xhc3M9XFxcImt5Y1VwbG9hZCBoaWRkZW5cXFwiIGRhdGEtZm9ybT1cXFwiMVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXFxcIiBcXFwiUGhvdG8gSUQgRnJvbnQgKEZyb250IG9mIHBhc3Nwb3J0KVxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiaWRlbnRpdHlfdmVyaWZpY2F0aW9uXzJcXFwiIFxcXCJQaG90byBJRCBCYWNrIChQYXNzcG9ydCBwaWN0dXJlIG9mIElEKSBcXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgIHt7e2ZpbGVVcGxvYWQgXFxcImFkZHJlc3NfdmVyaWZpY2F0aW9uXFxcIiBcXFwiUGljdHVyZSBvZiBhZGRyZXNzIHZlcmlmaWNhdGlvblxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcInVwbG9hZF9wcmV2XFxcIj5QcmV2aW91czogRGlzY2xvc3VyZXM8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBpZD1cXFwidXBsb2FkX25leHRcXFwiPk5leHQ6IEFncmVlbWVudHM8L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS3ljVXBsb2FkSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNVcGxvYWQuaHRtbCc7XHJcbmltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljVXBsb2FkIGV4dGVuZHMgS3ljQmFzZSB7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNVcGxvYWRIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuc2hvd0ZpZWxkc2V0KCcua3ljVXBsb2FkJywgJ1VwbG9hZCBkb2N1bWVudHMnKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuYmluZEZpbGVVcGxvYWRzKCk7XHJcblxyXG4gICAgICAgIGxldCB1cGxvYWRfcHJldiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGxvYWRfcHJldicpO1xyXG4gICAgICAgIHVwbG9hZF9wcmV2Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y0Rpc2Nsb3N1cmVzLnNob3coKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIGxldCB1cGxvYWRfbmV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1cGxvYWRfbmV4dCcpO1xyXG4gICAgICAgIHVwbG9hZF9uZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlUmVxdWlyZWRGaWVsZHMoJy5reWNVcGxvYWQnKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y0FjY291bnRBZ3JlZW1lbnQuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgS1lDRm9ybUh0bWwgZnJvbSAnLi4vLi4vaHRtbC9tb2RhbC9LWUNNb2RhbC5odG1sJztcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuL01vZGFsXCI7XHJcbmltcG9ydCBLeWNDb250YWN0IGZyb20gXCIuL0tZQy9LeWNDb250YWN0XCI7XHJcbmltcG9ydCBLeWNJZGVudGl0eSBmcm9tIFwiLi9LWUMvS3ljSWRlbnRpdHlcIjtcclxuaW1wb3J0IEt5Y0Rpc2Nsb3N1cmVzIGZyb20gXCIuL0tZQy9LeWNEaXNjbG9zdXJlc1wiO1xyXG5pbXBvcnQgS3ljQWNjb3VudEFncmVlbWVudCBmcm9tIFwiLi9LWUMvS3ljQWNjb3VudEFncmVlbWVudFwiO1xyXG5pbXBvcnQgS3ljVHJ1c3RlZENvbnRhY3QgZnJvbSBcIi4vS1lDL0t5Y1RydXN0ZWRDb250YWN0XCI7XHJcbmltcG9ydCBLeWNVcGxvYWQgZnJvbSBcIi4vS1lDL0t5Y1VwbG9hZFwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtZQ0Zvcm0ge1xyXG4gICAgc3RlcHMgPSA1O1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG4gICAgdGltZW91dD86IGFueSA9IHVuZGVmaW5lZDtcclxuICAgIG9uSGlkZTogKCkgPT4gdm9pZDtcclxuICAgIGFjdGl2ZUZpZWxkc2V0U2VsZWN0b3IgPSAnLmt5Y0NvbnRhY3QnO1xyXG5cclxuICAgIGt5Y0NvbnRhY3Q6IEt5Y0NvbnRhY3Q7XHJcbiAgICBreWNJZGVudGl0eTogS3ljSWRlbnRpdHk7XHJcbiAgICBreWNEaXNjbG9zdXJlczogS3ljRGlzY2xvc3VyZXNcclxuICAgIGt5Y1RydXN0ZWRDb250YWN0OiBLeWNUcnVzdGVkQ29udGFjdDtcclxuICAgIGt5Y1VwbG9hZDogS3ljVXBsb2FkO1xyXG4gICAga3ljQWNjb3VudEFncmVlbWVudDogS3ljQWNjb3VudEFncmVlbWVudDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihvbkhpZGU6ICgpID0+IHZvaWQpIHtcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgdGhpcy5vbkhpZGUgPSBvbkhpZGU7XHJcblxyXG4gICAgICAgIHRoaXMua3ljQ29udGFjdCA9IG5ldyBLeWNDb250YWN0KHRoaXMpO1xyXG4gICAgICAgIHRoaXMua3ljSWRlbnRpdHkgPSBuZXcgS3ljSWRlbnRpdHkodGhpcyk7XHJcbiAgICAgICAgdGhpcy5reWNUcnVzdGVkQ29udGFjdCA9IG5ldyBLeWNUcnVzdGVkQ29udGFjdCh0aGlzKTtcclxuICAgICAgICB0aGlzLmt5Y0Rpc2Nsb3N1cmVzID0gbmV3IEt5Y0Rpc2Nsb3N1cmVzKHRoaXMpO1xyXG4gICAgICAgIHRoaXMua3ljVXBsb2FkID0gbmV3IEt5Y1VwbG9hZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmt5Y0FjY291bnRBZ3JlZW1lbnQgPSBuZXcgS3ljQWNjb3VudEFncmVlbWVudCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdyhjbGFzc05hbWU6IHN0cmluZykge1xyXG5cclxuICAgICAgICBsZXQga3ljRm9ybSA9IG5ldyBLWUNGb3JtKCgpID0+IHtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0eXBlIE9iamVjdEtleSA9IGtleW9mIHR5cGVvZiBreWNGb3JtO1xyXG4gICAgICAgIGNvbnN0IGJsZSA9IGNsYXNzTmFtZSBhcyBPYmplY3RLZXk7XHJcbiAgICAgICAgKHRoaXNbYmxlXSBhcyBhbnkpLnNob3coKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY3RpdmVGaWVsZHNldFNlbGVjdG9yID0gY2xhc3NOYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93S1lDRm9ybShlZGl0ID0gZmFsc2UpIHtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEtZQ0Zvcm1IdG1sKTtcclxuICAgICAgICBsZXQgb2JqID0ge1xyXG4gICAgICAgICAgICBLeWNDb250YWN0SHRtbDogdGhpcy5reWNDb250YWN0LnJlbmRlcigpLFxyXG4gICAgICAgICAgICBLeWNJZGVudGl0eUh0bWw6IHRoaXMua3ljSWRlbnRpdHkucmVuZGVyKCksXHJcbiAgICAgICAgICAgIEt5Y0Rpc2Nsb3N1cmVIdG1sOiB0aGlzLmt5Y0Rpc2Nsb3N1cmVzLnJlbmRlcigpLFxyXG4gICAgICAgICAgICBLeWNUcnVzdGVkQ29udGFjdEh0bWw6IHRoaXMua3ljVHJ1c3RlZENvbnRhY3QucmVuZGVyKCksXHJcbiAgICAgICAgICAgIEt5Y0FjY291bnRBZ3JlZW1lbnRIdG1sOiB0aGlzLmt5Y0FjY291bnRBZ3JlZW1lbnQucmVuZGVyKCksXHJcbiAgICAgICAgICAgIEt5Y1VwbG9hZEh0bWw6IHRoaXMua3ljVXBsb2FkLnJlbmRlcigpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGUob2JqKTtcclxuICAgICAgICBsZXQgbmV3TW9kYWwgPSB0aGlzLm1vZGFsLnNob3dNb2RhbCgnS1lDICYgQU1MJywgY29udGVudCwgdHJ1ZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uSGlkZSgpO1xyXG4gICAgICAgIH0sIGZhbHNlKTtcclxuXHJcbiAgICAgICAgbGV0IHRheFJlc2lkZW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb3VudHJ5X29mX3RheF9yZXNpZGVuY2UnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICBpZiAodGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RlcHMgPSAodGF4UmVzaWRlbmNlLnZhbHVlID09ICdVU0EnKSA/IDUgOiA2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld01vZGFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMua3ljQ29udGFjdC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljSWRlbnRpdHkuYmluZEV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLmt5Y1RydXN0ZWRDb250YWN0LmJpbmRFdmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5reWNEaXNjbG9zdXJlcy5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljVXBsb2FkLmJpbmRFdmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5reWNBY2NvdW50QWdyZWVtZW50LmJpbmRFdmVudHMoKTtcclxuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNfd2l6YXJkX2Zvcm0nKSEuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmtleSA9PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmt5Y0NvbnRhY3Quc2hvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRTdGVwcyhzdGVwczogbnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdGVwcyA9IHN0ZXBzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhclRpbWVvdXQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IEt5Y1N0YXR1cyBmcm9tIFwiLi4vLi4vLi4vZHRvL0t5Y1N0YXR1c1wiO1xyXG5pbXBvcnQgS3ljQWN0aW9uUmVxdWlyZWQgZnJvbSBcIi4vS3ljQWN0aW9uUmVxdWlyZWRcIjtcclxuaW1wb3J0IEV4ZWN1dGVPcmRlckJ1dHRvbiBmcm9tIFwiLi4vLi4vZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlT3JkZXJCdXR0b25cIjtcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljU3RhdHVzSGFuZGxlciB7XHJcbiAgICBreWNSZXNwb25zZTogS3ljU3RhdHVzO1xyXG4gICAgZXhlY3V0ZVRyYWRlQnV0dG9uOiBFeGVjdXRlT3JkZXJCdXR0b247XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa3ljUmVzcG9uc2U6IEt5Y1N0YXR1cywgZXhlY3V0ZVRyYWRlQnV0dG9uOiBFeGVjdXRlT3JkZXJCdXR0b24pIHtcclxuICAgICAgICB0aGlzLmt5Y1Jlc3BvbnNlID0ga3ljUmVzcG9uc2U7XHJcbiAgICAgICAgdGhpcy5leGVjdXRlVHJhZGVCdXR0b24gPSBleGVjdXRlVHJhZGVCdXR0b247XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEJ1dHRvblRleHQoKSB7XHJcbiAgICAgICAgbGV0IHR4dCA9ICdGaW5pc2ggS1lDJztcclxuICAgICAgICBzd2l0Y2ggKHRoaXMua3ljUmVzcG9uc2Uuc3RhdHVzKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1NVQk1JVFRFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ09OQk9BUkRJTkcnOlxyXG4gICAgICAgICAgICBjYXNlICdJTkFDVElWRSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0FQUFJPVkVEJzpcclxuICAgICAgICAgICAgY2FzZSAnRURJVEVEJzpcclxuICAgICAgICAgICAgY2FzZSAnQVBQUk9WQUxfUEVORElORyc6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSAnU3VibWl0dGVkIHRvIEtZQyBwcm9jZXNzb3InO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0FDVElPTl9SRVFVSVJFRCc6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSAnQWN0aW9uIHJlcXVpcmVkLiBDbGljayB0byBjb250aW51ZSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnUkVKRUNURUQnOlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gJ1lvdXIgYXBwbGljYXRpb24gd2FzIHJlamVjdGVkJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdESVNBQkxFRCc6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSAnWW91ciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdBQ1RJVkUnOlxyXG4gICAgICAgICAgICBjYXNlICdBQ0NPVU5UX1VQREFURUQnOlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gJ1lvdSBhcmUgYXBwcm92ZWQuIEtZQyBpcyBiZWluZyBzZW50IHRvIGJsb2NrY2hhaW4uIEdpdmUgaXQgZmV3IG1pbnV0ZXMnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0FDQ09VTlRfQ0xPU0VEJzpcclxuICAgICAgICAgICAgICAgIHR4dCA9ICdZb3VyIGFjY291bnQgaGFzIGJlZW4gY2xvc2VkJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHh0ICsgJzxzbWFsbD5DbGljayBmb3IgbW9yZSBpbmZvPC9zbWFsbD4nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCdXR0b25DbGlja0V2ZW50KGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZU9yZGVyQnV0dG9uKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmt5Y1Jlc3BvbnNlLnN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlICdTVUJNSVRURUQnOlxyXG4gICAgICAgICAgICBjYXNlICdPTkJPQVJESU5HJzpcclxuICAgICAgICAgICAgY2FzZSAnSU5BQ1RJVkUnOlxyXG4gICAgICAgICAgICBjYXNlICdBUFBST1ZFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0VESVRFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0FQUFJPVkFMX1BFTkRJTkcnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd01vZGFsKCdBcHBsaWNhdGlvbiBpcyBiZWluZyBwcm9jZXNzZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiWW91IG5lZWQgdG8gd2FpdCBmb3IgS1lDIHRvIGJlIGFwcHJvdmVkLiBUaGVuIHlvdSdsbCBiZSBhYmxlIHRvIGRvIHRyYWRlcy4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiVGhpcyB1c3VhbGx5IHRha2VzIGZldyBtaW51dGVzIGZvciB0aGUgZmlyc3Qgc3VibWlzc2lvbiwgYnV0IGNhbiB0YWtlIGxvbmdlciBmb3Igc2Vjb25kIHN1Ym1pc3Npb24uIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIldlIHdpbGwgZW1haWwgeW91IHdoZW4geW91IGFyZSBhcHByb3ZlZCBvciBpZiB0aGVyZSBhcmUgcHJvYmxlbXM8YnIgLz48YnIgLz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJJZiB0aGlzIHN0YXR1cyBoYXMgYmVlbiBmb3IgbW9yZSB0aGFuIDEgZGF5LCBhbmQgeW91IGhhdmVuJ3QgZ290dGVuIGFueSBlbWFpbCBmcm9tIHVzLiBQbGVhc2UgZW1haWwgdXMgYXQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9J21haWx0bzppbmZvQGxpbWluYWwubWFya2V0P3N1YmplY3Q9TXkgYXBwbGljYXRpb24gaXMgYmVpbmcgcHJvY2Vzc2VkIGZvciB0byBsb25nJmJvZHk9SGksIGNhbiB5b3UgaGVscCBtZSB0byBmaW5kIG91dCB3aGF0IHRoZSBwcm9ibGVtIGlzLCB0aGUgS1lDIHByb2Nlc3MgaGFzIG5vdCBjaGFuZ2VkIGZvciBzb21lIHRpbWU/IE15IG5hbWUgaXMgX19fX19fXyBhbmQgSSB1c2VkIHRoZSBlbWFpbCBfX19fX19fIHRvIHJlZ2lzdGVyIGF0IGxpbWluYWwubWFya2V0Jz5pbmZvQGxpbWluYWwubWFya2V0PC9hPlwiKTtcclxuICAgICAgICAgICAgY2FzZSAnQUNUSU9OX1JFUVVJUkVEJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkID0gbmV3IEt5Y0FjdGlvblJlcXVpcmVkKGV4ZWN1dGVUcmFkZUJ1dHRvbilcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBreWNBY3Rpb25SZXF1aXJlZC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjYXNlICdSRUpFQ1RFRCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93TW9kYWwoJ0FwcGxpY2F0aW9uIHdhcyByZWplY3RlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJZb3VyIGFwcGxpY2F0aW9uIGhhcyBiZWVuIHJlamVjdGVkIGR1cmluZyBLWUMgcHJvY2Vzcy48YnIgLz48YnIgLz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJXZSBkb24ndCBoYXZlIHRoZSBpbmZvcm1hdGlvbiBvbiB3aHkgdGhhdCBoYXBwZW5lZCwgYnV0IHlvdSBjYW4gZW1haWwgdXMgYXQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9J21haWx0bzppbmZvQGxpbWluYWwubWFya2V0P3N1YmplY3Q9TXkgYXBwbGljYXRpb24gd2FzIHJlamVjdGVkJmJvZHk9SGksIGNhbiB5b3UgaGVscCBtZSB0byBmaW5kIG91dCB3aGF0IHRoZSBwcm9ibGVtIGlzPyBNeSBuYW1lIGlzIF9fX19fX18gYW5kIEkgdXNlZCB0aGUgZW1haWwgX19fX19fXyB0byByZWdpc3RlciBhdCBsaW1pbmFsLm1hcmtldCc+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgYW5kIHdlIGNhbiBmaW5kIG91dCwgYW5kIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNvbHZlIGl0IHRvZ2V0aGVyLlwiKTtcclxuICAgICAgICAgICAgY2FzZSAnRElTQUJMRUQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd01vZGFsKCdBcHBsaWNhdGlvbiB3YXMgZGlzYWJsZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiWW91ciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkLjxiciAvPjxiciAvPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIldlIGRvbid0IGhhdmUgdGhlIGluZm9ybWF0aW9uIG9uIHdoeSB0aGF0IGhhcHBlbmVkLCBidXQgeW91IGNhbiBlbWFpbCB1cyBhdCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCI8YSB0YXJnZXQ9J19ibGFuaycgaHJlZj0nbWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXQ/c3ViamVjdD1NeSBhcHBsaWNhdGlvbiB3YXMgZGlzYWJsZWQmYm9keT1IaSwgY2FuIHlvdSBoZWxwIG1lIHRvIGZpbmQgb3V0IHdoYXQgdGhlIHByb2JsZW0gaXM/IE15IG5hbWUgaXMgX19fX19fXyBhbmQgSSB1c2VkIHRoZSBlbWFpbCBfX19fX19fIHRvIHJlZ2lzdGVyIGF0IGxpbWluYWwubWFya2V0Jz5pbmZvQGxpbWluYWwubWFya2V0PC9hPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIiBhbmQgd2UgY2FuIGZpbmQgb3V0LCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gc29sdmUgaXQgdG9nZXRoZXIuXCIpO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAnQUNDT1VOVF9DTE9TRUQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd01vZGFsKCdBcHBsaWNhdGlvbiB3YXMgY2xvc2VkJyxcclxuICAgICAgICAgICAgICAgICAgICBcIllvdXIgYWNjb3VudCBoYXMgYmVlbiBjbG9zZWQuPGJyIC8+PGJyIC8+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiV2UgZG9uJ3QgaGF2ZSB0aGUgaW5mb3JtYXRpb24gb24gd2h5IHRoYXQgaGFwcGVuZWQsIGJ1dCB5b3UgY2FuIGVtYWlsIHVzIGF0IFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxhIHRhcmdldD0nX2JsYW5rJyBocmVmPSdtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldD9zdWJqZWN0PU15IGFwcGxpY2F0aW9uIHdhcyBjbG9zZWQmYm9keT1IaSwgY2FuIHlvdSBoZWxwIG1lIHRvIGZpbmQgb3V0IHdoYXQgdGhlIHByb2JsZW0gaXM/IE15IG5hbWUgaXMgX19fX19fXyBhbmQgSSB1c2VkIHRoZSBlbWFpbCBfX19fX19fIHRvIHJlZ2lzdGVyIGF0IGxpbWluYWwubWFya2V0Jz5pbmZvQGxpbWluYWwubWFya2V0PC9hPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIiBhbmQgd2UgY2FuIGZpbmQgb3V0LCBhbmQgd2Ugc2hvdWxkIGJlIGFibGUgdG8gc29sdmUgaXQgdG9nZXRoZXIuXCIpO1xyXG4gICAgICAgICAgICBjYXNlICdBQ0NPVU5UX1VQREFURUQnOlxyXG4gICAgICAgICAgICBjYXNlICdBQ1RJVkUnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd01vZGFsKCdBY2NvdW50IHNvb24gcmVhZHknLCAnWW91ciBhY2NvdW50IGhhcyBiZWVuIGFwcHJvdmVkLi4uPGJyIC8+PGJyLz4nICtcclxuICAgICAgICAgICAgICAgICAgICAnLi5idXQsIGFmdGVyIHdlIGFwcHJvdmUgeW91ciBhY2NvdW50LCB3ZSB3cml0ZSB0aGUgaW5mb3JtYXRpb24gdG8gdGhlIGJsb2NrY2hhaW4uJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBUaGlzIHVzdWFsbHkgdGFrZXMganVzdCBmZXcoMi0zKSBtaW51dGVzLjxiciAvPjxici8+IElmIHRoaXMgaXMgdGFraW5nIGxvbmdlciwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3BsZWFzZSBlbWFpbCB1cyBhdCA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwibWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXQ/c3ViamVjdD1LWUMgaXMgYmVpbmcgd3JpdHRlbiB0byBibG9ja2NoYWluJmJvZHk9SGksIGNhbiB5b3UgaGVscCBtZSB0byBmaW5kIG91dCB3aGF0IHRoZSBwcm9ibGVtIGlzPyBNeSBuYW1lIGlzIF9fX19fX18gYW5kIEkgdXNlZCB0aGUgZW1haWwgX19fX19fXyB0byByZWdpc3RlciBhdCBsaW1pbmFsLm1hcmtldFwiPmluZm9AbGltaW5hbC5tYXJrZXQ8L2E+Jyk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IGt5Y0Zvcm0gPSBuZXcgS1lDRm9ybShhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVUcmFkZUJ1dHRvbi5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGt5Y0Zvcm0uc2hvd0tZQ0Zvcm0oKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93TW9kYWwodGl0bGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgICAgIG1vZGFsLnNob3dNb2RhbCh0aXRsZSwgY29udGVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGgyPllvdSBhcmUgYWNjb3VudCBoYXMgYmVlbiBhcHByb3ZlZDwvaDI+XFxyXFxuPHA+V2UgaGF2ZSBhcHByb3ZlZCB5b3VyIGFjY291bnQuIFlvdSBjYW4gbm93IGZ1bmQgeW91ciBhY2NvdW50IGFuZCBzdGFydCB0byB0cmFkZS5cXHJcXG5cXHJcXG4gICAgPGJ1dHRvbiBpZD1cXFwia3ljQXBwcm92ZWRGdW5kXFxcIj5GdW5kIGFjY291bnQ8L2J1dHRvbj5cXHJcXG48L3A+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBNb2RhbCBmcm9tIFwiLi4vTW9kYWxcIjtcclxuaW1wb3J0IEZha2VBVVNERnVuZCBmcm9tIFwiLi4vRnVuZGluZy9GYWtlQVVTREZ1bmRcIjtcclxuaW1wb3J0IEt5Y0FwcHJvdmVkSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNBcHByb3ZlZC5odG1sJztcclxuaW1wb3J0IEV4ZWN1dGVPcmRlckJ1dHRvbiBmcm9tIFwiLi4vLi4vZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlT3JkZXJCdXR0b25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0FwcHJvdmVkIHtcclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljQXBwcm92ZWRIdG1sKTtcclxuICAgICAgICBsZXQgbW9kYWwgPSBuZXcgTW9kYWwoKTtcclxuICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ0FjY291bnQgYXBwcm92ZWQnLCB0ZW1wbGF0ZSh7fSkpO1xyXG5cclxuICAgICAgICBsZXQgZnVuZEFjY291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQXBwcm92ZWRGdW5kJyk7XHJcbiAgICAgICAgZnVuZEFjY291bnQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBtb2RhbC5oaWRlTW9kYWwoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhdXNkRnVuZCA9IG5ldyBGYWtlQVVTREZ1bmQoKTtcclxuICAgICAgICAgICAgYXVzZEZ1bmQuc2hvd0FVU0RGYWtlRnVuZCgpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgaWYgKEV4ZWN1dGVPcmRlckJ1dHRvbi5JbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKEV4ZWN1dGVPcmRlckJ1dHRvbi5JbnN0YW5jZS5reWNJZERvbmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgRXhlY3V0ZU9yZGVyQnV0dG9uLkluc3RhbmNlLnJlbmRlckJ1dHRvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgQXBwIGZyb20gXCIuLi8uLi8uLi9tYWluXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcmRlclByb2dyZXNzIHtcclxuICAgIHByb2dyZXNzTnI6IG51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogT3JkZXJQcm9ncmVzcyA9IG5ldyBPcmRlclByb2dyZXNzKCk7XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhclByb2dyZXNzVGV4dCgpIHtcclxuICAgICAgICBsZXQgZXhlY3V0aW5nT3JkZXJQcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGVjdXRpbmctb3JkZXItcHJvZ3Jlc3MnKVxyXG4gICAgICAgIGV4ZWN1dGluZ09yZGVyUHJvZ3Jlc3M/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NOciA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFByb2dyZXNzVGV4dChwcm9ncmVzc05yOiBudW1iZXIsIHRleHQ6IHN0cmluZywgaGFzaDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ3RoaXNOcicsIHRoaXMucHJvZ3Jlc3NOciwgJ25yJywgcHJvZ3Jlc3NOciwgJ3RleHQnLCB0ZXh0KTtcclxuICAgICAgICBpZiAocHJvZ3Jlc3NOciA8IHRoaXMucHJvZ3Jlc3NOcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgZXhlY3V0aW5nT3JkZXJQcm9ncmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGVjdXRpbmctb3JkZXItcHJvZ3Jlc3MnKVxyXG4gICAgICAgIGlmICghZXhlY3V0aW5nT3JkZXJQcm9ncmVzcykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcHJvZ3Jlc3NUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyZXNzLXRleHQnKTtcclxuICAgICAgICBpZiAoIXByb2dyZXNzVGV4dCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBBcHAuTmV0d29yaztcclxuICAgICAgICBwcm9ncmVzc1RleHQuaW5uZXJIVE1MID0gdGV4dCArICc8YnIgLz48YSBocmVmPVwiJyArIG5ldHdvcmtJbmZvLkJsb2NrRXhwbG9yZXIgKyAnL3R4LycgKyBoYXNoICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiIHN0eWxlPVwiZm9udC1zaXplOjEwcHhcIj5WaWV3PC9hPic7XHJcbiAgICAgICAgZXhlY3V0aW5nT3JkZXJQcm9ncmVzcy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICB0aGlzLnByb2dyZXNzTnIgPSBwcm9ncmVzc05yO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vLi4vLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IENvbm5lY3RXYWxsZXQgZnJvbSBcIi4uLy4uL21vZGFscy9Db25uZWN0V2FsbGV0XCI7XHJcbmltcG9ydCBLWUNTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0tZQ1NlcnZpY2VcIjtcclxuaW1wb3J0IEFVU0RTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0FVU0RTZXJ2aWNlXCI7XHJcbmltcG9ydCBGYWtlQVVTREZ1bmQgZnJvbSBcIi4uLy4uL21vZGFscy9GdW5kaW5nL0Zha2VBVVNERnVuZFwiO1xyXG5pbXBvcnQgU2VjdXJpdHlUb2tlblNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2Jsb2NrY2hhaW4vU2VjdXJpdHlUb2tlblNlcnZpY2VcIjtcclxuaW1wb3J0IExpbWluYWxNYXJrZXRTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0xpbWluYWxNYXJrZXRTZXJ2aWNlXCI7XHJcbmltcG9ydCB7QWRkcmVzc1plcm8sIHNob3dCYXJ9IGZyb20gXCIuLi8uLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgVHJhZGVQYW5lbElucHV0IGZyb20gXCIuL1RyYWRlUGFuZWxJbnB1dFwiO1xyXG5pbXBvcnQgRXhlY3V0ZVRyYWRlQnV0dG9uSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvRXhlY3V0ZVRyYWRlQnV0dG9uLmh0bWwnO1xyXG5pbXBvcnQgQmxvY2tjaGFpbkVycm9yIGZyb20gXCIuLi8uLi8uLi9lcnJvcnMvQmxvY2tjaGFpbkVycm9yXCI7XHJcbmltcG9ydCBOYXRpdmVUb2tlbk5lZWRlZCBmcm9tIFwiLi4vLi4vbW9kYWxzL05hdGl2ZVRva2VuTmVlZGVkXCI7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xyXG5pbXBvcnQgS3ljU3RhdHVzSGFuZGxlciBmcm9tIFwiLi4vLi4vbW9kYWxzL0tZQy9LeWNTdGF0dXNIYW5kbGVyXCI7XHJcbmltcG9ydCBBVXNkQmFsYW5jZSBmcm9tIFwiLi4vQVVzZEJhbGFuY2VcIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQgS3ljQXBwcm92ZWQgZnJvbSBcIi4uLy4uL21vZGFscy9LWUMvS3ljQXBwcm92ZWRcIjtcclxuaW1wb3J0IE9yZGVyUHJvZ3Jlc3MgZnJvbSBcIi4vT3JkZXJQcm9ncmVzc1wiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV4ZWN1dGVPcmRlckJ1dHRvbiB7XHJcbiAgICBhdXRoZW50aWNhdGVTZXJ2aWNlOiBBdXRoZW50aWNhdGVTZXJ2aWNlO1xyXG4gICAgc2VsbFRyYWRlSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dDtcclxuICAgIGJ1eVRyYWRlSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dDtcclxuICAgIHRlbXBsYXRlOiBhbnk7XHJcbiAgICBidXR0b246IEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICBzdGF0aWMgSW5zdGFuY2U6IEV4ZWN1dGVPcmRlckJ1dHRvbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzZWxsVHJhZGVJbnB1dDogVHJhZGVQYW5lbElucHV0LCBidXlUcmFkZUlucHV0OiBUcmFkZVBhbmVsSW5wdXQpIHtcclxuXHJcbiAgICAgICAgdGhpcy5zZWxsVHJhZGVJbnB1dCA9IHNlbGxUcmFkZUlucHV0O1xyXG4gICAgICAgIHRoaXMuYnV5VHJhZGVJbnB1dCA9IGJ1eVRyYWRlSW5wdXQ7XHJcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlID0gbmV3IEF1dGhlbnRpY2F0ZVNlcnZpY2UoKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEV4ZWN1dGVUcmFkZUJ1dHRvbkh0bWwpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X2V4ZWN1dGVfdHJhZGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBFeGVjdXRlT3JkZXJCdXR0b24uSW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXJCdXR0b24oKSB7XHJcbiAgICAgICAgdGhpcy5idXR0b24ub3V0ZXJIVE1MID0gdGhpcy5idXR0b24ub3V0ZXJIVE1MO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X2V4ZWN1dGVfdHJhZGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRpbmdCdXR0b24odGhpcy5idXR0b24pO1xyXG5cclxuICAgICAgICAvL3dhbGxldCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIXRoaXMud2FsbGV0SXNDb25uZWN0ZWQodGhpcy5idXR0b24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy91c2VyIGxvZ2dlZCBpblxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy51c2VySXNMb2dnZWRJbih0aGlzLmJ1dHRvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NoYWluIGlkIGNvcnJlY3RcclxuICAgICAgICBpZiAoIXRoaXMuY2hhaW5JZElzQ29ycmVjdCh0aGlzLmJ1dHRvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL25hdGl2ZSB0b2tlbiBpcyBhdmFpbGFibGVcclxuICAgICAgICBpZiAoIWF3YWl0IHRoaXMudXNlckhhc05hdGl2ZVRva2VuKHRoaXMuYnV0dG9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8va3ljIGlzIGRvbmVcclxuICAgICAgICBpZiAoIWF3YWl0IHRoaXMua3ljSXNEb25lKHRoaXMuYnV0dG9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vYXVzZCBpcyBzZXR1cFxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy51c2VySGFzQVVTRCh0aGlzLmJ1dHRvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hdXNkID4gYnV5IGFtb3VudFxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy51c2VySGFzRW5vdWdoUXR5KHRoaXMuYnV0dG9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzUXVhbnRpdHlBbmRTeW1ib2wodGhpcy5idXR0b24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy5pc01hcmtldE9wZW4odGhpcy5idXR0b24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlRXhlY3V0ZU9yZGVyKHRoaXMuYnV0dG9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGVuYWJsZUV4ZWN1dGVPcmRlcihidXR0b246IEhUTUxFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vaWYgKHRoaXMuc2VsbFRyYWRlSW5wdXQucXVhbnRpdHkuZXEoMCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy9leGVjdXRlIHRyYWRlIGNhbiBiZSBkb25lXHJcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdFeGVjdXRlIHRyYWRlJztcclxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlcGxhY2UoJ2Rpc2FibGVkJywgJ2VuYWJsZWQnKTtcclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcblxyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcblxyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0NvbmZpcm0gdHJhbnNhY3Rpb24gaW4geW91ciB3YWxsZXQnO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsbFRyYWRlSW5wdXQuc3ltYm9sID09ICdhVVNEJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbWluYWxNYXJrZXRTZXJ2aWNlID0gbmV3IExpbWluYWxNYXJrZXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sQWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyh0aGlzLmJ1eVRyYWRlSW5wdXQuc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sQWRkcmVzcyA9PT0gQWRkcmVzc1plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbGltaW5hbE1hcmtldFNlcnZpY2UuY3JlYXRlVG9rZW4odGhpcy5idXlUcmFkZUlucHV0LnN5bWJvbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0NyZWF0aW5nIHRva2VuLiBHaXZlIGl0IGZldyBzZWNvbmRzJztcclxuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0V4ZWN1dGUgdHJhZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBCbG9ja2NoYWluRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0JhcignRXJyb3I6JyArIHJlc3VsdC5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEFkZHJlc3MgPSByZXN1bHQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZVRyYW5zZmVyKHN5bWJvbEFkZHJlc3MsIHRoaXMuc2VsbFRyYWRlSW5wdXQucXVhbnRpdHksIG5ldyBBVVNEU2VydmljZSgpLCBidXR0b24pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGV0IGxpbWluYWxNYXJrZXRTZXJ2aWNlID0gbmV3IExpbWluYWxNYXJrZXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sQWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyh0aGlzLnNlbGxUcmFkZUlucHV0LnN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlVHJhbnNmZXIoc3ltYm9sQWRkcmVzcywgdGhpcy5zZWxsVHJhZGVJbnB1dC5xdWFudGl0eSwgbmV3IFNlY3VyaXR5VG9rZW5TZXJ2aWNlKCksIGJ1dHRvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZXhlY3V0ZVRyYW5zZmVyKHN5bWJvbEFkZHJlc3M6IHN0cmluZywgcXVhbnRpdHk6IEJpZ051bWJlciwgc2VydmljZTogQVVTRFNlcnZpY2UgfCBTZWN1cml0eVRva2VuU2VydmljZSwgYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG5cclxuICAgICAgICBhd2FpdCBzZXJ2aWNlLnRyYW5zZmVyKHN5bWJvbEFkZHJlc3MsIHF1YW50aXR5KVxyXG4gICAgICAgICAgICAudGhlbih0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0V4ZWN1dGUgdHJhZGUnO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbikgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgT3JkZXJQcm9ncmVzcy5nZXRJbnN0YW5jZSgpLnNldFByb2dyZXNzVGV4dCgwLCAnU2VuZGluZyB0byBibG9ja2NoYWluJywgdHJhbnNhY3Rpb24uaGFzaClcclxuICAgICAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBtc2cgPSByZWFzb24udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDQVRDSCAtIGNvbnRyYWN0LnRyYW5zZmVyJywgcmVhc29uKTtcclxuICAgICAgICAgICAgICAgIGlmIChtc2cuaW5kZXhPZignTWFya2V0IGlzIGNsb3NlZCcpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b24uaW5uZXJIVE1MID0gJ01hcmtldCBpcyBjbG9zZWQnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0V4ZWN1dGUgdHJhZGUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcExvYWRpbmdCdXR0b24oYnV0dG9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgbG9hZGluZ0J1dHRvbihidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBidXR0b24ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWJ1c3knKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHdhbGxldElzQ29ubmVjdGVkKGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoQXBwLlVzZXIucHJvdmlkZXIpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0Nvbm5lY3Qgd2FsbGV0JztcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0V2FsbGV0ID0gbmV3IENvbm5lY3RXYWxsZXQoKTtcclxuICAgICAgICAgICAgYXdhaXQgY29ubmVjdFdhbGxldC5jb25uZWN0V2FsbGV0KGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHVzZXJJc0xvZ2dlZEluKGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoQXBwLlVzZXIuaXNMb2dnZWRJbikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnTG9naW4nO1xyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlLmF1dGhlbnRpY2F0ZVVzZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2hhaW5JZElzQ29ycmVjdChidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IGNoYWluSWQgPSBBcHAuVXNlci5jaGFpbklkO1xyXG4gICAgICAgIGlmIChjaGFpbklkID09PSBBcHAuTmV0d29yay5DaGFpbklkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgbGV0IHVzZXJzV2FsbGV0TmV0d29yayA9IE5ldHdvcmtJbmZvLmdldE5ldHdvcmtJbmZvQnlDaGFpbklkKGNoYWluSWQpO1xyXG4gICAgICAgIGlmICh1c2Vyc1dhbGxldE5ldHdvcmspIHtcclxuICAgICAgICAgICAgTmV0d29ya0luZm8uc2V0TmV0d29ya0J5Q2hhaW5JZChjaGFpbklkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1N3aXRjaCBOZXR3b3JrJztcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IEFwcC5OZXR3b3JrLmFkZE5ldHdvcmtUb1dhbGxldCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyB1c2VySGFzTmF0aXZlVG9rZW4oYnV0dG9uOiBIVE1MRWxlbWVudCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IEFwcC5OZXR3b3JrO1xyXG4gICAgICAgIGxldCBoYXNFbm91Z2hOYXRpdmVUb2tlbnMgPSBhd2FpdCBuZXR3b3JrSW5mby5oYXNFbm91Z2hOYXRpdmVUb2tlbnMoKTtcclxuICAgICAgICBpZiAoaGFzRW5vdWdoTmF0aXZlVG9rZW5zKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZXBsYWNlKCdlbmFibGVkJywgJ2Rpc2FibGVkJyk7XHJcblxyXG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnWW91IG5lZWQgJyArIG5ldHdvcmtJbmZvLk5hdGl2ZUN1cnJlbmN5TmFtZSArICcgdG9rZW5zLiBDbGljayBtZSBmb3Igc29tZSB0b2tlbnMnO1xyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5hdGl2ZVRva2VuTmVlZGVkTW9kYWwgPSBuZXcgTmF0aXZlVG9rZW5OZWVkZWQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5hdGl2ZVRva2VuTmVlZGVkTW9kYWwuc2hvdygpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3RvcExvYWRpbmdCdXR0b24oYnV0dG9uKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGt5Y0lkRG9uZVRpbWVvdXQ6IGFueTtcclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGt5Y0lzRG9uZShidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IGt5Y1NlcnZpY2UgPSBuZXcgS1lDU2VydmljZSgpO1xyXG4gICAgICAgIGxldCBreWNSZXNwb25zZSA9IGF3YWl0IGt5Y1NlcnZpY2UuaGFzVmFsaWRLWUMoKTtcclxuXHJcbiAgICAgICAgaWYgKCFreWNSZXNwb25zZS5pc1ZhbGlkS3ljKSB7XHJcbiAgICAgICAgICAgIGxldCBreWNTdGF0dXNIYW5kbGVyID0gbmV3IEt5Y1N0YXR1c0hhbmRsZXIoa3ljUmVzcG9uc2UsIHRoaXMpO1xyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0ga3ljU3RhdHVzSGFuZGxlci5nZXRCdXR0b25UZXh0KCk7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGt5Y1N0YXR1c0hhbmRsZXIuZ2V0QnV0dG9uQ2xpY2tFdmVudCh0aGlzKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoa3ljUmVzcG9uc2Uuc3RhdHVzID09ICdBQ1RJVkUnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdCdXR0b24oYnV0dG9uKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0lkRG9uZVRpbWVvdXQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAga3ljUmVzcG9uc2UgPSBhd2FpdCBreWNTZXJ2aWNlLmhhc1ZhbGlkS1lDKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGt5Y1Jlc3BvbnNlLmlzVmFsaWRLeWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNCdXlpbmdQb3dlciA9IGt5Y1Jlc3BvbnNlLmhhc0J1eWluZ1Bvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQnV5aW5nUG93ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBreWNBcHByb3ZlZCA9IG5ldyBLeWNBcHByb3ZlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga3ljQXBwcm92ZWQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5reWNJZERvbmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJCdXR0b24oKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIDMwICogMTAwMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuc3RvcExvYWRpbmdCdXR0b24oYnV0dG9uKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tCYWxhbmNlSW50ZXJ2YWw6IGFueTtcclxuICAgIGhhc0J1eWluZ1Bvd2VyID0gZmFsc2U7XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyB1c2VySGFzQVVTRChidXR0b246IEhUTUxFbGVtZW50KTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgbGV0IGF1c2RTZXJ2aWNlID0gbmV3IEFVU0RTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IGJhbGFuY2UgPSBhd2FpdCBhdXNkU2VydmljZS5nZXRBVVNEQmFsYW5jZU9mKEFwcC5Vc2VyLmFkZHJlc3MpO1xyXG4gICAgICAgIGlmIChiYWxhbmNlLmlzR3JlYXRlclRoYW4oMCkpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5oYXNCdXlpbmdQb3dlcikge1xyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1dlIGFyZSBmdW5kaW5nIHlvdXIgYVVTRCB0b2tlbic7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCYWxhbmNlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBBVVNEU2VydmljZS5sYXN0VXBkYXRlID0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgYXVzZFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZihBcHAuVXNlci5hZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgIGlmIChiYWxhbmNlLmlzR3JlYXRlclRoYW4oMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBBVXNkQmFsYW5jZS5mb3JjZUxvYWRBVVNEQmFsYW5jZVVJKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jaGVja0JhbGFuY2VJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgMTAgKiAxMDAwKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChBcHAuTmV0d29yay5UZXN0TmV0d29yaykge1xyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1lvdSBuZWVkIGFVU0QuIENsaWNrIGhlcmUgdG8gZ2V0IHNvbWUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnWW91IG5lZWQgYVVTRC4gQ2xpY2sgaGVyZSBmb3IgaW5zdHJ1Y3Rpb25zJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYXVzZEZ1bmQgPSBuZXcgRmFrZUFVU0RGdW5kKCk7XHJcbiAgICAgICAgICAgIGF1c2RGdW5kLnNob3dBVVNERmFrZUZ1bmQoKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIHVzZXJIYXNFbm91Z2hRdHkoYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG5cclxuICAgICAgICBsZXQgYXVzZFNlcnZpY2UgPSBuZXcgQVVTRFNlcnZpY2UoKTtcclxuICAgICAgICBpZiAodGhpcy5zZWxsVHJhZGVJbnB1dC5zeW1ib2wgPT0gJ2FVU0QnKSB7XHJcbiAgICAgICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgYXVzZFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZihBcHAuVXNlci5hZGRyZXNzKTtcclxuICAgICAgICAgICAgaWYgKGJhbGFuY2UuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyh0aGlzLnNlbGxUcmFkZUlucHV0LnF1YW50aXR5KSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gXCJZb3UgZG9uJ3QgaGF2ZSBlbm91Z2ggYVVTRC4gQ2xpY2sgZm9yIG1vcmUgZnVuZGluZ1wiO1xyXG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXVzZEZ1bmQgPSBuZXcgRmFrZUFVU0RGdW5kKCk7XHJcbiAgICAgICAgICAgICAgICBhdXNkRnVuZC5zaG93QVVTREZha2VGdW5kKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHNlY3VyaXR5VG9rZW5TZXJ2aWNlID0gbmV3IFNlY3VyaXR5VG9rZW5TZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgIGxldCB1c2VyUXVhbnRpdHkgPSBhd2FpdCBzZWN1cml0eVRva2VuU2VydmljZS5nZXRRdWFudGl0eUJ5QWRkcmVzcyh0aGlzLnNlbGxUcmFkZUlucHV0LnN5bWJvbCwgQXBwLlVzZXIuYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGxUcmFkZUlucHV0LnF1YW50aXR5IDw9IHVzZXJRdWFudGl0eSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gXCJZb3UgZG9uJ3QgaGF2ZSBlbm91Z2ggXCIgKyB0aGlzLnNlbGxUcmFkZUlucHV0LnN5bWJvbDtcclxuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZXBsYWNlKCdkaXNhYmxlJywgJ2VuYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgaXNNYXJrZXRPcGVuKGJ1dHRvbjogSFRNTEVsZW1lbnQpOiBQcm9taXNlPGJvb2xlYW4+IHtcclxuICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgaXNNYXJrZXRPcGVuID0gYXdhaXQgdXNlclNlcnZpY2UuaXNNYXJrZXRPcGVuT3JVc2VyT2ZmSG91cnMoKTtcclxuICAgICAgICBpZiAoaXNNYXJrZXRPcGVuKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdNYXJrZXQgaXMgY2xvc2VkJ1xyXG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVwbGFjZSgnZW5hYmxlZCcsICdkaXNhYmxlZCcpO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhc1F1YW50aXR5QW5kU3ltYm9sKGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5zZWxsVHJhZGVJbnB1dC5xdWFudGl0eS5lcSgwKSkge1xyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1R5cGUgaW4gcXVhbnRpdHknO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmJ1eVRyYWRlSW5wdXQubmFtZSA9PSAnJykge1xyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1NlbGVjdCBzdG9jayB0byBidXknO1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG5cclxufSIsImV4cG9ydCBlbnVtIFRyYWRlVHlwZSB7XHJcbiAgICBTZWxsID0gJ1NlbGwnLFxyXG4gICAgQnV5ID0gJ0J1eSdcclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxhcnRpY2xlIGNsYXNzPVxcXCJ7e3RyYWRlVHlwZX19SW5wdXRzIHRyYWRlSW5wdXRBcnRpY2xlXFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZCB0cmFkZUlucHV0XFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNlbGVjdF90b2tlblxcXCI+XFxyXFxuICAgICAgICAgICAgPGEgaWQ9XFxcInt7dHJhZGVUeXBlfX1TZWxlY3RTdG9ja1xcXCIgaHJlZj1cXFwiI1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcInt7bG9nb319XFxcIi8+XFxyXFxuICAgICAgICAgICAgICAgIHt7c3ltYm9sfX1cXHJcXG4gICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWRlX2lucHV0XFxcIj48aW5wdXQgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIHR5cGU9XFxcInRlbFxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCJ7e3N0clF1YW50aXR5fX1cXFwiIHBsYWNlaG9sZGVyPVxcXCIwLjBcXFwiLz48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJhbGFuY2VcXFwiPkJhbGFuY2UgOiA8YWJiciB0aXRsZT1cXFwie3tiYWxhbmNlfX1cXFwiIGRhdGEtdG9vbHRpcD1cXFwie3tiYWxhbmNlfX1cXFwiIGNsYXNzPVxcXCJiYWxhbmNlX3ZhbHVlXFxcIj57e2FiYnJCYWxhbmNlfX08L2FiYnI+XFxyXFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiXFxcIiBjbGFzcz1cXFwiYmFsYW5jZV9tYXhcXFwiPk1heDwvYT48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByaWNlX3Blcl9zaGFyZVxcXCI+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8cHJvZ3Jlc3MgY2xhc3M9XFxcInByb2dyZXNzIGQtbm9uZVxcXCIgdmFsdWU9XFxcIjBcXFwiIG1heD1cXFwiMVxcXCI+PC9wcm9ncmVzcz5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZXhjZWVkc193YWxsZXRfYmFsYW5jZSBkLW5vbmVcXFwiPkV4Y2VlZHMgd2FsbGV0IGJhbGFuY2U8L2Rpdj5cXHJcXG48L2FydGljbGU+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBNb2RhbCBmcm9tIFwiLi9Nb2RhbFwiO1xyXG5pbXBvcnQgU2VjdXJpdGllc0xpc3QgZnJvbSBcIi4uL2VsZW1lbnRzL1NlY3VyaXRpZXNMaXN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWN1cml0aWVzTGlzdE1vZGFsIHtcclxuICAgIHBhZ2U6IG51bWJlcjtcclxuICAgIHRib2R5SWQgPSAnbGltaW5hbF9tYXJrZXRfc2VjdXJpdGllc19saXN0JztcclxuICAgIGxvYWRtb3JlOiBib29sZWFuO1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2FkbW9yZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93TW9kYWwob25TZWxlY3RTeW1ib2w6IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgc2VjdXJpdGllc0xpc3QgPSBuZXcgU2VjdXJpdGllc0xpc3QoKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IGF3YWl0IHNlY3VyaXRpZXNMaXN0LnJlbmRlcigpO1xyXG5cclxuICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSB0aGlzLm1vZGFsLnNob3dNb2RhbCgnU2VsZWN0IHN0b2NrIHRvIGJ1eScsIGNvbnRlbnQsXHJcbiAgICAgICAgICAgIHRydWUpO1xyXG4gICAgICAgIC8vaWYgKG5ld0luc3RhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXdhaXQgc2VjdXJpdGllc0xpc3QuYmluZEV2ZW50cyhvblNlbGVjdFN5bWJvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGVNb2RhbCgpIHtcclxuICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhZGVJbmZvIHtcclxuICAgIHByaWNlIDogbnVtYmVyO1xyXG4gICAgbGFzdFRyYWRlIDogRGF0ZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwcmljZSA6IG51bWJlciwgbGFzdFRyYWRlIDogRGF0ZSkge1xyXG4gICAgICAgIHRoaXMucHJpY2UgPSBwcmljZTtcclxuICAgICAgICB0aGlzLmxhc3RUcmFkZSA9IGxhc3RUcmFkZTtcclxuICAgIH1cclxufSIsImltcG9ydCBJQ2xvdWRFcnJvciBmcm9tIFwiLi9JQ2xvdWRFcnJvclwiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi9FcnJvckluZm9cIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi4vR2VuZXJhbEVycm9yXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIdHRwRXJyb3IgaW1wbGVtZW50cyBJQ2xvdWRFcnJvciB7XHJcbiAgICBtZXRob2QgOiBzdHJpbmc7XHJcbiAgICB1cmwgOiBzdHJpbmc7XHJcbiAgICBib2R5IDogc3RyaW5nO1xyXG4gICAgc2VydmVyRXJyb3IgOiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob2JqIDogYW55KSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBvYmoubWV0aG9kO1xyXG4gICAgICAgIHRoaXMudXJsID0gb2JqLnVybDtcclxuICAgICAgICB0aGlzLmJvZHkgPSBvYmouYm9keTtcclxuICAgICAgICB0aGlzLnNlcnZlckVycm9yID0gb2JqLnNlcnZlckVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzKTtcclxuICAgICAgICBFcnJvckluZm8ucmVwb3J0KG5ldyBHZW5lcmFsRXJyb3IoJ0Vycm9yIGRvaW5nIHJlcXVlc3QuIFNlcnZlciByZXNwb25zZSB3YXM6JyArIHRoaXMuc2VydmVyRXJyb3IuZGF0YS5tZXNzYWdlKSlcclxuXHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi9HZW5lcmFsRXJyb3JcIjtcclxuaW1wb3J0IEVycm9ySW5mbyBmcm9tIFwiLi9FcnJvckluZm9cIjtcclxuaW1wb3J0IEt5Y1ZhbGlkYXRvckVycm9yIGZyb20gXCIuL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBJQ2xvdWRFcnJvciBmcm9tIFwiLi9jbG91ZC9JQ2xvdWRFcnJvclwiO1xyXG5pbXBvcnQgSHR0cEVycm9yIGZyb20gXCIuL2Nsb3VkL0h0dHBFcnJvclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xvdWRFcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGU6IGFueSkge1xyXG4gICAgICAgIHN1cGVyKGUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChvYmoubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVycm9ySGFuZGxlciA9IENsb3VkRXJyb3IuZ2V0QWN0aW9uSW5zdGFuY2Uob2JqLm5hbWUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmhhbmRsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRXJyb3JJbmZvLmVycm9yKG9iaik7XHJcbiAgICAgICAgfSBjYXRjaCAoanNvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIEVycm9ySW5mby5lcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRBY3Rpb25JbnN0YW5jZShhY3Rpb246IHN0cmluZywgb2JqOiBhbnkpOiBJQ2xvdWRFcnJvciB7XHJcbiAgICAgICAgbGV0IHRtcDogYW55ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAobGV0IGk9MDtpPENsb3VkRXJyb3IuRXJyb3JzLmxlbmd0aDtpKyspIHtcclxuICAgICAgICAgICAgaWYgKENsb3VkRXJyb3IuRXJyb3JzW2ldLm5hbWUgPT09IGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVycm9ySGFuZGxlciA9IENsb3VkRXJyb3IuRXJyb3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBlcnJvckhhbmRsZXIob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgRXJyb3JzID0gW1xyXG4gICAgICAgIEh0dHBFcnJvclxyXG4gICAgXVxyXG59IiwiaW1wb3J0IFRyYWRlSW5mbyBmcm9tIFwiLi9UcmFkZUluZm9cIjtcclxuaW1wb3J0IENsb3VkRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9DbG91ZEVycm9yXCI7XHJcbmltcG9ydCB7VHJhZGVUeXBlfSBmcm9tIFwiLi4vLi4vZW51bXMvVHJhZGVUeXBlXCI7XHJcbmltcG9ydCBCYXNlU2VydmljZSBmcm9tIFwiLi9CYXNlU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvY2tQcmljZVNlcnZpY2UgZXh0ZW5kcyBCYXNlU2VydmljZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U3ltYm9sUHJpY2Uoc3ltYm9sOiBzdHJpbmcsIHRyYWRlVHlwZTogVHJhZGVUeXBlKTogUHJvbWlzZTxUcmFkZUluZm8+IHtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXQoXCJnZXRTeW1ib2xQcmljZVwiLCBwYXJhbXMpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2xvdWRFcnJvcihlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHF1b3RlID0gcmVzdWx0LnF1b3RlO1xyXG4gICAgICAgIGxldCBwcmljZSA9ICh0cmFkZVR5cGUgPT0gVHJhZGVUeXBlLlNlbGwpID8gcXVvdGUuYXAgOiBxdW90ZS5icDtcclxuICAgICAgICBsZXQgdHJhZGVJbmZvID0gbmV3IFRyYWRlSW5mbyhwcmljZSwgcXVvdGUudCk7XHJcbiAgICAgICAgcmV0dXJuIHRyYWRlSW5mbztcclxuXHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YWJiciB0aXRsZT1cXFwiTGFzdCB0cmFkZSB3YXMge3tsYXN0VHJhZGVkfX1cXFwiIGRhdGEtdG9vbHRpcD1cXFwiTGFzdCB0cmFkZSB3YXMge3tsYXN0VHJhZGVkfX1cXFwiPnt7dGV4dH19PC9hYmJyPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgVHJhZGVJbnB1dEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9lbGVtZW50cy90cmFkZXBhbmVsL1RyYWRlSW5wdXQuaHRtbCc7XHJcbmltcG9ydCB7VHJhZGVUeXBlfSBmcm9tIFwiLi4vLi4vLi4vZW51bXMvVHJhZGVUeXBlXCI7XHJcbmltcG9ydCBTZWN1cml0aWVzTGlzdE1vZGFsIGZyb20gXCIuLi8uLi9tb2RhbHMvU2VjdXJpdGllc0xpc3RNb2RhbFwiO1xyXG5pbXBvcnQgTGltaW5hbE1hcmtldFNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2Jsb2NrY2hhaW4vTGltaW5hbE1hcmtldFNlcnZpY2VcIjtcclxuaW1wb3J0IFNlY3VyaXR5VG9rZW5TZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL1NlY3VyaXR5VG9rZW5TZXJ2aWNlXCI7XHJcbmltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IHtyb3VuZE51bWJlckRlY2ltYWx9IGZyb20gXCIuLi8uLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgU3RvY2tQcmljZVNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvU3RvY2tQcmljZVNlcnZpY2VcIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbmltcG9ydCBQcmljZVBlclNoYXJlSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvUHJpY2VQZXJTaGFyZS5odG1sJ1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWRlUGFuZWxJbnB1dCB7XHJcbiAgICBzeW1ib2w6IHN0cmluZztcclxuICAgIG5hbWU6IHN0cmluZztcclxuICAgIGxvZ286IHN0cmluZztcclxuICAgIGFkZHJlc3M6IHN0cmluZztcclxuICAgIHJlYWRvbmx5IHRyYWRlVHlwZTogVHJhZGVUeXBlO1xyXG4gICAgcXVhbnRpdHk6IEJpZ051bWJlcjtcclxuICAgIHN0clF1YW50aXR5IDogc3RyaW5nO1xyXG4gICAgYmFsYW5jZTogQmlnTnVtYmVyO1xyXG4gICAgbGFzdFByaWNlOiBudW1iZXI7XHJcbiAgICBsYXN0VHJhZGVkOiBzdHJpbmc7XHJcbiAgICBxdHlQZXJEb2xsYXI6IG51bWJlcjtcclxuICAgIHRlbXBsYXRlOiBhbnk7XHJcbiAgICBwcmljZVBlclNoYXJlVGVtcGxhdGU6IGFueTtcclxuICAgIG90aGVyVHJhZGVQYW5lbElucHV0OiBUcmFkZVBhbmVsSW5wdXQgfCB1bmRlZmluZWQ7XHJcbiAgICBvblVwZGF0ZSA6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcclxuICAgIGlzRGlydHkgOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioc3ltYm9sOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbG9nbzogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcsIHRyYWRlVHlwZTogVHJhZGVUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmxvZ28gPSBsb2dvO1xyXG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XHJcbiAgICAgICAgdGhpcy50cmFkZVR5cGUgPSB0cmFkZVR5cGU7XHJcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcbiAgICAgICAgdGhpcy5zdHJRdWFudGl0eSA9ICcnO1xyXG4gICAgICAgIHRoaXMuYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcbiAgICAgICAgdGhpcy5sYXN0UHJpY2UgPSAwO1xyXG4gICAgICAgIHRoaXMucXR5UGVyRG9sbGFyID0gMDtcclxuICAgICAgICB0aGlzLmxhc3RUcmFkZWQgPSAnJztcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFRyYWRlSW5wdXRIdG1sKTtcclxuICAgICAgICB0aGlzLnByaWNlUGVyU2hhcmVUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShQcmljZVBlclNoYXJlSHRtbCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRPdGhlclRyYWRlUGFuZWxJbnB1dCh0cmFkZVBhbmVsSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dCkge1xyXG4gICAgICAgIHRoaXMub3RoZXJUcmFkZVBhbmVsSW5wdXQgPSB0cmFkZVBhbmVsSW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlclRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihiaW5kRXZlbnRzIDogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgZWxlbWVudC5vdXRlckhUTUwgPSB0aGlzLnJlbmRlclRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKGJpbmRFdmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuYmluZFF1YW50aXR5TGlzdGVuZXIoKTtcclxuICAgICAgICB0aGlzLmJpbmRTZWxlY3RTdG9ja0J1dHRvbigpO1xyXG4gICAgICAgIHRoaXMuYmluZE1heExpbmsoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0U3ltYm9sKHN5bWJvbDogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGxvZ286IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5sb2dvID0gbG9nbztcclxuXHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJpbmRTZWxlY3RTdG9ja0J1dHRvbigpIHtcclxuICAgICAgICBsZXQgc2VsZWN0U3RvY2sgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIHRoaXMudHJhZGVUeXBlICsgJ1NlbGVjdFN0b2NrJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoIXNlbGVjdFN0b2NrKSByZXR1cm47XHJcblxyXG4gICAgICAgIHNlbGVjdFN0b2NrLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzZWN1cml0eUxpc3QgPSBuZXcgU2VjdXJpdGllc0xpc3RNb2RhbCgpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZWN1cml0eUxpc3Quc2hvd01vZGFsKGFzeW5jIChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIHNlY3VyaXR5TGlzdC5oaWRlTW9kYWwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dCAmJiB0aGlzLnN5bWJvbCA9PSAnYVVTRCcgJiYgc3ltYm9sICE9IHRoaXMuc3ltYm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC5zZXRTeW1ib2wodGhpcy5zeW1ib2wsIHRoaXMubmFtZSwgdGhpcy5sb2dvKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3ltYm9sID0gc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nbyA9IGxvZ287XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxpbWluYWxNYXJrZXRTZXJ2aWNlID0gbmV3IExpbWluYWxNYXJrZXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3MgPSBhd2FpdCBsaW1pbmFsTWFya2V0U2VydmljZS5nZXRTeW1ib2xDb250cmFjdEFkZHJlc3Moc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQmFsYW5jZSgpLnRoZW4oKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZExhc3RUcmFkZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uVXBkYXRlKSB0aGlzLm9uVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBwcml2YXRlIGJpbmRRdWFudGl0eUxpc3RlbmVyKCkge1xyXG4gICAgICAgIGxldCBxdHlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC50cmFkZV9pbnB1dCBpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFxdHlJbnB1dCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgaW5wdXRUaW1lciA6IGFueTtcclxuICAgICAgICBxdHlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlucHV0VGltZXIpIGNsZWFyVGltZW91dChpbnB1dFRpbWVyKTtcclxuXHJcbiAgICAgICAgICAgIGlucHV0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpbnB1dFZhbHVlID0gKGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFF1YW50aXR5KGlucHV0VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkUHJvZ3Jlc3NiYXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dCkgdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC51cGRhdGVRdWFudGl0eSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25VcGRhdGUpIHRoaXMub25VcGRhdGUoKTtcclxuICAgICAgICAgICAgfSwgMzAwKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYmluZE1heExpbmsoKSB7XHJcbiAgICAgICAgbGV0IG1heEJhbGFuY2VEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAuYmFsYW5jZV9tYXgnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAoIW1heEJhbGFuY2VEb20pIHJldHVybjtcclxuXHJcbiAgICAgICAgbWF4QmFsYW5jZURvbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcXR5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAudHJhZGVfaW5wdXQgaW5wdXQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoIXF0eUlucHV0KSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBxdHlJbnB1dC52YWx1ZSA9IHRoaXMuYmFsYW5jZS50b0ZpeGVkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UXVhbnRpdHkocXR5SW5wdXQudmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRQcm9ncmVzc2JhcigpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3RoZXJUcmFkZVBhbmVsSW5wdXQpIHRoaXMub3RoZXJUcmFkZVBhbmVsSW5wdXQudXBkYXRlUXVhbnRpdHkoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25VcGRhdGUpIHRoaXMub25VcGRhdGUoKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkQmFsYW5jZSgpIHtcclxuICAgICAgICB0aGlzLmJhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKDApO1xyXG5cclxuICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgZXRoQWRkcmVzcyA9IHVzZXJTZXJ2aWNlLmdldEV0aEFkZHJlc3MoKTtcclxuXHJcbiAgICAgICAgbGV0IGJhbGFuY2VEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAuYmFsYW5jZV92YWx1ZScpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghYmFsYW5jZURvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5zeW1ib2wgPT09ICdhVVNEJykge1xyXG4gICAgICAgICAgICBpZiAoZXRoQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFVc2RTZXJ2aWNlID0gbmV3IEFVU0RTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhbGFuY2UgPSBhd2FpdCBhVXNkU2VydmljZS5nZXRBVVNEQmFsYW5jZU9mKGV0aEFkZHJlc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhbGFuY2VEb20uaW5uZXJIVE1MID0gJyQnICsgdGhpcy5iYWxhbmNlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgICB0aGlzLmJhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKDApO1xyXG4gICAgICAgICAgICBpZiAoZXRoQWRkcmVzcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3VyaXR5VG9rZW5TZXJ2aWNlID0gbmV3IFNlY3VyaXR5VG9rZW5TZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhbGFuY2UgPSBhd2FpdCBzZWN1cml0eVRva2VuU2VydmljZS5nZXRRdWFudGl0eUJ5QWRkcmVzcyh0aGlzLnN5bWJvbCwgZXRoQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFsYW5jZURvbS5pbm5lckhUTUwgPSB0aGlzLmJhbGFuY2UudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmFsYW5jZURvbS5kYXRhc2V0LnRvb2x0aXAgPSB0aGlzLmJhbGFuY2UudG9TdHJpbmcoKTtcclxuICAgICAgICBiYWxhbmNlRG9tLnRpdGxlID0gdGhpcy5iYWxhbmNlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZFByb2dyZXNzYmFyKCk7XHJcbiAgICAgICAgdGhpcy50b2dnbGVNYXhCYWxhbmNlTGluaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkTGFzdFRyYWRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbCA9PT0gJ2FVU0QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdFByaWNlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5xdHlQZXJEb2xsYXIgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dCB8fCB0aGlzLm5hbWUgPT0gJycpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGFVc2RQcmljZVBlclNoYXJlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnRyYWRlVHlwZSArICdJbnB1dHMgLnByaWNlX3Blcl9zaGFyZScpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghYVVzZFByaWNlUGVyU2hhcmUpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHByaWNlUGVyU2hhcmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAucHJpY2VfcGVyX3NoYXJlJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFwcmljZVBlclNoYXJlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGFVc2RQcmljZVBlclNoYXJlLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuICAgICAgICBwcmljZVBlclNoYXJlLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuXHJcbiAgICAgICAgbGV0IHN0b2NrUHJpY2VTZXJ2aWNlID0gbmV3IFN0b2NrUHJpY2VTZXJ2aWNlKCk7XHJcbiAgICAgICAgbGV0IHRyYWRlSW5mbyA9IGF3YWl0IHN0b2NrUHJpY2VTZXJ2aWNlLmdldFN5bWJvbFByaWNlKHRoaXMuc3ltYm9sLCB0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnRyYWRlVHlwZSk7XHJcblxyXG4gICAgICAgIHRoaXMubGFzdFByaWNlID0gdHJhZGVJbmZvLnByaWNlO1xyXG4gICAgICAgIHRoaXMubGFzdFRyYWRlZCA9IHRyYWRlSW5mby5sYXN0VHJhZGUudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLnF0eVBlckRvbGxhciA9IDEgLyB0aGlzLmxhc3RQcmljZTtcclxuXHJcbiAgICAgICAgbGV0IHByaWNlUGVyU2hhcmVIdG1sOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIGxhc3RUcmFkZWQ6IHRoaXMubGFzdFRyYWRlZCxcclxuICAgICAgICAgICAgdGV4dDogJ+KJiCAkJyArIHRoaXMubGFzdFByaWNlICsgJyBwZXIgc2hhcmUnXHJcbiAgICAgICAgfTtcclxuICAgICAgICBwcmljZVBlclNoYXJlLmlubmVySFRNTCA9IHRoaXMucHJpY2VQZXJTaGFyZVRlbXBsYXRlKHByaWNlUGVyU2hhcmVIdG1sKTtcclxuXHJcbiAgICAgICAgbGV0IHByaWNlUGVyQVVzZEh0bWw6IGFueSA9IHtcclxuICAgICAgICAgICAgbGFzdFRyYWRlZDogdGhpcy5sYXN0VHJhZGVkLFxyXG4gICAgICAgICAgICB0ZXh0OiAnMSBhVVNEIOKJiCAnICsgcm91bmROdW1iZXJEZWNpbWFsKHRoaXMucXR5UGVyRG9sbGFyLCA2KSArICcgJyArIHRoaXMuc3ltYm9sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBhVXNkUHJpY2VQZXJTaGFyZS5pbm5lckhUTUwgPSB0aGlzLnByaWNlUGVyU2hhcmVUZW1wbGF0ZShwcmljZVBlckFVc2RIdG1sKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVF1YW50aXR5KCk7XHJcblxyXG4gICAgICAgIGFVc2RQcmljZVBlclNoYXJlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1idXN5Jyk7XHJcbiAgICAgICAgcHJpY2VQZXJTaGFyZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGVRdWFudGl0eSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3RoZXJUcmFkZVBhbmVsSW5wdXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHF0eUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLnRyYWRlVHlwZSArICdJbnB1dHMgLnRyYWRlX2lucHV0IGlucHV0JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoIXF0eUlucHV0KSByZXR1cm47XHJcbiAgICAgICAgaWYgKHRoaXMuc3ltYm9sID09PSAnYVVTRCcpIHtcclxuICAgICAgICAgICAgcXR5SW5wdXQudmFsdWUgPSB0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnF1YW50aXR5LmRpdih0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnF0eVBlckRvbGxhcikudG9TdHJpbmcoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBxdHlJbnB1dC52YWx1ZSA9IHRoaXMub3RoZXJUcmFkZVBhbmVsSW5wdXQucXVhbnRpdHkubXVsdGlwbGllZEJ5KHRoaXMucXR5UGVyRG9sbGFyKS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFF1YW50aXR5KHF0eUlucHV0LnZhbHVlKTtcclxuICAgICAgICB0aGlzLmxvYWRQcm9ncmVzc2JhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZFByb2dyZXNzYmFyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnF1YW50aXR5LmVxKDApIHx8IHRoaXMuYmFsYW5jZS5lcSgwKSB8fCB0aGlzLnRyYWRlVHlwZSA9PSBUcmFkZVR5cGUuQnV5KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBwcm9ncmVzc0RvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC5wcm9ncmVzcycpIGFzIEhUTUxQcm9ncmVzc0VsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFwcm9ncmVzc0RvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcGVyY2VudGFnZSA9IHRoaXMucXVhbnRpdHkuZGl2KHRoaXMuYmFsYW5jZSkudG9OdW1iZXIoKTtcclxuICAgICAgICBwcm9ncmVzc0RvbS52YWx1ZSA9IHBlcmNlbnRhZ2U7XHJcbiAgICAgICAgcHJvZ3Jlc3NEb20uY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcblxyXG4gICAgICAgIGxldCBleGNlZWRzQmFsYW5jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC5leGNlZWRzX3dhbGxldF9iYWxhbmNlJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHBlcmNlbnRhZ2UgPiAxKSB7XHJcbiAgICAgICAgICAgIGV4Y2VlZHNCYWxhbmNlLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICBwcm9ncmVzc0RvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXhjZWVkc0JhbGFuY2UuY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgc3dpdGNoUGFuZWxzKHNlbGxUcmFkZVBhbmVsSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dCwgYnV5VHJhZGVQYW5lbElucHV0OiBUcmFkZVBhbmVsSW5wdXQpOiBQcm9taXNlPFtUcmFkZVBhbmVsSW5wdXQsIFRyYWRlUGFuZWxJbnB1dF0+IHtcclxuICAgICAgICBsZXQgc2VsbFN5bWJvbCA9IHNlbGxUcmFkZVBhbmVsSW5wdXQuc3ltYm9sO1xyXG4gICAgICAgIGxldCBzZWxsTmFtZSA9IHNlbGxUcmFkZVBhbmVsSW5wdXQubmFtZTtcclxuICAgICAgICBsZXQgc2VsbExvZ28gPSBzZWxsVHJhZGVQYW5lbElucHV0LmxvZ287XHJcbiAgICAgICAgbGV0IHNlbGxRdWFudGl0eSA9IHNlbGxUcmFkZVBhbmVsSW5wdXQucXVhbnRpdHk7XHJcbiAgICAgICAgc2VsbFRyYWRlUGFuZWxJbnB1dC5zZXRTeW1ib2woYnV5VHJhZGVQYW5lbElucHV0LnN5bWJvbCwgYnV5VHJhZGVQYW5lbElucHV0Lm5hbWUsIGJ1eVRyYWRlUGFuZWxJbnB1dC5sb2dvKVxyXG4gICAgICAgIHNlbGxUcmFkZVBhbmVsSW5wdXQucXVhbnRpdHkgPSBidXlUcmFkZVBhbmVsSW5wdXQucXVhbnRpdHk7XHJcbiAgICAgICAgYnV5VHJhZGVQYW5lbElucHV0LnNldFN5bWJvbChzZWxsU3ltYm9sLCBzZWxsTmFtZSwgc2VsbExvZ28pXHJcbiAgICAgICAgYnV5VHJhZGVQYW5lbElucHV0LnF1YW50aXR5ID0gc2VsbFF1YW50aXR5O1xyXG5cclxuICAgICAgICBhd2FpdCBzZWxsVHJhZGVQYW5lbElucHV0LnVwZGF0ZVBhbmVsKCk7XHJcbiAgICAgICAgYXdhaXQgYnV5VHJhZGVQYW5lbElucHV0LnVwZGF0ZVBhbmVsKCk7XHJcblxyXG4gICAgICAgIHJldHVybiBbc2VsbFRyYWRlUGFuZWxJbnB1dCwgYnV5VHJhZGVQYW5lbElucHV0XTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0UXVhbnRpdHkodmFsdWUgOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT0gJycgfHwgdmFsdWUgPT0gJzAnKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5xdWFudGl0eSA9IG5ldyBCaWdOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuc3RyUXVhbnRpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBxdWFudGl0eUZvcm1hdHRlZCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc3ltYm9sID09PSAnYVVTRCcpID8gJyQnICsgdGhpcy5xdWFudGl0eSA6IHRoaXMucXVhbnRpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZVBhbmVsKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlUXVhbnRpdHkoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcih0cnVlKTtcclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkQmFsYW5jZSgpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZExhc3RUcmFkZSgpO1xyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB0b2dnbGVNYXhCYWxhbmNlTGluaygpIHtcclxuICAgICAgICBsZXQgbWF4QmFsYW5jZURvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC5iYWxhbmNlX21heCcpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghbWF4QmFsYW5jZURvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5iYWxhbmNlLmVxKDApKSB7XHJcbiAgICAgICAgICAgIG1heEJhbGFuY2VEb20uY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF4QmFsYW5jZURvbS5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGl2IGNsYXNzPVxcXCJncmlkIHRyYWRlU3dpdGNoXFxcIj5cXHJcXG4gICAgPGEgdGl0bGU9XFxcIlN3aXRjaCB0aGUgdHJhZGVcXFwiIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcInN3aXRjaEJ0blxcXCIgY2xhc3M9XFxcIm91dGxpbmVcXFwiPjwvYT5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IFRyYWRlU3dpdGNoSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVTd2l0Y2guaHRtbCc7XHJcbmltcG9ydCBUcmFkZVBhbmVsSW5wdXQgZnJvbSBcIi4vVHJhZGVQYW5lbElucHV0XCI7XHJcbmltcG9ydCBFeGVjdXRlT3JkZXJCdXR0b24gZnJvbSBcIi4vRXhlY3V0ZU9yZGVyQnV0dG9uXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFkZVN3aXRjaCB7XHJcblxyXG4gICAgdGVtcGxhdGUgOiBhbnkgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShUcmFkZVN3aXRjaEh0bWwpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyVG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHJhZGVTd2l0Y2gnKTtcclxuICAgICAgICBpZiAoIWRvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBkb20ub3V0ZXJIVE1MID0gdGhpcy5yZW5kZXJUb1N0cmluZygpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoc2VsbFRyYWRlUGFuZWxJbnB1dDogVHJhZGVQYW5lbElucHV0LCBidXlUcmFkZVBhbmVsSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dCwgZXhlY3V0ZVRyYWRlQnV0dG9uOiBFeGVjdXRlT3JkZXJCdXR0b24pIHtcclxuICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnN3aXRjaEJ0bicpO1xyXG4gICAgICAgIGlmICghZG9tKSByZXR1cm47XHJcblxyXG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBbc2VsbFRyYWRlUGFuZWxJbnB1dCwgYnV5VHJhZGVQYW5lbElucHV0XSA9IGF3YWl0IFRyYWRlUGFuZWxJbnB1dC5zd2l0Y2hQYW5lbHMoc2VsbFRyYWRlUGFuZWxJbnB1dCwgYnV5VHJhZGVQYW5lbElucHV0KTtcclxuXHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgRXhlY3V0ZU9yZGVyQnV0dG9uIGZyb20gXCIuL3RyYWRlcGFuZWwvRXhlY3V0ZU9yZGVyQnV0dG9uXCI7XHJcbmltcG9ydCBTdG9ja1ByaWNlU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9TdG9ja1ByaWNlU2VydmljZVwiO1xyXG5pbXBvcnQge1RyYWRlVHlwZX0gZnJvbSBcIi4uLy4uL2VudW1zL1RyYWRlVHlwZVwiO1xyXG5pbXBvcnQgVHJhZGVQYW5lbElucHV0IGZyb20gXCIuL3RyYWRlcGFuZWwvVHJhZGVQYW5lbElucHV0XCI7XHJcbmltcG9ydCBDb250cmFjdEluZm8gZnJvbSBcIi4uLy4uL2NvbnRyYWN0cy9Db250cmFjdEluZm9cIjtcclxuaW1wb3J0IFRyYWRlU3dpdGNoIGZyb20gXCIuL3RyYWRlcGFuZWwvVHJhZGVTd2l0Y2hcIjtcclxuaW1wb3J0IFNlY3VyaXRpZXNMaXN0TW9kYWwgZnJvbSBcIi4uL21vZGFscy9TZWN1cml0aWVzTGlzdE1vZGFsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFkZVBhbmVsIHtcclxuICAgIHF1YW50aXR5IDogbnVtYmVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXIoZWxlbWVudElkIDogc3RyaW5nLCBzeW1ib2w/IDogc3RyaW5nLCBuYW1lPyA6IHN0cmluZywgbG9nbz8gOiBzdHJpbmcsIGFkZHJlc3M/IDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbygpO1xyXG5cclxuICAgICAgICBsZXQgc2VsbFRyYWRlSW5wdXQgPSBuZXcgVHJhZGVQYW5lbElucHV0KFwiYVVTRFwiLCBcImFVU0QgYXQgQnJva2VyXCIsIFwiL2ltZy9hdXNkLnBuZ1wiLCBjb250cmFjdEluZm8uQVVTRF9BRERSRVNTLCBUcmFkZVR5cGUuU2VsbCk7XHJcbiAgICAgICAgbGV0IGJ1eVRyYWRlSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dDtcclxuICAgICAgICBpZiAoIXN5bWJvbCkge1xyXG4gICAgICAgICAgICBidXlUcmFkZUlucHV0ID0gbmV3IFRyYWRlUGFuZWxJbnB1dChcIlNlbGVjdCBzdG9ja1wiLCBcIlwiLCBcIlwiLCBcIlwiLCBUcmFkZVR5cGUuQnV5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidXlUcmFkZUlucHV0ID0gbmV3IFRyYWRlUGFuZWxJbnB1dChzeW1ib2wgYXMgc3RyaW5nLCBuYW1lIGFzIHN0cmluZywgbG9nbyBhcyBzdHJpbmcsIGFkZHJlc3MgYXMgc3RyaW5nLCBUcmFkZVR5cGUuQnV5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNlbGxUcmFkZUlucHV0LnNldE90aGVyVHJhZGVQYW5lbElucHV0KGJ1eVRyYWRlSW5wdXQpO1xyXG4gICAgICAgIGJ1eVRyYWRlSW5wdXQuc2V0T3RoZXJUcmFkZVBhbmVsSW5wdXQoc2VsbFRyYWRlSW5wdXQpO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IHRyYWRlU3dpdGNoID0gbmV3IFRyYWRlU3dpdGNoKCk7XHJcblxyXG4gICAgICAgIGxldCBzZWxsSW5wdXQgPSBzZWxsVHJhZGVJbnB1dC5yZW5kZXJUb1N0cmluZygpO1xyXG4gICAgICAgIGxldCBidXlJbnB1dCA9IGJ1eVRyYWRlSW5wdXQucmVuZGVyVG9TdHJpbmcoKTtcclxuICAgICAgICBsZXQgc3dpdGNoSHRtbCA9IHRyYWRlU3dpdGNoLnJlbmRlclRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gc2VsbElucHV0ICsgc3dpdGNoSHRtbCArIGJ1eUlucHV0O1xyXG5cclxuICAgICAgICBhd2FpdCBzZWxsVHJhZGVJbnB1dC5sb2FkQmFsYW5jZSgpO1xyXG4gICAgICAgIGF3YWl0IGJ1eVRyYWRlSW5wdXQubG9hZEJhbGFuY2UoKTtcclxuICAgICAgICBpZiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGJ1eVRyYWRlSW5wdXQubG9hZExhc3RUcmFkZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxsVHJhZGVJbnB1dC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgYnV5VHJhZGVJbnB1dC5iaW5kRXZlbnRzKCk7XHJcblxyXG4gICAgICAgIGxldCBleGVjdXRlVHJhZGVCdXR0b24gPSBuZXcgRXhlY3V0ZU9yZGVyQnV0dG9uKHNlbGxUcmFkZUlucHV0LCBidXlUcmFkZUlucHV0KTtcclxuICAgICAgICBhd2FpdCBleGVjdXRlVHJhZGVCdXR0b24ucmVuZGVyQnV0dG9uKCk7XHJcblxyXG4gICAgICAgIHRyYWRlU3dpdGNoLmJpbmRFdmVudHMoc2VsbFRyYWRlSW5wdXQsIGJ1eVRyYWRlSW5wdXQsIGV4ZWN1dGVUcmFkZUJ1dHRvbik7XHJcbiAgICAgICAgc2VsbFRyYWRlSW5wdXQub25VcGRhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChidXlUcmFkZUlucHV0LmlzRGlydHkpIGJ1eVRyYWRlSW5wdXQudXBkYXRlUGFuZWwoKTtcclxuICAgICAgICAgICAgZXhlY3V0ZVRyYWRlQnV0dG9uLnJlbmRlckJ1dHRvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidXlUcmFkZUlucHV0Lm9uVXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc2VsbFRyYWRlSW5wdXQuaXNEaXJ0eSkgc2VsbFRyYWRlSW5wdXQudXBkYXRlUGFuZWwoKTtcclxuICAgICAgICAgICAgZXhlY3V0ZVRyYWRlQnV0dG9uLnJlbmRlckJ1dHRvbigpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG4gICAgcHVibGljIGZvcm1hdEJ1eVBhbmVsKHN5bWJvbCA6IHN0cmluZywgbmFtZSA6IHN0cmluZywgbG9nbyA6IHN0cmluZywgdHJhZGVUeXBlIDogVHJhZGVUeXBlLCBjb250cmFjdEFkZHJlc3MgOiBzdHJpbmcpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfc2VsZWN0X3N5bWJvbCcpIS5pbm5lckhUTUwgPSBzeW1ib2w7XHJcbiAgICB9XHJcblxyXG5cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxkaXYgaWQ9XFxcInRyYWRpbmdQYW5lbFxcXCI+XFxyXFxuICAgIDxhIGhyZWY9XFxcIiN1c2Vfd2FsbGV0X2Zvcl9vcmRlcnNcXFwiIGlkPVxcXCJ1c2Vfd2FsbGV0X2Zvcl9vcmRlcnNfbGlua1xcXCIgY2xhc3M9XFxcIm5vdF92aXNpYmxlXFxcIj5UcmFkZSBpbiB5b3VyIHdhbGxldCBpbnN0ZWFkIG9mXFxyXFxuICAgICAgICBoZXJlPC9hPlxcclxcbiAgICA8YXJ0aWNsZSBpZD1cXFwibGltaW5hbF9tYXJrZXRfdHJhZGVfcGFuZWxcXFwiPjwvYXJ0aWNsZT5cXHJcXG4gICAgPGRpdiBpZD1cXFwiZXhlY3V0aW5nLW9yZGVyLXByb2dyZXNzXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcInByb2dyZXNzLXRleHRcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgPHByb2dyZXNzPjwvcHJvZ3Jlc3M+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8YnV0dG9uIGlkPVxcXCJsaW1pbmFsX21hcmtldF9leGVjdXRlX3RyYWRlXFxcIj48L2J1dHRvbj5cXHJcXG5cXHJcXG4gICAgPGFydGljbGUgaWQ9XFxcInVzZV93YWxsZXRfZm9yX29yZGVyc1xcXCI+XFxyXFxuXFxyXFxuICAgICAgICA8aDM+SG93IHRvIGJ1eSBpbiB3YWxsZXQ8L2gzPlxcclxcbiAgICAgICAgPHVsPlxcclxcbiAgICAgICAgICAgIDxsaT5JZiB5b3UgaGF2ZW4ndCBhZGRlZCBhVVNEIHRvIHlvdXIgd2FsbGV0LCBub3cgaXMgdGhlIHRpbWUgLSA8c21hbGw+PGEgaHJlZj1cXFwiXFxcIiBpZD1cXFwiYWRkQVVTRFRvV2FsbGV0XFxcIj5DbGlja1xcclxcbiAgICAgICAgICAgICAgICBoZXJlIHRvIGFkZCBhVVNEIHRvIHdhbGxldDwvYT48L3NtYWxsPjwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPjxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImZpbmRTeW1ib2xcXFwiPkZpbmQgc3ltYm9sPC9hPiB5b3Ugd2FudCB0byBidXkgJiBjbGljayBcXFwiR2V0IGFkZHJlc3NcXFwiPC9saT5cXHJcXG4gICAgICAgICAgICA8bGk+R28gdG8geW91ciB3YWxsZXQgYW5kIGZpbmQgdGhlIGFVU0QgdG9rZW4sIGNsaWNrIFxcXCJTZW5kXFxcIjwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPlBhc3RlIGluIHRoZSBhZGRyZXNzIHlvdSBqdXN0IGNvcGllZCBmb3IgdGhlIFJlY2VpdmVyLlxcclxcbiAgICAgICAgICAgICAgICA8dWw+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8bGk+PGVtPk5vdGU6IElmIHlvdSBjYW4sIHNhdmUgdGhlIGFkZHJlc3MgdG8geW91ciBjb250YWN0IGxpc3QgZm9yIGVhc3kgYWNjZXNzIG5leHQgdGltZTwvZW0+PC9saT5cXHJcXG4gICAgICAgICAgICAgICAgPC91bD5cXHJcXG4gICAgICAgICAgICA8L2xpPlxcclxcblxcclxcbiAgICAgICAgICAgIDxsaT5UeXBlIGluIHRoZSBhbW91bnQgJiBjbGljayBDb25maXJtPC9saT5cXHJcXG4gICAgICAgICAgICA8bGk+WW91IGhhdmUgbm93IGJvdWdodCB0aGUgc2hhcmVzLCBkb24ndCBmb3JnZXQgdG8gPGEgaHJlZj1cXFwiXFxcIiBjbGFzcz1cXFwiZmluZFN5bWJvbFxcXCI+YWRkIHRoZSB0b2tlbiB0byB3YWxsZXQ8L2E+LiAmIzEyNzg4MTs8L2xpPlxcclxcbiAgICAgICAgPC91bD5cXHJcXG4gICAgICAgIDxkaXYgc3R5bGU9XFxcInRleHQtYWxpZ246IGNlbnRlcjtcXFwiPlxcclxcbiAgICAgICAgICAgIDwhLS1cXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICA8aWZyYW1lIHdpZHRoPVxcXCIzODBcXFwiIGhlaWdodD1cXFwiNTAwXFxcIiBzcmM9XFxcImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL20xaU5vdGdhaWM0P2F1dG9wbGF5PTEmY2NfbG9hZF9wb2xpY3k9MSZwbGF5bGlzdD1tMWlOb3RnYWljNCZsb29wPTFcXFwiIHRpdGxlPVxcXCJZb3VUdWJlIHZpZGVvIHBsYXllclxcXCIgZnJhbWVib3JkZXI9XFxcIjBcXFwiIGFsbG93PVxcXCJhY2NlbGVyb21ldGVyOyBhdXRvcGxheTsgY2xpcGJvYXJkLXdyaXRlOyBlbmNyeXB0ZWQtbWVkaWE7IGd5cm9zY29wZTsgcGljdHVyZS1pbi1waWN0dXJlXFxcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+XFxyXFxuICAgICAgICAgICAgLS0+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG5cXHJcXG5cXHJcXG4gICAgICAgIDxoMz5TZWxsIHlvdXIgc2VjdXJpdGllczwvaDM+XFxyXFxuXFxyXFxuICAgICAgICA8dWw+XFxyXFxuICAgICAgICAgICAgPGxpPkZpbmQgdGhlIHRva2VuIHlvdSB3YW50IHNvIHNlbGwgaW4geW91IHdhbGxldCBhbmQgY2xpY2sgU2VuZDwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPlB1dCB0aGUgaW4gdGhlIGFVU0QgYWRkcmVzczxici8+PGlucHV0IGlkPVxcXCJhVXNkQWRkcmVzc1xcXCIgdmFsdWU9XFxcInt7QVVTREFkZHJlc3N9fVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDx1bD5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxsaT48ZW0+Tm90ZTogSWYgeW91IGNhbiwgc2F2ZSB0aGUgYWRkcmVzcyB0byB5b3VyIGNvbnRhY3QgbGlzdCBmb3IgZWFzeSBhY2Nlc3MgbmV4dCB0aW1lPC9lbT48L2xpPlxcclxcbiAgICAgICAgICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPlR5cGUgaW4gdGhlIHF1YW50aXR5IG9mIHNoYXJlcyB5b3Ugd2FudCB0byBzZWxsICYgY2xpY2sgQ29uZmlybTwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPllvdSBoYXZlIG5vdyBzb2xkIHRoZSBzaGFyZXMgJiMxMjc4ODE7PC9saT5cXHJcXG4gICAgICAgIDwvdWw+XFxyXFxuXFxyXFxuICAgIDwvYXJ0aWNsZT5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiXFxyXFxuXFxyXFxuICAgIFlvdSBjYW4gY29weSB0aGUgYWRkcmVzcyBvZiB7e3N5bWJvbH19IGFuZCBpbXBvcnQgaXQgaW50byB5b3VyIHdhbGxldFxcclxcbiAgICA8aW5wdXQgaWQ9XFxcInRva2VuQWRkcmVzc1xcXCIgdmFsdWU9XFxcInt7dG9rZW5BZGRyZXNzfX1cXFwiIC8+XFxyXFxuXFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBUcmFkZVBhbmVsIGZyb20gXCIuLi9lbGVtZW50cy9UcmFkZVBhbmVsXCI7XHJcbmltcG9ydCBUcmFkZVBhZ2VIdG1sIGZyb20gXCIuLi8uLi9odG1sL3BhZ2VzL3RyYWRlLmh0bWxcIjtcclxuaW1wb3J0IENvbnRyYWN0SW5mbyBmcm9tIFwiLi4vLi4vY29udHJhY3RzL0NvbnRyYWN0SW5mb1wiO1xyXG5pbXBvcnQgU2VjdXJpdGllc0xpc3RNb2RhbCBmcm9tIFwiLi4vbW9kYWxzL1NlY3VyaXRpZXNMaXN0TW9kYWxcIjtcclxuaW1wb3J0IEFVU0RTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0FVU0RTZXJ2aWNlXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi8uLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL21vZGFscy9Nb2RhbFwiO1xyXG5pbXBvcnQgQ29weVRva2VuQWRkcmVzc1RvQWRkVG9XYWxsZXQgZnJvbSAnLi4vLi4vaHRtbC9tb2RhbC9Db3B5VG9rZW5BZGRyZXNzVG9BZGRUb1dhbGxldC5odG1sJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbmltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi4vLi4vY29udHJhY3RzL0NvbnRyYWN0QWRkcmVzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFkZVBhZ2Uge1xyXG5cclxuICAgIGNvbnRyYWN0SW5mbzogQ29udHJhY3RBZGRyZXNzZXM7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb250cmFjdEluZm8gPSBDb250cmFjdEluZm8uZ2V0Q29udHJhY3RJbmZvKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoc3ltYm9sPzogc3RyaW5nLCBuYW1lPzogc3RyaW5nLCBsb2dvPzogc3RyaW5nLCBhZGRyZXNzPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbl9jb250YWluZXInKTtcclxuICAgICAgICBpZiAoIW1haW5Db250YWluZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFRyYWRlUGFnZUh0bWwpO1xyXG4gICAgICAgIG1haW5Db250YWluZXIuaW5uZXJIVE1MID0gdGVtcGxhdGUoe0FVU0RBZGRyZXNzOiB0aGlzLmNvbnRyYWN0SW5mby5BVVNEX0FERFJFU1N9KTtcclxuXHJcbiAgICAgICAgbGV0IHRyYWRlUGFuZWwgPSBuZXcgVHJhZGVQYW5lbCgpO1xyXG4gICAgICAgIGF3YWl0IHRyYWRlUGFuZWwucmVuZGVyKCdsaW1pbmFsX21hcmtldF90cmFkZV9wYW5lbCcpO1xyXG5cclxuICAgICAgICBpZiAoc3ltYm9sKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VsZWN0U3ltYm9sKHN5bWJvbCwgbmFtZSEsIGxvZ28hLCBhZGRyZXNzISlcclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBBVVNEU2VydmljZS5vbkFVc2RMb2FkLnB1c2goKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRCdXlXaXRoV2FsbGV0KCk7XHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGxldCBmaW5kU3ltYm9scyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maW5kU3ltYm9sJyk7XHJcbiAgICAgICAgZmluZFN5bWJvbHM/LmZvckVhY2goZmluZFN5bWJvbCA9PiB7XHJcbiAgICAgICAgICAgIGZpbmRTeW1ib2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdXJpdGllc01vZGFsID0gbmV3IFNlY3VyaXRpZXNMaXN0TW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIHNlY3VyaXRpZXNNb2RhbC5zaG93TW9kYWwoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyaXRpZXNNb2RhbC5oaWRlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNlbGVjdFN5bWJvbChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgICAgIGxldCB0cmFkZVBhbmVsID0gbmV3IFRyYWRlUGFuZWwoKTtcclxuICAgICAgICBhd2FpdCB0cmFkZVBhbmVsLnJlbmRlcignbGltaW5hbF9tYXJrZXRfdHJhZGVfcGFuZWwnLCBzeW1ib2wsIG5hbWUsIGxvZ28sIGFkZHJlc3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgbG9hZEJ1eVdpdGhXYWxsZXQoKSB7XHJcbiAgICAgICAgbGV0IHVzZXIgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgZXRoQWRkcmVzcyA9IHVzZXIuZ2V0RXRoQWRkcmVzcygpO1xyXG4gICAgICAgIGlmICghZXRoQWRkcmVzcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBhVVNEU2VydmljZSA9IG5ldyBBVVNEU2VydmljZSgpO1xyXG4gICAgICAgIGxldCBhdXNkQW1vdW50ID0gYXdhaXQgYVVTRFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZihldGhBZGRyZXNzKTtcclxuXHJcbiAgICAgICAgbGV0IHVzZXJXYWxsZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlX3dhbGxldF9mb3Jfb3JkZXJzJyk7XHJcbiAgICAgICAgbGV0IHVzZXJXYWxsZXRMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZV93YWxsZXRfZm9yX29yZGVyc19saW5rJyk7XHJcbiAgICAgICAgaWYgKGF1c2RBbW91bnQuZXEoMCkpIHtcclxuICAgICAgICAgICAgdXNlcldhbGxldD8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHVzZXJXYWxsZXRMaW5rPy5jbGFzc0xpc3QuYWRkKCdub3RfdmlzaWJsZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVzZXJXYWxsZXQ/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB1c2VyV2FsbGV0TGluaz8uY2xhc3NMaXN0LnJlbW92ZSgnbm90X3Zpc2libGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhZGRBVVNEVG9XYWxsZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWRkQVVTRFRvV2FsbGV0Jyk7XHJcbiAgICAgICAgYWRkQVVTRFRvV2FsbGV0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcigpO1xyXG4gICAgICAgICAgICB3YWxsZXRIZWxwZXIuYWRkVG9rZW5Ub1dhbGxldCh0aGlzLmNvbnRyYWN0SW5mby5BVVNEX0FERFJFU1MsICdhVVNEJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoQ29weVRva2VuQWRkcmVzc1RvQWRkVG9XYWxsZXQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZSh7c3ltYm9sOiAnYVVTRCcsIHRva2VuQWRkcmVzczogdGhpcy5jb250cmFjdEluZm8uQVVTRF9BRERSRVNTfSk7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ0FkZCBhVVNEIHRvIHdhbGxldCcsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJcXHJcXG48YXJ0aWNsZSBpZD1cXFwic3RvY2tMaXN0XFxcIj5cXHJcXG4gPGRpdiBpZD1cXFwidWFcXFwiPjwvZGl2PlxcclxcbiA8ZGl2IGlkPVxcXCJsaXN0X29mX3NlY3VyaXRpZXNcXFwiPnt7e3NlY3VyaXRpZXN9fX08L2Rpdj5cXHJcXG5cXHJcXG48L2FydGljbGU+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBMaW1pbmFsTWFya2V0U2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9MaW1pbmFsTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQgU2VjdXJpdGllc0xpc3QgZnJvbSBcIi4uLy4uL3VpL2VsZW1lbnRzL1NlY3VyaXRpZXNMaXN0XCI7XHJcbmltcG9ydCBUcmFkZVBhZ2UgZnJvbSBcIi4uL3BhZ2VzL1RyYWRlUGFnZVwiO1xyXG5pbXBvcnQgU3RvY2tzUGFnZUh0bWwgZnJvbSAnLi4vLi4vaHRtbC9wYWdlcy9zdG9ja3NwYWdlLmh0bWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvY2tzUGFnZSB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcblxyXG5cdHB1YmxpYyBhc3luYyBsb2FkKCkge1xyXG5cdFx0bGV0IG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbl9jb250YWluZXInKTtcclxuXHRcdGlmICghbWFpbkNvbnRhaW5lcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgc2VjdXJpdGllc0xpc3QgPSBuZXcgU2VjdXJpdGllc0xpc3QoKTtcclxuICAgICAgICBsZXQgc2VjdXJpdGllcyA9IGF3YWl0IHNlY3VyaXRpZXNMaXN0LnJlbmRlcigpO1xyXG5cclxuXHRcdGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShTdG9ja3NQYWdlSHRtbCk7XHJcblx0XHRtYWluQ29udGFpbmVyLmlubmVySFRNTCA9IHRlbXBsYXRlKHtzZWN1cml0aWVzOnNlY3VyaXRpZXN9KTtcclxuXHJcblx0XHRhd2FpdCBzZWN1cml0aWVzTGlzdC5sb2FkTW9yZSgpO1xyXG5cclxuXHRcdGF3YWl0IHNlY3VyaXRpZXNMaXN0LmJpbmRFdmVudHMoYXN5bmMgKHN5bWJvbCwgbmFtZSwgbG9nbykgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UoKTtcclxuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSBhd2FpdCBsaW1pbmFsTWFya2V0U2VydmljZS5nZXRTeW1ib2xDb250cmFjdEFkZHJlc3Moc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0cmFkZVBhZ2UgPSBuZXcgVHJhZGVQYWdlKCk7XHJcblx0XHRcdHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcclxuXHRcdFx0aGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJ0J1eSBzdG9ja3MnLCAnIy90cmFkZScpO1xyXG5cdFx0XHRhd2FpdCB0cmFkZVBhZ2UubG9hZChzeW1ib2wsIG5hbWUsIGxvZ28sIGFkZHJlc3MpO1xyXG5cdFx0fSlcclxuXHR9O1xyXG5cclxufVxyXG4iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8aDM+RG9jdW1lbnRzPC9oMz5cXHJcXG48cD5UaGVzZSBhcmUgeW91ciBkb2N1bWVudHMgZm9yIHlvdXIgdHJhZGVzLCBnZW5lcmF0ZWQgYnkgdGhlIGJyb2tlci4gVGhlc2UgZG9jdW1lbnRzIGFyZSB0cmFkZSBjb25maXJtYXRpb24gJiBtb250aGx5IHN0YXRlbWVudHMuXFxyXFxuXFx0VGhleSBhcmUgZ2VuZXJhdGVkIGF0IHRoZSBlbmQgb2YgdGhlIGRheSwgYmV0d2VlbiAwNjozMFBNLTA3OjMwUE0gRVNULlxcclxcbjwvcD5cXHJcXG57eyNpZiByZXN1bHR9fVxcclxcbjx0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtaG92ZXJcXFwiPlxcclxcblxcdDx0aGVhZD5cXHJcXG5cXHRcXHQ8dHI+XFxyXFxuXFx0XFx0XFx0PHRoPlR5cGU8L3RoPlxcclxcblxcdFxcdFxcdDx0aD5EYXRlPC90aD5cXHJcXG5cXHRcXHRcXHQ8dGg+RG93bmxvYWQ8L3RoPlxcclxcblxcdFxcdDwvdHI+XFxyXFxuXFx0PC90aGVhZD5cXHJcXG5cXHQ8dGJvZHk+XFxyXFxuXFx0XFx0e3sjZWFjaCByZXN1bHR9fVxcclxcblxcdFxcdDx0cj5cXHJcXG5cXHRcXHRcXHQ8dGQgdGl0bGU9XFxcInt7aWR9fVxcXCI+e3t0eXBlfX08L2E+PC90ZD5cXHJcXG5cXHRcXHRcXHQ8dGQ+e3tkYXRlfX08L3RkPlxcclxcblxcdFxcdFxcdDx0ZD48YSBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJkb3dubG9hZERvY1xcXCIgZGF0YS1kb2NpZD1cXFwie3tpZH19XFxcIj5Eb3dubG9hZDwvYT48L3RkPlxcclxcblxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0e3svZWFjaH19XFxyXFxuXFx0PC90Ym9keT5cXHJcXG48L3RhYmxlPlxcclxcbnt7L2lmfX1cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEJhc2VTZXJ2aWNlIGZyb20gXCIuL0Jhc2VTZXJ2aWNlXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRTZXJ2aWNlIGV4dGVuZHMgQmFzZVNlcnZpY2Uge1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXREb2N1bWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0KCdkb2N1bWVudHMnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnQoZG9jdW1lbnRJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBkb2N1bWVudElkOiBkb2N1bWVudElkXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXQoXCJkb3dubG9hZFwiLCBwYXJhbXMpO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiVG9rZW4gZm9yIHt7c3ltYm9sfX0gZG9lcyBub3QgZXhpc3QuIFlvdSBjYW4gY2xpY2sgdGhlIGJ1dHRvbiBiZWxvdyB0byBjcmVhdGUgdGhlIHRva2VuLiBUaGlzIHdpbGwgY29zdCBhIGJpdCBvZiBnYXMuXFxyXFxuPGJyIC8+PGJyIC8+XFxyXFxuQWZ0ZXIgdGhlIHRva2VuIGhhcyBiZWVuIGNyZWF0ZWQgd2Ugd2lsbCB0cnkgdG8gYWRkIGl0IHRvIHlvdXIgd2FsbGV0LlxcclxcbjxiciAvPjxiciAvPlxcclxcbjxidXR0b24gaWQ9XFxcImNyZWF0ZVRva2VuQnRuXFxcIj5DcmVhdGUgdG9rZW48L2J1dHRvbj5cXHJcXG5cXHJcXG48ZGl2IGNsYXNzPVxcXCJkLW5vbmVcXFwiIGlkPVxcXCJjb3B5QWRkcmVzc0luZm9cXFwiPlxcclxcbiAgICBZb3UgY2FuIGNvcHkgdGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIGFuZCBpbXBvcnQgaXQgaW50byB5b3VyIHdhbGxldFxcclxcbiAgICA8aW5wdXQgaWQ9XFxcInRva2VuQWRkcmVzc1xcXCIgLz5cXHJcXG5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuL01vZGFsXCI7XHJcbmltcG9ydCBDcmVhdGVUb2tlbkh0bWwgZnJvbSAnLi4vLi4vaHRtbC9tb2RhbC9DcmVhdGVUb2tlbi5odG1sJztcclxuaW1wb3J0IExpbWluYWxNYXJrZXRTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0xpbWluYWxNYXJrZXRTZXJ2aWNlXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCB7QWRkcmVzc1plcm99IGZyb20gXCIuLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcbmltcG9ydCBCbG9ja2NoYWluRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9CbG9ja2NoYWluRXJyb3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWF0ZVRva2VuIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KHN5bWJvbCA6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoQ3JlYXRlVG9rZW5IdG1sKTtcclxuXHJcblxyXG4gICAgICAgIG1vZGFsLnNob3dNb2RhbChcIlRva2VuIFwiICsgc3ltYm9sICsgXCIgZG9lc24ndCBleGlzdFwiLCB0ZW1wbGF0ZSh7c3ltYm9sOnN5bWJvbH0pKTtcclxuXHJcbiAgICAgICAgbGV0IGJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjcmVhdGVUb2tlbkJ0bicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghYnRuKSByZXR1cm47XHJcblxyXG4gICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKGJ0biEpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGxpbWluYWxNYXJrZXRTZXJ2aWNlID0gbmV3IExpbWluYWxNYXJrZXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gYXdhaXQgbGltaW5hbE1hcmtldFNlcnZpY2UuZ2V0U3ltYm9sQ29udHJhY3RBZGRyZXNzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID09PSBBZGRyZXNzWmVybykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmNyZWF0ZVRva2VuKHN5bWJvbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnQ3JlYXRpbmcgdG9rZW4uIEdpdmUgaXQgZmV3IHNlY29uZHMnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEJsb2NrY2hhaW5FcnJvciAmJiByZXN1bHQuY29kZSA9PSBCbG9ja2NoYWluRXJyb3IuVXNlckNhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSByZXN1bHQgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICBidG4uaW5uZXJIVE1MID0gJ0FkZCB0b2tlbiB0byB3YWxsZXQnO1xyXG4gICAgICAgICAgICBsZXQgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcigpO1xyXG4gICAgICAgICAgICBhd2FpdCB3YWxsZXRIZWxwZXIuYWRkVG9rZW5Ub1dhbGxldChhZGRyZXNzLCBzeW1ib2wsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB0b2tlbkFkZHJlc3NJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b2tlbkFkZHJlc3MnKTtcclxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5BZGRyZXNzSW5wdXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICB0b2tlbkFkZHJlc3NJbnB1dC5pbm5lckhUTUwgPSBhZGRyZXNzO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvcHlBZGRyZXNzSW5mbycpIS5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxhcnRpY2xlIGNsYXNzPVxcXCJsb2FkZWQtY29udGVudDJcXFwiPlxcclxcblxcdDxoMz5Qb3NpdGlvbnM8IS0tIDxhIGhyZWY9XFxcIlxcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIiBpZD1cXFwic3luY1dhbGxldFxcXCI+U3luYyB3YWxsZXQ8L2E+LS0+PC9oMz5cXHJcXG5cXHQ8ZmlndXJlPlxcclxcblxcdDx0YWJsZT5cXHJcXG5cXHRcXHQ8dGhlYWQ+XFxyXFxuXFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdDx0aD48L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5TeW1ib2w8L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5DdXJyZW50IHByaWNlPC90aD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGg+QXZnLiBlbnRyeSB2YWx1ZTwvdGg+XFxyXFxuXFx0XFx0XFx0XFx0PHRoPlF1YW50aXR5PC90aD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGg+TWFya2V0IHZhbHVlPC90aD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGg+VW5yZWFsaXplIFBMPC90aD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGg+VHJhZGU8L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5BZGQgdG8gd2FsbGV0PC90aD5cXHJcXG5cXHRcXHRcXHQ8L3RyPlxcclxcblxcdFxcdDwvdGhlYWQ+XFxyXFxuXFx0XFx0PHRib2R5PlxcclxcblxcdFxcdFxcdHt7I2lmIHJlc3VsdH19XFxyXFxuXFx0XFx0XFx0e3sjZWFjaCByZXN1bHR9fVxcclxcblxcdFxcdFxcdDx0cj5cXHJcXG5cXHRcXHRcXHRcXHQ8dGQgY2xhc3M9XFxcInN5bWJvbF9sb2dvXFxcIj48aW1nIGlkPVxcXCJzeW1ib2xfbG9nb197e3N5bWJvbH19XFxcIiBzcmM9XFxcIi9pbWcvbG9nb3MvZGVmYXVsdF9sb2dvLnBuZ1xcXCIgLz48L3RkPlxcclxcblxcdFxcdFxcdFxcdDx0ZD48YSBocmVmPVxcXCJodHRwczovL3N0cmlrZS5tYXJrZXQvc3RvY2tzL3t7c3ltYm9sfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57e3N5bWJvbH19PC9hPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0PHRkPnt7Y3VycmVudF9wcmljZX19PC90ZD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGQ+e3tyb3VuZDIgYXZnX2VudHJ5X3ByaWNlfX08L3RkPlxcclxcblxcdFxcdFxcdFxcdDx0ZD57e3JvdW5kMiBxdHl9fTwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0PHRkPiR7e3JvdW5kIG1hcmtldF92YWx1ZX19PC90ZD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGQgY2xhc3M9XFxcInt7Y2xhc3NDb2xvciB1bnJlYWxpemVkX3BsfX1cXFwiPiR7e3JvdW5kIHVucmVhbGl6ZWRfcGx9fSAoe3twZXJjIHVucmVhbGl6ZWRfcGxwY319KTwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0PHRkPjxhIGhyZWY9XFxcIiNcXFwiIGNsYXNzPVxcXCJ0cmFkZVNlY3VyaXR5XFxcIiBkYXRhLXN5bWJvbD1cXFwie3tzeW1ib2x9fVxcXCIgZGF0YS1xdHk9e3txdHl9fT5UcmFkZTwvYT48L3RkPlxcclxcblxcdFxcdFxcdFxcdDx0ZD48YSBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJhZGRUb1dhbGxldFxcXCIgZGF0YS1zeW1ib2w9XFxcInt7c3ltYm9sfX1cXFwiPkFkZDwvYT48L3RkPlxcclxcblxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0XFx0e3svZWFjaH19XFxyXFxuXFx0XFx0XFx0e3tefX1cXHJcXG5cXHRcXHRcXHQ8dHI+XFxyXFxuXFx0XFx0XFx0XFx0PHRkIGNvbHNwYW49XFxcIjlcXFwiPk5vIHRyYWRlcyBoYXZlIGJlZW4gZXhlY3V0ZWQgb24gdGhpcyB3YWxsZXQuIFN0YXJ0IHRyYWRpbmcgdG8gc2VlXFxyXFxuXFx0XFx0XFx0XFx0XFx0eW91ciBwb3NpdGlvbnNcXHJcXG5cXHRcXHRcXHRcXHQ8L3RkPlxcclxcblxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0XFx0e3svaWZ9fVxcclxcblxcdFxcdDwvdGJvZHk+XFxyXFxuXFx0PC90YWJsZT5cXHJcXG5cXHQ8L2ZpZ3VyZT5cXHJcXG5cXHQ8ZGl2IGlkPVxcXCJkb2N1bWVudHNcXFwiPjwvZGl2PlxcclxcblxcclxcbjwvYXJ0aWNsZT5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEJhc2VTZXJ2aWNlIGZyb20gXCIuL0Jhc2VTZXJ2aWNlXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25zU2VydmljZSBleHRlbmRzIEJhc2VTZXJ2aWNlIHtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0UG9zaXRpb25zKGFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgICAgIGxldCB1c2VyUG9zaXRpb24gPSBhd2FpdCB0aGlzLmdldCgncG9zaXRpb25zJywge2FkZHJlc3N9KTtcclxuICAgICAgICByZXR1cm4gdXNlclBvc2l0aW9uPy5wb3NpdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFVzZXJQb3NpdGlvbnMoYWRkcmVzczogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0KCdwb3NpdGlvbnMnLCB7YWRkcmVzc30pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFVzZXIgZnJvbSBcIi4uLy4uL2R0by9Vc2VyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBBcHAgZnJvbSBcIi4uLy4uL21haW5cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQYWdlIHtcclxuXHJcbiAgICB1c2VyOiBVc2VyO1xyXG4gICAgbmV0d29yazogTmV0d29ya0luZm87XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy51c2VyID0gQXBwLlVzZXI7XHJcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gQXBwLk5ldHdvcmtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQge0FkZHJlc3NaZXJvfSBmcm9tICcuLi8uLi91dGlsL0hlbHBlcic7XHJcbmltcG9ydCBMaW1pbmFsTWFya2V0U2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9MaW1pbmFsTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQgU2VjdXJpdGllc1NlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2Jyb2tlci9TZWN1cml0aWVzU2VydmljZVwiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi8uLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5pbXBvcnQgRG9jdW1lbnRzSHRtbCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL2RvY3VtZW50cy5odG1sJztcclxuaW1wb3J0IERvY3VtZW50U2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Eb2N1bWVudFNlcnZpY2VcIjtcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi8uLi91aS9tb2RhbHMvTW9kYWxcIjtcclxuaW1wb3J0IENyZWF0ZVRva2VuIGZyb20gXCIuLi8uLi91aS9tb2RhbHMvQ3JlYXRlVG9rZW5cIjtcclxuaW1wb3J0IEFkZHJlc3NJbmZvSHRtbCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL0FkZHJlc3NJbmZvLmh0bWwnO1xyXG5pbXBvcnQgUG9zaXRpb25QYWdlSHRtbCBmcm9tICcuLi8uLi9odG1sL3BhZ2VzL3Bvc2l0aW9ucy5odG1sJztcclxuaW1wb3J0IFN5bmNTdG9ja0h0bWwgZnJvbSAnLi4vLi4vaHRtbC9tb2RhbC9TeW5jU3RvY2suaHRtbCc7XHJcbmltcG9ydCBQb3NpdGlvbnNTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1Bvc2l0aW9uc1NlcnZpY2VcIjtcclxuaW1wb3J0IEhhbmRsZWJhckhlbHBlcnMgZnJvbSBcIi4uLy4uL3V0aWwvSGFuZGxlYmFySGVscGVyc1wiO1xyXG5pbXBvcnQgVHJhZGVQYWdlIGZyb20gXCIuL1RyYWRlUGFnZVwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgQmFzZVBhZ2UgZnJvbSBcIi4vQmFzZVBhZ2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvc2l0aW9uc1BhZ2UgZXh0ZW5kcyBCYXNlUGFnZSB7XHJcbiAgICBkb2N1bWVudFNlcnZpY2U6IERvY3VtZW50U2VydmljZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnRTZXJ2aWNlID0gbmV3IERvY3VtZW50U2VydmljZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkKCkge1xyXG5cclxuICAgICAgICBsZXQgbWFpbkNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWluX2NvbnRhaW5lcicpO1xyXG4gICAgICAgIGlmICghbWFpbkNvbnRhaW5lcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoKTtcclxuICAgICAgICBsZXQgcG9zaXRpb25TZXJ2aWNlID0gbmV3IFBvc2l0aW9uc1NlcnZpY2UoKTtcclxuICAgICAgICBsZXQgcG9zaXRpb25zID0gYXdhaXQgcG9zaXRpb25TZXJ2aWNlLmdldFBvc2l0aW9ucyh1c2VyU2VydmljZS5nZXRFdGhBZGRyZXNzKCkhKTtcclxuICAgICAgICBpZiAoIXBvc2l0aW9ucykgcG9zaXRpb25zID0gW107XHJcblxyXG4gICAgICAgIEhhbmRsZWJhckhlbHBlcnMucmVnaXN0ZXJIZWxwZXJzKCk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShQb3NpdGlvblBhZ2VIdG1sKTtcclxuICAgICAgICBtYWluQ29udGFpbmVyLmlubmVySFRNTCA9IHRlbXBsYXRlKHtyZXN1bHQ6IHBvc2l0aW9uc30pO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGxldCBzeW1ib2xzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcclxuICAgICAgICBjb25zdCBzZWxsTGlua3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0cmFkZVNlY3VyaXR5Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxsTGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBzZWxsTGlua3NbaV0gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBzeW1ib2wgPSBlbGVtZW50LmRhdGFzZXQuc3ltYm9sO1xyXG4gICAgICAgICAgICBpZiAoIXN5bWJvbCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBzeW1ib2xzLnB1c2goc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgIHNlbGxMaW5rc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50ID0gZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGxldCBzeW1ib2wgPSBlbGVtZW50LmRhdGFzZXQuc3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzeW1ib2wpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBjb250cmFjdEFkZHJlc3MgPSBhd2FpdCBsaW1pbmFsTWFya2V0U2VydmljZS5nZXRTeW1ib2xDb250cmFjdEFkZHJlc3Moc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdXJpdGllc1NlcnZpY2UgPSBhd2FpdCBTZWN1cml0aWVzU2VydmljZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3VyaXR5ID0gYXdhaXQgc2VjdXJpdGllc1NlcnZpY2UuZ2V0U2VjdXJpdHlCeVN5bWJvbChzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB0cmFkZVBhZ2UgPSBuZXcgVHJhZGVQYWdlKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0cmFkZVBhZ2UubG9hZChzeW1ib2wsIHNlY3VyaXR5Lk5hbWUsIHNlY3VyaXR5LkxvZ29QYXRoICsgc2VjdXJpdHkuTG9nbywgY29udHJhY3RBZGRyZXNzKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBhZGRUb1dhbGxldExpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYWRkVG9XYWxsZXQnKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZFRvV2FsbGV0TGlua3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWRkVG9XYWxsZXRMaW5rc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXZ0LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGFkZFRvV2FsbGV0TGlua3NbaV0gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gZWxlbWVudC5kYXRhc2V0LnN5bWJvbCE7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxpbWluYWxNYXJrZXRTZXJ2aWNlID0gbmV3IExpbWluYWxNYXJrZXRTZXJ2aWNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgbGltaW5hbE1hcmtldFNlcnZpY2UuZ2V0U3ltYm9sQ29udHJhY3RBZGRyZXNzKHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJhY3RBZGRyZXNzLnRvU3RyaW5nKCkgPT0gQWRkcmVzc1plcm8pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3JlYXRlVG9rZW4gPSBuZXcgQ3JlYXRlVG9rZW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVUb2tlbi5zaG93KHN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB3YWxsZXRIZWxwZXIuYWRkVG9rZW5Ub1dhbGxldChjb250cmFjdEFkZHJlc3MudG9TdHJpbmcoKSwgc3ltYm9sLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEFkZHJlc3NJbmZvSHRtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZSh7c3ltYm9sOiBzeW1ib2wsIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzc30pO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZGFsLnNob3dNb2RhbCgnSW1wb3J0IHRva2VuIHRvIHdhbGxldCcsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG5cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclN5bWJvbExvZ29zKHN5bWJvbHMpO1xyXG5cclxuICAgICAgICBsZXQgZG9jVGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoRG9jdW1lbnRzSHRtbCk7XHJcbiAgICAgICAgbGV0IGRvY3VtZW50cyA9IGF3YWl0IHRoaXMuZG9jdW1lbnRTZXJ2aWNlLmdldERvY3VtZW50cygpO1xyXG4gICAgICAgIGxldCBkb2N1bWVudERvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkb2N1bWVudHMnKTtcclxuICAgICAgICBpZiAoIWRvY3VtZW50RG9tKSByZXR1cm47XHJcblxyXG4gICAgICAgIGRvY3VtZW50RG9tLmlubmVySFRNTCA9IGRvY1RlbXBsYXRlKHtyZXN1bHQ6IGRvY3VtZW50c30pO1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLmluaXREb2N1bWVudHMoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHJlbmRlclN5bWJvbExvZ29zKHN5bWJvbHM6IEFycmF5PHN0cmluZz4pIHtcclxuICAgICAgICBsZXQgc2VjdXJpdGllc1NlcnZpY2UgPSBhd2FpdCBTZWN1cml0aWVzU2VydmljZS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IGF3YWl0IHNlY3VyaXRpZXNTZXJ2aWNlLmdldFNlY3VyaXRpZXMoKTtcclxuICAgICAgICBsZXQgYXNzZXQ7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFzc2V0ID0gYXNzZXRzLmdldChzeW1ib2xzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGFzc2V0KSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ltYm9sX2xvZ29fJyArIHN5bWJvbHNbaV0pIS5zZXRBdHRyaWJ1dGUoJ3NyYycsICcvaW1nL2xvZ29zLycgKyBhc3NldC5Mb2dvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIGluaXREb2N1bWVudHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnVzZXIuaXNMb2dnZWRJbikgcmV0dXJuO1xyXG5cclxuICAgICAgICBjb25zdCBsaW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Rvd25sb2FkRG9jJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaW5rc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudElkID0gKGxpbmtzW2ldIGFzIEhUTUxFbGVtZW50KS5kYXRhc2V0LmRvY2lkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudElkKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2F0aW9uVXJsID0gYXdhaXQgdGhpcy5kb2N1bWVudFNlcnZpY2UuZ2V0RG9jdW1lbnQoZG9jdW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25VcmwgPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGVydCgnQ291bGQgbm90IGZpbmQgZG9jdW1lbnQuIFBsZWFzZSBjb250YWN0IHVzIGlmIHlvdSBzaG91bGQgaGF2ZSBnb3R0ZW4gYSBkb2N1bWVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gbG9jYXRpb25Vcmw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBTdG9ja3NQYWdlIGZyb20gXCIuLi91aS9wYWdlcy9TdG9ja3NQYWdlXCI7XHJcbmltcG9ydCBUcmFkZVBhZ2UgZnJvbSBcIi4uL3VpL3BhZ2VzL1RyYWRlUGFnZVwiO1xyXG5pbXBvcnQgUG9zaXRpb25zUGFnZSBmcm9tIFwiLi4vdWkvcGFnZXMvUG9zaXRpb25zUGFnZVwiO1xyXG5pbXBvcnQgRmFrZUFVU0RGdW5kIGZyb20gXCIuLi91aS9tb2RhbHMvRnVuZGluZy9GYWtlQVVTREZ1bmRcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5pbXBvcnQgQXBwIGZyb20gXCIuLi9tYWluXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGluZyB7XHJcblxyXG4gICAgc2V0dGluZ3M6IGFueSA9IHtcclxuICAgICAgICBzaG93X3RyYWRlOiB0aGlzLnNob3dUcmFkZSxcclxuICAgICAgICBzaG93X3Bvc2l0aW9uczogdGhpcy5zaG93UG9zaXRpb25zLFxyXG4gICAgICAgIHNob3dfc3RvY2tzOiB0aGlzLnNob3dTdG9ja3MsXHJcbiAgICAgICAgc2hvd19reWNfYWN0aW9uX3JlcXVpcmVkOiB0aGlzLnNob3dLeWNBY3Rpb25SZXF1aXJlZCxcclxuICAgICAgICBzaG93X2Z1bmRpbmc6IHRoaXMuc2hvd0Z1bmRpbmcsXHJcbiAgICAgICAgc2hvd19reWM6IHRoaXMuc2hvd0t5Y1xyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZFJvdXRlcygpIHtcclxuICAgICAgICBsZXQgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJykucmVwbGFjZSgnLycsICcnKTtcclxuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHBhdGggPSAnc3RvY2tzJztcclxuXHJcbiAgICAgICAgdGhpcy5hdHRhY2hOYXZMaW5rcygpO1xyXG5cclxuICAgICAgICBsZXQgZm4gPSB0aGlzLnNldHRpbmdzWydzaG93XycgKyBwYXRoXSA/PyB0aGlzLnNldHRpbmdzWydzaG93X3N0b2NrcyddO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZuKHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZuKHRoaXMuc2V0dGluZ3NbJ3Nob3dfc3RvY2tzJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd0t5Y0FjdGlvblJlcXVpcmVkKHJvdXRpbmc6IFJvdXRpbmcsIGV2dDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGlmIChldnQpIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBsZXQgcGFnZSA9IG5ldyBUcmFkZVBhZ2UoKTtcclxuICAgICAgICBhd2FpdCBwYWdlLmxvYWQoKTtcclxuXHJcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJ0J1eSBzdG9ja3MnLCAnIy9reWNfYWN0aW9uX3JlcXVpcmVkJyk7XHJcblxyXG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZScpXHJcbiAgICAgICAgYnV0dG9uPy5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd0t5Yyhyb3V0aW5nOiBSb3V0aW5nLCBldnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZ0KSBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHBhZ2UgPSBuZXcgVHJhZGVQYWdlKCk7XHJcbiAgICAgICAgYXdhaXQgcGFnZS5sb2FkKCk7XHJcblxyXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsICdCdXkgc3RvY2tzJywgJyMva3ljJyk7XHJcblxyXG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZScpXHJcbiAgICAgICAgYnV0dG9uPy5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd0Z1bmRpbmcocm91dGluZzogUm91dGluZywgZXZ0OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2dCkgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGxldCBwYWdlID0gbmV3IFRyYWRlUGFnZSgpO1xyXG4gICAgICAgIGF3YWl0IHBhZ2UubG9hZCgpO1xyXG5cclxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnQnV5IHN0b2NrcycsICcjL2Z1bmRpbmcnKTtcclxuXHJcbiAgICAgICAgbGV0IGFVU0RGdW5kaW5nTW9kYWwgPSBuZXcgRmFrZUFVU0RGdW5kKCk7XHJcbiAgICAgICAgaWYgKEFwcC5OZXR3b3JrLlRlc3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIGFVU0RGdW5kaW5nTW9kYWwuc2hvd0FVU0RGYWtlRnVuZCgpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYVVTREZ1bmRpbmdNb2RhbC5zaG93QVVTREZ1bmQoKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3dUcmFkZShyb3V0aW5nOiBSb3V0aW5nLCBldnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZ0KSBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHBhZ2UgPSBuZXcgVHJhZGVQYWdlKCk7XHJcbiAgICAgICAgYXdhaXQgcGFnZS5sb2FkKCk7XHJcblxyXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsICdCdXkgc3RvY2tzJywgJyMvdHJhZGUnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd1N0b2Nrcyhyb3V0aW5nIDogUm91dGluZyxldnQgOiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2dCkgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGxldCBwYWdlID0gbmV3IFN0b2Nrc1BhZ2UoKTtcclxuICAgICAgICBhd2FpdCBwYWdlLmxvYWQoKTtcclxuXHJcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJ1N0b2NrcycsICcjL3N0b2NrcycpO1xyXG5cclxuICAgIH1cclxuICAgIHB1YmxpYyBhc3luYyBzaG93UG9zaXRpb25zKHJvdXRpbmcgOiBSb3V0aW5nLGV2dCA6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZ0KSBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHBhZ2UgPSBuZXcgUG9zaXRpb25zUGFnZSgpO1xyXG4gICAgICAgIGF3YWl0IHBhZ2UubG9hZCgpO1xyXG5cclxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnUG9zaXRpb25zJywgJyMvcG9zaXRpb25zJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGF0dGFjaE5hdkxpbmtzKCkge1xyXG4gICAgICAgIGxldCByb3V0ZXIgPSB0aGlzO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IHRyYWRlTmF2TGlua3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudHJhZGVOYXZMaW5rJyk7XHJcbiAgICAgICAgdHJhZGVOYXZMaW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAobGluayBhcyBIVE1MRWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBXYWxsZXRIZWxwZXIuaGlkZU1hZ2ljV2FsbGV0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZXIuc2hvd1RyYWRlKHJvdXRlciwgZXZ0KTtcclxuICAgICAgICAgICAgICAgIGxpbmsucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEucmVtb3ZlQXR0cmlidXRlKCdvcGVuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBpbnZlc3RMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pbnZlc3ROYXZMaW5rJyk7XHJcbiAgICAgICAgaW52ZXN0TGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgKGxpbmsgYXMgSFRNTEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgV2FsbGV0SGVscGVyLmhpZGVNYWdpY1dhbGxldCgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcm91dGVyLnNob3dTdG9ja3Mocm91dGVyLCBldnQpO1xyXG4gICAgICAgICAgICAgICAgbGluay5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5yZW1vdmVBdHRyaWJ1dGUoJ29wZW4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBwb3NpdGlvbkxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnBvc2l0aW9uTmF2TGluaycpO1xyXG4gICAgICAgIHBvc2l0aW9uTGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgKGxpbmsgYXMgSFRNTEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgV2FsbGV0SGVscGVyLmhpZGVNYWdpY1dhbGxldCgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcm91dGVyLnNob3dQb3NpdGlvbnMocm91dGVyLCBldnQpO1xyXG4gICAgICAgICAgICAgICAgbGluay5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5yZW1vdmVBdHRyaWJ1dGUoJ29wZW4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IEF1dGhlbnRpY2F0ZVNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvQXV0aGVudGljYXRlU2VydmljZVwiO1xyXG5pbXBvcnQgQ29ubmVjdFdhbGxldCBmcm9tIFwiLi4vbW9kYWxzL0Nvbm5lY3RXYWxsZXRcIjtcclxuaW1wb3J0IFVzZXJJbmZvIGZyb20gXCIuL1VzZXJJbmZvXCI7XHJcbmltcG9ydCBBcHAgZnJvbSBcIi4uLy4uL21haW5cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlciB7XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2UoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLnNob3dVc2VyT3B0aW9ucygpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWRJbWFnZSgpIHtcclxuICAgICAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keSA+IGhlYWRlcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghaGVhZGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCk7XHJcblxyXG4gICAgICAgIGhlYWRlci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybCgvaW1nL2hlYWRlci9cIiArIHJhbmRvbSArIFwiLmpwZylcIjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd1VzZXJPcHRpb25zKCkge1xyXG4gICAgICAgIGxldCBhdXRoZW50aWNhdGlvblNlcnZpY2UgPSBuZXcgQXV0aGVudGljYXRlU2VydmljZSgpO1xyXG4gICAgICAgIGxldCBpc0F1dGhlbnRpY2F0ZWQgPSBhd2FpdCBhdXRoZW50aWNhdGlvblNlcnZpY2UuaXNBdXRoZW50aWNhdGVkKCk7XHJcblxyXG4gICAgICAgIGlmICghaXNBdXRoZW50aWNhdGVkKSB7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0V2FsbGV0ID0gbmV3IENvbm5lY3RXYWxsZXQoKTtcclxuICAgICAgICAgICAgY29ubmVjdFdhbGxldC5yZW5kZXJCdXR0b24oJ3VzZXJfaGVhZGVyX2luZm8nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHVzZXJJbmZvID0gbmV3IFVzZXJJbmZvKEFwcC5Vc2VyLnByb3ZpZGVySW5mbyk7XHJcbiAgICAgICAgYXdhaXQgdXNlckluZm8ucmVuZGVyKCd1c2VyX2hlYWRlcl9pbmZvJyk7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFBvc2l0aW9uc1NlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvUG9zaXRpb25zU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlckluZm8gZnJvbSBcIi4vVXNlckluZm9cIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xyXG5pbXBvcnQgUG9zaXRpb25zUGFnZSBmcm9tIFwiLi4vcGFnZXMvUG9zaXRpb25zUGFnZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlclBvc2l0aW9uIHtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3Rlckxpc3RlbmVyKCkge1xyXG4gICAgICAgIFVzZXJJbmZvLm9uVXNlckxvZ2dlZEluLnB1c2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdXNlclBvc2l0aW9uID0gbmV3IFVzZXJQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICB1c2VyUG9zaXRpb24ucmVuZGVyKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSgpO1xyXG4gICAgICAgIGxldCBwb3NpdGlvblNlcnZpY2UgPSBuZXcgUG9zaXRpb25zU2VydmljZSgpO1xyXG4gICAgICAgIGxldCB1c2VyUG9zaXRpb24gPSBhd2FpdCBwb3NpdGlvblNlcnZpY2UuZ2V0VXNlclBvc2l0aW9ucyh1c2VyU2VydmljZS5nZXRFdGhBZGRyZXNzKCkhKTtcclxuICAgICAgICBpZiAoIXVzZXJQb3NpdGlvbikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcGxfc3RhdHVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBsX3N0YXR1cycpO1xyXG4gICAgICAgIHBsX3N0YXR1cz8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgcGxfc3RhdHVzPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvblBhZ2UgPSBuZXcgUG9zaXRpb25zUGFnZSgpO1xyXG4gICAgICAgICAgICBwb3NpdGlvblBhZ2UubG9hZCgpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCB1bnJlYWxpemVkX3BsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VucmVhbGl6ZWRfcGwnKTtcclxuICAgICAgICBpZiAodW5yZWFsaXplZF9wbCkge1xyXG4gICAgICAgICAgICBsZXQgbnVtYmVyID0gbmV3IEJpZ051bWJlcih1c2VyUG9zaXRpb24udW5yZWFsaXplZFBMKTtcclxuICAgICAgICAgICAgdW5yZWFsaXplZF9wbC5pbm5lckhUTUwgPSAnJCcgKyBudW1iZXIuZGVjaW1hbFBsYWNlcygwKS50b0ZpeGVkKCk7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZSh1c2VyUG9zaXRpb24udW5yZWFsaXplZFBMKTtcclxuICAgICAgICAgICAgdW5yZWFsaXplZF9wbC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgbGV0IHVucmVhbGl6ZWRfcGxwYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1bnJlYWxpemVkX3BscGMnKTtcclxuICAgICAgICBpZiAodW5yZWFsaXplZF9wbHBjKSB7XHJcbiAgICAgICAgICAgIGxldCBudW1iZXIgPSBuZXcgQmlnTnVtYmVyKHVzZXJQb3NpdGlvbi51bnJlYWxpemVkUExQYyk7XHJcbiAgICAgICAgICAgIHVucmVhbGl6ZWRfcGxwYy5pbm5lckhUTUwgPSBudW1iZXIubXVsdGlwbGllZEJ5KDEwMCkuZGVjaW1hbFBsYWNlcygyKS50b0ZpeGVkKCkgKyAnJSc7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzTmFtZSh1c2VyUG9zaXRpb24udW5yZWFsaXplZFBMKTtcclxuICAgICAgICAgICAgdW5yZWFsaXplZF9wbHBjLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0Q2xhc3NOYW1lKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gKHZhbHVlLnRvU3RyaW5nKCkuaW5kZXhPZignLScpID09IC0xKSA/ICdncmVlbicgOiAncmVkJztcclxuICAgIH1cclxuXHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiXFxyXFxuPGFydGljbGUgY2xhc3M9XFxcInRyYWRlX2V4ZWN1dGVkXFxcIj5cXHJcXG4gICAgPG5hdj5cXHJcXG4gICAgPHVsPlxcclxcbiAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCJ7e3NlbGxpbmdMb2dvfX1cXFwiPjxiciAvPlxcclxcbiAgICAgICAgICAgIHt7c2VsbGluZ1N5bWJvbH19PGJyIC8+XFxyXFxuICAgICAgICAgICAge3tzZWxsaW5nQW1vdW50fX1cXHJcXG4gICAgICAgIDwvbGk+XFxyXFxuICAgIDwvdWw+XFxyXFxuICAgIDx1bD5cXHJcXG4gICAgICAgIDxsaT4gLS0tLT4gPC9saT5cXHJcXG4gICAgPC91bD5cXHJcXG4gICAgPHVsPlxcclxcbiAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCJ7e2J1eWluZ0xvZ299fVxcXCIgLz48YnIgLz5cXHJcXG4gICAgICAgICAgICB7e2J1eWluZ1N5bWJvbH19PGJyIC8+XFxyXFxuICAgICAgICAgICAgPGFiYnIgdGl0bGU9XFxcInt7YnV5aW5nUXVhbnRpdHl9fVxcXCIgZGF0YS10b29sdGlwPVxcXCJ7e2J1eWluZ1F1YW50aXR5fX1cXFwiPnt7YnV5aW5nUm91bmRRdWFudGl0eX19PC9hYmJyPlxcclxcbiAgICAgICAgPC9saT5cXHJcXG4gICAgPC91bD5cXHJcXG4gICAgPC9uYXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICBJZiB5b3UgaGF2ZW4ndCBhbHJlYWR5LCBhZGQgdGhlIHt7YnV5aW5nU3ltYm9sfX0gdG8geW91ciB3YWxsZXQuXFxyXFxuICAgICAgICA8YnIgLz48YnIgLz5cXHJcXG4gICAgICAgIDxidXR0b24gaWQ9XFxcImFkZFRva2VuVG9XYWxsZXRcXFwiIGRhdGEtYWRkcmVzcz1cXFwie3t0b2tlbkFkZHJlc3N9fVxcXCI+QWRkIHt7YnV5aW5nU3ltYm9sfX0gdG8gd2FsbGV0PC9idXR0b24+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJhZGRUb2tlblRvV2FsbGV0RmFpbGVkXFxcIiBjbGFzcz1cXFwiZC1ub25lXFxcIj5cXHJcXG4gICAgICAgICAgICBZb3UgY2FuIGNvcHkgdGhlIGFkZHJlc3MsIHRvIGltcG9ydCB0aGUgdG9rZW5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9XFxcInt7dG9rZW5BZGRyZXNzfX1cXFwiIC8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxiciAvPlxcclxcbiAgICAgICAgU2hvdWxkIGJlIHZpc2libGUgaW4geW91ciB7e3dhbGxldE5hbWV9fSBvbiBhZGRyZXNzIHt7c2hvcnRFdGhBZGRyZXNzfX0uXFxyXFxuICAgICAgICA8YnIgLz48YnIgLz5cXHJcXG4gICAgICAgIDxzbWFsbD5Zb3UgY2FuIHZpZXcgdGhlIDxhIGhyZWY9XFxcInt7YmxvY2tFeHBsb3Jlckxpbmt9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPmJsb2NrIHRyYW5zYWN0aW9uIGhlcmU8L2E+PC9zbWFsbD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9hcnRpY2xlPlxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQge3JvdW5kQmlnTnVtYmVyRGVjaW1hbCwgcm91bmROdW1iZXJEZWNpbWFsLCBzaG9ydEV0aH0gZnJvbSBcIi4uLy4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xyXG5pbXBvcnQgQVVzZEJhbGFuY2UgZnJvbSBcIi4uL0FVc2RCYWxhbmNlXCI7XHJcbmltcG9ydCBQcm92aWRlckluZm8gZnJvbSBcIi4uLy4uLy4uL3dhbGxldC9Qcm92aWRlckluZm9cIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uLy4uL21vZGFscy9Nb2RhbFwiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5pbXBvcnQgVHJhZGVFeGVjdXRlZEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9lbGVtZW50cy90cmFkZXBhbmVsL1RyYWRlRXhlY3V0ZWQuaHRtbCdcclxuaW1wb3J0IE9yZGVyUHJvZ3Jlc3MgZnJvbSBcIi4vT3JkZXJQcm9ncmVzc1wiO1xyXG5cclxuY29uc3QgY29uZmV0dGkgPSByZXF1aXJlKCdjYW52YXMtY29uZmV0dGknKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9yZGVyRXhlY3V0ZWRNb2RhbCB7XHJcblxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93KG9iamVjdDogYW55KSB7XHJcbiAgICAgICAgYXdhaXQgQVVzZEJhbGFuY2UuZm9yY2VMb2FkQVVTREJhbGFuY2VVSSgpO1xyXG5cclxuICAgICAgICBPcmRlclByb2dyZXNzLmdldEluc3RhbmNlKCkuY2xlYXJQcm9ncmVzc1RleHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHByb3ZpZGVySW5mbyA9IFByb3ZpZGVySW5mby5JbnN0YW5jZTtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBBcHAuTmV0d29yaztcclxuICAgICAgICBsZXQgaXNCdXkgPSAob2JqZWN0LnNpZGUgPT0gJ2J1eScpO1xyXG5cclxuICAgICAgICBsZXQgb2JqID0gKGlzQnV5KSA/IHRoaXMuZ2V0QnV5aW5nU2hhcmVzT2JqKG9iamVjdCkgOiB0aGlzLmdldFNlbGxTaGFyZXNPYmoob2JqZWN0KTtcclxuICAgICAgICBvYmoud2FsbGV0TmFtZSA9IHByb3ZpZGVySW5mbz8uV2FsbGV0TmFtZSA/PyAnJztcclxuICAgICAgICBvYmouYmxvY2tFeHBsb3JlckxpbmsgPSBuZXR3b3JrSW5mby5CbG9ja0V4cGxvcmVyICsgJy90eC8nICsgb2JqZWN0LnRyYW5zYWN0aW9uX2hhc2g7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShUcmFkZUV4ZWN1dGVkSHRtbCk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZShvYmopO1xyXG4gICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgIG1vZGFsLnNob3dNb2RhbCgnVHJhZGUgZXhlY3V0ZWQnLCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgbGV0IG15Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgbXlDYW52YXMuaWQgPSAnY29uZmV0dGknO1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cmFkZV9leGVjdXRlZCcpIS5hcHBlbmRDaGlsZChteUNhbnZhcyk7XHJcblxyXG4gICAgICAgIGxldCBteUNvbmZldHRpID0gY29uZmV0dGkuY3JlYXRlKG15Q2FudmFzLCB7cmVzaXplOiB0cnVlLCB1c2VXb3JrZXI6IHRydWV9KTtcclxuICAgICAgICBteUNvbmZldHRpKHtwYXJ0aWNsZUNvdW50OiAyMDAsIHNwcmVhZDogMjAwfSk7XHJcblxyXG4gICAgICAgIGxldCBhZGRUb2tlblRvV2FsbGV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFRva2VuVG9XYWxsZXQnKTtcclxuICAgICAgICBpZiAoIWFkZFRva2VuVG9XYWxsZXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgYWRkVG9rZW5Ub1dhbGxldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuXHJcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmRhdGFzZXQuYWRkcmVzcyBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIGxldCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKCk7XHJcbiAgICAgICAgICAgIHdhbGxldEhlbHBlci5hZGRUb2tlblRvV2FsbGV0KGFkZHJlc3MsIG9iai5idXlpbmdTeW1ib2wsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBhZGRUb2tlblRvV2FsbGV0RmFpbGVkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFRva2VuVG9XYWxsZXRGYWlsZWQnKTtcclxuICAgICAgICAgICAgICAgIGlmICghYWRkVG9rZW5Ub1dhbGxldEZhaWxlZCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGFkZFRva2VuVG9XYWxsZXRGYWlsZWQuY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGdldEJ1eWluZ1NoYXJlc09iaihvYmplY3Q6IGFueSk6IGFueSB7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSBvYmplY3Qud2FsbGV0QWRkcmVzcztcclxuICAgICAgICBsZXQgdG9rZW5BZGRyZXNzID0gb2JqZWN0LnRva2VuQWRkcmVzcztcclxuICAgICAgICBsZXQgYnV5aW5nUXVhbnRpdHkgPSBvYmplY3QuZmlsbGVkX3F0eTtcclxuICAgICAgICBsZXQgc2VsbGluZ0Ftb3VudCA9ICckJyArIG9iamVjdC5hbW91bnQ7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlbGxpbmdMb2dvOiAnL2ltZy9sb2dvcy9hVVNELnBuZycsXHJcbiAgICAgICAgICAgIHNlbGxpbmdTeW1ib2w6ICdhVVNEJyxcclxuICAgICAgICAgICAgc2VsbGluZ0Ftb3VudDogc2VsbGluZ0Ftb3VudCxcclxuICAgICAgICAgICAgYnV5aW5nTG9nbzogJy9pbWcvbG9nb3MvJyArIG9iamVjdC5zeW1ib2wgKyAnLnBuZycsXHJcbiAgICAgICAgICAgIGJ1eWluZ1N5bWJvbDogb2JqZWN0LnN5bWJvbCxcclxuICAgICAgICAgICAgYnV5aW5nUXVhbnRpdHk6IGJ1eWluZ1F1YW50aXR5LFxyXG4gICAgICAgICAgICBidXlpbmdSb3VuZFF1YW50aXR5OiByb3VuZE51bWJlckRlY2ltYWwoYnV5aW5nUXVhbnRpdHksIDYpICsgJyBzaGFyZXMnLFxyXG4gICAgICAgICAgICBzaG9ydEV0aEFkZHJlc3M6IHNob3J0RXRoKGV0aEFkZHJlc3MpLFxyXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IHRva2VuQWRkcmVzc1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0U2VsbFNoYXJlc09iaihvYmplY3Q6IGFueSk6IGFueSB7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSBvYmplY3Quc2VuZGVyO1xyXG4gICAgICAgIGxldCB0b2tlbkFkZHJlc3MgPSBvYmplY3QucmVjaXBpZW50O1xyXG4gICAgICAgIGxldCBidXlpbmdRdWFudGl0eSA9IG5ldyBCaWdOdW1iZXIob2JqZWN0LmZpbGxlZF9hdmdfcHJpY2UpLm11bHRpcGxpZWRCeShuZXcgQmlnTnVtYmVyKG9iamVjdC5maWxsZWRfcXR5KSlcclxuICAgICAgICBsZXQgc2VsbGluZ0Ftb3VudCA9IG9iamVjdC5maWxsZWRfcXR5O1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBzZWxsaW5nTG9nbzogJy9pbWcvbG9nb3MvJyArIG9iamVjdC5zeW1ib2wgKyAnLnBuZycsXHJcbiAgICAgICAgICAgIHNlbGxpbmdTeW1ib2w6IG9iamVjdC5zeW1ib2wsXHJcbiAgICAgICAgICAgIHNlbGxpbmdBbW91bnQ6IHNlbGxpbmdBbW91bnQgKyAnIHNoYXJlcycsXHJcbiAgICAgICAgICAgIGJ1eWluZ0xvZ286ICcvaW1nL2xvZ29zL2FVU0QucG5nJyxcclxuICAgICAgICAgICAgYnV5aW5nU3ltYm9sOiAnYVVTRCcsXHJcbiAgICAgICAgICAgIGJ1eWluZ1F1YW50aXR5OiBidXlpbmdRdWFudGl0eS50b0ZpeGVkKCksXHJcbiAgICAgICAgICAgIGJ1eWluZ1JvdW5kUXVhbnRpdHk6ICckJyArIHJvdW5kQmlnTnVtYmVyRGVjaW1hbChidXlpbmdRdWFudGl0eSwgNikudG9GaXhlZCgpLFxyXG4gICAgICAgICAgICBzaG9ydEV0aEFkZHJlc3M6IHNob3J0RXRoKGV0aEFkZHJlc3MpLFxyXG4gICAgICAgICAgICB0b2tlbkFkZHJlc3M6IHRva2VuQWRkcmVzc1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IEV4ZWN1dGVPcmRlckJ1dHRvbiBmcm9tIFwiLi4vLi4vdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlT3JkZXJCdXR0b25cIjtcclxuaW1wb3J0IEFwcCBmcm9tIFwiLi4vLi4vbWFpblwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IFVzZXJJbmZvIGZyb20gXCIuLi8uLi91aS9lbGVtZW50cy9Vc2VySW5mb1wiO1xyXG5pbXBvcnQge2lzSlNPTn0gZnJvbSBcIi4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBLeWNBcHByb3ZlZCBmcm9tIFwiLi4vLi4vdWkvbW9kYWxzL0tZQy9LeWNBcHByb3ZlZFwiO1xyXG5pbXBvcnQge0V4Y2VwdGlvbn0gZnJvbSBcImhhbmRsZWJhcnNcIjtcclxuaW1wb3J0IE9yZGVyRXhlY3V0ZWRNb2RhbCBmcm9tIFwiLi4vLi4vdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9PcmRlckV4ZWN1dGVkTW9kYWxcIjtcclxuaW1wb3J0IE9yZGVyUHJvZ3Jlc3MgZnJvbSBcIi4uLy4uL3VpL2VsZW1lbnRzL3RyYWRlcGFuZWwvT3JkZXJQcm9ncmVzc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRTZXJ2aWNlIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyKCkge1xyXG4gICAgICAgIFVzZXJJbmZvLm9uVXNlckxvZ2dlZEluLnB1c2goYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRTZXJ2aWNlID0gbmV3IEV2ZW50U2VydmljZSgpO1xyXG4gICAgICAgICAgICBldmVudFNlcnZpY2UubGlzdGVuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxpc3RlbigpIHtcclxuICAgICAgICBsZXQgbmV0d29yayA9IEFwcC5OZXR3b3JrO1xyXG4gICAgICAgIGxldCBldmVudFNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZShuZXR3b3JrLlNlcnZlclVybCArICcvbGlzdGVuRm9yQ2hhbmdlcz9qd3Q9JyArIEFwcC5Vc2VyLnRva2VuKTtcclxuICAgICAgICBldmVudFNvdXJjZS5vbm1lc3NhZ2UgPSBhc3luYyAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gZS5kYXRhO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEgPT0gJ29rJykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IG9iaiA9IGlzSlNPTihkYXRhKTtcclxuICAgICAgICAgICAgaWYgKCFvYmopIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkYXRhIGlzIG5vdCBqc29uOicsIGRhdGEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvYmoubWV0aG9kTmFtZSA9PSAnT3JkZXJFeGVjdXRlZCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBvcmRlckV4ZWN1dGVkTW9kYWwgPSBuZXcgT3JkZXJFeGVjdXRlZE1vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICBvcmRlckV4ZWN1dGVkTW9kYWwuc2hvdyhvYmopO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5tZXRob2ROYW1lID09ICdTZW5kaW5nVG9FeGNoYW5nZScpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IE9yZGVyUHJvZ3Jlc3MuZ2V0SW5zdGFuY2UoKS5zZXRQcm9ncmVzc1RleHQoMSwgJ1JlY2VpdmVkIG9yZGVyLCBzZW5kaW5nIHRvIHN0b2NrIGV4Y2hhbmdlJywgb2JqLmhhc2gpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqLm1ldGhvZE5hbWUgPT0gJ0JhbGFuY2VTZXQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmJhbGFuY2UgIT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRXhlY3V0ZU9yZGVyQnV0dG9uLkluc3RhbmNlLnJlbmRlckJ1dHRvbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iai5tZXRob2ROYW1lID09ICdBY2NvdW50VmFsaWRhdGVkJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGhhc0J1eWluZ1Bvd2VyID0gb2JqLmhhc0J1eWluZ1Bvd2VyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNCdXlpbmdQb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBreWNBcHByb3ZlZCA9IG5ldyBLeWNBcHByb3ZlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGt5Y0FwcHJvdmVkLnNob3coKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRXhlY3V0ZU9yZGVyQnV0dG9uLkluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRXhlY3V0ZU9yZGVyQnV0dG9uLkluc3RhbmNlLmhhc0J1eWluZ1Bvd2VyID0gb2JqLmhhc0J1eWluZ1Bvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoRXhlY3V0ZU9yZGVyQnV0dG9uLkluc3RhbmNlLmt5Y0lkRG9uZVRpbWVvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIEV4ZWN1dGVPcmRlckJ1dHRvbi5JbnN0YW5jZS5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IFJvdXRpbmcgZnJvbSBcIi4vcm91dGluZy9Sb3V0aW5nXCI7XHJcbmltcG9ydCBIZWFkZXIgZnJvbSBcIi4vdWkvZWxlbWVudHMvSGVhZGVyXCI7XHJcbmltcG9ydCBVc2VyUG9zaXRpb24gZnJvbSBcIi4vdWkvZWxlbWVudHMvVXNlclBvc2l0aW9uXCI7XHJcbmltcG9ydCBVc2VyIGZyb20gXCIuL2R0by9Vc2VyXCI7XHJcbmltcG9ydCBOZXR3b3JrIGZyb20gXCIuL25ldHdvcmtzL05ldHdvcmtcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBFdmVudFNlcnZpY2UgZnJvbSBcIi4vc2VydmljZXMvYmFja2VuZC9FdmVudFNlcnZpY2VcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIHtcclxuICAgIHB1YmxpYyBzdGF0aWMgVXNlcjogVXNlcjtcclxuICAgIHB1YmxpYyBzdGF0aWMgTmV0d29yazogTmV0d29yaztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBBcHAuTmV0d29yayA9IE5ldHdvcmtJbmZvLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ25ldHdvcmsnLCBBcHAuTmV0d29yayk7XHJcbiAgICAgICAgQXBwLlVzZXIgPSBuZXcgVXNlcihudWxsLCAnJywgQXBwLk5ldHdvcmsuQ2hhaW5JZCwgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzdGFydCgpIHtcclxuICAgICAgICBsZXQgcm91dGluZyA9IG5ldyBSb3V0aW5nKCk7XHJcbiAgICAgICAgYXdhaXQgcm91dGluZy5sb2FkUm91dGVzKCk7XHJcblxyXG4gICAgICAgIFVzZXJQb3NpdGlvbi5yZWdpc3Rlckxpc3RlbmVyKCk7XHJcbiAgICAgICAgRXZlbnRTZXJ2aWNlLnJlZ2lzdGVyKCk7XHJcblxyXG4gICAgICAgIGxldCBoZWFkZXIgPSBuZXcgSGVhZGVyKCk7XHJcbiAgICAgICAgaGVhZGVyLmxvYWQoKTtcclxuXHJcbiAgICAgICAgaWYgKFdhbGxldEhlbHBlci5pc1dlYnZpZXcoKSkge1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIHZhciB2Q29uc29sZSA9IG5ldyB3aW5kb3cuVkNvbnNvbGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmxldCBhcHAgPSBuZXcgQXBwKCk7XHJcbmFwcC5zdGFydCgpLnRoZW4oKTtcclxuLy8gQHRzLWlnbm9yZVxyXG53aW5kb3cuYXBwID0gYXBwO1xyXG5cclxuZXhwb3J0IHtBcHB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.ts\n");

            /***/
        }),

        /***/ "?8131":
        /*!************************!*\
          !*** buffer (ignored) ***!
          \************************/
        /***/ (() => {

            /* (ignored) */

            /***/
        }),

        /***/ "./node_modules/canvas-confetti/dist/confetti.module.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/canvas-confetti/dist/confetti.module.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// canvas-confetti v1.6.0 built on 2022-10-24T21:26:41.619Z\nvar module = {};\n\n// source content\n(function main(global, module, isWorker, workerSize) {\n  var canUseWorker = !!(\n    global.Worker &&\n    global.Blob &&\n    global.Promise &&\n    global.OffscreenCanvas &&\n    global.OffscreenCanvasRenderingContext2D &&\n    global.HTMLCanvasElement &&\n    global.HTMLCanvasElement.prototype.transferControlToOffscreen &&\n    global.URL &&\n    global.URL.createObjectURL);\n\n  function noop() {}\n\n  // create a promise if it exists, otherwise, just\n  // call the function directly\n  function promise(func) {\n    var ModulePromise = module.exports.Promise;\n    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\n\n    if (typeof Prom === 'function') {\n      return new Prom(func);\n    }\n\n    func(noop, noop);\n\n    return null;\n  }\n\n  var raf = (function () {\n    var TIME = Math.floor(1000 / 60);\n    var frame, cancel;\n    var frames = {};\n    var lastFrameTime = 0;\n\n    if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {\n      frame = function (cb) {\n        var id = Math.random();\n\n        frames[id] = requestAnimationFrame(function onFrame(time) {\n          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\n            lastFrameTime = time;\n            delete frames[id];\n\n            cb();\n          } else {\n            frames[id] = requestAnimationFrame(onFrame);\n          }\n        });\n\n        return id;\n      };\n      cancel = function (id) {\n        if (frames[id]) {\n          cancelAnimationFrame(frames[id]);\n        }\n      };\n    } else {\n      frame = function (cb) {\n        return setTimeout(cb, TIME);\n      };\n      cancel = function (timer) {\n        return clearTimeout(timer);\n      };\n    }\n\n    return { frame: frame, cancel: cancel };\n  }());\n\n  var getWorker = (function () {\n    var worker;\n    var prom;\n    var resolves = {};\n\n    function decorate(worker) {\n      function execute(options, callback) {\n        worker.postMessage({ options: options || {}, callback: callback });\n      }\n      worker.init = function initWorker(canvas) {\n        var offscreen = canvas.transferControlToOffscreen();\n        worker.postMessage({ canvas: offscreen }, [offscreen]);\n      };\n\n      worker.fire = function fireWorker(options, size, done) {\n        if (prom) {\n          execute(options, null);\n          return prom;\n        }\n\n        var id = Math.random().toString(36).slice(2);\n\n        prom = promise(function (resolve) {\n          function workerDone(msg) {\n            if (msg.data.callback !== id) {\n              return;\n            }\n\n            delete resolves[id];\n            worker.removeEventListener('message', workerDone);\n\n            prom = null;\n            done();\n            resolve();\n          }\n\n          worker.addEventListener('message', workerDone);\n          execute(options, id);\n\n          resolves[id] = workerDone.bind(null, { data: { callback: id }});\n        });\n\n        return prom;\n      };\n\n      worker.reset = function resetWorker() {\n        worker.postMessage({ reset: true });\n\n        for (var id in resolves) {\n          resolves[id]();\n          delete resolves[id];\n        }\n      };\n    }\n\n    return function () {\n      if (worker) {\n        return worker;\n      }\n\n      if (!isWorker && canUseWorker) {\n        var code = [\n          'var CONFETTI, SIZE = {}, module = {};',\n          '(' + main.toString() + ')(this, module, true, SIZE);',\n          'onmessage = function(msg) {',\n          '  if (msg.data.options) {',\n          '    CONFETTI(msg.data.options).then(function () {',\n          '      if (msg.data.callback) {',\n          '        postMessage({ callback: msg.data.callback });',\n          '      }',\n          '    });',\n          '  } else if (msg.data.reset) {',\n          '    CONFETTI && CONFETTI.reset();',\n          '  } else if (msg.data.resize) {',\n          '    SIZE.width = msg.data.resize.width;',\n          '    SIZE.height = msg.data.resize.height;',\n          '  } else if (msg.data.canvas) {',\n          '    SIZE.width = msg.data.canvas.width;',\n          '    SIZE.height = msg.data.canvas.height;',\n          '    CONFETTI = module.exports.create(msg.data.canvas);',\n          '  }',\n          '}',\n        ].join('\\n');\n        try {\n          worker = new Worker(URL.createObjectURL(new Blob([code])));\n        } catch (e) {\n          // eslint-disable-next-line no-console\n          typeof console !== undefined && typeof console.warn === 'function' ? console.warn(' Could not load worker', e) : null;\n\n          return null;\n        }\n\n        decorate(worker);\n      }\n\n      return worker;\n    };\n  })();\n\n  var defaults = {\n    particleCount: 50,\n    angle: 90,\n    spread: 45,\n    startVelocity: 45,\n    decay: 0.9,\n    gravity: 1,\n    drift: 0,\n    ticks: 200,\n    x: 0.5,\n    y: 0.5,\n    shapes: ['square', 'circle'],\n    zIndex: 100,\n    colors: [\n      '#26ccff',\n      '#a25afd',\n      '#ff5e7e',\n      '#88ff5a',\n      '#fcff42',\n      '#ffa62d',\n      '#ff36ff'\n    ],\n    // probably should be true, but back-compat\n    disableForReducedMotion: false,\n    scalar: 1\n  };\n\n  function convert(val, transform) {\n    return transform ? transform(val) : val;\n  }\n\n  function isOk(val) {\n    return !(val === null || val === undefined);\n  }\n\n  function prop(options, name, transform) {\n    return convert(\n      options && isOk(options[name]) ? options[name] : defaults[name],\n      transform\n    );\n  }\n\n  function onlyPositiveInt(number){\n    return number < 0 ? 0 : Math.floor(number);\n  }\n\n  function randomInt(min, max) {\n    // [min, max)\n    return Math.floor(Math.random() * (max - min)) + min;\n  }\n\n  function toDecimal(str) {\n    return parseInt(str, 16);\n  }\n\n  function colorsToRgb(colors) {\n    return colors.map(hexToRgb);\n  }\n\n  function hexToRgb(str) {\n    var val = String(str).replace(/[^0-9a-f]/gi, '');\n\n    if (val.length < 6) {\n        val = val[0]+val[0]+val[1]+val[1]+val[2]+val[2];\n    }\n\n    return {\n      r: toDecimal(val.substring(0,2)),\n      g: toDecimal(val.substring(2,4)),\n      b: toDecimal(val.substring(4,6))\n    };\n  }\n\n  function getOrigin(options) {\n    var origin = prop(options, 'origin', Object);\n    origin.x = prop(origin, 'x', Number);\n    origin.y = prop(origin, 'y', Number);\n\n    return origin;\n  }\n\n  function setCanvasWindowSize(canvas) {\n    canvas.width = document.documentElement.clientWidth;\n    canvas.height = document.documentElement.clientHeight;\n  }\n\n  function setCanvasRectSize(canvas) {\n    var rect = canvas.getBoundingClientRect();\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n  }\n\n  function getCanvas(zIndex) {\n    var canvas = document.createElement('canvas');\n\n    canvas.style.position = 'fixed';\n    canvas.style.top = '0px';\n    canvas.style.left = '0px';\n    canvas.style.pointerEvents = 'none';\n    canvas.style.zIndex = zIndex;\n\n    return canvas;\n  }\n\n  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\n    context.save();\n    context.translate(x, y);\n    context.rotate(rotation);\n    context.scale(radiusX, radiusY);\n    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\n    context.restore();\n  }\n\n  function randomPhysics(opts) {\n    var radAngle = opts.angle * (Math.PI / 180);\n    var radSpread = opts.spread * (Math.PI / 180);\n\n    return {\n      x: opts.x,\n      y: opts.y,\n      wobble: Math.random() * 10,\n      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\n      velocity: (opts.startVelocity * 0.5) + (Math.random() * opts.startVelocity),\n      angle2D: -radAngle + ((0.5 * radSpread) - (Math.random() * radSpread)),\n      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\n      color: opts.color,\n      shape: opts.shape,\n      tick: 0,\n      totalTicks: opts.ticks,\n      decay: opts.decay,\n      drift: opts.drift,\n      random: Math.random() + 2,\n      tiltSin: 0,\n      tiltCos: 0,\n      wobbleX: 0,\n      wobbleY: 0,\n      gravity: opts.gravity * 3,\n      ovalScalar: 0.6,\n      scalar: opts.scalar\n    };\n  }\n\n  function updateFetti(context, fetti) {\n    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\n    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\n    fetti.wobble += fetti.wobbleSpeed;\n    fetti.velocity *= fetti.decay;\n    fetti.tiltAngle += 0.1;\n    fetti.tiltSin = Math.sin(fetti.tiltAngle);\n    fetti.tiltCos = Math.cos(fetti.tiltAngle);\n    fetti.random = Math.random() + 2;\n    fetti.wobbleX = fetti.x + ((10 * fetti.scalar) * Math.cos(fetti.wobble));\n    fetti.wobbleY = fetti.y + ((10 * fetti.scalar) * Math.sin(fetti.wobble));\n\n    var progress = (fetti.tick++) / fetti.totalTicks;\n\n    var x1 = fetti.x + (fetti.random * fetti.tiltCos);\n    var y1 = fetti.y + (fetti.random * fetti.tiltSin);\n    var x2 = fetti.wobbleX + (fetti.random * fetti.tiltCos);\n    var y2 = fetti.wobbleY + (fetti.random * fetti.tiltSin);\n\n    context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';\n    context.beginPath();\n\n    if (fetti.shape === 'circle') {\n      context.ellipse ?\n        context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) :\n        ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\n    } else if (fetti.shape === 'star') {\n      var rot = Math.PI / 2 * 3;\n      var innerRadius = 4 * fetti.scalar;\n      var outerRadius = 8 * fetti.scalar;\n      var x = fetti.x;\n      var y = fetti.y;\n      var spikes = 5;\n      var step = Math.PI / spikes;\n\n      while (spikes--) {\n        x = fetti.x + Math.cos(rot) * outerRadius;\n        y = fetti.y + Math.sin(rot) * outerRadius;\n        context.lineTo(x, y);\n        rot += step;\n\n        x = fetti.x + Math.cos(rot) * innerRadius;\n        y = fetti.y + Math.sin(rot) * innerRadius;\n        context.lineTo(x, y);\n        rot += step;\n      }\n    } else {\n      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\n      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\n      context.lineTo(Math.floor(x2), Math.floor(y2));\n      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\n    }\n\n    context.closePath();\n    context.fill();\n\n    return fetti.tick < fetti.totalTicks;\n  }\n\n  function animate(canvas, fettis, resizer, size, done) {\n    var animatingFettis = fettis.slice();\n    var context = canvas.getContext('2d');\n    var animationFrame;\n    var destroy;\n\n    var prom = promise(function (resolve) {\n      function onDone() {\n        animationFrame = destroy = null;\n\n        context.clearRect(0, 0, size.width, size.height);\n\n        done();\n        resolve();\n      }\n\n      function update() {\n        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\n          size.width = canvas.width = workerSize.width;\n          size.height = canvas.height = workerSize.height;\n        }\n\n        if (!size.width && !size.height) {\n          resizer(canvas);\n          size.width = canvas.width;\n          size.height = canvas.height;\n        }\n\n        context.clearRect(0, 0, size.width, size.height);\n\n        animatingFettis = animatingFettis.filter(function (fetti) {\n          return updateFetti(context, fetti);\n        });\n\n        if (animatingFettis.length) {\n          animationFrame = raf.frame(update);\n        } else {\n          onDone();\n        }\n      }\n\n      animationFrame = raf.frame(update);\n      destroy = onDone;\n    });\n\n    return {\n      addFettis: function (fettis) {\n        animatingFettis = animatingFettis.concat(fettis);\n\n        return prom;\n      },\n      canvas: canvas,\n      promise: prom,\n      reset: function () {\n        if (animationFrame) {\n          raf.cancel(animationFrame);\n        }\n\n        if (destroy) {\n          destroy();\n        }\n      }\n    };\n  }\n\n  function confettiCannon(canvas, globalOpts) {\n    var isLibCanvas = !canvas;\n    var allowResize = !!prop(globalOpts || {}, 'resize');\n    var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);\n    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');\n    var worker = shouldUseWorker ? getWorker() : null;\n    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\n    var initialized = (canvas && worker) ? !!canvas.__confetti_initialized : false;\n    var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;\n    var animationObj;\n\n    function fireLocal(options, size, done) {\n      var particleCount = prop(options, 'particleCount', onlyPositiveInt);\n      var angle = prop(options, 'angle', Number);\n      var spread = prop(options, 'spread', Number);\n      var startVelocity = prop(options, 'startVelocity', Number);\n      var decay = prop(options, 'decay', Number);\n      var gravity = prop(options, 'gravity', Number);\n      var drift = prop(options, 'drift', Number);\n      var colors = prop(options, 'colors', colorsToRgb);\n      var ticks = prop(options, 'ticks', Number);\n      var shapes = prop(options, 'shapes');\n      var scalar = prop(options, 'scalar');\n      var origin = getOrigin(options);\n\n      var temp = particleCount;\n      var fettis = [];\n\n      var startX = canvas.width * origin.x;\n      var startY = canvas.height * origin.y;\n\n      while (temp--) {\n        fettis.push(\n          randomPhysics({\n            x: startX,\n            y: startY,\n            angle: angle,\n            spread: spread,\n            startVelocity: startVelocity,\n            color: colors[temp % colors.length],\n            shape: shapes[randomInt(0, shapes.length)],\n            ticks: ticks,\n            decay: decay,\n            gravity: gravity,\n            drift: drift,\n            scalar: scalar\n          })\n        );\n      }\n\n      // if we have a previous canvas already animating,\n      // add to it\n      if (animationObj) {\n        return animationObj.addFettis(fettis);\n      }\n\n      animationObj = animate(canvas, fettis, resizer, size , done);\n\n      return animationObj.promise;\n    }\n\n    function fire(options) {\n      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);\n      var zIndex = prop(options, 'zIndex', Number);\n\n      if (disableForReducedMotion && preferLessMotion) {\n        return promise(function (resolve) {\n          resolve();\n        });\n      }\n\n      if (isLibCanvas && animationObj) {\n        // use existing canvas from in-progress animation\n        canvas = animationObj.canvas;\n      } else if (isLibCanvas && !canvas) {\n        // create and initialize a new canvas\n        canvas = getCanvas(zIndex);\n        document.body.appendChild(canvas);\n      }\n\n      if (allowResize && !initialized) {\n        // initialize the size of a user-supplied canvas\n        resizer(canvas);\n      }\n\n      var size = {\n        width: canvas.width,\n        height: canvas.height\n      };\n\n      if (worker && !initialized) {\n        worker.init(canvas);\n      }\n\n      initialized = true;\n\n      if (worker) {\n        canvas.__confetti_initialized = true;\n      }\n\n      function onResize() {\n        if (worker) {\n          // TODO this really shouldn't be immediate, because it is expensive\n          var obj = {\n            getBoundingClientRect: function () {\n              if (!isLibCanvas) {\n                return canvas.getBoundingClientRect();\n              }\n            }\n          };\n\n          resizer(obj);\n\n          worker.postMessage({\n            resize: {\n              width: obj.width,\n              height: obj.height\n            }\n          });\n          return;\n        }\n\n        // don't actually query the size here, since this\n        // can execute frequently and rapidly\n        size.width = size.height = null;\n      }\n\n      function done() {\n        animationObj = null;\n\n        if (allowResize) {\n          global.removeEventListener('resize', onResize);\n        }\n\n        if (isLibCanvas && canvas) {\n          document.body.removeChild(canvas);\n          canvas = null;\n          initialized = false;\n        }\n      }\n\n      if (allowResize) {\n        global.addEventListener('resize', onResize, false);\n      }\n\n      if (worker) {\n        return worker.fire(options, size, done);\n      }\n\n      return fireLocal(options, size, done);\n    }\n\n    fire.reset = function () {\n      if (worker) {\n        worker.reset();\n      }\n\n      if (animationObj) {\n        animationObj.reset();\n      }\n    };\n\n    return fire;\n  }\n\n  // Make default export lazy to defer worker creation until called.\n  var defaultFire;\n  function getDefaultFire() {\n    if (!defaultFire) {\n      defaultFire = confettiCannon(null, { useWorker: true, resize: true });\n    }\n    return defaultFire;\n  }\n\n  module.exports = function() {\n    return getDefaultFire().apply(this, arguments);\n  };\n  module.exports.reset = function() {\n    getDefaultFire().reset();\n  };\n  module.exports.create = confettiCannon;\n}((function () {\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  return this || {};\n})(), module, false));\n\n// end source content\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (module.exports);\nvar create = module.exports.create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2FudmFzLWNvbmZldHRpL2Rpc3QvY29uZmV0dGkubW9kdWxlLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixzQkFBc0Isc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsUUFBUSxlQUFlO0FBQ3hFLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixhQUFhOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hELCtEQUErRDtBQUMvRCxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLDREQUE0RDtBQUM1RCx5Q0FBeUM7QUFDekMsaUNBQWlDLDZCQUE2QixFQUFFO0FBQ2hFLGtCQUFrQjtBQUNsQixnQkFBZ0IsRUFBRTtBQUNsQixlQUFlLDBCQUEwQjtBQUN6Qyw0Q0FBNEM7QUFDNUMsZUFBZSwyQkFBMkI7QUFDMUMsa0RBQWtEO0FBQ2xELG9EQUFvRDtBQUNwRCxlQUFlLDJCQUEyQjtBQUMxQyxrREFBa0Q7QUFDbEQsb0RBQW9EO0FBQ3BELGlFQUFpRTtBQUNqRSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxpRUFBZSxjQUFjLEVBQUM7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9jYW52YXMtY29uZmV0dGkvZGlzdC9jb25mZXR0aS5tb2R1bGUubWpzP2JkOTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FudmFzLWNvbmZldHRpIHYxLjYuMCBidWlsdCBvbiAyMDIyLTEwLTI0VDIxOjI2OjQxLjYxOVpcbnZhciBtb2R1bGUgPSB7fTtcblxuLy8gc291cmNlIGNvbnRlbnRcbihmdW5jdGlvbiBtYWluKGdsb2JhbCwgbW9kdWxlLCBpc1dvcmtlciwgd29ya2VyU2l6ZSkge1xuICB2YXIgY2FuVXNlV29ya2VyID0gISEoXG4gICAgZ2xvYmFsLldvcmtlciAmJlxuICAgIGdsb2JhbC5CbG9iICYmXG4gICAgZ2xvYmFsLlByb21pc2UgJiZcbiAgICBnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzICYmXG4gICAgZ2xvYmFsLk9mZnNjcmVlbkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCAmJlxuICAgIGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudCAmJlxuICAgIGdsb2JhbC5IVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUudHJhbnNmZXJDb250cm9sVG9PZmZzY3JlZW4gJiZcbiAgICBnbG9iYWwuVVJMICYmXG4gICAgZ2xvYmFsLlVSTC5jcmVhdGVPYmplY3RVUkwpO1xuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4gIC8vIGNyZWF0ZSBhIHByb21pc2UgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UsIGp1c3RcbiAgLy8gY2FsbCB0aGUgZnVuY3Rpb24gZGlyZWN0bHlcbiAgZnVuY3Rpb24gcHJvbWlzZShmdW5jKSB7XG4gICAgdmFyIE1vZHVsZVByb21pc2UgPSBtb2R1bGUuZXhwb3J0cy5Qcm9taXNlO1xuICAgIHZhciBQcm9tID0gTW9kdWxlUHJvbWlzZSAhPT0gdm9pZCAwID8gTW9kdWxlUHJvbWlzZSA6IGdsb2JhbC5Qcm9taXNlO1xuXG4gICAgaWYgKHR5cGVvZiBQcm9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb20oZnVuYyk7XG4gICAgfVxuXG4gICAgZnVuYyhub29wLCBub29wKTtcblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHJhZiA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIFRJTUUgPSBNYXRoLmZsb29yKDEwMDAgLyA2MCk7XG4gICAgdmFyIGZyYW1lLCBjYW5jZWw7XG4gICAgdmFyIGZyYW1lcyA9IHt9O1xuICAgIHZhciBsYXN0RnJhbWVUaW1lID0gMDtcblxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZnJhbWUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIGlkID0gTWF0aC5yYW5kb20oKTtcblxuICAgICAgICBmcmFtZXNbaWRdID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIG9uRnJhbWUodGltZSkge1xuICAgICAgICAgIGlmIChsYXN0RnJhbWVUaW1lID09PSB0aW1lIHx8IGxhc3RGcmFtZVRpbWUgKyBUSU1FIC0gMSA8IHRpbWUpIHtcbiAgICAgICAgICAgIGxhc3RGcmFtZVRpbWUgPSB0aW1lO1xuICAgICAgICAgICAgZGVsZXRlIGZyYW1lc1tpZF07XG5cbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYW1lc1tpZF0gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgICAgY2FuY2VsID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChmcmFtZXNbaWRdKSB7XG4gICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVzW2lkXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNiLCBUSU1FKTtcbiAgICAgIH07XG4gICAgICBjYW5jZWwgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IGZyYW1lOiBmcmFtZSwgY2FuY2VsOiBjYW5jZWwgfTtcbiAgfSgpKTtcblxuICB2YXIgZ2V0V29ya2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd29ya2VyO1xuICAgIHZhciBwcm9tO1xuICAgIHZhciByZXNvbHZlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVjb3JhdGUod29ya2VyKSB7XG4gICAgICBmdW5jdGlvbiBleGVjdXRlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IG9wdGlvbnM6IG9wdGlvbnMgfHwge30sIGNhbGxiYWNrOiBjYWxsYmFjayB9KTtcbiAgICAgIH1cbiAgICAgIHdvcmtlci5pbml0ID0gZnVuY3Rpb24gaW5pdFdvcmtlcihjYW52YXMpIHtcbiAgICAgICAgdmFyIG9mZnNjcmVlbiA9IGNhbnZhcy50cmFuc2ZlckNvbnRyb2xUb09mZnNjcmVlbigpO1xuICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyBjYW52YXM6IG9mZnNjcmVlbiB9LCBbb2Zmc2NyZWVuXSk7XG4gICAgICB9O1xuXG4gICAgICB3b3JrZXIuZmlyZSA9IGZ1bmN0aW9uIGZpcmVXb3JrZXIob3B0aW9ucywgc2l6ZSwgZG9uZSkge1xuICAgICAgICBpZiAocHJvbSkge1xuICAgICAgICAgIGV4ZWN1dGUob3B0aW9ucywgbnVsbCk7XG4gICAgICAgICAgcmV0dXJuIHByb207XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuICAgICAgICBwcm9tID0gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGZ1bmN0aW9uIHdvcmtlckRvbmUobXNnKSB7XG4gICAgICAgICAgICBpZiAobXNnLmRhdGEuY2FsbGJhY2sgIT09IGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHJlc29sdmVzW2lkXTtcbiAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyRG9uZSk7XG5cbiAgICAgICAgICAgIHByb20gPSBudWxsO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgd29ya2VyRG9uZSk7XG4gICAgICAgICAgZXhlY3V0ZShvcHRpb25zLCBpZCk7XG5cbiAgICAgICAgICByZXNvbHZlc1tpZF0gPSB3b3JrZXJEb25lLmJpbmQobnVsbCwgeyBkYXRhOiB7IGNhbGxiYWNrOiBpZCB9fSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgfTtcblxuICAgICAgd29ya2VyLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXRXb3JrZXIoKSB7XG4gICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHJlc2V0OiB0cnVlIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGlkIGluIHJlc29sdmVzKSB7XG4gICAgICAgICAgcmVzb2x2ZXNbaWRdKCk7XG4gICAgICAgICAgZGVsZXRlIHJlc29sdmVzW2lkXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzV29ya2VyICYmIGNhblVzZVdvcmtlcikge1xuICAgICAgICB2YXIgY29kZSA9IFtcbiAgICAgICAgICAndmFyIENPTkZFVFRJLCBTSVpFID0ge30sIG1vZHVsZSA9IHt9OycsXG4gICAgICAgICAgJygnICsgbWFpbi50b1N0cmluZygpICsgJykodGhpcywgbW9kdWxlLCB0cnVlLCBTSVpFKTsnLFxuICAgICAgICAgICdvbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHsnLFxuICAgICAgICAgICcgIGlmIChtc2cuZGF0YS5vcHRpb25zKSB7JyxcbiAgICAgICAgICAnICAgIENPTkZFVFRJKG1zZy5kYXRhLm9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkgeycsXG4gICAgICAgICAgJyAgICAgIGlmIChtc2cuZGF0YS5jYWxsYmFjaykgeycsXG4gICAgICAgICAgJyAgICAgICAgcG9zdE1lc3NhZ2UoeyBjYWxsYmFjazogbXNnLmRhdGEuY2FsbGJhY2sgfSk7JyxcbiAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgJyAgICB9KTsnLFxuICAgICAgICAgICcgIH0gZWxzZSBpZiAobXNnLmRhdGEucmVzZXQpIHsnLFxuICAgICAgICAgICcgICAgQ09ORkVUVEkgJiYgQ09ORkVUVEkucmVzZXQoKTsnLFxuICAgICAgICAgICcgIH0gZWxzZSBpZiAobXNnLmRhdGEucmVzaXplKSB7JyxcbiAgICAgICAgICAnICAgIFNJWkUud2lkdGggPSBtc2cuZGF0YS5yZXNpemUud2lkdGg7JyxcbiAgICAgICAgICAnICAgIFNJWkUuaGVpZ2h0ID0gbXNnLmRhdGEucmVzaXplLmhlaWdodDsnLFxuICAgICAgICAgICcgIH0gZWxzZSBpZiAobXNnLmRhdGEuY2FudmFzKSB7JyxcbiAgICAgICAgICAnICAgIFNJWkUud2lkdGggPSBtc2cuZGF0YS5jYW52YXMud2lkdGg7JyxcbiAgICAgICAgICAnICAgIFNJWkUuaGVpZ2h0ID0gbXNnLmRhdGEuY2FudmFzLmhlaWdodDsnLFxuICAgICAgICAgICcgICAgQ09ORkVUVEkgPSBtb2R1bGUuZXhwb3J0cy5jcmVhdGUobXNnLmRhdGEuY2FudmFzKTsnLFxuICAgICAgICAgICcgIH0nLFxuICAgICAgICAgICd9JyxcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB3b3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2NvZGVdKSkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjb25zb2xlLndhcm4gPT09ICdmdW5jdGlvbicgPyBjb25zb2xlLndhcm4oJ/CfjoogQ291bGQgbm90IGxvYWQgd29ya2VyJywgZSkgOiBudWxsO1xuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBkZWNvcmF0ZSh3b3JrZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHBhcnRpY2xlQ291bnQ6IDUwLFxuICAgIGFuZ2xlOiA5MCxcbiAgICBzcHJlYWQ6IDQ1LFxuICAgIHN0YXJ0VmVsb2NpdHk6IDQ1LFxuICAgIGRlY2F5OiAwLjksXG4gICAgZ3Jhdml0eTogMSxcbiAgICBkcmlmdDogMCxcbiAgICB0aWNrczogMjAwLFxuICAgIHg6IDAuNSxcbiAgICB5OiAwLjUsXG4gICAgc2hhcGVzOiBbJ3NxdWFyZScsICdjaXJjbGUnXSxcbiAgICB6SW5kZXg6IDEwMCxcbiAgICBjb2xvcnM6IFtcbiAgICAgICcjMjZjY2ZmJyxcbiAgICAgICcjYTI1YWZkJyxcbiAgICAgICcjZmY1ZTdlJyxcbiAgICAgICcjODhmZjVhJyxcbiAgICAgICcjZmNmZjQyJyxcbiAgICAgICcjZmZhNjJkJyxcbiAgICAgICcjZmYzNmZmJ1xuICAgIF0sXG4gICAgLy8gcHJvYmFibHkgc2hvdWxkIGJlIHRydWUsIGJ1dCBiYWNrLWNvbXBhdFxuICAgIGRpc2FibGVGb3JSZWR1Y2VkTW90aW9uOiBmYWxzZSxcbiAgICBzY2FsYXI6IDFcbiAgfTtcblxuICBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybSA/IHRyYW5zZm9ybSh2YWwpIDogdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPayh2YWwpIHtcbiAgICByZXR1cm4gISh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvcChvcHRpb25zLCBuYW1lLCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gY29udmVydChcbiAgICAgIG9wdGlvbnMgJiYgaXNPayhvcHRpb25zW25hbWVdKSA/IG9wdGlvbnNbbmFtZV0gOiBkZWZhdWx0c1tuYW1lXSxcbiAgICAgIHRyYW5zZm9ybVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmx5UG9zaXRpdmVJbnQobnVtYmVyKXtcbiAgICByZXR1cm4gbnVtYmVyIDwgMCA/IDAgOiBNYXRoLmZsb29yKG51bWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb21JbnQobWluLCBtYXgpIHtcbiAgICAvLyBbbWluLCBtYXgpXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvRGVjaW1hbChzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxNik7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xvcnNUb1JnYihjb2xvcnMpIHtcbiAgICByZXR1cm4gY29sb3JzLm1hcChoZXhUb1JnYik7XG4gIH1cblxuICBmdW5jdGlvbiBoZXhUb1JnYihzdHIpIHtcbiAgICB2YXIgdmFsID0gU3RyaW5nKHN0cikucmVwbGFjZSgvW14wLTlhLWZdL2dpLCAnJyk7XG5cbiAgICBpZiAodmFsLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgdmFsID0gdmFsWzBdK3ZhbFswXSt2YWxbMV0rdmFsWzFdK3ZhbFsyXSt2YWxbMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHI6IHRvRGVjaW1hbCh2YWwuc3Vic3RyaW5nKDAsMikpLFxuICAgICAgZzogdG9EZWNpbWFsKHZhbC5zdWJzdHJpbmcoMiw0KSksXG4gICAgICBiOiB0b0RlY2ltYWwodmFsLnN1YnN0cmluZyg0LDYpKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcmlnaW4ob3B0aW9ucykge1xuICAgIHZhciBvcmlnaW4gPSBwcm9wKG9wdGlvbnMsICdvcmlnaW4nLCBPYmplY3QpO1xuICAgIG9yaWdpbi54ID0gcHJvcChvcmlnaW4sICd4JywgTnVtYmVyKTtcbiAgICBvcmlnaW4ueSA9IHByb3Aob3JpZ2luLCAneScsIE51bWJlcik7XG5cbiAgICByZXR1cm4gb3JpZ2luO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FudmFzV2luZG93U2l6ZShjYW52YXMpIHtcbiAgICBjYW52YXMud2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRDYW52YXNSZWN0U2l6ZShjYW52YXMpIHtcbiAgICB2YXIgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjYW52YXMud2lkdGggPSByZWN0LndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENhbnZhcyh6SW5kZXgpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG5cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgZnVuY3Rpb24gZWxsaXBzZShjb250ZXh0LCB4LCB5LCByYWRpdXNYLCByYWRpdXNZLCByb3RhdGlvbiwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShyb3RhdGlvbik7XG4gICAgY29udGV4dC5zY2FsZShyYWRpdXNYLCByYWRpdXNZKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCAxLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb21QaHlzaWNzKG9wdHMpIHtcbiAgICB2YXIgcmFkQW5nbGUgPSBvcHRzLmFuZ2xlICogKE1hdGguUEkgLyAxODApO1xuICAgIHZhciByYWRTcHJlYWQgPSBvcHRzLnNwcmVhZCAqIChNYXRoLlBJIC8gMTgwKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBvcHRzLngsXG4gICAgICB5OiBvcHRzLnksXG4gICAgICB3b2JibGU6IE1hdGgucmFuZG9tKCkgKiAxMCxcbiAgICAgIHdvYmJsZVNwZWVkOiBNYXRoLm1pbigwLjExLCBNYXRoLnJhbmRvbSgpICogMC4xICsgMC4wNSksXG4gICAgICB2ZWxvY2l0eTogKG9wdHMuc3RhcnRWZWxvY2l0eSAqIDAuNSkgKyAoTWF0aC5yYW5kb20oKSAqIG9wdHMuc3RhcnRWZWxvY2l0eSksXG4gICAgICBhbmdsZTJEOiAtcmFkQW5nbGUgKyAoKDAuNSAqIHJhZFNwcmVhZCkgLSAoTWF0aC5yYW5kb20oKSAqIHJhZFNwcmVhZCkpLFxuICAgICAgdGlsdEFuZ2xlOiAoTWF0aC5yYW5kb20oKSAqICgwLjc1IC0gMC4yNSkgKyAwLjI1KSAqIE1hdGguUEksXG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIHNoYXBlOiBvcHRzLnNoYXBlLFxuICAgICAgdGljazogMCxcbiAgICAgIHRvdGFsVGlja3M6IG9wdHMudGlja3MsXG4gICAgICBkZWNheTogb3B0cy5kZWNheSxcbiAgICAgIGRyaWZ0OiBvcHRzLmRyaWZ0LFxuICAgICAgcmFuZG9tOiBNYXRoLnJhbmRvbSgpICsgMixcbiAgICAgIHRpbHRTaW46IDAsXG4gICAgICB0aWx0Q29zOiAwLFxuICAgICAgd29iYmxlWDogMCxcbiAgICAgIHdvYmJsZVk6IDAsXG4gICAgICBncmF2aXR5OiBvcHRzLmdyYXZpdHkgKiAzLFxuICAgICAgb3ZhbFNjYWxhcjogMC42LFxuICAgICAgc2NhbGFyOiBvcHRzLnNjYWxhclxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGZXR0aShjb250ZXh0LCBmZXR0aSkge1xuICAgIGZldHRpLnggKz0gTWF0aC5jb3MoZmV0dGkuYW5nbGUyRCkgKiBmZXR0aS52ZWxvY2l0eSArIGZldHRpLmRyaWZ0O1xuICAgIGZldHRpLnkgKz0gTWF0aC5zaW4oZmV0dGkuYW5nbGUyRCkgKiBmZXR0aS52ZWxvY2l0eSArIGZldHRpLmdyYXZpdHk7XG4gICAgZmV0dGkud29iYmxlICs9IGZldHRpLndvYmJsZVNwZWVkO1xuICAgIGZldHRpLnZlbG9jaXR5ICo9IGZldHRpLmRlY2F5O1xuICAgIGZldHRpLnRpbHRBbmdsZSArPSAwLjE7XG4gICAgZmV0dGkudGlsdFNpbiA9IE1hdGguc2luKGZldHRpLnRpbHRBbmdsZSk7XG4gICAgZmV0dGkudGlsdENvcyA9IE1hdGguY29zKGZldHRpLnRpbHRBbmdsZSk7XG4gICAgZmV0dGkucmFuZG9tID0gTWF0aC5yYW5kb20oKSArIDI7XG4gICAgZmV0dGkud29iYmxlWCA9IGZldHRpLnggKyAoKDEwICogZmV0dGkuc2NhbGFyKSAqIE1hdGguY29zKGZldHRpLndvYmJsZSkpO1xuICAgIGZldHRpLndvYmJsZVkgPSBmZXR0aS55ICsgKCgxMCAqIGZldHRpLnNjYWxhcikgKiBNYXRoLnNpbihmZXR0aS53b2JibGUpKTtcblxuICAgIHZhciBwcm9ncmVzcyA9IChmZXR0aS50aWNrKyspIC8gZmV0dGkudG90YWxUaWNrcztcblxuICAgIHZhciB4MSA9IGZldHRpLnggKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdENvcyk7XG4gICAgdmFyIHkxID0gZmV0dGkueSArIChmZXR0aS5yYW5kb20gKiBmZXR0aS50aWx0U2luKTtcbiAgICB2YXIgeDIgPSBmZXR0aS53b2JibGVYICsgKGZldHRpLnJhbmRvbSAqIGZldHRpLnRpbHRDb3MpO1xuICAgIHZhciB5MiA9IGZldHRpLndvYmJsZVkgKyAoZmV0dGkucmFuZG9tICogZmV0dGkudGlsdFNpbik7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBmZXR0aS5jb2xvci5yICsgJywgJyArIGZldHRpLmNvbG9yLmcgKyAnLCAnICsgZmV0dGkuY29sb3IuYiArICcsICcgKyAoMSAtIHByb2dyZXNzKSArICcpJztcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgaWYgKGZldHRpLnNoYXBlID09PSAnY2lyY2xlJykge1xuICAgICAgY29udGV4dC5lbGxpcHNlID9cbiAgICAgICAgY29udGV4dC5lbGxpcHNlKGZldHRpLngsIGZldHRpLnksIE1hdGguYWJzKHgyIC0geDEpICogZmV0dGkub3ZhbFNjYWxhciwgTWF0aC5hYnMoeTIgLSB5MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLlBJIC8gMTAgKiBmZXR0aS53b2JibGUsIDAsIDIgKiBNYXRoLlBJKSA6XG4gICAgICAgIGVsbGlwc2UoY29udGV4dCwgZmV0dGkueCwgZmV0dGkueSwgTWF0aC5hYnMoeDIgLSB4MSkgKiBmZXR0aS5vdmFsU2NhbGFyLCBNYXRoLmFicyh5MiAtIHkxKSAqIGZldHRpLm92YWxTY2FsYXIsIE1hdGguUEkgLyAxMCAqIGZldHRpLndvYmJsZSwgMCwgMiAqIE1hdGguUEkpO1xuICAgIH0gZWxzZSBpZiAoZmV0dGkuc2hhcGUgPT09ICdzdGFyJykge1xuICAgICAgdmFyIHJvdCA9IE1hdGguUEkgLyAyICogMztcbiAgICAgIHZhciBpbm5lclJhZGl1cyA9IDQgKiBmZXR0aS5zY2FsYXI7XG4gICAgICB2YXIgb3V0ZXJSYWRpdXMgPSA4ICogZmV0dGkuc2NhbGFyO1xuICAgICAgdmFyIHggPSBmZXR0aS54O1xuICAgICAgdmFyIHkgPSBmZXR0aS55O1xuICAgICAgdmFyIHNwaWtlcyA9IDU7XG4gICAgICB2YXIgc3RlcCA9IE1hdGguUEkgLyBzcGlrZXM7XG5cbiAgICAgIHdoaWxlIChzcGlrZXMtLSkge1xuICAgICAgICB4ID0gZmV0dGkueCArIE1hdGguY29zKHJvdCkgKiBvdXRlclJhZGl1cztcbiAgICAgICAgeSA9IGZldHRpLnkgKyBNYXRoLnNpbihyb3QpICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICByb3QgKz0gc3RlcDtcblxuICAgICAgICB4ID0gZmV0dGkueCArIE1hdGguY29zKHJvdCkgKiBpbm5lclJhZGl1cztcbiAgICAgICAgeSA9IGZldHRpLnkgKyBNYXRoLnNpbihyb3QpICogaW5uZXJSYWRpdXM7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgICByb3QgKz0gc3RlcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5tb3ZlVG8oTWF0aC5mbG9vcihmZXR0aS54KSwgTWF0aC5mbG9vcihmZXR0aS55KSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKGZldHRpLndvYmJsZVgpLCBNYXRoLmZsb29yKHkxKSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmZsb29yKHgyKSwgTWF0aC5mbG9vcih5MikpO1xuICAgICAgY29udGV4dC5saW5lVG8oTWF0aC5mbG9vcih4MSksIE1hdGguZmxvb3IoZmV0dGkud29iYmxlWSkpO1xuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG5cbiAgICByZXR1cm4gZmV0dGkudGljayA8IGZldHRpLnRvdGFsVGlja3M7XG4gIH1cblxuICBmdW5jdGlvbiBhbmltYXRlKGNhbnZhcywgZmV0dGlzLCByZXNpemVyLCBzaXplLCBkb25lKSB7XG4gICAgdmFyIGFuaW1hdGluZ0ZldHRpcyA9IGZldHRpcy5zbGljZSgpO1xuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGFuaW1hdGlvbkZyYW1lO1xuICAgIHZhciBkZXN0cm95O1xuXG4gICAgdmFyIHByb20gPSBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBmdW5jdGlvbiBvbkRvbmUoKSB7XG4gICAgICAgIGFuaW1hdGlvbkZyYW1lID0gZGVzdHJveSA9IG51bGw7XG5cbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmIChpc1dvcmtlciAmJiAhKHNpemUud2lkdGggPT09IHdvcmtlclNpemUud2lkdGggJiYgc2l6ZS5oZWlnaHQgPT09IHdvcmtlclNpemUuaGVpZ2h0KSkge1xuICAgICAgICAgIHNpemUud2lkdGggPSBjYW52YXMud2lkdGggPSB3b3JrZXJTaXplLndpZHRoO1xuICAgICAgICAgIHNpemUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHdvcmtlclNpemUuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzaXplLndpZHRoICYmICFzaXplLmhlaWdodCkge1xuICAgICAgICAgIHJlc2l6ZXIoY2FudmFzKTtcbiAgICAgICAgICBzaXplLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgIHNpemUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblxuICAgICAgICBhbmltYXRpbmdGZXR0aXMgPSBhbmltYXRpbmdGZXR0aXMuZmlsdGVyKGZ1bmN0aW9uIChmZXR0aSkge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVGZXR0aShjb250ZXh0LCBmZXR0aSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhbmltYXRpbmdGZXR0aXMubGVuZ3RoKSB7XG4gICAgICAgICAgYW5pbWF0aW9uRnJhbWUgPSByYWYuZnJhbWUodXBkYXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbmltYXRpb25GcmFtZSA9IHJhZi5mcmFtZSh1cGRhdGUpO1xuICAgICAgZGVzdHJveSA9IG9uRG9uZTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZGRGZXR0aXM6IGZ1bmN0aW9uIChmZXR0aXMpIHtcbiAgICAgICAgYW5pbWF0aW5nRmV0dGlzID0gYW5pbWF0aW5nRmV0dGlzLmNvbmNhdChmZXR0aXMpO1xuXG4gICAgICAgIHJldHVybiBwcm9tO1xuICAgICAgfSxcbiAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgcHJvbWlzZTogcHJvbSxcbiAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgIHJhZi5jYW5jZWwoYW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlc3Ryb3kpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmV0dGlDYW5ub24oY2FudmFzLCBnbG9iYWxPcHRzKSB7XG4gICAgdmFyIGlzTGliQ2FudmFzID0gIWNhbnZhcztcbiAgICB2YXIgYWxsb3dSZXNpemUgPSAhIXByb3AoZ2xvYmFsT3B0cyB8fCB7fSwgJ3Jlc2l6ZScpO1xuICAgIHZhciBnbG9iYWxEaXNhYmxlRm9yUmVkdWNlZE1vdGlvbiA9IHByb3AoZ2xvYmFsT3B0cywgJ2Rpc2FibGVGb3JSZWR1Y2VkTW90aW9uJywgQm9vbGVhbik7XG4gICAgdmFyIHNob3VsZFVzZVdvcmtlciA9IGNhblVzZVdvcmtlciAmJiAhIXByb3AoZ2xvYmFsT3B0cyB8fCB7fSwgJ3VzZVdvcmtlcicpO1xuICAgIHZhciB3b3JrZXIgPSBzaG91bGRVc2VXb3JrZXIgPyBnZXRXb3JrZXIoKSA6IG51bGw7XG4gICAgdmFyIHJlc2l6ZXIgPSBpc0xpYkNhbnZhcyA/IHNldENhbnZhc1dpbmRvd1NpemUgOiBzZXRDYW52YXNSZWN0U2l6ZTtcbiAgICB2YXIgaW5pdGlhbGl6ZWQgPSAoY2FudmFzICYmIHdvcmtlcikgPyAhIWNhbnZhcy5fX2NvbmZldHRpX2luaXRpYWxpemVkIDogZmFsc2U7XG4gICAgdmFyIHByZWZlckxlc3NNb3Rpb24gPSB0eXBlb2YgbWF0Y2hNZWRpYSA9PT0gJ2Z1bmN0aW9uJyAmJiBtYXRjaE1lZGlhKCcocHJlZmVycy1yZWR1Y2VkLW1vdGlvbiknKS5tYXRjaGVzO1xuICAgIHZhciBhbmltYXRpb25PYmo7XG5cbiAgICBmdW5jdGlvbiBmaXJlTG9jYWwob3B0aW9ucywgc2l6ZSwgZG9uZSkge1xuICAgICAgdmFyIHBhcnRpY2xlQ291bnQgPSBwcm9wKG9wdGlvbnMsICdwYXJ0aWNsZUNvdW50Jywgb25seVBvc2l0aXZlSW50KTtcbiAgICAgIHZhciBhbmdsZSA9IHByb3Aob3B0aW9ucywgJ2FuZ2xlJywgTnVtYmVyKTtcbiAgICAgIHZhciBzcHJlYWQgPSBwcm9wKG9wdGlvbnMsICdzcHJlYWQnLCBOdW1iZXIpO1xuICAgICAgdmFyIHN0YXJ0VmVsb2NpdHkgPSBwcm9wKG9wdGlvbnMsICdzdGFydFZlbG9jaXR5JywgTnVtYmVyKTtcbiAgICAgIHZhciBkZWNheSA9IHByb3Aob3B0aW9ucywgJ2RlY2F5JywgTnVtYmVyKTtcbiAgICAgIHZhciBncmF2aXR5ID0gcHJvcChvcHRpb25zLCAnZ3Jhdml0eScsIE51bWJlcik7XG4gICAgICB2YXIgZHJpZnQgPSBwcm9wKG9wdGlvbnMsICdkcmlmdCcsIE51bWJlcik7XG4gICAgICB2YXIgY29sb3JzID0gcHJvcChvcHRpb25zLCAnY29sb3JzJywgY29sb3JzVG9SZ2IpO1xuICAgICAgdmFyIHRpY2tzID0gcHJvcChvcHRpb25zLCAndGlja3MnLCBOdW1iZXIpO1xuICAgICAgdmFyIHNoYXBlcyA9IHByb3Aob3B0aW9ucywgJ3NoYXBlcycpO1xuICAgICAgdmFyIHNjYWxhciA9IHByb3Aob3B0aW9ucywgJ3NjYWxhcicpO1xuICAgICAgdmFyIG9yaWdpbiA9IGdldE9yaWdpbihvcHRpb25zKTtcblxuICAgICAgdmFyIHRlbXAgPSBwYXJ0aWNsZUNvdW50O1xuICAgICAgdmFyIGZldHRpcyA9IFtdO1xuXG4gICAgICB2YXIgc3RhcnRYID0gY2FudmFzLndpZHRoICogb3JpZ2luLng7XG4gICAgICB2YXIgc3RhcnRZID0gY2FudmFzLmhlaWdodCAqIG9yaWdpbi55O1xuXG4gICAgICB3aGlsZSAodGVtcC0tKSB7XG4gICAgICAgIGZldHRpcy5wdXNoKFxuICAgICAgICAgIHJhbmRvbVBoeXNpY3Moe1xuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgeTogc3RhcnRZLFxuICAgICAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICAgICAgc3ByZWFkOiBzcHJlYWQsXG4gICAgICAgICAgICBzdGFydFZlbG9jaXR5OiBzdGFydFZlbG9jaXR5LFxuICAgICAgICAgICAgY29sb3I6IGNvbG9yc1t0ZW1wICUgY29sb3JzLmxlbmd0aF0sXG4gICAgICAgICAgICBzaGFwZTogc2hhcGVzW3JhbmRvbUludCgwLCBzaGFwZXMubGVuZ3RoKV0sXG4gICAgICAgICAgICB0aWNrczogdGlja3MsXG4gICAgICAgICAgICBkZWNheTogZGVjYXksXG4gICAgICAgICAgICBncmF2aXR5OiBncmF2aXR5LFxuICAgICAgICAgICAgZHJpZnQ6IGRyaWZ0LFxuICAgICAgICAgICAgc2NhbGFyOiBzY2FsYXJcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgcHJldmlvdXMgY2FudmFzIGFscmVhZHkgYW5pbWF0aW5nLFxuICAgICAgLy8gYWRkIHRvIGl0XG4gICAgICBpZiAoYW5pbWF0aW9uT2JqKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25PYmouYWRkRmV0dGlzKGZldHRpcyk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbk9iaiA9IGFuaW1hdGUoY2FudmFzLCBmZXR0aXMsIHJlc2l6ZXIsIHNpemUgLCBkb25lKTtcblxuICAgICAgcmV0dXJuIGFuaW1hdGlvbk9iai5wcm9taXNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpcmUob3B0aW9ucykge1xuICAgICAgdmFyIGRpc2FibGVGb3JSZWR1Y2VkTW90aW9uID0gZ2xvYmFsRGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gfHwgcHJvcChvcHRpb25zLCAnZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24nLCBCb29sZWFuKTtcbiAgICAgIHZhciB6SW5kZXggPSBwcm9wKG9wdGlvbnMsICd6SW5kZXgnLCBOdW1iZXIpO1xuXG4gICAgICBpZiAoZGlzYWJsZUZvclJlZHVjZWRNb3Rpb24gJiYgcHJlZmVyTGVzc01vdGlvbikge1xuICAgICAgICByZXR1cm4gcHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0xpYkNhbnZhcyAmJiBhbmltYXRpb25PYmopIHtcbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIGNhbnZhcyBmcm9tIGluLXByb2dyZXNzIGFuaW1hdGlvblxuICAgICAgICBjYW52YXMgPSBhbmltYXRpb25PYmouY2FudmFzO1xuICAgICAgfSBlbHNlIGlmIChpc0xpYkNhbnZhcyAmJiAhY2FudmFzKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbmQgaW5pdGlhbGl6ZSBhIG5ldyBjYW52YXNcbiAgICAgICAgY2FudmFzID0gZ2V0Q2FudmFzKHpJbmRleCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFsbG93UmVzaXplICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzaXplIG9mIGEgdXNlci1zdXBwbGllZCBjYW52YXNcbiAgICAgICAgcmVzaXplcihjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZSA9IHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICBpZiAod29ya2VyICYmICFpbml0aWFsaXplZCkge1xuICAgICAgICB3b3JrZXIuaW5pdChjYW52YXMpO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgY2FudmFzLl9fY29uZmV0dGlfaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgIC8vIFRPRE8gdGhpcyByZWFsbHkgc2hvdWxkbid0IGJlIGltbWVkaWF0ZSwgYmVjYXVzZSBpdCBpcyBleHBlbnNpdmVcbiAgICAgICAgICB2YXIgb2JqID0ge1xuICAgICAgICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghaXNMaWJDYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJlc2l6ZXIob2JqKTtcblxuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgICAgd2lkdGg6IG9iai53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBvYmouaGVpZ2h0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgcXVlcnkgdGhlIHNpemUgaGVyZSwgc2luY2UgdGhpc1xuICAgICAgICAvLyBjYW4gZXhlY3V0ZSBmcmVxdWVudGx5IGFuZCByYXBpZGx5XG4gICAgICAgIHNpemUud2lkdGggPSBzaXplLmhlaWdodCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICAgIGFuaW1hdGlvbk9iaiA9IG51bGw7XG5cbiAgICAgICAgaWYgKGFsbG93UmVzaXplKSB7XG4gICAgICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0xpYkNhbnZhcyAmJiBjYW52YXMpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgY2FudmFzID0gbnVsbDtcbiAgICAgICAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd1Jlc2l6ZSkge1xuICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICByZXR1cm4gd29ya2VyLmZpcmUob3B0aW9ucywgc2l6ZSwgZG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXJlTG9jYWwob3B0aW9ucywgc2l6ZSwgZG9uZSk7XG4gICAgfVxuXG4gICAgZmlyZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgd29ya2VyLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRpb25PYmopIHtcbiAgICAgICAgYW5pbWF0aW9uT2JqLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmaXJlO1xuICB9XG5cbiAgLy8gTWFrZSBkZWZhdWx0IGV4cG9ydCBsYXp5IHRvIGRlZmVyIHdvcmtlciBjcmVhdGlvbiB1bnRpbCBjYWxsZWQuXG4gIHZhciBkZWZhdWx0RmlyZTtcbiAgZnVuY3Rpb24gZ2V0RGVmYXVsdEZpcmUoKSB7XG4gICAgaWYgKCFkZWZhdWx0RmlyZSkge1xuICAgICAgZGVmYXVsdEZpcmUgPSBjb25mZXR0aUNhbm5vbihudWxsLCB7IHVzZVdvcmtlcjogdHJ1ZSwgcmVzaXplOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZpcmU7XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnZXREZWZhdWx0RmlyZSgpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIG1vZHVsZS5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZ2V0RGVmYXVsdEZpcmUoKS5yZXNldCgpO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cy5jcmVhdGUgPSBjb25mZXR0aUNhbm5vbjtcbn0oKGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIHJldHVybiB0aGlzIHx8IHt9O1xufSkoKSwgbW9kdWxlLCBmYWxzZSkpO1xuXG4vLyBlbmQgc291cmNlIGNvbnRlbnRcblxuZXhwb3J0IGRlZmF1bHQgbW9kdWxlLmV4cG9ydHM7XG5leHBvcnQgdmFyIGNyZWF0ZSA9IG1vZHVsZS5leHBvcnRzLmNyZWF0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/canvas-confetti/dist/confetti.module.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	
/******/ })()
;