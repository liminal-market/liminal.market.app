/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

        /***/
        "./node_modules/ansi-html-community/index.js":
        /*!***************************************************!*\
          !*** ./node_modules/ansi-html-community/index.js ***!
          \***************************************************/
        /***/ ((module) => {

            "use strict";
            eval("\n\nmodule.exports = ansiHTML\n\n// Reference to https://github.com/sindresorhus/ansi-regex\nvar _regANSI = /(?:(?:\\u001b\\[)|\\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\\u001b[A-M]/\n\nvar _defColors = {\n  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]\n  black: '000',\n  red: 'ff0000',\n  green: '209805',\n  yellow: 'e8bf03',\n  blue: '0000ff',\n  magenta: 'ff00ff',\n  cyan: '00ffee',\n  lightgrey: 'f0f0f0',\n  darkgrey: '888'\n}\nvar _styles = {\n  30: 'black',\n  31: 'red',\n  32: 'green',\n  33: 'yellow',\n  34: 'blue',\n  35: 'magenta',\n  36: 'cyan',\n  37: 'lightgrey'\n}\nvar _openTags = {\n  '1': 'font-weight:bold', // bold\n  '2': 'opacity:0.5', // dim\n  '3': '<i>', // italic\n  '4': '<u>', // underscore\n  '8': 'display:none', // hidden\n  '9': '<del>' // delete\n}\nvar _closeTags = {\n  '23': '</i>', // reset italic\n  '24': '</u>', // reset underscore\n  '29': '</del>' // reset delete\n}\n\n;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {\n  _closeTags[n] = '</span>'\n})\n\n/**\n * Converts text with ANSI color codes to HTML markup.\n * @param {String} text\n * @returns {*}\n */\nfunction ansiHTML (text) {\n  // Returns the text if the string has no ANSI escape code.\n  if (!_regANSI.test(text)) {\n    return text\n  }\n\n  // Cache opened sequence.\n  var ansiCodes = []\n  // Replace with markup.\n  var ret = text.replace(/\\033\\[(\\d+)m/g, function (match, seq) {\n    var ot = _openTags[seq]\n    if (ot) {\n      // If current sequence has been opened, close it.\n      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast\n        ansiCodes.pop()\n        return '</span>'\n      }\n      // Open tag.\n      ansiCodes.push(seq)\n      return ot[0] === '<' ? ot : '<span style=\"' + ot + ';\">'\n    }\n\n    var ct = _closeTags[seq]\n    if (ct) {\n      // Pop sequence\n      ansiCodes.pop()\n      return ct\n    }\n    return ''\n  })\n\n  // Make sure tags are closed.\n  var l = ansiCodes.length\n  ;(l > 0) && (ret += Array(l + 1).join('</span>'))\n\n  return ret\n}\n\n/**\n * Customize colors.\n * @param {Object} colors reference to _defColors\n */\nansiHTML.setColors = function (colors) {\n  if (typeof colors !== 'object') {\n    throw new Error('`colors` parameter must be an Object.')\n  }\n\n  var _finalColors = {}\n  for (var key in _defColors) {\n    var hex = colors.hasOwnProperty(key) ? colors[key] : null\n    if (!hex) {\n      _finalColors[key] = _defColors[key]\n      continue\n    }\n    if ('reset' === key) {\n      if (typeof hex === 'string') {\n        hex = [hex]\n      }\n      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {\n        return typeof h !== 'string'\n      })) {\n        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')\n      }\n      var defHexColor = _defColors[key]\n      if (!hex[0]) {\n        hex[0] = defHexColor[0]\n      }\n      if (hex.length === 1 || !hex[1]) {\n        hex = [hex[0]]\n        hex.push(defHexColor[1])\n      }\n\n      hex = hex.slice(0, 2)\n    } else if (typeof hex !== 'string') {\n      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')\n    }\n    _finalColors[key] = hex\n  }\n  _setTags(_finalColors)\n}\n\n/**\n * Reset colors.\n */\nansiHTML.reset = function () {\n  _setTags(_defColors)\n}\n\n/**\n * Expose tags, including open and close.\n * @type {Object}\n */\nansiHTML.tags = {}\n\nif (Object.defineProperty) {\n  Object.defineProperty(ansiHTML.tags, 'open', {\n    get: function () { return _openTags }\n  })\n  Object.defineProperty(ansiHTML.tags, 'close', {\n    get: function () { return _closeTags }\n  })\n} else {\n  ansiHTML.tags.open = _openTags\n  ansiHTML.tags.close = _closeTags\n}\n\nfunction _setTags (colors) {\n  // reset all\n  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]\n  // inverse\n  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]\n  // dark grey\n  _openTags['90'] = 'color:#' + colors.darkgrey\n\n  for (var code in _styles) {\n    var color = _styles[code]\n    var oriColor = colors[color] || '000'\n    _openTags[code] = 'color:#' + oriColor\n    code = parseInt(code)\n    _openTags[(code + 10).toString()] = 'background:#' + oriColor\n  }\n}\n\nansiHTML.reset()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sLWNvbW11bml0eS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBLG1EQUFtRCxJQUFJLFNBQVMsTUFBTSxJQUFJOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNIO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVSwrQkFBK0I7QUFDaEY7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvYW5zaS1odG1sLWNvbW11bml0eS9pbmRleC5qcz9kZjA2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MXG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL1xuXG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLCAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59XG52YXIgX29wZW5UYWdzID0ge1xuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxuICAnMic6ICdvcGFjaXR5OjAuNScsIC8vIGRpbVxuICAnMyc6ICc8aT4nLCAvLyBpdGFsaWNcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxuICAnOCc6ICdkaXNwbGF5Om5vbmUnLCAvLyBoaWRkZW5cbiAgJzknOiAnPGRlbD4nIC8vIGRlbGV0ZVxufVxudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JywgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn1cblxuO1swLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPidcbn0pXG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MICh0ZXh0KSB7XG4gIC8vIFJldHVybnMgdGhlIHRleHQgaWYgdGhlIHN0cmluZyBoYXMgbm8gQU5TSSBlc2NhcGUgY29kZS5cbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ansi-html-community/index.js\n");

            /***/
        }),

        /***/
        "./node_modules/bech32/index.js":
        /*!**************************************!*\
          !*** ./node_modules/bech32/index.js ***!
          \**************************************/
        /***/ ((module) => {

            "use strict";
            eval("\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmVjaDMyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2JlY2gzMi9pbmRleC5qcz9iZjJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xudmFyIEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJ1xuXG4vLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbnZhciBBTFBIQUJFVF9NQVAgPSB7fVxuZm9yICh2YXIgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdCh6KVxuXG4gIGlmIChBTFBIQUJFVF9NQVBbeF0gIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKVxuICBBTFBIQUJFVF9NQVBbeF0gPSB6XG59XG5cbmZ1bmN0aW9uIHBvbHltb2RTdGVwIChwcmUpIHtcbiAgdmFyIGIgPSBwcmUgPj4gMjVcbiAgcmV0dXJuICgocHJlICYgMHgxRkZGRkZGKSA8PCA1KSBeXG4gICAgKC0oKGIgPj4gMCkgJiAxKSAmIDB4M2I2YTU3YjIpIF5cbiAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgKC0oKGIgPj4gMykgJiAxKSAmIDB4M2Q0MjMzZGQpIF5cbiAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMylcbn1cblxuZnVuY3Rpb24gcHJlZml4Q2hrIChwcmVmaXgpIHtcbiAgdmFyIGNoayA9IDFcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KSByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknXG5cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKGMgPj4gNSlcbiAgfVxuICBjaGsgPSBwb2x5bW9kU3RlcChjaGspXG5cbiAgZm9yIChpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7ICsraSkge1xuICAgIHZhciB2ID0gcHJlZml4LmNoYXJDb2RlQXQoaSlcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKVxuICB9XG4gIHJldHVybiBjaGtcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuICBMSU1JVCA9IExJTUlUIHx8IDkwXG4gIGlmICgocHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGgpID4gTElNSVQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0JylcblxuICBwcmVmaXggPSBwcmVmaXgudG9Mb3dlckNhc2UoKVxuXG4gIC8vIGRldGVybWluZSBjaGsgbW9kXG4gIHZhciBjaGsgPSBwcmVmaXhDaGsocHJlZml4KVxuICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihjaGspXG5cbiAgdmFyIHJlc3VsdCA9IHByZWZpeCArICcxJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHggPSB3b3Jkc1tpXVxuICAgIGlmICgoeCA+PiA1KSAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpXG5cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4geFxuICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQoeClcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspXG4gIH1cbiAgY2hrIF49IDFcblxuICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgdmFyIHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZlxuICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodilcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gX19kZWNvZGUgKHN0ciwgTElNSVQpIHtcbiAgTElNSVQgPSBMSU1JVCB8fCA5MFxuICBpZiAoc3RyLmxlbmd0aCA8IDgpIHJldHVybiBzdHIgKyAnIHRvbyBzaG9ydCdcbiAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVCkgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCdcblxuICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gIHZhciBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKClcbiAgdmFyIHVwcGVyZWQgPSBzdHIudG9VcHBlckNhc2UoKVxuICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZCkgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyXG4gIHN0ciA9IGxvd2VyZWRcblxuICB2YXIgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKVxuICBpZiAoc3BsaXQgPT09IC0xKSByZXR1cm4gJ05vIHNlcGFyYXRvciBjaGFyYWN0ZXIgZm9yICcgKyBzdHJcbiAgaWYgKHNwbGl0ID09PSAwKSByZXR1cm4gJ01pc3NpbmcgcHJlZml4IGZvciAnICsgc3RyXG5cbiAgdmFyIHByZWZpeCA9IHN0ci5zbGljZSgwLCBzcGxpdClcbiAgdmFyIHdvcmRDaGFycyA9IHN0ci5zbGljZShzcGxpdCArIDEpXG4gIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNikgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCdcblxuICB2YXIgY2hrID0gcHJlZml4Q2hrKHByZWZpeClcbiAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKSByZXR1cm4gY2hrXG5cbiAgdmFyIHdvcmRzID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IHdvcmRDaGFycy5jaGFyQXQoaSlcbiAgICB2YXIgdiA9IEFMUEhBQkVUX01BUFtjXVxuICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGNcbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdlxuXG4gICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cbiAgICBpZiAoaSArIDYgPj0gd29yZENoYXJzLmxlbmd0aCkgY29udGludWVcbiAgICB3b3Jkcy5wdXNoKHYpXG4gIH1cblxuICBpZiAoY2hrICE9PSAxKSByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHJcbiAgcmV0dXJuIHsgcHJlZml4OiBwcmVmaXgsIHdvcmRzOiB3b3JkcyB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoKSB7XG4gIHZhciByZXMgPSBfX2RlY29kZS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JykgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZWNvZGUgKHN0cikge1xuICB2YXIgcmVzID0gX19kZWNvZGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpIHJldHVybiByZXNcblxuICB0aHJvdyBuZXcgRXJyb3IocmVzKVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0IChkYXRhLCBpbkJpdHMsIG91dEJpdHMsIHBhZCkge1xuICB2YXIgdmFsdWUgPSAwXG4gIHZhciBiaXRzID0gMFxuICB2YXIgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMVxuXG4gIHZhciByZXN1bHQgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gaW5CaXRzXG5cbiAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG4gICAgICBiaXRzIC09IG91dEJpdHNcbiAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA+PiBiaXRzKSAmIG1heFYpXG4gICAgfVxuICB9XG5cbiAgaWYgKHBhZCkge1xuICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VilcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJpdHMgPj0gaW5CaXRzKSByZXR1cm4gJ0V4Y2VzcyBwYWRkaW5nJ1xuICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKSByZXR1cm4gJ05vbi16ZXJvIHBhZGRpbmcnXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHRvV29yZHNVbnNhZmUgKGJ5dGVzKSB7XG4gIHZhciByZXMgPSBjb252ZXJ0KGJ5dGVzLCA4LCA1LCB0cnVlKVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHRvV29yZHMgKGJ5dGVzKSB7XG4gIHZhciByZXMgPSBjb252ZXJ0KGJ5dGVzLCA4LCA1LCB0cnVlKVxuICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSByZXR1cm4gcmVzXG5cbiAgdGhyb3cgbmV3IEVycm9yKHJlcylcbn1cblxuZnVuY3Rpb24gZnJvbVdvcmRzVW5zYWZlICh3b3Jkcykge1xuICB2YXIgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZnJvbVdvcmRzICh3b3Jkcykge1xuICB2YXIgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblxuICB0aHJvdyBuZXcgRXJyb3IocmVzKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gIGRlY29kZTogZGVjb2RlLFxuICBlbmNvZGU6IGVuY29kZSxcbiAgdG9Xb3Jkc1Vuc2FmZTogdG9Xb3Jkc1Vuc2FmZSxcbiAgdG9Xb3JkczogdG9Xb3JkcyxcbiAgZnJvbVdvcmRzVW5zYWZlOiBmcm9tV29yZHNVbnNhZmUsXG4gIGZyb21Xb3JkczogZnJvbVdvcmRzXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bech32/index.js\n");

/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"?8131\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [ number & 0x3ffffff ];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [ 0 ];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this.strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // 'A' - 'F'\n    if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    // '0' - '9'\n    } else {\n      return (c - 48) & 0xf;\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this.strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        r += c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        r += c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        r += c;\n      }\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [ 0 ];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this.strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype.strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  BN.prototype.inspect = function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  };\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16);\n  };\n\n  BN.prototype.toBuffer = function toBuffer (endian, length) {\n    assert(typeof Buffer !== 'undefined');\n    return this.toArrayLike(Buffer, endian, length);\n  };\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    this.strip();\n    var littleEndian = endian === 'le';\n    var res = new ArrayType(reqLength);\n\n    var b, i;\n    var q = this.clone();\n    if (!littleEndian) {\n      // Assume big-endian\n      for (i = 0; i < reqLength - byteLength; i++) {\n        res[i] = 0;\n      }\n\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[reqLength - i - 1] = b;\n      }\n    } else {\n      for (i = 0; !q.isZero(); i++) {\n        b = q.andln(0xff);\n        q.iushrn(8);\n\n        res[i] = b;\n      }\n\n      for (; i < reqLength; i++) {\n        res[i] = 0;\n      }\n    }\n\n    return res;\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this.strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this.strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this.strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this.strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out.strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    var fftm = new FFTM();\n    return fftm.mulp(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out.strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this.strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) < num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this.strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this.strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q.strip();\n    }\n    a.strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modn = function modn (num) {\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return acc;\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    return this.strip();\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this.strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is BN v4 instance\n        r.strip();\n      } else {\n        // r is BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.umod(this.m)._forceRed(this);\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzPzM5OWYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgbnVtYmVyICYgMHgzZmZmZmZmIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPCAweDEwMDAwMDAwMDAwMDAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobnVtYmVyIDwgMHgyMDAwMDAwMDAwMDAwMCk7IC8vIDIgXiA1MyAodW5zYWZlKVxuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZixcbiAgICAgICAgMVxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMztcbiAgICB9XG5cbiAgICBpZiAoZW5kaWFuICE9PSAnbGUnKSByZXR1cm47XG5cbiAgICAvLyBSZXZlcnNlIHRoZSBieXRlc1xuICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uIF9pbml0QXJyYXkgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcbiAgICBhc3NlcnQodHlwZW9mIG51bWJlci5sZW5ndGggPT09ICdudW1iZXInKTtcbiAgICBpZiAobnVtYmVyLmxlbmd0aCA8PSAwKSB7XG4gICAgICB0aGlzLndvcmRzID0gWyAwIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoYyAtIDQ4KSAmIDB4ZjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gciBpcyBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgcmV0dXJuIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bn.js/lib/bn.js\n");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELFlBQVk7QUFDMUU7QUFDQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mYWExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var hash = exports;\n\nhash.utils = __webpack_require__(/*! ./hash/utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nhash.common = __webpack_require__(/*! ./hash/common */ \"./node_modules/hash.js/lib/hash/common.js\");\nhash.sha = __webpack_require__(/*! ./hash/sha */ \"./node_modules/hash.js/lib/hash/sha.js\");\nhash.ripemd = __webpack_require__(/*! ./hash/ripemd */ \"./node_modules/hash.js/lib/hash/ripemd.js\");\nhash.hmac = __webpack_require__(/*! ./hash/hmac */ \"./node_modules/hash.js/lib/hash/hmac.js\");\n\n// Proxy hash functions to the main object\nhash.sha1 = hash.sha.sha1;\nhash.sha256 = hash.sha.sha256;\nhash.sha224 = hash.sha.sha224;\nhash.sha384 = hash.sha.sha384;\nhash.sha512 = hash.sha.sha512;\nhash.ripemd160 = hash.ripemd.ripemd160;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsOERBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGdFQUFlO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQywwREFBWTtBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0VBQWU7QUFDckMsWUFBWSxtQkFBTyxDQUFDLDREQUFhOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2guanM/N2Q5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzaCA9IGV4cG9ydHM7XG5cbmhhc2gudXRpbHMgPSByZXF1aXJlKCcuL2hhc2gvdXRpbHMnKTtcbmhhc2guY29tbW9uID0gcmVxdWlyZSgnLi9oYXNoL2NvbW1vbicpO1xuaGFzaC5zaGEgPSByZXF1aXJlKCcuL2hhc2gvc2hhJyk7XG5oYXNoLnJpcGVtZCA9IHJlcXVpcmUoJy4vaGFzaC9yaXBlbWQnKTtcbmhhc2guaG1hYyA9IHJlcXVpcmUoJy4vaGFzaC9obWFjJyk7XG5cbi8vIFByb3h5IGhhc2ggZnVuY3Rpb25zIHRvIHRoZSBtYWluIG9iamVjdFxuaGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcbmhhc2guc2hhMjU2ID0gaGFzaC5zaGEuc2hhMjU2O1xuaGFzaC5zaGEyMjQgPSBoYXNoLnNoYS5zaGEyMjQ7XG5oYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcbmhhc2guc2hhNTEyID0gaGFzaC5zaGEuc2hhNTEyO1xuaGFzaC5yaXBlbWQxNjAgPSBoYXNoLnJpcGVtZC5yaXBlbWQxNjA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction BlockHash() {\n  this.pending = null;\n  this.pendingTotal = 0;\n  this.blockSize = this.constructor.blockSize;\n  this.outSize = this.constructor.outSize;\n  this.hmacStrength = this.constructor.hmacStrength;\n  this.padLength = this.constructor.padLength / 8;\n  this.endian = 'big';\n\n  this._delta8 = this.blockSize / 8;\n  this._delta32 = this.blockSize / 32;\n}\nexports.BlockHash = BlockHash;\n\nBlockHash.prototype.update = function update(msg, enc) {\n  // Convert message to array, pad it, and join into 32bit blocks\n  msg = utils.toArray(msg, enc);\n  if (!this.pending)\n    this.pending = msg;\n  else\n    this.pending = this.pending.concat(msg);\n  this.pendingTotal += msg.length;\n\n  // Enough data, try updating\n  if (this.pending.length >= this._delta8) {\n    msg = this.pending;\n\n    // Process pending data in blocks\n    var r = msg.length % this._delta8;\n    this.pending = msg.slice(msg.length - r, msg.length);\n    if (this.pending.length === 0)\n      this.pending = null;\n\n    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n    for (var i = 0; i < msg.length; i += this._delta32)\n      this._update(msg, i, i + this._delta32);\n  }\n\n  return this;\n};\n\nBlockHash.prototype.digest = function digest(enc) {\n  this.update(this._pad());\n  assert(this.pending === null);\n\n  return this._digest(enc);\n};\n\nBlockHash.prototype._pad = function pad() {\n  var len = this.pendingTotal;\n  var bytes = this._delta8;\n  var k = bytes - ((len + this.padLength) % bytes);\n  var res = new Array(k + this.padLength);\n  res[0] = 0x80;\n  for (var i = 1; i < k; i++)\n    res[i] = 0;\n\n  // Append length\n  len <<= 3;\n  if (this.endian === 'big') {\n    for (var t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = len & 0xff;\n  } else {\n    res[i++] = len & 0xff;\n    res[i++] = (len >>> 8) & 0xff;\n    res[i++] = (len >>> 16) & 0xff;\n    res[i++] = (len >>> 24) & 0xff;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n    res[i++] = 0;\n\n    for (t = 8; t < this.padLength; t++)\n      res[i++] = 0;\n  }\n\n  return res;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHlEQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyx3RUFBcUI7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcz9lZGM5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/common.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nfunction Hmac(hash, key, enc) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hash, key, enc);\n  this.Hash = hash;\n  this.blockSize = hash.blockSize / 8;\n  this.outSize = hash.outSize / 8;\n  this.inner = null;\n  this.outer = null;\n\n  this._init(utils.toArray(key, enc));\n}\nmodule.exports = Hmac;\n\nHmac.prototype._init = function init(key) {\n  // Shorten key, if needed\n  if (key.length > this.blockSize)\n    key = new this.Hash().update(key).digest();\n  assert(key.length <= this.blockSize);\n\n  // Add padding to key\n  for (var i = key.length; i < this.blockSize; i++)\n    key.push(0);\n\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x36;\n  this.inner = new this.Hash().update(key);\n\n  // 0x36 ^ 0x5c = 0x6a\n  for (i = 0; i < key.length; i++)\n    key[i] ^= 0x6a;\n  this.outer = new this.Hash().update(key);\n};\n\nHmac.prototype.update = function update(msg, enc) {\n  this.inner.update(msg, enc);\n  return this;\n};\n\nHmac.prototype.digest = function digest(enc) {\n  this.outer.update(this.inner.digest());\n  return this.outer.digest(enc);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx5REFBUztBQUM3QixhQUFhLG1CQUFPLENBQUMsd0VBQXFCOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQzs7QUFFQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9obWFjLmpzPzIxMzciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBIbWFjKGhhc2gsIGtleSwgZW5jKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjKSlcbiAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuICB0aGlzLkhhc2ggPSBoYXNoO1xuICB0aGlzLmJsb2NrU2l6ZSA9IGhhc2guYmxvY2tTaXplIC8gODtcbiAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcbiAgdGhpcy5pbm5lciA9IG51bGw7XG4gIHRoaXMub3V0ZXIgPSBudWxsO1xuXG4gIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBIbWFjO1xuXG5IbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG4gIC8vIFNob3J0ZW4ga2V5LCBpZiBuZWVkZWRcbiAgaWYgKGtleS5sZW5ndGggPiB0aGlzLmJsb2NrU2l6ZSlcbiAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG4gIGFzc2VydChrZXkubGVuZ3RoIDw9IHRoaXMuYmxvY2tTaXplKTtcblxuICAvLyBBZGQgcGFkZGluZyB0byBrZXlcbiAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuICAgIGtleS5wdXNoKDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4MzY7XG4gIHRoaXMuaW5uZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG5cbiAgLy8gMHgzNiBeIDB4NWMgPSAweDZhXG4gIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG4gICAga2V5W2ldIF49IDB4NmE7XG4gIHRoaXMub3V0ZXIgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSk7XG59O1xuXG5IbWFjLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBlbmMpIHtcbiAgdGhpcy5pbm5lci51cGRhdGUobXNnLCBlbmMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkhtYWMucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG4gIHJldHVybiB0aGlzLm91dGVyLmRpZ2VzdChlbmMpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/hmac.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_3 = utils.sum32_3;\nvar sum32_4 = utils.sum32_4;\nvar BlockHash = common.BlockHash;\n\nfunction RIPEMD160() {\n  if (!(this instanceof RIPEMD160))\n    return new RIPEMD160();\n\n  BlockHash.call(this);\n\n  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n  this.endian = 'little';\n}\nutils.inherits(RIPEMD160, BlockHash);\nexports.ripemd160 = RIPEMD160;\n\nRIPEMD160.blockSize = 512;\nRIPEMD160.outSize = 160;\nRIPEMD160.hmacStrength = 192;\nRIPEMD160.padLength = 64;\n\nRIPEMD160.prototype._update = function update(msg, start) {\n  var A = this.h[0];\n  var B = this.h[1];\n  var C = this.h[2];\n  var D = this.h[3];\n  var E = this.h[4];\n  var Ah = A;\n  var Bh = B;\n  var Ch = C;\n  var Dh = D;\n  var Eh = E;\n  for (var j = 0; j < 80; j++) {\n    var T = sum32(\n      rotl32(\n        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n        s[j]),\n      E);\n    A = E;\n    E = D;\n    D = rotl32(C, 10);\n    C = B;\n    B = T;\n    T = sum32(\n      rotl32(\n        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n        sh[j]),\n      Eh);\n    Ah = Eh;\n    Eh = Dh;\n    Dh = rotl32(Ch, 10);\n    Ch = Bh;\n    Bh = T;\n  }\n  T = sum32_3(this.h[1], C, Dh);\n  this.h[1] = sum32_3(this.h[2], D, Eh);\n  this.h[2] = sum32_3(this.h[3], E, Ah);\n  this.h[3] = sum32_3(this.h[4], A, Bh);\n  this.h[4] = sum32_3(this.h[0], B, Ch);\n  this.h[0] = T;\n};\n\nRIPEMD160.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'little');\n  else\n    return utils.split32(this.h, 'little');\n};\n\nfunction f(j, x, y, z) {\n  if (j <= 15)\n    return x ^ y ^ z;\n  else if (j <= 31)\n    return (x & y) | ((~x) & z);\n  else if (j <= 47)\n    return (x | (~y)) ^ z;\n  else if (j <= 63)\n    return (x & z) | (y & (~z));\n  else\n    return x ^ (y | (~z));\n}\n\nfunction K(j) {\n  if (j <= 15)\n    return 0x00000000;\n  else if (j <= 31)\n    return 0x5a827999;\n  else if (j <= 47)\n    return 0x6ed9eba1;\n  else if (j <= 63)\n    return 0x8f1bbcdc;\n  else\n    return 0xa953fd4e;\n}\n\nfunction Kh(j) {\n  if (j <= 15)\n    return 0x50a28be6;\n  else if (j <= 31)\n    return 0x5c4dd124;\n  else if (j <= 47)\n    return 0x6d703ef3;\n  else if (j <= 63)\n    return 0x7a6d76e9;\n  else\n    return 0x00000000;\n}\n\nvar r = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\n\nvar rh = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\n\nvar s = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\n\nvar sh = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHlEQUFTO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywyREFBVTs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3JpcGVtZC5qcz9iYjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl8zID0gdXRpbHMuc3VtMzJfMztcbnZhciBzdW0zMl80ID0gdXRpbHMuc3VtMzJfNDtcbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG5mdW5jdGlvbiBSSVBFTUQxNjAoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSSVBFTUQxNjApKVxuICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuZW5kaWFuID0gJ2xpdHRsZSc7XG59XG51dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuUklQRU1EMTYwLmJsb2NrU2l6ZSA9IDUxMjtcblJJUEVNRDE2MC5vdXRTaXplID0gMTYwO1xuUklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5MjtcblJJUEVNRDE2MC5wYWRMZW5ndGggPSA2NDtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIEEgPSB0aGlzLmhbMF07XG4gIHZhciBCID0gdGhpcy5oWzFdO1xuICB2YXIgQyA9IHRoaXMuaFsyXTtcbiAgdmFyIEQgPSB0aGlzLmhbM107XG4gIHZhciBFID0gdGhpcy5oWzRdO1xuICB2YXIgQWggPSBBO1xuICB2YXIgQmggPSBCO1xuICB2YXIgQ2ggPSBDO1xuICB2YXIgRGggPSBEO1xuICB2YXIgRWggPSBFO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDgwOyBqKyspIHtcbiAgICB2YXIgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEEsIGYoaiwgQiwgQywgRCksIG1zZ1tyW2pdICsgc3RhcnRdLCBLKGopKSxcbiAgICAgICAgc1tqXSksXG4gICAgICBFKTtcbiAgICBBID0gRTtcbiAgICBFID0gRDtcbiAgICBEID0gcm90bDMyKEMsIDEwKTtcbiAgICBDID0gQjtcbiAgICBCID0gVDtcbiAgICBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG4gICAgICAgIHNoW2pdKSxcbiAgICAgIEVoKTtcbiAgICBBaCA9IEVoO1xuICAgIEVoID0gRGg7XG4gICAgRGggPSByb3RsMzIoQ2gsIDEwKTtcbiAgICBDaCA9IEJoO1xuICAgIEJoID0gVDtcbiAgfVxuICBUID0gc3VtMzJfMyh0aGlzLmhbMV0sIEMsIERoKTtcbiAgdGhpcy5oWzFdID0gc3VtMzJfMyh0aGlzLmhbMl0sIEQsIEVoKTtcbiAgdGhpcy5oWzJdID0gc3VtMzJfMyh0aGlzLmhbM10sIEUsIEFoKTtcbiAgdGhpcy5oWzNdID0gc3VtMzJfMyh0aGlzLmhbNF0sIEEsIEJoKTtcbiAgdGhpcy5oWzRdID0gc3VtMzJfMyh0aGlzLmhbMF0sIEIsIENoKTtcbiAgdGhpcy5oWzBdID0gVDtcbn07XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdsaXR0bGUnKTtcbn07XG5cbmZ1bmN0aW9uIGYoaiwgeCwgeSwgeikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4geCBeIHkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAoeCAmIHkpIHwgKCh+eCkgJiB6KTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gKHggfCAofnkpKSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuICBlbHNlXG4gICAgcmV0dXJuIHggXiAoeSB8ICh+eikpO1xufVxuXG5mdW5jdGlvbiBLKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWE4Mjc5OTk7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmVkOWViYTE7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4OGYxYmJjZGM7XG4gIGVsc2VcbiAgICByZXR1cm4gMHhhOTUzZmQ0ZTtcbn1cblxuZnVuY3Rpb24gS2goaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHg1MGEyOGJlNjtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YzRkZDEyNDtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZDcwM2VmMztcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg3YTZkNzZlOTtcbiAgZWxzZVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xufVxuXG52YXIgciA9IFtcbiAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbiAgMywgMTAsIDE0LCA0LCA5LCAxNSwgOCwgMSwgMiwgNywgMCwgNiwgMTMsIDExLCA1LCAxMixcbiAgMSwgOSwgMTEsIDEwLCAwLCA4LCAxMiwgNCwgMTMsIDMsIDcsIDE1LCAxNCwgNSwgNiwgMixcbiAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXTtcblxudmFyIHJoID0gW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXG5dO1xuXG52YXIgcyA9IFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZcbl07XG5cbnZhciBzaCA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/ripemd.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nexports.sha1 = __webpack_require__(/*! ./sha/1 */ \"./node_modules/hash.js/lib/hash/sha/1.js\");\nexports.sha224 = __webpack_require__(/*! ./sha/224 */ \"./node_modules/hash.js/lib/hash/sha/224.js\");\nexports.sha256 = __webpack_require__(/*! ./sha/256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\nexports.sha384 = __webpack_require__(/*! ./sha/384 */ \"./node_modules/hash.js/lib/hash/sha/384.js\");\nexports.sha512 = __webpack_require__(/*! ./sha/512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkZBQWlDO0FBQ2pDLG1HQUFxQztBQUNyQyxtR0FBcUM7QUFDckMsbUdBQXFDO0FBQ3JDLG1HQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLmpzPzU5MTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYS8xJyk7XG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhLzIyNCcpO1xuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYS8yNTYnKTtcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEvMzg0Jyk7XG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhLzUxMicpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\n\nvar rotl32 = utils.rotl32;\nvar sum32 = utils.sum32;\nvar sum32_5 = utils.sum32_5;\nvar ft_1 = shaCommon.ft_1;\nvar BlockHash = common.BlockHash;\n\nvar sha1_K = [\n  0x5A827999, 0x6ED9EBA1,\n  0x8F1BBCDC, 0xCA62C1D6\n];\n\nfunction SHA1() {\n  if (!(this instanceof SHA1))\n    return new SHA1();\n\n  BlockHash.call(this);\n  this.h = [\n    0x67452301, 0xefcdab89, 0x98badcfe,\n    0x10325476, 0xc3d2e1f0 ];\n  this.W = new Array(80);\n}\n\nutils.inherits(SHA1, BlockHash);\nmodule.exports = SHA1;\n\nSHA1.blockSize = 512;\nSHA1.outSize = 160;\nSHA1.hmacStrength = 80;\nSHA1.padLength = 64;\n\nSHA1.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n\n  for(; i < W.length; i++)\n    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n\n  for (i = 0; i < W.length; i++) {\n    var s = ~~(i / 20);\n    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);\n    e = d;\n    d = c;\n    c = rotl32(b, 30);\n    b = a;\n    a = t;\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n};\n\nSHA1.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLDREQUFXO0FBQ2hDLGdCQUFnQixtQkFBTyxDQUFDLCtEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixRQUFRO0FBQzFCOztBQUVBLFFBQVEsY0FBYztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8xLmpzPzEzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/1.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar SHA256 = __webpack_require__(/*! ./256 */ \"./node_modules/hash.js/lib/hash/sha/256.js\");\n\nfunction SHA224() {\n  if (!(this instanceof SHA224))\n    return new SHA224();\n\n  SHA256.call(this);\n  this.h = [\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];\n}\nutils.inherits(SHA224, SHA256);\nmodule.exports = SHA224;\n\nSHA224.blockSize = 512;\nSHA224.outSize = 224;\nSHA224.hmacStrength = 192;\nSHA224.padLength = 64;\n\nSHA224.prototype._digest = function digest(enc) {\n  // Just truncate output\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 7), 'big');\n  else\n    return utils.split32(this.h.slice(0, 7), 'big');\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjI0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMseURBQU87O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzIyNC5qcz8wN2YyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBTSEEyNTYgPSByZXF1aXJlKCcuLzI1NicpO1xuXG5mdW5jdGlvbiBTSEEyMjQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyMjQpKVxuICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cbiAgU0hBMjU2LmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTIyNCwgU0hBMjU2KTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjI0O1xuXG5TSEEyMjQuYmxvY2tTaXplID0gNTEyO1xuU0hBMjI0Lm91dFNpemUgPSAyMjQ7XG5TSEEyMjQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjI0LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyMjQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIC8vIEp1c3QgdHJ1bmNhdGUgb3V0cHV0XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/224.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar shaCommon = __webpack_require__(/*! ./common */ \"./node_modules/hash.js/lib/hash/sha/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar sum32 = utils.sum32;\nvar sum32_4 = utils.sum32_4;\nvar sum32_5 = utils.sum32_5;\nvar ch32 = shaCommon.ch32;\nvar maj32 = shaCommon.maj32;\nvar s0_256 = shaCommon.s0_256;\nvar s1_256 = shaCommon.s1_256;\nvar g0_256 = shaCommon.g0_256;\nvar g1_256 = shaCommon.g1_256;\n\nvar BlockHash = common.BlockHash;\n\nvar sha256_K = [\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n];\n\nfunction SHA256() {\n  if (!(this instanceof SHA256))\n    return new SHA256();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n  ];\n  this.k = sha256_K;\n  this.W = new Array(64);\n}\nutils.inherits(SHA256, BlockHash);\nmodule.exports = SHA256;\n\nSHA256.blockSize = 512;\nSHA256.outSize = 256;\nSHA256.hmacStrength = 192;\nSHA256.padLength = 64;\n\nSHA256.prototype._update = function _update(msg, start) {\n  var W = this.W;\n\n  for (var i = 0; i < 16; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i++)\n    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);\n\n  var a = this.h[0];\n  var b = this.h[1];\n  var c = this.h[2];\n  var d = this.h[3];\n  var e = this.h[4];\n  var f = this.h[5];\n  var g = this.h[6];\n  var h = this.h[7];\n\n  assert(this.k.length === W.length);\n  for (i = 0; i < W.length; i++) {\n    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);\n    var T2 = sum32(s0_256(a), maj32(a, b, c));\n    h = g;\n    g = f;\n    f = e;\n    e = sum32(d, T1);\n    d = c;\n    c = b;\n    b = a;\n    a = sum32(T1, T2);\n  }\n\n  this.h[0] = sum32(this.h[0], a);\n  this.h[1] = sum32(this.h[1], b);\n  this.h[2] = sum32(this.h[2], c);\n  this.h[3] = sum32(this.h[3], d);\n  this.h[4] = sum32(this.h[4], e);\n  this.h[5] = sum32(this.h[5], f);\n  this.h[6] = sum32(this.h[6], g);\n  this.h[7] = sum32(this.h[7], h);\n};\n\nSHA256.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjU2LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsNERBQVc7QUFDaEMsZ0JBQWdCLG1CQUFPLENBQUMsK0RBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLHdFQUFxQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLFNBQVMsY0FBYztBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzI1Ni5qcz82ZWVkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgY2gzMiA9IHNoYUNvbW1vbi5jaDMyO1xudmFyIG1hajMyID0gc2hhQ29tbW9uLm1hajMyO1xudmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG52YXIgczFfMjU2ID0gc2hhQ29tbW9uLnMxXzI1NjtcbnZhciBnMF8yNTYgPSBzaGFDb21tb24uZzBfMjU2O1xudmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuICBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/256.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\n\nvar SHA512 = __webpack_require__(/*! ./512 */ \"./node_modules/hash.js/lib/hash/sha/512.js\");\n\nfunction SHA384() {\n  if (!(this instanceof SHA384))\n    return new SHA384();\n\n  SHA512.call(this);\n  this.h = [\n    0xcbbb9d5d, 0xc1059ed8,\n    0x629a292a, 0x367cd507,\n    0x9159015a, 0x3070dd17,\n    0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31,\n    0x8eb44a87, 0x68581511,\n    0xdb0c2e0d, 0x64f98fa7,\n    0x47b5481d, 0xbefa4fa4 ];\n}\nutils.inherits(SHA384, SHA512);\nmodule.exports = SHA384;\n\nSHA384.blockSize = 1024;\nSHA384.outSize = 384;\nSHA384.hmacStrength = 192;\nSHA384.padLength = 128;\n\nSHA384.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h.slice(0, 12), 'big');\n  else\n    return utils.split32(this.h.slice(0, 12), 'big');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTs7QUFFOUIsYUFBYSxtQkFBTyxDQUFDLHlEQUFPOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzPzhiOTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi81MTInKTtcblxuZnVuY3Rpb24gU0hBMzg0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG4gIFNIQTUxMi5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCxcbiAgICAweDYyOWEyOTJhLCAweDM2N2NkNTA3LFxuICAgIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsXG4gICAgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLFxuICAgIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsXG4gICAgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyxcbiAgICAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEzODQsIFNIQTUxMik7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTM4NDtcblxuU0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEEzODQub3V0U2l6ZSA9IDM4NDtcblNIQTM4NC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEEzODQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/384.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar common = __webpack_require__(/*! ../common */ \"./node_modules/hash.js/lib/hash/common.js\");\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\n\nvar rotr64_hi = utils.rotr64_hi;\nvar rotr64_lo = utils.rotr64_lo;\nvar shr64_hi = utils.shr64_hi;\nvar shr64_lo = utils.shr64_lo;\nvar sum64 = utils.sum64;\nvar sum64_hi = utils.sum64_hi;\nvar sum64_lo = utils.sum64_lo;\nvar sum64_4_hi = utils.sum64_4_hi;\nvar sum64_4_lo = utils.sum64_4_lo;\nvar sum64_5_hi = utils.sum64_5_hi;\nvar sum64_5_lo = utils.sum64_5_lo;\n\nvar BlockHash = common.BlockHash;\n\nvar sha512_K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction SHA512() {\n  if (!(this instanceof SHA512))\n    return new SHA512();\n\n  BlockHash.call(this);\n  this.h = [\n    0x6a09e667, 0xf3bcc908,\n    0xbb67ae85, 0x84caa73b,\n    0x3c6ef372, 0xfe94f82b,\n    0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1,\n    0x9b05688c, 0x2b3e6c1f,\n    0x1f83d9ab, 0xfb41bd6b,\n    0x5be0cd19, 0x137e2179 ];\n  this.k = sha512_K;\n  this.W = new Array(160);\n}\nutils.inherits(SHA512, BlockHash);\nmodule.exports = SHA512;\n\nSHA512.blockSize = 1024;\nSHA512.outSize = 512;\nSHA512.hmacStrength = 192;\nSHA512.padLength = 128;\n\nSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n  var W = this.W;\n\n  // 32 x 32bit words\n  for (var i = 0; i < 32; i++)\n    W[i] = msg[start + i];\n  for (; i < W.length; i += 2) {\n    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n    var c1_hi = W[i - 14];  // i - 7\n    var c1_lo = W[i - 13];\n    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n    var c3_hi = W[i - 32];  // i - 16\n    var c3_lo = W[i - 31];\n\n    W[i] = sum64_4_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n    W[i + 1] = sum64_4_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo);\n  }\n};\n\nSHA512.prototype._update = function _update(msg, start) {\n  this._prepareBlock(msg, start);\n\n  var W = this.W;\n\n  var ah = this.h[0];\n  var al = this.h[1];\n  var bh = this.h[2];\n  var bl = this.h[3];\n  var ch = this.h[4];\n  var cl = this.h[5];\n  var dh = this.h[6];\n  var dl = this.h[7];\n  var eh = this.h[8];\n  var el = this.h[9];\n  var fh = this.h[10];\n  var fl = this.h[11];\n  var gh = this.h[12];\n  var gl = this.h[13];\n  var hh = this.h[14];\n  var hl = this.h[15];\n\n  assert(this.k.length === W.length);\n  for (var i = 0; i < W.length; i += 2) {\n    var c0_hi = hh;\n    var c0_lo = hl;\n    var c1_hi = s1_512_hi(eh, el);\n    var c1_lo = s1_512_lo(eh, el);\n    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n    var c3_hi = this.k[i];\n    var c3_lo = this.k[i + 1];\n    var c4_hi = W[i];\n    var c4_lo = W[i + 1];\n\n    var T1_hi = sum64_5_hi(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n    var T1_lo = sum64_5_lo(\n      c0_hi, c0_lo,\n      c1_hi, c1_lo,\n      c2_hi, c2_lo,\n      c3_hi, c3_lo,\n      c4_hi, c4_lo);\n\n    c0_hi = s0_512_hi(ah, al);\n    c0_lo = s0_512_lo(ah, al);\n    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);\n    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);\n\n    hh = gh;\n    hl = gl;\n\n    gh = fh;\n    gl = fl;\n\n    fh = eh;\n    fl = el;\n\n    eh = sum64_hi(dh, dl, T1_hi, T1_lo);\n    el = sum64_lo(dl, dl, T1_hi, T1_lo);\n\n    dh = ch;\n    dl = cl;\n\n    ch = bh;\n    cl = bl;\n\n    bh = ah;\n    bl = al;\n\n    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);\n    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);\n  }\n\n  sum64(this.h, 0, ah, al);\n  sum64(this.h, 2, bh, bl);\n  sum64(this.h, 4, ch, cl);\n  sum64(this.h, 6, dh, dl);\n  sum64(this.h, 8, eh, el);\n  sum64(this.h, 10, fh, fl);\n  sum64(this.h, 12, gh, gl);\n  sum64(this.h, 14, hh, hl);\n};\n\nSHA512.prototype._digest = function digest(enc) {\n  if (enc === 'hex')\n    return utils.toHex32(this.h, 'big');\n  else\n    return utils.split32(this.h, 'big');\n};\n\nfunction ch64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ ((~xh) & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ ((~xl) & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_hi(xh, xl, yh, yl, zh) {\n  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 28);\n  var c1_hi = rotr64_hi(xl, xh, 2);  // 34\n  var c2_hi = rotr64_hi(xl, xh, 7);  // 39\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 28);\n  var c1_lo = rotr64_lo(xl, xh, 2);  // 34\n  var c2_lo = rotr64_lo(xl, xh, 7);  // 39\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 14);\n  var c1_hi = rotr64_hi(xh, xl, 18);\n  var c2_hi = rotr64_hi(xl, xh, 9);  // 41\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction s1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 14);\n  var c1_lo = rotr64_lo(xh, xl, 18);\n  var c2_lo = rotr64_lo(xl, xh, 9);  // 41\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 1);\n  var c1_hi = rotr64_hi(xh, xl, 8);\n  var c2_hi = shr64_hi(xh, xl, 7);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g0_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 1);\n  var c1_lo = rotr64_lo(xh, xl, 8);\n  var c2_lo = shr64_lo(xh, xl, 7);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_hi(xh, xl) {\n  var c0_hi = rotr64_hi(xh, xl, 19);\n  var c1_hi = rotr64_hi(xl, xh, 29);  // 61\n  var c2_hi = shr64_hi(xh, xl, 6);\n\n  var r = c0_hi ^ c1_hi ^ c2_hi;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n\nfunction g1_512_lo(xh, xl) {\n  var c0_lo = rotr64_lo(xh, xl, 19);\n  var c1_lo = rotr64_lo(xl, xh, 29);  // 61\n  var c2_lo = shr64_lo(xh, xl, 6);\n\n  var r = c0_lo ^ c1_lo ^ c2_lo;\n  if (r < 0)\n    r += 0x100000000;\n  return r;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvNTEyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5QixhQUFhLG1CQUFPLENBQUMsNERBQVc7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLHdFQUFxQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxTQUFTLGNBQWM7QUFDdkIsZ0RBQWdEO0FBQ2hEO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzUxMi5qcz9iNTI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/512.js\n");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/hash.js/lib/hash/utils.js\");\nvar rotr32 = utils.rotr32;\n\nfunction ft_1(s, x, y, z) {\n  if (s === 0)\n    return ch32(x, y, z);\n  if (s === 1 || s === 3)\n    return p32(x, y, z);\n  if (s === 2)\n    return maj32(x, y, z);\n}\nexports.ft_1 = ft_1;\n\nfunction ch32(x, y, z) {\n  return (x & y) ^ ((~x) & z);\n}\nexports.ch32 = ch32;\n\nfunction maj32(x, y, z) {\n  return (x & y) ^ (x & z) ^ (y & z);\n}\nexports.maj32 = maj32;\n\nfunction p32(x, y, z) {\n  return x ^ y ^ z;\n}\nexports.p32 = p32;\n\nfunction s0_256(x) {\n  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\nexports.s0_256 = s0_256;\n\nfunction s1_256(x) {\n  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\nexports.s1_256 = s1_256;\n\nfunction g0_256(x) {\n  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\nexports.g0_256 = g0_256;\n\nfunction g1_256(x) {\n  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\nexports.g1_256 = g1_256;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBVTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzP2FhNTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cbmV4cG9ydHMuZnRfMSA9IGZ0XzE7XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5leHBvcnRzLmNoMzIgPSBjaDMyO1xuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5leHBvcnRzLm1hajMyID0gbWFqMzI7XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5leHBvcnRzLnAzMiA9IHAzMjtcblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuZXhwb3J0cy5zMF8yNTYgPSBzMF8yNTY7XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cbmV4cG9ydHMuczFfMjU2ID0gczFfMjU2O1xuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cbmV4cG9ydHMuZzBfMjU2ID0gZzBfMjU2O1xuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuZXhwb3J0cy5nMV8yNTYgPSBnMV8yNTY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/sha/common.js\n");

/***/ }),

        /***/
        "./node_modules/hash.js/lib/hash/utils.js":
        /*!************************************************!*\
          !*** ./node_modules/hash.js/lib/hash/utils.js ***!
          \************************************************/
        /***/ ((__unused_webpack_module, exports, __webpack_require__) => {

            "use strict";
            eval("\n\nvar assert = __webpack_require__(/*! minimalistic-assert */ \"./node_modules/minimalistic-assert/index.js\");\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports.inherits = inherits;\n\nfunction isSurrogatePair(msg, i) {\n  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {\n    return false;\n  }\n  if (i < 0 || i + 1 >= msg.length) {\n    return false;\n  }\n  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;\n}\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg === 'string') {\n    if (!enc) {\n      // Inspired by stringToUtf8ByteArray() in closure-library by Google\n      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n      // Apache License 2.0\n      // https://github.com/google/closure-library/blob/master/LICENSE\n      var p = 0;\n      for (var i = 0; i < msg.length; i++) {\n        var c = msg.charCodeAt(i);\n        if (c < 128) {\n          res[p++] = c;\n        } else if (c < 2048) {\n          res[p++] = (c >> 6) | 192;\n          res[p++] = (c & 63) | 128;\n        } else if (isSurrogatePair(msg, i)) {\n          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);\n          res[p++] = (c >> 18) | 240;\n          res[p++] = ((c >> 12) & 63) | 128;\n          res[p++] = ((c >> 6) & 63) | 128;\n          res[p++] = (c & 63) | 128;\n        } else {\n          res[p++] = (c >> 12) | 224;\n          res[p++] = ((c >> 6) & 63) | 128;\n          res[p++] = (c & 63) | 128;\n        }\n      }\n    } else if (enc === 'hex') {\n      msg = msg.replace(/[^a-z0-9]+/ig, '');\n      if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n      for (i = 0; i < msg.length; i += 2)\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n  } else {\n    for (i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n  }\n  return res;\n}\nexports.toArray = toArray;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nexports.toHex = toHex;\n\nfunction htonl(w) {\n  var res = (w >>> 24) |\n            ((w >>> 8) & 0xff00) |\n            ((w << 8) & 0xff0000) |\n            ((w & 0xff) << 24);\n  return res >>> 0;\n}\nexports.htonl = htonl;\n\nfunction toHex32(msg, endian) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++) {\n    var w = msg[i];\n    if (endian === 'little')\n      w = htonl(w);\n    res += zero8(w.toString(16));\n  }\n  return res;\n}\nexports.toHex32 = toHex32;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nexports.zero2 = zero2;\n\nfunction zero8(word) {\n  if (word.length === 7)\n    return '0' + word;\n  else if (word.length === 6)\n    return '00' + word;\n  else if (word.length === 5)\n    return '000' + word;\n  else if (word.length === 4)\n    return '0000' + word;\n  else if (word.length === 3)\n    return '00000' + word;\n  else if (word.length === 2)\n    return '000000' + word;\n  else if (word.length === 1)\n    return '0000000' + word;\n  else\n    return word;\n}\nexports.zero8 = zero8;\n\nfunction join32(msg, start, end, endian) {\n  var len = end - start;\n  assert(len % 4 === 0);\n  var res = new Array(len / 4);\n  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n    var w;\n    if (endian === 'big')\n      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n    else\n      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n    res[i] = w >>> 0;\n  }\n  return res;\n}\nexports.join32 = join32;\n\nfunction split32(msg, endian) {\n  var res = new Array(msg.length * 4);\n  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n    var m = msg[i];\n    if (endian === 'big') {\n      res[k] = m >>> 24;\n      res[k + 1] = (m >>> 16) & 0xff;\n      res[k + 2] = (m >>> 8) & 0xff;\n      res[k + 3] = m & 0xff;\n    } else {\n      res[k + 3] = m >>> 24;\n      res[k + 2] = (m >>> 16) & 0xff;\n      res[k + 1] = (m >>> 8) & 0xff;\n      res[k] = m & 0xff;\n    }\n  }\n  return res;\n}\nexports.split32 = split32;\n\nfunction rotr32(w, b) {\n  return (w >>> b) | (w << (32 - b));\n}\nexports.rotr32 = rotr32;\n\nfunction rotl32(w, b) {\n  return (w << b) | (w >>> (32 - b));\n}\nexports.rotl32 = rotl32;\n\nfunction sum32(a, b) {\n  return (a + b) >>> 0;\n}\nexports.sum32 = sum32;\n\nfunction sum32_3(a, b, c) {\n  return (a + b + c) >>> 0;\n}\nexports.sum32_3 = sum32_3;\n\nfunction sum32_4(a, b, c, d) {\n  return (a + b + c + d) >>> 0;\n}\nexports.sum32_4 = sum32_4;\n\nfunction sum32_5(a, b, c, d, e) {\n  return (a + b + c + d + e) >>> 0;\n}\nexports.sum32_5 = sum32_5;\n\nfunction sum64(buf, pos, ah, al) {\n  var bh = buf[pos];\n  var bl = buf[pos + 1];\n\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  buf[pos] = hi >>> 0;\n  buf[pos + 1] = lo;\n}\nexports.sum64 = sum64;\n\nfunction sum64_hi(ah, al, bh, bl) {\n  var lo = (al + bl) >>> 0;\n  var hi = (lo < al ? 1 : 0) + ah + bh;\n  return hi >>> 0;\n}\nexports.sum64_hi = sum64_hi;\n\nfunction sum64_lo(ah, al, bh, bl) {\n  var lo = al + bl;\n  return lo >>> 0;\n}\nexports.sum64_lo = sum64_lo;\n\nfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + carry;\n  return hi >>> 0;\n}\nexports.sum64_4_hi = sum64_4_hi;\n\nfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n  var lo = al + bl + cl + dl;\n  return lo >>> 0;\n}\nexports.sum64_4_lo = sum64_4_lo;\n\nfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var carry = 0;\n  var lo = al;\n  lo = (lo + bl) >>> 0;\n  carry += lo < al ? 1 : 0;\n  lo = (lo + cl) >>> 0;\n  carry += lo < cl ? 1 : 0;\n  lo = (lo + dl) >>> 0;\n  carry += lo < dl ? 1 : 0;\n  lo = (lo + el) >>> 0;\n  carry += lo < el ? 1 : 0;\n\n  var hi = ah + bh + ch + dh + eh + carry;\n  return hi >>> 0;\n}\nexports.sum64_5_hi = sum64_5_hi;\n\nfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n  var lo = al + bl + cl + dl + el;\n\n  return lo >>> 0;\n}\nexports.sum64_5_lo = sum64_5_lo;\n\nfunction rotr64_hi(ah, al, num) {\n  var r = (al << (32 - num)) | (ah >>> num);\n  return r >>> 0;\n}\nexports.rotr64_hi = rotr64_hi;\n\nfunction rotr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.rotr64_lo = rotr64_lo;\n\nfunction shr64_hi(ah, al, num) {\n  return ah >>> num;\n}\nexports.shr64_hi = shr64_hi;\n\nfunction shr64_lo(ah, al, num) {\n  var r = (ah << (32 - num)) | (al >>> num);\n  return r >>> 0;\n}\nexports.shr64_lo = shr64_lo;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsd0VBQXFCO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyw2REFBVTs7QUFFakMsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcz9jM2MwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcblxuZnVuY3Rpb24gaXNTdXJyb2dhdGVQYWlyKG1zZywgaSkge1xuICBpZiAoKG1zZy5jaGFyQ29kZUF0KGkpICYgMHhGQzAwKSAhPT0gMHhEODAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpIDwgMCB8fCBpICsgMSA+PSBtc2cubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAobXNnLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKCFlbmMpIHtcbiAgICAgIC8vIEluc3BpcmVkIGJ5IHN0cmluZ1RvVXRmOEJ5dGVBcnJheSgpIGluIGNsb3N1cmUtbGlicmFyeSBieSBHb29nbGVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvODU5OGQ4NzI0MmFmNTlhYWMyMzMyNzA3NDJjODk4NGUyYjJiZGJlMC9jbG9zdXJlL2dvb2cvY3J5cHQvY3J5cHQuanMjTDExNy1MMTQzXG4gICAgICAvLyBBcGFjaGUgTGljZW5zZSAyLjBcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9IGVsc2UgaWYgKGlzU3Vycm9nYXRlUGFpcihtc2csIGkpKSB7XG4gICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzRkYpIDw8IDEwKSArIChtc2cuY2hhckNvZGVBdCgrK2kpICYgMHgwM0ZGKTtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDE4KSB8IDI0MDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmMgPT09ICdoZXgnKSB7XG4gICAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgICBtc2cgPSAnMCcgKyBtc2c7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgICAgcmVzW2ldID0gbXNnW2ldIHwgMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gdG9IZXgobXNnKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgcmVzICs9IHplcm8yKG1zZ1tpXS50b1N0cmluZygxNikpO1xuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuXG5mdW5jdGlvbiBodG9ubCh3KSB7XG4gIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcbiAgICAgICAgICAgICgodyA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgICAgICgodyA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG4gIHJldHVybiByZXMgPj4+IDA7XG59XG5leHBvcnRzLmh0b25sID0gaHRvbmw7XG5cbmZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB3ID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdsaXR0bGUnKVxuICAgICAgdyA9IGh0b25sKHcpO1xuICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXgzMiA9IHRvSGV4MzI7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHplcm84KHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSA3KVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNilcbiAgICByZXR1cm4gJzAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuICAgIHJldHVybiAnMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA0KVxuICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMylcbiAgICByZXR1cm4gJzAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuICAgIHJldHVybiAnMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG5leHBvcnRzLnplcm84ID0gemVybzg7XG5cbmZ1bmN0aW9uIGpvaW4zMihtc2csIHN0YXJ0LCBlbmQsIGVuZGlhbikge1xuICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGFzc2VydChsZW4gJSA0ID09PSAwKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShsZW4gLyA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSBzdGFydDsgaSA8IHJlcy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpXG4gICAgICB3ID0gKG1zZ1trXSA8PCAyNCkgfCAobXNnW2sgKyAxXSA8PCAxNikgfCAobXNnW2sgKyAyXSA8PCA4KSB8IG1zZ1trICsgM107XG4gICAgZWxzZVxuICAgICAgdyA9IChtc2dbayArIDNdIDw8IDI0KSB8IChtc2dbayArIDJdIDw8IDE2KSB8IChtc2dbayArIDFdIDw8IDgpIHwgbXNnW2tdO1xuICAgIHJlc1tpXSA9IHcgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuam9pbjMyID0gam9pbjMyO1xuXG5mdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobXNnLmxlbmd0aCAqIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciBtID0gbXNnW2ldO1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgICByZXNba10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2sgKyAzXSA9IG0gJiAweGZmO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbayArIDNdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trXSA9IG0gJiAweGZmO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5zcGxpdDMyID0gc3BsaXQzMjtcblxuZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcbiAgcmV0dXJuICh3ID4+PiBiKSB8ICh3IDw8ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90cjMyID0gcm90cjMyO1xuXG5mdW5jdGlvbiByb3RsMzIodywgYikge1xuICByZXR1cm4gKHcgPDwgYikgfCAodyA+Pj4gKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RsMzIgPSByb3RsMzI7XG5cbmZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcbiAgcmV0dXJuIChhICsgYikgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyID0gc3VtMzI7XG5cbmZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuICByZXR1cm4gKGEgKyBiICsgYykgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzMgPSBzdW0zMl8zO1xuXG5mdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNCA9IHN1bTMyXzQ7XG5cbmZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQgKyBlKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfNSA9IHN1bTMyXzU7XG5cbmZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcbiAgdmFyIGJoID0gYnVmW3Bvc107XG4gIHZhciBibCA9IGJ1Zltwb3MgKyAxXTtcblxuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgYnVmW3Bvc10gPSBoaSA+Pj4gMDtcbiAgYnVmW3BvcyArIDFdID0gbG87XG59XG5leHBvcnRzLnN1bTY0ID0gc3VtNjQ7XG5cbmZ1bmN0aW9uIHN1bTY0X2hpKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2hpID0gc3VtNjRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0X2xvKGFoLCBhbCwgYmgsIGJsKSB7XG4gIHZhciBsbyA9IGFsICsgYmw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfbG8gPSBzdW02NF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2hpID0gc3VtNjRfNF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNF9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9sbyA9IHN1bTY0XzRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGNhcnJ5ID0gMDtcbiAgdmFyIGxvID0gYWw7XG4gIGxvID0gKGxvICsgYmwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgY2wpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZGwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGRsID8gMSA6IDA7XG4gIGxvID0gKGxvICsgZWwpID4+PiAwO1xuICBjYXJyeSArPSBsbyA8IGVsID8gMSA6IDA7XG5cbiAgdmFyIGhpID0gYWggKyBiaCArIGNoICsgZGggKyBlaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfaGkgPSBzdW02NF81X2hpO1xuXG5mdW5jdGlvbiBzdW02NF81X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2xvID0gc3VtNjRfNV9sbztcblxuZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFsIDw8ICgzMiAtIG51bSkpIHwgKGFoID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2hpID0gcm90cjY0X2hpO1xuXG5mdW5jdGlvbiByb3RyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfbG8gPSByb3RyNjRfbG87XG5cbmZ1bmN0aW9uIHNocjY0X2hpKGFoLCBhbCwgbnVtKSB7XG4gIHJldHVybiBhaCA+Pj4gbnVtO1xufVxuZXhwb3J0cy5zaHI2NF9oaSA9IHNocjY0X2hpO1xuXG5mdW5jdGlvbiBzaHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnNocjY0X2xvID0gc2hyNjRfbG87XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hash.js/lib/hash/utils.js\n");

            /***/
        }),

        /***/
        "./node_modules/html-entities/lib/index.js":
        /*!*************************************************!*\
          !*** ./node_modules/html-entities/lib/index.js ***!
          \*************************************************/
        /***/ (function (__unused_webpack_module, exports, __webpack_require__) {

            "use strict";
            eval("\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar named_references_1 = __webpack_require__(/*! ./named-references */ \"./node_modules/html-entities/lib/named-references.js\");\nvar numeric_unicode_map_1 = __webpack_require__(/*! ./numeric-unicode-map */ \"./node_modules/html-entities/lib/numeric-unicode-map.js\");\nvar surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ \"./node_modules/html-entities/lib/surrogate-pairs.js\");\nvar allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });\nvar encodeRegExps = {\n    specialChars: /[<>'\"&]/g,\n    nonAscii: /(?:[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g,\n    nonAsciiPrintable: /(?:[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g,\n    extensive: /(?:[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g\n};\nvar defaultEncodeOptions = {\n    mode: 'specialChars',\n    level: 'all',\n    numeric: 'decimal'\n};\n/** Encodes all the necessary (specified by `level`) characters in the text */\nfunction encode(text, _a) {\n    var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? 'specialChars' : _c, _d = _b.numeric, numeric = _d === void 0 ? 'decimal' : _d, _e = _b.level, level = _e === void 0 ? 'all' : _e;\n    if (!text) {\n        return '';\n    }\n    var encodeRegExp = encodeRegExps[mode];\n    var references = allNamedReferences[level].characters;\n    var isHex = numeric === 'hexadecimal';\n    encodeRegExp.lastIndex = 0;\n    var _b = encodeRegExp.exec(text);\n    var _c;\n    if (_b) {\n        _c = '';\n        var _d = 0;\n        do {\n            if (_d !== _b.index) {\n                _c += text.substring(_d, _b.index);\n            }\n            var _e = _b[0];\n            var result_1 = references[_e];\n            if (!result_1) {\n                var code_1 = _e.length > 1 ? surrogate_pairs_1.getCodePoint(_e, 0) : _e.charCodeAt(0);\n                result_1 = (isHex ? '&#x' + code_1.toString(16) : '&#' + code_1) + ';';\n            }\n            _c += result_1;\n            _d = _b.index + _e.length;\n        } while ((_b = encodeRegExp.exec(text)));\n        if (_d !== text.length) {\n            _c += text.substring(_d);\n        }\n    }\n    else {\n        _c =\n            text;\n    }\n    return _c;\n}\nexports.encode = encode;\nvar defaultDecodeOptions = {\n    scope: 'body',\n    level: 'all'\n};\nvar strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nvar attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\nvar baseDecodeRegExps = {\n    xml: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_1.bodyRegExps.xml\n    },\n    html4: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_1.bodyRegExps.html4\n    },\n    html5: {\n        strict: strict,\n        attribute: attribute,\n        body: named_references_1.bodyRegExps.html5\n    }\n};\nvar decodeRegExps = __assign(__assign({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });\nvar fromCharCode = String.fromCharCode;\nvar outOfBoundsChar = fromCharCode(65533);\nvar defaultDecodeEntityOptions = {\n    level: 'all'\n};\n/** Decodes a single entity */\nfunction decodeEntity(entity, _a) {\n    var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level, level = _b === void 0 ? 'all' : _b;\n    if (!entity) {\n        return '';\n    }\n    var _b = entity;\n    var decodeEntityLastChar_1 = entity[entity.length - 1];\n    if (false) {}\n    else if (false) {}\n    else {\n        var decodeResultByReference_1 = allNamedReferences[level].entities[entity];\n        if (decodeResultByReference_1) {\n            _b = decodeResultByReference_1;\n        }\n        else if (entity[0] === '&' && entity[1] === '#') {\n            var decodeSecondChar_1 = entity[2];\n            var decodeCode_1 = decodeSecondChar_1 == 'x' || decodeSecondChar_1 == 'X'\n                ? parseInt(entity.substr(3), 16)\n                : parseInt(entity.substr(2));\n            _b =\n                decodeCode_1 >= 0x10ffff\n                    ? outOfBoundsChar\n                    : decodeCode_1 > 65535\n                        ? surrogate_pairs_1.fromCodePoint(decodeCode_1)\n                        : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_1] || decodeCode_1);\n        }\n    }\n    return _b;\n}\nexports.decodeEntity = decodeEntity;\n/** Decodes all entities in the text */\nfunction decode(text, _a) {\n    var decodeSecondChar_1 = _a === void 0 ? defaultDecodeOptions : _a, decodeCode_1 = decodeSecondChar_1.level, level = decodeCode_1 === void 0 ? 'all' : decodeCode_1, _b = decodeSecondChar_1.scope, scope = _b === void 0 ? level === 'xml' ? 'strict' : 'body' : _b;\n    if (!text) {\n        return '';\n    }\n    var decodeRegExp = decodeRegExps[level][scope];\n    var references = allNamedReferences[level].entities;\n    var isAttribute = scope === 'attribute';\n    var isStrict = scope === 'strict';\n    decodeRegExp.lastIndex = 0;\n    var replaceMatch_1 = decodeRegExp.exec(text);\n    var replaceResult_1;\n    if (replaceMatch_1) {\n        replaceResult_1 = '';\n        var replaceLastIndex_1 = 0;\n        do {\n            if (replaceLastIndex_1 !== replaceMatch_1.index) {\n                replaceResult_1 += text.substring(replaceLastIndex_1, replaceMatch_1.index);\n            }\n            var replaceInput_1 = replaceMatch_1[0];\n            var decodeResult_1 = replaceInput_1;\n            var decodeEntityLastChar_2 = replaceInput_1[replaceInput_1.length - 1];\n            if (isAttribute\n                && decodeEntityLastChar_2 === '=') {\n                decodeResult_1 = replaceInput_1;\n            }\n            else if (isStrict\n                && decodeEntityLastChar_2 !== ';') {\n                decodeResult_1 = replaceInput_1;\n            }\n            else {\n                var decodeResultByReference_2 = references[replaceInput_1];\n                if (decodeResultByReference_2) {\n                    decodeResult_1 = decodeResultByReference_2;\n                }\n                else if (replaceInput_1[0] === '&' && replaceInput_1[1] === '#') {\n                    var decodeSecondChar_2 = replaceInput_1[2];\n                    var decodeCode_2 = decodeSecondChar_2 == 'x' || decodeSecondChar_2 == 'X'\n                        ? parseInt(replaceInput_1.substr(3), 16)\n                        : parseInt(replaceInput_1.substr(2));\n                    decodeResult_1 =\n                        decodeCode_2 >= 0x10ffff\n                            ? outOfBoundsChar\n                            : decodeCode_2 > 65535\n                                ? surrogate_pairs_1.fromCodePoint(decodeCode_2)\n                                : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_2] || decodeCode_2);\n                }\n            }\n            replaceResult_1 += decodeResult_1;\n            replaceLastIndex_1 = replaceMatch_1.index + replaceInput_1.length;\n        } while ((replaceMatch_1 = decodeRegExp.exec(text)));\n        if (replaceLastIndex_1 !== text.length) {\n            replaceResult_1 += text.substring(replaceLastIndex_1);\n        }\n    }\n    else {\n        replaceResult_1 =\n            text;\n    }\n    return replaceResult_1;\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsbUJBQU8sQ0FBQyxnRkFBb0I7QUFDckQsNEJBQTRCLG1CQUFPLENBQUMsc0ZBQXVCO0FBQzNELHdCQUF3QixtQkFBTyxDQUFDLDhFQUFtQjtBQUNuRCw2Q0FBNkMseUNBQXlDLCtDQUErQztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3Qiw4QkFBOEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQ2lDLEVBQUUsRUFHdEM7QUFDTCxhQUFhLEtBQzRCLEVBQUUsRUFHdEM7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2luZGV4LmpzP2MyYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG5hbWVkX3JlZmVyZW5jZXNfMSA9IHJlcXVpcmUoXCIuL25hbWVkLXJlZmVyZW5jZXNcIik7XG52YXIgbnVtZXJpY191bmljb2RlX21hcF8xID0gcmVxdWlyZShcIi4vbnVtZXJpYy11bmljb2RlLW1hcFwiKTtcbnZhciBzdXJyb2dhdGVfcGFpcnNfMSA9IHJlcXVpcmUoXCIuL3N1cnJvZ2F0ZS1wYWlyc1wiKTtcbnZhciBhbGxOYW1lZFJlZmVyZW5jZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbmFtZWRfcmVmZXJlbmNlc18xLm5hbWVkUmVmZXJlbmNlcyksIHsgYWxsOiBuYW1lZF9yZWZlcmVuY2VzXzEubmFtZWRSZWZlcmVuY2VzLmh0bWw1IH0pO1xudmFyIGVuY29kZVJlZ0V4cHMgPSB7XG4gICAgc3BlY2lhbENoYXJzOiAvWzw+J1wiJl0vZyxcbiAgICBub25Bc2NpaTogLyg/Ols8PidcIiZcXHUwMDgwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pL2csXG4gICAgbm9uQXNjaWlQcmludGFibGU6IC8oPzpbPD4nXCImXFx4MDEtXFx4MDhcXHgxMS1cXHgxNVxceDE3LVxceDFGXFx4N2YtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkvZyxcbiAgICBleHRlbnNpdmU6IC8oPzpbXFx4MDEtXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDJjXFx4MmUtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4N2RcXHg3Zi1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKS9nXG59O1xudmFyIGRlZmF1bHRFbmNvZGVPcHRpb25zID0ge1xuICAgIG1vZGU6ICdzcGVjaWFsQ2hhcnMnLFxuICAgIGxldmVsOiAnYWxsJyxcbiAgICBudW1lcmljOiAnZGVjaW1hbCdcbn07XG4vKiogRW5jb2RlcyBhbGwgdGhlIG5lY2Vzc2FyeSAoc3BlY2lmaWVkIGJ5IGBsZXZlbGApIGNoYXJhY3RlcnMgaW4gdGhlIHRleHQgKi9cbmZ1bmN0aW9uIGVuY29kZSh0ZXh0LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyBkZWZhdWx0RW5jb2RlT3B0aW9ucyA6IF9hLCBfYyA9IF9iLm1vZGUsIG1vZGUgPSBfYyA9PT0gdm9pZCAwID8gJ3NwZWNpYWxDaGFycycgOiBfYywgX2QgPSBfYi5udW1lcmljLCBudW1lcmljID0gX2QgPT09IHZvaWQgMCA/ICdkZWNpbWFsJyA6IF9kLCBfZSA9IF9iLmxldmVsLCBsZXZlbCA9IF9lID09PSB2b2lkIDAgPyAnYWxsJyA6IF9lO1xuICAgIGlmICghdGV4dCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBlbmNvZGVSZWdFeHAgPSBlbmNvZGVSZWdFeHBzW21vZGVdO1xuICAgIHZhciByZWZlcmVuY2VzID0gYWxsTmFtZWRSZWZlcmVuY2VzW2xldmVsXS5jaGFyYWN0ZXJzO1xuICAgIHZhciBpc0hleCA9IG51bWVyaWMgPT09ICdoZXhhZGVjaW1hbCc7XG4gICAgZW5jb2RlUmVnRXhwLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIF9iID0gZW5jb2RlUmVnRXhwLmV4ZWModGV4dCk7XG4gICAgdmFyIF9jO1xuICAgIGlmIChfYikge1xuICAgICAgICBfYyA9ICcnO1xuICAgICAgICB2YXIgX2QgPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoX2QgIT09IF9iLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgX2MgKz0gdGV4dC5zdWJzdHJpbmcoX2QsIF9iLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZSA9IF9iWzBdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gcmVmZXJlbmNlc1tfZV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdF8xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGVfMSA9IF9lLmxlbmd0aCA+IDEgPyBzdXJyb2dhdGVfcGFpcnNfMS5nZXRDb2RlUG9pbnQoX2UsIDApIDogX2UuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICByZXN1bHRfMSA9IChpc0hleCA/ICcmI3gnICsgY29kZV8xLnRvU3RyaW5nKDE2KSA6ICcmIycgKyBjb2RlXzEpICsgJzsnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2MgKz0gcmVzdWx0XzE7XG4gICAgICAgICAgICBfZCA9IF9iLmluZGV4ICsgX2UubGVuZ3RoO1xuICAgICAgICB9IHdoaWxlICgoX2IgPSBlbmNvZGVSZWdFeHAuZXhlYyh0ZXh0KSkpO1xuICAgICAgICBpZiAoX2QgIT09IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBfYyArPSB0ZXh0LnN1YnN0cmluZyhfZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9jID1cbiAgICAgICAgICAgIHRleHQ7XG4gICAgfVxuICAgIHJldHVybiBfYztcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xudmFyIGRlZmF1bHREZWNvZGVPcHRpb25zID0ge1xuICAgIHNjb3BlOiAnYm9keScsXG4gICAgbGV2ZWw6ICdhbGwnXG59O1xudmFyIHN0cmljdCA9IC8mKD86I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKTsvZztcbnZhciBhdHRyaWJ1dGUgPSAvJig/OiNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKylbOz1dPy9nO1xudmFyIGJhc2VEZWNvZGVSZWdFeHBzID0ge1xuICAgIHhtbDoge1xuICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgIGJvZHk6IG5hbWVkX3JlZmVyZW5jZXNfMS5ib2R5UmVnRXhwcy54bWxcbiAgICB9LFxuICAgIGh0bWw0OiB7XG4gICAgICAgIHN0cmljdDogc3RyaWN0LFxuICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgYm9keTogbmFtZWRfcmVmZXJlbmNlc18xLmJvZHlSZWdFeHBzLmh0bWw0XG4gICAgfSxcbiAgICBodG1sNToge1xuICAgICAgICBzdHJpY3Q6IHN0cmljdCxcbiAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgIGJvZHk6IG5hbWVkX3JlZmVyZW5jZXNfMS5ib2R5UmVnRXhwcy5odG1sNVxuICAgIH1cbn07XG52YXIgZGVjb2RlUmVnRXhwcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBiYXNlRGVjb2RlUmVnRXhwcyksIHsgYWxsOiBiYXNlRGVjb2RlUmVnRXhwcy5odG1sNSB9KTtcbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIG91dE9mQm91bmRzQ2hhciA9IGZyb21DaGFyQ29kZSg2NTUzMyk7XG52YXIgZGVmYXVsdERlY29kZUVudGl0eU9wdGlvbnMgPSB7XG4gICAgbGV2ZWw6ICdhbGwnXG59O1xuLyoqIERlY29kZXMgYSBzaW5nbGUgZW50aXR5ICovXG5mdW5jdGlvbiBkZWNvZGVFbnRpdHkoZW50aXR5LCBfYSkge1xuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8gZGVmYXVsdERlY29kZUVudGl0eU9wdGlvbnMgOiBfYSkubGV2ZWwsIGxldmVsID0gX2IgPT09IHZvaWQgMCA/ICdhbGwnIDogX2I7XG4gICAgaWYgKCFlbnRpdHkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgX2IgPSBlbnRpdHk7XG4gICAgdmFyIGRlY29kZUVudGl0eUxhc3RDaGFyXzEgPSBlbnRpdHlbZW50aXR5Lmxlbmd0aCAtIDFdO1xuICAgIGlmIChmYWxzZVxuICAgICAgICAmJiBkZWNvZGVFbnRpdHlMYXN0Q2hhcl8xID09PSAnPScpIHtcbiAgICAgICAgX2IgPVxuICAgICAgICAgICAgZW50aXR5O1xuICAgIH1cbiAgICBlbHNlIGlmIChmYWxzZVxuICAgICAgICAmJiBkZWNvZGVFbnRpdHlMYXN0Q2hhcl8xICE9PSAnOycpIHtcbiAgICAgICAgX2IgPVxuICAgICAgICAgICAgZW50aXR5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzEgPSBhbGxOYW1lZFJlZmVyZW5jZXNbbGV2ZWxdLmVudGl0aWVzW2VudGl0eV07XG4gICAgICAgIGlmIChkZWNvZGVSZXN1bHRCeVJlZmVyZW5jZV8xKSB7XG4gICAgICAgICAgICBfYiA9IGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50aXR5WzBdID09PSAnJicgJiYgZW50aXR5WzFdID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBkZWNvZGVTZWNvbmRDaGFyXzEgPSBlbnRpdHlbMl07XG4gICAgICAgICAgICB2YXIgZGVjb2RlQ29kZV8xID0gZGVjb2RlU2Vjb25kQ2hhcl8xID09ICd4JyB8fCBkZWNvZGVTZWNvbmRDaGFyXzEgPT0gJ1gnXG4gICAgICAgICAgICAgICAgPyBwYXJzZUludChlbnRpdHkuc3Vic3RyKDMpLCAxNilcbiAgICAgICAgICAgICAgICA6IHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikpO1xuICAgICAgICAgICAgX2IgPVxuICAgICAgICAgICAgICAgIGRlY29kZUNvZGVfMSA+PSAweDEwZmZmZlxuICAgICAgICAgICAgICAgICAgICA/IG91dE9mQm91bmRzQ2hhclxuICAgICAgICAgICAgICAgICAgICA6IGRlY29kZUNvZGVfMSA+IDY1NTM1XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN1cnJvZ2F0ZV9wYWlyc18xLmZyb21Db2RlUG9pbnQoZGVjb2RlQ29kZV8xKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBmcm9tQ2hhckNvZGUobnVtZXJpY191bmljb2RlX21hcF8xLm51bWVyaWNVbmljb2RlTWFwW2RlY29kZUNvZGVfMV0gfHwgZGVjb2RlQ29kZV8xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2I7XG59XG5leHBvcnRzLmRlY29kZUVudGl0eSA9IGRlY29kZUVudGl0eTtcbi8qKiBEZWNvZGVzIGFsbCBlbnRpdGllcyBpbiB0aGUgdGV4dCAqL1xuZnVuY3Rpb24gZGVjb2RlKHRleHQsIF9hKSB7XG4gICAgdmFyIGRlY29kZVNlY29uZENoYXJfMSA9IF9hID09PSB2b2lkIDAgPyBkZWZhdWx0RGVjb2RlT3B0aW9ucyA6IF9hLCBkZWNvZGVDb2RlXzEgPSBkZWNvZGVTZWNvbmRDaGFyXzEubGV2ZWwsIGxldmVsID0gZGVjb2RlQ29kZV8xID09PSB2b2lkIDAgPyAnYWxsJyA6IGRlY29kZUNvZGVfMSwgX2IgPSBkZWNvZGVTZWNvbmRDaGFyXzEuc2NvcGUsIHNjb3BlID0gX2IgPT09IHZvaWQgMCA/IGxldmVsID09PSAneG1sJyA/ICdzdHJpY3QnIDogJ2JvZHknIDogX2I7XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIGRlY29kZVJlZ0V4cCA9IGRlY29kZVJlZ0V4cHNbbGV2ZWxdW3Njb3BlXTtcbiAgICB2YXIgcmVmZXJlbmNlcyA9IGFsbE5hbWVkUmVmZXJlbmNlc1tsZXZlbF0uZW50aXRpZXM7XG4gICAgdmFyIGlzQXR0cmlidXRlID0gc2NvcGUgPT09ICdhdHRyaWJ1dGUnO1xuICAgIHZhciBpc1N0cmljdCA9IHNjb3BlID09PSAnc3RyaWN0JztcbiAgICBkZWNvZGVSZWdFeHAubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgcmVwbGFjZU1hdGNoXzEgPSBkZWNvZGVSZWdFeHAuZXhlYyh0ZXh0KTtcbiAgICB2YXIgcmVwbGFjZVJlc3VsdF8xO1xuICAgIGlmIChyZXBsYWNlTWF0Y2hfMSkge1xuICAgICAgICByZXBsYWNlUmVzdWx0XzEgPSAnJztcbiAgICAgICAgdmFyIHJlcGxhY2VMYXN0SW5kZXhfMSA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlTGFzdEluZGV4XzEgIT09IHJlcGxhY2VNYXRjaF8xLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVJlc3VsdF8xICs9IHRleHQuc3Vic3RyaW5nKHJlcGxhY2VMYXN0SW5kZXhfMSwgcmVwbGFjZU1hdGNoXzEuaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcGxhY2VJbnB1dF8xID0gcmVwbGFjZU1hdGNoXzFbMF07XG4gICAgICAgICAgICB2YXIgZGVjb2RlUmVzdWx0XzEgPSByZXBsYWNlSW5wdXRfMTtcbiAgICAgICAgICAgIHZhciBkZWNvZGVFbnRpdHlMYXN0Q2hhcl8yID0gcmVwbGFjZUlucHV0XzFbcmVwbGFjZUlucHV0XzEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoaXNBdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAmJiBkZWNvZGVFbnRpdHlMYXN0Q2hhcl8yID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHRfMSA9IHJlcGxhY2VJbnB1dF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpY3RcbiAgICAgICAgICAgICAgICAmJiBkZWNvZGVFbnRpdHlMYXN0Q2hhcl8yICE9PSAnOycpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHRfMSA9IHJlcGxhY2VJbnB1dF8xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzIgPSByZWZlcmVuY2VzW3JlcGxhY2VJbnB1dF8xXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVjb2RlUmVzdWx0QnlSZWZlcmVuY2VfMikge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVSZXN1bHRfMSA9IGRlY29kZVJlc3VsdEJ5UmVmZXJlbmNlXzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VJbnB1dF8xWzBdID09PSAnJicgJiYgcmVwbGFjZUlucHV0XzFbMV0gPT09ICcjJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVjb2RlU2Vjb25kQ2hhcl8yID0gcmVwbGFjZUlucHV0XzFbMl07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWNvZGVDb2RlXzIgPSBkZWNvZGVTZWNvbmRDaGFyXzIgPT0gJ3gnIHx8IGRlY29kZVNlY29uZENoYXJfMiA9PSAnWCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQocmVwbGFjZUlucHV0XzEuc3Vic3RyKDMpLCAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcGFyc2VJbnQocmVwbGFjZUlucHV0XzEuc3Vic3RyKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlUmVzdWx0XzEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlQ29kZV8yID49IDB4MTBmZmZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvdXRPZkJvdW5kc0NoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRlY29kZUNvZGVfMiA+IDY1NTM1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3Vycm9nYXRlX3BhaXJzXzEuZnJvbUNvZGVQb2ludChkZWNvZGVDb2RlXzIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZnJvbUNoYXJDb2RlKG51bWVyaWNfdW5pY29kZV9tYXBfMS5udW1lcmljVW5pY29kZU1hcFtkZWNvZGVDb2RlXzJdIHx8IGRlY29kZUNvZGVfMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVwbGFjZVJlc3VsdF8xICs9IGRlY29kZVJlc3VsdF8xO1xuICAgICAgICAgICAgcmVwbGFjZUxhc3RJbmRleF8xID0gcmVwbGFjZU1hdGNoXzEuaW5kZXggKyByZXBsYWNlSW5wdXRfMS5sZW5ndGg7XG4gICAgICAgIH0gd2hpbGUgKChyZXBsYWNlTWF0Y2hfMSA9IGRlY29kZVJlZ0V4cC5leGVjKHRleHQpKSk7XG4gICAgICAgIGlmIChyZXBsYWNlTGFzdEluZGV4XzEgIT09IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXBsYWNlUmVzdWx0XzEgKz0gdGV4dC5zdWJzdHJpbmcocmVwbGFjZUxhc3RJbmRleF8xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVwbGFjZVJlc3VsdF8xID1cbiAgICAgICAgICAgIHRleHQ7XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlUmVzdWx0XzE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/index.js\n");

            /***/
        }),

        /***/
        "./node_modules/html-entities/lib/named-references.js":
        /*!************************************************************!*\
          !*** ./node_modules/html-entities/lib/named-references.js ***!
          \************************************************************/
        /***/ ((__unused_webpack_module, exports) => {

            "use strict";
            eval("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports.bodyRegExps={xml:/&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,html4:/&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g,html5:/&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);?/g};exports.namedReferences={xml:{entities:{\"&lt;\":\"<\",\"&gt;\":\">\",\"&quot;\":'\"',\"&apos;\":\"'\",\"&amp;\":\"&\"},characters:{\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&apos;\",\"&\":\"&amp;\"}},html4:{entities:{\"&apos;\":\"'\",\"&nbsp\":\"\",\"&nbsp;\":\"\",\"&iexcl\":\"\",\"&iexcl;\":\"\",\"&cent\":\"\",\"&cent;\":\"\",\"&pound\":\"\",\"&pound;\":\"\",\"&curren\":\"\",\"&curren;\":\"\",\"&yen\":\"\",\"&yen;\":\"\",\"&brvbar\":\"\",\"&brvbar;\":\"\",\"&sect\":\"\",\"&sect;\":\"\",\"&uml\":\"\",\"&uml;\":\"\",\"&copy\":\"\",\"&copy;\":\"\",\"&ordf\":\"\",\"&ordf;\":\"\",\"&laquo\":\"\",\"&laquo;\":\"\",\"&not\":\"\",\"&not;\":\"\",\"&shy\":\"\",\"&shy;\":\"\",\"&reg\":\"\",\"&reg;\":\"\",\"&macr\":\"\",\"&macr;\":\"\",\"&deg\":\"\",\"&deg;\":\"\",\"&plusmn\":\"\",\"&plusmn;\":\"\",\"&sup2\":\"\",\"&sup2;\":\"\",\"&sup3\":\"\",\"&sup3;\":\"\",\"&acute\":\"\",\"&acute;\":\"\",\"&micro\":\"\",\"&micro;\":\"\",\"&para\":\"\",\"&para;\":\"\",\"&middot\":\"\",\"&middot;\":\"\",\"&cedil\":\"\",\"&cedil;\":\"\",\"&sup1\":\"\",\"&sup1;\":\"\",\"&ordm\":\"\",\"&ordm;\":\"\",\"&raquo\":\"\",\"&raquo;\":\"\",\"&frac14\":\"\",\"&frac14;\":\"\",\"&frac12\":\"\",\"&frac12;\":\"\",\"&frac34\":\"\",\"&frac34;\":\"\",\"&iquest\":\"\",\"&iquest;\":\"\",\"&Agrave\":\"\",\"&Agrave;\":\"\",\"&Aacute\":\"\",\"&Aacute;\":\"\",\"&Acirc\":\"\",\"&Acirc;\":\"\",\"&Atilde\":\"\",\"&Atilde;\":\"\",\"&Auml\":\"\",\"&Auml;\":\"\",\"&Aring\":\"\",\"&Aring;\":\"\",\"&AElig\":\"\",\"&AElig;\":\"\",\"&Ccedil\":\"\",\"&Ccedil;\":\"\",\"&Egrave\":\"\",\"&Egrave;\":\"\",\"&Eacute\":\"\",\"&Eacute;\":\"\",\"&Ecirc\":\"\",\"&Ecirc;\":\"\",\"&Euml\":\"\",\"&Euml;\":\"\",\"&Igrave\":\"\",\"&Igrave;\":\"\",\"&Iacute\":\"\",\"&Iacute;\":\"\",\"&Icirc\":\"\",\"&Icirc;\":\"\",\"&Iuml\":\"\",\"&Iuml;\":\"\",\"&ETH\":\"\",\"&ETH;\":\"\",\"&Ntilde\":\"\",\"&Ntilde;\":\"\",\"&Ograve\":\"\",\"&Ograve;\":\"\",\"&Oacute\":\"\",\"&Oacute;\":\"\",\"&Ocirc\":\"\",\"&Ocirc;\":\"\",\"&Otilde\":\"\",\"&Otilde;\":\"\",\"&Ouml\":\"\",\"&Ouml;\":\"\",\"&times\":\"\",\"&times;\":\"\",\"&Oslash\":\"\",\"&Oslash;\":\"\",\"&Ugrave\":\"\",\"&Ugrave;\":\"\",\"&Uacute\":\"\",\"&Uacute;\":\"\",\"&Ucirc\":\"\",\"&Ucirc;\":\"\",\"&Uuml\":\"\",\"&Uuml;\":\"\",\"&Yacute\":\"\",\"&Yacute;\":\"\",\"&THORN\":\"\",\"&THORN;\":\"\",\"&szlig\":\"\",\"&szlig;\":\"\",\"&agrave\":\"\",\"&agrave;\":\"\",\"&aacute\":\"\",\"&aacute;\":\"\",\"&acirc\":\"\",\"&acirc;\":\"\",\"&atilde\":\"\",\"&atilde;\":\"\",\"&auml\":\"\",\"&auml;\":\"\",\"&aring\":\"\",\"&aring;\":\"\",\"&aelig\":\"\",\"&aelig;\":\"\",\"&ccedil\":\"\",\"&ccedil;\":\"\",\"&egrave\":\"\",\"&egrave;\":\"\",\"&eacute\":\"\",\"&eacute;\":\"\",\"&ecirc\":\"\",\"&ecirc;\":\"\",\"&euml\":\"\",\"&euml;\":\"\",\"&igrave\":\"\",\"&igrave;\":\"\",\"&iacute\":\"\",\"&iacute;\":\"\",\"&icirc\":\"\",\"&icirc;\":\"\",\"&iuml\":\"\",\"&iuml;\":\"\",\"&eth\":\"\",\"&eth;\":\"\",\"&ntilde\":\"\",\"&ntilde;\":\"\",\"&ograve\":\"\",\"&ograve;\":\"\",\"&oacute\":\"\",\"&oacute;\":\"\",\"&ocirc\":\"\",\"&ocirc;\":\"\",\"&otilde\":\"\",\"&otilde;\":\"\",\"&ouml\":\"\",\"&ouml;\":\"\",\"&divide\":\"\",\"&divide;\":\"\",\"&oslash\":\"\",\"&oslash;\":\"\",\"&ugrave\":\"\",\"&ugrave;\":\"\",\"&uacute\":\"\",\"&uacute;\":\"\",\"&ucirc\":\"\",\"&ucirc;\":\"\",\"&uuml\":\"\",\"&uuml;\":\"\",\"&yacute\":\"\",\"&yacute;\":\"\",\"&thorn\":\"\",\"&thorn;\":\"\",\"&yuml\":\"\",\"&yuml;\":\"\",\"&quot\":'\"',\"&quot;\":'\"',\"&amp\":\"&\",\"&amp;\":\"&\",\"&lt\":\"<\",\"&lt;\":\"<\",\"&gt\":\">\",\"&gt;\":\">\",\"&OElig;\":\"\",\"&oelig;\":\"\",\"&Scaron;\":\"\",\"&scaron;\":\"\",\"&Yuml;\":\"\",\"&circ;\":\"\",\"&tilde;\":\"\",\"&ensp;\":\"\",\"&emsp;\":\"\",\"&thinsp;\":\"\",\"&zwnj;\":\"\",\"&zwj;\":\"\",\"&lrm;\":\"\",\"&rlm;\":\"\",\"&ndash;\":\"\",\"&mdash;\":\"\",\"&lsquo;\":\"\",\"&rsquo;\":\"\",\"&sbquo;\":\"\",\"&ldquo;\":\"\",\"&rdquo;\":\"\",\"&bdquo;\":\"\",\"&dagger;\":\"\",\"&Dagger;\":\"\",\"&permil;\":\"\",\"&lsaquo;\":\"\",\"&rsaquo;\":\"\",\"&euro;\":\"\",\"&fnof;\":\"\",\"&Alpha;\":\"\",\"&Beta;\":\"\",\"&Gamma;\":\"\",\"&Delta;\":\"\",\"&Epsilon;\":\"\",\"&Zeta;\":\"\",\"&Eta;\":\"\",\"&Theta;\":\"\",\"&Iota;\":\"\",\"&Kappa;\":\"\",\"&Lambda;\":\"\",\"&Mu;\":\"\",\"&Nu;\":\"\",\"&Xi;\":\"\",\"&Omicron;\":\"\",\"&Pi;\":\"\",\"&Rho;\":\"\",\"&Sigma;\":\"\",\"&Tau;\":\"\",\"&Upsilon;\":\"\",\"&Phi;\":\"\",\"&Chi;\":\"\",\"&Psi;\":\"\",\"&Omega;\":\"\",\"&alpha;\":\"\",\"&beta;\":\"\",\"&gamma;\":\"\",\"&delta;\":\"\",\"&epsilon;\":\"\",\"&zeta;\":\"\",\"&eta;\":\"\",\"&theta;\":\"\",\"&iota;\":\"\",\"&kappa;\":\"\",\"&lambda;\":\"\",\"&mu;\":\"\",\"&nu;\":\"\",\"&xi;\":\"\",\"&omicron;\":\"\",\"&pi;\":\"\",\"&rho;\":\"\",\"&sigmaf;\":\"\",\"&sigma;\":\"\",\"&tau;\":\"\",\"&upsilon;\":\"\",\"&phi;\":\"\",\"&chi;\":\"\",\"&psi;\":\"\",\"&omega;\":\"\",\"&thetasym;\":\"\",\"&upsih;\":\"\",\"&piv;\":\"\",\"&bull;\":\"\",\"&hellip;\":\"\",\"&prime;\":\"\",\"&Prime;\":\"\",\"&oline;\":\"\",\"&frasl;\":\"\",\"&weierp;\":\"\",\"&image;\":\"\",\"&real;\":\"\",\"&trade;\":\"\",\"&alefsym;\":\"\",\"&larr;\":\"\",\"&uarr;\":\"\",\"&rarr;\":\"\",\"&darr;\":\"\",\"&harr;\":\"\",\"&crarr;\":\"\",\"&lArr;\":\"\",\"&uArr;\":\"\",\"&rArr;\":\"\",\"&dArr;\":\"\",\"&hArr;\":\"\",\"&forall;\":\"\",\"&part;\":\"\",\"&exist;\":\"\",\"&empty;\":\"\",\"&nabla;\":\"\",\"&isin;\":\"\",\"&notin;\":\"\",\"&ni;\":\"\",\"&prod;\":\"\",\"&sum;\":\"\",\"&minus;\":\"\",\"&lowast;\":\"\",\"&radic;\":\"\",\"&prop;\":\"\",\"&infin;\":\"\",\"&ang;\":\"\",\"&and;\":\"\",\"&or;\":\"\",\"&cap;\":\"\",\"&cup;\":\"\",\"&int;\":\"\",\"&there4;\":\"\",\"&sim;\":\"\",\"&cong;\":\"\",\"&asymp;\":\"\",\"&ne;\":\"\",\"&equiv;\":\"\",\"&le;\":\"\",\"&ge;\":\"\",\"&sub;\":\"\",\"&sup;\":\"\",\"&nsub;\":\"\",\"&sube;\":\"\",\"&supe;\":\"\",\"&oplus;\":\"\",\"&otimes;\":\"\",\"&perp;\":\"\",\"&sdot;\":\"\",\"&lceil;\":\"\",\"&rceil;\":\"\",\"&lfloor;\":\"\",\"&rfloor;\":\"\",\"&lang;\":\"\",\"&rang;\":\"\",\"&loz;\":\"\",\"&spades;\":\"\",\"&clubs;\":\"\",\"&hearts;\":\"\",\"&diams;\":\"\"},characters:{\"'\":\"&apos;\",\"\":\"&nbsp;\",\"\":\"&iexcl;\",\"\":\"&cent;\",\"\":\"&pound;\",\"\":\"&curren;\",\"\":\"&yen;\",\"\":\"&brvbar;\",\"\":\"&sect;\",\"\":\"&uml;\",\"\":\"&copy;\",\"\":\"&ordf;\",\"\":\"&laquo;\",\"\":\"&not;\",\"\":\"&shy;\",\"\":\"&reg;\",\"\":\"&macr;\",\"\":\"&deg;\",\"\":\"&plusmn;\",\"\":\"&sup2;\",\"\":\"&sup3;\",\"\":\"&acute;\",\"\":\"&micro;\",\"\":\"&para;\",\"\":\"&middot;\",\"\":\"&cedil;\",\"\":\"&sup1;\",\"\":\"&ordm;\",\"\":\"&raquo;\",\"\":\"&frac14;\",\"\":\"&frac12;\",\"\":\"&frac34;\",\"\":\"&iquest;\",\"\":\"&Agrave;\",\"\":\"&Aacute;\",\"\":\"&Acirc;\",\"\":\"&Atilde;\",\"\":\"&Auml;\",\"\":\"&Aring;\",\"\":\"&AElig;\",\"\":\"&Ccedil;\",\"\":\"&Egrave;\",\"\":\"&Eacute;\",\"\":\"&Ecirc;\",\"\":\"&Euml;\",\"\":\"&Igrave;\",\"\":\"&Iacute;\",\"\":\"&Icirc;\",\"\":\"&Iuml;\",\"\":\"&ETH;\",\"\":\"&Ntilde;\",\"\":\"&Ograve;\",\"\":\"&Oacute;\",\"\":\"&Ocirc;\",\"\":\"&Otilde;\",\"\":\"&Ouml;\",\"\":\"&times;\",\"\":\"&Oslash;\",\"\":\"&Ugrave;\",\"\":\"&Uacute;\",\"\":\"&Ucirc;\",\"\":\"&Uuml;\",\"\":\"&Yacute;\",\"\":\"&THORN;\",\"\":\"&szlig;\",\"\":\"&agrave;\",\"\":\"&aacute;\",\"\":\"&acirc;\",\"\":\"&atilde;\",\"\":\"&auml;\",\"\":\"&aring;\",\"\":\"&aelig;\",\"\":\"&ccedil;\",\"\":\"&egrave;\",\"\":\"&eacute;\",\"\":\"&ecirc;\",\"\":\"&euml;\",\"\":\"&igrave;\",\"\":\"&iacute;\",\"\":\"&icirc;\",\"\":\"&iuml;\",\"\":\"&eth;\",\"\":\"&ntilde;\",\"\":\"&ograve;\",\"\":\"&oacute;\",\"\":\"&ocirc;\",\"\":\"&otilde;\",\"\":\"&ouml;\",\"\":\"&divide;\",\"\":\"&oslash;\",\"\":\"&ugrave;\",\"\":\"&uacute;\",\"\":\"&ucirc;\",\"\":\"&uuml;\",\"\":\"&yacute;\",\"\":\"&thorn;\",\"\":\"&yuml;\",'\"':\"&quot;\",\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",\"\":\"&OElig;\",\"\":\"&oelig;\",\"\":\"&Scaron;\",\"\":\"&scaron;\",\"\":\"&Yuml;\",\"\":\"&circ;\",\"\":\"&tilde;\",\"\":\"&ensp;\",\"\":\"&emsp;\",\"\":\"&thinsp;\",\"\":\"&zwnj;\",\"\":\"&zwj;\",\"\":\"&lrm;\",\"\":\"&rlm;\",\"\":\"&ndash;\",\"\":\"&mdash;\",\"\":\"&lsquo;\",\"\":\"&rsquo;\",\"\":\"&sbquo;\",\"\":\"&ldquo;\",\"\":\"&rdquo;\",\"\":\"&bdquo;\",\"\":\"&dagger;\",\"\":\"&Dagger;\",\"\":\"&permil;\",\"\":\"&lsaquo;\",\"\":\"&rsaquo;\",\"\":\"&euro;\",\"\":\"&fnof;\",\"\":\"&Alpha;\",\"\":\"&Beta;\",\"\":\"&Gamma;\",\"\":\"&Delta;\",\"\":\"&Epsilon;\",\"\":\"&Zeta;\",\"\":\"&Eta;\",\"\":\"&Theta;\",\"\":\"&Iota;\",\"\":\"&Kappa;\",\"\":\"&Lambda;\",\"\":\"&Mu;\",\"\":\"&Nu;\",\"\":\"&Xi;\",\"\":\"&Omicron;\",\"\":\"&Pi;\",\"\":\"&Rho;\",\"\":\"&Sigma;\",\"\":\"&Tau;\",\"\":\"&Upsilon;\",\"\":\"&Phi;\",\"\":\"&Chi;\",\"\":\"&Psi;\",\"\":\"&Omega;\",\"\":\"&alpha;\",\"\":\"&beta;\",\"\":\"&gamma;\",\"\":\"&delta;\",\"\":\"&epsilon;\",\"\":\"&zeta;\",\"\":\"&eta;\",\"\":\"&theta;\",\"\":\"&iota;\",\"\":\"&kappa;\",\"\":\"&lambda;\",\"\":\"&mu;\",\"\":\"&nu;\",\"\":\"&xi;\",\"\":\"&omicron;\",\"\":\"&pi;\",\"\":\"&rho;\",\"\":\"&sigmaf;\",\"\":\"&sigma;\",\"\":\"&tau;\",\"\":\"&upsilon;\",\"\":\"&phi;\",\"\":\"&chi;\",\"\":\"&psi;\",\"\":\"&omega;\",\"\":\"&thetasym;\",\"\":\"&upsih;\",\"\":\"&piv;\",\"\":\"&bull;\",\"\":\"&hellip;\",\"\":\"&prime;\",\"\":\"&Prime;\",\"\":\"&oline;\",\"\":\"&frasl;\",\"\":\"&weierp;\",\"\":\"&image;\",\"\":\"&real;\",\"\":\"&trade;\",\"\":\"&alefsym;\",\"\":\"&larr;\",\"\":\"&uarr;\",\"\":\"&rarr;\",\"\":\"&darr;\",\"\":\"&harr;\",\"\":\"&crarr;\",\"\":\"&lArr;\",\"\":\"&uArr;\",\"\":\"&rArr;\",\"\":\"&dArr;\",\"\":\"&hArr;\",\"\":\"&forall;\",\"\":\"&part;\",\"\":\"&exist;\",\"\":\"&empty;\",\"\":\"&nabla;\",\"\":\"&isin;\",\"\":\"&notin;\",\"\":\"&ni;\",\"\":\"&prod;\",\"\":\"&sum;\",\"\":\"&minus;\",\"\":\"&lowast;\",\"\":\"&radic;\",\"\":\"&prop;\",\"\":\"&infin;\",\"\":\"&ang;\",\"\":\"&and;\",\"\":\"&or;\",\"\":\"&cap;\",\"\":\"&cup;\",\"\":\"&int;\",\"\":\"&there4;\",\"\":\"&sim;\",\"\":\"&cong;\",\"\":\"&asymp;\",\"\":\"&ne;\",\"\":\"&equiv;\",\"\":\"&le;\",\"\":\"&ge;\",\"\":\"&sub;\",\"\":\"&sup;\",\"\":\"&nsub;\",\"\":\"&sube;\",\"\":\"&supe;\",\"\":\"&oplus;\",\"\":\"&otimes;\",\"\":\"&perp;\",\"\":\"&sdot;\",\"\":\"&lceil;\",\"\":\"&rceil;\",\"\":\"&lfloor;\",\"\":\"&rfloor;\",\"\":\"&lang;\",\"\":\"&rang;\",\"\":\"&loz;\",\"\":\"&spades;\",\"\":\"&clubs;\",\"\":\"&hearts;\",\"\":\"&diams;\"}},html5:{entities:{\"&AElig\":\"\",\"&AElig;\":\"\",\"&AMP\":\"&\",\"&AMP;\":\"&\",\"&Aacute\":\"\",\"&Aacute;\":\"\",\"&Abreve;\":\"\",\"&Acirc\":\"\",\"&Acirc;\":\"\",\"&Acy;\":\"\",\"&Afr;\":\"\",\"&Agrave\":\"\",\"&Agrave;\":\"\",\"&Alpha;\":\"\",\"&Amacr;\":\"\",\"&And;\":\"\",\"&Aogon;\":\"\",\"&Aopf;\":\"\",\"&ApplyFunction;\":\"\",\"&Aring\":\"\",\"&Aring;\":\"\",\"&Ascr;\":\"\",\"&Assign;\":\"\",\"&Atilde\":\"\",\"&Atilde;\":\"\",\"&Auml\":\"\",\"&Auml;\":\"\",\"&Backslash;\":\"\",\"&Barv;\":\"\",\"&Barwed;\":\"\",\"&Bcy;\":\"\",\"&Because;\":\"\",\"&Bernoullis;\":\"\",\"&Beta;\":\"\",\"&Bfr;\":\"\",\"&Bopf;\":\"\",\"&Breve;\":\"\",\"&Bscr;\":\"\",\"&Bumpeq;\":\"\",\"&CHcy;\":\"\",\"&COPY\":\"\",\"&COPY;\":\"\",\"&Cacute;\":\"\",\"&Cap;\":\"\",\"&CapitalDifferentialD;\":\"\",\"&Cayleys;\":\"\",\"&Ccaron;\":\"\",\"&Ccedil\":\"\",\"&Ccedil;\":\"\",\"&Ccirc;\":\"\",\"&Cconint;\":\"\",\"&Cdot;\":\"\",\"&Cedilla;\":\"\",\"&CenterDot;\":\"\",\"&Cfr;\":\"\",\"&Chi;\":\"\",\"&CircleDot;\":\"\",\"&CircleMinus;\":\"\",\"&CirclePlus;\":\"\",\"&CircleTimes;\":\"\",\"&ClockwiseContourIntegral;\":\"\",\"&CloseCurlyDoubleQuote;\":\"\",\"&CloseCurlyQuote;\":\"\",\"&Colon;\":\"\",\"&Colone;\":\"\",\"&Congruent;\":\"\",\"&Conint;\":\"\",\"&ContourIntegral;\":\"\",\"&Copf;\":\"\",\"&Coproduct;\":\"\",\"&CounterClockwiseContourIntegral;\":\"\",\"&Cross;\":\"\",\"&Cscr;\":\"\",\"&Cup;\":\"\",\"&CupCap;\":\"\",\"&DD;\":\"\",\"&DDotrahd;\":\"\",\"&DJcy;\":\"\",\"&DScy;\":\"\",\"&DZcy;\":\"\",\"&Dagger;\":\"\",\"&Darr;\":\"\",\"&Dashv;\":\"\",\"&Dcaron;\":\"\",\"&Dcy;\":\"\",\"&Del;\":\"\",\"&Delta;\":\"\",\"&Dfr;\":\"\",\"&DiacriticalAcute;\":\"\",\"&DiacriticalDot;\":\"\",\"&DiacriticalDoubleAcute;\":\"\",\"&DiacriticalGrave;\":\"`\",\"&DiacriticalTilde;\":\"\",\"&Diamond;\":\"\",\"&DifferentialD;\":\"\",\"&Dopf;\":\"\",\"&Dot;\":\"\",\"&DotDot;\":\"\",\"&DotEqual;\":\"\",\"&DoubleContourIntegral;\":\"\",\"&DoubleDot;\":\"\",\"&DoubleDownArrow;\":\"\",\"&DoubleLeftArrow;\":\"\",\"&DoubleLeftRightArrow;\":\"\",\"&DoubleLeftTee;\":\"\",\"&DoubleLongLeftArrow;\":\"\",\"&DoubleLongLeftRightArrow;\":\"\",\"&DoubleLongRightArrow;\":\"\",\"&DoubleRightArrow;\":\"\",\"&DoubleRightTee;\":\"\",\"&DoubleUpArrow;\":\"\",\"&DoubleUpDownArrow;\":\"\",\"&DoubleVerticalBar;\":\"\",\"&DownArrow;\":\"\",\"&DownArrowBar;\":\"\",\"&DownArrowUpArrow;\":\"\",\"&DownBreve;\":\"\",\"&DownLeftRightVector;\":\"\",\"&DownLeftTeeVector;\":\"\",\"&DownLeftVector;\":\"\",\"&DownLeftVectorBar;\":\"\",\"&DownRightTeeVector;\":\"\",\"&DownRightVector;\":\"\",\"&DownRightVectorBar;\":\"\",\"&DownTee;\":\"\",\"&DownTeeArrow;\":\"\",\"&Downarrow;\":\"\",\"&Dscr;\":\"\",\"&Dstrok;\":\"\",\"&ENG;\":\"\",\"&ETH\":\"\",\"&ETH;\":\"\",\"&Eacute\":\"\",\"&Eacute;\":\"\",\"&Ecaron;\":\"\",\"&Ecirc\":\"\",\"&Ecirc;\":\"\",\"&Ecy;\":\"\",\"&Edot;\":\"\",\"&Efr;\":\"\",\"&Egrave\":\"\",\"&Egrave;\":\"\",\"&Element;\":\"\",\"&Emacr;\":\"\",\"&EmptySmallSquare;\":\"\",\"&EmptyVerySmallSquare;\":\"\",\"&Eogon;\":\"\",\"&Eopf;\":\"\",\"&Epsilon;\":\"\",\"&Equal;\":\"\",\"&EqualTilde;\":\"\",\"&Equilibrium;\":\"\",\"&Escr;\":\"\",\"&Esim;\":\"\",\"&Eta;\":\"\",\"&Euml\":\"\",\"&Euml;\":\"\",\"&Exists;\":\"\",\"&ExponentialE;\":\"\",\"&Fcy;\":\"\",\"&Ffr;\":\"\",\"&FilledSmallSquare;\":\"\",\"&FilledVerySmallSquare;\":\"\",\"&Fopf;\":\"\",\"&ForAll;\":\"\",\"&Fouriertrf;\":\"\",\"&Fscr;\":\"\",\"&GJcy;\":\"\",\"&GT\":\">\",\"&GT;\":\">\",\"&Gamma;\":\"\",\"&Gammad;\":\"\",\"&Gbreve;\":\"\",\"&Gcedil;\":\"\",\"&Gcirc;\":\"\",\"&Gcy;\":\"\",\"&Gdot;\":\"\",\"&Gfr;\":\"\",\"&Gg;\":\"\",\"&Gopf;\":\"\",\"&GreaterEqual;\":\"\",\"&GreaterEqualLess;\":\"\",\"&GreaterFullEqual;\":\"\",\"&GreaterGreater;\":\"\",\"&GreaterLess;\":\"\",\"&GreaterSlantEqual;\":\"\",\"&GreaterTilde;\":\"\",\"&Gscr;\":\"\",\"&Gt;\":\"\",\"&HARDcy;\":\"\",\"&Hacek;\":\"\",\"&Hat;\":\"^\",\"&Hcirc;\":\"\",\"&Hfr;\":\"\",\"&HilbertSpace;\":\"\",\"&Hopf;\":\"\",\"&HorizontalLine;\":\"\",\"&Hscr;\":\"\",\"&Hstrok;\":\"\",\"&HumpDownHump;\":\"\",\"&HumpEqual;\":\"\",\"&IEcy;\":\"\",\"&IJlig;\":\"\",\"&IOcy;\":\"\",\"&Iacute\":\"\",\"&Iacute;\":\"\",\"&Icirc\":\"\",\"&Icirc;\":\"\",\"&Icy;\":\"\",\"&Idot;\":\"\",\"&Ifr;\":\"\",\"&Igrave\":\"\",\"&Igrave;\":\"\",\"&Im;\":\"\",\"&Imacr;\":\"\",\"&ImaginaryI;\":\"\",\"&Implies;\":\"\",\"&Int;\":\"\",\"&Integral;\":\"\",\"&Intersection;\":\"\",\"&InvisibleComma;\":\"\",\"&InvisibleTimes;\":\"\",\"&Iogon;\":\"\",\"&Iopf;\":\"\",\"&Iota;\":\"\",\"&Iscr;\":\"\",\"&Itilde;\":\"\",\"&Iukcy;\":\"\",\"&Iuml\":\"\",\"&Iuml;\":\"\",\"&Jcirc;\":\"\",\"&Jcy;\":\"\",\"&Jfr;\":\"\",\"&Jopf;\":\"\",\"&Jscr;\":\"\",\"&Jsercy;\":\"\",\"&Jukcy;\":\"\",\"&KHcy;\":\"\",\"&KJcy;\":\"\",\"&Kappa;\":\"\",\"&Kcedil;\":\"\",\"&Kcy;\":\"\",\"&Kfr;\":\"\",\"&Kopf;\":\"\",\"&Kscr;\":\"\",\"&LJcy;\":\"\",\"&LT\":\"<\",\"&LT;\":\"<\",\"&Lacute;\":\"\",\"&Lambda;\":\"\",\"&Lang;\":\"\",\"&Laplacetrf;\":\"\",\"&Larr;\":\"\",\"&Lcaron;\":\"\",\"&Lcedil;\":\"\",\"&Lcy;\":\"\",\"&LeftAngleBracket;\":\"\",\"&LeftArrow;\":\"\",\"&LeftArrowBar;\":\"\",\"&LeftArrowRightArrow;\":\"\",\"&LeftCeiling;\":\"\",\"&LeftDoubleBracket;\":\"\",\"&LeftDownTeeVector;\":\"\",\"&LeftDownVector;\":\"\",\"&LeftDownVectorBar;\":\"\",\"&LeftFloor;\":\"\",\"&LeftRightArrow;\":\"\",\"&LeftRightVector;\":\"\",\"&LeftTee;\":\"\",\"&LeftTeeArrow;\":\"\",\"&LeftTeeVector;\":\"\",\"&LeftTriangle;\":\"\",\"&LeftTriangleBar;\":\"\",\"&LeftTriangleEqual;\":\"\",\"&LeftUpDownVector;\":\"\",\"&LeftUpTeeVector;\":\"\",\"&LeftUpVector;\":\"\",\"&LeftUpVectorBar;\":\"\",\"&LeftVector;\":\"\",\"&LeftVectorBar;\":\"\",\"&Leftarrow;\":\"\",\"&Leftrightarrow;\":\"\",\"&LessEqualGreater;\":\"\",\"&LessFullEqual;\":\"\",\"&LessGreater;\":\"\",\"&LessLess;\":\"\",\"&LessSlantEqual;\":\"\",\"&LessTilde;\":\"\",\"&Lfr;\":\"\",\"&Ll;\":\"\",\"&Lleftarrow;\":\"\",\"&Lmidot;\":\"\",\"&LongLeftArrow;\":\"\",\"&LongLeftRightArrow;\":\"\",\"&LongRightArrow;\":\"\",\"&Longleftarrow;\":\"\",\"&Longleftrightarrow;\":\"\",\"&Longrightarrow;\":\"\",\"&Lopf;\":\"\",\"&LowerLeftArrow;\":\"\",\"&LowerRightArrow;\":\"\",\"&Lscr;\":\"\",\"&Lsh;\":\"\",\"&Lstrok;\":\"\",\"&Lt;\":\"\",\"&Map;\":\"\",\"&Mcy;\":\"\",\"&MediumSpace;\":\"\",\"&Mellintrf;\":\"\",\"&Mfr;\":\"\",\"&MinusPlus;\":\"\",\"&Mopf;\":\"\",\"&Mscr;\":\"\",\"&Mu;\":\"\",\"&NJcy;\":\"\",\"&Nacute;\":\"\",\"&Ncaron;\":\"\",\"&Ncedil;\":\"\",\"&Ncy;\":\"\",\"&NegativeMediumSpace;\":\"\",\"&NegativeThickSpace;\":\"\",\"&NegativeThinSpace;\":\"\",\"&NegativeVeryThinSpace;\":\"\",\"&NestedGreaterGreater;\":\"\",\"&NestedLessLess;\":\"\",\"&NewLine;\":\"\\n\",\"&Nfr;\":\"\",\"&NoBreak;\":\"\",\"&NonBreakingSpace;\":\"\",\"&Nopf;\":\"\",\"&Not;\":\"\",\"&NotCongruent;\":\"\",\"&NotCupCap;\":\"\",\"&NotDoubleVerticalBar;\":\"\",\"&NotElement;\":\"\",\"&NotEqual;\":\"\",\"&NotEqualTilde;\":\"\",\"&NotExists;\":\"\",\"&NotGreater;\":\"\",\"&NotGreaterEqual;\":\"\",\"&NotGreaterFullEqual;\":\"\",\"&NotGreaterGreater;\":\"\",\"&NotGreaterLess;\":\"\",\"&NotGreaterSlantEqual;\":\"\",\"&NotGreaterTilde;\":\"\",\"&NotHumpDownHump;\":\"\",\"&NotHumpEqual;\":\"\",\"&NotLeftTriangle;\":\"\",\"&NotLeftTriangleBar;\":\"\",\"&NotLeftTriangleEqual;\":\"\",\"&NotLess;\":\"\",\"&NotLessEqual;\":\"\",\"&NotLessGreater;\":\"\",\"&NotLessLess;\":\"\",\"&NotLessSlantEqual;\":\"\",\"&NotLessTilde;\":\"\",\"&NotNestedGreaterGreater;\":\"\",\"&NotNestedLessLess;\":\"\",\"&NotPrecedes;\":\"\",\"&NotPrecedesEqual;\":\"\",\"&NotPrecedesSlantEqual;\":\"\",\"&NotReverseElement;\":\"\",\"&NotRightTriangle;\":\"\",\"&NotRightTriangleBar;\":\"\",\"&NotRightTriangleEqual;\":\"\",\"&NotSquareSubset;\":\"\",\"&NotSquareSubsetEqual;\":\"\",\"&NotSquareSuperset;\":\"\",\"&NotSquareSupersetEqual;\":\"\",\"&NotSubset;\":\"\",\"&NotSubsetEqual;\":\"\",\"&NotSucceeds;\":\"\",\"&NotSucceedsEqual;\":\"\",\"&NotSucceedsSlantEqual;\":\"\",\"&NotSucceedsTilde;\":\"\",\"&NotSuperset;\":\"\",\"&NotSupersetEqual;\":\"\",\"&NotTilde;\":\"\",\"&NotTildeEqual;\":\"\",\"&NotTildeFullEqual;\":\"\",\"&NotTildeTilde;\":\"\",\"&NotVerticalBar;\":\"\",\"&Nscr;\":\"\",\"&Ntilde\":\"\",\"&Ntilde;\":\"\",\"&Nu;\":\"\",\"&OElig;\":\"\",\"&Oacute\":\"\",\"&Oacute;\":\"\",\"&Ocirc\":\"\",\"&Ocirc;\":\"\",\"&Ocy;\":\"\",\"&Odblac;\":\"\",\"&Ofr;\":\"\",\"&Ograve\":\"\",\"&Ograve;\":\"\",\"&Omacr;\":\"\",\"&Omega;\":\"\",\"&Omicron;\":\"\",\"&Oopf;\":\"\",\"&OpenCurlyDoubleQuote;\":\"\",\"&OpenCurlyQuote;\":\"\",\"&Or;\":\"\",\"&Oscr;\":\"\",\"&Oslash\":\"\",\"&Oslash;\":\"\",\"&Otilde\":\"\",\"&Otilde;\":\"\",\"&Otimes;\":\"\",\"&Ouml\":\"\",\"&Ouml;\":\"\",\"&OverBar;\":\"\",\"&OverBrace;\":\"\",\"&OverBracket;\":\"\",\"&OverParenthesis;\":\"\",\"&PartialD;\":\"\",\"&Pcy;\":\"\",\"&Pfr;\":\"\",\"&Phi;\":\"\",\"&Pi;\":\"\",\"&PlusMinus;\":\"\",\"&Poincareplane;\":\"\",\"&Popf;\":\"\",\"&Pr;\":\"\",\"&Precedes;\":\"\",\"&PrecedesEqual;\":\"\",\"&PrecedesSlantEqual;\":\"\",\"&PrecedesTilde;\":\"\",\"&Prime;\":\"\",\"&Product;\":\"\",\"&Proportion;\":\"\",\"&Proportional;\":\"\",\"&Pscr;\":\"\",\"&Psi;\":\"\",\"&QUOT\":'\"',\"&QUOT;\":'\"',\"&Qfr;\":\"\",\"&Qopf;\":\"\",\"&Qscr;\":\"\",\"&RBarr;\":\"\",\"&REG\":\"\",\"&REG;\":\"\",\"&Racute;\":\"\",\"&Rang;\":\"\",\"&Rarr;\":\"\",\"&Rarrtl;\":\"\",\"&Rcaron;\":\"\",\"&Rcedil;\":\"\",\"&Rcy;\":\"\",\"&Re;\":\"\",\"&ReverseElement;\":\"\",\"&ReverseEquilibrium;\":\"\",\"&ReverseUpEquilibrium;\":\"\",\"&Rfr;\":\"\",\"&Rho;\":\"\",\"&RightAngleBracket;\":\"\",\"&RightArrow;\":\"\",\"&RightArrowBar;\":\"\",\"&RightArrowLeftArrow;\":\"\",\"&RightCeiling;\":\"\",\"&RightDoubleBracket;\":\"\",\"&RightDownTeeVector;\":\"\",\"&RightDownVector;\":\"\",\"&RightDownVectorBar;\":\"\",\"&RightFloor;\":\"\",\"&RightTee;\":\"\",\"&RightTeeArrow;\":\"\",\"&RightTeeVector;\":\"\",\"&RightTriangle;\":\"\",\"&RightTriangleBar;\":\"\",\"&RightTriangleEqual;\":\"\",\"&RightUpDownVector;\":\"\",\"&RightUpTeeVector;\":\"\",\"&RightUpVector;\":\"\",\"&RightUpVectorBar;\":\"\",\"&RightVector;\":\"\",\"&RightVectorBar;\":\"\",\"&Rightarrow;\":\"\",\"&Ropf;\":\"\",\"&RoundImplies;\":\"\",\"&Rrightarrow;\":\"\",\"&Rscr;\":\"\",\"&Rsh;\":\"\",\"&RuleDelayed;\":\"\",\"&SHCHcy;\":\"\",\"&SHcy;\":\"\",\"&SOFTcy;\":\"\",\"&Sacute;\":\"\",\"&Sc;\":\"\",\"&Scaron;\":\"\",\"&Scedil;\":\"\",\"&Scirc;\":\"\",\"&Scy;\":\"\",\"&Sfr;\":\"\",\"&ShortDownArrow;\":\"\",\"&ShortLeftArrow;\":\"\",\"&ShortRightArrow;\":\"\",\"&ShortUpArrow;\":\"\",\"&Sigma;\":\"\",\"&SmallCircle;\":\"\",\"&Sopf;\":\"\",\"&Sqrt;\":\"\",\"&Square;\":\"\",\"&SquareIntersection;\":\"\",\"&SquareSubset;\":\"\",\"&SquareSubsetEqual;\":\"\",\"&SquareSuperset;\":\"\",\"&SquareSupersetEqual;\":\"\",\"&SquareUnion;\":\"\",\"&Sscr;\":\"\",\"&Star;\":\"\",\"&Sub;\":\"\",\"&Subset;\":\"\",\"&SubsetEqual;\":\"\",\"&Succeeds;\":\"\",\"&SucceedsEqual;\":\"\",\"&SucceedsSlantEqual;\":\"\",\"&SucceedsTilde;\":\"\",\"&SuchThat;\":\"\",\"&Sum;\":\"\",\"&Sup;\":\"\",\"&Superset;\":\"\",\"&SupersetEqual;\":\"\",\"&Supset;\":\"\",\"&THORN\":\"\",\"&THORN;\":\"\",\"&TRADE;\":\"\",\"&TSHcy;\":\"\",\"&TScy;\":\"\",\"&Tab;\":\"\\t\",\"&Tau;\":\"\",\"&Tcaron;\":\"\",\"&Tcedil;\":\"\",\"&Tcy;\":\"\",\"&Tfr;\":\"\",\"&Therefore;\":\"\",\"&Theta;\":\"\",\"&ThickSpace;\":\"\",\"&ThinSpace;\":\"\",\"&Tilde;\":\"\",\"&TildeEqual;\":\"\",\"&TildeFullEqual;\":\"\",\"&TildeTilde;\":\"\",\"&Topf;\":\"\",\"&TripleDot;\":\"\",\"&Tscr;\":\"\",\"&Tstrok;\":\"\",\"&Uacute\":\"\",\"&Uacute;\":\"\",\"&Uarr;\":\"\",\"&Uarrocir;\":\"\",\"&Ubrcy;\":\"\",\"&Ubreve;\":\"\",\"&Ucirc\":\"\",\"&Ucirc;\":\"\",\"&Ucy;\":\"\",\"&Udblac;\":\"\",\"&Ufr;\":\"\",\"&Ugrave\":\"\",\"&Ugrave;\":\"\",\"&Umacr;\":\"\",\"&UnderBar;\":\"_\",\"&UnderBrace;\":\"\",\"&UnderBracket;\":\"\",\"&UnderParenthesis;\":\"\",\"&Union;\":\"\",\"&UnionPlus;\":\"\",\"&Uogon;\":\"\",\"&Uopf;\":\"\",\"&UpArrow;\":\"\",\"&UpArrowBar;\":\"\",\"&UpArrowDownArrow;\":\"\",\"&UpDownArrow;\":\"\",\"&UpEquilibrium;\":\"\",\"&UpTee;\":\"\",\"&UpTeeArrow;\":\"\",\"&Uparrow;\":\"\",\"&Updownarrow;\":\"\",\"&UpperLeftArrow;\":\"\",\"&UpperRightArrow;\":\"\",\"&Upsi;\":\"\",\"&Upsilon;\":\"\",\"&Uring;\":\"\",\"&Uscr;\":\"\",\"&Utilde;\":\"\",\"&Uuml\":\"\",\"&Uuml;\":\"\",\"&VDash;\":\"\",\"&Vbar;\":\"\",\"&Vcy;\":\"\",\"&Vdash;\":\"\",\"&Vdashl;\":\"\",\"&Vee;\":\"\",\"&Verbar;\":\"\",\"&Vert;\":\"\",\"&VerticalBar;\":\"\",\"&VerticalLine;\":\"|\",\"&VerticalSeparator;\":\"\",\"&VerticalTilde;\":\"\",\"&VeryThinSpace;\":\"\",\"&Vfr;\":\"\",\"&Vopf;\":\"\",\"&Vscr;\":\"\",\"&Vvdash;\":\"\",\"&Wcirc;\":\"\",\"&Wedge;\":\"\",\"&Wfr;\":\"\",\"&Wopf;\":\"\",\"&Wscr;\":\"\",\"&Xfr;\":\"\",\"&Xi;\":\"\",\"&Xopf;\":\"\",\"&Xscr;\":\"\",\"&YAcy;\":\"\",\"&YIcy;\":\"\",\"&YUcy;\":\"\",\"&Yacute\":\"\",\"&Yacute;\":\"\",\"&Ycirc;\":\"\",\"&Ycy;\":\"\",\"&Yfr;\":\"\",\"&Yopf;\":\"\",\"&Yscr;\":\"\",\"&Yuml;\":\"\",\"&ZHcy;\":\"\",\"&Zacute;\":\"\",\"&Zcaron;\":\"\",\"&Zcy;\":\"\",\"&Zdot;\":\"\",\"&ZeroWidthSpace;\":\"\",\"&Zeta;\":\"\",\"&Zfr;\":\"\",\"&Zopf;\":\"\",\"&Zscr;\":\"\",\"&aacute\":\"\",\"&aacute;\":\"\",\"&abreve;\":\"\",\"&ac;\":\"\",\"&acE;\":\"\",\"&acd;\":\"\",\"&acirc\":\"\",\"&acirc;\":\"\",\"&acute\":\"\",\"&acute;\":\"\",\"&acy;\":\"\",\"&aelig\":\"\",\"&aelig;\":\"\",\"&af;\":\"\",\"&afr;\":\"\",\"&agrave\":\"\",\"&agrave;\":\"\",\"&alefsym;\":\"\",\"&aleph;\":\"\",\"&alpha;\":\"\",\"&amacr;\":\"\",\"&amalg;\":\"\",\"&amp\":\"&\",\"&amp;\":\"&\",\"&and;\":\"\",\"&andand;\":\"\",\"&andd;\":\"\",\"&andslope;\":\"\",\"&andv;\":\"\",\"&ang;\":\"\",\"&ange;\":\"\",\"&angle;\":\"\",\"&angmsd;\":\"\",\"&angmsdaa;\":\"\",\"&angmsdab;\":\"\",\"&angmsdac;\":\"\",\"&angmsdad;\":\"\",\"&angmsdae;\":\"\",\"&angmsdaf;\":\"\",\"&angmsdag;\":\"\",\"&angmsdah;\":\"\",\"&angrt;\":\"\",\"&angrtvb;\":\"\",\"&angrtvbd;\":\"\",\"&angsph;\":\"\",\"&angst;\":\"\",\"&angzarr;\":\"\",\"&aogon;\":\"\",\"&aopf;\":\"\",\"&ap;\":\"\",\"&apE;\":\"\",\"&apacir;\":\"\",\"&ape;\":\"\",\"&apid;\":\"\",\"&apos;\":\"'\",\"&approx;\":\"\",\"&approxeq;\":\"\",\"&aring\":\"\",\"&aring;\":\"\",\"&ascr;\":\"\",\"&ast;\":\"*\",\"&asymp;\":\"\",\"&asympeq;\":\"\",\"&atilde\":\"\",\"&atilde;\":\"\",\"&auml\":\"\",\"&auml;\":\"\",\"&awconint;\":\"\",\"&awint;\":\"\",\"&bNot;\":\"\",\"&backcong;\":\"\",\"&backepsilon;\":\"\",\"&backprime;\":\"\",\"&backsim;\":\"\",\"&backsimeq;\":\"\",\"&barvee;\":\"\",\"&barwed;\":\"\",\"&barwedge;\":\"\",\"&bbrk;\":\"\",\"&bbrktbrk;\":\"\",\"&bcong;\":\"\",\"&bcy;\":\"\",\"&bdquo;\":\"\",\"&becaus;\":\"\",\"&because;\":\"\",\"&bemptyv;\":\"\",\"&bepsi;\":\"\",\"&bernou;\":\"\",\"&beta;\":\"\",\"&beth;\":\"\",\"&between;\":\"\",\"&bfr;\":\"\",\"&bigcap;\":\"\",\"&bigcirc;\":\"\",\"&bigcup;\":\"\",\"&bigodot;\":\"\",\"&bigoplus;\":\"\",\"&bigotimes;\":\"\",\"&bigsqcup;\":\"\",\"&bigstar;\":\"\",\"&bigtriangledown;\":\"\",\"&bigtriangleup;\":\"\",\"&biguplus;\":\"\",\"&bigvee;\":\"\",\"&bigwedge;\":\"\",\"&bkarow;\":\"\",\"&blacklozenge;\":\"\",\"&blacksquare;\":\"\",\"&blacktriangle;\":\"\",\"&blacktriangledown;\":\"\",\"&blacktriangleleft;\":\"\",\"&blacktriangleright;\":\"\",\"&blank;\":\"\",\"&blk12;\":\"\",\"&blk14;\":\"\",\"&blk34;\":\"\",\"&block;\":\"\",\"&bne;\":\"=\",\"&bnequiv;\":\"\",\"&bnot;\":\"\",\"&bopf;\":\"\",\"&bot;\":\"\",\"&bottom;\":\"\",\"&bowtie;\":\"\",\"&boxDL;\":\"\",\"&boxDR;\":\"\",\"&boxDl;\":\"\",\"&boxDr;\":\"\",\"&boxH;\":\"\",\"&boxHD;\":\"\",\"&boxHU;\":\"\",\"&boxHd;\":\"\",\"&boxHu;\":\"\",\"&boxUL;\":\"\",\"&boxUR;\":\"\",\"&boxUl;\":\"\",\"&boxUr;\":\"\",\"&boxV;\":\"\",\"&boxVH;\":\"\",\"&boxVL;\":\"\",\"&boxVR;\":\"\",\"&boxVh;\":\"\",\"&boxVl;\":\"\",\"&boxVr;\":\"\",\"&boxbox;\":\"\",\"&boxdL;\":\"\",\"&boxdR;\":\"\",\"&boxdl;\":\"\",\"&boxdr;\":\"\",\"&boxh;\":\"\",\"&boxhD;\":\"\",\"&boxhU;\":\"\",\"&boxhd;\":\"\",\"&boxhu;\":\"\",\"&boxminus;\":\"\",\"&boxplus;\":\"\",\"&boxtimes;\":\"\",\"&boxuL;\":\"\",\"&boxuR;\":\"\",\"&boxul;\":\"\",\"&boxur;\":\"\",\"&boxv;\":\"\",\"&boxvH;\":\"\",\"&boxvL;\":\"\",\"&boxvR;\":\"\",\"&boxvh;\":\"\",\"&boxvl;\":\"\",\"&boxvr;\":\"\",\"&bprime;\":\"\",\"&breve;\":\"\",\"&brvbar\":\"\",\"&brvbar;\":\"\",\"&bscr;\":\"\",\"&bsemi;\":\"\",\"&bsim;\":\"\",\"&bsime;\":\"\",\"&bsol;\":\"\\\\\",\"&bsolb;\":\"\",\"&bsolhsub;\":\"\",\"&bull;\":\"\",\"&bullet;\":\"\",\"&bump;\":\"\",\"&bumpE;\":\"\",\"&bumpe;\":\"\",\"&bumpeq;\":\"\",\"&cacute;\":\"\",\"&cap;\":\"\",\"&capand;\":\"\",\"&capbrcup;\":\"\",\"&capcap;\":\"\",\"&capcup;\":\"\",\"&capdot;\":\"\",\"&caps;\":\"\",\"&caret;\":\"\",\"&caron;\":\"\",\"&ccaps;\":\"\",\"&ccaron;\":\"\",\"&ccedil\":\"\",\"&ccedil;\":\"\",\"&ccirc;\":\"\",\"&ccups;\":\"\",\"&ccupssm;\":\"\",\"&cdot;\":\"\",\"&cedil\":\"\",\"&cedil;\":\"\",\"&cemptyv;\":\"\",\"&cent\":\"\",\"&cent;\":\"\",\"&centerdot;\":\"\",\"&cfr;\":\"\",\"&chcy;\":\"\",\"&check;\":\"\",\"&checkmark;\":\"\",\"&chi;\":\"\",\"&cir;\":\"\",\"&cirE;\":\"\",\"&circ;\":\"\",\"&circeq;\":\"\",\"&circlearrowleft;\":\"\",\"&circlearrowright;\":\"\",\"&circledR;\":\"\",\"&circledS;\":\"\",\"&circledast;\":\"\",\"&circledcirc;\":\"\",\"&circleddash;\":\"\",\"&cire;\":\"\",\"&cirfnint;\":\"\",\"&cirmid;\":\"\",\"&cirscir;\":\"\",\"&clubs;\":\"\",\"&clubsuit;\":\"\",\"&colon;\":\":\",\"&colone;\":\"\",\"&coloneq;\":\"\",\"&comma;\":\",\",\"&commat;\":\"@\",\"&comp;\":\"\",\"&compfn;\":\"\",\"&complement;\":\"\",\"&complexes;\":\"\",\"&cong;\":\"\",\"&congdot;\":\"\",\"&conint;\":\"\",\"&copf;\":\"\",\"&coprod;\":\"\",\"&copy\":\"\",\"&copy;\":\"\",\"&copysr;\":\"\",\"&crarr;\":\"\",\"&cross;\":\"\",\"&cscr;\":\"\",\"&csub;\":\"\",\"&csube;\":\"\",\"&csup;\":\"\",\"&csupe;\":\"\",\"&ctdot;\":\"\",\"&cudarrl;\":\"\",\"&cudarrr;\":\"\",\"&cuepr;\":\"\",\"&cuesc;\":\"\",\"&cularr;\":\"\",\"&cularrp;\":\"\",\"&cup;\":\"\",\"&cupbrcap;\":\"\",\"&cupcap;\":\"\",\"&cupcup;\":\"\",\"&cupdot;\":\"\",\"&cupor;\":\"\",\"&cups;\":\"\",\"&curarr;\":\"\",\"&curarrm;\":\"\",\"&curlyeqprec;\":\"\",\"&curlyeqsucc;\":\"\",\"&curlyvee;\":\"\",\"&curlywedge;\":\"\",\"&curren\":\"\",\"&curren;\":\"\",\"&curvearrowleft;\":\"\",\"&curvearrowright;\":\"\",\"&cuvee;\":\"\",\"&cuwed;\":\"\",\"&cwconint;\":\"\",\"&cwint;\":\"\",\"&cylcty;\":\"\",\"&dArr;\":\"\",\"&dHar;\":\"\",\"&dagger;\":\"\",\"&daleth;\":\"\",\"&darr;\":\"\",\"&dash;\":\"\",\"&dashv;\":\"\",\"&dbkarow;\":\"\",\"&dblac;\":\"\",\"&dcaron;\":\"\",\"&dcy;\":\"\",\"&dd;\":\"\",\"&ddagger;\":\"\",\"&ddarr;\":\"\",\"&ddotseq;\":\"\",\"&deg\":\"\",\"&deg;\":\"\",\"&delta;\":\"\",\"&demptyv;\":\"\",\"&dfisht;\":\"\",\"&dfr;\":\"\",\"&dharl;\":\"\",\"&dharr;\":\"\",\"&diam;\":\"\",\"&diamond;\":\"\",\"&diamondsuit;\":\"\",\"&diams;\":\"\",\"&die;\":\"\",\"&digamma;\":\"\",\"&disin;\":\"\",\"&div;\":\"\",\"&divide\":\"\",\"&divide;\":\"\",\"&divideontimes;\":\"\",\"&divonx;\":\"\",\"&djcy;\":\"\",\"&dlcorn;\":\"\",\"&dlcrop;\":\"\",\"&dollar;\":\"$\",\"&dopf;\":\"\",\"&dot;\":\"\",\"&doteq;\":\"\",\"&doteqdot;\":\"\",\"&dotminus;\":\"\",\"&dotplus;\":\"\",\"&dotsquare;\":\"\",\"&doublebarwedge;\":\"\",\"&downarrow;\":\"\",\"&downdownarrows;\":\"\",\"&downharpoonleft;\":\"\",\"&downharpoonright;\":\"\",\"&drbkarow;\":\"\",\"&drcorn;\":\"\",\"&drcrop;\":\"\",\"&dscr;\":\"\",\"&dscy;\":\"\",\"&dsol;\":\"\",\"&dstrok;\":\"\",\"&dtdot;\":\"\",\"&dtri;\":\"\",\"&dtrif;\":\"\",\"&duarr;\":\"\",\"&duhar;\":\"\",\"&dwangle;\":\"\",\"&dzcy;\":\"\",\"&dzigrarr;\":\"\",\"&eDDot;\":\"\",\"&eDot;\":\"\",\"&eacute\":\"\",\"&eacute;\":\"\",\"&easter;\":\"\",\"&ecaron;\":\"\",\"&ecir;\":\"\",\"&ecirc\":\"\",\"&ecirc;\":\"\",\"&ecolon;\":\"\",\"&ecy;\":\"\",\"&edot;\":\"\",\"&ee;\":\"\",\"&efDot;\":\"\",\"&efr;\":\"\",\"&eg;\":\"\",\"&egrave\":\"\",\"&egrave;\":\"\",\"&egs;\":\"\",\"&egsdot;\":\"\",\"&el;\":\"\",\"&elinters;\":\"\",\"&ell;\":\"\",\"&els;\":\"\",\"&elsdot;\":\"\",\"&emacr;\":\"\",\"&empty;\":\"\",\"&emptyset;\":\"\",\"&emptyv;\":\"\",\"&emsp13;\":\"\",\"&emsp14;\":\"\",\"&emsp;\":\"\",\"&eng;\":\"\",\"&ensp;\":\"\",\"&eogon;\":\"\",\"&eopf;\":\"\",\"&epar;\":\"\",\"&eparsl;\":\"\",\"&eplus;\":\"\",\"&epsi;\":\"\",\"&epsilon;\":\"\",\"&epsiv;\":\"\",\"&eqcirc;\":\"\",\"&eqcolon;\":\"\",\"&eqsim;\":\"\",\"&eqslantgtr;\":\"\",\"&eqslantless;\":\"\",\"&equals;\":\"=\",\"&equest;\":\"\",\"&equiv;\":\"\",\"&equivDD;\":\"\",\"&eqvparsl;\":\"\",\"&erDot;\":\"\",\"&erarr;\":\"\",\"&escr;\":\"\",\"&esdot;\":\"\",\"&esim;\":\"\",\"&eta;\":\"\",\"&eth\":\"\",\"&eth;\":\"\",\"&euml\":\"\",\"&euml;\":\"\",\"&euro;\":\"\",\"&excl;\":\"!\",\"&exist;\":\"\",\"&expectation;\":\"\",\"&exponentiale;\":\"\",\"&fallingdotseq;\":\"\",\"&fcy;\":\"\",\"&female;\":\"\",\"&ffilig;\":\"\",\"&fflig;\":\"\",\"&ffllig;\":\"\",\"&ffr;\":\"\",\"&filig;\":\"\",\"&fjlig;\":\"fj\",\"&flat;\":\"\",\"&fllig;\":\"\",\"&fltns;\":\"\",\"&fnof;\":\"\",\"&fopf;\":\"\",\"&forall;\":\"\",\"&fork;\":\"\",\"&forkv;\":\"\",\"&fpartint;\":\"\",\"&frac12\":\"\",\"&frac12;\":\"\",\"&frac13;\":\"\",\"&frac14\":\"\",\"&frac14;\":\"\",\"&frac15;\":\"\",\"&frac16;\":\"\",\"&frac18;\":\"\",\"&frac23;\":\"\",\"&frac25;\":\"\",\"&frac34\":\"\",\"&frac34;\":\"\",\"&frac35;\":\"\",\"&frac38;\":\"\",\"&frac45;\":\"\",\"&frac56;\":\"\",\"&frac58;\":\"\",\"&frac78;\":\"\",\"&frasl;\":\"\",\"&frown;\":\"\",\"&fscr;\":\"\",\"&gE;\":\"\",\"&gEl;\":\"\",\"&gacute;\":\"\",\"&gamma;\":\"\",\"&gammad;\":\"\",\"&gap;\":\"\",\"&gbreve;\":\"\",\"&gcirc;\":\"\",\"&gcy;\":\"\",\"&gdot;\":\"\",\"&ge;\":\"\",\"&gel;\":\"\",\"&geq;\":\"\",\"&geqq;\":\"\",\"&geqslant;\":\"\",\"&ges;\":\"\",\"&gescc;\":\"\",\"&gesdot;\":\"\",\"&gesdoto;\":\"\",\"&gesdotol;\":\"\",\"&gesl;\":\"\",\"&gesles;\":\"\",\"&gfr;\":\"\",\"&gg;\":\"\",\"&ggg;\":\"\",\"&gimel;\":\"\",\"&gjcy;\":\"\",\"&gl;\":\"\",\"&glE;\":\"\",\"&gla;\":\"\",\"&glj;\":\"\",\"&gnE;\":\"\",\"&gnap;\":\"\",\"&gnapprox;\":\"\",\"&gne;\":\"\",\"&gneq;\":\"\",\"&gneqq;\":\"\",\"&gnsim;\":\"\",\"&gopf;\":\"\",\"&grave;\":\"`\",\"&gscr;\":\"\",\"&gsim;\":\"\",\"&gsime;\":\"\",\"&gsiml;\":\"\",\"&gt\":\">\",\"&gt;\":\">\",\"&gtcc;\":\"\",\"&gtcir;\":\"\",\"&gtdot;\":\"\",\"&gtlPar;\":\"\",\"&gtquest;\":\"\",\"&gtrapprox;\":\"\",\"&gtrarr;\":\"\",\"&gtrdot;\":\"\",\"&gtreqless;\":\"\",\"&gtreqqless;\":\"\",\"&gtrless;\":\"\",\"&gtrsim;\":\"\",\"&gvertneqq;\":\"\",\"&gvnE;\":\"\",\"&hArr;\":\"\",\"&hairsp;\":\"\",\"&half;\":\"\",\"&hamilt;\":\"\",\"&hardcy;\":\"\",\"&harr;\":\"\",\"&harrcir;\":\"\",\"&harrw;\":\"\",\"&hbar;\":\"\",\"&hcirc;\":\"\",\"&hearts;\":\"\",\"&heartsuit;\":\"\",\"&hellip;\":\"\",\"&hercon;\":\"\",\"&hfr;\":\"\",\"&hksearow;\":\"\",\"&hkswarow;\":\"\",\"&hoarr;\":\"\",\"&homtht;\":\"\",\"&hookleftarrow;\":\"\",\"&hookrightarrow;\":\"\",\"&hopf;\":\"\",\"&horbar;\":\"\",\"&hscr;\":\"\",\"&hslash;\":\"\",\"&hstrok;\":\"\",\"&hybull;\":\"\",\"&hyphen;\":\"\",\"&iacute\":\"\",\"&iacute;\":\"\",\"&ic;\":\"\",\"&icirc\":\"\",\"&icirc;\":\"\",\"&icy;\":\"\",\"&iecy;\":\"\",\"&iexcl\":\"\",\"&iexcl;\":\"\",\"&iff;\":\"\",\"&ifr;\":\"\",\"&igrave\":\"\",\"&igrave;\":\"\",\"&ii;\":\"\",\"&iiiint;\":\"\",\"&iiint;\":\"\",\"&iinfin;\":\"\",\"&iiota;\":\"\",\"&ijlig;\":\"\",\"&imacr;\":\"\",\"&image;\":\"\",\"&imagline;\":\"\",\"&imagpart;\":\"\",\"&imath;\":\"\",\"&imof;\":\"\",\"&imped;\":\"\",\"&in;\":\"\",\"&incare;\":\"\",\"&infin;\":\"\",\"&infintie;\":\"\",\"&inodot;\":\"\",\"&int;\":\"\",\"&intcal;\":\"\",\"&integers;\":\"\",\"&intercal;\":\"\",\"&intlarhk;\":\"\",\"&intprod;\":\"\",\"&iocy;\":\"\",\"&iogon;\":\"\",\"&iopf;\":\"\",\"&iota;\":\"\",\"&iprod;\":\"\",\"&iquest\":\"\",\"&iquest;\":\"\",\"&iscr;\":\"\",\"&isin;\":\"\",\"&isinE;\":\"\",\"&isindot;\":\"\",\"&isins;\":\"\",\"&isinsv;\":\"\",\"&isinv;\":\"\",\"&it;\":\"\",\"&itilde;\":\"\",\"&iukcy;\":\"\",\"&iuml\":\"\",\"&iuml;\":\"\",\"&jcirc;\":\"\",\"&jcy;\":\"\",\"&jfr;\":\"\",\"&jmath;\":\"\",\"&jopf;\":\"\",\"&jscr;\":\"\",\"&jsercy;\":\"\",\"&jukcy;\":\"\",\"&kappa;\":\"\",\"&kappav;\":\"\",\"&kcedil;\":\"\",\"&kcy;\":\"\",\"&kfr;\":\"\",\"&kgreen;\":\"\",\"&khcy;\":\"\",\"&kjcy;\":\"\",\"&kopf;\":\"\",\"&kscr;\":\"\",\"&lAarr;\":\"\",\"&lArr;\":\"\",\"&lAtail;\":\"\",\"&lBarr;\":\"\",\"&lE;\":\"\",\"&lEg;\":\"\",\"&lHar;\":\"\",\"&lacute;\":\"\",\"&laemptyv;\":\"\",\"&lagran;\":\"\",\"&lambda;\":\"\",\"&lang;\":\"\",\"&langd;\":\"\",\"&langle;\":\"\",\"&lap;\":\"\",\"&laquo\":\"\",\"&laquo;\":\"\",\"&larr;\":\"\",\"&larrb;\":\"\",\"&larrbfs;\":\"\",\"&larrfs;\":\"\",\"&larrhk;\":\"\",\"&larrlp;\":\"\",\"&larrpl;\":\"\",\"&larrsim;\":\"\",\"&larrtl;\":\"\",\"&lat;\":\"\",\"&latail;\":\"\",\"&late;\":\"\",\"&lates;\":\"\",\"&lbarr;\":\"\",\"&lbbrk;\":\"\",\"&lbrace;\":\"{\",\"&lbrack;\":\"[\",\"&lbrke;\":\"\",\"&lbrksld;\":\"\",\"&lbrkslu;\":\"\",\"&lcaron;\":\"\",\"&lcedil;\":\"\",\"&lceil;\":\"\",\"&lcub;\":\"{\",\"&lcy;\":\"\",\"&ldca;\":\"\",\"&ldquo;\":\"\",\"&ldquor;\":\"\",\"&ldrdhar;\":\"\",\"&ldrushar;\":\"\",\"&ldsh;\":\"\",\"&le;\":\"\",\"&leftarrow;\":\"\",\"&leftarrowtail;\":\"\",\"&leftharpoondown;\":\"\",\"&leftharpoonup;\":\"\",\"&leftleftarrows;\":\"\",\"&leftrightarrow;\":\"\",\"&leftrightarrows;\":\"\",\"&leftrightharpoons;\":\"\",\"&leftrightsquigarrow;\":\"\",\"&leftthreetimes;\":\"\",\"&leg;\":\"\",\"&leq;\":\"\",\"&leqq;\":\"\",\"&leqslant;\":\"\",\"&les;\":\"\",\"&lescc;\":\"\",\"&lesdot;\":\"\",\"&lesdoto;\":\"\",\"&lesdotor;\":\"\",\"&lesg;\":\"\",\"&lesges;\":\"\",\"&lessapprox;\":\"\",\"&lessdot;\":\"\",\"&lesseqgtr;\":\"\",\"&lesseqqgtr;\":\"\",\"&lessgtr;\":\"\",\"&lesssim;\":\"\",\"&lfisht;\":\"\",\"&lfloor;\":\"\",\"&lfr;\":\"\",\"&lg;\":\"\",\"&lgE;\":\"\",\"&lhard;\":\"\",\"&lharu;\":\"\",\"&lharul;\":\"\",\"&lhblk;\":\"\",\"&ljcy;\":\"\",\"&ll;\":\"\",\"&llarr;\":\"\",\"&llcorner;\":\"\",\"&llhard;\":\"\",\"&lltri;\":\"\",\"&lmidot;\":\"\",\"&lmoust;\":\"\",\"&lmoustache;\":\"\",\"&lnE;\":\"\",\"&lnap;\":\"\",\"&lnapprox;\":\"\",\"&lne;\":\"\",\"&lneq;\":\"\",\"&lneqq;\":\"\",\"&lnsim;\":\"\",\"&loang;\":\"\",\"&loarr;\":\"\",\"&lobrk;\":\"\",\"&longleftarrow;\":\"\",\"&longleftrightarrow;\":\"\",\"&longmapsto;\":\"\",\"&longrightarrow;\":\"\",\"&looparrowleft;\":\"\",\"&looparrowright;\":\"\",\"&lopar;\":\"\",\"&lopf;\":\"\",\"&loplus;\":\"\",\"&lotimes;\":\"\",\"&lowast;\":\"\",\"&lowbar;\":\"_\",\"&loz;\":\"\",\"&lozenge;\":\"\",\"&lozf;\":\"\",\"&lpar;\":\"(\",\"&lparlt;\":\"\",\"&lrarr;\":\"\",\"&lrcorner;\":\"\",\"&lrhar;\":\"\",\"&lrhard;\":\"\",\"&lrm;\":\"\",\"&lrtri;\":\"\",\"&lsaquo;\":\"\",\"&lscr;\":\"\",\"&lsh;\":\"\",\"&lsim;\":\"\",\"&lsime;\":\"\",\"&lsimg;\":\"\",\"&lsqb;\":\"[\",\"&lsquo;\":\"\",\"&lsquor;\":\"\",\"&lstrok;\":\"\",\"&lt\":\"<\",\"&lt;\":\"<\",\"&ltcc;\":\"\",\"&ltcir;\":\"\",\"&ltdot;\":\"\",\"&lthree;\":\"\",\"&ltimes;\":\"\",\"&ltlarr;\":\"\",\"&ltquest;\":\"\",\"&ltrPar;\":\"\",\"&ltri;\":\"\",\"&ltrie;\":\"\",\"&ltrif;\":\"\",\"&lurdshar;\":\"\",\"&luruhar;\":\"\",\"&lvertneqq;\":\"\",\"&lvnE;\":\"\",\"&mDDot;\":\"\",\"&macr\":\"\",\"&macr;\":\"\",\"&male;\":\"\",\"&malt;\":\"\",\"&maltese;\":\"\",\"&map;\":\"\",\"&mapsto;\":\"\",\"&mapstodown;\":\"\",\"&mapstoleft;\":\"\",\"&mapstoup;\":\"\",\"&marker;\":\"\",\"&mcomma;\":\"\",\"&mcy;\":\"\",\"&mdash;\":\"\",\"&measuredangle;\":\"\",\"&mfr;\":\"\",\"&mho;\":\"\",\"&micro\":\"\",\"&micro;\":\"\",\"&mid;\":\"\",\"&midast;\":\"*\",\"&midcir;\":\"\",\"&middot\":\"\",\"&middot;\":\"\",\"&minus;\":\"\",\"&minusb;\":\"\",\"&minusd;\":\"\",\"&minusdu;\":\"\",\"&mlcp;\":\"\",\"&mldr;\":\"\",\"&mnplus;\":\"\",\"&models;\":\"\",\"&mopf;\":\"\",\"&mp;\":\"\",\"&mscr;\":\"\",\"&mstpos;\":\"\",\"&mu;\":\"\",\"&multimap;\":\"\",\"&mumap;\":\"\",\"&nGg;\":\"\",\"&nGt;\":\"\",\"&nGtv;\":\"\",\"&nLeftarrow;\":\"\",\"&nLeftrightarrow;\":\"\",\"&nLl;\":\"\",\"&nLt;\":\"\",\"&nLtv;\":\"\",\"&nRightarrow;\":\"\",\"&nVDash;\":\"\",\"&nVdash;\":\"\",\"&nabla;\":\"\",\"&nacute;\":\"\",\"&nang;\":\"\",\"&nap;\":\"\",\"&napE;\":\"\",\"&napid;\":\"\",\"&napos;\":\"\",\"&napprox;\":\"\",\"&natur;\":\"\",\"&natural;\":\"\",\"&naturals;\":\"\",\"&nbsp\":\"\",\"&nbsp;\":\"\",\"&nbump;\":\"\",\"&nbumpe;\":\"\",\"&ncap;\":\"\",\"&ncaron;\":\"\",\"&ncedil;\":\"\",\"&ncong;\":\"\",\"&ncongdot;\":\"\",\"&ncup;\":\"\",\"&ncy;\":\"\",\"&ndash;\":\"\",\"&ne;\":\"\",\"&neArr;\":\"\",\"&nearhk;\":\"\",\"&nearr;\":\"\",\"&nearrow;\":\"\",\"&nedot;\":\"\",\"&nequiv;\":\"\",\"&nesear;\":\"\",\"&nesim;\":\"\",\"&nexist;\":\"\",\"&nexists;\":\"\",\"&nfr;\":\"\",\"&ngE;\":\"\",\"&nge;\":\"\",\"&ngeq;\":\"\",\"&ngeqq;\":\"\",\"&ngeqslant;\":\"\",\"&nges;\":\"\",\"&ngsim;\":\"\",\"&ngt;\":\"\",\"&ngtr;\":\"\",\"&nhArr;\":\"\",\"&nharr;\":\"\",\"&nhpar;\":\"\",\"&ni;\":\"\",\"&nis;\":\"\",\"&nisd;\":\"\",\"&niv;\":\"\",\"&njcy;\":\"\",\"&nlArr;\":\"\",\"&nlE;\":\"\",\"&nlarr;\":\"\",\"&nldr;\":\"\",\"&nle;\":\"\",\"&nleftarrow;\":\"\",\"&nleftrightarrow;\":\"\",\"&nleq;\":\"\",\"&nleqq;\":\"\",\"&nleqslant;\":\"\",\"&nles;\":\"\",\"&nless;\":\"\",\"&nlsim;\":\"\",\"&nlt;\":\"\",\"&nltri;\":\"\",\"&nltrie;\":\"\",\"&nmid;\":\"\",\"&nopf;\":\"\",\"&not\":\"\",\"&not;\":\"\",\"&notin;\":\"\",\"&notinE;\":\"\",\"&notindot;\":\"\",\"&notinva;\":\"\",\"&notinvb;\":\"\",\"&notinvc;\":\"\",\"&notni;\":\"\",\"&notniva;\":\"\",\"&notnivb;\":\"\",\"&notnivc;\":\"\",\"&npar;\":\"\",\"&nparallel;\":\"\",\"&nparsl;\":\"\",\"&npart;\":\"\",\"&npolint;\":\"\",\"&npr;\":\"\",\"&nprcue;\":\"\",\"&npre;\":\"\",\"&nprec;\":\"\",\"&npreceq;\":\"\",\"&nrArr;\":\"\",\"&nrarr;\":\"\",\"&nrarrc;\":\"\",\"&nrarrw;\":\"\",\"&nrightarrow;\":\"\",\"&nrtri;\":\"\",\"&nrtrie;\":\"\",\"&nsc;\":\"\",\"&nsccue;\":\"\",\"&nsce;\":\"\",\"&nscr;\":\"\",\"&nshortmid;\":\"\",\"&nshortparallel;\":\"\",\"&nsim;\":\"\",\"&nsime;\":\"\",\"&nsimeq;\":\"\",\"&nsmid;\":\"\",\"&nspar;\":\"\",\"&nsqsube;\":\"\",\"&nsqsupe;\":\"\",\"&nsub;\":\"\",\"&nsubE;\":\"\",\"&nsube;\":\"\",\"&nsubset;\":\"\",\"&nsubseteq;\":\"\",\"&nsubseteqq;\":\"\",\"&nsucc;\":\"\",\"&nsucceq;\":\"\",\"&nsup;\":\"\",\"&nsupE;\":\"\",\"&nsupe;\":\"\",\"&nsupset;\":\"\",\"&nsupseteq;\":\"\",\"&nsupseteqq;\":\"\",\"&ntgl;\":\"\",\"&ntilde\":\"\",\"&ntilde;\":\"\",\"&ntlg;\":\"\",\"&ntriangleleft;\":\"\",\"&ntrianglelefteq;\":\"\",\"&ntriangleright;\":\"\",\"&ntrianglerighteq;\":\"\",\"&nu;\":\"\",\"&num;\":\"#\",\"&numero;\":\"\",\"&numsp;\":\"\",\"&nvDash;\":\"\",\"&nvHarr;\":\"\",\"&nvap;\":\"\",\"&nvdash;\":\"\",\"&nvge;\":\"\",\"&nvgt;\":\">\",\"&nvinfin;\":\"\",\"&nvlArr;\":\"\",\"&nvle;\":\"\",\"&nvlt;\":\"<\",\"&nvltrie;\":\"\",\"&nvrArr;\":\"\",\"&nvrtrie;\":\"\",\"&nvsim;\":\"\",\"&nwArr;\":\"\",\"&nwarhk;\":\"\",\"&nwarr;\":\"\",\"&nwarrow;\":\"\",\"&nwnear;\":\"\",\"&oS;\":\"\",\"&oacute\":\"\",\"&oacute;\":\"\",\"&oast;\":\"\",\"&ocir;\":\"\",\"&ocirc\":\"\",\"&ocirc;\":\"\",\"&ocy;\":\"\",\"&odash;\":\"\",\"&odblac;\":\"\",\"&odiv;\":\"\",\"&odot;\":\"\",\"&odsold;\":\"\",\"&oelig;\":\"\",\"&ofcir;\":\"\",\"&ofr;\":\"\",\"&ogon;\":\"\",\"&ograve\":\"\",\"&ograve;\":\"\",\"&ogt;\":\"\",\"&ohbar;\":\"\",\"&ohm;\":\"\",\"&oint;\":\"\",\"&olarr;\":\"\",\"&olcir;\":\"\",\"&olcross;\":\"\",\"&oline;\":\"\",\"&olt;\":\"\",\"&omacr;\":\"\",\"&omega;\":\"\",\"&omicron;\":\"\",\"&omid;\":\"\",\"&ominus;\":\"\",\"&oopf;\":\"\",\"&opar;\":\"\",\"&operp;\":\"\",\"&oplus;\":\"\",\"&or;\":\"\",\"&orarr;\":\"\",\"&ord;\":\"\",\"&order;\":\"\",\"&orderof;\":\"\",\"&ordf\":\"\",\"&ordf;\":\"\",\"&ordm\":\"\",\"&ordm;\":\"\",\"&origof;\":\"\",\"&oror;\":\"\",\"&orslope;\":\"\",\"&orv;\":\"\",\"&oscr;\":\"\",\"&oslash\":\"\",\"&oslash;\":\"\",\"&osol;\":\"\",\"&otilde\":\"\",\"&otilde;\":\"\",\"&otimes;\":\"\",\"&otimesas;\":\"\",\"&ouml\":\"\",\"&ouml;\":\"\",\"&ovbar;\":\"\",\"&par;\":\"\",\"&para\":\"\",\"&para;\":\"\",\"&parallel;\":\"\",\"&parsim;\":\"\",\"&parsl;\":\"\",\"&part;\":\"\",\"&pcy;\":\"\",\"&percnt;\":\"%\",\"&period;\":\".\",\"&permil;\":\"\",\"&perp;\":\"\",\"&pertenk;\":\"\",\"&pfr;\":\"\",\"&phi;\":\"\",\"&phiv;\":\"\",\"&phmmat;\":\"\",\"&phone;\":\"\",\"&pi;\":\"\",\"&pitchfork;\":\"\",\"&piv;\":\"\",\"&planck;\":\"\",\"&planckh;\":\"\",\"&plankv;\":\"\",\"&plus;\":\"+\",\"&plusacir;\":\"\",\"&plusb;\":\"\",\"&pluscir;\":\"\",\"&plusdo;\":\"\",\"&plusdu;\":\"\",\"&pluse;\":\"\",\"&plusmn\":\"\",\"&plusmn;\":\"\",\"&plussim;\":\"\",\"&plustwo;\":\"\",\"&pm;\":\"\",\"&pointint;\":\"\",\"&popf;\":\"\",\"&pound\":\"\",\"&pound;\":\"\",\"&pr;\":\"\",\"&prE;\":\"\",\"&prap;\":\"\",\"&prcue;\":\"\",\"&pre;\":\"\",\"&prec;\":\"\",\"&precapprox;\":\"\",\"&preccurlyeq;\":\"\",\"&preceq;\":\"\",\"&precnapprox;\":\"\",\"&precneqq;\":\"\",\"&precnsim;\":\"\",\"&precsim;\":\"\",\"&prime;\":\"\",\"&primes;\":\"\",\"&prnE;\":\"\",\"&prnap;\":\"\",\"&prnsim;\":\"\",\"&prod;\":\"\",\"&profalar;\":\"\",\"&profline;\":\"\",\"&profsurf;\":\"\",\"&prop;\":\"\",\"&propto;\":\"\",\"&prsim;\":\"\",\"&prurel;\":\"\",\"&pscr;\":\"\",\"&psi;\":\"\",\"&puncsp;\":\"\",\"&qfr;\":\"\",\"&qint;\":\"\",\"&qopf;\":\"\",\"&qprime;\":\"\",\"&qscr;\":\"\",\"&quaternions;\":\"\",\"&quatint;\":\"\",\"&quest;\":\"?\",\"&questeq;\":\"\",\"&quot\":'\"',\"&quot;\":'\"',\"&rAarr;\":\"\",\"&rArr;\":\"\",\"&rAtail;\":\"\",\"&rBarr;\":\"\",\"&rHar;\":\"\",\"&race;\":\"\",\"&racute;\":\"\",\"&radic;\":\"\",\"&raemptyv;\":\"\",\"&rang;\":\"\",\"&rangd;\":\"\",\"&range;\":\"\",\"&rangle;\":\"\",\"&raquo\":\"\",\"&raquo;\":\"\",\"&rarr;\":\"\",\"&rarrap;\":\"\",\"&rarrb;\":\"\",\"&rarrbfs;\":\"\",\"&rarrc;\":\"\",\"&rarrfs;\":\"\",\"&rarrhk;\":\"\",\"&rarrlp;\":\"\",\"&rarrpl;\":\"\",\"&rarrsim;\":\"\",\"&rarrtl;\":\"\",\"&rarrw;\":\"\",\"&ratail;\":\"\",\"&ratio;\":\"\",\"&rationals;\":\"\",\"&rbarr;\":\"\",\"&rbbrk;\":\"\",\"&rbrace;\":\"}\",\"&rbrack;\":\"]\",\"&rbrke;\":\"\",\"&rbrksld;\":\"\",\"&rbrkslu;\":\"\",\"&rcaron;\":\"\",\"&rcedil;\":\"\",\"&rceil;\":\"\",\"&rcub;\":\"}\",\"&rcy;\":\"\",\"&rdca;\":\"\",\"&rdldhar;\":\"\",\"&rdquo;\":\"\",\"&rdquor;\":\"\",\"&rdsh;\":\"\",\"&real;\":\"\",\"&realine;\":\"\",\"&realpart;\":\"\",\"&reals;\":\"\",\"&rect;\":\"\",\"&reg\":\"\",\"&reg;\":\"\",\"&rfisht;\":\"\",\"&rfloor;\":\"\",\"&rfr;\":\"\",\"&rhard;\":\"\",\"&rharu;\":\"\",\"&rharul;\":\"\",\"&rho;\":\"\",\"&rhov;\":\"\",\"&rightarrow;\":\"\",\"&rightarrowtail;\":\"\",\"&rightharpoondown;\":\"\",\"&rightharpoonup;\":\"\",\"&rightleftarrows;\":\"\",\"&rightleftharpoons;\":\"\",\"&rightrightarrows;\":\"\",\"&rightsquigarrow;\":\"\",\"&rightthreetimes;\":\"\",\"&ring;\":\"\",\"&risingdotseq;\":\"\",\"&rlarr;\":\"\",\"&rlhar;\":\"\",\"&rlm;\":\"\",\"&rmoust;\":\"\",\"&rmoustache;\":\"\",\"&rnmid;\":\"\",\"&roang;\":\"\",\"&roarr;\":\"\",\"&robrk;\":\"\",\"&ropar;\":\"\",\"&ropf;\":\"\",\"&roplus;\":\"\",\"&rotimes;\":\"\",\"&rpar;\":\")\",\"&rpargt;\":\"\",\"&rppolint;\":\"\",\"&rrarr;\":\"\",\"&rsaquo;\":\"\",\"&rscr;\":\"\",\"&rsh;\":\"\",\"&rsqb;\":\"]\",\"&rsquo;\":\"\",\"&rsquor;\":\"\",\"&rthree;\":\"\",\"&rtimes;\":\"\",\"&rtri;\":\"\",\"&rtrie;\":\"\",\"&rtrif;\":\"\",\"&rtriltri;\":\"\",\"&ruluhar;\":\"\",\"&rx;\":\"\",\"&sacute;\":\"\",\"&sbquo;\":\"\",\"&sc;\":\"\",\"&scE;\":\"\",\"&scap;\":\"\",\"&scaron;\":\"\",\"&sccue;\":\"\",\"&sce;\":\"\",\"&scedil;\":\"\",\"&scirc;\":\"\",\"&scnE;\":\"\",\"&scnap;\":\"\",\"&scnsim;\":\"\",\"&scpolint;\":\"\",\"&scsim;\":\"\",\"&scy;\":\"\",\"&sdot;\":\"\",\"&sdotb;\":\"\",\"&sdote;\":\"\",\"&seArr;\":\"\",\"&searhk;\":\"\",\"&searr;\":\"\",\"&searrow;\":\"\",\"&sect\":\"\",\"&sect;\":\"\",\"&semi;\":\";\",\"&seswar;\":\"\",\"&setminus;\":\"\",\"&setmn;\":\"\",\"&sext;\":\"\",\"&sfr;\":\"\",\"&sfrown;\":\"\",\"&sharp;\":\"\",\"&shchcy;\":\"\",\"&shcy;\":\"\",\"&shortmid;\":\"\",\"&shortparallel;\":\"\",\"&shy\":\"\",\"&shy;\":\"\",\"&sigma;\":\"\",\"&sigmaf;\":\"\",\"&sigmav;\":\"\",\"&sim;\":\"\",\"&simdot;\":\"\",\"&sime;\":\"\",\"&simeq;\":\"\",\"&simg;\":\"\",\"&simgE;\":\"\",\"&siml;\":\"\",\"&simlE;\":\"\",\"&simne;\":\"\",\"&simplus;\":\"\",\"&simrarr;\":\"\",\"&slarr;\":\"\",\"&smallsetminus;\":\"\",\"&smashp;\":\"\",\"&smeparsl;\":\"\",\"&smid;\":\"\",\"&smile;\":\"\",\"&smt;\":\"\",\"&smte;\":\"\",\"&smtes;\":\"\",\"&softcy;\":\"\",\"&sol;\":\"/\",\"&solb;\":\"\",\"&solbar;\":\"\",\"&sopf;\":\"\",\"&spades;\":\"\",\"&spadesuit;\":\"\",\"&spar;\":\"\",\"&sqcap;\":\"\",\"&sqcaps;\":\"\",\"&sqcup;\":\"\",\"&sqcups;\":\"\",\"&sqsub;\":\"\",\"&sqsube;\":\"\",\"&sqsubset;\":\"\",\"&sqsubseteq;\":\"\",\"&sqsup;\":\"\",\"&sqsupe;\":\"\",\"&sqsupset;\":\"\",\"&sqsupseteq;\":\"\",\"&squ;\":\"\",\"&square;\":\"\",\"&squarf;\":\"\",\"&squf;\":\"\",\"&srarr;\":\"\",\"&sscr;\":\"\",\"&ssetmn;\":\"\",\"&ssmile;\":\"\",\"&sstarf;\":\"\",\"&star;\":\"\",\"&starf;\":\"\",\"&straightepsilon;\":\"\",\"&straightphi;\":\"\",\"&strns;\":\"\",\"&sub;\":\"\",\"&subE;\":\"\",\"&subdot;\":\"\",\"&sube;\":\"\",\"&subedot;\":\"\",\"&submult;\":\"\",\"&subnE;\":\"\",\"&subne;\":\"\",\"&subplus;\":\"\",\"&subrarr;\":\"\",\"&subset;\":\"\",\"&subseteq;\":\"\",\"&subseteqq;\":\"\",\"&subsetneq;\":\"\",\"&subsetneqq;\":\"\",\"&subsim;\":\"\",\"&subsub;\":\"\",\"&subsup;\":\"\",\"&succ;\":\"\",\"&succapprox;\":\"\",\"&succcurlyeq;\":\"\",\"&succeq;\":\"\",\"&succnapprox;\":\"\",\"&succneqq;\":\"\",\"&succnsim;\":\"\",\"&succsim;\":\"\",\"&sum;\":\"\",\"&sung;\":\"\",\"&sup1\":\"\",\"&sup1;\":\"\",\"&sup2\":\"\",\"&sup2;\":\"\",\"&sup3\":\"\",\"&sup3;\":\"\",\"&sup;\":\"\",\"&supE;\":\"\",\"&supdot;\":\"\",\"&supdsub;\":\"\",\"&supe;\":\"\",\"&supedot;\":\"\",\"&suphsol;\":\"\",\"&suphsub;\":\"\",\"&suplarr;\":\"\",\"&supmult;\":\"\",\"&supnE;\":\"\",\"&supne;\":\"\",\"&supplus;\":\"\",\"&supset;\":\"\",\"&supseteq;\":\"\",\"&supseteqq;\":\"\",\"&supsetneq;\":\"\",\"&supsetneqq;\":\"\",\"&supsim;\":\"\",\"&supsub;\":\"\",\"&supsup;\":\"\",\"&swArr;\":\"\",\"&swarhk;\":\"\",\"&swarr;\":\"\",\"&swarrow;\":\"\",\"&swnwar;\":\"\",\"&szlig\":\"\",\"&szlig;\":\"\",\"&target;\":\"\",\"&tau;\":\"\",\"&tbrk;\":\"\",\"&tcaron;\":\"\",\"&tcedil;\":\"\",\"&tcy;\":\"\",\"&tdot;\":\"\",\"&telrec;\":\"\",\"&tfr;\":\"\",\"&there4;\":\"\",\"&therefore;\":\"\",\"&theta;\":\"\",\"&thetasym;\":\"\",\"&thetav;\":\"\",\"&thickapprox;\":\"\",\"&thicksim;\":\"\",\"&thinsp;\":\"\",\"&thkap;\":\"\",\"&thksim;\":\"\",\"&thorn\":\"\",\"&thorn;\":\"\",\"&tilde;\":\"\",\"&times\":\"\",\"&times;\":\"\",\"&timesb;\":\"\",\"&timesbar;\":\"\",\"&timesd;\":\"\",\"&tint;\":\"\",\"&toea;\":\"\",\"&top;\":\"\",\"&topbot;\":\"\",\"&topcir;\":\"\",\"&topf;\":\"\",\"&topfork;\":\"\",\"&tosa;\":\"\",\"&tprime;\":\"\",\"&trade;\":\"\",\"&triangle;\":\"\",\"&triangledown;\":\"\",\"&triangleleft;\":\"\",\"&trianglelefteq;\":\"\",\"&triangleq;\":\"\",\"&triangleright;\":\"\",\"&trianglerighteq;\":\"\",\"&tridot;\":\"\",\"&trie;\":\"\",\"&triminus;\":\"\",\"&triplus;\":\"\",\"&trisb;\":\"\",\"&tritime;\":\"\",\"&trpezium;\":\"\",\"&tscr;\":\"\",\"&tscy;\":\"\",\"&tshcy;\":\"\",\"&tstrok;\":\"\",\"&twixt;\":\"\",\"&twoheadleftarrow;\":\"\",\"&twoheadrightarrow;\":\"\",\"&uArr;\":\"\",\"&uHar;\":\"\",\"&uacute\":\"\",\"&uacute;\":\"\",\"&uarr;\":\"\",\"&ubrcy;\":\"\",\"&ubreve;\":\"\",\"&ucirc\":\"\",\"&ucirc;\":\"\",\"&ucy;\":\"\",\"&udarr;\":\"\",\"&udblac;\":\"\",\"&udhar;\":\"\",\"&ufisht;\":\"\",\"&ufr;\":\"\",\"&ugrave\":\"\",\"&ugrave;\":\"\",\"&uharl;\":\"\",\"&uharr;\":\"\",\"&uhblk;\":\"\",\"&ulcorn;\":\"\",\"&ulcorner;\":\"\",\"&ulcrop;\":\"\",\"&ultri;\":\"\",\"&umacr;\":\"\",\"&uml\":\"\",\"&uml;\":\"\",\"&uogon;\":\"\",\"&uopf;\":\"\",\"&uparrow;\":\"\",\"&updownarrow;\":\"\",\"&upharpoonleft;\":\"\",\"&upharpoonright;\":\"\",\"&uplus;\":\"\",\"&upsi;\":\"\",\"&upsih;\":\"\",\"&upsilon;\":\"\",\"&upuparrows;\":\"\",\"&urcorn;\":\"\",\"&urcorner;\":\"\",\"&urcrop;\":\"\",\"&uring;\":\"\",\"&urtri;\":\"\",\"&uscr;\":\"\",\"&utdot;\":\"\",\"&utilde;\":\"\",\"&utri;\":\"\",\"&utrif;\":\"\",\"&uuarr;\":\"\",\"&uuml\":\"\",\"&uuml;\":\"\",\"&uwangle;\":\"\",\"&vArr;\":\"\",\"&vBar;\":\"\",\"&vBarv;\":\"\",\"&vDash;\":\"\",\"&vangrt;\":\"\",\"&varepsilon;\":\"\",\"&varkappa;\":\"\",\"&varnothing;\":\"\",\"&varphi;\":\"\",\"&varpi;\":\"\",\"&varpropto;\":\"\",\"&varr;\":\"\",\"&varrho;\":\"\",\"&varsigma;\":\"\",\"&varsubsetneq;\":\"\",\"&varsubsetneqq;\":\"\",\"&varsupsetneq;\":\"\",\"&varsupsetneqq;\":\"\",\"&vartheta;\":\"\",\"&vartriangleleft;\":\"\",\"&vartriangleright;\":\"\",\"&vcy;\":\"\",\"&vdash;\":\"\",\"&vee;\":\"\",\"&veebar;\":\"\",\"&veeeq;\":\"\",\"&vellip;\":\"\",\"&verbar;\":\"|\",\"&vert;\":\"|\",\"&vfr;\":\"\",\"&vltri;\":\"\",\"&vnsub;\":\"\",\"&vnsup;\":\"\",\"&vopf;\":\"\",\"&vprop;\":\"\",\"&vrtri;\":\"\",\"&vscr;\":\"\",\"&vsubnE;\":\"\",\"&vsubne;\":\"\",\"&vsupnE;\":\"\",\"&vsupne;\":\"\",\"&vzigzag;\":\"\",\"&wcirc;\":\"\",\"&wedbar;\":\"\",\"&wedge;\":\"\",\"&wedgeq;\":\"\",\"&weierp;\":\"\",\"&wfr;\":\"\",\"&wopf;\":\"\",\"&wp;\":\"\",\"&wr;\":\"\",\"&wreath;\":\"\",\"&wscr;\":\"\",\"&xcap;\":\"\",\"&xcirc;\":\"\",\"&xcup;\":\"\",\"&xdtri;\":\"\",\"&xfr;\":\"\",\"&xhArr;\":\"\",\"&xharr;\":\"\",\"&xi;\":\"\",\"&xlArr;\":\"\",\"&xlarr;\":\"\",\"&xmap;\":\"\",\"&xnis;\":\"\",\"&xodot;\":\"\",\"&xopf;\":\"\",\"&xoplus;\":\"\",\"&xotime;\":\"\",\"&xrArr;\":\"\",\"&xrarr;\":\"\",\"&xscr;\":\"\",\"&xsqcup;\":\"\",\"&xuplus;\":\"\",\"&xutri;\":\"\",\"&xvee;\":\"\",\"&xwedge;\":\"\",\"&yacute\":\"\",\"&yacute;\":\"\",\"&yacy;\":\"\",\"&ycirc;\":\"\",\"&ycy;\":\"\",\"&yen\":\"\",\"&yen;\":\"\",\"&yfr;\":\"\",\"&yicy;\":\"\",\"&yopf;\":\"\",\"&yscr;\":\"\",\"&yucy;\":\"\",\"&yuml\":\"\",\"&yuml;\":\"\",\"&zacute;\":\"\",\"&zcaron;\":\"\",\"&zcy;\":\"\",\"&zdot;\":\"\",\"&zeetrf;\":\"\",\"&zeta;\":\"\",\"&zfr;\":\"\",\"&zhcy;\":\"\",\"&zigrarr;\":\"\",\"&zopf;\":\"\",\"&zscr;\":\"\",\"&zwj;\":\"\",\"&zwnj;\":\"\"},characters:{\"\":\"&AElig;\",\"&\":\"&amp;\",\"\":\"&Aacute;\",\"\":\"&Abreve;\",\"\":\"&Acirc;\",\"\":\"&Acy;\",\"\":\"&Afr;\",\"\":\"&Agrave;\",\"\":\"&Alpha;\",\"\":\"&Amacr;\",\"\":\"&And;\",\"\":\"&Aogon;\",\"\":\"&Aopf;\",\"\":\"&af;\",\"\":\"&angst;\",\"\":\"&Ascr;\",\"\":\"&coloneq;\",\"\":\"&Atilde;\",\"\":\"&Auml;\",\"\":\"&ssetmn;\",\"\":\"&Barv;\",\"\":\"&doublebarwedge;\",\"\":\"&Bcy;\",\"\":\"&because;\",\"\":\"&bernou;\",\"\":\"&Beta;\",\"\":\"&Bfr;\",\"\":\"&Bopf;\",\"\":\"&breve;\",\"\":\"&bump;\",\"\":\"&CHcy;\",\"\":\"&copy;\",\"\":\"&Cacute;\",\"\":\"&Cap;\",\"\":\"&DD;\",\"\":\"&Cfr;\",\"\":\"&Ccaron;\",\"\":\"&Ccedil;\",\"\":\"&Ccirc;\",\"\":\"&Cconint;\",\"\":\"&Cdot;\",\"\":\"&cedil;\",\"\":\"&middot;\",\"\":\"&Chi;\",\"\":\"&odot;\",\"\":\"&ominus;\",\"\":\"&oplus;\",\"\":\"&otimes;\",\"\":\"&cwconint;\",\"\":\"&rdquor;\",\"\":\"&rsquor;\",\"\":\"&Proportion;\",\"\":\"&Colone;\",\"\":\"&equiv;\",\"\":\"&DoubleContourIntegral;\",\"\":\"&oint;\",\"\":\"&complexes;\",\"\":\"&coprod;\",\"\":\"&awconint;\",\"\":\"&Cross;\",\"\":\"&Cscr;\",\"\":\"&Cup;\",\"\":\"&asympeq;\",\"\":\"&DDotrahd;\",\"\":\"&DJcy;\",\"\":\"&DScy;\",\"\":\"&DZcy;\",\"\":\"&ddagger;\",\"\":\"&Darr;\",\"\":\"&DoubleLeftTee;\",\"\":\"&Dcaron;\",\"\":\"&Dcy;\",\"\":\"&nabla;\",\"\":\"&Delta;\",\"\":\"&Dfr;\",\"\":\"&acute;\",\"\":\"&dot;\",\"\":\"&dblac;\",\"`\":\"&grave;\",\"\":\"&tilde;\",\"\":\"&diamond;\",\"\":\"&dd;\",\"\":\"&Dopf;\",\"\":\"&uml;\",\"\":\"&DotDot;\",\"\":\"&esdot;\",\"\":\"&dArr;\",\"\":\"&lArr;\",\"\":\"&iff;\",\"\":\"&xlArr;\",\"\":\"&xhArr;\",\"\":\"&xrArr;\",\"\":\"&rArr;\",\"\":\"&vDash;\",\"\":\"&uArr;\",\"\":\"&vArr;\",\"\":\"&spar;\",\"\":\"&downarrow;\",\"\":\"&DownArrowBar;\",\"\":\"&duarr;\",\"\":\"&DownBreve;\",\"\":\"&DownLeftRightVector;\",\"\":\"&DownLeftTeeVector;\",\"\":\"&lhard;\",\"\":\"&DownLeftVectorBar;\",\"\":\"&DownRightTeeVector;\",\"\":\"&rightharpoondown;\",\"\":\"&DownRightVectorBar;\",\"\":\"&top;\",\"\":\"&mapstodown;\",\"\":\"&Dscr;\",\"\":\"&Dstrok;\",\"\":\"&ENG;\",\"\":\"&ETH;\",\"\":\"&Eacute;\",\"\":\"&Ecaron;\",\"\":\"&Ecirc;\",\"\":\"&Ecy;\",\"\":\"&Edot;\",\"\":\"&Efr;\",\"\":\"&Egrave;\",\"\":\"&isinv;\",\"\":\"&Emacr;\",\"\":\"&EmptySmallSquare;\",\"\":\"&EmptyVerySmallSquare;\",\"\":\"&Eogon;\",\"\":\"&Eopf;\",\"\":\"&Epsilon;\",\"\":\"&Equal;\",\"\":\"&esim;\",\"\":\"&rlhar;\",\"\":\"&expectation;\",\"\":\"&Esim;\",\"\":\"&Eta;\",\"\":\"&Euml;\",\"\":\"&exist;\",\"\":\"&exponentiale;\",\"\":\"&Fcy;\",\"\":\"&Ffr;\",\"\":\"&FilledSmallSquare;\",\"\":\"&squf;\",\"\":\"&Fopf;\",\"\":\"&forall;\",\"\":\"&Fscr;\",\"\":\"&GJcy;\",\">\":\"&gt;\",\"\":\"&Gamma;\",\"\":\"&Gammad;\",\"\":\"&Gbreve;\",\"\":\"&Gcedil;\",\"\":\"&Gcirc;\",\"\":\"&Gcy;\",\"\":\"&Gdot;\",\"\":\"&Gfr;\",\"\":\"&ggg;\",\"\":\"&Gopf;\",\"\":\"&geq;\",\"\":\"&gtreqless;\",\"\":\"&geqq;\",\"\":\"&GreaterGreater;\",\"\":\"&gtrless;\",\"\":\"&ges;\",\"\":\"&gtrsim;\",\"\":\"&Gscr;\",\"\":\"&gg;\",\"\":\"&HARDcy;\",\"\":\"&caron;\",\"^\":\"&Hat;\",\"\":\"&Hcirc;\",\"\":\"&Poincareplane;\",\"\":\"&hamilt;\",\"\":\"&quaternions;\",\"\":\"&boxh;\",\"\":\"&Hstrok;\",\"\":\"&bumpeq;\",\"\":\"&IEcy;\",\"\":\"&IJlig;\",\"\":\"&IOcy;\",\"\":\"&Iacute;\",\"\":\"&Icirc;\",\"\":\"&Icy;\",\"\":\"&Idot;\",\"\":\"&imagpart;\",\"\":\"&Igrave;\",\"\":\"&Imacr;\",\"\":\"&ii;\",\"\":\"&Int;\",\"\":\"&int;\",\"\":\"&xcap;\",\"\":\"&ic;\",\"\":\"&it;\",\"\":\"&Iogon;\",\"\":\"&Iopf;\",\"\":\"&Iota;\",\"\":\"&imagline;\",\"\":\"&Itilde;\",\"\":\"&Iukcy;\",\"\":\"&Iuml;\",\"\":\"&Jcirc;\",\"\":\"&Jcy;\",\"\":\"&Jfr;\",\"\":\"&Jopf;\",\"\":\"&Jscr;\",\"\":\"&Jsercy;\",\"\":\"&Jukcy;\",\"\":\"&KHcy;\",\"\":\"&KJcy;\",\"\":\"&Kappa;\",\"\":\"&Kcedil;\",\"\":\"&Kcy;\",\"\":\"&Kfr;\",\"\":\"&Kopf;\",\"\":\"&Kscr;\",\"\":\"&LJcy;\",\"<\":\"&lt;\",\"\":\"&Lacute;\",\"\":\"&Lambda;\",\"\":\"&Lang;\",\"\":\"&lagran;\",\"\":\"&twoheadleftarrow;\",\"\":\"&Lcaron;\",\"\":\"&Lcedil;\",\"\":\"&Lcy;\",\"\":\"&langle;\",\"\":\"&slarr;\",\"\":\"&larrb;\",\"\":\"&lrarr;\",\"\":\"&lceil;\",\"\":\"&lobrk;\",\"\":\"&LeftDownTeeVector;\",\"\":\"&downharpoonleft;\",\"\":\"&LeftDownVectorBar;\",\"\":\"&lfloor;\",\"\":\"&leftrightarrow;\",\"\":\"&LeftRightVector;\",\"\":\"&dashv;\",\"\":\"&mapstoleft;\",\"\":\"&LeftTeeVector;\",\"\":\"&vltri;\",\"\":\"&LeftTriangleBar;\",\"\":\"&trianglelefteq;\",\"\":\"&LeftUpDownVector;\",\"\":\"&LeftUpTeeVector;\",\"\":\"&upharpoonleft;\",\"\":\"&LeftUpVectorBar;\",\"\":\"&lharu;\",\"\":\"&LeftVectorBar;\",\"\":\"&lesseqgtr;\",\"\":\"&leqq;\",\"\":\"&lg;\",\"\":\"&LessLess;\",\"\":\"&les;\",\"\":\"&lsim;\",\"\":\"&Lfr;\",\"\":\"&Ll;\",\"\":\"&lAarr;\",\"\":\"&Lmidot;\",\"\":\"&xlarr;\",\"\":\"&xharr;\",\"\":\"&xrarr;\",\"\":\"&Lopf;\",\"\":\"&swarrow;\",\"\":\"&searrow;\",\"\":\"&lsh;\",\"\":\"&Lstrok;\",\"\":\"&ll;\",\"\":\"&Map;\",\"\":\"&Mcy;\",\"\":\"&MediumSpace;\",\"\":\"&phmmat;\",\"\":\"&Mfr;\",\"\":\"&mp;\",\"\":\"&Mopf;\",\"\":\"&Mu;\",\"\":\"&NJcy;\",\"\":\"&Nacute;\",\"\":\"&Ncaron;\",\"\":\"&Ncedil;\",\"\":\"&Ncy;\",\"\":\"&ZeroWidthSpace;\",\"\\n\":\"&NewLine;\",\"\":\"&Nfr;\",\"\":\"&NoBreak;\",\"\":\"&nbsp;\",\"\":\"&naturals;\",\"\":\"&Not;\",\"\":\"&nequiv;\",\"\":\"&NotCupCap;\",\"\":\"&nspar;\",\"\":\"&notinva;\",\"\":\"&ne;\",\"\":\"&nesim;\",\"\":\"&nexists;\",\"\":\"&ngtr;\",\"\":\"&ngeq;\",\"\":\"&ngeqq;\",\"\":\"&nGtv;\",\"\":\"&ntgl;\",\"\":\"&nges;\",\"\":\"&ngsim;\",\"\":\"&nbump;\",\"\":\"&nbumpe;\",\"\":\"&ntriangleleft;\",\"\":\"&NotLeftTriangleBar;\",\"\":\"&ntrianglelefteq;\",\"\":\"&nlt;\",\"\":\"&nleq;\",\"\":\"&ntlg;\",\"\":\"&nLtv;\",\"\":\"&nles;\",\"\":\"&nlsim;\",\"\":\"&NotNestedGreaterGreater;\",\"\":\"&NotNestedLessLess;\",\"\":\"&nprec;\",\"\":\"&npreceq;\",\"\":\"&nprcue;\",\"\":\"&notniva;\",\"\":\"&ntriangleright;\",\"\":\"&NotRightTriangleBar;\",\"\":\"&ntrianglerighteq;\",\"\":\"&NotSquareSubset;\",\"\":\"&nsqsube;\",\"\":\"&NotSquareSuperset;\",\"\":\"&nsqsupe;\",\"\":\"&vnsub;\",\"\":\"&nsubseteq;\",\"\":\"&nsucc;\",\"\":\"&nsucceq;\",\"\":\"&nsccue;\",\"\":\"&NotSucceedsTilde;\",\"\":\"&vnsup;\",\"\":\"&nsupseteq;\",\"\":\"&nsim;\",\"\":\"&nsimeq;\",\"\":\"&ncong;\",\"\":\"&napprox;\",\"\":\"&nsmid;\",\"\":\"&Nscr;\",\"\":\"&Ntilde;\",\"\":\"&Nu;\",\"\":\"&OElig;\",\"\":\"&Oacute;\",\"\":\"&Ocirc;\",\"\":\"&Ocy;\",\"\":\"&Odblac;\",\"\":\"&Ofr;\",\"\":\"&Ograve;\",\"\":\"&Omacr;\",\"\":\"&ohm;\",\"\":\"&Omicron;\",\"\":\"&Oopf;\",\"\":\"&ldquo;\",\"\":\"&lsquo;\",\"\":\"&Or;\",\"\":\"&Oscr;\",\"\":\"&Oslash;\",\"\":\"&Otilde;\",\"\":\"&Otimes;\",\"\":\"&Ouml;\",\"\":\"&oline;\",\"\":\"&OverBrace;\",\"\":\"&tbrk;\",\"\":\"&OverParenthesis;\",\"\":\"&part;\",\"\":\"&Pcy;\",\"\":\"&Pfr;\",\"\":\"&Phi;\",\"\":\"&Pi;\",\"\":\"&pm;\",\"\":\"&primes;\",\"\":\"&Pr;\",\"\":\"&prec;\",\"\":\"&preceq;\",\"\":\"&preccurlyeq;\",\"\":\"&prsim;\",\"\":\"&Prime;\",\"\":\"&prod;\",\"\":\"&vprop;\",\"\":\"&Pscr;\",\"\":\"&Psi;\",'\"':\"&quot;\",\"\":\"&Qfr;\",\"\":\"&rationals;\",\"\":\"&Qscr;\",\"\":\"&drbkarow;\",\"\":\"&reg;\",\"\":\"&Racute;\",\"\":\"&Rang;\",\"\":\"&twoheadrightarrow;\",\"\":\"&Rarrtl;\",\"\":\"&Rcaron;\",\"\":\"&Rcedil;\",\"\":\"&Rcy;\",\"\":\"&realpart;\",\"\":\"&niv;\",\"\":\"&lrhar;\",\"\":\"&duhar;\",\"\":\"&Rho;\",\"\":\"&rangle;\",\"\":\"&srarr;\",\"\":\"&rarrb;\",\"\":\"&rlarr;\",\"\":\"&rceil;\",\"\":\"&robrk;\",\"\":\"&RightDownTeeVector;\",\"\":\"&downharpoonright;\",\"\":\"&RightDownVectorBar;\",\"\":\"&rfloor;\",\"\":\"&vdash;\",\"\":\"&mapsto;\",\"\":\"&RightTeeVector;\",\"\":\"&vrtri;\",\"\":\"&RightTriangleBar;\",\"\":\"&trianglerighteq;\",\"\":\"&RightUpDownVector;\",\"\":\"&RightUpTeeVector;\",\"\":\"&upharpoonright;\",\"\":\"&RightUpVectorBar;\",\"\":\"&rightharpoonup;\",\"\":\"&RightVectorBar;\",\"\":\"&reals;\",\"\":\"&RoundImplies;\",\"\":\"&rAarr;\",\"\":\"&realine;\",\"\":\"&rsh;\",\"\":\"&RuleDelayed;\",\"\":\"&SHCHcy;\",\"\":\"&SHcy;\",\"\":\"&SOFTcy;\",\"\":\"&Sacute;\",\"\":\"&Sc;\",\"\":\"&Scaron;\",\"\":\"&Scedil;\",\"\":\"&Scirc;\",\"\":\"&Scy;\",\"\":\"&Sfr;\",\"\":\"&uparrow;\",\"\":\"&Sigma;\",\"\":\"&compfn;\",\"\":\"&Sopf;\",\"\":\"&radic;\",\"\":\"&square;\",\"\":\"&sqcap;\",\"\":\"&sqsubset;\",\"\":\"&sqsubseteq;\",\"\":\"&sqsupset;\",\"\":\"&sqsupseteq;\",\"\":\"&sqcup;\",\"\":\"&Sscr;\",\"\":\"&sstarf;\",\"\":\"&Subset;\",\"\":\"&subseteq;\",\"\":\"&succ;\",\"\":\"&succeq;\",\"\":\"&succcurlyeq;\",\"\":\"&succsim;\",\"\":\"&sum;\",\"\":\"&Supset;\",\"\":\"&supset;\",\"\":\"&supseteq;\",\"\":\"&THORN;\",\"\":\"&trade;\",\"\":\"&TSHcy;\",\"\":\"&TScy;\",\"\\t\":\"&Tab;\",\"\":\"&Tau;\",\"\":\"&Tcaron;\",\"\":\"&Tcedil;\",\"\":\"&Tcy;\",\"\":\"&Tfr;\",\"\":\"&therefore;\",\"\":\"&Theta;\",\"\":\"&ThickSpace;\",\"\":\"&thinsp;\",\"\":\"&thksim;\",\"\":\"&simeq;\",\"\":\"&cong;\",\"\":\"&thkap;\",\"\":\"&Topf;\",\"\":\"&tdot;\",\"\":\"&Tscr;\",\"\":\"&Tstrok;\",\"\":\"&Uacute;\",\"\":\"&Uarr;\",\"\":\"&Uarrocir;\",\"\":\"&Ubrcy;\",\"\":\"&Ubreve;\",\"\":\"&Ucirc;\",\"\":\"&Ucy;\",\"\":\"&Udblac;\",\"\":\"&Ufr;\",\"\":\"&Ugrave;\",\"\":\"&Umacr;\",_:\"&lowbar;\",\"\":\"&UnderBrace;\",\"\":\"&bbrk;\",\"\":\"&UnderParenthesis;\",\"\":\"&xcup;\",\"\":\"&uplus;\",\"\":\"&Uogon;\",\"\":\"&Uopf;\",\"\":\"&UpArrowBar;\",\"\":\"&udarr;\",\"\":\"&varr;\",\"\":\"&udhar;\",\"\":\"&perp;\",\"\":\"&mapstoup;\",\"\":\"&nwarrow;\",\"\":\"&nearrow;\",\"\":\"&upsih;\",\"\":\"&Upsilon;\",\"\":\"&Uring;\",\"\":\"&Uscr;\",\"\":\"&Utilde;\",\"\":\"&Uuml;\",\"\":\"&VDash;\",\"\":\"&Vbar;\",\"\":\"&Vcy;\",\"\":\"&Vdash;\",\"\":\"&Vdashl;\",\"\":\"&xvee;\",\"\":\"&Vert;\",\"\":\"&smid;\",\"|\":\"&vert;\",\"\":\"&VerticalSeparator;\",\"\":\"&wreath;\",\"\":\"&hairsp;\",\"\":\"&Vfr;\",\"\":\"&Vopf;\",\"\":\"&Vscr;\",\"\":\"&Vvdash;\",\"\":\"&Wcirc;\",\"\":\"&xwedge;\",\"\":\"&Wfr;\",\"\":\"&Wopf;\",\"\":\"&Wscr;\",\"\":\"&Xfr;\",\"\":\"&Xi;\",\"\":\"&Xopf;\",\"\":\"&Xscr;\",\"\":\"&YAcy;\",\"\":\"&YIcy;\",\"\":\"&YUcy;\",\"\":\"&Yacute;\",\"\":\"&Ycirc;\",\"\":\"&Ycy;\",\"\":\"&Yfr;\",\"\":\"&Yopf;\",\"\":\"&Yscr;\",\"\":\"&Yuml;\",\"\":\"&ZHcy;\",\"\":\"&Zacute;\",\"\":\"&Zcaron;\",\"\":\"&Zcy;\",\"\":\"&Zdot;\",\"\":\"&Zeta;\",\"\":\"&zeetrf;\",\"\":\"&integers;\",\"\":\"&Zscr;\",\"\":\"&aacute;\",\"\":\"&abreve;\",\"\":\"&mstpos;\",\"\":\"&acE;\",\"\":\"&acd;\",\"\":\"&acirc;\",\"\":\"&acy;\",\"\":\"&aelig;\",\"\":\"&afr;\",\"\":\"&agrave;\",\"\":\"&aleph;\",\"\":\"&alpha;\",\"\":\"&amacr;\",\"\":\"&amalg;\",\"\":\"&wedge;\",\"\":\"&andand;\",\"\":\"&andd;\",\"\":\"&andslope;\",\"\":\"&andv;\",\"\":\"&angle;\",\"\":\"&ange;\",\"\":\"&measuredangle;\",\"\":\"&angmsdaa;\",\"\":\"&angmsdab;\",\"\":\"&angmsdac;\",\"\":\"&angmsdad;\",\"\":\"&angmsdae;\",\"\":\"&angmsdaf;\",\"\":\"&angmsdag;\",\"\":\"&angmsdah;\",\"\":\"&angrt;\",\"\":\"&angrtvb;\",\"\":\"&angrtvbd;\",\"\":\"&angsph;\",\"\":\"&angzarr;\",\"\":\"&aogon;\",\"\":\"&aopf;\",\"\":\"&apE;\",\"\":\"&apacir;\",\"\":\"&approxeq;\",\"\":\"&apid;\",\"'\":\"&apos;\",\"\":\"&aring;\",\"\":\"&ascr;\",\"*\":\"&midast;\",\"\":\"&atilde;\",\"\":\"&auml;\",\"\":\"&awint;\",\"\":\"&bNot;\",\"\":\"&bcong;\",\"\":\"&bepsi;\",\"\":\"&bprime;\",\"\":\"&bsim;\",\"\":\"&bsime;\",\"\":\"&barvee;\",\"\":\"&barwedge;\",\"\":\"&bbrktbrk;\",\"\":\"&bcy;\",\"\":\"&ldquor;\",\"\":\"&bemptyv;\",\"\":\"&beta;\",\"\":\"&beth;\",\"\":\"&twixt;\",\"\":\"&bfr;\",\"\":\"&xcirc;\",\"\":\"&xodot;\",\"\":\"&xoplus;\",\"\":\"&xotime;\",\"\":\"&xsqcup;\",\"\":\"&starf;\",\"\":\"&xdtri;\",\"\":\"&xutri;\",\"\":\"&xuplus;\",\"\":\"&rbarr;\",\"\":\"&lozf;\",\"\":\"&utrif;\",\"\":\"&dtrif;\",\"\":\"&ltrif;\",\"\":\"&rtrif;\",\"\":\"&blank;\",\"\":\"&blk12;\",\"\":\"&blk14;\",\"\":\"&blk34;\",\"\":\"&block;\",\"=\":\"&bne;\",\"\":\"&bnequiv;\",\"\":\"&bnot;\",\"\":\"&bopf;\",\"\":\"&bowtie;\",\"\":\"&boxDL;\",\"\":\"&boxDR;\",\"\":\"&boxDl;\",\"\":\"&boxDr;\",\"\":\"&boxH;\",\"\":\"&boxHD;\",\"\":\"&boxHU;\",\"\":\"&boxHd;\",\"\":\"&boxHu;\",\"\":\"&boxUL;\",\"\":\"&boxUR;\",\"\":\"&boxUl;\",\"\":\"&boxUr;\",\"\":\"&boxV;\",\"\":\"&boxVH;\",\"\":\"&boxVL;\",\"\":\"&boxVR;\",\"\":\"&boxVh;\",\"\":\"&boxVl;\",\"\":\"&boxVr;\",\"\":\"&boxbox;\",\"\":\"&boxdL;\",\"\":\"&boxdR;\",\"\":\"&boxdl;\",\"\":\"&boxdr;\",\"\":\"&boxhD;\",\"\":\"&boxhU;\",\"\":\"&boxhd;\",\"\":\"&boxhu;\",\"\":\"&minusb;\",\"\":\"&plusb;\",\"\":\"&timesb;\",\"\":\"&boxuL;\",\"\":\"&boxuR;\",\"\":\"&boxul;\",\"\":\"&boxur;\",\"\":\"&boxv;\",\"\":\"&boxvH;\",\"\":\"&boxvL;\",\"\":\"&boxvR;\",\"\":\"&boxvh;\",\"\":\"&boxvl;\",\"\":\"&boxvr;\",\"\":\"&brvbar;\",\"\":\"&bscr;\",\"\":\"&bsemi;\",\"\\\\\":\"&bsol;\",\"\":\"&bsolb;\",\"\":\"&bsolhsub;\",\"\":\"&bullet;\",\"\":\"&bumpE;\",\"\":\"&cacute;\",\"\":\"&cap;\",\"\":\"&capand;\",\"\":\"&capbrcup;\",\"\":\"&capcap;\",\"\":\"&capcup;\",\"\":\"&capdot;\",\"\":\"&caps;\",\"\":\"&caret;\",\"\":\"&ccaps;\",\"\":\"&ccaron;\",\"\":\"&ccedil;\",\"\":\"&ccirc;\",\"\":\"&ccups;\",\"\":\"&ccupssm;\",\"\":\"&cdot;\",\"\":\"&cemptyv;\",\"\":\"&cent;\",\"\":\"&cfr;\",\"\":\"&chcy;\",\"\":\"&checkmark;\",\"\":\"&chi;\",\"\":\"&cir;\",\"\":\"&cirE;\",\"\":\"&circ;\",\"\":\"&cire;\",\"\":\"&olarr;\",\"\":\"&orarr;\",\"\":\"&oS;\",\"\":\"&oast;\",\"\":\"&ocir;\",\"\":\"&odash;\",\"\":\"&cirfnint;\",\"\":\"&cirmid;\",\"\":\"&cirscir;\",\"\":\"&clubsuit;\",\":\":\"&colon;\",\",\":\"&comma;\",\"@\":\"&commat;\",\"\":\"&complement;\",\"\":\"&congdot;\",\"\":\"&copf;\",\"\":\"&copysr;\",\"\":\"&crarr;\",\"\":\"&cross;\",\"\":\"&cscr;\",\"\":\"&csub;\",\"\":\"&csube;\",\"\":\"&csup;\",\"\":\"&csupe;\",\"\":\"&ctdot;\",\"\":\"&cudarrl;\",\"\":\"&cudarrr;\",\"\":\"&curlyeqprec;\",\"\":\"&curlyeqsucc;\",\"\":\"&curvearrowleft;\",\"\":\"&cularrp;\",\"\":\"&cup;\",\"\":\"&cupbrcap;\",\"\":\"&cupcap;\",\"\":\"&cupcup;\",\"\":\"&cupdot;\",\"\":\"&cupor;\",\"\":\"&cups;\",\"\":\"&curvearrowright;\",\"\":\"&curarrm;\",\"\":\"&cuvee;\",\"\":\"&cuwed;\",\"\":\"&curren;\",\"\":\"&cwint;\",\"\":\"&cylcty;\",\"\":\"&dHar;\",\"\":\"&dagger;\",\"\":\"&daleth;\",\"\":\"&hyphen;\",\"\":\"&rBarr;\",\"\":\"&dcaron;\",\"\":\"&dcy;\",\"\":\"&downdownarrows;\",\"\":\"&eDDot;\",\"\":\"&deg;\",\"\":\"&delta;\",\"\":\"&demptyv;\",\"\":\"&dfisht;\",\"\":\"&dfr;\",\"\":\"&diams;\",\"\":\"&gammad;\",\"\":\"&disin;\",\"\":\"&divide;\",\"\":\"&divonx;\",\"\":\"&djcy;\",\"\":\"&llcorner;\",\"\":\"&dlcrop;\",$:\"&dollar;\",\"\":\"&dopf;\",\"\":\"&eDot;\",\"\":\"&minusd;\",\"\":\"&plusdo;\",\"\":\"&sdotb;\",\"\":\"&lrcorner;\",\"\":\"&drcrop;\",\"\":\"&dscr;\",\"\":\"&dscy;\",\"\":\"&dsol;\",\"\":\"&dstrok;\",\"\":\"&dtdot;\",\"\":\"&triangledown;\",\"\":\"&dwangle;\",\"\":\"&dzcy;\",\"\":\"&dzigrarr;\",\"\":\"&eacute;\",\"\":\"&easter;\",\"\":\"&ecaron;\",\"\":\"&eqcirc;\",\"\":\"&ecirc;\",\"\":\"&eqcolon;\",\"\":\"&ecy;\",\"\":\"&edot;\",\"\":\"&fallingdotseq;\",\"\":\"&efr;\",\"\":\"&eg;\",\"\":\"&egrave;\",\"\":\"&eqslantgtr;\",\"\":\"&egsdot;\",\"\":\"&el;\",\"\":\"&elinters;\",\"\":\"&ell;\",\"\":\"&eqslantless;\",\"\":\"&elsdot;\",\"\":\"&emacr;\",\"\":\"&varnothing;\",\"\":\"&emsp13;\",\"\":\"&emsp14;\",\"\":\"&emsp;\",\"\":\"&eng;\",\"\":\"&ensp;\",\"\":\"&eogon;\",\"\":\"&eopf;\",\"\":\"&epar;\",\"\":\"&eparsl;\",\"\":\"&eplus;\",\"\":\"&epsilon;\",\"\":\"&varepsilon;\",\"=\":\"&equals;\",\"\":\"&questeq;\",\"\":\"&equivDD;\",\"\":\"&eqvparsl;\",\"\":\"&risingdotseq;\",\"\":\"&erarr;\",\"\":\"&escr;\",\"\":\"&eta;\",\"\":\"&eth;\",\"\":\"&euml;\",\"\":\"&euro;\",\"!\":\"&excl;\",\"\":\"&fcy;\",\"\":\"&female;\",\"\":\"&ffilig;\",\"\":\"&fflig;\",\"\":\"&ffllig;\",\"\":\"&ffr;\",\"\":\"&filig;\",fj:\"&fjlig;\",\"\":\"&flat;\",\"\":\"&fllig;\",\"\":\"&fltns;\",\"\":\"&fnof;\",\"\":\"&fopf;\",\"\":\"&pitchfork;\",\"\":\"&forkv;\",\"\":\"&fpartint;\",\"\":\"&half;\",\"\":\"&frac13;\",\"\":\"&frac14;\",\"\":\"&frac15;\",\"\":\"&frac16;\",\"\":\"&frac18;\",\"\":\"&frac23;\",\"\":\"&frac25;\",\"\":\"&frac34;\",\"\":\"&frac35;\",\"\":\"&frac38;\",\"\":\"&frac45;\",\"\":\"&frac56;\",\"\":\"&frac58;\",\"\":\"&frac78;\",\"\":\"&frasl;\",\"\":\"&sfrown;\",\"\":\"&fscr;\",\"\":\"&gtreqqless;\",\"\":\"&gacute;\",\"\":\"&gamma;\",\"\":\"&gtrapprox;\",\"\":\"&gbreve;\",\"\":\"&gcirc;\",\"\":\"&gcy;\",\"\":\"&gdot;\",\"\":\"&gescc;\",\"\":\"&gesdot;\",\"\":\"&gesdoto;\",\"\":\"&gesdotol;\",\"\":\"&gesl;\",\"\":\"&gesles;\",\"\":\"&gfr;\",\"\":\"&gimel;\",\"\":\"&gjcy;\",\"\":\"&glE;\",\"\":\"&gla;\",\"\":\"&glj;\",\"\":\"&gneqq;\",\"\":\"&gnapprox;\",\"\":\"&gneq;\",\"\":\"&gnsim;\",\"\":\"&gopf;\",\"\":\"&gscr;\",\"\":\"&gsime;\",\"\":\"&gsiml;\",\"\":\"&gtcc;\",\"\":\"&gtcir;\",\"\":\"&gtrdot;\",\"\":\"&gtlPar;\",\"\":\"&gtquest;\",\"\":\"&gtrarr;\",\"\":\"&gvnE;\",\"\":\"&hardcy;\",\"\":\"&harrcir;\",\"\":\"&leftrightsquigarrow;\",\"\":\"&plankv;\",\"\":\"&hcirc;\",\"\":\"&heartsuit;\",\"\":\"&mldr;\",\"\":\"&hercon;\",\"\":\"&hfr;\",\"\":\"&searhk;\",\"\":\"&swarhk;\",\"\":\"&hoarr;\",\"\":\"&homtht;\",\"\":\"&larrhk;\",\"\":\"&rarrhk;\",\"\":\"&hopf;\",\"\":\"&horbar;\",\"\":\"&hscr;\",\"\":\"&hstrok;\",\"\":\"&hybull;\",\"\":\"&iacute;\",\"\":\"&icirc;\",\"\":\"&icy;\",\"\":\"&iecy;\",\"\":\"&iexcl;\",\"\":\"&ifr;\",\"\":\"&igrave;\",\"\":\"&qint;\",\"\":\"&tint;\",\"\":\"&iinfin;\",\"\":\"&iiota;\",\"\":\"&ijlig;\",\"\":\"&imacr;\",\"\":\"&inodot;\",\"\":\"&imof;\",\"\":\"&imped;\",\"\":\"&incare;\",\"\":\"&infin;\",\"\":\"&infintie;\",\"\":\"&intercal;\",\"\":\"&intlarhk;\",\"\":\"&iprod;\",\"\":\"&iocy;\",\"\":\"&iogon;\",\"\":\"&iopf;\",\"\":\"&iota;\",\"\":\"&iquest;\",\"\":\"&iscr;\",\"\":\"&isinE;\",\"\":\"&isindot;\",\"\":\"&isins;\",\"\":\"&isinsv;\",\"\":\"&itilde;\",\"\":\"&iukcy;\",\"\":\"&iuml;\",\"\":\"&jcirc;\",\"\":\"&jcy;\",\"\":\"&jfr;\",\"\":\"&jmath;\",\"\":\"&jopf;\",\"\":\"&jscr;\",\"\":\"&jsercy;\",\"\":\"&jukcy;\",\"\":\"&kappa;\",\"\":\"&varkappa;\",\"\":\"&kcedil;\",\"\":\"&kcy;\",\"\":\"&kfr;\",\"\":\"&kgreen;\",\"\":\"&khcy;\",\"\":\"&kjcy;\",\"\":\"&kopf;\",\"\":\"&kscr;\",\"\":\"&lAtail;\",\"\":\"&lBarr;\",\"\":\"&lesseqqgtr;\",\"\":\"&lHar;\",\"\":\"&lacute;\",\"\":\"&laemptyv;\",\"\":\"&lambda;\",\"\":\"&langd;\",\"\":\"&lessapprox;\",\"\":\"&laquo;\",\"\":\"&larrbfs;\",\"\":\"&larrfs;\",\"\":\"&looparrowleft;\",\"\":\"&larrpl;\",\"\":\"&larrsim;\",\"\":\"&leftarrowtail;\",\"\":\"&lat;\",\"\":\"&latail;\",\"\":\"&late;\",\"\":\"&lates;\",\"\":\"&lbarr;\",\"\":\"&lbbrk;\",\"{\":\"&lcub;\",\"[\":\"&lsqb;\",\"\":\"&lbrke;\",\"\":\"&lbrksld;\",\"\":\"&lbrkslu;\",\"\":\"&lcaron;\",\"\":\"&lcedil;\",\"\":\"&lcy;\",\"\":\"&ldca;\",\"\":\"&ldrdhar;\",\"\":\"&ldrushar;\",\"\":\"&ldsh;\",\"\":\"&leq;\",\"\":\"&llarr;\",\"\":\"&lthree;\",\"\":\"&lescc;\",\"\":\"&lesdot;\",\"\":\"&lesdoto;\",\"\":\"&lesdotor;\",\"\":\"&lesg;\",\"\":\"&lesges;\",\"\":\"&ltdot;\",\"\":\"&lfisht;\",\"\":\"&lfr;\",\"\":\"&lgE;\",\"\":\"&lharul;\",\"\":\"&lhblk;\",\"\":\"&ljcy;\",\"\":\"&llhard;\",\"\":\"&lltri;\",\"\":\"&lmidot;\",\"\":\"&lmoustache;\",\"\":\"&lneqq;\",\"\":\"&lnapprox;\",\"\":\"&lneq;\",\"\":\"&lnsim;\",\"\":\"&loang;\",\"\":\"&loarr;\",\"\":\"&xmap;\",\"\":\"&rarrlp;\",\"\":\"&lopar;\",\"\":\"&lopf;\",\"\":\"&loplus;\",\"\":\"&lotimes;\",\"\":\"&lowast;\",\"\":\"&lozenge;\",\"(\":\"&lpar;\",\"\":\"&lparlt;\",\"\":\"&lrhard;\",\"\":\"&lrm;\",\"\":\"&lrtri;\",\"\":\"&lsaquo;\",\"\":\"&lscr;\",\"\":\"&lsime;\",\"\":\"&lsimg;\",\"\":\"&sbquo;\",\"\":\"&lstrok;\",\"\":\"&ltcc;\",\"\":\"&ltcir;\",\"\":\"&ltimes;\",\"\":\"&ltlarr;\",\"\":\"&ltquest;\",\"\":\"&ltrPar;\",\"\":\"&triangleleft;\",\"\":\"&lurdshar;\",\"\":\"&luruhar;\",\"\":\"&lvnE;\",\"\":\"&mDDot;\",\"\":\"&strns;\",\"\":\"&male;\",\"\":\"&maltese;\",\"\":\"&marker;\",\"\":\"&mcomma;\",\"\":\"&mcy;\",\"\":\"&mdash;\",\"\":\"&mfr;\",\"\":\"&mho;\",\"\":\"&micro;\",\"\":\"&midcir;\",\"\":\"&minus;\",\"\":\"&minusdu;\",\"\":\"&mlcp;\",\"\":\"&models;\",\"\":\"&mopf;\",\"\":\"&mscr;\",\"\":\"&mu;\",\"\":\"&mumap;\",\"\":\"&nGg;\",\"\":\"&nGt;\",\"\":\"&nlArr;\",\"\":\"&nhArr;\",\"\":\"&nLl;\",\"\":\"&nLt;\",\"\":\"&nrArr;\",\"\":\"&nVDash;\",\"\":\"&nVdash;\",\"\":\"&nacute;\",\"\":\"&nang;\",\"\":\"&napE;\",\"\":\"&napid;\",\"\":\"&napos;\",\"\":\"&natural;\",\"\":\"&ncap;\",\"\":\"&ncaron;\",\"\":\"&ncedil;\",\"\":\"&ncongdot;\",\"\":\"&ncup;\",\"\":\"&ncy;\",\"\":\"&ndash;\",\"\":\"&neArr;\",\"\":\"&nearhk;\",\"\":\"&nedot;\",\"\":\"&toea;\",\"\":\"&nfr;\",\"\":\"&nleftrightarrow;\",\"\":\"&nhpar;\",\"\":\"&nis;\",\"\":\"&nisd;\",\"\":\"&njcy;\",\"\":\"&nleqq;\",\"\":\"&nleftarrow;\",\"\":\"&nldr;\",\"\":\"&nopf;\",\"\":\"&not;\",\"\":\"&notinE;\",\"\":\"&notindot;\",\"\":\"&notinvb;\",\"\":\"&notinvc;\",\"\":\"&notnivb;\",\"\":\"&notnivc;\",\"\":\"&nparsl;\",\"\":\"&npart;\",\"\":\"&npolint;\",\"\":\"&nrightarrow;\",\"\":\"&nrarrc;\",\"\":\"&nrarrw;\",\"\":\"&nscr;\",\"\":\"&nsub;\",\"\":\"&nsubseteqq;\",\"\":\"&nsup;\",\"\":\"&nsupseteqq;\",\"\":\"&ntilde;\",\"\":\"&nu;\",\"#\":\"&num;\",\"\":\"&numero;\",\"\":\"&numsp;\",\"\":\"&nvDash;\",\"\":\"&nvHarr;\",\"\":\"&nvap;\",\"\":\"&nvdash;\",\"\":\"&nvge;\",\">\":\"&nvgt;\",\"\":\"&nvinfin;\",\"\":\"&nvlArr;\",\"\":\"&nvle;\",\"<\":\"&nvlt;\",\"\":\"&nvltrie;\",\"\":\"&nvrArr;\",\"\":\"&nvrtrie;\",\"\":\"&nvsim;\",\"\":\"&nwArr;\",\"\":\"&nwarhk;\",\"\":\"&nwnear;\",\"\":\"&oacute;\",\"\":\"&ocirc;\",\"\":\"&ocy;\",\"\":\"&odblac;\",\"\":\"&odiv;\",\"\":\"&odsold;\",\"\":\"&oelig;\",\"\":\"&ofcir;\",\"\":\"&ofr;\",\"\":\"&ogon;\",\"\":\"&ograve;\",\"\":\"&ogt;\",\"\":\"&ohbar;\",\"\":\"&olcir;\",\"\":\"&olcross;\",\"\":\"&olt;\",\"\":\"&omacr;\",\"\":\"&omega;\",\"\":\"&omicron;\",\"\":\"&omid;\",\"\":\"&oopf;\",\"\":\"&opar;\",\"\":\"&operp;\",\"\":\"&vee;\",\"\":\"&ord;\",\"\":\"&oscr;\",\"\":\"&ordf;\",\"\":\"&ordm;\",\"\":\"&origof;\",\"\":\"&oror;\",\"\":\"&orslope;\",\"\":\"&orv;\",\"\":\"&oslash;\",\"\":\"&osol;\",\"\":\"&otilde;\",\"\":\"&otimesas;\",\"\":\"&ouml;\",\"\":\"&ovbar;\",\"\":\"&para;\",\"\":\"&parsim;\",\"\":\"&parsl;\",\"\":\"&pcy;\",\"%\":\"&percnt;\",\".\":\"&period;\",\"\":\"&permil;\",\"\":\"&pertenk;\",\"\":\"&pfr;\",\"\":\"&phi;\",\"\":\"&varphi;\",\"\":\"&phone;\",\"\":\"&pi;\",\"\":\"&varpi;\",\"\":\"&planckh;\",\"+\":\"&plus;\",\"\":\"&plusacir;\",\"\":\"&pluscir;\",\"\":\"&plusdu;\",\"\":\"&pluse;\",\"\":\"&plussim;\",\"\":\"&plustwo;\",\"\":\"&pointint;\",\"\":\"&popf;\",\"\":\"&pound;\",\"\":\"&prE;\",\"\":\"&precapprox;\",\"\":\"&prnap;\",\"\":\"&prnE;\",\"\":\"&prnsim;\",\"\":\"&prime;\",\"\":\"&profalar;\",\"\":\"&profline;\",\"\":\"&profsurf;\",\"\":\"&prurel;\",\"\":\"&pscr;\",\"\":\"&psi;\",\"\":\"&puncsp;\",\"\":\"&qfr;\",\"\":\"&qopf;\",\"\":\"&qprime;\",\"\":\"&qscr;\",\"\":\"&quatint;\",\"?\":\"&quest;\",\"\":\"&rAtail;\",\"\":\"&rHar;\",\"\":\"&race;\",\"\":\"&racute;\",\"\":\"&raemptyv;\",\"\":\"&rangd;\",\"\":\"&range;\",\"\":\"&raquo;\",\"\":\"&rarrap;\",\"\":\"&rarrbfs;\",\"\":\"&rarrc;\",\"\":\"&rarrfs;\",\"\":\"&rarrpl;\",\"\":\"&rarrsim;\",\"\":\"&rightarrowtail;\",\"\":\"&rightsquigarrow;\",\"\":\"&ratail;\",\"\":\"&ratio;\",\"\":\"&rbbrk;\",\"}\":\"&rcub;\",\"]\":\"&rsqb;\",\"\":\"&rbrke;\",\"\":\"&rbrksld;\",\"\":\"&rbrkslu;\",\"\":\"&rcaron;\",\"\":\"&rcedil;\",\"\":\"&rcy;\",\"\":\"&rdca;\",\"\":\"&rdldhar;\",\"\":\"&rdsh;\",\"\":\"&rect;\",\"\":\"&rfisht;\",\"\":\"&rfr;\",\"\":\"&rharul;\",\"\":\"&rho;\",\"\":\"&varrho;\",\"\":\"&rrarr;\",\"\":\"&rthree;\",\"\":\"&ring;\",\"\":\"&rlm;\",\"\":\"&rmoustache;\",\"\":\"&rnmid;\",\"\":\"&roang;\",\"\":\"&roarr;\",\"\":\"&ropar;\",\"\":\"&ropf;\",\"\":\"&roplus;\",\"\":\"&rotimes;\",\")\":\"&rpar;\",\"\":\"&rpargt;\",\"\":\"&rppolint;\",\"\":\"&rsaquo;\",\"\":\"&rscr;\",\"\":\"&rtimes;\",\"\":\"&triangleright;\",\"\":\"&rtriltri;\",\"\":\"&ruluhar;\",\"\":\"&rx;\",\"\":\"&sacute;\",\"\":\"&scE;\",\"\":\"&succapprox;\",\"\":\"&scaron;\",\"\":\"&scedil;\",\"\":\"&scirc;\",\"\":\"&succneqq;\",\"\":\"&succnapprox;\",\"\":\"&succnsim;\",\"\":\"&scpolint;\",\"\":\"&scy;\",\"\":\"&sdot;\",\"\":\"&sdote;\",\"\":\"&seArr;\",\"\":\"&sect;\",\";\":\"&semi;\",\"\":\"&tosa;\",\"\":\"&sext;\",\"\":\"&sfr;\",\"\":\"&sharp;\",\"\":\"&shchcy;\",\"\":\"&shcy;\",\"\":\"&shy;\",\"\":\"&sigma;\",\"\":\"&varsigma;\",\"\":\"&simdot;\",\"\":\"&simg;\",\"\":\"&simgE;\",\"\":\"&siml;\",\"\":\"&simlE;\",\"\":\"&simne;\",\"\":\"&simplus;\",\"\":\"&simrarr;\",\"\":\"&smashp;\",\"\":\"&smeparsl;\",\"\":\"&ssmile;\",\"\":\"&smt;\",\"\":\"&smte;\",\"\":\"&smtes;\",\"\":\"&softcy;\",\"/\":\"&sol;\",\"\":\"&solb;\",\"\":\"&solbar;\",\"\":\"&sopf;\",\"\":\"&spadesuit;\",\"\":\"&sqcaps;\",\"\":\"&sqcups;\",\"\":\"&sscr;\",\"\":\"&star;\",\"\":\"&subset;\",\"\":\"&subseteqq;\",\"\":\"&subdot;\",\"\":\"&subedot;\",\"\":\"&submult;\",\"\":\"&subsetneqq;\",\"\":\"&subsetneq;\",\"\":\"&subplus;\",\"\":\"&subrarr;\",\"\":\"&subsim;\",\"\":\"&subsub;\",\"\":\"&subsup;\",\"\":\"&sung;\",\"\":\"&sup1;\",\"\":\"&sup2;\",\"\":\"&sup3;\",\"\":\"&supseteqq;\",\"\":\"&supdot;\",\"\":\"&supdsub;\",\"\":\"&supedot;\",\"\":\"&suphsol;\",\"\":\"&suphsub;\",\"\":\"&suplarr;\",\"\":\"&supmult;\",\"\":\"&supsetneqq;\",\"\":\"&supsetneq;\",\"\":\"&supplus;\",\"\":\"&supsim;\",\"\":\"&supsub;\",\"\":\"&supsup;\",\"\":\"&swArr;\",\"\":\"&swnwar;\",\"\":\"&szlig;\",\"\":\"&target;\",\"\":\"&tau;\",\"\":\"&tcaron;\",\"\":\"&tcedil;\",\"\":\"&tcy;\",\"\":\"&telrec;\",\"\":\"&tfr;\",\"\":\"&theta;\",\"\":\"&vartheta;\",\"\":\"&thorn;\",\"\":\"&times;\",\"\":\"&timesbar;\",\"\":\"&timesd;\",\"\":\"&topbot;\",\"\":\"&topcir;\",\"\":\"&topf;\",\"\":\"&topfork;\",\"\":\"&tprime;\",\"\":\"&utri;\",\"\":\"&trie;\",\"\":\"&tridot;\",\"\":\"&triminus;\",\"\":\"&triplus;\",\"\":\"&trisb;\",\"\":\"&tritime;\",\"\":\"&trpezium;\",\"\":\"&tscr;\",\"\":\"&tscy;\",\"\":\"&tshcy;\",\"\":\"&tstrok;\",\"\":\"&uHar;\",\"\":\"&uacute;\",\"\":\"&ubrcy;\",\"\":\"&ubreve;\",\"\":\"&ucirc;\",\"\":\"&ucy;\",\"\":\"&udblac;\",\"\":\"&ufisht;\",\"\":\"&ufr;\",\"\":\"&ugrave;\",\"\":\"&uhblk;\",\"\":\"&ulcorner;\",\"\":\"&ulcrop;\",\"\":\"&ultri;\",\"\":\"&umacr;\",\"\":\"&uogon;\",\"\":\"&uopf;\",\"\":\"&upsilon;\",\"\":\"&uuarr;\",\"\":\"&urcorner;\",\"\":\"&urcrop;\",\"\":\"&uring;\",\"\":\"&urtri;\",\"\":\"&uscr;\",\"\":\"&utdot;\",\"\":\"&utilde;\",\"\":\"&uuml;\",\"\":\"&uwangle;\",\"\":\"&vBar;\",\"\":\"&vBarv;\",\"\":\"&vangrt;\",\"\":\"&vsubne;\",\"\":\"&vsubnE;\",\"\":\"&vsupne;\",\"\":\"&vsupnE;\",\"\":\"&vcy;\",\"\":\"&veebar;\",\"\":\"&veeeq;\",\"\":\"&vellip;\",\"\":\"&vfr;\",\"\":\"&vopf;\",\"\":\"&vscr;\",\"\":\"&vzigzag;\",\"\":\"&wcirc;\",\"\":\"&wedbar;\",\"\":\"&wedgeq;\",\"\":\"&wp;\",\"\":\"&wfr;\",\"\":\"&wopf;\",\"\":\"&wscr;\",\"\":\"&xfr;\",\"\":\"&xi;\",\"\":\"&xnis;\",\"\":\"&xopf;\",\"\":\"&xscr;\",\"\":\"&yacute;\",\"\":\"&yacy;\",\"\":\"&ycirc;\",\"\":\"&ycy;\",\"\":\"&yen;\",\"\":\"&yfr;\",\"\":\"&yicy;\",\"\":\"&yopf;\",\"\":\"&yscr;\",\"\":\"&yucy;\",\"\":\"&yuml;\",\"\":\"&zacute;\",\"\":\"&zcaron;\",\"\":\"&zcy;\",\"\":\"&zdot;\",\"\":\"&zeta;\",\"\":\"&zfr;\",\"\":\"&zhcy;\",\"\":\"&zigrarr;\",\"\":\"&zopf;\",\"\":\"&zscr;\",\"\":\"&zwj;\",\"\":\"&zwnj;\"}}};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbmFtZWQtcmVmZXJlbmNlcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyxtQkFBbUIsRUFBRSw2Q0FBNkMscW9CQUFxb0IsNnBCQUE2cEIsS0FBSyx1QkFBdUIsRUFBRSxLQUFLLFVBQVUsS0FBSyxXQUFXLGFBQWEsYUFBYSxZQUFZLE1BQU0sYUFBYSxTQUFTLFdBQVcsYUFBYSxhQUFhLFlBQVksR0FBRyxRQUFRLFVBQVUsT0FBTyx5QkFBeUIsMkJBQTJCLHlCQUF5QiwyQkFBMkIsNkJBQTZCLHVCQUF1Qiw2QkFBNkIseUJBQXlCLHVCQUF1Qix5QkFBeUIseUJBQXlCLDJCQUEyQix1QkFBdUIsdUJBQXVCLHVCQUF1Qix5QkFBeUIsdUJBQXVCLDZCQUE2Qix5QkFBeUIseUJBQXlCLDJCQUEyQiwyQkFBMkIseUJBQXlCLDZCQUE2QiwyQkFBMkIseUJBQXlCLHlCQUF5QiwyQkFBMkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDZCQUE2Qix5QkFBeUIsMkJBQTJCLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIseUJBQXlCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLHlCQUF5Qix1QkFBdUIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLDZCQUE2Qix5QkFBeUIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDJCQUEyQix5QkFBeUIsNkJBQTZCLDJCQUEyQiwyQkFBMkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsNkJBQTZCLHlCQUF5QiwyQkFBMkIsMkJBQTJCLDZCQUE2Qiw2QkFBNkIsNkJBQTZCLDJCQUEyQix5QkFBeUIsNkJBQTZCLDZCQUE2QiwyQkFBMkIseUJBQXlCLHVCQUF1Qiw2QkFBNkIsNkJBQTZCLDZCQUE2QiwyQkFBMkIsNkJBQTZCLHlCQUF5Qiw2QkFBNkIsNkJBQTZCLDZCQUE2Qiw2QkFBNkIsMkJBQTJCLHlCQUF5Qiw2QkFBNkIsMkJBQTJCLHlCQUF5Qix5QkFBeUIsdUJBQXVCLHFCQUFxQixxQkFBcUIsY0FBYyxjQUFjLGVBQWUsZUFBZSxhQUFhLGFBQWEsY0FBYyxhQUFhLGFBQWEsZUFBZSxhQUFhLFlBQVksWUFBWSxZQUFZLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsYUFBYSxhQUFhLGNBQWMsYUFBYSxjQUFjLGNBQWMsZ0JBQWdCLGFBQWEsWUFBWSxjQUFjLGFBQWEsY0FBYyxlQUFlLFdBQVcsV0FBVyxXQUFXLGdCQUFnQixXQUFXLFlBQVksY0FBYyxZQUFZLGdCQUFnQixZQUFZLFlBQVksWUFBWSxjQUFjLGNBQWMsYUFBYSxjQUFjLGNBQWMsZ0JBQWdCLGFBQWEsWUFBWSxjQUFjLGFBQWEsY0FBYyxlQUFlLFdBQVcsV0FBVyxXQUFXLGdCQUFnQixXQUFXLFlBQVksZUFBZSxjQUFjLFlBQVksZ0JBQWdCLFlBQVksWUFBWSxZQUFZLGNBQWMsaUJBQWlCLGNBQWMsWUFBWSxhQUFhLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxlQUFlLGNBQWMsYUFBYSxjQUFjLGdCQUFnQixhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsY0FBYyxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsZUFBZSxhQUFhLGNBQWMsY0FBYyxjQUFjLGFBQWEsY0FBYyxXQUFXLGFBQWEsWUFBWSxjQUFjLGVBQWUsY0FBYyxhQUFhLGNBQWMsWUFBWSxZQUFZLFdBQVcsWUFBWSxZQUFZLFlBQVksZUFBZSxZQUFZLGFBQWEsY0FBYyxXQUFXLGNBQWMsV0FBVyxXQUFXLFlBQVksWUFBWSxhQUFhLGFBQWEsYUFBYSxjQUFjLGVBQWUsYUFBYSxhQUFhLGNBQWMsY0FBYyxlQUFlLGVBQWUsYUFBYSxhQUFhLFlBQVksZUFBZSxjQUFjLGVBQWUsY0FBYyxNQUFNLGFBQWEsV0FBVyxhQUFhLGNBQWMsYUFBYSxjQUFjLGVBQWUsWUFBWSxlQUFlLGFBQWEsWUFBWSxhQUFhLGFBQWEsY0FBYyxZQUFZLFlBQVksWUFBWSxhQUFhLFlBQVksZUFBZSxhQUFhLGFBQWEsY0FBYyxjQUFjLGFBQWEsZUFBZSxjQUFjLGFBQWEsYUFBYSxjQUFjLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGNBQWMsZUFBZSxhQUFhLGNBQWMsY0FBYyxlQUFlLGVBQWUsZUFBZSxjQUFjLGFBQWEsZUFBZSxlQUFlLGNBQWMsYUFBYSxZQUFZLGVBQWUsZUFBZSxlQUFlLGNBQWMsZUFBZSxhQUFhLGNBQWMsZUFBZSxlQUFlLGVBQWUsY0FBYyxhQUFhLGVBQWUsY0FBYyxjQUFjLGVBQWUsZUFBZSxjQUFjLGVBQWUsYUFBYSxjQUFjLGNBQWMsZUFBZSxlQUFlLGVBQWUsY0FBYyxhQUFhLGVBQWUsZUFBZSxjQUFjLGFBQWEsWUFBWSxlQUFlLGVBQWUsZUFBZSxjQUFjLGVBQWUsYUFBYSxlQUFlLGVBQWUsZUFBZSxlQUFlLGNBQWMsYUFBYSxlQUFlLGNBQWMsYUFBYSxhQUFhLFlBQVksV0FBVyxXQUFXLGNBQWMsY0FBYyxlQUFlLGVBQWUsYUFBYSxhQUFhLGNBQWMsYUFBYSxhQUFhLGVBQWUsYUFBYSxZQUFZLFlBQVksWUFBWSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGFBQWEsYUFBYSxjQUFjLGFBQWEsY0FBYyxjQUFjLGdCQUFnQixhQUFhLFlBQVksY0FBYyxhQUFhLGNBQWMsZUFBZSxXQUFXLFdBQVcsV0FBVyxnQkFBZ0IsV0FBVyxZQUFZLGNBQWMsWUFBWSxnQkFBZ0IsWUFBWSxZQUFZLFlBQVksY0FBYyxjQUFjLGFBQWEsY0FBYyxjQUFjLGdCQUFnQixhQUFhLFlBQVksY0FBYyxhQUFhLGNBQWMsZUFBZSxXQUFXLFdBQVcsV0FBVyxnQkFBZ0IsV0FBVyxZQUFZLGVBQWUsY0FBYyxZQUFZLGdCQUFnQixZQUFZLFlBQVksWUFBWSxjQUFjLGlCQUFpQixjQUFjLFlBQVksYUFBYSxlQUFlLGNBQWMsY0FBYyxjQUFj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LGFBQWEseUJBQXlCLGFBQWEsY0FBYyxjQUFjLGNBQWMsbUJBQW1CLGNBQWMsYUFBYSxjQUFjLGFBQWEsaUJBQWlCLGdCQUFnQixnQkFBZ0IsY0FBYyxnQkFBZ0IsY0FBYyxjQUFjLGVBQWUsYUFBYSxjQUFjLGFBQWEsWUFBWSxjQUFjLGVBQWUsYUFBYSxhQUFhLGFBQWEsYUFBYSwwQkFBMEIsZUFBZSxlQUFlLGFBQWEsY0FBYyxjQUFjLGVBQWUsY0FBYyxlQUFlLGFBQWEsY0FBYyxjQUFjLGFBQWEsV0FBVyxjQUFjLGNBQWMsYUFBYSxhQUFhLGFBQWEsZUFBZSxjQUFjLFlBQVksYUFBYSxjQUFjLGNBQWMsYUFBYSxhQUFhLGVBQWUsZUFBZSxZQUFZLGFBQWEsYUFBYSxlQUFlLGlCQUFpQixjQUFjLGVBQWUsZUFBZSxlQUFlLGFBQWEsWUFBWSxjQUFjLFlBQVksY0FBYyxhQUFhLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsYUFBYSxpQkFBaUIsYUFBYSxjQUFjLGFBQWEsc0JBQXNCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsaUJBQWlCLGlCQUFpQixpQkFBaUIsY0FBYyxnQkFBZ0IsaUJBQWlCLGVBQWUsZ0JBQWdCLGNBQWMsY0FBYyxZQUFZLGVBQWUsaUJBQWlCLGFBQWEsYUFBYSxjQUFjLGNBQWMsZUFBZSxlQUFlLGFBQWEsY0FBYyxhQUFhLGNBQWMsY0FBYyxlQUFlLGFBQWEsY0FBYyxlQUFlLGlCQUFpQixpQkFBaUIsWUFBWSxlQUFlLGdCQUFnQixhQUFhLGFBQWEsY0FBYyxhQUFhLGNBQWMsY0FBYyxlQUFlLGVBQWUsZUFBZSxjQUFjLGNBQWMsY0FBYyxlQUFlLGNBQWMsYUFBYSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxhQUFhLGlCQUFpQixhQUFhLGNBQWMsZUFBZSxjQUFjLGNBQWMsY0FBYyxjQUFjLGFBQWEsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGFBQWEsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGNBQWMsZUFBZSxjQUFjLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxhQUFhLGNBQWMsY0FBYyxjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxpQkFBaUIsZUFBZSxjQUFjLGVBQWUsWUFBWSxlQUFlLGlCQUFpQixlQUFlLGVBQWUsZUFBZSxjQUFjLGNBQWMsY0FBYyxlQUFlLGVBQWUsY0FBYyxjQUFjLGdCQUFnQixhQUFhLGdCQUFnQixhQUFhLGFBQWEsYUFBYSxrQkFBa0IsWUFBWSxZQUFZLGFBQWEsYUFBYSxhQUFhLGNBQWMsY0FBYyxXQUFXLGFBQWEsYUFBYSxjQUFjLGlCQUFpQixlQUFlLGdCQUFnQixpQkFBaUIsY0FBYyxjQUFjLGVBQWUsbUJBQW1CLGdCQUFnQixjQUFjLGVBQWUsY0FBYyxjQUFjLGNBQWMsYUFBYSxjQUFjLGFBQWEsY0FBYyxjQUFjLGdCQUFnQixnQkFBZ0Isb0JBQW9CLG9CQUFvQix1QkFBdUIsZ0JBQWdCLFlBQVksaUJBQWlCLGVBQWUsZUFBZSxlQUFlLGNBQWMsY0FBYyx3QkFBd0IsZ0JBQWdCLGNBQWMsY0FBYyxlQUFlLGNBQWMsZUFBZSxhQUFhLGVBQWUsZUFBZSxlQUFlLGNBQWMsZUFBZSxZQUFZLHVCQUF1QixjQUFjLFlBQVksY0FBYyxnQkFBZ0IsZUFBZSxhQUFhLGNBQWMsZUFBZSxjQUFjLGVBQWUsZUFBZSxhQUFhLGlCQUFpQixlQUFlLGFBQWEsY0FBYyxhQUFhLGVBQWUsZUFBZSxjQUFjLGlCQUFpQixlQUFlLGNBQWMsYUFBYSxhQUFhLGVBQWUsY0FBYyxxQkFBcUIsZ0JBQWdCLGFBQWEsaUJBQWlCLGVBQWUsZUFBZSxlQUFlLGVBQWUsY0FBYyxnQkFBZ0IsWUFBWSxhQUFhLHNCQUFzQixhQUFhLFdBQVcsZUFBZSxtQkFBbUIsZUFBZSxXQUFXLGlCQUFpQixZQUFZLG9CQUFvQixlQUFlLGNBQWMsbUJBQW1CLGVBQWUsZUFBZSxhQUFhLFlBQVksYUFBYSxjQUFjLGNBQWMsYUFBYSxlQUFlLGNBQWMsZ0JBQWdCLG1CQUFtQixlQUFlLGdCQUFnQixnQkFBZ0IsaUJBQWlCLHFCQUFxQixjQUFjLGFBQWEsWUFBWSxZQUFZLGFBQWEsYUFBYSxhQUFhLFlBQVksZUFBZSxlQUFlLGNBQWMsZUFBZSxhQUFhLGNBQWMsYUFBYSxhQUFhLGNBQWMsY0FBYyxhQUFhLGNBQWMsa0JBQWtCLGNBQWMsaUJBQWlCLGFBQWEsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGVBQWUsZUFBZSxlQUFlLGNBQWMsZUFBZSxjQUFjLG1CQUFtQixlQUFlLGNBQWMsa0JBQWtCLGVBQWUsY0FBYyxZQUFZLGFBQWEsY0FBYyxlQUFlLGdCQUFnQixpQkFBaUIsY0FBYyxlQUFlLGFBQWEsY0FBYyxhQUFhLFlBQVksWUFBWSxZQUFZLGNBQWMsaUJBQWlCLGFBQWEsY0FBYyxjQUFjLGFBQWEsY0FBYyxjQUFjLGFBQWEsY0FBYyxlQUFlLGVBQWUsZ0JBQWdCLGVBQWUsY0FBYyxlQUFlLGdCQUFnQiw0QkFBNEIsZUFBZSxjQUFjLGtCQUFrQixhQUFhLGVBQWUsYUFBYSxlQUFlLGVBQWUsY0FBYyxlQUFlLGVBQWUsZUFBZSxjQUFjLGVBQWUsY0FBYyxlQUFlLGVBQWUsZUFBZSxjQUFjLFlBQVksYUFBYSxjQUFjLGFBQWEsZUFBZSxhQUFhLGFBQWEsZUFBZSxjQUFjLGNBQWMsY0FBYyxlQUFlLGFBQWEsY0FBYyxlQUFlLGNBQWMsaUJBQWlCLGlCQUFpQixpQkFBaUIsY0FBYyxhQUFhLGNBQWMsY0FBYyxhQUFhLGVBQWUsY0FBYyxjQUFjLGdCQUFnQixjQUFjLGVBQWUsZUFBZSxjQUFjLGFBQWEsY0FBYyxZQUFZLGFBQWEsY0FBYyxjQUFjLGNBQWMsZUFBZSxjQUFjLGNBQWMsaUJBQWlCLGVBQWUsWUFBWSxhQUFhLGVBQWUsYUFBYSxhQUFhLGNBQWMsY0FBYyxlQUFlLGNBQWMsbUJBQW1CLGFBQWEsZUFBZSxpQkFBaUIs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aUJBQWlCLFlBQVksYUFBYSxjQUFjLGNBQWMsYUFBYSxJQUFJLFNBQVMsYUFBYSxhQUFhLGFBQWEsY0FBYyxlQUFlLGFBQWEsWUFBWSxjQUFjLGlCQUFpQixlQUFlLGFBQWEsY0FBYyxhQUFhLGNBQWMsY0FBYyxnQkFBZ0IsZ0JBQWdCLGVBQWUsaUJBQWlCLGVBQWUsWUFBWSxhQUFhLGVBQWUsZUFBZSxZQUFZLGFBQWEsZUFBZSxjQUFjLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGNBQWMsYUFBYSxlQUFlLGtCQUFrQixlQUFlLGdCQUFnQixnQkFBZ0IsbUJBQW1CLGtCQUFrQixnQkFBZ0IsZ0JBQWdCLGVBQWUsZUFBZSxlQUFlLGFBQWEsYUFBYSxhQUFhLGFBQWEsa0JBQWtCLGVBQWUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsbUJBQW1CLGtCQUFrQixnQkFBZ0IsZUFBZSxlQUFlLGVBQWUsY0FBYyxlQUFlLGNBQWMsZUFBZSxZQUFZLGVBQWUsZUFBZSxZQUFZLGVBQWUsYUFBYSxjQUFjLGlCQUFpQixjQUFjLGNBQWMsaUJBQWlCLGVBQWUsZUFBZSxlQUFlLGNBQWMsZ0JBQWdCLGVBQWUsYUFBYSxhQUFhLGVBQWUsaUJBQWlCLGdCQUFnQixjQUFjLGdCQUFnQixpQkFBaUIsY0FBYyxhQUFhLGNBQWMsZUFBZSxhQUFhLGVBQWUsY0FBYyxlQUFlLGNBQWMsWUFBWSxlQUFlLGVBQWUsYUFBYSxlQUFlLGNBQWMsaUJBQWlCLGVBQWUsY0FBYyxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IsY0FBYyxpQkFBaUIsZUFBZSxjQUFjLGNBQWMsY0FBYyxjQUFjLGVBQWUsYUFBYSxnQkFBZ0IsYUFBYSxjQUFjLGVBQWUsZ0JBQWdCLGdCQUFnQixnQkFBZ0IsZ0JBQWdCLFlBQVksZUFBZSxjQUFjLGVBQWUsYUFBYSxjQUFjLGNBQWMsZ0JBQWdCLGNBQWMsZUFBZSxlQUFlLFdBQVcsYUFBYSxjQUFjLGNBQWMsYUFBYSxXQUFXLGFBQWEsY0FBYyxjQUFjLGVBQWUsYUFBYSxjQUFjLFlBQVksWUFBWSxhQUFhLGFBQWEsY0FBYyxjQUFjLGFBQWEsYUFBYSxlQUFlLGVBQWUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGdCQUFnQixjQUFjLGNBQWMsWUFBWSxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbmFtZWQtcmVmZXJlbmNlcy5qcz8wNmIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTp0cnVlfSk7ZXhwb3J0cy5ib2R5UmVnRXhwcz17eG1sOi8mKD86I1xcZCt8I1t4WF1bXFxkYS1mQS1GXSt8WzAtOWEtekEtWl0rKTs/L2csaHRtbDQ6LyYoPzpuYnNwfGlleGNsfGNlbnR8cG91bmR8Y3VycmVufHllbnxicnZiYXJ8c2VjdHx1bWx8Y29weXxvcmRmfGxhcXVvfG5vdHxzaHl8cmVnfG1hY3J8ZGVnfHBsdXNtbnxzdXAyfHN1cDN8YWN1dGV8bWljcm98cGFyYXxtaWRkb3R8Y2VkaWx8c3VwMXxvcmRtfHJhcXVvfGZyYWMxNHxmcmFjMTJ8ZnJhYzM0fGlxdWVzdHxBZ3JhdmV8QWFjdXRlfEFjaXJjfEF0aWxkZXxBdW1sfEFyaW5nfEFFbGlnfENjZWRpbHxFZ3JhdmV8RWFjdXRlfEVjaXJjfEV1bWx8SWdyYXZlfElhY3V0ZXxJY2lyY3xJdW1sfEVUSHxOdGlsZGV8T2dyYXZlfE9hY3V0ZXxPY2lyY3xPdGlsZGV8T3VtbHx0aW1lc3xPc2xhc2h8VWdyYXZlfFVhY3V0ZXxVY2lyY3xVdW1sfFlhY3V0ZXxUSE9STnxzemxpZ3xhZ3JhdmV8YWFjdXRlfGFjaXJjfGF0aWxkZXxhdW1sfGFyaW5nfGFlbGlnfGNjZWRpbHxlZ3JhdmV8ZWFjdXRlfGVjaXJjfGV1bWx8aWdyYXZlfGlhY3V0ZXxpY2lyY3xpdW1sfGV0aHxudGlsZGV8b2dyYXZlfG9hY3V0ZXxvY2lyY3xvdGlsZGV8b3VtbHxkaXZpZGV8b3NsYXNofHVncmF2ZXx1YWN1dGV8dWNpcmN8dXVtbHx5YWN1dGV8dGhvcm58eXVtbHxxdW90fGFtcHxsdHxndHwjXFxkK3wjW3hYXVtcXGRhLWZBLUZdK3xbMC05YS16QS1aXSspOz8vZyxodG1sNTovJig/OkFFbGlnfEFNUHxBYWN1dGV8QWNpcmN8QWdyYXZlfEFyaW5nfEF0aWxkZXxBdW1sfENPUFl8Q2NlZGlsfEVUSHxFYWN1dGV8RWNpcmN8RWdyYXZlfEV1bWx8R1R8SWFjdXRlfEljaXJjfElncmF2ZXxJdW1sfExUfE50aWxkZXxPYWN1dGV8T2NpcmN8T2dyYXZlfE9zbGFzaHxPdGlsZGV8T3VtbHxRVU9UfFJFR3xUSE9STnxVYWN1dGV8VWNpcmN8VWdyYXZlfFV1bWx8WWFjdXRlfGFhY3V0ZXxhY2lyY3xhY3V0ZXxhZWxpZ3xhZ3JhdmV8YW1wfGFyaW5nfGF0aWxkZXxhdW1sfGJydmJhcnxjY2VkaWx8Y2VkaWx8Y2VudHxjb3B5fGN1cnJlbnxkZWd8ZGl2aWRlfGVhY3V0ZXxlY2lyY3xlZ3JhdmV8ZXRofGV1bWx8ZnJhYzEyfGZyYWMxNHxmcmFjMzR8Z3R8aWFjdXRlfGljaXJjfGlleGNsfGlncmF2ZXxpcXVlc3R8aXVtbHxsYXF1b3xsdHxtYWNyfG1pY3JvfG1pZGRvdHxuYnNwfG5vdHxudGlsZGV8b2FjdXRlfG9jaXJjfG9ncmF2ZXxvcmRmfG9yZG18b3NsYXNofG90aWxkZXxvdW1sfHBhcmF8cGx1c21ufHBvdW5kfHF1b3R8cmFxdW98cmVnfHNlY3R8c2h5fHN1cDF8c3VwMnxzdXAzfHN6bGlnfHRob3JufHRpbWVzfHVhY3V0ZXx1Y2lyY3x1Z3JhdmV8dW1sfHV1bWx8eWFjdXRlfHllbnx5dW1sfCNcXGQrfCNbeFhdW1xcZGEtZkEtRl0rfFswLTlhLXpBLVpdKyk7Py9nfTtleHBvcnRzLm5hbWVkUmVmZXJlbmNlcz17eG1sOntlbnRpdGllczp7XCImbHQ7XCI6XCI8XCIsXCImZ3Q7XCI6XCI+XCIsXCImcXVvdDtcIjonXCInLFwiJmFwb3M7XCI6XCInXCIsXCImYW1wO1wiOlwiJlwifSxjaGFyYWN0ZXJzOntcIjxcIjpcIiZsdDtcIixcIj5cIjpcIiZndDtcIiwnXCInOlwiJnF1b3Q7XCIsXCInXCI6XCImYXBvcztcIixcIiZcIjpcIiZhbXA7XCJ9fSxodG1sNDp7ZW50aXRpZXM6e1wiJmFwb3M7XCI6XCInXCIsXCImbmJzcFwiOlwiwqBcIixcIiZuYnNwO1wiOlwiwqBcIixcIiZpZXhjbFwiOlwiwqFcIixcIiZpZXhjbDtcIjpcIsKhXCIsXCImY2VudFwiOlwiwqJcIixcIiZjZW50O1wiOlwiwqJcIixcIiZwb3VuZFwiOlwiwqNcIixcIiZwb3VuZDtcIjpcIsKjXCIsXCImY3VycmVuXCI6XCLCpFwiLFwiJmN1cnJlbjtcIjpcIsKkXCIsXCImeWVuXCI6XCLCpVwiLFwiJnllbjtcIjpcIsKlXCIsXCImYnJ2YmFyXCI6XCLCplwiLFwiJmJydmJhcjtcIjpcIsKmXCIsXCImc2VjdFwiOlwiwqdcIixcIiZzZWN0O1wiOlwiwqdcIixcIiZ1bWxcIjpcIsKoXCIsXCImdW1sO1wiOlwiwqhcIixcIiZjb3B5XCI6XCLCqVwiLFwiJmNvcHk7XCI6XCLCqVwiLFwiJm9yZGZcIjpcIsKqXCIsXCImb3JkZjtcIjpcIsKqXCIsXCImbGFxdW9cIjpcIsKrXCIsXCImbGFxdW87XCI6XCLCq1wiLFwiJm5vdFwiOlwiwqxcIixcIiZub3Q7XCI6XCLCrFwiLFwiJnNoeVwiOlwiwq1cIixcIiZzaHk7XCI6XCLCrVwiLFwiJnJlZ1wiOlwiwq5cIixcIiZyZWc7XCI6XCLCrlwiLFwiJm1hY3JcIjpcIsKvXCIsXCImbWFjcjtcIjpcIsKvXCIsXCImZGVnXCI6XCLCsFwiLFwiJmRlZztcIjpcIsKwXCIsXCImcGx1c21uXCI6XCLCsVwiLFwiJnBsdXNtbjtcIjpcIsKxXCIsXCImc3VwMlwiOlwiwrJcIixcIiZzdXAyO1wiOlwiwrJcIixcIiZzdXAzXCI6XCLCs1wiLFwiJnN1cDM7XCI6XCLCs1wiLFwiJmFjdXRlXCI6XCLCtFwiLFwiJmFjdXRlO1wiOlwiwrRcIixcIiZtaWNyb1wiOlwiwrVcIixcIiZtaWNybztcIjpcIsK1XCIsXCImcGFyYVwiOlwiwrZcIixcIiZwYXJhO1wiOlwiwrZcIixcIiZtaWRkb3RcIjpcIsK3XCIsXCImbWlkZG90O1wiOlwiwrdcIixcIiZjZWRpbFwiOlwiwrhcIixcIiZjZWRpbDtcIjpcIsK4XCIsXCImc3VwMVwiOlwiwrlcIixcIiZzdXAxO1wiOlwiwrlcIixcIiZvcmRtXCI6XCLCulwiLFwiJm9yZG07XCI6XCLCulwiLFwiJnJhcXVvXCI6XCLCu1wiLFwiJnJhcXVvO1wiOlwiwrtcIixcIiZmcmFjMTRcIjpcIsK8XCIsXCImZnJhYzE0O1wiOlwiwrxcIixcIiZmcmFjMTJcIjpcIsK9XCIsXCImZnJhYzEyO1wiOlwiwr1cIixcIiZmcmFjMzRcIjpcIsK+XCIsXCImZnJhYzM0O1wiOlwiwr5cIixcIiZpcXVlc3RcIjpcIsK/XCIsXCImaXF1ZXN0O1wiOlwiwr9cIixcIiZBZ3JhdmVcIjpcIsOAXCIsXCImQWdyYXZlO1wiOlwiw4BcIixcIiZBYWN1dGVcIjpcIsOBXCIsXCImQWFjdXRlO1wiOlwiw4FcIixcIiZBY2lyY1wiOlwiw4JcIixcIiZBY2lyYztcIjpcIsOCXCIsXCImQXRpbGRlXCI6XCLDg1wiLFwiJkF0aWxkZTtcIjpcIsODXCIsXCImQXVtbFwiOlwiw4RcIixcIiZBdW1sO1wiOlwiw4RcIixcIiZBcmluZ1wiOlwiw4VcIixcIiZBcmluZztcIjpcIsOFXCIsXCImQUVsaWdcIjpcIsOGXCIsXCImQUVsaWc7XCI6XCLDhlwiLFwiJkNjZWRpbFwiOlwiw4dcIixcIiZDY2VkaWw7XCI6XCLDh1wiLFwiJkVncmF2ZVwiOlwiw4hcIixcIiZFZ3JhdmU7XCI6XCLDiFwiLFwiJkVhY3V0ZVwiOlwiw4lcIixcIiZFYWN1dGU7XCI6XCLDiVwiLFwiJkVjaXJjXCI6XCLDilwiLFwiJkVjaXJjO1wiOlwiw4pcIixcIiZFdW1sXCI6XCLDi1wiLFwiJkV1bWw7XCI6XCLDi1wiLFwiJklncmF2ZVwiOlwiw4xcIixcIiZJZ3JhdmU7XCI6XCLDjFwiLFwiJklhY3V0ZVwiOlwiw41cIixcIiZJYWN1dGU7XCI6XCLDjVwiLFwiJkljaXJjXCI6XCLDjlwiLFwiJkljaXJjO1wiOlwiw45cIixcIiZJdW1sXCI6XCLDj1wiLFwiJkl1bWw7XCI6XCLDj1wiLFwiJkVUSFwiOlwiw5BcIixcIiZFVEg7XCI6XCLDkFwiLFwiJk50aWxkZVwiOlwiw5FcIixcIiZOdGlsZGU7XCI6XCLDkVwiLFwiJk9ncmF2ZVwiOlwiw5JcIixcIiZPZ3JhdmU7XCI6XCLDklwiLFwiJk9hY3V0ZVwiOlwiw5NcIixcIiZPYWN1dGU7XCI6XCLDk1wiLFwiJk9jaXJjXCI6XCLDlFwiLFwiJk9jaXJjO1wiOlwiw5RcIixcIiZPdGlsZGVcIjpcIsOVXCIsXCImT3RpbGRlO1wiOlwiw5VcIixcIiZPdW1sXCI6XCLDllwiLFwiJk91bWw7XCI6XCLDllwiLFwiJnRpbWVzXCI6XCLDl1wiLFwiJnRpbWVzO1wiOlwiw5dcIixcIiZPc2xhc2hcIjpcIsOYXCIsXCImT3NsYXNoO1wiOlwiw5hcIixcIiZVZ3JhdmVcIjpcIsOZXCIsXCImVWdyYXZlO1wiOlwiw5lcIixcIiZVYWN1dGVcIjpcIsOaXCIsXCImVWFjdXRlO1wiOlwiw5pcIixcIiZVY2lyY1wiOlwiw5tcIixcIiZVY2lyYztcIjpcIsObXCIsXCImVXVtbFwiOlwiw5xcIixcIiZVdW1sO1wiOlwiw5xcIixcIiZZYWN1dGVcIjpcIsOdXCIsXCImWWFjdXRlO1wiOlwiw51cIixcIiZUSE9STlwiOlwiw55cIixcIiZUSE9STjtcIjpcIsOeXCIsXCImc3psaWdcIjpcIsOfXCIsXCImc3psaWc7XCI6XCLDn1wiLFwiJmFncmF2ZVwiOlwiw6BcIixcIiZhZ3JhdmU7XCI6XCLDoFwiLFwiJmFhY3V0ZVwiOlwiw6FcIixcIiZhYWN1dGU7XCI6XCLDoVwiLFwiJmFjaXJjXCI6XCLDolwiLFwiJmFjaXJjO1wiOlwiw6JcIixcIiZhdGlsZGVcIjpcIsOjXCIsXCImYXRpbGRlO1wiOlwiw6NcIixcIiZhdW1sXCI6XCLDpFwiLFwiJmF1bWw7XCI6XCLDpFwiLFwiJmFyaW5nXCI6XCLDpVwiLFwiJmFyaW5nO1wiOlwiw6VcIixcIiZhZWxpZ1wiOlwiw6ZcIixcIiZhZWxpZztcIjpcIsOmXCIsXCImY2NlZGlsXCI6XCLDp1wiLFwiJmNjZWRpbDtcIjpcIsOnXCIsXCImZWdyYXZlXCI6XCLDqFwiLFwiJmVncmF2ZTtcIjpcIsOoXCIsXCImZWFjdXRlXCI6XCLDqVwiLFwiJmVhY3V0ZTtcIjpcIsOpXCIsXCImZWNpcmNcIjpcIsOqXCIsXCImZWNpcmM7XCI6XCLDqlwiLFwiJmV1bWxcIjpcIsOrXCIsXCImZXVtbDtcIjpcIsOrXCIsXCImaWdyYXZlXCI6XCLDrFwiLFwiJmlncmF2ZTtcIjpcIsOsXCIsXCImaWFjdXRlXCI6XCLDrVwiLFwiJmlhY3V0ZTtcIjpcIsOtXCIsXCImaWNpcmNcIjpcIsOuXCIsXCImaWNpcmM7XCI6XCLDrlwiLFwiJml1bWxcIjpcIsOvXCIsXCImaXVtbDtcIjpcIsOvXCIsXCImZXRoXCI6XCLDsFwiLFwiJmV0aDtcIjpcIsOwXCIsXCImbnRpbGRlXCI6XCLDsVwiLFwiJm50aWxkZTtcIjpcIsOxXCIsXCImb2dyYXZlXCI6XCLDslwiLFwiJm9ncmF2ZTtcIjpcIsOyXCIsXCImb2FjdXRlXCI6XCLDs1wiLFwiJm9hY3V0ZTtcIjpcIsOzXCIsXCImb2NpcmNcIjpcIsO0XCIsXCImb2NpcmM7XCI6XCLDtFwiLFwiJm90aWxkZVwiOlwiw7VcIixcIiZvdGlsZGU7XCI6XCLDtVwiLFwiJm91bWxcIjpcIsO2XCIsXCImb3VtbDtcIjpcIsO2XCIsXCImZGl2aWRlXCI6XCLDt1wiLFwiJmRpdmlkZTtcIjpcIsO3XCIsXCImb3NsYXNoXCI6XCLDuFwiLFwiJm9zbGFzaDtcIjpcIsO4XCIsXCImdWdyYXZlXCI6XCLDuVwiLFwiJnVncmF2ZTtcIjpcIsO5XCIsXCImdWFjdXRlXCI6XCLDulwiLFwiJnVhY3V0ZTtcIjpcIsO6XCIsXCImdWNpcmNcIjpcIsO7XCIsXCImdWNpcmM7XCI6XCLDu1wiLFwiJnV1bWxcIjpcIsO8XCIsXCImdXVtbDtcIjpcIsO8XCIsXCImeWFjdXRlXCI6XCLDvVwiLFwiJnlhY3V0ZTtcIjpcIsO9XCIsXCImdGhvcm5cIjpcIsO+XCIsXCImdGhvcm47XCI6XCLDvlwiLFwiJnl1bWxcIjpcIsO/XCIsXCImeXVtbDtcIjpcIsO/XCIsXCImcXVvdFwiOidcIicsXCImcXVvdDtcIjonXCInLFwiJmFtcFwiOlwiJlwiLFwiJmFtcDtcIjpcIiZcIixcIiZsdFwiOlwiPFwiLFwiJmx0O1wiOlwiPFwiLFwiJmd0XCI6XCI+XCIsXCImZ3Q7XCI6XCI+XCIsXCImT0VsaWc7XCI6XCLFklwiLFwiJm9lbGlnO1wiOlwixZNcIixcIiZTY2Fyb247XCI6XCLFoFwiLFwiJnNjYXJvbjtcIjpcIsWhXCIsXCImWXVtbDtcIjpcIsW4XCIsXCImY2lyYztcIjpcIsuGXCIsXCImdGlsZGU7XCI6XCLLnFwiLFwiJmVuc3A7XCI6XCLigIJcIixcIiZlbXNwO1wiOlwi4oCDXCIsXCImdGhpbnNwO1wiOlwi4oCJXCIsXCImenduajtcIjpcIuKAjFwiLFwiJnp3ajtcIjpcIuKAjVwiLFwiJmxybTtcIjpcIuKAjlwiLFwiJnJsbTtcIjpcIuKAj1wiLFwiJm5kYXNoO1wiOlwi4oCTXCIsXCImbWRhc2g7XCI6XCLigJRcIixcIiZsc3F1bztcIjpcIuKAmFwiLFwiJnJzcXVvO1wiOlwi4oCZXCIsXCImc2JxdW87XCI6XCLigJpcIixcIiZsZHF1bztcIjpcIuKAnFwiLFwiJnJkcXVvO1wiOlwi4oCdXCIsXCImYmRxdW87XCI6XCLigJ5cIixcIiZkYWdnZXI7XCI6XCLigKBcIixcIiZEYWdnZXI7XCI6XCLigKFcIixcIiZwZXJtaWw7XCI6XCLigLBcIixcIiZsc2FxdW87XCI6XCLigLlcIixcIiZyc2FxdW87XCI6XCLigLpcIixcIiZldXJvO1wiOlwi4oKsXCIsXCImZm5vZjtcIjpcIsaSXCIsXCImQWxwaGE7XCI6XCLOkVwiLFwiJkJldGE7XCI6XCLOklwiLFwiJkdhbW1hO1wiOlwizpNcIixcIiZEZWx0YTtcIjpcIs6UXCIsXCImRXBzaWxvbjtcIjpcIs6VXCIsXCImWmV0YTtcIjpcIs6WXCIsXCImRXRhO1wiOlwizpdcIixcIiZUaGV0YTtcIjpcIs6YXCIsXCImSW90YTtcIjpcIs6ZXCIsXCImS2FwcGE7XCI6XCLOmlwiLFwiJkxhbWJkYTtcIjpcIs6bXCIsXCImTXU7XCI6XCLOnFwiLFwiJk51O1wiOlwizp1cIixcIiZYaTtcIjpcIs6eXCIsXCImT21pY3JvbjtcIjpcIs6fXCIsXCImUGk7XCI6XCLOoFwiLFwiJlJobztcIjpcIs6hXCIsXCImU2lnbWE7XCI6XCLOo1wiLFwiJlRhdTtcIjpcIs6kXCIsXCImVXBzaWxvbjtcIjpcIs6lXCIsXCImUGhpO1wiOlwizqZcIixcIiZDaGk7XCI6XCLOp1wiLFwiJlBzaTtcIjpcIs6oXCIsXCImT21lZ2E7XCI6XCLOqVwiLFwiJmFscGhhO1wiOlwizrFcIixcIiZiZXRhO1wiOlwizrJcIixcIiZnYW1tYTtcIjpcIs6zXCIsXCImZGVsdGE7XCI6XCLOtFwiLFwiJmVwc2lsb247XCI6XCLOtVwiLFwiJnpldGE7XCI6XCLOtlwiLFwiJmV0YTtcIjpcIs63XCIsXCImdGhldGE7XCI6XCLOuFwiLFwiJmlvdGE7XCI6XCLOuVwiLFwiJmthcHBhO1wiOlwizrpcIixcIiZsYW1iZGE7XCI6XCLOu1wiLFwiJm11O1wiOlwizrxcIixcIiZudTtcIjpcIs69XCIsXCImeGk7XCI6XCLOvlwiLFwiJm9taWNyb247XCI6XCLOv1wiLFwiJnBpO1wiOlwiz4BcIixcIiZyaG87XCI6XCLPgVwiLFwiJnNpZ21hZjtcIjpcIs+CXCIsXCImc2lnbWE7XCI6XCLPg1wiLFwiJnRhdTtcIjpcIs+EXCIsXCImdXBzaWxvbjtcIjpcIs+FXCIsXCImcGhpO1wiOlwiz4ZcIixcIiZjaGk7XCI6XCLPh1wiLFwiJnBzaTtcIjpcIs+IXCIsXCImb21lZ2E7XCI6XCLPiVwiLFwiJnRoZXRhc3ltO1wiOlwiz5FcIixcIiZ1cHNpaDtcIjpcIs+SXCIsXCImcGl2O1wiOlwiz5ZcIixcIiZidWxsO1wiOlwi4oCiXCIsXCImaGVsbGlwO1wiOlwi4oCmXCIsXCImcHJpbWU7XCI6XCLigLJcIixcIiZQcmltZTtcIjpcIuKAs1wiLFwiJm9saW5lO1wiOlwi4oC+XCIsXCImZnJhc2w7XCI6XCLigYRcIixcIiZ3ZWllcnA7XCI6XCLihJhcIixcIiZpbWFnZTtcIjpcIuKEkVwiLFwiJnJlYWw7XCI6XCLihJxcIixcIiZ0cmFkZTtcIjpcIuKEolwiLFwiJmFsZWZzeW07XCI6XCLihLVcIixcIiZsYXJyO1wiOlwi4oaQXCIsXCImdWFycjtcIjpcIuKGkVwiLFwiJnJhcnI7XCI6XCLihpJcIixcIiZkYXJyO1wiOlwi4oaTXCIsXCImaGFycjtcIjpcIuKGlFwiLFwiJmNyYXJyO1wiOlwi4oa1XCIsXCImbEFycjtcIjpcIuKHkFwiLFwiJnVBcnI7XCI6XCLih5FcIixcIiZyQXJyO1wiOlwi4oeSXCIsXCImZEFycjtcIjpcIuKHk1wiLFwiJmhBcnI7XCI6XCLih5RcIixcIiZmb3JhbGw7XCI6XCLiiIBcIixcIiZwYXJ0O1wiOlwi4oiCXCIsXCImZXhpc3Q7XCI6XCLiiINcIixcIiZlbXB0eTtcIjpcIuKIhVwiLFwiJm5hYmxhO1wiOlwi4oiHXCIsXCImaXNpbjtcIjpcIuKIiFwiLFwiJm5vdGluO1wiOlwi4oiJXCIsXCImbmk7XCI6XCLiiItcIixcIiZwcm9kO1wiOlwi4oiPXCIsXCImc3VtO1wiOlwi4oiRXCIsXCImbWludXM7XCI6XCLiiJJcIixcIiZsb3dhc3Q7XCI6XCLiiJdcIixcIiZyYWRpYztcIjpcIuKImlwiLFwiJnByb3A7XCI6XCLiiJ1cIixcIiZpbmZpbjtcIjpcIuKInlwiLFwiJmFuZztcIjpcIuKIoFwiLFwiJmFuZDtcIjpcIuKIp1wiLFwiJm9yO1wiOlwi4oioXCIsXCImY2FwO1wiOlwi4oipXCIsXCImY3VwO1wiOlwi4oiqXCIsXCImaW50O1wiOlwi4oirXCIsXCImdGhlcmU0O1wiOlwi4oi0XCIsXCImc2ltO1wiOlwi4oi8XCIsXCImY29uZztcIjpcIuKJhVwiLFwiJmFzeW1wO1wiOlwi4omIXCIsXCImbmU7XCI6XCLiiaBcIixcIiZlcXVpdjtcIjpcIuKJoVwiLFwiJmxlO1wiOlwi4omkXCIsXCImZ2U7XCI6XCLiiaVcIixcIiZzdWI7XCI6XCLiioJcIixcIiZzdXA7XCI6XCLiioNcIixcIiZuc3ViO1wiOlwi4oqEXCIsXCImc3ViZTtcIjpcIuKKhlwiLFwiJnN1cGU7XCI6XCLiiodcIixcIiZvcGx1cztcIjpcIuKKlVwiLFwiJm90aW1lcztcIjpcIuKKl1wiLFwiJnBlcnA7XCI6XCLiiqVcIixcIiZzZG90O1wiOlwi4ouFXCIsXCImbGNlaWw7XCI6XCLijIhcIixcIiZyY2VpbDtcIjpcIuKMiVwiLFwiJmxmbG9vcjtcIjpcIuKMilwiLFwiJnJmbG9vcjtcIjpcIuKMi1wiLFwiJmxhbmc7XCI6XCLijKlcIixcIiZyYW5nO1wiOlwi4oyqXCIsXCImbG96O1wiOlwi4peKXCIsXCImc3BhZGVzO1wiOlwi4pmgXCIsXCImY2x1YnM7XCI6XCLimaNcIixcIiZoZWFydHM7XCI6XCLimaVcIixcIiZkaWFtcztcIjpcIuKZplwifSxjaGFyYWN0ZXJzOntcIidcIjpcIiZhcG9zO1wiLFwiwqBcIjpcIiZuYnNwO1wiLFwiwqFcIjpcIiZpZXhjbDtcIixcIsKiXCI6XCImY2VudDtcIixcIsKjXCI6XCImcG91bmQ7XCIsXCLCpFwiOlwiJmN1cnJlbjtcIixcIsKlXCI6XCImeWVuO1wiLFwiwqZcIjpcIiZicnZiYXI7XCIsXCLCp1wiOlwiJnNlY3Q7XCIsXCLCqFwiOlwiJnVtbDtcIixcIsKpXCI6XCImY29weTtcIixcIsKqXCI6XCImb3JkZjtcIixcIsKrXCI6XCImbGFxdW87XCIsXCLCrFwiOlwiJm5vdDtcIixcIsKtXCI6XCImc2h5O1wiLFwiwq5cIjpcIiZyZWc7XCIsXCLCr1wiOlwiJm1hY3I7XCIsXCLCsFwiOlwiJmRlZztcIixcIsKxXCI6XCImcGx1c21uO1wiLFwiwrJcIjpcIiZzdXAyO1wiLFwiwrNcIjpcIiZzdXAzO1wiLFwiwrRcIjpcIiZhY3V0ZTtcIixcIsK1XCI6XCImbWljcm87XCIsXCLCtlwiOlwiJnBhcmE7XCIsXCLCt1wiOlwiJm1pZGRvdDtcIixcIsK4XCI6XCImY2VkaWw7XCIsXCLCuVwiOlwiJnN1cDE7XCIsXCLCulwiOlwiJm9yZG07XCIsXCLCu1wiOlwiJnJhcXVvO1wiLFwiwrxcIjpcIiZmcmFjMTQ7XCIsXCLCvVwiOlwiJmZyYWMxMjtcIixcIsK+XCI6XCImZnJhYzM0O1wiLFwiwr9cIjpcIiZpcXVlc3Q7XCIsXCLDgFwiOlwiJkFncmF2ZTtcIixcIsOBXCI6XCImQWFjdXRlO1wiLFwiw4JcIjpcIiZBY2lyYztcIixcIsODXCI6XCImQXRpbGRlO1wiLFwiw4RcIjpcIiZBdW1sO1wiLFwiw4VcIjpcIiZBcmluZztcIixcIsOGXCI6XCImQUVsaWc7XCIsXCLDh1wiOlwiJkNjZWRpbDtcIixcIsOIXCI6XCImRWdyYXZlO1wiLFwiw4lcIjpcIiZFYWN1dGU7XCIsXCLDilwiOlwiJkVjaXJjO1wiLFwiw4tcIjpcIiZFdW1sO1wiLFwiw4xcIjpcIiZJZ3JhdmU7XCIsXCLDjVwiOlwiJklhY3V0ZTtcIixcIsOOXCI6XCImSWNpcmM7XCIsXCLDj1wiOlwiJkl1bWw7XCIsXCLDkFwiOlwiJkVUSDtcIixcIsORXCI6XCImTnRpbGRlO1wiLFwiw5JcIjpcIiZPZ3JhdmU7XCIsXCLDk1wiOlwiJk9hY3V0ZTtcIixcIsOUXCI6XCImT2NpcmM7XCIsXCLDlVwiOlwiJk90aWxkZTtcIixcIsOWXCI6XCImT3VtbDtcIixcIsOXXCI6XCImdGltZXM7XCIsXCLDmFwiOlwiJk9zbGFzaDtcIixcIsOZXCI6XCImVWdyYXZlO1wiLFwiw5pcIjpcIiZVYWN1dGU7XCIsXCLDm1wiOlwiJlVjaXJjO1wiLFwiw5xcIjpcIiZVdW1sO1wiLFwiw51cIjpcIiZZYWN1dGU7XCIsXCLDnlwiOlwiJlRIT1JOO1wiLFwiw59cIjpcIiZzemxpZztcIixcIsOgXCI6XCImYWdyYXZlO1wiLFwiw6FcIjpcIiZhYWN1dGU7XCIsXCLDolwiOlwiJmFjaXJjO1wiLFwiw6NcIjpcIiZhdGlsZGU7XCIsXCLDpFwiOlwiJmF1bWw7XCIsXCLDpVwiOlwiJmFyaW5nO1wiLFwiw6ZcIjpcIiZhZWxpZztcIixcIsOnXCI6XCImY2NlZGlsO1wiLFwiw6hcIjpcIiZlZ3JhdmU7XCIsXCLDqVwiOlwiJmVhY3V0ZTtcIixcIsOqXCI6XCImZWNpcmM7XCIsXCLDq1wiOlwiJmV1bWw7XCIsXCLDrFwiOlwiJmlncmF2ZTtcIixcIsOtXCI6XCImaWFjdXRlO1wiLFwiw65cIjpcIiZpY2lyYztcIixcIsOvXCI6XCImaXVtbDtcIixcIsOwXCI6XCImZXRoO1wiLFwiw7FcIjpcIiZudGlsZGU7XCIsXCLDslwiOlwiJm9ncmF2ZTtcIixcIsOzXCI6XCImb2FjdXRlO1wiLFwiw7RcIjpcIiZvY2lyYztcIixcIsO1XCI6XCImb3RpbGRlO1wiLFwiw7ZcIjpcIiZvdW1sO1wiLFwiw7dcIjpcIiZkaXZpZGU7XCIsXCLDuFwiOlwiJm9zbGFzaDtcIixcIsO5XCI6XCImdWdyYXZlO1wiLFwiw7pcIjpcIiZ1YWN1dGU7XCIsXCLDu1wiOlwiJnVjaXJjO1wiLFwiw7xcIjpcIiZ1dW1sO1wiLFwiw71cIjpcIiZ5YWN1dGU7XCIsXCLDvlwiOlwiJnRob3JuO1wiLFwiw79cIjpcIiZ5dW1sO1wiLCdcIic6XCImcXVvdDtcIixcIiZcIjpcIiZhbXA7XCIsXCI8XCI6XCImbHQ7XCIsXCI+XCI6XCImZ3Q7XCIsXCLFklwiOlwiJk9FbGlnO1wiLFwixZNcIjpcIiZvZWxpZztcIixcIsWgXCI6XCImU2Nhcm9uO1wiLFwixaFcIjpcIiZzY2Fyb247XCIsXCLFuFwiOlwiJll1bWw7XCIsXCLLhlwiOlwiJmNpcmM7XCIsXCLLnFwiOlwiJnRpbGRlO1wiLFwi4oCCXCI6XCImZW5zcDtcIixcIuKAg1wiOlwiJmVtc3A7XCIsXCLigIlcIjpcIiZ0aGluc3A7XCIsXCLigIxcIjpcIiZ6d25qO1wiLFwi4oCNXCI6XCImendqO1wiLFwi4oCOXCI6XCImbHJtO1wiLFwi4oCPXCI6XCImcmxtO1wiLFwi4oCTXCI6XCImbmRhc2g7XCIsXCLigJRcIjpcIiZtZGFzaDtcIixcIuKAmFwiOlwiJmxzcXVvO1wiLFwi4oCZXCI6XCImcnNxdW87XCIsXCLigJpcIjpcIiZzYnF1bztcIixcIuKAnFwiOlwiJmxkcXVvO1wiLFwi4oCdXCI6XCImcmRxdW87XCIsXCLigJ5cIjpcIiZiZHF1bztcIixcIuKAoFwiOlwiJmRhZ2dlcjtcIixcIuKAoVwiOlwiJkRhZ2dlcjtcIixcIuKAsFwiOlwiJnBlcm1pbDtcIixcIuKAuVwiOlwiJmxzYXF1bztcIixcIuKAulwiOlwiJnJzYXF1bztcIixcIuKCrFwiOlwiJmV1cm87XCIsXCLGklwiOlwiJmZub2Y7XCIsXCLOkVwiOlwiJkFscGhhO1wiLFwizpJcIjpcIiZCZXRhO1wiLFwizpNcIjpcIiZHYW1tYTtcIixcIs6UXCI6XCImRGVsdGE7XCIsXCLOlVwiOlwiJkVwc2lsb247XCIsXCLOllwiOlwiJlpldGE7XCIsXCLOl1wiOlwiJkV0YTtcIixcIs6YXCI6XCImVGhldGE7XCIsXCLOmVwiOlwiJklvdGE7XCIsXCLOmlwiOlwiJkthcHBhO1wiLFwizptcIjpcIiZMYW1iZGE7XCIsXCLOnFwiOlwiJk11O1wiLFwizp1cIjpcIiZOdTtcIixcIs6eXCI6XCImWGk7XCIsXCLOn1wiOlwiJk9taWNyb247XCIsXCLOoFwiOlwiJlBpO1wiLFwizqFcIjpcIiZSaG87XCIsXCLOo1wiOlwiJlNpZ21hO1wiLFwizqRcIjpcIiZUYXU7XCIsXCLOpVwiOlwiJlVwc2lsb247XCIsXCLOplwiOlwiJlBoaTtcIixcIs6nXCI6XCImQ2hpO1wiLFwizqhcIjpcIiZQc2k7XCIsXCLOqVwiOlwiJk9tZWdhO1wiLFwizrFcIjpcIiZhbHBoYTtcIixcIs6yXCI6XCImYmV0YTtcIixcIs6zXCI6XCImZ2FtbWE7XCIsXCLOtFwiOlwiJmRlbHRhO1wiLFwizrVcIjpcIiZlcHNpbG9uO1wiLFwizrZcIjpcIiZ6ZXRhO1wiLFwizrdcIjpcIiZldGE7XCIsXCLOuFwiOlwiJnRoZXRhO1wiLFwizrlcIjpcIiZpb3RhO1wiLFwizrpcIjpcIiZrYXBwYTtcIixcIs67XCI6XCImbGFtYmRhO1wiLFwizrxcIjpcIiZtdTtcIixcIs69XCI6XCImbnU7XCIsXCLOvlwiOlwiJnhpO1wiLFwizr9cIjpcIiZvbWljcm9uO1wiLFwiz4BcIjpcIiZwaTtcIixcIs+BXCI6XCImcmhvO1wiLFwiz4JcIjpcIiZzaWdtYWY7XCIsXCLPg1wiOlwiJnNpZ21hO1wiLFwiz4RcIjpcIiZ0YXU7XCIsXCLPhVwiOlwiJnVwc2lsb247XCIsXCLPhlwiOlwiJnBoaTtcIixcIs+HXCI6XCImY2hpO1wiLFwiz4hcIjpcIiZwc2k7XCIsXCLPiVwiOlwiJm9tZWdhO1wiLFwiz5FcIjpcIiZ0aGV0YXN5bTtcIixcIs+SXCI6XCImdXBzaWg7XCIsXCLPllwiOlwiJnBpdjtcIixcIuKAolwiOlwiJmJ1bGw7XCIsXCLigKZcIjpcIiZoZWxsaXA7XCIsXCLigLJcIjpcIiZwcmltZTtcIixcIuKAs1wiOlwiJlByaW1lO1wiLFwi4oC+XCI6XCImb2xpbmU7XCIsXCLigYRcIjpcIiZmcmFzbDtcIixcIuKEmFwiOlwiJndlaWVycDtcIixcIuKEkVwiOlwiJmltYWdlO1wiLFwi4oScXCI6XCImcmVhbDtcIixcIuKEolwiOlwiJnRyYWRlO1wiLFwi4oS1XCI6XCImYWxlZnN5bTtcIixcIuKGkFwiOlwiJmxhcnI7XCIsXCLihpFcIjpcIiZ1YXJyO1wiLFwi4oaSXCI6XCImcmFycjtcIixcIuKGk1wiOlwiJmRhcnI7XCIsXCLihpRcIjpcIiZoYXJyO1wiLFwi4oa1XCI6XCImY3JhcnI7XCIsXCLih5BcIjpcIiZsQXJyO1wiLFwi4oeRXCI6XCImdUFycjtcIixcIuKHklwiOlwiJnJBcnI7XCIsXCLih5NcIjpcIiZkQXJyO1wiLFwi4oeUXCI6XCImaEFycjtcIixcIuKIgFwiOlwiJmZvcmFsbDtcIixcIuKIglwiOlwiJnBhcnQ7XCIsXCLiiINcIjpcIiZleGlzdDtcIixcIuKIhVwiOlwiJmVtcHR5O1wiLFwi4oiHXCI6XCImbmFibGE7XCIsXCLiiIhcIjpcIiZpc2luO1wiLFwi4oiJXCI6XCImbm90aW47XCIsXCLiiItcIjpcIiZuaTtcIixcIuKIj1wiOlwiJnByb2Q7XCIsXCLiiJFcIjpcIiZzdW07XCIsXCLiiJJcIjpcIiZtaW51cztcIixcIuKIl1wiOlwiJmxvd2FzdDtcIixcIuKImlwiOlwiJnJhZGljO1wiLFwi4oidXCI6XCImcHJvcDtcIixcIuKInlwiOlwiJmluZmluO1wiLFwi4oigXCI6XCImYW5nO1wiLFwi4oinXCI6XCImYW5kO1wiLFwi4oioXCI6XCImb3I7XCIsXCLiiKlcIjpcIiZjYXA7XCIsXCLiiKpcIjpcIiZjdXA7XCIsXCLiiKtcIjpcIiZpbnQ7XCIsXCLiiLRcIjpcIiZ0aGVyZTQ7XCIsXCLiiLxcIjpcIiZzaW07XCIsXCLiiYVcIjpcIiZjb25nO1wiLFwi4omIXCI6XCImYXN5bXA7XCIsXCLiiaBcIjpcIiZuZTtcIixcIuKJoVwiOlwiJmVxdWl2O1wiLFwi4omkXCI6XCImbGU7XCIsXCLiiaVcIjpcIiZnZTtcIixcIuKKglwiOlwiJnN1YjtcIixcIuKKg1wiOlwiJnN1cDtcIixcIuKKhFwiOlwiJm5zdWI7XCIsXCLiioZcIjpcIiZzdWJlO1wiLFwi4oqHXCI6XCImc3VwZTtcIixcIuKKlVwiOlwiJm9wbHVzO1wiLFwi4oqXXCI6XCImb3RpbWVzO1wiLFwi4oqlXCI6XCImcGVycDtcIixcIuKLhVwiOlwiJnNkb3Q7XCIsXCLijIhcIjpcIiZsY2VpbDtcIixcIuKMiVwiOlwiJnJjZWlsO1wiLFwi4oyKXCI6XCImbGZsb29yO1wiLFwi4oyLXCI6XCImcmZsb29yO1wiLFwi4oypXCI6XCImbGFuZztcIixcIuKMqlwiOlwiJnJhbmc7XCIsXCLil4pcIjpcIiZsb3o7XCIsXCLimaBcIjpcIiZzcGFkZXM7XCIsXCLimaNcIjpcIiZjbHVicztcIixcIuKZpVwiOlwiJmhlYXJ0cztcIixcIuKZplwiOlwiJmRpYW1zO1wifX0saHRtbDU6e2VudGl0aWVzOntcIiZBRWxpZ1wiOlwiw4ZcIixcIiZBRWxpZztcIjpcIsOGXCIsXCImQU1QXCI6XCImXCIsXCImQU1QO1wiOlwiJlwiLFwiJkFhY3V0ZVwiOlwiw4FcIixcIiZBYWN1dGU7XCI6XCLDgVwiLFwiJkFicmV2ZTtcIjpcIsSCXCIsXCImQWNpcmNcIjpcIsOCXCIsXCImQWNpcmM7XCI6XCLDglwiLFwiJkFjeTtcIjpcItCQXCIsXCImQWZyO1wiOlwi8J2UhFwiLFwiJkFncmF2ZVwiOlwiw4BcIixcIiZBZ3JhdmU7XCI6XCLDgFwiLFwiJkFscGhhO1wiOlwizpFcIixcIiZBbWFjcjtcIjpcIsSAXCIsXCImQW5kO1wiOlwi4qmTXCIsXCImQW9nb247XCI6XCLEhFwiLFwiJkFvcGY7XCI6XCLwnZS4XCIsXCImQXBwbHlGdW5jdGlvbjtcIjpcIuKBoVwiLFwiJkFyaW5nXCI6XCLDhVwiLFwiJkFyaW5nO1wiOlwiw4VcIixcIiZBc2NyO1wiOlwi8J2SnFwiLFwiJkFzc2lnbjtcIjpcIuKJlFwiLFwiJkF0aWxkZVwiOlwiw4NcIixcIiZBdGlsZGU7XCI6XCLDg1wiLFwiJkF1bWxcIjpcIsOEXCIsXCImQXVtbDtcIjpcIsOEXCIsXCImQmFja3NsYXNoO1wiOlwi4oiWXCIsXCImQmFydjtcIjpcIuKrp1wiLFwiJkJhcndlZDtcIjpcIuKMhlwiLFwiJkJjeTtcIjpcItCRXCIsXCImQmVjYXVzZTtcIjpcIuKItVwiLFwiJkJlcm5vdWxsaXM7XCI6XCLihKxcIixcIiZCZXRhO1wiOlwizpJcIixcIiZCZnI7XCI6XCLwnZSFXCIsXCImQm9wZjtcIjpcIvCdlLlcIixcIiZCcmV2ZTtcIjpcIsuYXCIsXCImQnNjcjtcIjpcIuKErFwiLFwiJkJ1bXBlcTtcIjpcIuKJjlwiLFwiJkNIY3k7XCI6XCLQp1wiLFwiJkNPUFlcIjpcIsKpXCIsXCImQ09QWTtcIjpcIsKpXCIsXCImQ2FjdXRlO1wiOlwixIZcIixcIiZDYXA7XCI6XCLii5JcIixcIiZDYXBpdGFsRGlmZmVyZW50aWFsRDtcIjpcIuKFhVwiLFwiJkNheWxleXM7XCI6XCLihK1cIixcIiZDY2Fyb247XCI6XCLEjFwiLFwiJkNjZWRpbFwiOlwiw4dcIixcIiZDY2VkaWw7XCI6XCLDh1wiLFwiJkNjaXJjO1wiOlwixIhcIixcIiZDY29uaW50O1wiOlwi4oiwXCIsXCImQ2RvdDtcIjpcIsSKXCIsXCImQ2VkaWxsYTtcIjpcIsK4XCIsXCImQ2VudGVyRG90O1wiOlwiwrdcIixcIiZDZnI7XCI6XCLihK1cIixcIiZDaGk7XCI6XCLOp1wiLFwiJkNpcmNsZURvdDtcIjpcIuKKmVwiLFwiJkNpcmNsZU1pbnVzO1wiOlwi4oqWXCIsXCImQ2lyY2xlUGx1cztcIjpcIuKKlVwiLFwiJkNpcmNsZVRpbWVzO1wiOlwi4oqXXCIsXCImQ2xvY2t3aXNlQ29udG91ckludGVncmFsO1wiOlwi4oiyXCIsXCImQ2xvc2VDdXJseURvdWJsZVF1b3RlO1wiOlwi4oCdXCIsXCImQ2xvc2VDdXJseVF1b3RlO1wiOlwi4oCZXCIsXCImQ29sb247XCI6XCLiiLdcIixcIiZDb2xvbmU7XCI6XCLiqbRcIixcIiZDb25ncnVlbnQ7XCI6XCLiiaFcIixcIiZDb25pbnQ7XCI6XCLiiK9cIixcIiZDb250b3VySW50ZWdyYWw7XCI6XCLiiK5cIixcIiZDb3BmO1wiOlwi4oSCXCIsXCImQ29wcm9kdWN0O1wiOlwi4oiQXCIsXCImQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDtcIjpcIuKIs1wiLFwiJkNyb3NzO1wiOlwi4qivXCIsXCImQ3NjcjtcIjpcIvCdkp5cIixcIiZDdXA7XCI6XCLii5NcIixcIiZDdXBDYXA7XCI6XCLiiY1cIixcIiZERDtcIjpcIuKFhVwiLFwiJkREb3RyYWhkO1wiOlwi4qSRXCIsXCImREpjeTtcIjpcItCCXCIsXCImRFNjeTtcIjpcItCFXCIsXCImRFpjeTtcIjpcItCPXCIsXCImRGFnZ2VyO1wiOlwi4oChXCIsXCImRGFycjtcIjpcIuKGoVwiLFwiJkRhc2h2O1wiOlwi4qukXCIsXCImRGNhcm9uO1wiOlwixI5cIixcIiZEY3k7XCI6XCLQlFwiLFwiJkRlbDtcIjpcIuKIh1wiLFwiJkRlbHRhO1wiOlwizpRcIixcIiZEZnI7XCI6XCLwnZSHXCIsXCImRGlhY3JpdGljYWxBY3V0ZTtcIjpcIsK0XCIsXCImRGlhY3JpdGljYWxEb3Q7XCI6XCLLmVwiLFwiJkRpYWNyaXRpY2FsRG91YmxlQWN1dGU7XCI6XCLLnVwiLFwiJkRpYWNyaXRpY2FsR3JhdmU7XCI6XCJgXCIsXCImRGlhY3JpdGljYWxUaWxkZTtcIjpcIsucXCIsXCImRGlhbW9uZDtcIjpcIuKLhFwiLFwiJkRpZmZlcmVudGlhbEQ7XCI6XCLihYZcIixcIiZEb3BmO1wiOlwi8J2Uu1wiLFwiJkRvdDtcIjpcIsKoXCIsXCImRG90RG90O1wiOlwi4oOcXCIsXCImRG90RXF1YWw7XCI6XCLiiZBcIixcIiZEb3VibGVDb250b3VySW50ZWdyYWw7XCI6XCLiiK9cIixcIiZEb3VibGVEb3Q7XCI6XCLCqFwiLFwiJkRvdWJsZURvd25BcnJvdztcIjpcIuKHk1wiLFwiJkRvdWJsZUxlZnRBcnJvdztcIjpcIuKHkFwiLFwiJkRvdWJsZUxlZnRSaWdodEFycm93O1wiOlwi4oeUXCIsXCImRG91YmxlTGVmdFRlZTtcIjpcIuKrpFwiLFwiJkRvdWJsZUxvbmdMZWZ0QXJyb3c7XCI6XCLin7hcIixcIiZEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c7XCI6XCLin7pcIixcIiZEb3VibGVMb25nUmlnaHRBcnJvdztcIjpcIuKfuVwiLFwiJkRvdWJsZVJpZ2h0QXJyb3c7XCI6XCLih5JcIixcIiZEb3VibGVSaWdodFRlZTtcIjpcIuKKqFwiLFwiJkRvdWJsZVVwQXJyb3c7XCI6XCLih5FcIixcIiZEb3VibGVVcERvd25BcnJvdztcIjpcIuKHlVwiLFwiJkRvdWJsZVZlcnRpY2FsQmFyO1wiOlwi4oilXCIsXCImRG93bkFycm93O1wiOlwi4oaTXCIsXCImRG93bkFycm93QmFyO1wiOlwi4qSTXCIsXCImRG93bkFycm93VXBBcnJvdztcIjpcIuKHtVwiLFwiJkRvd25CcmV2ZTtcIjpcIsyRXCIsXCImRG93bkxlZnRSaWdodFZlY3RvcjtcIjpcIuKlkFwiLFwiJkRvd25MZWZ0VGVlVmVjdG9yO1wiOlwi4qWeXCIsXCImRG93bkxlZnRWZWN0b3I7XCI6XCLihr1cIixcIiZEb3duTGVmdFZlY3RvckJhcjtcIjpcIuKlllwiLFwiJkRvd25SaWdodFRlZVZlY3RvcjtcIjpcIuKln1wiLFwiJkRvd25SaWdodFZlY3RvcjtcIjpcIuKHgVwiLFwiJkRvd25SaWdodFZlY3RvckJhcjtcIjpcIuKll1wiLFwiJkRvd25UZWU7XCI6XCLiiqRcIixcIiZEb3duVGVlQXJyb3c7XCI6XCLihqdcIixcIiZEb3duYXJyb3c7XCI6XCLih5NcIixcIiZEc2NyO1wiOlwi8J2Sn1wiLFwiJkRzdHJvaztcIjpcIsSQXCIsXCImRU5HO1wiOlwixYpcIixcIiZFVEhcIjpcIsOQXCIsXCImRVRIO1wiOlwiw5BcIixcIiZFYWN1dGVcIjpcIsOJXCIsXCImRWFjdXRlO1wiOlwiw4lcIixcIiZFY2Fyb247XCI6XCLEmlwiLFwiJkVjaXJjXCI6XCLDilwiLFwiJkVjaXJjO1wiOlwiw4pcIixcIiZFY3k7XCI6XCLQrVwiLFwiJkVkb3Q7XCI6XCLEllwiLFwiJkVmcjtcIjpcIvCdlIhcIixcIiZFZ3JhdmVcIjpcIsOIXCIsXCImRWdyYXZlO1wiOlwiw4hcIixcIiZFbGVtZW50O1wiOlwi4oiIXCIsXCImRW1hY3I7XCI6XCLEklwiLFwiJkVtcHR5U21hbGxTcXVhcmU7XCI6XCLil7tcIixcIiZFbXB0eVZlcnlTbWFsbFNxdWFyZTtcIjpcIuKWq1wiLFwiJkVvZ29uO1wiOlwixJhcIixcIiZFb3BmO1wiOlwi8J2UvFwiLFwiJkVwc2lsb247XCI6XCLOlVwiLFwiJkVxdWFsO1wiOlwi4qm1XCIsXCImRXF1YWxUaWxkZTtcIjpcIuKJglwiLFwiJkVxdWlsaWJyaXVtO1wiOlwi4oeMXCIsXCImRXNjcjtcIjpcIuKEsFwiLFwiJkVzaW07XCI6XCLiqbNcIixcIiZFdGE7XCI6XCLOl1wiLFwiJkV1bWxcIjpcIsOLXCIsXCImRXVtbDtcIjpcIsOLXCIsXCImRXhpc3RzO1wiOlwi4oiDXCIsXCImRXhwb25lbnRpYWxFO1wiOlwi4oWHXCIsXCImRmN5O1wiOlwi0KRcIixcIiZGZnI7XCI6XCLwnZSJXCIsXCImRmlsbGVkU21hbGxTcXVhcmU7XCI6XCLil7xcIixcIiZGaWxsZWRWZXJ5U21hbGxTcXVhcmU7XCI6XCLilqpcIixcIiZGb3BmO1wiOlwi8J2UvVwiLFwiJkZvckFsbDtcIjpcIuKIgFwiLFwiJkZvdXJpZXJ0cmY7XCI6XCLihLFcIixcIiZGc2NyO1wiOlwi4oSxXCIsXCImR0pjeTtcIjpcItCDXCIsXCImR1RcIjpcIj5cIixcIiZHVDtcIjpcIj5cIixcIiZHYW1tYTtcIjpcIs6TXCIsXCImR2FtbWFkO1wiOlwiz5xcIixcIiZHYnJldmU7XCI6XCLEnlwiLFwiJkdjZWRpbDtcIjpcIsSiXCIsXCImR2NpcmM7XCI6XCLEnFwiLFwiJkdjeTtcIjpcItCTXCIsXCImR2RvdDtcIjpcIsSgXCIsXCImR2ZyO1wiOlwi8J2UilwiLFwiJkdnO1wiOlwi4ouZXCIsXCImR29wZjtcIjpcIvCdlL5cIixcIiZHcmVhdGVyRXF1YWw7XCI6XCLiiaVcIixcIiZHcmVhdGVyRXF1YWxMZXNzO1wiOlwi4oubXCIsXCImR3JlYXRlckZ1bGxFcXVhbDtcIjpcIuKJp1wiLFwiJkdyZWF0ZXJHcmVhdGVyO1wiOlwi4qqiXCIsXCImR3JlYXRlckxlc3M7XCI6XCLiibdcIixcIiZHcmVhdGVyU2xhbnRFcXVhbDtcIjpcIuKpvlwiLFwiJkdyZWF0ZXJUaWxkZTtcIjpcIuKJs1wiLFwiJkdzY3I7XCI6XCLwnZKiXCIsXCImR3Q7XCI6XCLiiatcIixcIiZIQVJEY3k7XCI6XCLQqlwiLFwiJkhhY2VrO1wiOlwiy4dcIixcIiZIYXQ7XCI6XCJeXCIsXCImSGNpcmM7XCI6XCLEpFwiLFwiJkhmcjtcIjpcIuKEjFwiLFwiJkhpbGJlcnRTcGFjZTtcIjpcIuKEi1wiLFwiJkhvcGY7XCI6XCLihI1cIixcIiZIb3Jpem9udGFsTGluZTtcIjpcIuKUgFwiLFwiJkhzY3I7XCI6XCLihItcIixcIiZIc3Ryb2s7XCI6XCLEplwiLFwiJkh1bXBEb3duSHVtcDtcIjpcIuKJjlwiLFwiJkh1bXBFcXVhbDtcIjpcIuKJj1wiLFwiJklFY3k7XCI6XCLQlVwiLFwiJklKbGlnO1wiOlwixLJcIixcIiZJT2N5O1wiOlwi0IFcIixcIiZJYWN1dGVcIjpcIsONXCIsXCImSWFjdXRlO1wiOlwiw41cIixcIiZJY2lyY1wiOlwiw45cIixcIiZJY2lyYztcIjpcIsOOXCIsXCImSWN5O1wiOlwi0JhcIixcIiZJZG90O1wiOlwixLBcIixcIiZJZnI7XCI6XCLihJFcIixcIiZJZ3JhdmVcIjpcIsOMXCIsXCImSWdyYXZlO1wiOlwiw4xcIixcIiZJbTtcIjpcIuKEkVwiLFwiJkltYWNyO1wiOlwixKpcIixcIiZJbWFnaW5hcnlJO1wiOlwi4oWIXCIsXCImSW1wbGllcztcIjpcIuKHklwiLFwiJkludDtcIjpcIuKIrFwiLFwiJkludGVncmFsO1wiOlwi4oirXCIsXCImSW50ZXJzZWN0aW9uO1wiOlwi4ouCXCIsXCImSW52aXNpYmxlQ29tbWE7XCI6XCLigaNcIixcIiZJbnZpc2libGVUaW1lcztcIjpcIuKBolwiLFwiJklvZ29uO1wiOlwixK5cIixcIiZJb3BmO1wiOlwi8J2VgFwiLFwiJklvdGE7XCI6XCLOmVwiLFwiJklzY3I7XCI6XCLihJBcIixcIiZJdGlsZGU7XCI6XCLEqFwiLFwiJkl1a2N5O1wiOlwi0IZcIixcIiZJdW1sXCI6XCLDj1wiLFwiJkl1bWw7XCI6XCLDj1wiLFwiJkpjaXJjO1wiOlwixLRcIixcIiZKY3k7XCI6XCLQmVwiLFwiJkpmcjtcIjpcIvCdlI1cIixcIiZKb3BmO1wiOlwi8J2VgVwiLFwiJkpzY3I7XCI6XCLwnZKlXCIsXCImSnNlcmN5O1wiOlwi0IhcIixcIiZKdWtjeTtcIjpcItCEXCIsXCImS0hjeTtcIjpcItClXCIsXCImS0pjeTtcIjpcItCMXCIsXCImS2FwcGE7XCI6XCLOmlwiLFwiJktjZWRpbDtcIjpcIsS2XCIsXCImS2N5O1wiOlwi0JpcIixcIiZLZnI7XCI6XCLwnZSOXCIsXCImS29wZjtcIjpcIvCdlYJcIixcIiZLc2NyO1wiOlwi8J2SplwiLFwiJkxKY3k7XCI6XCLQiVwiLFwiJkxUXCI6XCI8XCIsXCImTFQ7XCI6XCI8XCIsXCImTGFjdXRlO1wiOlwixLlcIixcIiZMYW1iZGE7XCI6XCLOm1wiLFwiJkxhbmc7XCI6XCLin6pcIixcIiZMYXBsYWNldHJmO1wiOlwi4oSSXCIsXCImTGFycjtcIjpcIuKGnlwiLFwiJkxjYXJvbjtcIjpcIsS9XCIsXCImTGNlZGlsO1wiOlwixLtcIixcIiZMY3k7XCI6XCLQm1wiLFwiJkxlZnRBbmdsZUJyYWNrZXQ7XCI6XCLin6hcIixcIiZMZWZ0QXJyb3c7XCI6XCLihpBcIixcIiZMZWZ0QXJyb3dCYXI7XCI6XCLih6RcIixcIiZMZWZ0QXJyb3dSaWdodEFycm93O1wiOlwi4oeGXCIsXCImTGVmdENlaWxpbmc7XCI6XCLijIhcIixcIiZMZWZ0RG91YmxlQnJhY2tldDtcIjpcIuKfplwiLFwiJkxlZnREb3duVGVlVmVjdG9yO1wiOlwi4qWhXCIsXCImTGVmdERvd25WZWN0b3I7XCI6XCLih4NcIixcIiZMZWZ0RG93blZlY3RvckJhcjtcIjpcIuKlmVwiLFwiJkxlZnRGbG9vcjtcIjpcIuKMilwiLFwiJkxlZnRSaWdodEFycm93O1wiOlwi4oaUXCIsXCImTGVmdFJpZ2h0VmVjdG9yO1wiOlwi4qWOXCIsXCImTGVmdFRlZTtcIjpcIuKKo1wiLFwiJkxlZnRUZWVBcnJvdztcIjpcIuKGpFwiLFwiJkxlZnRUZWVWZWN0b3I7XCI6XCLipZpcIixcIiZMZWZ0VHJpYW5nbGU7XCI6XCLiirJcIixcIiZMZWZ0VHJpYW5nbGVCYXI7XCI6XCLip49cIixcIiZMZWZ0VHJpYW5nbGVFcXVhbDtcIjpcIuKKtFwiLFwiJkxlZnRVcERvd25WZWN0b3I7XCI6XCLipZFcIixcIiZMZWZ0VXBUZWVWZWN0b3I7XCI6XCLipaBcIixcIiZMZWZ0VXBWZWN0b3I7XCI6XCLihr9cIixcIiZMZWZ0VXBWZWN0b3JCYXI7XCI6XCLipZhcIixcIiZMZWZ0VmVjdG9yO1wiOlwi4oa8XCIsXCImTGVmdFZlY3RvckJhcjtcIjpcIuKlklwiLFwiJkxlZnRhcnJvdztcIjpcIuKHkFwiLFwiJkxlZnRyaWdodGFycm93O1wiOlwi4oeUXCIsXCImTGVzc0VxdWFsR3JlYXRlcjtcIjpcIuKLmlwiLFwiJkxlc3NGdWxsRXF1YWw7XCI6XCLiiaZcIixcIiZMZXNzR3JlYXRlcjtcIjpcIuKJtlwiLFwiJkxlc3NMZXNzO1wiOlwi4qqhXCIsXCImTGVzc1NsYW50RXF1YWw7XCI6XCLiqb1cIixcIiZMZXNzVGlsZGU7XCI6XCLiibJcIixcIiZMZnI7XCI6XCLwnZSPXCIsXCImTGw7XCI6XCLii5hcIixcIiZMbGVmdGFycm93O1wiOlwi4oeaXCIsXCImTG1pZG90O1wiOlwixL9cIixcIiZMb25nTGVmdEFycm93O1wiOlwi4p+1XCIsXCImTG9uZ0xlZnRSaWdodEFycm93O1wiOlwi4p+3XCIsXCImTG9uZ1JpZ2h0QXJyb3c7XCI6XCLin7ZcIixcIiZMb25nbGVmdGFycm93O1wiOlwi4p+4XCIsXCImTG9uZ2xlZnRyaWdodGFycm93O1wiOlwi4p+6XCIsXCImTG9uZ3JpZ2h0YXJyb3c7XCI6XCLin7lcIixcIiZMb3BmO1wiOlwi8J2Vg1wiLFwiJkxvd2VyTGVmdEFycm93O1wiOlwi4oaZXCIsXCImTG93ZXJSaWdodEFycm93O1wiOlwi4oaYXCIsXCImTHNjcjtcIjpcIuKEklwiLFwiJkxzaDtcIjpcIuKGsFwiLFwiJkxzdHJvaztcIjpcIsWBXCIsXCImTHQ7XCI6XCLiiapcIixcIiZNYXA7XCI6XCLipIVcIixcIiZNY3k7XCI6XCLQnFwiLFwiJk1lZGl1bVNwYWNlO1wiOlwi4oGfXCIsXCImTWVsbGludHJmO1wiOlwi4oSzXCIsXCImTWZyO1wiOlwi8J2UkFwiLFwiJk1pbnVzUGx1cztcIjpcIuKIk1wiLFwiJk1vcGY7XCI6XCLwnZWEXCIsXCImTXNjcjtcIjpcIuKEs1wiLFwiJk11O1wiOlwizpxcIixcIiZOSmN5O1wiOlwi0IpcIixcIiZOYWN1dGU7XCI6XCLFg1wiLFwiJk5jYXJvbjtcIjpcIsWHXCIsXCImTmNlZGlsO1wiOlwixYVcIixcIiZOY3k7XCI6XCLQnVwiLFwiJk5lZ2F0aXZlTWVkaXVtU3BhY2U7XCI6XCLigItcIixcIiZOZWdhdGl2ZVRoaWNrU3BhY2U7XCI6XCLigItcIixcIiZOZWdhdGl2ZVRoaW5TcGFjZTtcIjpcIuKAi1wiLFwiJk5lZ2F0aXZlVmVyeVRoaW5TcGFjZTtcIjpcIuKAi1wiLFwiJk5lc3RlZEdyZWF0ZXJHcmVhdGVyO1wiOlwi4omrXCIsXCImTmVzdGVkTGVzc0xlc3M7XCI6XCLiiapcIixcIiZOZXdMaW5lO1wiOlwiXFxuXCIsXCImTmZyO1wiOlwi8J2UkVwiLFwiJk5vQnJlYWs7XCI6XCLigaBcIixcIiZOb25CcmVha2luZ1NwYWNlO1wiOlwiwqBcIixcIiZOb3BmO1wiOlwi4oSVXCIsXCImTm90O1wiOlwi4qusXCIsXCImTm90Q29uZ3J1ZW50O1wiOlwi4omiXCIsXCImTm90Q3VwQ2FwO1wiOlwi4omtXCIsXCImTm90RG91YmxlVmVydGljYWxCYXI7XCI6XCLiiKZcIixcIiZOb3RFbGVtZW50O1wiOlwi4oiJXCIsXCImTm90RXF1YWw7XCI6XCLiiaBcIixcIiZOb3RFcXVhbFRpbGRlO1wiOlwi4omCzLhcIixcIiZOb3RFeGlzdHM7XCI6XCLiiIRcIixcIiZOb3RHcmVhdGVyO1wiOlwi4omvXCIsXCImTm90R3JlYXRlckVxdWFsO1wiOlwi4omxXCIsXCImTm90R3JlYXRlckZ1bGxFcXVhbDtcIjpcIuKJp8y4XCIsXCImTm90R3JlYXRlckdyZWF0ZXI7XCI6XCLiiavMuFwiLFwiJk5vdEdyZWF0ZXJMZXNzO1wiOlwi4om5XCIsXCImTm90R3JlYXRlclNsYW50RXF1YWw7XCI6XCLiqb7MuFwiLFwiJk5vdEdyZWF0ZXJUaWxkZTtcIjpcIuKJtVwiLFwiJk5vdEh1bXBEb3duSHVtcDtcIjpcIuKJjsy4XCIsXCImTm90SHVtcEVxdWFsO1wiOlwi4omPzLhcIixcIiZOb3RMZWZ0VHJpYW5nbGU7XCI6XCLii6pcIixcIiZOb3RMZWZ0VHJpYW5nbGVCYXI7XCI6XCLip4/MuFwiLFwiJk5vdExlZnRUcmlhbmdsZUVxdWFsO1wiOlwi4ousXCIsXCImTm90TGVzcztcIjpcIuKJrlwiLFwiJk5vdExlc3NFcXVhbDtcIjpcIuKJsFwiLFwiJk5vdExlc3NHcmVhdGVyO1wiOlwi4om4XCIsXCImTm90TGVzc0xlc3M7XCI6XCLiiarMuFwiLFwiJk5vdExlc3NTbGFudEVxdWFsO1wiOlwi4qm9zLhcIixcIiZOb3RMZXNzVGlsZGU7XCI6XCLiibRcIixcIiZOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjtcIjpcIuKqosy4XCIsXCImTm90TmVzdGVkTGVzc0xlc3M7XCI6XCLiqqHMuFwiLFwiJk5vdFByZWNlZGVzO1wiOlwi4oqAXCIsXCImTm90UHJlY2VkZXNFcXVhbDtcIjpcIuKqr8y4XCIsXCImTm90UHJlY2VkZXNTbGFudEVxdWFsO1wiOlwi4ougXCIsXCImTm90UmV2ZXJzZUVsZW1lbnQ7XCI6XCLiiIxcIixcIiZOb3RSaWdodFRyaWFuZ2xlO1wiOlwi4ourXCIsXCImTm90UmlnaHRUcmlhbmdsZUJhcjtcIjpcIuKnkMy4XCIsXCImTm90UmlnaHRUcmlhbmdsZUVxdWFsO1wiOlwi4outXCIsXCImTm90U3F1YXJlU3Vic2V0O1wiOlwi4oqPzLhcIixcIiZOb3RTcXVhcmVTdWJzZXRFcXVhbDtcIjpcIuKLolwiLFwiJk5vdFNxdWFyZVN1cGVyc2V0O1wiOlwi4oqQzLhcIixcIiZOb3RTcXVhcmVTdXBlcnNldEVxdWFsO1wiOlwi4oujXCIsXCImTm90U3Vic2V0O1wiOlwi4oqC4oOSXCIsXCImTm90U3Vic2V0RXF1YWw7XCI6XCLiiohcIixcIiZOb3RTdWNjZWVkcztcIjpcIuKKgVwiLFwiJk5vdFN1Y2NlZWRzRXF1YWw7XCI6XCLiqrDMuFwiLFwiJk5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtcIjpcIuKLoVwiLFwiJk5vdFN1Y2NlZWRzVGlsZGU7XCI6XCLiib/MuFwiLFwiJk5vdFN1cGVyc2V0O1wiOlwi4oqD4oOSXCIsXCImTm90U3VwZXJzZXRFcXVhbDtcIjpcIuKKiVwiLFwiJk5vdFRpbGRlO1wiOlwi4omBXCIsXCImTm90VGlsZGVFcXVhbDtcIjpcIuKJhFwiLFwiJk5vdFRpbGRlRnVsbEVxdWFsO1wiOlwi4omHXCIsXCImTm90VGlsZGVUaWxkZTtcIjpcIuKJiVwiLFwiJk5vdFZlcnRpY2FsQmFyO1wiOlwi4oikXCIsXCImTnNjcjtcIjpcIvCdkqlcIixcIiZOdGlsZGVcIjpcIsORXCIsXCImTnRpbGRlO1wiOlwiw5FcIixcIiZOdTtcIjpcIs6dXCIsXCImT0VsaWc7XCI6XCLFklwiLFwiJk9hY3V0ZVwiOlwiw5NcIixcIiZPYWN1dGU7XCI6XCLDk1wiLFwiJk9jaXJjXCI6XCLDlFwiLFwiJk9jaXJjO1wiOlwiw5RcIixcIiZPY3k7XCI6XCLQnlwiLFwiJk9kYmxhYztcIjpcIsWQXCIsXCImT2ZyO1wiOlwi8J2UklwiLFwiJk9ncmF2ZVwiOlwiw5JcIixcIiZPZ3JhdmU7XCI6XCLDklwiLFwiJk9tYWNyO1wiOlwixYxcIixcIiZPbWVnYTtcIjpcIs6pXCIsXCImT21pY3JvbjtcIjpcIs6fXCIsXCImT29wZjtcIjpcIvCdlYZcIixcIiZPcGVuQ3VybHlEb3VibGVRdW90ZTtcIjpcIuKAnFwiLFwiJk9wZW5DdXJseVF1b3RlO1wiOlwi4oCYXCIsXCImT3I7XCI6XCLiqZRcIixcIiZPc2NyO1wiOlwi8J2SqlwiLFwiJk9zbGFzaFwiOlwiw5hcIixcIiZPc2xhc2g7XCI6XCLDmFwiLFwiJk90aWxkZVwiOlwiw5VcIixcIiZPdGlsZGU7XCI6XCLDlVwiLFwiJk90aW1lcztcIjpcIuKot1wiLFwiJk91bWxcIjpcIsOWXCIsXCImT3VtbDtcIjpcIsOWXCIsXCImT3ZlckJhcjtcIjpcIuKAvlwiLFwiJk92ZXJCcmFjZTtcIjpcIuKPnlwiLFwiJk92ZXJCcmFja2V0O1wiOlwi4o60XCIsXCImT3ZlclBhcmVudGhlc2lzO1wiOlwi4o+cXCIsXCImUGFydGlhbEQ7XCI6XCLiiIJcIixcIiZQY3k7XCI6XCLQn1wiLFwiJlBmcjtcIjpcIvCdlJNcIixcIiZQaGk7XCI6XCLOplwiLFwiJlBpO1wiOlwizqBcIixcIiZQbHVzTWludXM7XCI6XCLCsVwiLFwiJlBvaW5jYXJlcGxhbmU7XCI6XCLihIxcIixcIiZQb3BmO1wiOlwi4oSZXCIsXCImUHI7XCI6XCLiqrtcIixcIiZQcmVjZWRlcztcIjpcIuKJulwiLFwiJlByZWNlZGVzRXF1YWw7XCI6XCLiqq9cIixcIiZQcmVjZWRlc1NsYW50RXF1YWw7XCI6XCLiibxcIixcIiZQcmVjZWRlc1RpbGRlO1wiOlwi4om+XCIsXCImUHJpbWU7XCI6XCLigLNcIixcIiZQcm9kdWN0O1wiOlwi4oiPXCIsXCImUHJvcG9ydGlvbjtcIjpcIuKIt1wiLFwiJlByb3BvcnRpb25hbDtcIjpcIuKInVwiLFwiJlBzY3I7XCI6XCLwnZKrXCIsXCImUHNpO1wiOlwizqhcIixcIiZRVU9UXCI6J1wiJyxcIiZRVU9UO1wiOidcIicsXCImUWZyO1wiOlwi8J2UlFwiLFwiJlFvcGY7XCI6XCLihJpcIixcIiZRc2NyO1wiOlwi8J2SrFwiLFwiJlJCYXJyO1wiOlwi4qSQXCIsXCImUkVHXCI6XCLCrlwiLFwiJlJFRztcIjpcIsKuXCIsXCImUmFjdXRlO1wiOlwixZRcIixcIiZSYW5nO1wiOlwi4p+rXCIsXCImUmFycjtcIjpcIuKGoFwiLFwiJlJhcnJ0bDtcIjpcIuKkllwiLFwiJlJjYXJvbjtcIjpcIsWYXCIsXCImUmNlZGlsO1wiOlwixZZcIixcIiZSY3k7XCI6XCLQoFwiLFwiJlJlO1wiOlwi4oScXCIsXCImUmV2ZXJzZUVsZW1lbnQ7XCI6XCLiiItcIixcIiZSZXZlcnNlRXF1aWxpYnJpdW07XCI6XCLih4tcIixcIiZSZXZlcnNlVXBFcXVpbGlicml1bTtcIjpcIuKlr1wiLFwiJlJmcjtcIjpcIuKEnFwiLFwiJlJobztcIjpcIs6hXCIsXCImUmlnaHRBbmdsZUJyYWNrZXQ7XCI6XCLin6lcIixcIiZSaWdodEFycm93O1wiOlwi4oaSXCIsXCImUmlnaHRBcnJvd0JhcjtcIjpcIuKHpVwiLFwiJlJpZ2h0QXJyb3dMZWZ0QXJyb3c7XCI6XCLih4RcIixcIiZSaWdodENlaWxpbmc7XCI6XCLijIlcIixcIiZSaWdodERvdWJsZUJyYWNrZXQ7XCI6XCLin6dcIixcIiZSaWdodERvd25UZWVWZWN0b3I7XCI6XCLipZ1cIixcIiZSaWdodERvd25WZWN0b3I7XCI6XCLih4JcIixcIiZSaWdodERvd25WZWN0b3JCYXI7XCI6XCLipZVcIixcIiZSaWdodEZsb29yO1wiOlwi4oyLXCIsXCImUmlnaHRUZWU7XCI6XCLiiqJcIixcIiZSaWdodFRlZUFycm93O1wiOlwi4oamXCIsXCImUmlnaHRUZWVWZWN0b3I7XCI6XCLipZtcIixcIiZSaWdodFRyaWFuZ2xlO1wiOlwi4oqzXCIsXCImUmlnaHRUcmlhbmdsZUJhcjtcIjpcIuKnkFwiLFwiJlJpZ2h0VHJpYW5nbGVFcXVhbDtcIjpcIuKKtVwiLFwiJlJpZ2h0VXBEb3duVmVjdG9yO1wiOlwi4qWPXCIsXCImUmlnaHRVcFRlZVZlY3RvcjtcIjpcIuKlnFwiLFwiJlJpZ2h0VXBWZWN0b3I7XCI6XCLihr5cIixcIiZSaWdodFVwVmVjdG9yQmFyO1wiOlwi4qWUXCIsXCImUmlnaHRWZWN0b3I7XCI6XCLih4BcIixcIiZSaWdodFZlY3RvckJhcjtcIjpcIuKlk1wiLFwiJlJpZ2h0YXJyb3c7XCI6XCLih5JcIixcIiZSb3BmO1wiOlwi4oSdXCIsXCImUm91bmRJbXBsaWVzO1wiOlwi4qWwXCIsXCImUnJpZ2h0YXJyb3c7XCI6XCLih5tcIixcIiZSc2NyO1wiOlwi4oSbXCIsXCImUnNoO1wiOlwi4oaxXCIsXCImUnVsZURlbGF5ZWQ7XCI6XCLip7RcIixcIiZTSENIY3k7XCI6XCLQqVwiLFwiJlNIY3k7XCI6XCLQqFwiLFwiJlNPRlRjeTtcIjpcItCsXCIsXCImU2FjdXRlO1wiOlwixZpcIixcIiZTYztcIjpcIuKqvFwiLFwiJlNjYXJvbjtcIjpcIsWgXCIsXCImU2NlZGlsO1wiOlwixZ5cIixcIiZTY2lyYztcIjpcIsWcXCIsXCImU2N5O1wiOlwi0KFcIixcIiZTZnI7XCI6XCLwnZSWXCIsXCImU2hvcnREb3duQXJyb3c7XCI6XCLihpNcIixcIiZTaG9ydExlZnRBcnJvdztcIjpcIuKGkFwiLFwiJlNob3J0UmlnaHRBcnJvdztcIjpcIuKGklwiLFwiJlNob3J0VXBBcnJvdztcIjpcIuKGkVwiLFwiJlNpZ21hO1wiOlwizqNcIixcIiZTbWFsbENpcmNsZTtcIjpcIuKImFwiLFwiJlNvcGY7XCI6XCLwnZWKXCIsXCImU3FydDtcIjpcIuKImlwiLFwiJlNxdWFyZTtcIjpcIuKWoVwiLFwiJlNxdWFyZUludGVyc2VjdGlvbjtcIjpcIuKKk1wiLFwiJlNxdWFyZVN1YnNldDtcIjpcIuKKj1wiLFwiJlNxdWFyZVN1YnNldEVxdWFsO1wiOlwi4oqRXCIsXCImU3F1YXJlU3VwZXJzZXQ7XCI6XCLiipBcIixcIiZTcXVhcmVTdXBlcnNldEVxdWFsO1wiOlwi4oqSXCIsXCImU3F1YXJlVW5pb247XCI6XCLiipRcIixcIiZTc2NyO1wiOlwi8J2SrlwiLFwiJlN0YXI7XCI6XCLii4ZcIixcIiZTdWI7XCI6XCLii5BcIixcIiZTdWJzZXQ7XCI6XCLii5BcIixcIiZTdWJzZXRFcXVhbDtcIjpcIuKKhlwiLFwiJlN1Y2NlZWRzO1wiOlwi4om7XCIsXCImU3VjY2VlZHNFcXVhbDtcIjpcIuKqsFwiLFwiJlN1Y2NlZWRzU2xhbnRFcXVhbDtcIjpcIuKJvVwiLFwiJlN1Y2NlZWRzVGlsZGU7XCI6XCLiib9cIixcIiZTdWNoVGhhdDtcIjpcIuKIi1wiLFwiJlN1bTtcIjpcIuKIkVwiLFwiJlN1cDtcIjpcIuKLkVwiLFwiJlN1cGVyc2V0O1wiOlwi4oqDXCIsXCImU3VwZXJzZXRFcXVhbDtcIjpcIuKKh1wiLFwiJlN1cHNldDtcIjpcIuKLkVwiLFwiJlRIT1JOXCI6XCLDnlwiLFwiJlRIT1JOO1wiOlwiw55cIixcIiZUUkFERTtcIjpcIuKEolwiLFwiJlRTSGN5O1wiOlwi0ItcIixcIiZUU2N5O1wiOlwi0KZcIixcIiZUYWI7XCI6XCJcXHRcIixcIiZUYXU7XCI6XCLOpFwiLFwiJlRjYXJvbjtcIjpcIsWkXCIsXCImVGNlZGlsO1wiOlwixaJcIixcIiZUY3k7XCI6XCLQolwiLFwiJlRmcjtcIjpcIvCdlJdcIixcIiZUaGVyZWZvcmU7XCI6XCLiiLRcIixcIiZUaGV0YTtcIjpcIs6YXCIsXCImVGhpY2tTcGFjZTtcIjpcIuKBn+KAilwiLFwiJlRoaW5TcGFjZTtcIjpcIuKAiVwiLFwiJlRpbGRlO1wiOlwi4oi8XCIsXCImVGlsZGVFcXVhbDtcIjpcIuKJg1wiLFwiJlRpbGRlRnVsbEVxdWFsO1wiOlwi4omFXCIsXCImVGlsZGVUaWxkZTtcIjpcIuKJiFwiLFwiJlRvcGY7XCI6XCLwnZWLXCIsXCImVHJpcGxlRG90O1wiOlwi4oObXCIsXCImVHNjcjtcIjpcIvCdkq9cIixcIiZUc3Ryb2s7XCI6XCLFplwiLFwiJlVhY3V0ZVwiOlwiw5pcIixcIiZVYWN1dGU7XCI6XCLDmlwiLFwiJlVhcnI7XCI6XCLihp9cIixcIiZVYXJyb2NpcjtcIjpcIuKliVwiLFwiJlVicmN5O1wiOlwi0I5cIixcIiZVYnJldmU7XCI6XCLFrFwiLFwiJlVjaXJjXCI6XCLDm1wiLFwiJlVjaXJjO1wiOlwiw5tcIixcIiZVY3k7XCI6XCLQo1wiLFwiJlVkYmxhYztcIjpcIsWwXCIsXCImVWZyO1wiOlwi8J2UmFwiLFwiJlVncmF2ZVwiOlwiw5lcIixcIiZVZ3JhdmU7XCI6XCLDmVwiLFwiJlVtYWNyO1wiOlwixapcIixcIiZVbmRlckJhcjtcIjpcIl9cIixcIiZVbmRlckJyYWNlO1wiOlwi4o+fXCIsXCImVW5kZXJCcmFja2V0O1wiOlwi4o61XCIsXCImVW5kZXJQYXJlbnRoZXNpcztcIjpcIuKPnVwiLFwiJlVuaW9uO1wiOlwi4ouDXCIsXCImVW5pb25QbHVzO1wiOlwi4oqOXCIsXCImVW9nb247XCI6XCLFslwiLFwiJlVvcGY7XCI6XCLwnZWMXCIsXCImVXBBcnJvdztcIjpcIuKGkVwiLFwiJlVwQXJyb3dCYXI7XCI6XCLipJJcIixcIiZVcEFycm93RG93bkFycm93O1wiOlwi4oeFXCIsXCImVXBEb3duQXJyb3c7XCI6XCLihpVcIixcIiZVcEVxdWlsaWJyaXVtO1wiOlwi4qWuXCIsXCImVXBUZWU7XCI6XCLiiqVcIixcIiZVcFRlZUFycm93O1wiOlwi4oalXCIsXCImVXBhcnJvdztcIjpcIuKHkVwiLFwiJlVwZG93bmFycm93O1wiOlwi4oeVXCIsXCImVXBwZXJMZWZ0QXJyb3c7XCI6XCLihpZcIixcIiZVcHBlclJpZ2h0QXJyb3c7XCI6XCLihpdcIixcIiZVcHNpO1wiOlwiz5JcIixcIiZVcHNpbG9uO1wiOlwizqVcIixcIiZVcmluZztcIjpcIsWuXCIsXCImVXNjcjtcIjpcIvCdkrBcIixcIiZVdGlsZGU7XCI6XCLFqFwiLFwiJlV1bWxcIjpcIsOcXCIsXCImVXVtbDtcIjpcIsOcXCIsXCImVkRhc2g7XCI6XCLiiqtcIixcIiZWYmFyO1wiOlwi4qurXCIsXCImVmN5O1wiOlwi0JJcIixcIiZWZGFzaDtcIjpcIuKKqVwiLFwiJlZkYXNobDtcIjpcIuKrplwiLFwiJlZlZTtcIjpcIuKLgVwiLFwiJlZlcmJhcjtcIjpcIuKAllwiLFwiJlZlcnQ7XCI6XCLigJZcIixcIiZWZXJ0aWNhbEJhcjtcIjpcIuKIo1wiLFwiJlZlcnRpY2FsTGluZTtcIjpcInxcIixcIiZWZXJ0aWNhbFNlcGFyYXRvcjtcIjpcIuKdmFwiLFwiJlZlcnRpY2FsVGlsZGU7XCI6XCLiiYBcIixcIiZWZXJ5VGhpblNwYWNlO1wiOlwi4oCKXCIsXCImVmZyO1wiOlwi8J2UmVwiLFwiJlZvcGY7XCI6XCLwnZWNXCIsXCImVnNjcjtcIjpcIvCdkrFcIixcIiZWdmRhc2g7XCI6XCLiiqpcIixcIiZXY2lyYztcIjpcIsW0XCIsXCImV2VkZ2U7XCI6XCLii4BcIixcIiZXZnI7XCI6XCLwnZSaXCIsXCImV29wZjtcIjpcIvCdlY5cIixcIiZXc2NyO1wiOlwi8J2SslwiLFwiJlhmcjtcIjpcIvCdlJtcIixcIiZYaTtcIjpcIs6eXCIsXCImWG9wZjtcIjpcIvCdlY9cIixcIiZYc2NyO1wiOlwi8J2Ss1wiLFwiJllBY3k7XCI6XCLQr1wiLFwiJllJY3k7XCI6XCLQh1wiLFwiJllVY3k7XCI6XCLQrlwiLFwiJllhY3V0ZVwiOlwiw51cIixcIiZZYWN1dGU7XCI6XCLDnVwiLFwiJlljaXJjO1wiOlwixbZcIixcIiZZY3k7XCI6XCLQq1wiLFwiJllmcjtcIjpcIvCdlJxcIixcIiZZb3BmO1wiOlwi8J2VkFwiLFwiJllzY3I7XCI6XCLwnZK0XCIsXCImWXVtbDtcIjpcIsW4XCIsXCImWkhjeTtcIjpcItCWXCIsXCImWmFjdXRlO1wiOlwixblcIixcIiZaY2Fyb247XCI6XCLFvVwiLFwiJlpjeTtcIjpcItCXXCIsXCImWmRvdDtcIjpcIsW7XCIsXCImWmVyb1dpZHRoU3BhY2U7XCI6XCLigItcIixcIiZaZXRhO1wiOlwizpZcIixcIiZaZnI7XCI6XCLihKhcIixcIiZab3BmO1wiOlwi4oSkXCIsXCImWnNjcjtcIjpcIvCdkrVcIixcIiZhYWN1dGVcIjpcIsOhXCIsXCImYWFjdXRlO1wiOlwiw6FcIixcIiZhYnJldmU7XCI6XCLEg1wiLFwiJmFjO1wiOlwi4oi+XCIsXCImYWNFO1wiOlwi4oi+zLNcIixcIiZhY2Q7XCI6XCLiiL9cIixcIiZhY2lyY1wiOlwiw6JcIixcIiZhY2lyYztcIjpcIsOiXCIsXCImYWN1dGVcIjpcIsK0XCIsXCImYWN1dGU7XCI6XCLCtFwiLFwiJmFjeTtcIjpcItCwXCIsXCImYWVsaWdcIjpcIsOmXCIsXCImYWVsaWc7XCI6XCLDplwiLFwiJmFmO1wiOlwi4oGhXCIsXCImYWZyO1wiOlwi8J2UnlwiLFwiJmFncmF2ZVwiOlwiw6BcIixcIiZhZ3JhdmU7XCI6XCLDoFwiLFwiJmFsZWZzeW07XCI6XCLihLVcIixcIiZhbGVwaDtcIjpcIuKEtVwiLFwiJmFscGhhO1wiOlwizrFcIixcIiZhbWFjcjtcIjpcIsSBXCIsXCImYW1hbGc7XCI6XCLiqL9cIixcIiZhbXBcIjpcIiZcIixcIiZhbXA7XCI6XCImXCIsXCImYW5kO1wiOlwi4oinXCIsXCImYW5kYW5kO1wiOlwi4qmVXCIsXCImYW5kZDtcIjpcIuKpnFwiLFwiJmFuZHNsb3BlO1wiOlwi4qmYXCIsXCImYW5kdjtcIjpcIuKpmlwiLFwiJmFuZztcIjpcIuKIoFwiLFwiJmFuZ2U7XCI6XCLipqRcIixcIiZhbmdsZTtcIjpcIuKIoFwiLFwiJmFuZ21zZDtcIjpcIuKIoVwiLFwiJmFuZ21zZGFhO1wiOlwi4qaoXCIsXCImYW5nbXNkYWI7XCI6XCLipqlcIixcIiZhbmdtc2RhYztcIjpcIuKmqlwiLFwiJmFuZ21zZGFkO1wiOlwi4qarXCIsXCImYW5nbXNkYWU7XCI6XCLipqxcIixcIiZhbmdtc2RhZjtcIjpcIuKmrVwiLFwiJmFuZ21zZGFnO1wiOlwi4qauXCIsXCImYW5nbXNkYWg7XCI6XCLipq9cIixcIiZhbmdydDtcIjpcIuKIn1wiLFwiJmFuZ3J0dmI7XCI6XCLiir5cIixcIiZhbmdydHZiZDtcIjpcIuKmnVwiLFwiJmFuZ3NwaDtcIjpcIuKIolwiLFwiJmFuZ3N0O1wiOlwiw4VcIixcIiZhbmd6YXJyO1wiOlwi4o28XCIsXCImYW9nb247XCI6XCLEhVwiLFwiJmFvcGY7XCI6XCLwnZWSXCIsXCImYXA7XCI6XCLiiYhcIixcIiZhcEU7XCI6XCLiqbBcIixcIiZhcGFjaXI7XCI6XCLiqa9cIixcIiZhcGU7XCI6XCLiiYpcIixcIiZhcGlkO1wiOlwi4omLXCIsXCImYXBvcztcIjpcIidcIixcIiZhcHByb3g7XCI6XCLiiYhcIixcIiZhcHByb3hlcTtcIjpcIuKJilwiLFwiJmFyaW5nXCI6XCLDpVwiLFwiJmFyaW5nO1wiOlwiw6VcIixcIiZhc2NyO1wiOlwi8J2StlwiLFwiJmFzdDtcIjpcIipcIixcIiZhc3ltcDtcIjpcIuKJiFwiLFwiJmFzeW1wZXE7XCI6XCLiiY1cIixcIiZhdGlsZGVcIjpcIsOjXCIsXCImYXRpbGRlO1wiOlwiw6NcIixcIiZhdW1sXCI6XCLDpFwiLFwiJmF1bWw7XCI6XCLDpFwiLFwiJmF3Y29uaW50O1wiOlwi4oizXCIsXCImYXdpbnQ7XCI6XCLiqJFcIixcIiZiTm90O1wiOlwi4qutXCIsXCImYmFja2Nvbmc7XCI6XCLiiYxcIixcIiZiYWNrZXBzaWxvbjtcIjpcIs+2XCIsXCImYmFja3ByaW1lO1wiOlwi4oC1XCIsXCImYmFja3NpbTtcIjpcIuKIvVwiLFwiJmJhY2tzaW1lcTtcIjpcIuKLjVwiLFwiJmJhcnZlZTtcIjpcIuKKvVwiLFwiJmJhcndlZDtcIjpcIuKMhVwiLFwiJmJhcndlZGdlO1wiOlwi4oyFXCIsXCImYmJyaztcIjpcIuKOtVwiLFwiJmJicmt0YnJrO1wiOlwi4o62XCIsXCImYmNvbmc7XCI6XCLiiYxcIixcIiZiY3k7XCI6XCLQsVwiLFwiJmJkcXVvO1wiOlwi4oCeXCIsXCImYmVjYXVzO1wiOlwi4oi1XCIsXCImYmVjYXVzZTtcIjpcIuKItVwiLFwiJmJlbXB0eXY7XCI6XCLiprBcIixcIiZiZXBzaTtcIjpcIs+2XCIsXCImYmVybm91O1wiOlwi4oSsXCIsXCImYmV0YTtcIjpcIs6yXCIsXCImYmV0aDtcIjpcIuKEtlwiLFwiJmJldHdlZW47XCI6XCLiiaxcIixcIiZiZnI7XCI6XCLwnZSfXCIsXCImYmlnY2FwO1wiOlwi4ouCXCIsXCImYmlnY2lyYztcIjpcIuKXr1wiLFwiJmJpZ2N1cDtcIjpcIuKLg1wiLFwiJmJpZ29kb3Q7XCI6XCLiqIBcIixcIiZiaWdvcGx1cztcIjpcIuKogVwiLFwiJmJpZ290aW1lcztcIjpcIuKoglwiLFwiJmJpZ3NxY3VwO1wiOlwi4qiGXCIsXCImYmlnc3RhcjtcIjpcIuKYhVwiLFwiJmJpZ3RyaWFuZ2xlZG93bjtcIjpcIuKWvVwiLFwiJmJpZ3RyaWFuZ2xldXA7XCI6XCLilrNcIixcIiZiaWd1cGx1cztcIjpcIuKohFwiLFwiJmJpZ3ZlZTtcIjpcIuKLgVwiLFwiJmJpZ3dlZGdlO1wiOlwi4ouAXCIsXCImYmthcm93O1wiOlwi4qSNXCIsXCImYmxhY2tsb3plbmdlO1wiOlwi4qerXCIsXCImYmxhY2tzcXVhcmU7XCI6XCLilqpcIixcIiZibGFja3RyaWFuZ2xlO1wiOlwi4pa0XCIsXCImYmxhY2t0cmlhbmdsZWRvd247XCI6XCLilr5cIixcIiZibGFja3RyaWFuZ2xlbGVmdDtcIjpcIuKXglwiLFwiJmJsYWNrdHJpYW5nbGVyaWdodDtcIjpcIuKWuFwiLFwiJmJsYW5rO1wiOlwi4pCjXCIsXCImYmxrMTI7XCI6XCLilpJcIixcIiZibGsxNDtcIjpcIuKWkVwiLFwiJmJsazM0O1wiOlwi4paTXCIsXCImYmxvY2s7XCI6XCLilohcIixcIiZibmU7XCI6XCI94oOlXCIsXCImYm5lcXVpdjtcIjpcIuKJoeKDpVwiLFwiJmJub3Q7XCI6XCLijJBcIixcIiZib3BmO1wiOlwi8J2Vk1wiLFwiJmJvdDtcIjpcIuKKpVwiLFwiJmJvdHRvbTtcIjpcIuKKpVwiLFwiJmJvd3RpZTtcIjpcIuKLiFwiLFwiJmJveERMO1wiOlwi4pWXXCIsXCImYm94RFI7XCI6XCLilZRcIixcIiZib3hEbDtcIjpcIuKVllwiLFwiJmJveERyO1wiOlwi4pWTXCIsXCImYm94SDtcIjpcIuKVkFwiLFwiJmJveEhEO1wiOlwi4pWmXCIsXCImYm94SFU7XCI6XCLilalcIixcIiZib3hIZDtcIjpcIuKVpFwiLFwiJmJveEh1O1wiOlwi4pWnXCIsXCImYm94VUw7XCI6XCLilZ1cIixcIiZib3hVUjtcIjpcIuKVmlwiLFwiJmJveFVsO1wiOlwi4pWcXCIsXCImYm94VXI7XCI6XCLilZlcIixcIiZib3hWO1wiOlwi4pWRXCIsXCImYm94Vkg7XCI6XCLilaxcIixcIiZib3hWTDtcIjpcIuKVo1wiLFwiJmJveFZSO1wiOlwi4pWgXCIsXCImYm94Vmg7XCI6XCLilatcIixcIiZib3hWbDtcIjpcIuKVolwiLFwiJmJveFZyO1wiOlwi4pWfXCIsXCImYm94Ym94O1wiOlwi4qeJXCIsXCImYm94ZEw7XCI6XCLilZVcIixcIiZib3hkUjtcIjpcIuKVklwiLFwiJmJveGRsO1wiOlwi4pSQXCIsXCImYm94ZHI7XCI6XCLilIxcIixcIiZib3hoO1wiOlwi4pSAXCIsXCImYm94aEQ7XCI6XCLilaVcIixcIiZib3hoVTtcIjpcIuKVqFwiLFwiJmJveGhkO1wiOlwi4pSsXCIsXCImYm94aHU7XCI6XCLilLRcIixcIiZib3htaW51cztcIjpcIuKKn1wiLFwiJmJveHBsdXM7XCI6XCLiip5cIixcIiZib3h0aW1lcztcIjpcIuKKoFwiLFwiJmJveHVMO1wiOlwi4pWbXCIsXCImYm94dVI7XCI6XCLilZhcIixcIiZib3h1bDtcIjpcIuKUmFwiLFwiJmJveHVyO1wiOlwi4pSUXCIsXCImYm94djtcIjpcIuKUglwiLFwiJmJveHZIO1wiOlwi4pWqXCIsXCImYm94dkw7XCI6XCLilaFcIixcIiZib3h2UjtcIjpcIuKVnlwiLFwiJmJveHZoO1wiOlwi4pS8XCIsXCImYm94dmw7XCI6XCLilKRcIixcIiZib3h2cjtcIjpcIuKUnFwiLFwiJmJwcmltZTtcIjpcIuKAtVwiLFwiJmJyZXZlO1wiOlwiy5hcIixcIiZicnZiYXJcIjpcIsKmXCIsXCImYnJ2YmFyO1wiOlwiwqZcIixcIiZic2NyO1wiOlwi8J2St1wiLFwiJmJzZW1pO1wiOlwi4oGPXCIsXCImYnNpbTtcIjpcIuKIvVwiLFwiJmJzaW1lO1wiOlwi4ouNXCIsXCImYnNvbDtcIjpcIlxcXFxcIixcIiZic29sYjtcIjpcIuKnhVwiLFwiJmJzb2xoc3ViO1wiOlwi4p+IXCIsXCImYnVsbDtcIjpcIuKAolwiLFwiJmJ1bGxldDtcIjpcIuKAolwiLFwiJmJ1bXA7XCI6XCLiiY5cIixcIiZidW1wRTtcIjpcIuKqrlwiLFwiJmJ1bXBlO1wiOlwi4omPXCIsXCImYnVtcGVxO1wiOlwi4omPXCIsXCImY2FjdXRlO1wiOlwixIdcIixcIiZjYXA7XCI6XCLiiKlcIixcIiZjYXBhbmQ7XCI6XCLiqYRcIixcIiZjYXBicmN1cDtcIjpcIuKpiVwiLFwiJmNhcGNhcDtcIjpcIuKpi1wiLFwiJmNhcGN1cDtcIjpcIuKph1wiLFwiJmNhcGRvdDtcIjpcIuKpgFwiLFwiJmNhcHM7XCI6XCLiiKnvuIBcIixcIiZjYXJldDtcIjpcIuKBgVwiLFwiJmNhcm9uO1wiOlwiy4dcIixcIiZjY2FwcztcIjpcIuKpjVwiLFwiJmNjYXJvbjtcIjpcIsSNXCIsXCImY2NlZGlsXCI6XCLDp1wiLFwiJmNjZWRpbDtcIjpcIsOnXCIsXCImY2NpcmM7XCI6XCLEiVwiLFwiJmNjdXBzO1wiOlwi4qmMXCIsXCImY2N1cHNzbTtcIjpcIuKpkFwiLFwiJmNkb3Q7XCI6XCLEi1wiLFwiJmNlZGlsXCI6XCLCuFwiLFwiJmNlZGlsO1wiOlwiwrhcIixcIiZjZW1wdHl2O1wiOlwi4qayXCIsXCImY2VudFwiOlwiwqJcIixcIiZjZW50O1wiOlwiwqJcIixcIiZjZW50ZXJkb3Q7XCI6XCLCt1wiLFwiJmNmcjtcIjpcIvCdlKBcIixcIiZjaGN5O1wiOlwi0YdcIixcIiZjaGVjaztcIjpcIuKck1wiLFwiJmNoZWNrbWFyaztcIjpcIuKck1wiLFwiJmNoaTtcIjpcIs+HXCIsXCImY2lyO1wiOlwi4peLXCIsXCImY2lyRTtcIjpcIuKng1wiLFwiJmNpcmM7XCI6XCLLhlwiLFwiJmNpcmNlcTtcIjpcIuKJl1wiLFwiJmNpcmNsZWFycm93bGVmdDtcIjpcIuKGulwiLFwiJmNpcmNsZWFycm93cmlnaHQ7XCI6XCLihrtcIixcIiZjaXJjbGVkUjtcIjpcIsKuXCIsXCImY2lyY2xlZFM7XCI6XCLik4hcIixcIiZjaXJjbGVkYXN0O1wiOlwi4oqbXCIsXCImY2lyY2xlZGNpcmM7XCI6XCLiippcIixcIiZjaXJjbGVkZGFzaDtcIjpcIuKKnVwiLFwiJmNpcmU7XCI6XCLiiZdcIixcIiZjaXJmbmludDtcIjpcIuKokFwiLFwiJmNpcm1pZDtcIjpcIuKrr1wiLFwiJmNpcnNjaXI7XCI6XCLip4JcIixcIiZjbHVicztcIjpcIuKZo1wiLFwiJmNsdWJzdWl0O1wiOlwi4pmjXCIsXCImY29sb247XCI6XCI6XCIsXCImY29sb25lO1wiOlwi4omUXCIsXCImY29sb25lcTtcIjpcIuKJlFwiLFwiJmNvbW1hO1wiOlwiLFwiLFwiJmNvbW1hdDtcIjpcIkBcIixcIiZjb21wO1wiOlwi4oiBXCIsXCImY29tcGZuO1wiOlwi4oiYXCIsXCImY29tcGxlbWVudDtcIjpcIuKIgVwiLFwiJmNvbXBsZXhlcztcIjpcIuKEglwiLFwiJmNvbmc7XCI6XCLiiYVcIixcIiZjb25nZG90O1wiOlwi4qmtXCIsXCImY29uaW50O1wiOlwi4oiuXCIsXCImY29wZjtcIjpcIvCdlZRcIixcIiZjb3Byb2Q7XCI6XCLiiJBcIixcIiZjb3B5XCI6XCLCqVwiLFwiJmNvcHk7XCI6XCLCqVwiLFwiJmNvcHlzcjtcIjpcIuKEl1wiLFwiJmNyYXJyO1wiOlwi4oa1XCIsXCImY3Jvc3M7XCI6XCLinJdcIixcIiZjc2NyO1wiOlwi8J2SuFwiLFwiJmNzdWI7XCI6XCLiq49cIixcIiZjc3ViZTtcIjpcIuKrkVwiLFwiJmNzdXA7XCI6XCLiq5BcIixcIiZjc3VwZTtcIjpcIuKrklwiLFwiJmN0ZG90O1wiOlwi4ouvXCIsXCImY3VkYXJybDtcIjpcIuKkuFwiLFwiJmN1ZGFycnI7XCI6XCLipLVcIixcIiZjdWVwcjtcIjpcIuKLnlwiLFwiJmN1ZXNjO1wiOlwi4oufXCIsXCImY3VsYXJyO1wiOlwi4oa2XCIsXCImY3VsYXJycDtcIjpcIuKkvVwiLFwiJmN1cDtcIjpcIuKIqlwiLFwiJmN1cGJyY2FwO1wiOlwi4qmIXCIsXCImY3VwY2FwO1wiOlwi4qmGXCIsXCImY3VwY3VwO1wiOlwi4qmKXCIsXCImY3VwZG90O1wiOlwi4oqNXCIsXCImY3Vwb3I7XCI6XCLiqYVcIixcIiZjdXBzO1wiOlwi4oiq77iAXCIsXCImY3VyYXJyO1wiOlwi4oa3XCIsXCImY3VyYXJybTtcIjpcIuKkvFwiLFwiJmN1cmx5ZXFwcmVjO1wiOlwi4oueXCIsXCImY3VybHllcXN1Y2M7XCI6XCLii59cIixcIiZjdXJseXZlZTtcIjpcIuKLjlwiLFwiJmN1cmx5d2VkZ2U7XCI6XCLii49cIixcIiZjdXJyZW5cIjpcIsKkXCIsXCImY3VycmVuO1wiOlwiwqRcIixcIiZjdXJ2ZWFycm93bGVmdDtcIjpcIuKGtlwiLFwiJmN1cnZlYXJyb3dyaWdodDtcIjpcIuKGt1wiLFwiJmN1dmVlO1wiOlwi4ouOXCIsXCImY3V3ZWQ7XCI6XCLii49cIixcIiZjd2NvbmludDtcIjpcIuKIslwiLFwiJmN3aW50O1wiOlwi4oixXCIsXCImY3lsY3R5O1wiOlwi4oytXCIsXCImZEFycjtcIjpcIuKHk1wiLFwiJmRIYXI7XCI6XCLipaVcIixcIiZkYWdnZXI7XCI6XCLigKBcIixcIiZkYWxldGg7XCI6XCLihLhcIixcIiZkYXJyO1wiOlwi4oaTXCIsXCImZGFzaDtcIjpcIuKAkFwiLFwiJmRhc2h2O1wiOlwi4oqjXCIsXCImZGJrYXJvdztcIjpcIuKkj1wiLFwiJmRibGFjO1wiOlwiy51cIixcIiZkY2Fyb247XCI6XCLEj1wiLFwiJmRjeTtcIjpcItC0XCIsXCImZGQ7XCI6XCLihYZcIixcIiZkZGFnZ2VyO1wiOlwi4oChXCIsXCImZGRhcnI7XCI6XCLih4pcIixcIiZkZG90c2VxO1wiOlwi4qm3XCIsXCImZGVnXCI6XCLCsFwiLFwiJmRlZztcIjpcIsKwXCIsXCImZGVsdGE7XCI6XCLOtFwiLFwiJmRlbXB0eXY7XCI6XCLiprFcIixcIiZkZmlzaHQ7XCI6XCLipb9cIixcIiZkZnI7XCI6XCLwnZShXCIsXCImZGhhcmw7XCI6XCLih4NcIixcIiZkaGFycjtcIjpcIuKHglwiLFwiJmRpYW07XCI6XCLii4RcIixcIiZkaWFtb25kO1wiOlwi4ouEXCIsXCImZGlhbW9uZHN1aXQ7XCI6XCLimaZcIixcIiZkaWFtcztcIjpcIuKZplwiLFwiJmRpZTtcIjpcIsKoXCIsXCImZGlnYW1tYTtcIjpcIs+dXCIsXCImZGlzaW47XCI6XCLii7JcIixcIiZkaXY7XCI6XCLDt1wiLFwiJmRpdmlkZVwiOlwiw7dcIixcIiZkaXZpZGU7XCI6XCLDt1wiLFwiJmRpdmlkZW9udGltZXM7XCI6XCLii4dcIixcIiZkaXZvbng7XCI6XCLii4dcIixcIiZkamN5O1wiOlwi0ZJcIixcIiZkbGNvcm47XCI6XCLijJ5cIixcIiZkbGNyb3A7XCI6XCLijI1cIixcIiZkb2xsYXI7XCI6XCIkXCIsXCImZG9wZjtcIjpcIvCdlZVcIixcIiZkb3Q7XCI6XCLLmVwiLFwiJmRvdGVxO1wiOlwi4omQXCIsXCImZG90ZXFkb3Q7XCI6XCLiiZFcIixcIiZkb3RtaW51cztcIjpcIuKIuFwiLFwiJmRvdHBsdXM7XCI6XCLiiJRcIixcIiZkb3RzcXVhcmU7XCI6XCLiiqFcIixcIiZkb3VibGViYXJ3ZWRnZTtcIjpcIuKMhlwiLFwiJmRvd25hcnJvdztcIjpcIuKGk1wiLFwiJmRvd25kb3duYXJyb3dzO1wiOlwi4oeKXCIsXCImZG93bmhhcnBvb25sZWZ0O1wiOlwi4oeDXCIsXCImZG93bmhhcnBvb25yaWdodDtcIjpcIuKHglwiLFwiJmRyYmthcm93O1wiOlwi4qSQXCIsXCImZHJjb3JuO1wiOlwi4oyfXCIsXCImZHJjcm9wO1wiOlwi4oyMXCIsXCImZHNjcjtcIjpcIvCdkrlcIixcIiZkc2N5O1wiOlwi0ZVcIixcIiZkc29sO1wiOlwi4qe2XCIsXCImZHN0cm9rO1wiOlwixJFcIixcIiZkdGRvdDtcIjpcIuKLsVwiLFwiJmR0cmk7XCI6XCLilr9cIixcIiZkdHJpZjtcIjpcIuKWvlwiLFwiJmR1YXJyO1wiOlwi4oe1XCIsXCImZHVoYXI7XCI6XCLipa9cIixcIiZkd2FuZ2xlO1wiOlwi4qamXCIsXCImZHpjeTtcIjpcItGfXCIsXCImZHppZ3JhcnI7XCI6XCLin79cIixcIiZlRERvdDtcIjpcIuKpt1wiLFwiJmVEb3Q7XCI6XCLiiZFcIixcIiZlYWN1dGVcIjpcIsOpXCIsXCImZWFjdXRlO1wiOlwiw6lcIixcIiZlYXN0ZXI7XCI6XCLiqa5cIixcIiZlY2Fyb247XCI6XCLEm1wiLFwiJmVjaXI7XCI6XCLiiZZcIixcIiZlY2lyY1wiOlwiw6pcIixcIiZlY2lyYztcIjpcIsOqXCIsXCImZWNvbG9uO1wiOlwi4omVXCIsXCImZWN5O1wiOlwi0Y1cIixcIiZlZG90O1wiOlwixJdcIixcIiZlZTtcIjpcIuKFh1wiLFwiJmVmRG90O1wiOlwi4omSXCIsXCImZWZyO1wiOlwi8J2UolwiLFwiJmVnO1wiOlwi4qqaXCIsXCImZWdyYXZlXCI6XCLDqFwiLFwiJmVncmF2ZTtcIjpcIsOoXCIsXCImZWdzO1wiOlwi4qqWXCIsXCImZWdzZG90O1wiOlwi4qqYXCIsXCImZWw7XCI6XCLiqplcIixcIiZlbGludGVycztcIjpcIuKPp1wiLFwiJmVsbDtcIjpcIuKEk1wiLFwiJmVscztcIjpcIuKqlVwiLFwiJmVsc2RvdDtcIjpcIuKql1wiLFwiJmVtYWNyO1wiOlwixJNcIixcIiZlbXB0eTtcIjpcIuKIhVwiLFwiJmVtcHR5c2V0O1wiOlwi4oiFXCIsXCImZW1wdHl2O1wiOlwi4oiFXCIsXCImZW1zcDEzO1wiOlwi4oCEXCIsXCImZW1zcDE0O1wiOlwi4oCFXCIsXCImZW1zcDtcIjpcIuKAg1wiLFwiJmVuZztcIjpcIsWLXCIsXCImZW5zcDtcIjpcIuKAglwiLFwiJmVvZ29uO1wiOlwixJlcIixcIiZlb3BmO1wiOlwi8J2VllwiLFwiJmVwYXI7XCI6XCLii5VcIixcIiZlcGFyc2w7XCI6XCLip6NcIixcIiZlcGx1cztcIjpcIuKpsVwiLFwiJmVwc2k7XCI6XCLOtVwiLFwiJmVwc2lsb247XCI6XCLOtVwiLFwiJmVwc2l2O1wiOlwiz7VcIixcIiZlcWNpcmM7XCI6XCLiiZZcIixcIiZlcWNvbG9uO1wiOlwi4omVXCIsXCImZXFzaW07XCI6XCLiiYJcIixcIiZlcXNsYW50Z3RyO1wiOlwi4qqWXCIsXCImZXFzbGFudGxlc3M7XCI6XCLiqpVcIixcIiZlcXVhbHM7XCI6XCI9XCIsXCImZXF1ZXN0O1wiOlwi4omfXCIsXCImZXF1aXY7XCI6XCLiiaFcIixcIiZlcXVpdkREO1wiOlwi4qm4XCIsXCImZXF2cGFyc2w7XCI6XCLip6VcIixcIiZlckRvdDtcIjpcIuKJk1wiLFwiJmVyYXJyO1wiOlwi4qWxXCIsXCImZXNjcjtcIjpcIuKEr1wiLFwiJmVzZG90O1wiOlwi4omQXCIsXCImZXNpbTtcIjpcIuKJglwiLFwiJmV0YTtcIjpcIs63XCIsXCImZXRoXCI6XCLDsFwiLFwiJmV0aDtcIjpcIsOwXCIsXCImZXVtbFwiOlwiw6tcIixcIiZldW1sO1wiOlwiw6tcIixcIiZldXJvO1wiOlwi4oKsXCIsXCImZXhjbDtcIjpcIiFcIixcIiZleGlzdDtcIjpcIuKIg1wiLFwiJmV4cGVjdGF0aW9uO1wiOlwi4oSwXCIsXCImZXhwb25lbnRpYWxlO1wiOlwi4oWHXCIsXCImZmFsbGluZ2RvdHNlcTtcIjpcIuKJklwiLFwiJmZjeTtcIjpcItGEXCIsXCImZmVtYWxlO1wiOlwi4pmAXCIsXCImZmZpbGlnO1wiOlwi76yDXCIsXCImZmZsaWc7XCI6XCLvrIBcIixcIiZmZmxsaWc7XCI6XCLvrIRcIixcIiZmZnI7XCI6XCLwnZSjXCIsXCImZmlsaWc7XCI6XCLvrIFcIixcIiZmamxpZztcIjpcImZqXCIsXCImZmxhdDtcIjpcIuKZrVwiLFwiJmZsbGlnO1wiOlwi76yCXCIsXCImZmx0bnM7XCI6XCLilrFcIixcIiZmbm9mO1wiOlwixpJcIixcIiZmb3BmO1wiOlwi8J2Vl1wiLFwiJmZvcmFsbDtcIjpcIuKIgFwiLFwiJmZvcms7XCI6XCLii5RcIixcIiZmb3JrdjtcIjpcIuKrmVwiLFwiJmZwYXJ0aW50O1wiOlwi4qiNXCIsXCImZnJhYzEyXCI6XCLCvVwiLFwiJmZyYWMxMjtcIjpcIsK9XCIsXCImZnJhYzEzO1wiOlwi4oWTXCIsXCImZnJhYzE0XCI6XCLCvFwiLFwiJmZyYWMxNDtcIjpcIsK8XCIsXCImZnJhYzE1O1wiOlwi4oWVXCIsXCImZnJhYzE2O1wiOlwi4oWZXCIsXCImZnJhYzE4O1wiOlwi4oWbXCIsXCImZnJhYzIzO1wiOlwi4oWUXCIsXCImZnJhYzI1O1wiOlwi4oWWXCIsXCImZnJhYzM0XCI6XCLCvlwiLFwiJmZyYWMzNDtcIjpcIsK+XCIsXCImZnJhYzM1O1wiOlwi4oWXXCIsXCImZnJhYzM4O1wiOlwi4oWcXCIsXCImZnJhYzQ1O1wiOlwi4oWYXCIsXCImZnJhYzU2O1wiOlwi4oWaXCIsXCImZnJhYzU4O1wiOlwi4oWdXCIsXCImZnJhYzc4O1wiOlwi4oWeXCIsXCImZnJhc2w7XCI6XCLigYRcIixcIiZmcm93bjtcIjpcIuKMolwiLFwiJmZzY3I7XCI6XCLwnZK7XCIsXCImZ0U7XCI6XCLiiadcIixcIiZnRWw7XCI6XCLiqoxcIixcIiZnYWN1dGU7XCI6XCLHtVwiLFwiJmdhbW1hO1wiOlwizrNcIixcIiZnYW1tYWQ7XCI6XCLPnVwiLFwiJmdhcDtcIjpcIuKqhlwiLFwiJmdicmV2ZTtcIjpcIsSfXCIsXCImZ2NpcmM7XCI6XCLEnVwiLFwiJmdjeTtcIjpcItCzXCIsXCImZ2RvdDtcIjpcIsShXCIsXCImZ2U7XCI6XCLiiaVcIixcIiZnZWw7XCI6XCLii5tcIixcIiZnZXE7XCI6XCLiiaVcIixcIiZnZXFxO1wiOlwi4omnXCIsXCImZ2Vxc2xhbnQ7XCI6XCLiqb5cIixcIiZnZXM7XCI6XCLiqb5cIixcIiZnZXNjYztcIjpcIuKqqVwiLFwiJmdlc2RvdDtcIjpcIuKqgFwiLFwiJmdlc2RvdG87XCI6XCLiqoJcIixcIiZnZXNkb3RvbDtcIjpcIuKqhFwiLFwiJmdlc2w7XCI6XCLii5vvuIBcIixcIiZnZXNsZXM7XCI6XCLiqpRcIixcIiZnZnI7XCI6XCLwnZSkXCIsXCImZ2c7XCI6XCLiiatcIixcIiZnZ2c7XCI6XCLii5lcIixcIiZnaW1lbDtcIjpcIuKEt1wiLFwiJmdqY3k7XCI6XCLRk1wiLFwiJmdsO1wiOlwi4om3XCIsXCImZ2xFO1wiOlwi4qqSXCIsXCImZ2xhO1wiOlwi4qqlXCIsXCImZ2xqO1wiOlwi4qqkXCIsXCImZ25FO1wiOlwi4ompXCIsXCImZ25hcDtcIjpcIuKqilwiLFwiJmduYXBwcm94O1wiOlwi4qqKXCIsXCImZ25lO1wiOlwi4qqIXCIsXCImZ25lcTtcIjpcIuKqiFwiLFwiJmduZXFxO1wiOlwi4ompXCIsXCImZ25zaW07XCI6XCLii6dcIixcIiZnb3BmO1wiOlwi8J2VmFwiLFwiJmdyYXZlO1wiOlwiYFwiLFwiJmdzY3I7XCI6XCLihIpcIixcIiZnc2ltO1wiOlwi4omzXCIsXCImZ3NpbWU7XCI6XCLiqo5cIixcIiZnc2ltbDtcIjpcIuKqkFwiLFwiJmd0XCI6XCI+XCIsXCImZ3Q7XCI6XCI+XCIsXCImZ3RjYztcIjpcIuKqp1wiLFwiJmd0Y2lyO1wiOlwi4qm6XCIsXCImZ3Rkb3Q7XCI6XCLii5dcIixcIiZndGxQYXI7XCI6XCLippVcIixcIiZndHF1ZXN0O1wiOlwi4qm8XCIsXCImZ3RyYXBwcm94O1wiOlwi4qqGXCIsXCImZ3RyYXJyO1wiOlwi4qW4XCIsXCImZ3RyZG90O1wiOlwi4ouXXCIsXCImZ3RyZXFsZXNzO1wiOlwi4oubXCIsXCImZ3RyZXFxbGVzcztcIjpcIuKqjFwiLFwiJmd0cmxlc3M7XCI6XCLiibdcIixcIiZndHJzaW07XCI6XCLiibNcIixcIiZndmVydG5lcXE7XCI6XCLiianvuIBcIixcIiZndm5FO1wiOlwi4omp77iAXCIsXCImaEFycjtcIjpcIuKHlFwiLFwiJmhhaXJzcDtcIjpcIuKAilwiLFwiJmhhbGY7XCI6XCLCvVwiLFwiJmhhbWlsdDtcIjpcIuKEi1wiLFwiJmhhcmRjeTtcIjpcItGKXCIsXCImaGFycjtcIjpcIuKGlFwiLFwiJmhhcnJjaXI7XCI6XCLipYhcIixcIiZoYXJydztcIjpcIuKGrVwiLFwiJmhiYXI7XCI6XCLihI9cIixcIiZoY2lyYztcIjpcIsSlXCIsXCImaGVhcnRzO1wiOlwi4pmlXCIsXCImaGVhcnRzdWl0O1wiOlwi4pmlXCIsXCImaGVsbGlwO1wiOlwi4oCmXCIsXCImaGVyY29uO1wiOlwi4oq5XCIsXCImaGZyO1wiOlwi8J2UpVwiLFwiJmhrc2Vhcm93O1wiOlwi4qSlXCIsXCImaGtzd2Fyb3c7XCI6XCLipKZcIixcIiZob2FycjtcIjpcIuKHv1wiLFwiJmhvbXRodDtcIjpcIuKIu1wiLFwiJmhvb2tsZWZ0YXJyb3c7XCI6XCLihqlcIixcIiZob29rcmlnaHRhcnJvdztcIjpcIuKGqlwiLFwiJmhvcGY7XCI6XCLwnZWZXCIsXCImaG9yYmFyO1wiOlwi4oCVXCIsXCImaHNjcjtcIjpcIvCdkr1cIixcIiZoc2xhc2g7XCI6XCLihI9cIixcIiZoc3Ryb2s7XCI6XCLEp1wiLFwiJmh5YnVsbDtcIjpcIuKBg1wiLFwiJmh5cGhlbjtcIjpcIuKAkFwiLFwiJmlhY3V0ZVwiOlwiw61cIixcIiZpYWN1dGU7XCI6XCLDrVwiLFwiJmljO1wiOlwi4oGjXCIsXCImaWNpcmNcIjpcIsOuXCIsXCImaWNpcmM7XCI6XCLDrlwiLFwiJmljeTtcIjpcItC4XCIsXCImaWVjeTtcIjpcItC1XCIsXCImaWV4Y2xcIjpcIsKhXCIsXCImaWV4Y2w7XCI6XCLCoVwiLFwiJmlmZjtcIjpcIuKHlFwiLFwiJmlmcjtcIjpcIvCdlKZcIixcIiZpZ3JhdmVcIjpcIsOsXCIsXCImaWdyYXZlO1wiOlwiw6xcIixcIiZpaTtcIjpcIuKFiFwiLFwiJmlpaWludDtcIjpcIuKojFwiLFwiJmlpaW50O1wiOlwi4oitXCIsXCImaWluZmluO1wiOlwi4qecXCIsXCImaWlvdGE7XCI6XCLihKlcIixcIiZpamxpZztcIjpcIsSzXCIsXCImaW1hY3I7XCI6XCLEq1wiLFwiJmltYWdlO1wiOlwi4oSRXCIsXCImaW1hZ2xpbmU7XCI6XCLihJBcIixcIiZpbWFncGFydDtcIjpcIuKEkVwiLFwiJmltYXRoO1wiOlwixLFcIixcIiZpbW9mO1wiOlwi4oq3XCIsXCImaW1wZWQ7XCI6XCLGtVwiLFwiJmluO1wiOlwi4oiIXCIsXCImaW5jYXJlO1wiOlwi4oSFXCIsXCImaW5maW47XCI6XCLiiJ5cIixcIiZpbmZpbnRpZTtcIjpcIuKnnVwiLFwiJmlub2RvdDtcIjpcIsSxXCIsXCImaW50O1wiOlwi4oirXCIsXCImaW50Y2FsO1wiOlwi4oq6XCIsXCImaW50ZWdlcnM7XCI6XCLihKRcIixcIiZpbnRlcmNhbDtcIjpcIuKKulwiLFwiJmludGxhcmhrO1wiOlwi4qiXXCIsXCImaW50cHJvZDtcIjpcIuKovFwiLFwiJmlvY3k7XCI6XCLRkVwiLFwiJmlvZ29uO1wiOlwixK9cIixcIiZpb3BmO1wiOlwi8J2VmlwiLFwiJmlvdGE7XCI6XCLOuVwiLFwiJmlwcm9kO1wiOlwi4qi8XCIsXCImaXF1ZXN0XCI6XCLCv1wiLFwiJmlxdWVzdDtcIjpcIsK/XCIsXCImaXNjcjtcIjpcIvCdkr5cIixcIiZpc2luO1wiOlwi4oiIXCIsXCImaXNpbkU7XCI6XCLii7lcIixcIiZpc2luZG90O1wiOlwi4ou1XCIsXCImaXNpbnM7XCI6XCLii7RcIixcIiZpc2luc3Y7XCI6XCLii7NcIixcIiZpc2ludjtcIjpcIuKIiFwiLFwiJml0O1wiOlwi4oGiXCIsXCImaXRpbGRlO1wiOlwixKlcIixcIiZpdWtjeTtcIjpcItGWXCIsXCImaXVtbFwiOlwiw69cIixcIiZpdW1sO1wiOlwiw69cIixcIiZqY2lyYztcIjpcIsS1XCIsXCImamN5O1wiOlwi0LlcIixcIiZqZnI7XCI6XCLwnZSnXCIsXCImam1hdGg7XCI6XCLIt1wiLFwiJmpvcGY7XCI6XCLwnZWbXCIsXCImanNjcjtcIjpcIvCdkr9cIixcIiZqc2VyY3k7XCI6XCLRmFwiLFwiJmp1a2N5O1wiOlwi0ZRcIixcIiZrYXBwYTtcIjpcIs66XCIsXCIma2FwcGF2O1wiOlwiz7BcIixcIiZrY2VkaWw7XCI6XCLEt1wiLFwiJmtjeTtcIjpcItC6XCIsXCIma2ZyO1wiOlwi8J2UqFwiLFwiJmtncmVlbjtcIjpcIsS4XCIsXCIma2hjeTtcIjpcItGFXCIsXCIma2pjeTtcIjpcItGcXCIsXCIma29wZjtcIjpcIvCdlZxcIixcIiZrc2NyO1wiOlwi8J2TgFwiLFwiJmxBYXJyO1wiOlwi4oeaXCIsXCImbEFycjtcIjpcIuKHkFwiLFwiJmxBdGFpbDtcIjpcIuKkm1wiLFwiJmxCYXJyO1wiOlwi4qSOXCIsXCImbEU7XCI6XCLiiaZcIixcIiZsRWc7XCI6XCLiqotcIixcIiZsSGFyO1wiOlwi4qWiXCIsXCImbGFjdXRlO1wiOlwixLpcIixcIiZsYWVtcHR5djtcIjpcIuKmtFwiLFwiJmxhZ3JhbjtcIjpcIuKEklwiLFwiJmxhbWJkYTtcIjpcIs67XCIsXCImbGFuZztcIjpcIuKfqFwiLFwiJmxhbmdkO1wiOlwi4qaRXCIsXCImbGFuZ2xlO1wiOlwi4p+oXCIsXCImbGFwO1wiOlwi4qqFXCIsXCImbGFxdW9cIjpcIsKrXCIsXCImbGFxdW87XCI6XCLCq1wiLFwiJmxhcnI7XCI6XCLihpBcIixcIiZsYXJyYjtcIjpcIuKHpFwiLFwiJmxhcnJiZnM7XCI6XCLipJ9cIixcIiZsYXJyZnM7XCI6XCLipJ1cIixcIiZsYXJyaGs7XCI6XCLihqlcIixcIiZsYXJybHA7XCI6XCLihqtcIixcIiZsYXJycGw7XCI6XCLipLlcIixcIiZsYXJyc2ltO1wiOlwi4qWzXCIsXCImbGFycnRsO1wiOlwi4oaiXCIsXCImbGF0O1wiOlwi4qqrXCIsXCImbGF0YWlsO1wiOlwi4qSZXCIsXCImbGF0ZTtcIjpcIuKqrVwiLFwiJmxhdGVzO1wiOlwi4qqt77iAXCIsXCImbGJhcnI7XCI6XCLipIxcIixcIiZsYmJyaztcIjpcIuKdslwiLFwiJmxicmFjZTtcIjpcIntcIixcIiZsYnJhY2s7XCI6XCJbXCIsXCImbGJya2U7XCI6XCLipotcIixcIiZsYnJrc2xkO1wiOlwi4qaPXCIsXCImbGJya3NsdTtcIjpcIuKmjVwiLFwiJmxjYXJvbjtcIjpcIsS+XCIsXCImbGNlZGlsO1wiOlwixLxcIixcIiZsY2VpbDtcIjpcIuKMiFwiLFwiJmxjdWI7XCI6XCJ7XCIsXCImbGN5O1wiOlwi0LtcIixcIiZsZGNhO1wiOlwi4qS2XCIsXCImbGRxdW87XCI6XCLigJxcIixcIiZsZHF1b3I7XCI6XCLigJ5cIixcIiZsZHJkaGFyO1wiOlwi4qWnXCIsXCImbGRydXNoYXI7XCI6XCLipYtcIixcIiZsZHNoO1wiOlwi4oayXCIsXCImbGU7XCI6XCLiiaRcIixcIiZsZWZ0YXJyb3c7XCI6XCLihpBcIixcIiZsZWZ0YXJyb3d0YWlsO1wiOlwi4oaiXCIsXCImbGVmdGhhcnBvb25kb3duO1wiOlwi4oa9XCIsXCImbGVmdGhhcnBvb251cDtcIjpcIuKGvFwiLFwiJmxlZnRsZWZ0YXJyb3dzO1wiOlwi4oeHXCIsXCImbGVmdHJpZ2h0YXJyb3c7XCI6XCLihpRcIixcIiZsZWZ0cmlnaHRhcnJvd3M7XCI6XCLih4ZcIixcIiZsZWZ0cmlnaHRoYXJwb29ucztcIjpcIuKHi1wiLFwiJmxlZnRyaWdodHNxdWlnYXJyb3c7XCI6XCLihq1cIixcIiZsZWZ0dGhyZWV0aW1lcztcIjpcIuKLi1wiLFwiJmxlZztcIjpcIuKLmlwiLFwiJmxlcTtcIjpcIuKJpFwiLFwiJmxlcXE7XCI6XCLiiaZcIixcIiZsZXFzbGFudDtcIjpcIuKpvVwiLFwiJmxlcztcIjpcIuKpvVwiLFwiJmxlc2NjO1wiOlwi4qqoXCIsXCImbGVzZG90O1wiOlwi4qm/XCIsXCImbGVzZG90bztcIjpcIuKqgVwiLFwiJmxlc2RvdG9yO1wiOlwi4qqDXCIsXCImbGVzZztcIjpcIuKLmu+4gFwiLFwiJmxlc2dlcztcIjpcIuKqk1wiLFwiJmxlc3NhcHByb3g7XCI6XCLiqoVcIixcIiZsZXNzZG90O1wiOlwi4ouWXCIsXCImbGVzc2VxZ3RyO1wiOlwi4ouaXCIsXCImbGVzc2VxcWd0cjtcIjpcIuKqi1wiLFwiJmxlc3NndHI7XCI6XCLiibZcIixcIiZsZXNzc2ltO1wiOlwi4omyXCIsXCImbGZpc2h0O1wiOlwi4qW8XCIsXCImbGZsb29yO1wiOlwi4oyKXCIsXCImbGZyO1wiOlwi8J2UqVwiLFwiJmxnO1wiOlwi4om2XCIsXCImbGdFO1wiOlwi4qqRXCIsXCImbGhhcmQ7XCI6XCLihr1cIixcIiZsaGFydTtcIjpcIuKGvFwiLFwiJmxoYXJ1bDtcIjpcIuKlqlwiLFwiJmxoYmxrO1wiOlwi4paEXCIsXCImbGpjeTtcIjpcItGZXCIsXCImbGw7XCI6XCLiiapcIixcIiZsbGFycjtcIjpcIuKHh1wiLFwiJmxsY29ybmVyO1wiOlwi4oyeXCIsXCImbGxoYXJkO1wiOlwi4qWrXCIsXCImbGx0cmk7XCI6XCLil7pcIixcIiZsbWlkb3Q7XCI6XCLFgFwiLFwiJmxtb3VzdDtcIjpcIuKOsFwiLFwiJmxtb3VzdGFjaGU7XCI6XCLijrBcIixcIiZsbkU7XCI6XCLiiahcIixcIiZsbmFwO1wiOlwi4qqJXCIsXCImbG5hcHByb3g7XCI6XCLiqolcIixcIiZsbmU7XCI6XCLiqodcIixcIiZsbmVxO1wiOlwi4qqHXCIsXCImbG5lcXE7XCI6XCLiiahcIixcIiZsbnNpbTtcIjpcIuKLplwiLFwiJmxvYW5nO1wiOlwi4p+sXCIsXCImbG9hcnI7XCI6XCLih71cIixcIiZsb2JyaztcIjpcIuKfplwiLFwiJmxvbmdsZWZ0YXJyb3c7XCI6XCLin7VcIixcIiZsb25nbGVmdHJpZ2h0YXJyb3c7XCI6XCLin7dcIixcIiZsb25nbWFwc3RvO1wiOlwi4p+8XCIsXCImbG9uZ3JpZ2h0YXJyb3c7XCI6XCLin7ZcIixcIiZsb29wYXJyb3dsZWZ0O1wiOlwi4oarXCIsXCImbG9vcGFycm93cmlnaHQ7XCI6XCLihqxcIixcIiZsb3BhcjtcIjpcIuKmhVwiLFwiJmxvcGY7XCI6XCLwnZWdXCIsXCImbG9wbHVzO1wiOlwi4qitXCIsXCImbG90aW1lcztcIjpcIuKotFwiLFwiJmxvd2FzdDtcIjpcIuKIl1wiLFwiJmxvd2JhcjtcIjpcIl9cIixcIiZsb3o7XCI6XCLil4pcIixcIiZsb3plbmdlO1wiOlwi4peKXCIsXCImbG96ZjtcIjpcIuKnq1wiLFwiJmxwYXI7XCI6XCIoXCIsXCImbHBhcmx0O1wiOlwi4qaTXCIsXCImbHJhcnI7XCI6XCLih4ZcIixcIiZscmNvcm5lcjtcIjpcIuKMn1wiLFwiJmxyaGFyO1wiOlwi4oeLXCIsXCImbHJoYXJkO1wiOlwi4qWtXCIsXCImbHJtO1wiOlwi4oCOXCIsXCImbHJ0cmk7XCI6XCLiir9cIixcIiZsc2FxdW87XCI6XCLigLlcIixcIiZsc2NyO1wiOlwi8J2TgVwiLFwiJmxzaDtcIjpcIuKGsFwiLFwiJmxzaW07XCI6XCLiibJcIixcIiZsc2ltZTtcIjpcIuKqjVwiLFwiJmxzaW1nO1wiOlwi4qqPXCIsXCImbHNxYjtcIjpcIltcIixcIiZsc3F1bztcIjpcIuKAmFwiLFwiJmxzcXVvcjtcIjpcIuKAmlwiLFwiJmxzdHJvaztcIjpcIsWCXCIsXCImbHRcIjpcIjxcIixcIiZsdDtcIjpcIjxcIixcIiZsdGNjO1wiOlwi4qqmXCIsXCImbHRjaXI7XCI6XCLiqblcIixcIiZsdGRvdDtcIjpcIuKLllwiLFwiJmx0aHJlZTtcIjpcIuKLi1wiLFwiJmx0aW1lcztcIjpcIuKLiVwiLFwiJmx0bGFycjtcIjpcIuKltlwiLFwiJmx0cXVlc3Q7XCI6XCLiqbtcIixcIiZsdHJQYXI7XCI6XCLippZcIixcIiZsdHJpO1wiOlwi4peDXCIsXCImbHRyaWU7XCI6XCLiirRcIixcIiZsdHJpZjtcIjpcIuKXglwiLFwiJmx1cmRzaGFyO1wiOlwi4qWKXCIsXCImbHVydWhhcjtcIjpcIuKlplwiLFwiJmx2ZXJ0bmVxcTtcIjpcIuKJqO+4gFwiLFwiJmx2bkU7XCI6XCLiiajvuIBcIixcIiZtRERvdDtcIjpcIuKIulwiLFwiJm1hY3JcIjpcIsKvXCIsXCImbWFjcjtcIjpcIsKvXCIsXCImbWFsZTtcIjpcIuKZglwiLFwiJm1hbHQ7XCI6XCLinKBcIixcIiZtYWx0ZXNlO1wiOlwi4pygXCIsXCImbWFwO1wiOlwi4oamXCIsXCImbWFwc3RvO1wiOlwi4oamXCIsXCImbWFwc3RvZG93bjtcIjpcIuKGp1wiLFwiJm1hcHN0b2xlZnQ7XCI6XCLihqRcIixcIiZtYXBzdG91cDtcIjpcIuKGpVwiLFwiJm1hcmtlcjtcIjpcIuKWrlwiLFwiJm1jb21tYTtcIjpcIuKoqVwiLFwiJm1jeTtcIjpcItC8XCIsXCImbWRhc2g7XCI6XCLigJRcIixcIiZtZWFzdXJlZGFuZ2xlO1wiOlwi4oihXCIsXCImbWZyO1wiOlwi8J2UqlwiLFwiJm1obztcIjpcIuKEp1wiLFwiJm1pY3JvXCI6XCLCtVwiLFwiJm1pY3JvO1wiOlwiwrVcIixcIiZtaWQ7XCI6XCLiiKNcIixcIiZtaWRhc3Q7XCI6XCIqXCIsXCImbWlkY2lyO1wiOlwi4quwXCIsXCImbWlkZG90XCI6XCLCt1wiLFwiJm1pZGRvdDtcIjpcIsK3XCIsXCImbWludXM7XCI6XCLiiJJcIixcIiZtaW51c2I7XCI6XCLiip9cIixcIiZtaW51c2Q7XCI6XCLiiLhcIixcIiZtaW51c2R1O1wiOlwi4qiqXCIsXCImbWxjcDtcIjpcIuKrm1wiLFwiJm1sZHI7XCI6XCLigKZcIixcIiZtbnBsdXM7XCI6XCLiiJNcIixcIiZtb2RlbHM7XCI6XCLiiqdcIixcIiZtb3BmO1wiOlwi8J2VnlwiLFwiJm1wO1wiOlwi4oiTXCIsXCImbXNjcjtcIjpcIvCdk4JcIixcIiZtc3Rwb3M7XCI6XCLiiL5cIixcIiZtdTtcIjpcIs68XCIsXCImbXVsdGltYXA7XCI6XCLiirhcIixcIiZtdW1hcDtcIjpcIuKKuFwiLFwiJm5HZztcIjpcIuKLmcy4XCIsXCImbkd0O1wiOlwi4omr4oOSXCIsXCImbkd0djtcIjpcIuKJq8y4XCIsXCImbkxlZnRhcnJvdztcIjpcIuKHjVwiLFwiJm5MZWZ0cmlnaHRhcnJvdztcIjpcIuKHjlwiLFwiJm5MbDtcIjpcIuKLmMy4XCIsXCImbkx0O1wiOlwi4omq4oOSXCIsXCImbkx0djtcIjpcIuKJqsy4XCIsXCImblJpZ2h0YXJyb3c7XCI6XCLih49cIixcIiZuVkRhc2g7XCI6XCLiiq9cIixcIiZuVmRhc2g7XCI6XCLiiq5cIixcIiZuYWJsYTtcIjpcIuKIh1wiLFwiJm5hY3V0ZTtcIjpcIsWEXCIsXCImbmFuZztcIjpcIuKIoOKDklwiLFwiJm5hcDtcIjpcIuKJiVwiLFwiJm5hcEU7XCI6XCLiqbDMuFwiLFwiJm5hcGlkO1wiOlwi4omLzLhcIixcIiZuYXBvcztcIjpcIsWJXCIsXCImbmFwcHJveDtcIjpcIuKJiVwiLFwiJm5hdHVyO1wiOlwi4pmuXCIsXCImbmF0dXJhbDtcIjpcIuKZrlwiLFwiJm5hdHVyYWxzO1wiOlwi4oSVXCIsXCImbmJzcFwiOlwiwqBcIixcIiZuYnNwO1wiOlwiwqBcIixcIiZuYnVtcDtcIjpcIuKJjsy4XCIsXCImbmJ1bXBlO1wiOlwi4omPzLhcIixcIiZuY2FwO1wiOlwi4qmDXCIsXCImbmNhcm9uO1wiOlwixYhcIixcIiZuY2VkaWw7XCI6XCLFhlwiLFwiJm5jb25nO1wiOlwi4omHXCIsXCImbmNvbmdkb3Q7XCI6XCLiqa3MuFwiLFwiJm5jdXA7XCI6XCLiqYJcIixcIiZuY3k7XCI6XCLQvVwiLFwiJm5kYXNoO1wiOlwi4oCTXCIsXCImbmU7XCI6XCLiiaBcIixcIiZuZUFycjtcIjpcIuKHl1wiLFwiJm5lYXJoaztcIjpcIuKkpFwiLFwiJm5lYXJyO1wiOlwi4oaXXCIsXCImbmVhcnJvdztcIjpcIuKGl1wiLFwiJm5lZG90O1wiOlwi4omQzLhcIixcIiZuZXF1aXY7XCI6XCLiiaJcIixcIiZuZXNlYXI7XCI6XCLipKhcIixcIiZuZXNpbTtcIjpcIuKJgsy4XCIsXCImbmV4aXN0O1wiOlwi4oiEXCIsXCImbmV4aXN0cztcIjpcIuKIhFwiLFwiJm5mcjtcIjpcIvCdlKtcIixcIiZuZ0U7XCI6XCLiiafMuFwiLFwiJm5nZTtcIjpcIuKJsVwiLFwiJm5nZXE7XCI6XCLiibFcIixcIiZuZ2VxcTtcIjpcIuKJp8y4XCIsXCImbmdlcXNsYW50O1wiOlwi4qm+zLhcIixcIiZuZ2VzO1wiOlwi4qm+zLhcIixcIiZuZ3NpbTtcIjpcIuKJtVwiLFwiJm5ndDtcIjpcIuKJr1wiLFwiJm5ndHI7XCI6XCLiia9cIixcIiZuaEFycjtcIjpcIuKHjlwiLFwiJm5oYXJyO1wiOlwi4oauXCIsXCImbmhwYXI7XCI6XCLiq7JcIixcIiZuaTtcIjpcIuKIi1wiLFwiJm5pcztcIjpcIuKLvFwiLFwiJm5pc2Q7XCI6XCLii7pcIixcIiZuaXY7XCI6XCLiiItcIixcIiZuamN5O1wiOlwi0ZpcIixcIiZubEFycjtcIjpcIuKHjVwiLFwiJm5sRTtcIjpcIuKJpsy4XCIsXCImbmxhcnI7XCI6XCLihppcIixcIiZubGRyO1wiOlwi4oClXCIsXCImbmxlO1wiOlwi4omwXCIsXCImbmxlZnRhcnJvdztcIjpcIuKGmlwiLFwiJm5sZWZ0cmlnaHRhcnJvdztcIjpcIuKGrlwiLFwiJm5sZXE7XCI6XCLiibBcIixcIiZubGVxcTtcIjpcIuKJpsy4XCIsXCImbmxlcXNsYW50O1wiOlwi4qm9zLhcIixcIiZubGVzO1wiOlwi4qm9zLhcIixcIiZubGVzcztcIjpcIuKJrlwiLFwiJm5sc2ltO1wiOlwi4om0XCIsXCImbmx0O1wiOlwi4omuXCIsXCImbmx0cmk7XCI6XCLii6pcIixcIiZubHRyaWU7XCI6XCLii6xcIixcIiZubWlkO1wiOlwi4oikXCIsXCImbm9wZjtcIjpcIvCdlZ9cIixcIiZub3RcIjpcIsKsXCIsXCImbm90O1wiOlwiwqxcIixcIiZub3RpbjtcIjpcIuKIiVwiLFwiJm5vdGluRTtcIjpcIuKLucy4XCIsXCImbm90aW5kb3Q7XCI6XCLii7XMuFwiLFwiJm5vdGludmE7XCI6XCLiiIlcIixcIiZub3RpbnZiO1wiOlwi4ou3XCIsXCImbm90aW52YztcIjpcIuKLtlwiLFwiJm5vdG5pO1wiOlwi4oiMXCIsXCImbm90bml2YTtcIjpcIuKIjFwiLFwiJm5vdG5pdmI7XCI6XCLii75cIixcIiZub3RuaXZjO1wiOlwi4ou9XCIsXCImbnBhcjtcIjpcIuKIplwiLFwiJm5wYXJhbGxlbDtcIjpcIuKIplwiLFwiJm5wYXJzbDtcIjpcIuKrveKDpVwiLFwiJm5wYXJ0O1wiOlwi4oiCzLhcIixcIiZucG9saW50O1wiOlwi4qiUXCIsXCImbnByO1wiOlwi4oqAXCIsXCImbnByY3VlO1wiOlwi4ougXCIsXCImbnByZTtcIjpcIuKqr8y4XCIsXCImbnByZWM7XCI6XCLiioBcIixcIiZucHJlY2VxO1wiOlwi4qqvzLhcIixcIiZuckFycjtcIjpcIuKHj1wiLFwiJm5yYXJyO1wiOlwi4oabXCIsXCImbnJhcnJjO1wiOlwi4qSzzLhcIixcIiZucmFycnc7XCI6XCLihp3MuFwiLFwiJm5yaWdodGFycm93O1wiOlwi4oabXCIsXCImbnJ0cmk7XCI6XCLii6tcIixcIiZucnRyaWU7XCI6XCLii61cIixcIiZuc2M7XCI6XCLiioFcIixcIiZuc2NjdWU7XCI6XCLii6FcIixcIiZuc2NlO1wiOlwi4qqwzLhcIixcIiZuc2NyO1wiOlwi8J2Tg1wiLFwiJm5zaG9ydG1pZDtcIjpcIuKIpFwiLFwiJm5zaG9ydHBhcmFsbGVsO1wiOlwi4oimXCIsXCImbnNpbTtcIjpcIuKJgVwiLFwiJm5zaW1lO1wiOlwi4omEXCIsXCImbnNpbWVxO1wiOlwi4omEXCIsXCImbnNtaWQ7XCI6XCLiiKRcIixcIiZuc3BhcjtcIjpcIuKIplwiLFwiJm5zcXN1YmU7XCI6XCLii6JcIixcIiZuc3FzdXBlO1wiOlwi4oujXCIsXCImbnN1YjtcIjpcIuKKhFwiLFwiJm5zdWJFO1wiOlwi4quFzLhcIixcIiZuc3ViZTtcIjpcIuKKiFwiLFwiJm5zdWJzZXQ7XCI6XCLiioLig5JcIixcIiZuc3Vic2V0ZXE7XCI6XCLiiohcIixcIiZuc3Vic2V0ZXFxO1wiOlwi4quFzLhcIixcIiZuc3VjYztcIjpcIuKKgVwiLFwiJm5zdWNjZXE7XCI6XCLiqrDMuFwiLFwiJm5zdXA7XCI6XCLiioVcIixcIiZuc3VwRTtcIjpcIuKrhsy4XCIsXCImbnN1cGU7XCI6XCLiiolcIixcIiZuc3Vwc2V0O1wiOlwi4oqD4oOSXCIsXCImbnN1cHNldGVxO1wiOlwi4oqJXCIsXCImbnN1cHNldGVxcTtcIjpcIuKrhsy4XCIsXCImbnRnbDtcIjpcIuKJuVwiLFwiJm50aWxkZVwiOlwiw7FcIixcIiZudGlsZGU7XCI6XCLDsVwiLFwiJm50bGc7XCI6XCLiibhcIixcIiZudHJpYW5nbGVsZWZ0O1wiOlwi4ouqXCIsXCImbnRyaWFuZ2xlbGVmdGVxO1wiOlwi4ousXCIsXCImbnRyaWFuZ2xlcmlnaHQ7XCI6XCLii6tcIixcIiZudHJpYW5nbGVyaWdodGVxO1wiOlwi4outXCIsXCImbnU7XCI6XCLOvVwiLFwiJm51bTtcIjpcIiNcIixcIiZudW1lcm87XCI6XCLihJZcIixcIiZudW1zcDtcIjpcIuKAh1wiLFwiJm52RGFzaDtcIjpcIuKKrVwiLFwiJm52SGFycjtcIjpcIuKkhFwiLFwiJm52YXA7XCI6XCLiiY3ig5JcIixcIiZudmRhc2g7XCI6XCLiiqxcIixcIiZudmdlO1wiOlwi4oml4oOSXCIsXCImbnZndDtcIjpcIj7ig5JcIixcIiZudmluZmluO1wiOlwi4qeeXCIsXCImbnZsQXJyO1wiOlwi4qSCXCIsXCImbnZsZTtcIjpcIuKJpOKDklwiLFwiJm52bHQ7XCI6XCI84oOSXCIsXCImbnZsdHJpZTtcIjpcIuKKtOKDklwiLFwiJm52ckFycjtcIjpcIuKkg1wiLFwiJm52cnRyaWU7XCI6XCLiirXig5JcIixcIiZudnNpbTtcIjpcIuKIvOKDklwiLFwiJm53QXJyO1wiOlwi4oeWXCIsXCImbndhcmhrO1wiOlwi4qSjXCIsXCImbndhcnI7XCI6XCLihpZcIixcIiZud2Fycm93O1wiOlwi4oaWXCIsXCImbnduZWFyO1wiOlwi4qSnXCIsXCImb1M7XCI6XCLik4hcIixcIiZvYWN1dGVcIjpcIsOzXCIsXCImb2FjdXRlO1wiOlwiw7NcIixcIiZvYXN0O1wiOlwi4oqbXCIsXCImb2NpcjtcIjpcIuKKmlwiLFwiJm9jaXJjXCI6XCLDtFwiLFwiJm9jaXJjO1wiOlwiw7RcIixcIiZvY3k7XCI6XCLQvlwiLFwiJm9kYXNoO1wiOlwi4oqdXCIsXCImb2RibGFjO1wiOlwixZFcIixcIiZvZGl2O1wiOlwi4qi4XCIsXCImb2RvdDtcIjpcIuKKmVwiLFwiJm9kc29sZDtcIjpcIuKmvFwiLFwiJm9lbGlnO1wiOlwixZNcIixcIiZvZmNpcjtcIjpcIuKmv1wiLFwiJm9mcjtcIjpcIvCdlKxcIixcIiZvZ29uO1wiOlwiy5tcIixcIiZvZ3JhdmVcIjpcIsOyXCIsXCImb2dyYXZlO1wiOlwiw7JcIixcIiZvZ3Q7XCI6XCLip4FcIixcIiZvaGJhcjtcIjpcIuKmtVwiLFwiJm9obTtcIjpcIs6pXCIsXCImb2ludDtcIjpcIuKIrlwiLFwiJm9sYXJyO1wiOlwi4oa6XCIsXCImb2xjaXI7XCI6XCLipr5cIixcIiZvbGNyb3NzO1wiOlwi4qa7XCIsXCImb2xpbmU7XCI6XCLigL5cIixcIiZvbHQ7XCI6XCLip4BcIixcIiZvbWFjcjtcIjpcIsWNXCIsXCImb21lZ2E7XCI6XCLPiVwiLFwiJm9taWNyb247XCI6XCLOv1wiLFwiJm9taWQ7XCI6XCLiprZcIixcIiZvbWludXM7XCI6XCLiipZcIixcIiZvb3BmO1wiOlwi8J2VoFwiLFwiJm9wYXI7XCI6XCLiprdcIixcIiZvcGVycDtcIjpcIuKmuVwiLFwiJm9wbHVzO1wiOlwi4oqVXCIsXCImb3I7XCI6XCLiiKhcIixcIiZvcmFycjtcIjpcIuKGu1wiLFwiJm9yZDtcIjpcIuKpnVwiLFwiJm9yZGVyO1wiOlwi4oS0XCIsXCImb3JkZXJvZjtcIjpcIuKEtFwiLFwiJm9yZGZcIjpcIsKqXCIsXCImb3JkZjtcIjpcIsKqXCIsXCImb3JkbVwiOlwiwrpcIixcIiZvcmRtO1wiOlwiwrpcIixcIiZvcmlnb2Y7XCI6XCLiirZcIixcIiZvcm9yO1wiOlwi4qmWXCIsXCImb3JzbG9wZTtcIjpcIuKpl1wiLFwiJm9ydjtcIjpcIuKpm1wiLFwiJm9zY3I7XCI6XCLihLRcIixcIiZvc2xhc2hcIjpcIsO4XCIsXCImb3NsYXNoO1wiOlwiw7hcIixcIiZvc29sO1wiOlwi4oqYXCIsXCImb3RpbGRlXCI6XCLDtVwiLFwiJm90aWxkZTtcIjpcIsO1XCIsXCImb3RpbWVzO1wiOlwi4oqXXCIsXCImb3RpbWVzYXM7XCI6XCLiqLZcIixcIiZvdW1sXCI6XCLDtlwiLFwiJm91bWw7XCI6XCLDtlwiLFwiJm92YmFyO1wiOlwi4oy9XCIsXCImcGFyO1wiOlwi4oilXCIsXCImcGFyYVwiOlwiwrZcIixcIiZwYXJhO1wiOlwiwrZcIixcIiZwYXJhbGxlbDtcIjpcIuKIpVwiLFwiJnBhcnNpbTtcIjpcIuKrs1wiLFwiJnBhcnNsO1wiOlwi4qu9XCIsXCImcGFydDtcIjpcIuKIglwiLFwiJnBjeTtcIjpcItC/XCIsXCImcGVyY250O1wiOlwiJVwiLFwiJnBlcmlvZDtcIjpcIi5cIixcIiZwZXJtaWw7XCI6XCLigLBcIixcIiZwZXJwO1wiOlwi4oqlXCIsXCImcGVydGVuaztcIjpcIuKAsVwiLFwiJnBmcjtcIjpcIvCdlK1cIixcIiZwaGk7XCI6XCLPhlwiLFwiJnBoaXY7XCI6XCLPlVwiLFwiJnBobW1hdDtcIjpcIuKEs1wiLFwiJnBob25lO1wiOlwi4piOXCIsXCImcGk7XCI6XCLPgFwiLFwiJnBpdGNoZm9yaztcIjpcIuKLlFwiLFwiJnBpdjtcIjpcIs+WXCIsXCImcGxhbmNrO1wiOlwi4oSPXCIsXCImcGxhbmNraDtcIjpcIuKEjlwiLFwiJnBsYW5rdjtcIjpcIuKEj1wiLFwiJnBsdXM7XCI6XCIrXCIsXCImcGx1c2FjaXI7XCI6XCLiqKNcIixcIiZwbHVzYjtcIjpcIuKKnlwiLFwiJnBsdXNjaXI7XCI6XCLiqKJcIixcIiZwbHVzZG87XCI6XCLiiJRcIixcIiZwbHVzZHU7XCI6XCLiqKVcIixcIiZwbHVzZTtcIjpcIuKpslwiLFwiJnBsdXNtblwiOlwiwrFcIixcIiZwbHVzbW47XCI6XCLCsVwiLFwiJnBsdXNzaW07XCI6XCLiqKZcIixcIiZwbHVzdHdvO1wiOlwi4qinXCIsXCImcG07XCI6XCLCsVwiLFwiJnBvaW50aW50O1wiOlwi4qiVXCIsXCImcG9wZjtcIjpcIvCdlaFcIixcIiZwb3VuZFwiOlwiwqNcIixcIiZwb3VuZDtcIjpcIsKjXCIsXCImcHI7XCI6XCLiibpcIixcIiZwckU7XCI6XCLiqrNcIixcIiZwcmFwO1wiOlwi4qq3XCIsXCImcHJjdWU7XCI6XCLiibxcIixcIiZwcmU7XCI6XCLiqq9cIixcIiZwcmVjO1wiOlwi4om6XCIsXCImcHJlY2FwcHJveDtcIjpcIuKqt1wiLFwiJnByZWNjdXJseWVxO1wiOlwi4om8XCIsXCImcHJlY2VxO1wiOlwi4qqvXCIsXCImcHJlY25hcHByb3g7XCI6XCLiqrlcIixcIiZwcmVjbmVxcTtcIjpcIuKqtVwiLFwiJnByZWNuc2ltO1wiOlwi4ouoXCIsXCImcHJlY3NpbTtcIjpcIuKJvlwiLFwiJnByaW1lO1wiOlwi4oCyXCIsXCImcHJpbWVzO1wiOlwi4oSZXCIsXCImcHJuRTtcIjpcIuKqtVwiLFwiJnBybmFwO1wiOlwi4qq5XCIsXCImcHJuc2ltO1wiOlwi4ouoXCIsXCImcHJvZDtcIjpcIuKIj1wiLFwiJnByb2ZhbGFyO1wiOlwi4oyuXCIsXCImcHJvZmxpbmU7XCI6XCLijJJcIixcIiZwcm9mc3VyZjtcIjpcIuKMk1wiLFwiJnByb3A7XCI6XCLiiJ1cIixcIiZwcm9wdG87XCI6XCLiiJ1cIixcIiZwcnNpbTtcIjpcIuKJvlwiLFwiJnBydXJlbDtcIjpcIuKKsFwiLFwiJnBzY3I7XCI6XCLwnZOFXCIsXCImcHNpO1wiOlwiz4hcIixcIiZwdW5jc3A7XCI6XCLigIhcIixcIiZxZnI7XCI6XCLwnZSuXCIsXCImcWludDtcIjpcIuKojFwiLFwiJnFvcGY7XCI6XCLwnZWiXCIsXCImcXByaW1lO1wiOlwi4oGXXCIsXCImcXNjcjtcIjpcIvCdk4ZcIixcIiZxdWF0ZXJuaW9ucztcIjpcIuKEjVwiLFwiJnF1YXRpbnQ7XCI6XCLiqJZcIixcIiZxdWVzdDtcIjpcIj9cIixcIiZxdWVzdGVxO1wiOlwi4omfXCIsXCImcXVvdFwiOidcIicsXCImcXVvdDtcIjonXCInLFwiJnJBYXJyO1wiOlwi4oebXCIsXCImckFycjtcIjpcIuKHklwiLFwiJnJBdGFpbDtcIjpcIuKknFwiLFwiJnJCYXJyO1wiOlwi4qSPXCIsXCImckhhcjtcIjpcIuKlpFwiLFwiJnJhY2U7XCI6XCLiiL3MsVwiLFwiJnJhY3V0ZTtcIjpcIsWVXCIsXCImcmFkaWM7XCI6XCLiiJpcIixcIiZyYWVtcHR5djtcIjpcIuKms1wiLFwiJnJhbmc7XCI6XCLin6lcIixcIiZyYW5nZDtcIjpcIuKmklwiLFwiJnJhbmdlO1wiOlwi4qalXCIsXCImcmFuZ2xlO1wiOlwi4p+pXCIsXCImcmFxdW9cIjpcIsK7XCIsXCImcmFxdW87XCI6XCLCu1wiLFwiJnJhcnI7XCI6XCLihpJcIixcIiZyYXJyYXA7XCI6XCLipbVcIixcIiZyYXJyYjtcIjpcIuKHpVwiLFwiJnJhcnJiZnM7XCI6XCLipKBcIixcIiZyYXJyYztcIjpcIuKks1wiLFwiJnJhcnJmcztcIjpcIuKknlwiLFwiJnJhcnJoaztcIjpcIuKGqlwiLFwiJnJhcnJscDtcIjpcIuKGrFwiLFwiJnJhcnJwbDtcIjpcIuKlhVwiLFwiJnJhcnJzaW07XCI6XCLipbRcIixcIiZyYXJydGw7XCI6XCLihqNcIixcIiZyYXJydztcIjpcIuKGnVwiLFwiJnJhdGFpbDtcIjpcIuKkmlwiLFwiJnJhdGlvO1wiOlwi4oi2XCIsXCImcmF0aW9uYWxzO1wiOlwi4oSaXCIsXCImcmJhcnI7XCI6XCLipI1cIixcIiZyYmJyaztcIjpcIuKds1wiLFwiJnJicmFjZTtcIjpcIn1cIixcIiZyYnJhY2s7XCI6XCJdXCIsXCImcmJya2U7XCI6XCLipoxcIixcIiZyYnJrc2xkO1wiOlwi4qaOXCIsXCImcmJya3NsdTtcIjpcIuKmkFwiLFwiJnJjYXJvbjtcIjpcIsWZXCIsXCImcmNlZGlsO1wiOlwixZdcIixcIiZyY2VpbDtcIjpcIuKMiVwiLFwiJnJjdWI7XCI6XCJ9XCIsXCImcmN5O1wiOlwi0YBcIixcIiZyZGNhO1wiOlwi4qS3XCIsXCImcmRsZGhhcjtcIjpcIuKlqVwiLFwiJnJkcXVvO1wiOlwi4oCdXCIsXCImcmRxdW9yO1wiOlwi4oCdXCIsXCImcmRzaDtcIjpcIuKGs1wiLFwiJnJlYWw7XCI6XCLihJxcIixcIiZyZWFsaW5lO1wiOlwi4oSbXCIsXCImcmVhbHBhcnQ7XCI6XCLihJxcIixcIiZyZWFscztcIjpcIuKEnVwiLFwiJnJlY3Q7XCI6XCLilq1cIixcIiZyZWdcIjpcIsKuXCIsXCImcmVnO1wiOlwiwq5cIixcIiZyZmlzaHQ7XCI6XCLipb1cIixcIiZyZmxvb3I7XCI6XCLijItcIixcIiZyZnI7XCI6XCLwnZSvXCIsXCImcmhhcmQ7XCI6XCLih4FcIixcIiZyaGFydTtcIjpcIuKHgFwiLFwiJnJoYXJ1bDtcIjpcIuKlrFwiLFwiJnJobztcIjpcIs+BXCIsXCImcmhvdjtcIjpcIs+xXCIsXCImcmlnaHRhcnJvdztcIjpcIuKGklwiLFwiJnJpZ2h0YXJyb3d0YWlsO1wiOlwi4oajXCIsXCImcmlnaHRoYXJwb29uZG93bjtcIjpcIuKHgVwiLFwiJnJpZ2h0aGFycG9vbnVwO1wiOlwi4oeAXCIsXCImcmlnaHRsZWZ0YXJyb3dzO1wiOlwi4oeEXCIsXCImcmlnaHRsZWZ0aGFycG9vbnM7XCI6XCLih4xcIixcIiZyaWdodHJpZ2h0YXJyb3dzO1wiOlwi4oeJXCIsXCImcmlnaHRzcXVpZ2Fycm93O1wiOlwi4oadXCIsXCImcmlnaHR0aHJlZXRpbWVzO1wiOlwi4ouMXCIsXCImcmluZztcIjpcIsuaXCIsXCImcmlzaW5nZG90c2VxO1wiOlwi4omTXCIsXCImcmxhcnI7XCI6XCLih4RcIixcIiZybGhhcjtcIjpcIuKHjFwiLFwiJnJsbTtcIjpcIuKAj1wiLFwiJnJtb3VzdDtcIjpcIuKOsVwiLFwiJnJtb3VzdGFjaGU7XCI6XCLijrFcIixcIiZybm1pZDtcIjpcIuKrrlwiLFwiJnJvYW5nO1wiOlwi4p+tXCIsXCImcm9hcnI7XCI6XCLih75cIixcIiZyb2JyaztcIjpcIuKfp1wiLFwiJnJvcGFyO1wiOlwi4qaGXCIsXCImcm9wZjtcIjpcIvCdlaNcIixcIiZyb3BsdXM7XCI6XCLiqK5cIixcIiZyb3RpbWVzO1wiOlwi4qi1XCIsXCImcnBhcjtcIjpcIilcIixcIiZycGFyZ3Q7XCI6XCLippRcIixcIiZycHBvbGludDtcIjpcIuKoklwiLFwiJnJyYXJyO1wiOlwi4oeJXCIsXCImcnNhcXVvO1wiOlwi4oC6XCIsXCImcnNjcjtcIjpcIvCdk4dcIixcIiZyc2g7XCI6XCLihrFcIixcIiZyc3FiO1wiOlwiXVwiLFwiJnJzcXVvO1wiOlwi4oCZXCIsXCImcnNxdW9yO1wiOlwi4oCZXCIsXCImcnRocmVlO1wiOlwi4ouMXCIsXCImcnRpbWVzO1wiOlwi4ouKXCIsXCImcnRyaTtcIjpcIuKWuVwiLFwiJnJ0cmllO1wiOlwi4oq1XCIsXCImcnRyaWY7XCI6XCLilrhcIixcIiZydHJpbHRyaTtcIjpcIuKnjlwiLFwiJnJ1bHVoYXI7XCI6XCLipahcIixcIiZyeDtcIjpcIuKEnlwiLFwiJnNhY3V0ZTtcIjpcIsWbXCIsXCImc2JxdW87XCI6XCLigJpcIixcIiZzYztcIjpcIuKJu1wiLFwiJnNjRTtcIjpcIuKqtFwiLFwiJnNjYXA7XCI6XCLiqrhcIixcIiZzY2Fyb247XCI6XCLFoVwiLFwiJnNjY3VlO1wiOlwi4om9XCIsXCImc2NlO1wiOlwi4qqwXCIsXCImc2NlZGlsO1wiOlwixZ9cIixcIiZzY2lyYztcIjpcIsWdXCIsXCImc2NuRTtcIjpcIuKqtlwiLFwiJnNjbmFwO1wiOlwi4qq6XCIsXCImc2Nuc2ltO1wiOlwi4oupXCIsXCImc2Nwb2xpbnQ7XCI6XCLiqJNcIixcIiZzY3NpbTtcIjpcIuKJv1wiLFwiJnNjeTtcIjpcItGBXCIsXCImc2RvdDtcIjpcIuKLhVwiLFwiJnNkb3RiO1wiOlwi4oqhXCIsXCImc2RvdGU7XCI6XCLiqaZcIixcIiZzZUFycjtcIjpcIuKHmFwiLFwiJnNlYXJoaztcIjpcIuKkpVwiLFwiJnNlYXJyO1wiOlwi4oaYXCIsXCImc2VhcnJvdztcIjpcIuKGmFwiLFwiJnNlY3RcIjpcIsKnXCIsXCImc2VjdDtcIjpcIsKnXCIsXCImc2VtaTtcIjpcIjtcIixcIiZzZXN3YXI7XCI6XCLipKlcIixcIiZzZXRtaW51cztcIjpcIuKIllwiLFwiJnNldG1uO1wiOlwi4oiWXCIsXCImc2V4dDtcIjpcIuKctlwiLFwiJnNmcjtcIjpcIvCdlLBcIixcIiZzZnJvd247XCI6XCLijKJcIixcIiZzaGFycDtcIjpcIuKZr1wiLFwiJnNoY2hjeTtcIjpcItGJXCIsXCImc2hjeTtcIjpcItGIXCIsXCImc2hvcnRtaWQ7XCI6XCLiiKNcIixcIiZzaG9ydHBhcmFsbGVsO1wiOlwi4oilXCIsXCImc2h5XCI6XCLCrVwiLFwiJnNoeTtcIjpcIsKtXCIsXCImc2lnbWE7XCI6XCLPg1wiLFwiJnNpZ21hZjtcIjpcIs+CXCIsXCImc2lnbWF2O1wiOlwiz4JcIixcIiZzaW07XCI6XCLiiLxcIixcIiZzaW1kb3Q7XCI6XCLiqapcIixcIiZzaW1lO1wiOlwi4omDXCIsXCImc2ltZXE7XCI6XCLiiYNcIixcIiZzaW1nO1wiOlwi4qqeXCIsXCImc2ltZ0U7XCI6XCLiqqBcIixcIiZzaW1sO1wiOlwi4qqdXCIsXCImc2ltbEU7XCI6XCLiqp9cIixcIiZzaW1uZTtcIjpcIuKJhlwiLFwiJnNpbXBsdXM7XCI6XCLiqKRcIixcIiZzaW1yYXJyO1wiOlwi4qWyXCIsXCImc2xhcnI7XCI6XCLihpBcIixcIiZzbWFsbHNldG1pbnVzO1wiOlwi4oiWXCIsXCImc21hc2hwO1wiOlwi4qizXCIsXCImc21lcGFyc2w7XCI6XCLip6RcIixcIiZzbWlkO1wiOlwi4oijXCIsXCImc21pbGU7XCI6XCLijKNcIixcIiZzbXQ7XCI6XCLiqqpcIixcIiZzbXRlO1wiOlwi4qqsXCIsXCImc210ZXM7XCI6XCLiqqzvuIBcIixcIiZzb2Z0Y3k7XCI6XCLRjFwiLFwiJnNvbDtcIjpcIi9cIixcIiZzb2xiO1wiOlwi4qeEXCIsXCImc29sYmFyO1wiOlwi4oy/XCIsXCImc29wZjtcIjpcIvCdlaRcIixcIiZzcGFkZXM7XCI6XCLimaBcIixcIiZzcGFkZXN1aXQ7XCI6XCLimaBcIixcIiZzcGFyO1wiOlwi4oilXCIsXCImc3FjYXA7XCI6XCLiipNcIixcIiZzcWNhcHM7XCI6XCLiipPvuIBcIixcIiZzcWN1cDtcIjpcIuKKlFwiLFwiJnNxY3VwcztcIjpcIuKKlO+4gFwiLFwiJnNxc3ViO1wiOlwi4oqPXCIsXCImc3FzdWJlO1wiOlwi4oqRXCIsXCImc3FzdWJzZXQ7XCI6XCLiio9cIixcIiZzcXN1YnNldGVxO1wiOlwi4oqRXCIsXCImc3FzdXA7XCI6XCLiipBcIixcIiZzcXN1cGU7XCI6XCLiipJcIixcIiZzcXN1cHNldDtcIjpcIuKKkFwiLFwiJnNxc3Vwc2V0ZXE7XCI6XCLiipJcIixcIiZzcXU7XCI6XCLilqFcIixcIiZzcXVhcmU7XCI6XCLilqFcIixcIiZzcXVhcmY7XCI6XCLilqpcIixcIiZzcXVmO1wiOlwi4paqXCIsXCImc3JhcnI7XCI6XCLihpJcIixcIiZzc2NyO1wiOlwi8J2TiFwiLFwiJnNzZXRtbjtcIjpcIuKIllwiLFwiJnNzbWlsZTtcIjpcIuKMo1wiLFwiJnNzdGFyZjtcIjpcIuKLhlwiLFwiJnN0YXI7XCI6XCLimIZcIixcIiZzdGFyZjtcIjpcIuKYhVwiLFwiJnN0cmFpZ2h0ZXBzaWxvbjtcIjpcIs+1XCIsXCImc3RyYWlnaHRwaGk7XCI6XCLPlVwiLFwiJnN0cm5zO1wiOlwiwq9cIixcIiZzdWI7XCI6XCLiioJcIixcIiZzdWJFO1wiOlwi4quFXCIsXCImc3ViZG90O1wiOlwi4qq9XCIsXCImc3ViZTtcIjpcIuKKhlwiLFwiJnN1YmVkb3Q7XCI6XCLiq4NcIixcIiZzdWJtdWx0O1wiOlwi4quBXCIsXCImc3VibkU7XCI6XCLiq4tcIixcIiZzdWJuZTtcIjpcIuKKilwiLFwiJnN1YnBsdXM7XCI6XCLiqr9cIixcIiZzdWJyYXJyO1wiOlwi4qW5XCIsXCImc3Vic2V0O1wiOlwi4oqCXCIsXCImc3Vic2V0ZXE7XCI6XCLiioZcIixcIiZzdWJzZXRlcXE7XCI6XCLiq4VcIixcIiZzdWJzZXRuZXE7XCI6XCLiiopcIixcIiZzdWJzZXRuZXFxO1wiOlwi4quLXCIsXCImc3Vic2ltO1wiOlwi4quHXCIsXCImc3Vic3ViO1wiOlwi4quVXCIsXCImc3Vic3VwO1wiOlwi4quTXCIsXCImc3VjYztcIjpcIuKJu1wiLFwiJnN1Y2NhcHByb3g7XCI6XCLiqrhcIixcIiZzdWNjY3VybHllcTtcIjpcIuKJvVwiLFwiJnN1Y2NlcTtcIjpcIuKqsFwiLFwiJnN1Y2NuYXBwcm94O1wiOlwi4qq6XCIsXCImc3VjY25lcXE7XCI6XCLiqrZcIixcIiZzdWNjbnNpbTtcIjpcIuKLqVwiLFwiJnN1Y2NzaW07XCI6XCLiib9cIixcIiZzdW07XCI6XCLiiJFcIixcIiZzdW5nO1wiOlwi4pmqXCIsXCImc3VwMVwiOlwiwrlcIixcIiZzdXAxO1wiOlwiwrlcIixcIiZzdXAyXCI6XCLCslwiLFwiJnN1cDI7XCI6XCLCslwiLFwiJnN1cDNcIjpcIsKzXCIsXCImc3VwMztcIjpcIsKzXCIsXCImc3VwO1wiOlwi4oqDXCIsXCImc3VwRTtcIjpcIuKrhlwiLFwiJnN1cGRvdDtcIjpcIuKqvlwiLFwiJnN1cGRzdWI7XCI6XCLiq5hcIixcIiZzdXBlO1wiOlwi4oqHXCIsXCImc3VwZWRvdDtcIjpcIuKrhFwiLFwiJnN1cGhzb2w7XCI6XCLin4lcIixcIiZzdXBoc3ViO1wiOlwi4quXXCIsXCImc3VwbGFycjtcIjpcIuKlu1wiLFwiJnN1cG11bHQ7XCI6XCLiq4JcIixcIiZzdXBuRTtcIjpcIuKrjFwiLFwiJnN1cG5lO1wiOlwi4oqLXCIsXCImc3VwcGx1cztcIjpcIuKrgFwiLFwiJnN1cHNldDtcIjpcIuKKg1wiLFwiJnN1cHNldGVxO1wiOlwi4oqHXCIsXCImc3Vwc2V0ZXFxO1wiOlwi4quGXCIsXCImc3Vwc2V0bmVxO1wiOlwi4oqLXCIsXCImc3Vwc2V0bmVxcTtcIjpcIuKrjFwiLFwiJnN1cHNpbTtcIjpcIuKriFwiLFwiJnN1cHN1YjtcIjpcIuKrlFwiLFwiJnN1cHN1cDtcIjpcIuKrllwiLFwiJnN3QXJyO1wiOlwi4oeZXCIsXCImc3dhcmhrO1wiOlwi4qSmXCIsXCImc3dhcnI7XCI6XCLihplcIixcIiZzd2Fycm93O1wiOlwi4oaZXCIsXCImc3dud2FyO1wiOlwi4qSqXCIsXCImc3psaWdcIjpcIsOfXCIsXCImc3psaWc7XCI6XCLDn1wiLFwiJnRhcmdldDtcIjpcIuKMllwiLFwiJnRhdTtcIjpcIs+EXCIsXCImdGJyaztcIjpcIuKOtFwiLFwiJnRjYXJvbjtcIjpcIsWlXCIsXCImdGNlZGlsO1wiOlwixaNcIixcIiZ0Y3k7XCI6XCLRglwiLFwiJnRkb3Q7XCI6XCLig5tcIixcIiZ0ZWxyZWM7XCI6XCLijJVcIixcIiZ0ZnI7XCI6XCLwnZSxXCIsXCImdGhlcmU0O1wiOlwi4oi0XCIsXCImdGhlcmVmb3JlO1wiOlwi4oi0XCIsXCImdGhldGE7XCI6XCLOuFwiLFwiJnRoZXRhc3ltO1wiOlwiz5FcIixcIiZ0aGV0YXY7XCI6XCLPkVwiLFwiJnRoaWNrYXBwcm94O1wiOlwi4omIXCIsXCImdGhpY2tzaW07XCI6XCLiiLxcIixcIiZ0aGluc3A7XCI6XCLigIlcIixcIiZ0aGthcDtcIjpcIuKJiFwiLFwiJnRoa3NpbTtcIjpcIuKIvFwiLFwiJnRob3JuXCI6XCLDvlwiLFwiJnRob3JuO1wiOlwiw75cIixcIiZ0aWxkZTtcIjpcIsucXCIsXCImdGltZXNcIjpcIsOXXCIsXCImdGltZXM7XCI6XCLDl1wiLFwiJnRpbWVzYjtcIjpcIuKKoFwiLFwiJnRpbWVzYmFyO1wiOlwi4qixXCIsXCImdGltZXNkO1wiOlwi4qiwXCIsXCImdGludDtcIjpcIuKIrVwiLFwiJnRvZWE7XCI6XCLipKhcIixcIiZ0b3A7XCI6XCLiiqRcIixcIiZ0b3Bib3Q7XCI6XCLijLZcIixcIiZ0b3BjaXI7XCI6XCLiq7FcIixcIiZ0b3BmO1wiOlwi8J2VpVwiLFwiJnRvcGZvcms7XCI6XCLiq5pcIixcIiZ0b3NhO1wiOlwi4qSpXCIsXCImdHByaW1lO1wiOlwi4oC0XCIsXCImdHJhZGU7XCI6XCLihKJcIixcIiZ0cmlhbmdsZTtcIjpcIuKWtVwiLFwiJnRyaWFuZ2xlZG93bjtcIjpcIuKWv1wiLFwiJnRyaWFuZ2xlbGVmdDtcIjpcIuKXg1wiLFwiJnRyaWFuZ2xlbGVmdGVxO1wiOlwi4oq0XCIsXCImdHJpYW5nbGVxO1wiOlwi4omcXCIsXCImdHJpYW5nbGVyaWdodDtcIjpcIuKWuVwiLFwiJnRyaWFuZ2xlcmlnaHRlcTtcIjpcIuKKtVwiLFwiJnRyaWRvdDtcIjpcIuKXrFwiLFwiJnRyaWU7XCI6XCLiiZxcIixcIiZ0cmltaW51cztcIjpcIuKoulwiLFwiJnRyaXBsdXM7XCI6XCLiqLlcIixcIiZ0cmlzYjtcIjpcIuKnjVwiLFwiJnRyaXRpbWU7XCI6XCLiqLtcIixcIiZ0cnBleml1bTtcIjpcIuKPolwiLFwiJnRzY3I7XCI6XCLwnZOJXCIsXCImdHNjeTtcIjpcItGGXCIsXCImdHNoY3k7XCI6XCLRm1wiLFwiJnRzdHJvaztcIjpcIsWnXCIsXCImdHdpeHQ7XCI6XCLiiaxcIixcIiZ0d29oZWFkbGVmdGFycm93O1wiOlwi4oaeXCIsXCImdHdvaGVhZHJpZ2h0YXJyb3c7XCI6XCLihqBcIixcIiZ1QXJyO1wiOlwi4oeRXCIsXCImdUhhcjtcIjpcIuKlo1wiLFwiJnVhY3V0ZVwiOlwiw7pcIixcIiZ1YWN1dGU7XCI6XCLDulwiLFwiJnVhcnI7XCI6XCLihpFcIixcIiZ1YnJjeTtcIjpcItGeXCIsXCImdWJyZXZlO1wiOlwixa1cIixcIiZ1Y2lyY1wiOlwiw7tcIixcIiZ1Y2lyYztcIjpcIsO7XCIsXCImdWN5O1wiOlwi0YNcIixcIiZ1ZGFycjtcIjpcIuKHhVwiLFwiJnVkYmxhYztcIjpcIsWxXCIsXCImdWRoYXI7XCI6XCLipa5cIixcIiZ1ZmlzaHQ7XCI6XCLipb5cIixcIiZ1ZnI7XCI6XCLwnZSyXCIsXCImdWdyYXZlXCI6XCLDuVwiLFwiJnVncmF2ZTtcIjpcIsO5XCIsXCImdWhhcmw7XCI6XCLihr9cIixcIiZ1aGFycjtcIjpcIuKGvlwiLFwiJnVoYmxrO1wiOlwi4paAXCIsXCImdWxjb3JuO1wiOlwi4oycXCIsXCImdWxjb3JuZXI7XCI6XCLijJxcIixcIiZ1bGNyb3A7XCI6XCLijI9cIixcIiZ1bHRyaTtcIjpcIuKXuFwiLFwiJnVtYWNyO1wiOlwixatcIixcIiZ1bWxcIjpcIsKoXCIsXCImdW1sO1wiOlwiwqhcIixcIiZ1b2dvbjtcIjpcIsWzXCIsXCImdW9wZjtcIjpcIvCdlaZcIixcIiZ1cGFycm93O1wiOlwi4oaRXCIsXCImdXBkb3duYXJyb3c7XCI6XCLihpVcIixcIiZ1cGhhcnBvb25sZWZ0O1wiOlwi4oa/XCIsXCImdXBoYXJwb29ucmlnaHQ7XCI6XCLihr5cIixcIiZ1cGx1cztcIjpcIuKKjlwiLFwiJnVwc2k7XCI6XCLPhVwiLFwiJnVwc2loO1wiOlwiz5JcIixcIiZ1cHNpbG9uO1wiOlwiz4VcIixcIiZ1cHVwYXJyb3dzO1wiOlwi4oeIXCIsXCImdXJjb3JuO1wiOlwi4oydXCIsXCImdXJjb3JuZXI7XCI6XCLijJ1cIixcIiZ1cmNyb3A7XCI6XCLijI5cIixcIiZ1cmluZztcIjpcIsWvXCIsXCImdXJ0cmk7XCI6XCLil7lcIixcIiZ1c2NyO1wiOlwi8J2TilwiLFwiJnV0ZG90O1wiOlwi4ouwXCIsXCImdXRpbGRlO1wiOlwixalcIixcIiZ1dHJpO1wiOlwi4pa1XCIsXCImdXRyaWY7XCI6XCLilrRcIixcIiZ1dWFycjtcIjpcIuKHiFwiLFwiJnV1bWxcIjpcIsO8XCIsXCImdXVtbDtcIjpcIsO8XCIsXCImdXdhbmdsZTtcIjpcIuKmp1wiLFwiJnZBcnI7XCI6XCLih5VcIixcIiZ2QmFyO1wiOlwi4quoXCIsXCImdkJhcnY7XCI6XCLiq6lcIixcIiZ2RGFzaDtcIjpcIuKKqFwiLFwiJnZhbmdydDtcIjpcIuKmnFwiLFwiJnZhcmVwc2lsb247XCI6XCLPtVwiLFwiJnZhcmthcHBhO1wiOlwiz7BcIixcIiZ2YXJub3RoaW5nO1wiOlwi4oiFXCIsXCImdmFycGhpO1wiOlwiz5VcIixcIiZ2YXJwaTtcIjpcIs+WXCIsXCImdmFycHJvcHRvO1wiOlwi4oidXCIsXCImdmFycjtcIjpcIuKGlVwiLFwiJnZhcnJobztcIjpcIs+xXCIsXCImdmFyc2lnbWE7XCI6XCLPglwiLFwiJnZhcnN1YnNldG5lcTtcIjpcIuKKiu+4gFwiLFwiJnZhcnN1YnNldG5lcXE7XCI6XCLiq4vvuIBcIixcIiZ2YXJzdXBzZXRuZXE7XCI6XCLiiovvuIBcIixcIiZ2YXJzdXBzZXRuZXFxO1wiOlwi4quM77iAXCIsXCImdmFydGhldGE7XCI6XCLPkVwiLFwiJnZhcnRyaWFuZ2xlbGVmdDtcIjpcIuKKslwiLFwiJnZhcnRyaWFuZ2xlcmlnaHQ7XCI6XCLiirNcIixcIiZ2Y3k7XCI6XCLQslwiLFwiJnZkYXNoO1wiOlwi4oqiXCIsXCImdmVlO1wiOlwi4oioXCIsXCImdmVlYmFyO1wiOlwi4oq7XCIsXCImdmVlZXE7XCI6XCLiiZpcIixcIiZ2ZWxsaXA7XCI6XCLii65cIixcIiZ2ZXJiYXI7XCI6XCJ8XCIsXCImdmVydDtcIjpcInxcIixcIiZ2ZnI7XCI6XCLwnZSzXCIsXCImdmx0cmk7XCI6XCLiirJcIixcIiZ2bnN1YjtcIjpcIuKKguKDklwiLFwiJnZuc3VwO1wiOlwi4oqD4oOSXCIsXCImdm9wZjtcIjpcIvCdladcIixcIiZ2cHJvcDtcIjpcIuKInVwiLFwiJnZydHJpO1wiOlwi4oqzXCIsXCImdnNjcjtcIjpcIvCdk4tcIixcIiZ2c3VibkU7XCI6XCLiq4vvuIBcIixcIiZ2c3VibmU7XCI6XCLiiorvuIBcIixcIiZ2c3VwbkU7XCI6XCLiq4zvuIBcIixcIiZ2c3VwbmU7XCI6XCLiiovvuIBcIixcIiZ2emlnemFnO1wiOlwi4qaaXCIsXCImd2NpcmM7XCI6XCLFtVwiLFwiJndlZGJhcjtcIjpcIuKpn1wiLFwiJndlZGdlO1wiOlwi4oinXCIsXCImd2VkZ2VxO1wiOlwi4omZXCIsXCImd2VpZXJwO1wiOlwi4oSYXCIsXCImd2ZyO1wiOlwi8J2UtFwiLFwiJndvcGY7XCI6XCLwnZWoXCIsXCImd3A7XCI6XCLihJhcIixcIiZ3cjtcIjpcIuKJgFwiLFwiJndyZWF0aDtcIjpcIuKJgFwiLFwiJndzY3I7XCI6XCLwnZOMXCIsXCImeGNhcDtcIjpcIuKLglwiLFwiJnhjaXJjO1wiOlwi4pevXCIsXCImeGN1cDtcIjpcIuKLg1wiLFwiJnhkdHJpO1wiOlwi4pa9XCIsXCImeGZyO1wiOlwi8J2UtVwiLFwiJnhoQXJyO1wiOlwi4p+6XCIsXCImeGhhcnI7XCI6XCLin7dcIixcIiZ4aTtcIjpcIs6+XCIsXCImeGxBcnI7XCI6XCLin7hcIixcIiZ4bGFycjtcIjpcIuKftVwiLFwiJnhtYXA7XCI6XCLin7xcIixcIiZ4bmlzO1wiOlwi4ou7XCIsXCImeG9kb3Q7XCI6XCLiqIBcIixcIiZ4b3BmO1wiOlwi8J2VqVwiLFwiJnhvcGx1cztcIjpcIuKogVwiLFwiJnhvdGltZTtcIjpcIuKoglwiLFwiJnhyQXJyO1wiOlwi4p+5XCIsXCImeHJhcnI7XCI6XCLin7ZcIixcIiZ4c2NyO1wiOlwi8J2TjVwiLFwiJnhzcWN1cDtcIjpcIuKohlwiLFwiJnh1cGx1cztcIjpcIuKohFwiLFwiJnh1dHJpO1wiOlwi4pazXCIsXCImeHZlZTtcIjpcIuKLgVwiLFwiJnh3ZWRnZTtcIjpcIuKLgFwiLFwiJnlhY3V0ZVwiOlwiw71cIixcIiZ5YWN1dGU7XCI6XCLDvVwiLFwiJnlhY3k7XCI6XCLRj1wiLFwiJnljaXJjO1wiOlwixbdcIixcIiZ5Y3k7XCI6XCLRi1wiLFwiJnllblwiOlwiwqVcIixcIiZ5ZW47XCI6XCLCpVwiLFwiJnlmcjtcIjpcIvCdlLZcIixcIiZ5aWN5O1wiOlwi0ZdcIixcIiZ5b3BmO1wiOlwi8J2VqlwiLFwiJnlzY3I7XCI6XCLwnZOOXCIsXCImeXVjeTtcIjpcItGOXCIsXCImeXVtbFwiOlwiw79cIixcIiZ5dW1sO1wiOlwiw79cIixcIiZ6YWN1dGU7XCI6XCLFulwiLFwiJnpjYXJvbjtcIjpcIsW+XCIsXCImemN5O1wiOlwi0LdcIixcIiZ6ZG90O1wiOlwixbxcIixcIiZ6ZWV0cmY7XCI6XCLihKhcIixcIiZ6ZXRhO1wiOlwizrZcIixcIiZ6ZnI7XCI6XCLwnZS3XCIsXCImemhjeTtcIjpcItC2XCIsXCImemlncmFycjtcIjpcIuKHnVwiLFwiJnpvcGY7XCI6XCLwnZWrXCIsXCImenNjcjtcIjpcIvCdk49cIixcIiZ6d2o7XCI6XCLigI1cIixcIiZ6d25qO1wiOlwi4oCMXCJ9LGNoYXJhY3RlcnM6e1wiw4ZcIjpcIiZBRWxpZztcIixcIiZcIjpcIiZhbXA7XCIsXCLDgVwiOlwiJkFhY3V0ZTtcIixcIsSCXCI6XCImQWJyZXZlO1wiLFwiw4JcIjpcIiZBY2lyYztcIixcItCQXCI6XCImQWN5O1wiLFwi8J2UhFwiOlwiJkFmcjtcIixcIsOAXCI6XCImQWdyYXZlO1wiLFwizpFcIjpcIiZBbHBoYTtcIixcIsSAXCI6XCImQW1hY3I7XCIsXCLiqZNcIjpcIiZBbmQ7XCIsXCLEhFwiOlwiJkFvZ29uO1wiLFwi8J2UuFwiOlwiJkFvcGY7XCIsXCLigaFcIjpcIiZhZjtcIixcIsOFXCI6XCImYW5nc3Q7XCIsXCLwnZKcXCI6XCImQXNjcjtcIixcIuKJlFwiOlwiJmNvbG9uZXE7XCIsXCLDg1wiOlwiJkF0aWxkZTtcIixcIsOEXCI6XCImQXVtbDtcIixcIuKIllwiOlwiJnNzZXRtbjtcIixcIuKrp1wiOlwiJkJhcnY7XCIsXCLijIZcIjpcIiZkb3VibGViYXJ3ZWRnZTtcIixcItCRXCI6XCImQmN5O1wiLFwi4oi1XCI6XCImYmVjYXVzZTtcIixcIuKErFwiOlwiJmJlcm5vdTtcIixcIs6SXCI6XCImQmV0YTtcIixcIvCdlIVcIjpcIiZCZnI7XCIsXCLwnZS5XCI6XCImQm9wZjtcIixcIsuYXCI6XCImYnJldmU7XCIsXCLiiY5cIjpcIiZidW1wO1wiLFwi0KdcIjpcIiZDSGN5O1wiLFwiwqlcIjpcIiZjb3B5O1wiLFwixIZcIjpcIiZDYWN1dGU7XCIsXCLii5JcIjpcIiZDYXA7XCIsXCLihYVcIjpcIiZERDtcIixcIuKErVwiOlwiJkNmcjtcIixcIsSMXCI6XCImQ2Nhcm9uO1wiLFwiw4dcIjpcIiZDY2VkaWw7XCIsXCLEiFwiOlwiJkNjaXJjO1wiLFwi4oiwXCI6XCImQ2NvbmludDtcIixcIsSKXCI6XCImQ2RvdDtcIixcIsK4XCI6XCImY2VkaWw7XCIsXCLCt1wiOlwiJm1pZGRvdDtcIixcIs6nXCI6XCImQ2hpO1wiLFwi4oqZXCI6XCImb2RvdDtcIixcIuKKllwiOlwiJm9taW51cztcIixcIuKKlVwiOlwiJm9wbHVzO1wiLFwi4oqXXCI6XCImb3RpbWVzO1wiLFwi4oiyXCI6XCImY3djb25pbnQ7XCIsXCLigJ1cIjpcIiZyZHF1b3I7XCIsXCLigJlcIjpcIiZyc3F1b3I7XCIsXCLiiLdcIjpcIiZQcm9wb3J0aW9uO1wiLFwi4qm0XCI6XCImQ29sb25lO1wiLFwi4omhXCI6XCImZXF1aXY7XCIsXCLiiK9cIjpcIiZEb3VibGVDb250b3VySW50ZWdyYWw7XCIsXCLiiK5cIjpcIiZvaW50O1wiLFwi4oSCXCI6XCImY29tcGxleGVzO1wiLFwi4oiQXCI6XCImY29wcm9kO1wiLFwi4oizXCI6XCImYXdjb25pbnQ7XCIsXCLiqK9cIjpcIiZDcm9zcztcIixcIvCdkp5cIjpcIiZDc2NyO1wiLFwi4ouTXCI6XCImQ3VwO1wiLFwi4omNXCI6XCImYXN5bXBlcTtcIixcIuKkkVwiOlwiJkREb3RyYWhkO1wiLFwi0IJcIjpcIiZESmN5O1wiLFwi0IVcIjpcIiZEU2N5O1wiLFwi0I9cIjpcIiZEWmN5O1wiLFwi4oChXCI6XCImZGRhZ2dlcjtcIixcIuKGoVwiOlwiJkRhcnI7XCIsXCLiq6RcIjpcIiZEb3VibGVMZWZ0VGVlO1wiLFwixI5cIjpcIiZEY2Fyb247XCIsXCLQlFwiOlwiJkRjeTtcIixcIuKIh1wiOlwiJm5hYmxhO1wiLFwizpRcIjpcIiZEZWx0YTtcIixcIvCdlIdcIjpcIiZEZnI7XCIsXCLCtFwiOlwiJmFjdXRlO1wiLFwiy5lcIjpcIiZkb3Q7XCIsXCLLnVwiOlwiJmRibGFjO1wiLFwiYFwiOlwiJmdyYXZlO1wiLFwiy5xcIjpcIiZ0aWxkZTtcIixcIuKLhFwiOlwiJmRpYW1vbmQ7XCIsXCLihYZcIjpcIiZkZDtcIixcIvCdlLtcIjpcIiZEb3BmO1wiLFwiwqhcIjpcIiZ1bWw7XCIsXCLig5xcIjpcIiZEb3REb3Q7XCIsXCLiiZBcIjpcIiZlc2RvdDtcIixcIuKHk1wiOlwiJmRBcnI7XCIsXCLih5BcIjpcIiZsQXJyO1wiLFwi4oeUXCI6XCImaWZmO1wiLFwi4p+4XCI6XCImeGxBcnI7XCIsXCLin7pcIjpcIiZ4aEFycjtcIixcIuKfuVwiOlwiJnhyQXJyO1wiLFwi4oeSXCI6XCImckFycjtcIixcIuKKqFwiOlwiJnZEYXNoO1wiLFwi4oeRXCI6XCImdUFycjtcIixcIuKHlVwiOlwiJnZBcnI7XCIsXCLiiKVcIjpcIiZzcGFyO1wiLFwi4oaTXCI6XCImZG93bmFycm93O1wiLFwi4qSTXCI6XCImRG93bkFycm93QmFyO1wiLFwi4oe1XCI6XCImZHVhcnI7XCIsXCLMkVwiOlwiJkRvd25CcmV2ZTtcIixcIuKlkFwiOlwiJkRvd25MZWZ0UmlnaHRWZWN0b3I7XCIsXCLipZ5cIjpcIiZEb3duTGVmdFRlZVZlY3RvcjtcIixcIuKGvVwiOlwiJmxoYXJkO1wiLFwi4qWWXCI6XCImRG93bkxlZnRWZWN0b3JCYXI7XCIsXCLipZ9cIjpcIiZEb3duUmlnaHRUZWVWZWN0b3I7XCIsXCLih4FcIjpcIiZyaWdodGhhcnBvb25kb3duO1wiLFwi4qWXXCI6XCImRG93blJpZ2h0VmVjdG9yQmFyO1wiLFwi4oqkXCI6XCImdG9wO1wiLFwi4oanXCI6XCImbWFwc3RvZG93bjtcIixcIvCdkp9cIjpcIiZEc2NyO1wiLFwixJBcIjpcIiZEc3Ryb2s7XCIsXCLFilwiOlwiJkVORztcIixcIsOQXCI6XCImRVRIO1wiLFwiw4lcIjpcIiZFYWN1dGU7XCIsXCLEmlwiOlwiJkVjYXJvbjtcIixcIsOKXCI6XCImRWNpcmM7XCIsXCLQrVwiOlwiJkVjeTtcIixcIsSWXCI6XCImRWRvdDtcIixcIvCdlIhcIjpcIiZFZnI7XCIsXCLDiFwiOlwiJkVncmF2ZTtcIixcIuKIiFwiOlwiJmlzaW52O1wiLFwixJJcIjpcIiZFbWFjcjtcIixcIuKXu1wiOlwiJkVtcHR5U21hbGxTcXVhcmU7XCIsXCLilqtcIjpcIiZFbXB0eVZlcnlTbWFsbFNxdWFyZTtcIixcIsSYXCI6XCImRW9nb247XCIsXCLwnZS8XCI6XCImRW9wZjtcIixcIs6VXCI6XCImRXBzaWxvbjtcIixcIuKptVwiOlwiJkVxdWFsO1wiLFwi4omCXCI6XCImZXNpbTtcIixcIuKHjFwiOlwiJnJsaGFyO1wiLFwi4oSwXCI6XCImZXhwZWN0YXRpb247XCIsXCLiqbNcIjpcIiZFc2ltO1wiLFwizpdcIjpcIiZFdGE7XCIsXCLDi1wiOlwiJkV1bWw7XCIsXCLiiINcIjpcIiZleGlzdDtcIixcIuKFh1wiOlwiJmV4cG9uZW50aWFsZTtcIixcItCkXCI6XCImRmN5O1wiLFwi8J2UiVwiOlwiJkZmcjtcIixcIuKXvFwiOlwiJkZpbGxlZFNtYWxsU3F1YXJlO1wiLFwi4paqXCI6XCImc3F1ZjtcIixcIvCdlL1cIjpcIiZGb3BmO1wiLFwi4oiAXCI6XCImZm9yYWxsO1wiLFwi4oSxXCI6XCImRnNjcjtcIixcItCDXCI6XCImR0pjeTtcIixcIj5cIjpcIiZndDtcIixcIs6TXCI6XCImR2FtbWE7XCIsXCLPnFwiOlwiJkdhbW1hZDtcIixcIsSeXCI6XCImR2JyZXZlO1wiLFwixKJcIjpcIiZHY2VkaWw7XCIsXCLEnFwiOlwiJkdjaXJjO1wiLFwi0JNcIjpcIiZHY3k7XCIsXCLEoFwiOlwiJkdkb3Q7XCIsXCLwnZSKXCI6XCImR2ZyO1wiLFwi4ouZXCI6XCImZ2dnO1wiLFwi8J2UvlwiOlwiJkdvcGY7XCIsXCLiiaVcIjpcIiZnZXE7XCIsXCLii5tcIjpcIiZndHJlcWxlc3M7XCIsXCLiiadcIjpcIiZnZXFxO1wiLFwi4qqiXCI6XCImR3JlYXRlckdyZWF0ZXI7XCIsXCLiibdcIjpcIiZndHJsZXNzO1wiLFwi4qm+XCI6XCImZ2VzO1wiLFwi4omzXCI6XCImZ3Ryc2ltO1wiLFwi8J2SolwiOlwiJkdzY3I7XCIsXCLiiatcIjpcIiZnZztcIixcItCqXCI6XCImSEFSRGN5O1wiLFwiy4dcIjpcIiZjYXJvbjtcIixcIl5cIjpcIiZIYXQ7XCIsXCLEpFwiOlwiJkhjaXJjO1wiLFwi4oSMXCI6XCImUG9pbmNhcmVwbGFuZTtcIixcIuKEi1wiOlwiJmhhbWlsdDtcIixcIuKEjVwiOlwiJnF1YXRlcm5pb25zO1wiLFwi4pSAXCI6XCImYm94aDtcIixcIsSmXCI6XCImSHN0cm9rO1wiLFwi4omPXCI6XCImYnVtcGVxO1wiLFwi0JVcIjpcIiZJRWN5O1wiLFwixLJcIjpcIiZJSmxpZztcIixcItCBXCI6XCImSU9jeTtcIixcIsONXCI6XCImSWFjdXRlO1wiLFwiw45cIjpcIiZJY2lyYztcIixcItCYXCI6XCImSWN5O1wiLFwixLBcIjpcIiZJZG90O1wiLFwi4oSRXCI6XCImaW1hZ3BhcnQ7XCIsXCLDjFwiOlwiJklncmF2ZTtcIixcIsSqXCI6XCImSW1hY3I7XCIsXCLihYhcIjpcIiZpaTtcIixcIuKIrFwiOlwiJkludDtcIixcIuKIq1wiOlwiJmludDtcIixcIuKLglwiOlwiJnhjYXA7XCIsXCLigaNcIjpcIiZpYztcIixcIuKBolwiOlwiJml0O1wiLFwixK5cIjpcIiZJb2dvbjtcIixcIvCdlYBcIjpcIiZJb3BmO1wiLFwizplcIjpcIiZJb3RhO1wiLFwi4oSQXCI6XCImaW1hZ2xpbmU7XCIsXCLEqFwiOlwiJkl0aWxkZTtcIixcItCGXCI6XCImSXVrY3k7XCIsXCLDj1wiOlwiJkl1bWw7XCIsXCLEtFwiOlwiJkpjaXJjO1wiLFwi0JlcIjpcIiZKY3k7XCIsXCLwnZSNXCI6XCImSmZyO1wiLFwi8J2VgVwiOlwiJkpvcGY7XCIsXCLwnZKlXCI6XCImSnNjcjtcIixcItCIXCI6XCImSnNlcmN5O1wiLFwi0IRcIjpcIiZKdWtjeTtcIixcItClXCI6XCImS0hjeTtcIixcItCMXCI6XCImS0pjeTtcIixcIs6aXCI6XCImS2FwcGE7XCIsXCLEtlwiOlwiJktjZWRpbDtcIixcItCaXCI6XCImS2N5O1wiLFwi8J2UjlwiOlwiJktmcjtcIixcIvCdlYJcIjpcIiZLb3BmO1wiLFwi8J2SplwiOlwiJktzY3I7XCIsXCLQiVwiOlwiJkxKY3k7XCIsXCI8XCI6XCImbHQ7XCIsXCLEuVwiOlwiJkxhY3V0ZTtcIixcIs6bXCI6XCImTGFtYmRhO1wiLFwi4p+qXCI6XCImTGFuZztcIixcIuKEklwiOlwiJmxhZ3JhbjtcIixcIuKGnlwiOlwiJnR3b2hlYWRsZWZ0YXJyb3c7XCIsXCLEvVwiOlwiJkxjYXJvbjtcIixcIsS7XCI6XCImTGNlZGlsO1wiLFwi0JtcIjpcIiZMY3k7XCIsXCLin6hcIjpcIiZsYW5nbGU7XCIsXCLihpBcIjpcIiZzbGFycjtcIixcIuKHpFwiOlwiJmxhcnJiO1wiLFwi4oeGXCI6XCImbHJhcnI7XCIsXCLijIhcIjpcIiZsY2VpbDtcIixcIuKfplwiOlwiJmxvYnJrO1wiLFwi4qWhXCI6XCImTGVmdERvd25UZWVWZWN0b3I7XCIsXCLih4NcIjpcIiZkb3duaGFycG9vbmxlZnQ7XCIsXCLipZlcIjpcIiZMZWZ0RG93blZlY3RvckJhcjtcIixcIuKMilwiOlwiJmxmbG9vcjtcIixcIuKGlFwiOlwiJmxlZnRyaWdodGFycm93O1wiLFwi4qWOXCI6XCImTGVmdFJpZ2h0VmVjdG9yO1wiLFwi4oqjXCI6XCImZGFzaHY7XCIsXCLihqRcIjpcIiZtYXBzdG9sZWZ0O1wiLFwi4qWaXCI6XCImTGVmdFRlZVZlY3RvcjtcIixcIuKKslwiOlwiJnZsdHJpO1wiLFwi4qePXCI6XCImTGVmdFRyaWFuZ2xlQmFyO1wiLFwi4oq0XCI6XCImdHJpYW5nbGVsZWZ0ZXE7XCIsXCLipZFcIjpcIiZMZWZ0VXBEb3duVmVjdG9yO1wiLFwi4qWgXCI6XCImTGVmdFVwVGVlVmVjdG9yO1wiLFwi4oa/XCI6XCImdXBoYXJwb29ubGVmdDtcIixcIuKlmFwiOlwiJkxlZnRVcFZlY3RvckJhcjtcIixcIuKGvFwiOlwiJmxoYXJ1O1wiLFwi4qWSXCI6XCImTGVmdFZlY3RvckJhcjtcIixcIuKLmlwiOlwiJmxlc3NlcWd0cjtcIixcIuKJplwiOlwiJmxlcXE7XCIsXCLiibZcIjpcIiZsZztcIixcIuKqoVwiOlwiJkxlc3NMZXNzO1wiLFwi4qm9XCI6XCImbGVzO1wiLFwi4omyXCI6XCImbHNpbTtcIixcIvCdlI9cIjpcIiZMZnI7XCIsXCLii5hcIjpcIiZMbDtcIixcIuKHmlwiOlwiJmxBYXJyO1wiLFwixL9cIjpcIiZMbWlkb3Q7XCIsXCLin7VcIjpcIiZ4bGFycjtcIixcIuKft1wiOlwiJnhoYXJyO1wiLFwi4p+2XCI6XCImeHJhcnI7XCIsXCLwnZWDXCI6XCImTG9wZjtcIixcIuKGmVwiOlwiJnN3YXJyb3c7XCIsXCLihphcIjpcIiZzZWFycm93O1wiLFwi4oawXCI6XCImbHNoO1wiLFwixYFcIjpcIiZMc3Ryb2s7XCIsXCLiiapcIjpcIiZsbDtcIixcIuKkhVwiOlwiJk1hcDtcIixcItCcXCI6XCImTWN5O1wiLFwi4oGfXCI6XCImTWVkaXVtU3BhY2U7XCIsXCLihLNcIjpcIiZwaG1tYXQ7XCIsXCLwnZSQXCI6XCImTWZyO1wiLFwi4oiTXCI6XCImbXA7XCIsXCLwnZWEXCI6XCImTW9wZjtcIixcIs6cXCI6XCImTXU7XCIsXCLQilwiOlwiJk5KY3k7XCIsXCLFg1wiOlwiJk5hY3V0ZTtcIixcIsWHXCI6XCImTmNhcm9uO1wiLFwixYVcIjpcIiZOY2VkaWw7XCIsXCLQnVwiOlwiJk5jeTtcIixcIuKAi1wiOlwiJlplcm9XaWR0aFNwYWNlO1wiLFwiXFxuXCI6XCImTmV3TGluZTtcIixcIvCdlJFcIjpcIiZOZnI7XCIsXCLigaBcIjpcIiZOb0JyZWFrO1wiLFwiwqBcIjpcIiZuYnNwO1wiLFwi4oSVXCI6XCImbmF0dXJhbHM7XCIsXCLiq6xcIjpcIiZOb3Q7XCIsXCLiiaJcIjpcIiZuZXF1aXY7XCIsXCLiia1cIjpcIiZOb3RDdXBDYXA7XCIsXCLiiKZcIjpcIiZuc3BhcjtcIixcIuKIiVwiOlwiJm5vdGludmE7XCIsXCLiiaBcIjpcIiZuZTtcIixcIuKJgsy4XCI6XCImbmVzaW07XCIsXCLiiIRcIjpcIiZuZXhpc3RzO1wiLFwi4omvXCI6XCImbmd0cjtcIixcIuKJsVwiOlwiJm5nZXE7XCIsXCLiiafMuFwiOlwiJm5nZXFxO1wiLFwi4omrzLhcIjpcIiZuR3R2O1wiLFwi4om5XCI6XCImbnRnbDtcIixcIuKpvsy4XCI6XCImbmdlcztcIixcIuKJtVwiOlwiJm5nc2ltO1wiLFwi4omOzLhcIjpcIiZuYnVtcDtcIixcIuKJj8y4XCI6XCImbmJ1bXBlO1wiLFwi4ouqXCI6XCImbnRyaWFuZ2xlbGVmdDtcIixcIuKnj8y4XCI6XCImTm90TGVmdFRyaWFuZ2xlQmFyO1wiLFwi4ousXCI6XCImbnRyaWFuZ2xlbGVmdGVxO1wiLFwi4omuXCI6XCImbmx0O1wiLFwi4omwXCI6XCImbmxlcTtcIixcIuKJuFwiOlwiJm50bGc7XCIsXCLiiarMuFwiOlwiJm5MdHY7XCIsXCLiqb3MuFwiOlwiJm5sZXM7XCIsXCLiibRcIjpcIiZubHNpbTtcIixcIuKqosy4XCI6XCImTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7XCIsXCLiqqHMuFwiOlwiJk5vdE5lc3RlZExlc3NMZXNzO1wiLFwi4oqAXCI6XCImbnByZWM7XCIsXCLiqq/MuFwiOlwiJm5wcmVjZXE7XCIsXCLii6BcIjpcIiZucHJjdWU7XCIsXCLiiIxcIjpcIiZub3RuaXZhO1wiLFwi4ourXCI6XCImbnRyaWFuZ2xlcmlnaHQ7XCIsXCLip5DMuFwiOlwiJk5vdFJpZ2h0VHJpYW5nbGVCYXI7XCIsXCLii61cIjpcIiZudHJpYW5nbGVyaWdodGVxO1wiLFwi4oqPzLhcIjpcIiZOb3RTcXVhcmVTdWJzZXQ7XCIsXCLii6JcIjpcIiZuc3FzdWJlO1wiLFwi4oqQzLhcIjpcIiZOb3RTcXVhcmVTdXBlcnNldDtcIixcIuKLo1wiOlwiJm5zcXN1cGU7XCIsXCLiioLig5JcIjpcIiZ2bnN1YjtcIixcIuKKiFwiOlwiJm5zdWJzZXRlcTtcIixcIuKKgVwiOlwiJm5zdWNjO1wiLFwi4qqwzLhcIjpcIiZuc3VjY2VxO1wiLFwi4ouhXCI6XCImbnNjY3VlO1wiLFwi4om/zLhcIjpcIiZOb3RTdWNjZWVkc1RpbGRlO1wiLFwi4oqD4oOSXCI6XCImdm5zdXA7XCIsXCLiiolcIjpcIiZuc3Vwc2V0ZXE7XCIsXCLiiYFcIjpcIiZuc2ltO1wiLFwi4omEXCI6XCImbnNpbWVxO1wiLFwi4omHXCI6XCImbmNvbmc7XCIsXCLiiYlcIjpcIiZuYXBwcm94O1wiLFwi4oikXCI6XCImbnNtaWQ7XCIsXCLwnZKpXCI6XCImTnNjcjtcIixcIsORXCI6XCImTnRpbGRlO1wiLFwizp1cIjpcIiZOdTtcIixcIsWSXCI6XCImT0VsaWc7XCIsXCLDk1wiOlwiJk9hY3V0ZTtcIixcIsOUXCI6XCImT2NpcmM7XCIsXCLQnlwiOlwiJk9jeTtcIixcIsWQXCI6XCImT2RibGFjO1wiLFwi8J2UklwiOlwiJk9mcjtcIixcIsOSXCI6XCImT2dyYXZlO1wiLFwixYxcIjpcIiZPbWFjcjtcIixcIs6pXCI6XCImb2htO1wiLFwizp9cIjpcIiZPbWljcm9uO1wiLFwi8J2VhlwiOlwiJk9vcGY7XCIsXCLigJxcIjpcIiZsZHF1bztcIixcIuKAmFwiOlwiJmxzcXVvO1wiLFwi4qmUXCI6XCImT3I7XCIsXCLwnZKqXCI6XCImT3NjcjtcIixcIsOYXCI6XCImT3NsYXNoO1wiLFwiw5VcIjpcIiZPdGlsZGU7XCIsXCLiqLdcIjpcIiZPdGltZXM7XCIsXCLDllwiOlwiJk91bWw7XCIsXCLigL5cIjpcIiZvbGluZTtcIixcIuKPnlwiOlwiJk92ZXJCcmFjZTtcIixcIuKOtFwiOlwiJnRicms7XCIsXCLij5xcIjpcIiZPdmVyUGFyZW50aGVzaXM7XCIsXCLiiIJcIjpcIiZwYXJ0O1wiLFwi0J9cIjpcIiZQY3k7XCIsXCLwnZSTXCI6XCImUGZyO1wiLFwizqZcIjpcIiZQaGk7XCIsXCLOoFwiOlwiJlBpO1wiLFwiwrFcIjpcIiZwbTtcIixcIuKEmVwiOlwiJnByaW1lcztcIixcIuKqu1wiOlwiJlByO1wiLFwi4om6XCI6XCImcHJlYztcIixcIuKqr1wiOlwiJnByZWNlcTtcIixcIuKJvFwiOlwiJnByZWNjdXJseWVxO1wiLFwi4om+XCI6XCImcHJzaW07XCIsXCLigLNcIjpcIiZQcmltZTtcIixcIuKIj1wiOlwiJnByb2Q7XCIsXCLiiJ1cIjpcIiZ2cHJvcDtcIixcIvCdkqtcIjpcIiZQc2NyO1wiLFwizqhcIjpcIiZQc2k7XCIsJ1wiJzpcIiZxdW90O1wiLFwi8J2UlFwiOlwiJlFmcjtcIixcIuKEmlwiOlwiJnJhdGlvbmFscztcIixcIvCdkqxcIjpcIiZRc2NyO1wiLFwi4qSQXCI6XCImZHJia2Fyb3c7XCIsXCLCrlwiOlwiJnJlZztcIixcIsWUXCI6XCImUmFjdXRlO1wiLFwi4p+rXCI6XCImUmFuZztcIixcIuKGoFwiOlwiJnR3b2hlYWRyaWdodGFycm93O1wiLFwi4qSWXCI6XCImUmFycnRsO1wiLFwixZhcIjpcIiZSY2Fyb247XCIsXCLFllwiOlwiJlJjZWRpbDtcIixcItCgXCI6XCImUmN5O1wiLFwi4oScXCI6XCImcmVhbHBhcnQ7XCIsXCLiiItcIjpcIiZuaXY7XCIsXCLih4tcIjpcIiZscmhhcjtcIixcIuKlr1wiOlwiJmR1aGFyO1wiLFwizqFcIjpcIiZSaG87XCIsXCLin6lcIjpcIiZyYW5nbGU7XCIsXCLihpJcIjpcIiZzcmFycjtcIixcIuKHpVwiOlwiJnJhcnJiO1wiLFwi4oeEXCI6XCImcmxhcnI7XCIsXCLijIlcIjpcIiZyY2VpbDtcIixcIuKfp1wiOlwiJnJvYnJrO1wiLFwi4qWdXCI6XCImUmlnaHREb3duVGVlVmVjdG9yO1wiLFwi4oeCXCI6XCImZG93bmhhcnBvb25yaWdodDtcIixcIuKllVwiOlwiJlJpZ2h0RG93blZlY3RvckJhcjtcIixcIuKMi1wiOlwiJnJmbG9vcjtcIixcIuKKolwiOlwiJnZkYXNoO1wiLFwi4oamXCI6XCImbWFwc3RvO1wiLFwi4qWbXCI6XCImUmlnaHRUZWVWZWN0b3I7XCIsXCLiirNcIjpcIiZ2cnRyaTtcIixcIuKnkFwiOlwiJlJpZ2h0VHJpYW5nbGVCYXI7XCIsXCLiirVcIjpcIiZ0cmlhbmdsZXJpZ2h0ZXE7XCIsXCLipY9cIjpcIiZSaWdodFVwRG93blZlY3RvcjtcIixcIuKlnFwiOlwiJlJpZ2h0VXBUZWVWZWN0b3I7XCIsXCLihr5cIjpcIiZ1cGhhcnBvb25yaWdodDtcIixcIuKllFwiOlwiJlJpZ2h0VXBWZWN0b3JCYXI7XCIsXCLih4BcIjpcIiZyaWdodGhhcnBvb251cDtcIixcIuKlk1wiOlwiJlJpZ2h0VmVjdG9yQmFyO1wiLFwi4oSdXCI6XCImcmVhbHM7XCIsXCLipbBcIjpcIiZSb3VuZEltcGxpZXM7XCIsXCLih5tcIjpcIiZyQWFycjtcIixcIuKEm1wiOlwiJnJlYWxpbmU7XCIsXCLihrFcIjpcIiZyc2g7XCIsXCLip7RcIjpcIiZSdWxlRGVsYXllZDtcIixcItCpXCI6XCImU0hDSGN5O1wiLFwi0KhcIjpcIiZTSGN5O1wiLFwi0KxcIjpcIiZTT0ZUY3k7XCIsXCLFmlwiOlwiJlNhY3V0ZTtcIixcIuKqvFwiOlwiJlNjO1wiLFwixaBcIjpcIiZTY2Fyb247XCIsXCLFnlwiOlwiJlNjZWRpbDtcIixcIsWcXCI6XCImU2NpcmM7XCIsXCLQoVwiOlwiJlNjeTtcIixcIvCdlJZcIjpcIiZTZnI7XCIsXCLihpFcIjpcIiZ1cGFycm93O1wiLFwizqNcIjpcIiZTaWdtYTtcIixcIuKImFwiOlwiJmNvbXBmbjtcIixcIvCdlYpcIjpcIiZTb3BmO1wiLFwi4oiaXCI6XCImcmFkaWM7XCIsXCLilqFcIjpcIiZzcXVhcmU7XCIsXCLiipNcIjpcIiZzcWNhcDtcIixcIuKKj1wiOlwiJnNxc3Vic2V0O1wiLFwi4oqRXCI6XCImc3FzdWJzZXRlcTtcIixcIuKKkFwiOlwiJnNxc3Vwc2V0O1wiLFwi4oqSXCI6XCImc3FzdXBzZXRlcTtcIixcIuKKlFwiOlwiJnNxY3VwO1wiLFwi8J2SrlwiOlwiJlNzY3I7XCIsXCLii4ZcIjpcIiZzc3RhcmY7XCIsXCLii5BcIjpcIiZTdWJzZXQ7XCIsXCLiioZcIjpcIiZzdWJzZXRlcTtcIixcIuKJu1wiOlwiJnN1Y2M7XCIsXCLiqrBcIjpcIiZzdWNjZXE7XCIsXCLiib1cIjpcIiZzdWNjY3VybHllcTtcIixcIuKJv1wiOlwiJnN1Y2NzaW07XCIsXCLiiJFcIjpcIiZzdW07XCIsXCLii5FcIjpcIiZTdXBzZXQ7XCIsXCLiioNcIjpcIiZzdXBzZXQ7XCIsXCLiiodcIjpcIiZzdXBzZXRlcTtcIixcIsOeXCI6XCImVEhPUk47XCIsXCLihKJcIjpcIiZ0cmFkZTtcIixcItCLXCI6XCImVFNIY3k7XCIsXCLQplwiOlwiJlRTY3k7XCIsXCJcXHRcIjpcIiZUYWI7XCIsXCLOpFwiOlwiJlRhdTtcIixcIsWkXCI6XCImVGNhcm9uO1wiLFwixaJcIjpcIiZUY2VkaWw7XCIsXCLQolwiOlwiJlRjeTtcIixcIvCdlJdcIjpcIiZUZnI7XCIsXCLiiLRcIjpcIiZ0aGVyZWZvcmU7XCIsXCLOmFwiOlwiJlRoZXRhO1wiLFwi4oGf4oCKXCI6XCImVGhpY2tTcGFjZTtcIixcIuKAiVwiOlwiJnRoaW5zcDtcIixcIuKIvFwiOlwiJnRoa3NpbTtcIixcIuKJg1wiOlwiJnNpbWVxO1wiLFwi4omFXCI6XCImY29uZztcIixcIuKJiFwiOlwiJnRoa2FwO1wiLFwi8J2Vi1wiOlwiJlRvcGY7XCIsXCLig5tcIjpcIiZ0ZG90O1wiLFwi8J2Sr1wiOlwiJlRzY3I7XCIsXCLFplwiOlwiJlRzdHJvaztcIixcIsOaXCI6XCImVWFjdXRlO1wiLFwi4oafXCI6XCImVWFycjtcIixcIuKliVwiOlwiJlVhcnJvY2lyO1wiLFwi0I5cIjpcIiZVYnJjeTtcIixcIsWsXCI6XCImVWJyZXZlO1wiLFwiw5tcIjpcIiZVY2lyYztcIixcItCjXCI6XCImVWN5O1wiLFwixbBcIjpcIiZVZGJsYWM7XCIsXCLwnZSYXCI6XCImVWZyO1wiLFwiw5lcIjpcIiZVZ3JhdmU7XCIsXCLFqlwiOlwiJlVtYWNyO1wiLF86XCImbG93YmFyO1wiLFwi4o+fXCI6XCImVW5kZXJCcmFjZTtcIixcIuKOtVwiOlwiJmJicms7XCIsXCLij51cIjpcIiZVbmRlclBhcmVudGhlc2lzO1wiLFwi4ouDXCI6XCImeGN1cDtcIixcIuKKjlwiOlwiJnVwbHVzO1wiLFwixbJcIjpcIiZVb2dvbjtcIixcIvCdlYxcIjpcIiZVb3BmO1wiLFwi4qSSXCI6XCImVXBBcnJvd0JhcjtcIixcIuKHhVwiOlwiJnVkYXJyO1wiLFwi4oaVXCI6XCImdmFycjtcIixcIuKlrlwiOlwiJnVkaGFyO1wiLFwi4oqlXCI6XCImcGVycDtcIixcIuKGpVwiOlwiJm1hcHN0b3VwO1wiLFwi4oaWXCI6XCImbndhcnJvdztcIixcIuKGl1wiOlwiJm5lYXJyb3c7XCIsXCLPklwiOlwiJnVwc2loO1wiLFwizqVcIjpcIiZVcHNpbG9uO1wiLFwixa5cIjpcIiZVcmluZztcIixcIvCdkrBcIjpcIiZVc2NyO1wiLFwixahcIjpcIiZVdGlsZGU7XCIsXCLDnFwiOlwiJlV1bWw7XCIsXCLiiqtcIjpcIiZWRGFzaDtcIixcIuKrq1wiOlwiJlZiYXI7XCIsXCLQklwiOlwiJlZjeTtcIixcIuKKqVwiOlwiJlZkYXNoO1wiLFwi4qumXCI6XCImVmRhc2hsO1wiLFwi4ouBXCI6XCImeHZlZTtcIixcIuKAllwiOlwiJlZlcnQ7XCIsXCLiiKNcIjpcIiZzbWlkO1wiLFwifFwiOlwiJnZlcnQ7XCIsXCLinZhcIjpcIiZWZXJ0aWNhbFNlcGFyYXRvcjtcIixcIuKJgFwiOlwiJndyZWF0aDtcIixcIuKAilwiOlwiJmhhaXJzcDtcIixcIvCdlJlcIjpcIiZWZnI7XCIsXCLwnZWNXCI6XCImVm9wZjtcIixcIvCdkrFcIjpcIiZWc2NyO1wiLFwi4oqqXCI6XCImVnZkYXNoO1wiLFwixbRcIjpcIiZXY2lyYztcIixcIuKLgFwiOlwiJnh3ZWRnZTtcIixcIvCdlJpcIjpcIiZXZnI7XCIsXCLwnZWOXCI6XCImV29wZjtcIixcIvCdkrJcIjpcIiZXc2NyO1wiLFwi8J2Um1wiOlwiJlhmcjtcIixcIs6eXCI6XCImWGk7XCIsXCLwnZWPXCI6XCImWG9wZjtcIixcIvCdkrNcIjpcIiZYc2NyO1wiLFwi0K9cIjpcIiZZQWN5O1wiLFwi0IdcIjpcIiZZSWN5O1wiLFwi0K5cIjpcIiZZVWN5O1wiLFwiw51cIjpcIiZZYWN1dGU7XCIsXCLFtlwiOlwiJlljaXJjO1wiLFwi0KtcIjpcIiZZY3k7XCIsXCLwnZScXCI6XCImWWZyO1wiLFwi8J2VkFwiOlwiJllvcGY7XCIsXCLwnZK0XCI6XCImWXNjcjtcIixcIsW4XCI6XCImWXVtbDtcIixcItCWXCI6XCImWkhjeTtcIixcIsW5XCI6XCImWmFjdXRlO1wiLFwixb1cIjpcIiZaY2Fyb247XCIsXCLQl1wiOlwiJlpjeTtcIixcIsW7XCI6XCImWmRvdDtcIixcIs6WXCI6XCImWmV0YTtcIixcIuKEqFwiOlwiJnplZXRyZjtcIixcIuKEpFwiOlwiJmludGVnZXJzO1wiLFwi8J2StVwiOlwiJlpzY3I7XCIsXCLDoVwiOlwiJmFhY3V0ZTtcIixcIsSDXCI6XCImYWJyZXZlO1wiLFwi4oi+XCI6XCImbXN0cG9zO1wiLFwi4oi+zLNcIjpcIiZhY0U7XCIsXCLiiL9cIjpcIiZhY2Q7XCIsXCLDolwiOlwiJmFjaXJjO1wiLFwi0LBcIjpcIiZhY3k7XCIsXCLDplwiOlwiJmFlbGlnO1wiLFwi8J2UnlwiOlwiJmFmcjtcIixcIsOgXCI6XCImYWdyYXZlO1wiLFwi4oS1XCI6XCImYWxlcGg7XCIsXCLOsVwiOlwiJmFscGhhO1wiLFwixIFcIjpcIiZhbWFjcjtcIixcIuKov1wiOlwiJmFtYWxnO1wiLFwi4oinXCI6XCImd2VkZ2U7XCIsXCLiqZVcIjpcIiZhbmRhbmQ7XCIsXCLiqZxcIjpcIiZhbmRkO1wiLFwi4qmYXCI6XCImYW5kc2xvcGU7XCIsXCLiqZpcIjpcIiZhbmR2O1wiLFwi4oigXCI6XCImYW5nbGU7XCIsXCLipqRcIjpcIiZhbmdlO1wiLFwi4oihXCI6XCImbWVhc3VyZWRhbmdsZTtcIixcIuKmqFwiOlwiJmFuZ21zZGFhO1wiLFwi4qapXCI6XCImYW5nbXNkYWI7XCIsXCLipqpcIjpcIiZhbmdtc2RhYztcIixcIuKmq1wiOlwiJmFuZ21zZGFkO1wiLFwi4qasXCI6XCImYW5nbXNkYWU7XCIsXCLipq1cIjpcIiZhbmdtc2RhZjtcIixcIuKmrlwiOlwiJmFuZ21zZGFnO1wiLFwi4qavXCI6XCImYW5nbXNkYWg7XCIsXCLiiJ9cIjpcIiZhbmdydDtcIixcIuKKvlwiOlwiJmFuZ3J0dmI7XCIsXCLipp1cIjpcIiZhbmdydHZiZDtcIixcIuKIolwiOlwiJmFuZ3NwaDtcIixcIuKNvFwiOlwiJmFuZ3phcnI7XCIsXCLEhVwiOlwiJmFvZ29uO1wiLFwi8J2VklwiOlwiJmFvcGY7XCIsXCLiqbBcIjpcIiZhcEU7XCIsXCLiqa9cIjpcIiZhcGFjaXI7XCIsXCLiiYpcIjpcIiZhcHByb3hlcTtcIixcIuKJi1wiOlwiJmFwaWQ7XCIsXCInXCI6XCImYXBvcztcIixcIsOlXCI6XCImYXJpbmc7XCIsXCLwnZK2XCI6XCImYXNjcjtcIixcIipcIjpcIiZtaWRhc3Q7XCIsXCLDo1wiOlwiJmF0aWxkZTtcIixcIsOkXCI6XCImYXVtbDtcIixcIuKokVwiOlwiJmF3aW50O1wiLFwi4qutXCI6XCImYk5vdDtcIixcIuKJjFwiOlwiJmJjb25nO1wiLFwiz7ZcIjpcIiZiZXBzaTtcIixcIuKAtVwiOlwiJmJwcmltZTtcIixcIuKIvVwiOlwiJmJzaW07XCIsXCLii41cIjpcIiZic2ltZTtcIixcIuKKvVwiOlwiJmJhcnZlZTtcIixcIuKMhVwiOlwiJmJhcndlZGdlO1wiLFwi4o62XCI6XCImYmJya3Ricms7XCIsXCLQsVwiOlwiJmJjeTtcIixcIuKAnlwiOlwiJmxkcXVvcjtcIixcIuKmsFwiOlwiJmJlbXB0eXY7XCIsXCLOslwiOlwiJmJldGE7XCIsXCLihLZcIjpcIiZiZXRoO1wiLFwi4omsXCI6XCImdHdpeHQ7XCIsXCLwnZSfXCI6XCImYmZyO1wiLFwi4pevXCI6XCImeGNpcmM7XCIsXCLiqIBcIjpcIiZ4b2RvdDtcIixcIuKogVwiOlwiJnhvcGx1cztcIixcIuKoglwiOlwiJnhvdGltZTtcIixcIuKohlwiOlwiJnhzcWN1cDtcIixcIuKYhVwiOlwiJnN0YXJmO1wiLFwi4pa9XCI6XCImeGR0cmk7XCIsXCLilrNcIjpcIiZ4dXRyaTtcIixcIuKohFwiOlwiJnh1cGx1cztcIixcIuKkjVwiOlwiJnJiYXJyO1wiLFwi4qerXCI6XCImbG96ZjtcIixcIuKWtFwiOlwiJnV0cmlmO1wiLFwi4pa+XCI6XCImZHRyaWY7XCIsXCLil4JcIjpcIiZsdHJpZjtcIixcIuKWuFwiOlwiJnJ0cmlmO1wiLFwi4pCjXCI6XCImYmxhbms7XCIsXCLilpJcIjpcIiZibGsxMjtcIixcIuKWkVwiOlwiJmJsazE0O1wiLFwi4paTXCI6XCImYmxrMzQ7XCIsXCLilohcIjpcIiZibG9jaztcIixcIj3ig6VcIjpcIiZibmU7XCIsXCLiiaHig6VcIjpcIiZibmVxdWl2O1wiLFwi4oyQXCI6XCImYm5vdDtcIixcIvCdlZNcIjpcIiZib3BmO1wiLFwi4ouIXCI6XCImYm93dGllO1wiLFwi4pWXXCI6XCImYm94REw7XCIsXCLilZRcIjpcIiZib3hEUjtcIixcIuKVllwiOlwiJmJveERsO1wiLFwi4pWTXCI6XCImYm94RHI7XCIsXCLilZBcIjpcIiZib3hIO1wiLFwi4pWmXCI6XCImYm94SEQ7XCIsXCLilalcIjpcIiZib3hIVTtcIixcIuKVpFwiOlwiJmJveEhkO1wiLFwi4pWnXCI6XCImYm94SHU7XCIsXCLilZ1cIjpcIiZib3hVTDtcIixcIuKVmlwiOlwiJmJveFVSO1wiLFwi4pWcXCI6XCImYm94VWw7XCIsXCLilZlcIjpcIiZib3hVcjtcIixcIuKVkVwiOlwiJmJveFY7XCIsXCLilaxcIjpcIiZib3hWSDtcIixcIuKVo1wiOlwiJmJveFZMO1wiLFwi4pWgXCI6XCImYm94VlI7XCIsXCLilatcIjpcIiZib3hWaDtcIixcIuKVolwiOlwiJmJveFZsO1wiLFwi4pWfXCI6XCImYm94VnI7XCIsXCLip4lcIjpcIiZib3hib3g7XCIsXCLilZVcIjpcIiZib3hkTDtcIixcIuKVklwiOlwiJmJveGRSO1wiLFwi4pSQXCI6XCImYm94ZGw7XCIsXCLilIxcIjpcIiZib3hkcjtcIixcIuKVpVwiOlwiJmJveGhEO1wiLFwi4pWoXCI6XCImYm94aFU7XCIsXCLilKxcIjpcIiZib3hoZDtcIixcIuKUtFwiOlwiJmJveGh1O1wiLFwi4oqfXCI6XCImbWludXNiO1wiLFwi4oqeXCI6XCImcGx1c2I7XCIsXCLiiqBcIjpcIiZ0aW1lc2I7XCIsXCLilZtcIjpcIiZib3h1TDtcIixcIuKVmFwiOlwiJmJveHVSO1wiLFwi4pSYXCI6XCImYm94dWw7XCIsXCLilJRcIjpcIiZib3h1cjtcIixcIuKUglwiOlwiJmJveHY7XCIsXCLilapcIjpcIiZib3h2SDtcIixcIuKVoVwiOlwiJmJveHZMO1wiLFwi4pWeXCI6XCImYm94dlI7XCIsXCLilLxcIjpcIiZib3h2aDtcIixcIuKUpFwiOlwiJmJveHZsO1wiLFwi4pScXCI6XCImYm94dnI7XCIsXCLCplwiOlwiJmJydmJhcjtcIixcIvCdkrdcIjpcIiZic2NyO1wiLFwi4oGPXCI6XCImYnNlbWk7XCIsXCJcXFxcXCI6XCImYnNvbDtcIixcIuKnhVwiOlwiJmJzb2xiO1wiLFwi4p+IXCI6XCImYnNvbGhzdWI7XCIsXCLigKJcIjpcIiZidWxsZXQ7XCIsXCLiqq5cIjpcIiZidW1wRTtcIixcIsSHXCI6XCImY2FjdXRlO1wiLFwi4oipXCI6XCImY2FwO1wiLFwi4qmEXCI6XCImY2FwYW5kO1wiLFwi4qmJXCI6XCImY2FwYnJjdXA7XCIsXCLiqYtcIjpcIiZjYXBjYXA7XCIsXCLiqYdcIjpcIiZjYXBjdXA7XCIsXCLiqYBcIjpcIiZjYXBkb3Q7XCIsXCLiiKnvuIBcIjpcIiZjYXBzO1wiLFwi4oGBXCI6XCImY2FyZXQ7XCIsXCLiqY1cIjpcIiZjY2FwcztcIixcIsSNXCI6XCImY2Nhcm9uO1wiLFwiw6dcIjpcIiZjY2VkaWw7XCIsXCLEiVwiOlwiJmNjaXJjO1wiLFwi4qmMXCI6XCImY2N1cHM7XCIsXCLiqZBcIjpcIiZjY3Vwc3NtO1wiLFwixItcIjpcIiZjZG90O1wiLFwi4qayXCI6XCImY2VtcHR5djtcIixcIsKiXCI6XCImY2VudDtcIixcIvCdlKBcIjpcIiZjZnI7XCIsXCLRh1wiOlwiJmNoY3k7XCIsXCLinJNcIjpcIiZjaGVja21hcms7XCIsXCLPh1wiOlwiJmNoaTtcIixcIuKXi1wiOlwiJmNpcjtcIixcIuKng1wiOlwiJmNpckU7XCIsXCLLhlwiOlwiJmNpcmM7XCIsXCLiiZdcIjpcIiZjaXJlO1wiLFwi4oa6XCI6XCImb2xhcnI7XCIsXCLihrtcIjpcIiZvcmFycjtcIixcIuKTiFwiOlwiJm9TO1wiLFwi4oqbXCI6XCImb2FzdDtcIixcIuKKmlwiOlwiJm9jaXI7XCIsXCLiip1cIjpcIiZvZGFzaDtcIixcIuKokFwiOlwiJmNpcmZuaW50O1wiLFwi4quvXCI6XCImY2lybWlkO1wiLFwi4qeCXCI6XCImY2lyc2NpcjtcIixcIuKZo1wiOlwiJmNsdWJzdWl0O1wiLFwiOlwiOlwiJmNvbG9uO1wiLFwiLFwiOlwiJmNvbW1hO1wiLFwiQFwiOlwiJmNvbW1hdDtcIixcIuKIgVwiOlwiJmNvbXBsZW1lbnQ7XCIsXCLiqa1cIjpcIiZjb25nZG90O1wiLFwi8J2VlFwiOlwiJmNvcGY7XCIsXCLihJdcIjpcIiZjb3B5c3I7XCIsXCLihrVcIjpcIiZjcmFycjtcIixcIuKcl1wiOlwiJmNyb3NzO1wiLFwi8J2SuFwiOlwiJmNzY3I7XCIsXCLiq49cIjpcIiZjc3ViO1wiLFwi4quRXCI6XCImY3N1YmU7XCIsXCLiq5BcIjpcIiZjc3VwO1wiLFwi4quSXCI6XCImY3N1cGU7XCIsXCLii69cIjpcIiZjdGRvdDtcIixcIuKkuFwiOlwiJmN1ZGFycmw7XCIsXCLipLVcIjpcIiZjdWRhcnJyO1wiLFwi4oueXCI6XCImY3VybHllcXByZWM7XCIsXCLii59cIjpcIiZjdXJseWVxc3VjYztcIixcIuKGtlwiOlwiJmN1cnZlYXJyb3dsZWZ0O1wiLFwi4qS9XCI6XCImY3VsYXJycDtcIixcIuKIqlwiOlwiJmN1cDtcIixcIuKpiFwiOlwiJmN1cGJyY2FwO1wiLFwi4qmGXCI6XCImY3VwY2FwO1wiLFwi4qmKXCI6XCImY3VwY3VwO1wiLFwi4oqNXCI6XCImY3VwZG90O1wiLFwi4qmFXCI6XCImY3Vwb3I7XCIsXCLiiKrvuIBcIjpcIiZjdXBzO1wiLFwi4oa3XCI6XCImY3VydmVhcnJvd3JpZ2h0O1wiLFwi4qS8XCI6XCImY3VyYXJybTtcIixcIuKLjlwiOlwiJmN1dmVlO1wiLFwi4ouPXCI6XCImY3V3ZWQ7XCIsXCLCpFwiOlwiJmN1cnJlbjtcIixcIuKIsVwiOlwiJmN3aW50O1wiLFwi4oytXCI6XCImY3lsY3R5O1wiLFwi4qWlXCI6XCImZEhhcjtcIixcIuKAoFwiOlwiJmRhZ2dlcjtcIixcIuKEuFwiOlwiJmRhbGV0aDtcIixcIuKAkFwiOlwiJmh5cGhlbjtcIixcIuKkj1wiOlwiJnJCYXJyO1wiLFwixI9cIjpcIiZkY2Fyb247XCIsXCLQtFwiOlwiJmRjeTtcIixcIuKHilwiOlwiJmRvd25kb3duYXJyb3dzO1wiLFwi4qm3XCI6XCImZUREb3Q7XCIsXCLCsFwiOlwiJmRlZztcIixcIs60XCI6XCImZGVsdGE7XCIsXCLiprFcIjpcIiZkZW1wdHl2O1wiLFwi4qW/XCI6XCImZGZpc2h0O1wiLFwi8J2UoVwiOlwiJmRmcjtcIixcIuKZplwiOlwiJmRpYW1zO1wiLFwiz51cIjpcIiZnYW1tYWQ7XCIsXCLii7JcIjpcIiZkaXNpbjtcIixcIsO3XCI6XCImZGl2aWRlO1wiLFwi4ouHXCI6XCImZGl2b254O1wiLFwi0ZJcIjpcIiZkamN5O1wiLFwi4oyeXCI6XCImbGxjb3JuZXI7XCIsXCLijI1cIjpcIiZkbGNyb3A7XCIsJDpcIiZkb2xsYXI7XCIsXCLwnZWVXCI6XCImZG9wZjtcIixcIuKJkVwiOlwiJmVEb3Q7XCIsXCLiiLhcIjpcIiZtaW51c2Q7XCIsXCLiiJRcIjpcIiZwbHVzZG87XCIsXCLiiqFcIjpcIiZzZG90YjtcIixcIuKMn1wiOlwiJmxyY29ybmVyO1wiLFwi4oyMXCI6XCImZHJjcm9wO1wiLFwi8J2SuVwiOlwiJmRzY3I7XCIsXCLRlVwiOlwiJmRzY3k7XCIsXCLip7ZcIjpcIiZkc29sO1wiLFwixJFcIjpcIiZkc3Ryb2s7XCIsXCLii7FcIjpcIiZkdGRvdDtcIixcIuKWv1wiOlwiJnRyaWFuZ2xlZG93bjtcIixcIuKmplwiOlwiJmR3YW5nbGU7XCIsXCLRn1wiOlwiJmR6Y3k7XCIsXCLin79cIjpcIiZkemlncmFycjtcIixcIsOpXCI6XCImZWFjdXRlO1wiLFwi4qmuXCI6XCImZWFzdGVyO1wiLFwixJtcIjpcIiZlY2Fyb247XCIsXCLiiZZcIjpcIiZlcWNpcmM7XCIsXCLDqlwiOlwiJmVjaXJjO1wiLFwi4omVXCI6XCImZXFjb2xvbjtcIixcItGNXCI6XCImZWN5O1wiLFwixJdcIjpcIiZlZG90O1wiLFwi4omSXCI6XCImZmFsbGluZ2RvdHNlcTtcIixcIvCdlKJcIjpcIiZlZnI7XCIsXCLiqppcIjpcIiZlZztcIixcIsOoXCI6XCImZWdyYXZlO1wiLFwi4qqWXCI6XCImZXFzbGFudGd0cjtcIixcIuKqmFwiOlwiJmVnc2RvdDtcIixcIuKqmVwiOlwiJmVsO1wiLFwi4o+nXCI6XCImZWxpbnRlcnM7XCIsXCLihJNcIjpcIiZlbGw7XCIsXCLiqpVcIjpcIiZlcXNsYW50bGVzcztcIixcIuKql1wiOlwiJmVsc2RvdDtcIixcIsSTXCI6XCImZW1hY3I7XCIsXCLiiIVcIjpcIiZ2YXJub3RoaW5nO1wiLFwi4oCEXCI6XCImZW1zcDEzO1wiLFwi4oCFXCI6XCImZW1zcDE0O1wiLFwi4oCDXCI6XCImZW1zcDtcIixcIsWLXCI6XCImZW5nO1wiLFwi4oCCXCI6XCImZW5zcDtcIixcIsSZXCI6XCImZW9nb247XCIsXCLwnZWWXCI6XCImZW9wZjtcIixcIuKLlVwiOlwiJmVwYXI7XCIsXCLip6NcIjpcIiZlcGFyc2w7XCIsXCLiqbFcIjpcIiZlcGx1cztcIixcIs61XCI6XCImZXBzaWxvbjtcIixcIs+1XCI6XCImdmFyZXBzaWxvbjtcIixcIj1cIjpcIiZlcXVhbHM7XCIsXCLiiZ9cIjpcIiZxdWVzdGVxO1wiLFwi4qm4XCI6XCImZXF1aXZERDtcIixcIuKnpVwiOlwiJmVxdnBhcnNsO1wiLFwi4omTXCI6XCImcmlzaW5nZG90c2VxO1wiLFwi4qWxXCI6XCImZXJhcnI7XCIsXCLihK9cIjpcIiZlc2NyO1wiLFwizrdcIjpcIiZldGE7XCIsXCLDsFwiOlwiJmV0aDtcIixcIsOrXCI6XCImZXVtbDtcIixcIuKCrFwiOlwiJmV1cm87XCIsXCIhXCI6XCImZXhjbDtcIixcItGEXCI6XCImZmN5O1wiLFwi4pmAXCI6XCImZmVtYWxlO1wiLFwi76yDXCI6XCImZmZpbGlnO1wiLFwi76yAXCI6XCImZmZsaWc7XCIsXCLvrIRcIjpcIiZmZmxsaWc7XCIsXCLwnZSjXCI6XCImZmZyO1wiLFwi76yBXCI6XCImZmlsaWc7XCIsZmo6XCImZmpsaWc7XCIsXCLima1cIjpcIiZmbGF0O1wiLFwi76yCXCI6XCImZmxsaWc7XCIsXCLilrFcIjpcIiZmbHRucztcIixcIsaSXCI6XCImZm5vZjtcIixcIvCdlZdcIjpcIiZmb3BmO1wiLFwi4ouUXCI6XCImcGl0Y2hmb3JrO1wiLFwi4quZXCI6XCImZm9ya3Y7XCIsXCLiqI1cIjpcIiZmcGFydGludDtcIixcIsK9XCI6XCImaGFsZjtcIixcIuKFk1wiOlwiJmZyYWMxMztcIixcIsK8XCI6XCImZnJhYzE0O1wiLFwi4oWVXCI6XCImZnJhYzE1O1wiLFwi4oWZXCI6XCImZnJhYzE2O1wiLFwi4oWbXCI6XCImZnJhYzE4O1wiLFwi4oWUXCI6XCImZnJhYzIzO1wiLFwi4oWWXCI6XCImZnJhYzI1O1wiLFwiwr5cIjpcIiZmcmFjMzQ7XCIsXCLihZdcIjpcIiZmcmFjMzU7XCIsXCLihZxcIjpcIiZmcmFjMzg7XCIsXCLihZhcIjpcIiZmcmFjNDU7XCIsXCLihZpcIjpcIiZmcmFjNTY7XCIsXCLihZ1cIjpcIiZmcmFjNTg7XCIsXCLihZ5cIjpcIiZmcmFjNzg7XCIsXCLigYRcIjpcIiZmcmFzbDtcIixcIuKMolwiOlwiJnNmcm93bjtcIixcIvCdkrtcIjpcIiZmc2NyO1wiLFwi4qqMXCI6XCImZ3RyZXFxbGVzcztcIixcIse1XCI6XCImZ2FjdXRlO1wiLFwizrNcIjpcIiZnYW1tYTtcIixcIuKqhlwiOlwiJmd0cmFwcHJveDtcIixcIsSfXCI6XCImZ2JyZXZlO1wiLFwixJ1cIjpcIiZnY2lyYztcIixcItCzXCI6XCImZ2N5O1wiLFwixKFcIjpcIiZnZG90O1wiLFwi4qqpXCI6XCImZ2VzY2M7XCIsXCLiqoBcIjpcIiZnZXNkb3Q7XCIsXCLiqoJcIjpcIiZnZXNkb3RvO1wiLFwi4qqEXCI6XCImZ2VzZG90b2w7XCIsXCLii5vvuIBcIjpcIiZnZXNsO1wiLFwi4qqUXCI6XCImZ2VzbGVzO1wiLFwi8J2UpFwiOlwiJmdmcjtcIixcIuKEt1wiOlwiJmdpbWVsO1wiLFwi0ZNcIjpcIiZnamN5O1wiLFwi4qqSXCI6XCImZ2xFO1wiLFwi4qqlXCI6XCImZ2xhO1wiLFwi4qqkXCI6XCImZ2xqO1wiLFwi4ompXCI6XCImZ25lcXE7XCIsXCLiqopcIjpcIiZnbmFwcHJveDtcIixcIuKqiFwiOlwiJmduZXE7XCIsXCLii6dcIjpcIiZnbnNpbTtcIixcIvCdlZhcIjpcIiZnb3BmO1wiLFwi4oSKXCI6XCImZ3NjcjtcIixcIuKqjlwiOlwiJmdzaW1lO1wiLFwi4qqQXCI6XCImZ3NpbWw7XCIsXCLiqqdcIjpcIiZndGNjO1wiLFwi4qm6XCI6XCImZ3RjaXI7XCIsXCLii5dcIjpcIiZndHJkb3Q7XCIsXCLippVcIjpcIiZndGxQYXI7XCIsXCLiqbxcIjpcIiZndHF1ZXN0O1wiLFwi4qW4XCI6XCImZ3RyYXJyO1wiLFwi4omp77iAXCI6XCImZ3ZuRTtcIixcItGKXCI6XCImaGFyZGN5O1wiLFwi4qWIXCI6XCImaGFycmNpcjtcIixcIuKGrVwiOlwiJmxlZnRyaWdodHNxdWlnYXJyb3c7XCIsXCLihI9cIjpcIiZwbGFua3Y7XCIsXCLEpVwiOlwiJmhjaXJjO1wiLFwi4pmlXCI6XCImaGVhcnRzdWl0O1wiLFwi4oCmXCI6XCImbWxkcjtcIixcIuKKuVwiOlwiJmhlcmNvbjtcIixcIvCdlKVcIjpcIiZoZnI7XCIsXCLipKVcIjpcIiZzZWFyaGs7XCIsXCLipKZcIjpcIiZzd2FyaGs7XCIsXCLih79cIjpcIiZob2FycjtcIixcIuKIu1wiOlwiJmhvbXRodDtcIixcIuKGqVwiOlwiJmxhcnJoaztcIixcIuKGqlwiOlwiJnJhcnJoaztcIixcIvCdlZlcIjpcIiZob3BmO1wiLFwi4oCVXCI6XCImaG9yYmFyO1wiLFwi8J2SvVwiOlwiJmhzY3I7XCIsXCLEp1wiOlwiJmhzdHJvaztcIixcIuKBg1wiOlwiJmh5YnVsbDtcIixcIsOtXCI6XCImaWFjdXRlO1wiLFwiw65cIjpcIiZpY2lyYztcIixcItC4XCI6XCImaWN5O1wiLFwi0LVcIjpcIiZpZWN5O1wiLFwiwqFcIjpcIiZpZXhjbDtcIixcIvCdlKZcIjpcIiZpZnI7XCIsXCLDrFwiOlwiJmlncmF2ZTtcIixcIuKojFwiOlwiJnFpbnQ7XCIsXCLiiK1cIjpcIiZ0aW50O1wiLFwi4qecXCI6XCImaWluZmluO1wiLFwi4oSpXCI6XCImaWlvdGE7XCIsXCLEs1wiOlwiJmlqbGlnO1wiLFwixKtcIjpcIiZpbWFjcjtcIixcIsSxXCI6XCImaW5vZG90O1wiLFwi4oq3XCI6XCImaW1vZjtcIixcIsa1XCI6XCImaW1wZWQ7XCIsXCLihIVcIjpcIiZpbmNhcmU7XCIsXCLiiJ5cIjpcIiZpbmZpbjtcIixcIuKnnVwiOlwiJmluZmludGllO1wiLFwi4oq6XCI6XCImaW50ZXJjYWw7XCIsXCLiqJdcIjpcIiZpbnRsYXJoaztcIixcIuKovFwiOlwiJmlwcm9kO1wiLFwi0ZFcIjpcIiZpb2N5O1wiLFwixK9cIjpcIiZpb2dvbjtcIixcIvCdlZpcIjpcIiZpb3BmO1wiLFwizrlcIjpcIiZpb3RhO1wiLFwiwr9cIjpcIiZpcXVlc3Q7XCIsXCLwnZK+XCI6XCImaXNjcjtcIixcIuKLuVwiOlwiJmlzaW5FO1wiLFwi4ou1XCI6XCImaXNpbmRvdDtcIixcIuKLtFwiOlwiJmlzaW5zO1wiLFwi4ouzXCI6XCImaXNpbnN2O1wiLFwixKlcIjpcIiZpdGlsZGU7XCIsXCLRllwiOlwiJml1a2N5O1wiLFwiw69cIjpcIiZpdW1sO1wiLFwixLVcIjpcIiZqY2lyYztcIixcItC5XCI6XCImamN5O1wiLFwi8J2Up1wiOlwiJmpmcjtcIixcIsi3XCI6XCImam1hdGg7XCIsXCLwnZWbXCI6XCImam9wZjtcIixcIvCdkr9cIjpcIiZqc2NyO1wiLFwi0ZhcIjpcIiZqc2VyY3k7XCIsXCLRlFwiOlwiJmp1a2N5O1wiLFwizrpcIjpcIiZrYXBwYTtcIixcIs+wXCI6XCImdmFya2FwcGE7XCIsXCLEt1wiOlwiJmtjZWRpbDtcIixcItC6XCI6XCIma2N5O1wiLFwi8J2UqFwiOlwiJmtmcjtcIixcIsS4XCI6XCIma2dyZWVuO1wiLFwi0YVcIjpcIiZraGN5O1wiLFwi0ZxcIjpcIiZramN5O1wiLFwi8J2VnFwiOlwiJmtvcGY7XCIsXCLwnZOAXCI6XCIma3NjcjtcIixcIuKkm1wiOlwiJmxBdGFpbDtcIixcIuKkjlwiOlwiJmxCYXJyO1wiLFwi4qqLXCI6XCImbGVzc2VxcWd0cjtcIixcIuKlolwiOlwiJmxIYXI7XCIsXCLEulwiOlwiJmxhY3V0ZTtcIixcIuKmtFwiOlwiJmxhZW1wdHl2O1wiLFwizrtcIjpcIiZsYW1iZGE7XCIsXCLippFcIjpcIiZsYW5nZDtcIixcIuKqhVwiOlwiJmxlc3NhcHByb3g7XCIsXCLCq1wiOlwiJmxhcXVvO1wiLFwi4qSfXCI6XCImbGFycmJmcztcIixcIuKknVwiOlwiJmxhcnJmcztcIixcIuKGq1wiOlwiJmxvb3BhcnJvd2xlZnQ7XCIsXCLipLlcIjpcIiZsYXJycGw7XCIsXCLipbNcIjpcIiZsYXJyc2ltO1wiLFwi4oaiXCI6XCImbGVmdGFycm93dGFpbDtcIixcIuKqq1wiOlwiJmxhdDtcIixcIuKkmVwiOlwiJmxhdGFpbDtcIixcIuKqrVwiOlwiJmxhdGU7XCIsXCLiqq3vuIBcIjpcIiZsYXRlcztcIixcIuKkjFwiOlwiJmxiYXJyO1wiLFwi4p2yXCI6XCImbGJicms7XCIsXCJ7XCI6XCImbGN1YjtcIixcIltcIjpcIiZsc3FiO1wiLFwi4qaLXCI6XCImbGJya2U7XCIsXCLipo9cIjpcIiZsYnJrc2xkO1wiLFwi4qaNXCI6XCImbGJya3NsdTtcIixcIsS+XCI6XCImbGNhcm9uO1wiLFwixLxcIjpcIiZsY2VkaWw7XCIsXCLQu1wiOlwiJmxjeTtcIixcIuKktlwiOlwiJmxkY2E7XCIsXCLipadcIjpcIiZsZHJkaGFyO1wiLFwi4qWLXCI6XCImbGRydXNoYXI7XCIsXCLihrJcIjpcIiZsZHNoO1wiLFwi4omkXCI6XCImbGVxO1wiLFwi4oeHXCI6XCImbGxhcnI7XCIsXCLii4tcIjpcIiZsdGhyZWU7XCIsXCLiqqhcIjpcIiZsZXNjYztcIixcIuKpv1wiOlwiJmxlc2RvdDtcIixcIuKqgVwiOlwiJmxlc2RvdG87XCIsXCLiqoNcIjpcIiZsZXNkb3RvcjtcIixcIuKLmu+4gFwiOlwiJmxlc2c7XCIsXCLiqpNcIjpcIiZsZXNnZXM7XCIsXCLii5ZcIjpcIiZsdGRvdDtcIixcIuKlvFwiOlwiJmxmaXNodDtcIixcIvCdlKlcIjpcIiZsZnI7XCIsXCLiqpFcIjpcIiZsZ0U7XCIsXCLipapcIjpcIiZsaGFydWw7XCIsXCLiloRcIjpcIiZsaGJsaztcIixcItGZXCI6XCImbGpjeTtcIixcIuKlq1wiOlwiJmxsaGFyZDtcIixcIuKXulwiOlwiJmxsdHJpO1wiLFwixYBcIjpcIiZsbWlkb3Q7XCIsXCLijrBcIjpcIiZsbW91c3RhY2hlO1wiLFwi4omoXCI6XCImbG5lcXE7XCIsXCLiqolcIjpcIiZsbmFwcHJveDtcIixcIuKqh1wiOlwiJmxuZXE7XCIsXCLii6ZcIjpcIiZsbnNpbTtcIixcIuKfrFwiOlwiJmxvYW5nO1wiLFwi4oe9XCI6XCImbG9hcnI7XCIsXCLin7xcIjpcIiZ4bWFwO1wiLFwi4oasXCI6XCImcmFycmxwO1wiLFwi4qaFXCI6XCImbG9wYXI7XCIsXCLwnZWdXCI6XCImbG9wZjtcIixcIuKorVwiOlwiJmxvcGx1cztcIixcIuKotFwiOlwiJmxvdGltZXM7XCIsXCLiiJdcIjpcIiZsb3dhc3Q7XCIsXCLil4pcIjpcIiZsb3plbmdlO1wiLFwiKFwiOlwiJmxwYXI7XCIsXCLippNcIjpcIiZscGFybHQ7XCIsXCLipa1cIjpcIiZscmhhcmQ7XCIsXCLigI5cIjpcIiZscm07XCIsXCLiir9cIjpcIiZscnRyaTtcIixcIuKAuVwiOlwiJmxzYXF1bztcIixcIvCdk4FcIjpcIiZsc2NyO1wiLFwi4qqNXCI6XCImbHNpbWU7XCIsXCLiqo9cIjpcIiZsc2ltZztcIixcIuKAmlwiOlwiJnNicXVvO1wiLFwixYJcIjpcIiZsc3Ryb2s7XCIsXCLiqqZcIjpcIiZsdGNjO1wiLFwi4qm5XCI6XCImbHRjaXI7XCIsXCLii4lcIjpcIiZsdGltZXM7XCIsXCLipbZcIjpcIiZsdGxhcnI7XCIsXCLiqbtcIjpcIiZsdHF1ZXN0O1wiLFwi4qaWXCI6XCImbHRyUGFyO1wiLFwi4peDXCI6XCImdHJpYW5nbGVsZWZ0O1wiLFwi4qWKXCI6XCImbHVyZHNoYXI7XCIsXCLipaZcIjpcIiZsdXJ1aGFyO1wiLFwi4omo77iAXCI6XCImbHZuRTtcIixcIuKIulwiOlwiJm1ERG90O1wiLFwiwq9cIjpcIiZzdHJucztcIixcIuKZglwiOlwiJm1hbGU7XCIsXCLinKBcIjpcIiZtYWx0ZXNlO1wiLFwi4pauXCI6XCImbWFya2VyO1wiLFwi4qipXCI6XCImbWNvbW1hO1wiLFwi0LxcIjpcIiZtY3k7XCIsXCLigJRcIjpcIiZtZGFzaDtcIixcIvCdlKpcIjpcIiZtZnI7XCIsXCLihKdcIjpcIiZtaG87XCIsXCLCtVwiOlwiJm1pY3JvO1wiLFwi4quwXCI6XCImbWlkY2lyO1wiLFwi4oiSXCI6XCImbWludXM7XCIsXCLiqKpcIjpcIiZtaW51c2R1O1wiLFwi4qubXCI6XCImbWxjcDtcIixcIuKKp1wiOlwiJm1vZGVscztcIixcIvCdlZ5cIjpcIiZtb3BmO1wiLFwi8J2TglwiOlwiJm1zY3I7XCIsXCLOvFwiOlwiJm11O1wiLFwi4oq4XCI6XCImbXVtYXA7XCIsXCLii5nMuFwiOlwiJm5HZztcIixcIuKJq+KDklwiOlwiJm5HdDtcIixcIuKHjVwiOlwiJm5sQXJyO1wiLFwi4oeOXCI6XCImbmhBcnI7XCIsXCLii5jMuFwiOlwiJm5MbDtcIixcIuKJquKDklwiOlwiJm5MdDtcIixcIuKHj1wiOlwiJm5yQXJyO1wiLFwi4oqvXCI6XCImblZEYXNoO1wiLFwi4oquXCI6XCImblZkYXNoO1wiLFwixYRcIjpcIiZuYWN1dGU7XCIsXCLiiKDig5JcIjpcIiZuYW5nO1wiLFwi4qmwzLhcIjpcIiZuYXBFO1wiLFwi4omLzLhcIjpcIiZuYXBpZDtcIixcIsWJXCI6XCImbmFwb3M7XCIsXCLima5cIjpcIiZuYXR1cmFsO1wiLFwi4qmDXCI6XCImbmNhcDtcIixcIsWIXCI6XCImbmNhcm9uO1wiLFwixYZcIjpcIiZuY2VkaWw7XCIsXCLiqa3MuFwiOlwiJm5jb25nZG90O1wiLFwi4qmCXCI6XCImbmN1cDtcIixcItC9XCI6XCImbmN5O1wiLFwi4oCTXCI6XCImbmRhc2g7XCIsXCLih5dcIjpcIiZuZUFycjtcIixcIuKkpFwiOlwiJm5lYXJoaztcIixcIuKJkMy4XCI6XCImbmVkb3Q7XCIsXCLipKhcIjpcIiZ0b2VhO1wiLFwi8J2Uq1wiOlwiJm5mcjtcIixcIuKGrlwiOlwiJm5sZWZ0cmlnaHRhcnJvdztcIixcIuKrslwiOlwiJm5ocGFyO1wiLFwi4ou8XCI6XCImbmlzO1wiLFwi4ou6XCI6XCImbmlzZDtcIixcItGaXCI6XCImbmpjeTtcIixcIuKJpsy4XCI6XCImbmxlcXE7XCIsXCLihppcIjpcIiZubGVmdGFycm93O1wiLFwi4oClXCI6XCImbmxkcjtcIixcIvCdlZ9cIjpcIiZub3BmO1wiLFwiwqxcIjpcIiZub3Q7XCIsXCLii7nMuFwiOlwiJm5vdGluRTtcIixcIuKLtcy4XCI6XCImbm90aW5kb3Q7XCIsXCLii7dcIjpcIiZub3RpbnZiO1wiLFwi4ou2XCI6XCImbm90aW52YztcIixcIuKLvlwiOlwiJm5vdG5pdmI7XCIsXCLii71cIjpcIiZub3RuaXZjO1wiLFwi4qu94oOlXCI6XCImbnBhcnNsO1wiLFwi4oiCzLhcIjpcIiZucGFydDtcIixcIuKolFwiOlwiJm5wb2xpbnQ7XCIsXCLihptcIjpcIiZucmlnaHRhcnJvdztcIixcIuKks8y4XCI6XCImbnJhcnJjO1wiLFwi4oadzLhcIjpcIiZucmFycnc7XCIsXCLwnZODXCI6XCImbnNjcjtcIixcIuKKhFwiOlwiJm5zdWI7XCIsXCLiq4XMuFwiOlwiJm5zdWJzZXRlcXE7XCIsXCLiioVcIjpcIiZuc3VwO1wiLFwi4quGzLhcIjpcIiZuc3Vwc2V0ZXFxO1wiLFwiw7FcIjpcIiZudGlsZGU7XCIsXCLOvVwiOlwiJm51O1wiLFwiI1wiOlwiJm51bTtcIixcIuKEllwiOlwiJm51bWVybztcIixcIuKAh1wiOlwiJm51bXNwO1wiLFwi4oqtXCI6XCImbnZEYXNoO1wiLFwi4qSEXCI6XCImbnZIYXJyO1wiLFwi4omN4oOSXCI6XCImbnZhcDtcIixcIuKKrFwiOlwiJm52ZGFzaDtcIixcIuKJpeKDklwiOlwiJm52Z2U7XCIsXCI+4oOSXCI6XCImbnZndDtcIixcIuKnnlwiOlwiJm52aW5maW47XCIsXCLipIJcIjpcIiZudmxBcnI7XCIsXCLiiaTig5JcIjpcIiZudmxlO1wiLFwiPOKDklwiOlwiJm52bHQ7XCIsXCLiirTig5JcIjpcIiZudmx0cmllO1wiLFwi4qSDXCI6XCImbnZyQXJyO1wiLFwi4oq14oOSXCI6XCImbnZydHJpZTtcIixcIuKIvOKDklwiOlwiJm52c2ltO1wiLFwi4oeWXCI6XCImbndBcnI7XCIsXCLipKNcIjpcIiZud2FyaGs7XCIsXCLipKdcIjpcIiZud25lYXI7XCIsXCLDs1wiOlwiJm9hY3V0ZTtcIixcIsO0XCI6XCImb2NpcmM7XCIsXCLQvlwiOlwiJm9jeTtcIixcIsWRXCI6XCImb2RibGFjO1wiLFwi4qi4XCI6XCImb2RpdjtcIixcIuKmvFwiOlwiJm9kc29sZDtcIixcIsWTXCI6XCImb2VsaWc7XCIsXCLipr9cIjpcIiZvZmNpcjtcIixcIvCdlKxcIjpcIiZvZnI7XCIsXCLLm1wiOlwiJm9nb247XCIsXCLDslwiOlwiJm9ncmF2ZTtcIixcIuKngVwiOlwiJm9ndDtcIixcIuKmtVwiOlwiJm9oYmFyO1wiLFwi4qa+XCI6XCImb2xjaXI7XCIsXCLiprtcIjpcIiZvbGNyb3NzO1wiLFwi4qeAXCI6XCImb2x0O1wiLFwixY1cIjpcIiZvbWFjcjtcIixcIs+JXCI6XCImb21lZ2E7XCIsXCLOv1wiOlwiJm9taWNyb247XCIsXCLiprZcIjpcIiZvbWlkO1wiLFwi8J2VoFwiOlwiJm9vcGY7XCIsXCLiprdcIjpcIiZvcGFyO1wiLFwi4qa5XCI6XCImb3BlcnA7XCIsXCLiiKhcIjpcIiZ2ZWU7XCIsXCLiqZ1cIjpcIiZvcmQ7XCIsXCLihLRcIjpcIiZvc2NyO1wiLFwiwqpcIjpcIiZvcmRmO1wiLFwiwrpcIjpcIiZvcmRtO1wiLFwi4oq2XCI6XCImb3JpZ29mO1wiLFwi4qmWXCI6XCImb3JvcjtcIixcIuKpl1wiOlwiJm9yc2xvcGU7XCIsXCLiqZtcIjpcIiZvcnY7XCIsXCLDuFwiOlwiJm9zbGFzaDtcIixcIuKKmFwiOlwiJm9zb2w7XCIsXCLDtVwiOlwiJm90aWxkZTtcIixcIuKotlwiOlwiJm90aW1lc2FzO1wiLFwiw7ZcIjpcIiZvdW1sO1wiLFwi4oy9XCI6XCImb3ZiYXI7XCIsXCLCtlwiOlwiJnBhcmE7XCIsXCLiq7NcIjpcIiZwYXJzaW07XCIsXCLiq71cIjpcIiZwYXJzbDtcIixcItC/XCI6XCImcGN5O1wiLFwiJVwiOlwiJnBlcmNudDtcIixcIi5cIjpcIiZwZXJpb2Q7XCIsXCLigLBcIjpcIiZwZXJtaWw7XCIsXCLigLFcIjpcIiZwZXJ0ZW5rO1wiLFwi8J2UrVwiOlwiJnBmcjtcIixcIs+GXCI6XCImcGhpO1wiLFwiz5VcIjpcIiZ2YXJwaGk7XCIsXCLimI5cIjpcIiZwaG9uZTtcIixcIs+AXCI6XCImcGk7XCIsXCLPllwiOlwiJnZhcnBpO1wiLFwi4oSOXCI6XCImcGxhbmNraDtcIixcIitcIjpcIiZwbHVzO1wiLFwi4qijXCI6XCImcGx1c2FjaXI7XCIsXCLiqKJcIjpcIiZwbHVzY2lyO1wiLFwi4qilXCI6XCImcGx1c2R1O1wiLFwi4qmyXCI6XCImcGx1c2U7XCIsXCLiqKZcIjpcIiZwbHVzc2ltO1wiLFwi4qinXCI6XCImcGx1c3R3bztcIixcIuKolVwiOlwiJnBvaW50aW50O1wiLFwi8J2VoVwiOlwiJnBvcGY7XCIsXCLCo1wiOlwiJnBvdW5kO1wiLFwi4qqzXCI6XCImcHJFO1wiLFwi4qq3XCI6XCImcHJlY2FwcHJveDtcIixcIuKquVwiOlwiJnBybmFwO1wiLFwi4qq1XCI6XCImcHJuRTtcIixcIuKLqFwiOlwiJnBybnNpbTtcIixcIuKAslwiOlwiJnByaW1lO1wiLFwi4oyuXCI6XCImcHJvZmFsYXI7XCIsXCLijJJcIjpcIiZwcm9mbGluZTtcIixcIuKMk1wiOlwiJnByb2ZzdXJmO1wiLFwi4oqwXCI6XCImcHJ1cmVsO1wiLFwi8J2ThVwiOlwiJnBzY3I7XCIsXCLPiFwiOlwiJnBzaTtcIixcIuKAiFwiOlwiJnB1bmNzcDtcIixcIvCdlK5cIjpcIiZxZnI7XCIsXCLwnZWiXCI6XCImcW9wZjtcIixcIuKBl1wiOlwiJnFwcmltZTtcIixcIvCdk4ZcIjpcIiZxc2NyO1wiLFwi4qiWXCI6XCImcXVhdGludDtcIixcIj9cIjpcIiZxdWVzdDtcIixcIuKknFwiOlwiJnJBdGFpbDtcIixcIuKlpFwiOlwiJnJIYXI7XCIsXCLiiL3MsVwiOlwiJnJhY2U7XCIsXCLFlVwiOlwiJnJhY3V0ZTtcIixcIuKms1wiOlwiJnJhZW1wdHl2O1wiLFwi4qaSXCI6XCImcmFuZ2Q7XCIsXCLipqVcIjpcIiZyYW5nZTtcIixcIsK7XCI6XCImcmFxdW87XCIsXCLipbVcIjpcIiZyYXJyYXA7XCIsXCLipKBcIjpcIiZyYXJyYmZzO1wiLFwi4qSzXCI6XCImcmFycmM7XCIsXCLipJ5cIjpcIiZyYXJyZnM7XCIsXCLipYVcIjpcIiZyYXJycGw7XCIsXCLipbRcIjpcIiZyYXJyc2ltO1wiLFwi4oajXCI6XCImcmlnaHRhcnJvd3RhaWw7XCIsXCLihp1cIjpcIiZyaWdodHNxdWlnYXJyb3c7XCIsXCLipJpcIjpcIiZyYXRhaWw7XCIsXCLiiLZcIjpcIiZyYXRpbztcIixcIuKds1wiOlwiJnJiYnJrO1wiLFwifVwiOlwiJnJjdWI7XCIsXCJdXCI6XCImcnNxYjtcIixcIuKmjFwiOlwiJnJicmtlO1wiLFwi4qaOXCI6XCImcmJya3NsZDtcIixcIuKmkFwiOlwiJnJicmtzbHU7XCIsXCLFmVwiOlwiJnJjYXJvbjtcIixcIsWXXCI6XCImcmNlZGlsO1wiLFwi0YBcIjpcIiZyY3k7XCIsXCLipLdcIjpcIiZyZGNhO1wiLFwi4qWpXCI6XCImcmRsZGhhcjtcIixcIuKGs1wiOlwiJnJkc2g7XCIsXCLilq1cIjpcIiZyZWN0O1wiLFwi4qW9XCI6XCImcmZpc2h0O1wiLFwi8J2Ur1wiOlwiJnJmcjtcIixcIuKlrFwiOlwiJnJoYXJ1bDtcIixcIs+BXCI6XCImcmhvO1wiLFwiz7FcIjpcIiZ2YXJyaG87XCIsXCLih4lcIjpcIiZycmFycjtcIixcIuKLjFwiOlwiJnJ0aHJlZTtcIixcIsuaXCI6XCImcmluZztcIixcIuKAj1wiOlwiJnJsbTtcIixcIuKOsVwiOlwiJnJtb3VzdGFjaGU7XCIsXCLiq65cIjpcIiZybm1pZDtcIixcIuKfrVwiOlwiJnJvYW5nO1wiLFwi4oe+XCI6XCImcm9hcnI7XCIsXCLipoZcIjpcIiZyb3BhcjtcIixcIvCdlaNcIjpcIiZyb3BmO1wiLFwi4qiuXCI6XCImcm9wbHVzO1wiLFwi4qi1XCI6XCImcm90aW1lcztcIixcIilcIjpcIiZycGFyO1wiLFwi4qaUXCI6XCImcnBhcmd0O1wiLFwi4qiSXCI6XCImcnBwb2xpbnQ7XCIsXCLigLpcIjpcIiZyc2FxdW87XCIsXCLwnZOHXCI6XCImcnNjcjtcIixcIuKLilwiOlwiJnJ0aW1lcztcIixcIuKWuVwiOlwiJnRyaWFuZ2xlcmlnaHQ7XCIsXCLip45cIjpcIiZydHJpbHRyaTtcIixcIuKlqFwiOlwiJnJ1bHVoYXI7XCIsXCLihJ5cIjpcIiZyeDtcIixcIsWbXCI6XCImc2FjdXRlO1wiLFwi4qq0XCI6XCImc2NFO1wiLFwi4qq4XCI6XCImc3VjY2FwcHJveDtcIixcIsWhXCI6XCImc2Nhcm9uO1wiLFwixZ9cIjpcIiZzY2VkaWw7XCIsXCLFnVwiOlwiJnNjaXJjO1wiLFwi4qq2XCI6XCImc3VjY25lcXE7XCIsXCLiqrpcIjpcIiZzdWNjbmFwcHJveDtcIixcIuKLqVwiOlwiJnN1Y2Nuc2ltO1wiLFwi4qiTXCI6XCImc2Nwb2xpbnQ7XCIsXCLRgVwiOlwiJnNjeTtcIixcIuKLhVwiOlwiJnNkb3Q7XCIsXCLiqaZcIjpcIiZzZG90ZTtcIixcIuKHmFwiOlwiJnNlQXJyO1wiLFwiwqdcIjpcIiZzZWN0O1wiLFwiO1wiOlwiJnNlbWk7XCIsXCLipKlcIjpcIiZ0b3NhO1wiLFwi4py2XCI6XCImc2V4dDtcIixcIvCdlLBcIjpcIiZzZnI7XCIsXCLima9cIjpcIiZzaGFycDtcIixcItGJXCI6XCImc2hjaGN5O1wiLFwi0YhcIjpcIiZzaGN5O1wiLFwiwq1cIjpcIiZzaHk7XCIsXCLPg1wiOlwiJnNpZ21hO1wiLFwiz4JcIjpcIiZ2YXJzaWdtYTtcIixcIuKpqlwiOlwiJnNpbWRvdDtcIixcIuKqnlwiOlwiJnNpbWc7XCIsXCLiqqBcIjpcIiZzaW1nRTtcIixcIuKqnVwiOlwiJnNpbWw7XCIsXCLiqp9cIjpcIiZzaW1sRTtcIixcIuKJhlwiOlwiJnNpbW5lO1wiLFwi4qikXCI6XCImc2ltcGx1cztcIixcIuKlslwiOlwiJnNpbXJhcnI7XCIsXCLiqLNcIjpcIiZzbWFzaHA7XCIsXCLip6RcIjpcIiZzbWVwYXJzbDtcIixcIuKMo1wiOlwiJnNzbWlsZTtcIixcIuKqqlwiOlwiJnNtdDtcIixcIuKqrFwiOlwiJnNtdGU7XCIsXCLiqqzvuIBcIjpcIiZzbXRlcztcIixcItGMXCI6XCImc29mdGN5O1wiLFwiL1wiOlwiJnNvbDtcIixcIuKnhFwiOlwiJnNvbGI7XCIsXCLijL9cIjpcIiZzb2xiYXI7XCIsXCLwnZWkXCI6XCImc29wZjtcIixcIuKZoFwiOlwiJnNwYWRlc3VpdDtcIixcIuKKk++4gFwiOlwiJnNxY2FwcztcIixcIuKKlO+4gFwiOlwiJnNxY3VwcztcIixcIvCdk4hcIjpcIiZzc2NyO1wiLFwi4piGXCI6XCImc3RhcjtcIixcIuKKglwiOlwiJnN1YnNldDtcIixcIuKrhVwiOlwiJnN1YnNldGVxcTtcIixcIuKqvVwiOlwiJnN1YmRvdDtcIixcIuKrg1wiOlwiJnN1YmVkb3Q7XCIsXCLiq4FcIjpcIiZzdWJtdWx0O1wiLFwi4quLXCI6XCImc3Vic2V0bmVxcTtcIixcIuKKilwiOlwiJnN1YnNldG5lcTtcIixcIuKqv1wiOlwiJnN1YnBsdXM7XCIsXCLipblcIjpcIiZzdWJyYXJyO1wiLFwi4quHXCI6XCImc3Vic2ltO1wiLFwi4quVXCI6XCImc3Vic3ViO1wiLFwi4quTXCI6XCImc3Vic3VwO1wiLFwi4pmqXCI6XCImc3VuZztcIixcIsK5XCI6XCImc3VwMTtcIixcIsKyXCI6XCImc3VwMjtcIixcIsKzXCI6XCImc3VwMztcIixcIuKrhlwiOlwiJnN1cHNldGVxcTtcIixcIuKqvlwiOlwiJnN1cGRvdDtcIixcIuKrmFwiOlwiJnN1cGRzdWI7XCIsXCLiq4RcIjpcIiZzdXBlZG90O1wiLFwi4p+JXCI6XCImc3VwaHNvbDtcIixcIuKrl1wiOlwiJnN1cGhzdWI7XCIsXCLipbtcIjpcIiZzdXBsYXJyO1wiLFwi4quCXCI6XCImc3VwbXVsdDtcIixcIuKrjFwiOlwiJnN1cHNldG5lcXE7XCIsXCLiiotcIjpcIiZzdXBzZXRuZXE7XCIsXCLiq4BcIjpcIiZzdXBwbHVzO1wiLFwi4quIXCI6XCImc3Vwc2ltO1wiLFwi4quUXCI6XCImc3Vwc3ViO1wiLFwi4quWXCI6XCImc3Vwc3VwO1wiLFwi4oeZXCI6XCImc3dBcnI7XCIsXCLipKpcIjpcIiZzd253YXI7XCIsXCLDn1wiOlwiJnN6bGlnO1wiLFwi4oyWXCI6XCImdGFyZ2V0O1wiLFwiz4RcIjpcIiZ0YXU7XCIsXCLFpVwiOlwiJnRjYXJvbjtcIixcIsWjXCI6XCImdGNlZGlsO1wiLFwi0YJcIjpcIiZ0Y3k7XCIsXCLijJVcIjpcIiZ0ZWxyZWM7XCIsXCLwnZSxXCI6XCImdGZyO1wiLFwizrhcIjpcIiZ0aGV0YTtcIixcIs+RXCI6XCImdmFydGhldGE7XCIsXCLDvlwiOlwiJnRob3JuO1wiLFwiw5dcIjpcIiZ0aW1lcztcIixcIuKosVwiOlwiJnRpbWVzYmFyO1wiLFwi4qiwXCI6XCImdGltZXNkO1wiLFwi4oy2XCI6XCImdG9wYm90O1wiLFwi4quxXCI6XCImdG9wY2lyO1wiLFwi8J2VpVwiOlwiJnRvcGY7XCIsXCLiq5pcIjpcIiZ0b3Bmb3JrO1wiLFwi4oC0XCI6XCImdHByaW1lO1wiLFwi4pa1XCI6XCImdXRyaTtcIixcIuKJnFwiOlwiJnRyaWU7XCIsXCLil6xcIjpcIiZ0cmlkb3Q7XCIsXCLiqLpcIjpcIiZ0cmltaW51cztcIixcIuKouVwiOlwiJnRyaXBsdXM7XCIsXCLip41cIjpcIiZ0cmlzYjtcIixcIuKou1wiOlwiJnRyaXRpbWU7XCIsXCLij6JcIjpcIiZ0cnBleml1bTtcIixcIvCdk4lcIjpcIiZ0c2NyO1wiLFwi0YZcIjpcIiZ0c2N5O1wiLFwi0ZtcIjpcIiZ0c2hjeTtcIixcIsWnXCI6XCImdHN0cm9rO1wiLFwi4qWjXCI6XCImdUhhcjtcIixcIsO6XCI6XCImdWFjdXRlO1wiLFwi0Z5cIjpcIiZ1YnJjeTtcIixcIsWtXCI6XCImdWJyZXZlO1wiLFwiw7tcIjpcIiZ1Y2lyYztcIixcItGDXCI6XCImdWN5O1wiLFwixbFcIjpcIiZ1ZGJsYWM7XCIsXCLipb5cIjpcIiZ1ZmlzaHQ7XCIsXCLwnZSyXCI6XCImdWZyO1wiLFwiw7lcIjpcIiZ1Z3JhdmU7XCIsXCLiloBcIjpcIiZ1aGJsaztcIixcIuKMnFwiOlwiJnVsY29ybmVyO1wiLFwi4oyPXCI6XCImdWxjcm9wO1wiLFwi4pe4XCI6XCImdWx0cmk7XCIsXCLFq1wiOlwiJnVtYWNyO1wiLFwixbNcIjpcIiZ1b2dvbjtcIixcIvCdlaZcIjpcIiZ1b3BmO1wiLFwiz4VcIjpcIiZ1cHNpbG9uO1wiLFwi4oeIXCI6XCImdXVhcnI7XCIsXCLijJ1cIjpcIiZ1cmNvcm5lcjtcIixcIuKMjlwiOlwiJnVyY3JvcDtcIixcIsWvXCI6XCImdXJpbmc7XCIsXCLil7lcIjpcIiZ1cnRyaTtcIixcIvCdk4pcIjpcIiZ1c2NyO1wiLFwi4ouwXCI6XCImdXRkb3Q7XCIsXCLFqVwiOlwiJnV0aWxkZTtcIixcIsO8XCI6XCImdXVtbDtcIixcIuKmp1wiOlwiJnV3YW5nbGU7XCIsXCLiq6hcIjpcIiZ2QmFyO1wiLFwi4qupXCI6XCImdkJhcnY7XCIsXCLippxcIjpcIiZ2YW5ncnQ7XCIsXCLiiorvuIBcIjpcIiZ2c3VibmU7XCIsXCLiq4vvuIBcIjpcIiZ2c3VibkU7XCIsXCLiiovvuIBcIjpcIiZ2c3VwbmU7XCIsXCLiq4zvuIBcIjpcIiZ2c3VwbkU7XCIsXCLQslwiOlwiJnZjeTtcIixcIuKKu1wiOlwiJnZlZWJhcjtcIixcIuKJmlwiOlwiJnZlZWVxO1wiLFwi4ouuXCI6XCImdmVsbGlwO1wiLFwi8J2Us1wiOlwiJnZmcjtcIixcIvCdladcIjpcIiZ2b3BmO1wiLFwi8J2Ti1wiOlwiJnZzY3I7XCIsXCLipppcIjpcIiZ2emlnemFnO1wiLFwixbVcIjpcIiZ3Y2lyYztcIixcIuKpn1wiOlwiJndlZGJhcjtcIixcIuKJmVwiOlwiJndlZGdlcTtcIixcIuKEmFwiOlwiJndwO1wiLFwi8J2UtFwiOlwiJndmcjtcIixcIvCdlahcIjpcIiZ3b3BmO1wiLFwi8J2TjFwiOlwiJndzY3I7XCIsXCLwnZS1XCI6XCImeGZyO1wiLFwizr5cIjpcIiZ4aTtcIixcIuKLu1wiOlwiJnhuaXM7XCIsXCLwnZWpXCI6XCImeG9wZjtcIixcIvCdk41cIjpcIiZ4c2NyO1wiLFwiw71cIjpcIiZ5YWN1dGU7XCIsXCLRj1wiOlwiJnlhY3k7XCIsXCLFt1wiOlwiJnljaXJjO1wiLFwi0YtcIjpcIiZ5Y3k7XCIsXCLCpVwiOlwiJnllbjtcIixcIvCdlLZcIjpcIiZ5ZnI7XCIsXCLRl1wiOlwiJnlpY3k7XCIsXCLwnZWqXCI6XCImeW9wZjtcIixcIvCdk45cIjpcIiZ5c2NyO1wiLFwi0Y5cIjpcIiZ5dWN5O1wiLFwiw79cIjpcIiZ5dW1sO1wiLFwixbpcIjpcIiZ6YWN1dGU7XCIsXCLFvlwiOlwiJnpjYXJvbjtcIixcItC3XCI6XCImemN5O1wiLFwixbxcIjpcIiZ6ZG90O1wiLFwizrZcIjpcIiZ6ZXRhO1wiLFwi8J2Ut1wiOlwiJnpmcjtcIixcItC2XCI6XCImemhjeTtcIixcIuKHnVwiOlwiJnppZ3JhcnI7XCIsXCLwnZWrXCI6XCImem9wZjtcIixcIvCdk49cIjpcIiZ6c2NyO1wiLFwi4oCNXCI6XCImendqO1wiLFwi4oCMXCI6XCImenduajtcIn19fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/named-references.js\n");

            /***/
        }),

        /***/
        "./node_modules/html-entities/lib/numeric-unicode-map.js":
        /*!***************************************************************!*\
          !*** ./node_modules/html-entities/lib/numeric-unicode-map.js ***!
          \***************************************************************/
        /***/ ((__unused_webpack_module, exports) => {

            "use strict";
            eval("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports.numericUnicodeMap={0:65533,128:8364,130:8218,131:402,132:8222,133:8230,134:8224,135:8225,136:710,137:8240,138:352,139:8249,140:338,142:381,145:8216,146:8217,147:8220,148:8221,149:8226,150:8211,151:8212,152:732,153:8482,154:353,155:8250,156:339,158:382,159:376};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvbnVtZXJpYy11bmljb2RlLW1hcC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYSw4Q0FBMkMsQ0FBQyxXQUFXLEVBQUMsQ0FBQyx5QkFBeUIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL251bWVyaWMtdW5pY29kZS1tYXAuanM/NDAwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cyxcIl9fZXNNb2R1bGVcIix7dmFsdWU6dHJ1ZX0pO2V4cG9ydHMubnVtZXJpY1VuaWNvZGVNYXA9ezA6NjU1MzMsMTI4OjgzNjQsMTMwOjgyMTgsMTMxOjQwMiwxMzI6ODIyMiwxMzM6ODIzMCwxMzQ6ODIyNCwxMzU6ODIyNSwxMzY6NzEwLDEzNzo4MjQwLDEzODozNTIsMTM5OjgyNDksMTQwOjMzOCwxNDI6MzgxLDE0NTo4MjE2LDE0Njo4MjE3LDE0Nzo4MjIwLDE0ODo4MjIxLDE0OTo4MjI2LDE1MDo4MjExLDE1MTo4MjEyLDE1Mjo3MzIsMTUzOjg0ODIsMTU0OjM1MywxNTU6ODI1MCwxNTY6MzM5LDE1ODozODIsMTU5OjM3Nn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/numeric-unicode-map.js\n");

            /***/
        }),

        /***/
        "./node_modules/html-entities/lib/surrogate-pairs.js":
        /*!***********************************************************!*\
          !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
          \***********************************************************/
        /***/ ((__unused_webpack_module, exports) => {

            "use strict";
            eval("Object.defineProperty(exports, \"__esModule\", ({value:true}));exports.fromCodePoint=String.fromCodePoint||function(astralCodePoint){return String.fromCharCode(Math.floor((astralCodePoint-65536)/1024)+55296,(astralCodePoint-65536)%1024+56320)};exports.getCodePoint=String.prototype.codePointAt?function(input,position){return input.codePointAt(position)}:function(input,position){return(input.charCodeAt(position)-55296)*1024+input.charCodeAt(position+1)-56320+65536};exports.highSurrogateFrom=55296;exports.highSurrogateTo=56319;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhLDhDQUEyQyxDQUFDLFdBQVcsRUFBQyxDQUFDLHFCQUFxQixpREFBaUQsK0dBQStHLG9CQUFvQix1REFBdUQsbUNBQW1DLDBCQUEwQix3RkFBd0YseUJBQXlCLE9BQU8sdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvc3Vycm9nYXRlLXBhaXJzLmpzPzJmNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOnRydWV9KTtleHBvcnRzLmZyb21Db2RlUG9pbnQ9U3RyaW5nLmZyb21Db2RlUG9pbnR8fGZ1bmN0aW9uKGFzdHJhbENvZGVQb2ludCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoTWF0aC5mbG9vcigoYXN0cmFsQ29kZVBvaW50LTY1NTM2KS8xMDI0KSs1NTI5NiwoYXN0cmFsQ29kZVBvaW50LTY1NTM2KSUxMDI0KzU2MzIwKX07ZXhwb3J0cy5nZXRDb2RlUG9pbnQ9U3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdD9mdW5jdGlvbihpbnB1dCxwb3NpdGlvbil7cmV0dXJuIGlucHV0LmNvZGVQb2ludEF0KHBvc2l0aW9uKX06ZnVuY3Rpb24oaW5wdXQscG9zaXRpb24pe3JldHVybihpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKS01NTI5NikqMTAyNCtpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uKzEpLTU2MzIwKzY1NTM2fTtleHBvcnRzLmhpZ2hTdXJyb2dhdGVGcm9tPTU1Mjk2O2V4cG9ydHMuaGlnaFN1cnJvZ2F0ZVRvPTU2MzE5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/html-entities/lib/surrogate-pairs.js\n");

            /***/
        }),

        /***/
        "./node_modules/inherits/inherits_browser.js":
        /*!***************************************************!*\
          !*** ./node_modules/inherits/inherits_browser.js ***!
          \***************************************************/
        /***/ ((module) => {

            eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz8zZmI1Il0sInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits_browser.js\n");

/***/ }),

/***/ "./node_modules/js-sha3/src/sha3.js":
/*!******************************************!*\
  !*** ./node_modules/js-sha3/src/sha3.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * [js-sha3]{@link https://github.com/emn178/js-sha3}\n *\n * @version 0.8.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2015-2018\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var INPUT_ERROR = 'input is invalid type';\n  var FINALIZE_ERROR = 'finalize already called';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA3_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = __webpack_require__.g;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && \"object\" === 'object' && module.exports;\n  var AMD =  true && __webpack_require__.amdO;\n  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\n  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];\n  var KECCAK_PADDING = [1, 256, 65536, 16777216];\n  var PADDING = [6, 1536, 393216, 100663296];\n  var SHIFT = [0, 8, 16, 24];\n  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\n    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\n    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\n    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\n    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\n  var BITS = [224, 256, 384, 512];\n  var SHAKE_BITS = [128, 256];\n  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];\n  var CSHAKE_BYTEPAD = {\n    '128': 168,\n    '256': 136\n  };\n\n  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (bits, padding, outputType) {\n    return function (message) {\n      return new Keccak(bits, padding, bits).update(message)[outputType]();\n    };\n  };\n\n  var createShakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits) {\n      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\n    };\n  };\n\n  var createCshakeOutputMethod = function (bits, padding, outputType) {\n    return function (message, outputBits, n, s) {\n      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();\n    };\n  };\n\n  var createKmacOutputMethod = function (bits, padding, outputType) {\n    return function (key, message, outputBits, s) {\n      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();\n    };\n  };\n\n  var createOutputMethods = function (method, createMethod, bits, padding) {\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createMethod(bits, padding, type);\n    }\n    return method;\n  };\n\n  var createMethod = function (bits, padding) {\n    var method = createOutputMethod(bits, padding, 'hex');\n    method.create = function () {\n      return new Keccak(bits, padding, bits);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    return createOutputMethods(method, createOutputMethod, bits, padding);\n  };\n\n  var createShakeMethod = function (bits, padding) {\n    var method = createShakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits) {\n      return new Keccak(bits, padding, outputBits);\n    };\n    method.update = function (message, outputBits) {\n      return method.create(outputBits).update(message);\n    };\n    return createOutputMethods(method, createShakeOutputMethod, bits, padding);\n  };\n\n  var createCshakeMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createCshakeOutputMethod(bits, padding, 'hex');\n    method.create = function (outputBits, n, s) {\n      if (!n && !s) {\n        return methods['shake' + bits].create(outputBits);\n      } else {\n        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);\n      }\n    };\n    method.update = function (message, outputBits, n, s) {\n      return method.create(outputBits, n, s).update(message);\n    };\n    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);\n  };\n\n  var createKmacMethod = function (bits, padding) {\n    var w = CSHAKE_BYTEPAD[bits];\n    var method = createKmacOutputMethod(bits, padding, 'hex');\n    method.create = function (key, outputBits, s) {\n      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);\n    };\n    method.update = function (key, message, outputBits, s) {\n      return method.create(key, outputBits, s).update(message);\n    };\n    return createOutputMethods(method, createKmacOutputMethod, bits, padding);\n  };\n\n  var algorithms = [\n    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },\n    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },\n    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },\n    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }\n  ];\n\n  var methods = {}, methodNames = [];\n\n  for (var i = 0; i < algorithms.length; ++i) {\n    var algorithm = algorithms[i];\n    var bits = algorithm.bits;\n    for (var j = 0; j < bits.length; ++j) {\n      var methodName = algorithm.name + '_' + bits[j];\n      methodNames.push(methodName);\n      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\n      if (algorithm.name !== 'sha3') {\n        var newMethodName = algorithm.name + bits[j];\n        methodNames.push(newMethodName);\n        methods[newMethodName] = methods[methodName];\n      }\n    }\n  }\n\n  function Keccak(bits, padding, outputBits) {\n    this.blocks = [];\n    this.s = [];\n    this.padding = padding;\n    this.outputBits = outputBits;\n    this.reset = true;\n    this.finalized = false;\n    this.block = 0;\n    this.start = 0;\n    this.blockCount = (1600 - (bits << 1)) >> 5;\n    this.byteCount = this.blockCount << 2;\n    this.outputBlocks = outputBits >> 5;\n    this.extraBytes = (outputBits & 31) >> 3;\n\n    for (var i = 0; i < 50; ++i) {\n      this.s[i] = 0;\n    }\n  }\n\n  Keccak.prototype.update = function (message) {\n    if (this.finalized) {\n      throw new Error(FINALIZE_ERROR);\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,\n      blockCount = this.blockCount, index = 0, s = this.s, i, code;\n\n    while (index < length) {\n      if (this.reset) {\n        this.reset = false;\n        blocks[0] = this.block;\n        for (i = 1; i < blockCount + 1; ++i) {\n          blocks[i] = 0;\n        }\n      }\n      if (notString) {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < byteCount; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n      this.lastByteIndex = i;\n      if (i >= byteCount) {\n        this.start = i - byteCount;\n        this.block = blocks[blockCount];\n        for (i = 0; i < blockCount; ++i) {\n          s[i] ^= blocks[i];\n        }\n        f(s);\n        this.reset = true;\n      } else {\n        this.start = i;\n      }\n    }\n    return this;\n  };\n\n  Keccak.prototype.encode = function (x, right) {\n    var o = x & 255, n = 1;\n    var bytes = [o];\n    x = x >> 8;\n    o = x & 255;\n    while (o > 0) {\n      bytes.unshift(o);\n      x = x >> 8;\n      o = x & 255;\n      ++n;\n    }\n    if (right) {\n      bytes.push(n);\n    } else {\n      bytes.unshift(n);\n    }\n    this.update(bytes);\n    return bytes.length;\n  };\n\n  Keccak.prototype.encodeString = function (str) {\n    var notString, type = typeof str;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (str === null) {\n          throw new Error(INPUT_ERROR);\n        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {\n          str = new Uint8Array(str);\n        } else if (!Array.isArray(str)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {\n            throw new Error(INPUT_ERROR);\n          }\n        }\n      } else {\n        throw new Error(INPUT_ERROR);\n      }\n      notString = true;\n    }\n    var bytes = 0, length = str.length;\n    if (notString) {\n      bytes = length;\n    } else {\n      for (var i = 0; i < str.length; ++i) {\n        var code = str.charCodeAt(i);\n        if (code < 0x80) {\n          bytes += 1;\n        } else if (code < 0x800) {\n          bytes += 2;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes += 3;\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));\n          bytes += 4;\n        }\n      }\n    }\n    bytes += this.encode(bytes * 8);\n    this.update(str);\n    return bytes;\n  };\n\n  Keccak.prototype.bytepad = function (strs, w) {\n    var bytes = this.encode(w);\n    for (var i = 0; i < strs.length; ++i) {\n      bytes += this.encodeString(strs[i]);\n    }\n    var paddingBytes = w - bytes % w;\n    var zeros = [];\n    zeros.length = paddingBytes;\n    this.update(zeros);\n    return this;\n  };\n\n  Keccak.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\n    blocks[i >> 2] |= this.padding[i & 3];\n    if (this.lastByteIndex === this.byteCount) {\n      blocks[0] = blocks[blockCount];\n      for (i = 1; i < blockCount + 1; ++i) {\n        blocks[i] = 0;\n      }\n    }\n    blocks[blockCount - 1] |= 0x80000000;\n    for (i = 0; i < blockCount; ++i) {\n      s[i] ^= blocks[i];\n    }\n    f(s);\n  };\n\n  Keccak.prototype.toString = Keccak.prototype.hex = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var hex = '', block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        block = s[i];\n        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\n          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\n          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\n          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n        i = 0;\n      }\n    }\n    if (extraBytes) {\n      block = s[i];\n      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\n      if (extraBytes > 1) {\n        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\n      }\n      if (extraBytes > 2) {\n        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\n      }\n    }\n    return hex;\n  };\n\n  Keccak.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var bytes = this.outputBits >> 3;\n    var buffer;\n    if (extraBytes) {\n      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\n    } else {\n      buffer = new ArrayBuffer(bytes);\n    }\n    var array = new Uint32Array(buffer);\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        array[j] = s[i];\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      array[i] = s[i];\n      buffer = buffer.slice(0, bytes);\n    }\n    return buffer;\n  };\n\n  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\n\n  Keccak.prototype.digest = Keccak.prototype.array = function () {\n    this.finalize();\n\n    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\n      extraBytes = this.extraBytes, i = 0, j = 0;\n    var array = [], offset, block;\n    while (j < outputBlocks) {\n      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\n        offset = j << 2;\n        block = s[i];\n        array[offset] = block & 0xFF;\n        array[offset + 1] = (block >> 8) & 0xFF;\n        array[offset + 2] = (block >> 16) & 0xFF;\n        array[offset + 3] = (block >> 24) & 0xFF;\n      }\n      if (j % blockCount === 0) {\n        f(s);\n      }\n    }\n    if (extraBytes) {\n      offset = j << 2;\n      block = s[i];\n      array[offset] = block & 0xFF;\n      if (extraBytes > 1) {\n        array[offset + 1] = (block >> 8) & 0xFF;\n      }\n      if (extraBytes > 2) {\n        array[offset + 2] = (block >> 16) & 0xFF;\n      }\n    }\n    return array;\n  };\n\n  function Kmac(bits, padding, outputBits) {\n    Keccak.call(this, bits, padding, outputBits);\n  }\n\n  Kmac.prototype = new Keccak();\n\n  Kmac.prototype.finalize = function () {\n    this.encode(this.outputBits, true);\n    return Keccak.prototype.finalize.call(this);\n  };\n\n  var f = function (s) {\n    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\n      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\n      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\n      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\n    for (n = 0; n < 48; n += 2) {\n      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\n      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\n      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\n      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\n      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\n      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\n      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\n      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\n      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\n      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\n\n      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\n      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\n      s[0] ^= h;\n      s[1] ^= l;\n      s[10] ^= h;\n      s[11] ^= l;\n      s[20] ^= h;\n      s[21] ^= l;\n      s[30] ^= h;\n      s[31] ^= l;\n      s[40] ^= h;\n      s[41] ^= l;\n      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\n      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\n      s[2] ^= h;\n      s[3] ^= l;\n      s[12] ^= h;\n      s[13] ^= l;\n      s[22] ^= h;\n      s[23] ^= l;\n      s[32] ^= h;\n      s[33] ^= l;\n      s[42] ^= h;\n      s[43] ^= l;\n      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\n      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\n      s[4] ^= h;\n      s[5] ^= l;\n      s[14] ^= h;\n      s[15] ^= l;\n      s[24] ^= h;\n      s[25] ^= l;\n      s[34] ^= h;\n      s[35] ^= l;\n      s[44] ^= h;\n      s[45] ^= l;\n      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\n      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\n      s[6] ^= h;\n      s[7] ^= l;\n      s[16] ^= h;\n      s[17] ^= l;\n      s[26] ^= h;\n      s[27] ^= l;\n      s[36] ^= h;\n      s[37] ^= l;\n      s[46] ^= h;\n      s[47] ^= l;\n      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\n      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\n      s[8] ^= h;\n      s[9] ^= l;\n      s[18] ^= h;\n      s[19] ^= l;\n      s[28] ^= h;\n      s[29] ^= l;\n      s[38] ^= h;\n      s[39] ^= l;\n      s[48] ^= h;\n      s[49] ^= l;\n\n      b0 = s[0];\n      b1 = s[1];\n      b32 = (s[11] << 4) | (s[10] >>> 28);\n      b33 = (s[10] << 4) | (s[11] >>> 28);\n      b14 = (s[20] << 3) | (s[21] >>> 29);\n      b15 = (s[21] << 3) | (s[20] >>> 29);\n      b46 = (s[31] << 9) | (s[30] >>> 23);\n      b47 = (s[30] << 9) | (s[31] >>> 23);\n      b28 = (s[40] << 18) | (s[41] >>> 14);\n      b29 = (s[41] << 18) | (s[40] >>> 14);\n      b20 = (s[2] << 1) | (s[3] >>> 31);\n      b21 = (s[3] << 1) | (s[2] >>> 31);\n      b2 = (s[13] << 12) | (s[12] >>> 20);\n      b3 = (s[12] << 12) | (s[13] >>> 20);\n      b34 = (s[22] << 10) | (s[23] >>> 22);\n      b35 = (s[23] << 10) | (s[22] >>> 22);\n      b16 = (s[33] << 13) | (s[32] >>> 19);\n      b17 = (s[32] << 13) | (s[33] >>> 19);\n      b48 = (s[42] << 2) | (s[43] >>> 30);\n      b49 = (s[43] << 2) | (s[42] >>> 30);\n      b40 = (s[5] << 30) | (s[4] >>> 2);\n      b41 = (s[4] << 30) | (s[5] >>> 2);\n      b22 = (s[14] << 6) | (s[15] >>> 26);\n      b23 = (s[15] << 6) | (s[14] >>> 26);\n      b4 = (s[25] << 11) | (s[24] >>> 21);\n      b5 = (s[24] << 11) | (s[25] >>> 21);\n      b36 = (s[34] << 15) | (s[35] >>> 17);\n      b37 = (s[35] << 15) | (s[34] >>> 17);\n      b18 = (s[45] << 29) | (s[44] >>> 3);\n      b19 = (s[44] << 29) | (s[45] >>> 3);\n      b10 = (s[6] << 28) | (s[7] >>> 4);\n      b11 = (s[7] << 28) | (s[6] >>> 4);\n      b42 = (s[17] << 23) | (s[16] >>> 9);\n      b43 = (s[16] << 23) | (s[17] >>> 9);\n      b24 = (s[26] << 25) | (s[27] >>> 7);\n      b25 = (s[27] << 25) | (s[26] >>> 7);\n      b6 = (s[36] << 21) | (s[37] >>> 11);\n      b7 = (s[37] << 21) | (s[36] >>> 11);\n      b38 = (s[47] << 24) | (s[46] >>> 8);\n      b39 = (s[46] << 24) | (s[47] >>> 8);\n      b30 = (s[8] << 27) | (s[9] >>> 5);\n      b31 = (s[9] << 27) | (s[8] >>> 5);\n      b12 = (s[18] << 20) | (s[19] >>> 12);\n      b13 = (s[19] << 20) | (s[18] >>> 12);\n      b44 = (s[29] << 7) | (s[28] >>> 25);\n      b45 = (s[28] << 7) | (s[29] >>> 25);\n      b26 = (s[38] << 8) | (s[39] >>> 24);\n      b27 = (s[39] << 8) | (s[38] >>> 24);\n      b8 = (s[48] << 14) | (s[49] >>> 18);\n      b9 = (s[49] << 14) | (s[48] >>> 18);\n\n      s[0] = b0 ^ (~b2 & b4);\n      s[1] = b1 ^ (~b3 & b5);\n      s[10] = b10 ^ (~b12 & b14);\n      s[11] = b11 ^ (~b13 & b15);\n      s[20] = b20 ^ (~b22 & b24);\n      s[21] = b21 ^ (~b23 & b25);\n      s[30] = b30 ^ (~b32 & b34);\n      s[31] = b31 ^ (~b33 & b35);\n      s[40] = b40 ^ (~b42 & b44);\n      s[41] = b41 ^ (~b43 & b45);\n      s[2] = b2 ^ (~b4 & b6);\n      s[3] = b3 ^ (~b5 & b7);\n      s[12] = b12 ^ (~b14 & b16);\n      s[13] = b13 ^ (~b15 & b17);\n      s[22] = b22 ^ (~b24 & b26);\n      s[23] = b23 ^ (~b25 & b27);\n      s[32] = b32 ^ (~b34 & b36);\n      s[33] = b33 ^ (~b35 & b37);\n      s[42] = b42 ^ (~b44 & b46);\n      s[43] = b43 ^ (~b45 & b47);\n      s[4] = b4 ^ (~b6 & b8);\n      s[5] = b5 ^ (~b7 & b9);\n      s[14] = b14 ^ (~b16 & b18);\n      s[15] = b15 ^ (~b17 & b19);\n      s[24] = b24 ^ (~b26 & b28);\n      s[25] = b25 ^ (~b27 & b29);\n      s[34] = b34 ^ (~b36 & b38);\n      s[35] = b35 ^ (~b37 & b39);\n      s[44] = b44 ^ (~b46 & b48);\n      s[45] = b45 ^ (~b47 & b49);\n      s[6] = b6 ^ (~b8 & b0);\n      s[7] = b7 ^ (~b9 & b1);\n      s[16] = b16 ^ (~b18 & b10);\n      s[17] = b17 ^ (~b19 & b11);\n      s[26] = b26 ^ (~b28 & b20);\n      s[27] = b27 ^ (~b29 & b21);\n      s[36] = b36 ^ (~b38 & b30);\n      s[37] = b37 ^ (~b39 & b31);\n      s[46] = b46 ^ (~b48 & b40);\n      s[47] = b47 ^ (~b49 & b41);\n      s[8] = b8 ^ (~b0 & b2);\n      s[9] = b9 ^ (~b1 & b3);\n      s[18] = b18 ^ (~b10 & b12);\n      s[19] = b19 ^ (~b11 & b13);\n      s[28] = b28 ^ (~b20 & b22);\n      s[29] = b29 ^ (~b21 & b23);\n      s[38] = b38 ^ (~b30 & b32);\n      s[39] = b39 ^ (~b31 & b33);\n      s[48] = b48 ^ (~b40 & b42);\n      s[49] = b49 ^ (~b41 & b43);\n\n      s[0] ^= RC[n];\n      s[1] ^= RC[n + 1];\n    }\n  };\n\n  if (COMMON_JS) {\n    module.exports = methods;\n  } else {\n    for (i = 0; i < methodNames.length; ++i) {\n      root[methodNames[i]] = methods[methodNames[i]];\n    }\n    if (AMD) {\n      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n        return methods;\n      }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n  }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFNO0FBQ2pCLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0RBQWdELFFBQWE7QUFDN0QsWUFBWSxLQUE0QixJQUFJLHdCQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGlGQUFpRjtBQUN2RixNQUFNLHdFQUF3RTtBQUM5RSxNQUFNLDBGQUEwRjtBQUNoRyxNQUFNLDZGQUE2RjtBQUNuRyxNQUFNO0FBQ047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QUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUNBQU87QUFDYjtBQUNBLE9BQU87QUFBQSxrR0FBQztBQUNSO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcz8xYzU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogW2pzLXNoYTNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9lbW4xNzgvanMtc2hhM31cbiAqXG4gKiBAdmVyc2lvbiAwLjguMFxuICogQGF1dGhvciBDaGVuLCBZaS1DeXVhbiBbZW1uMTc4QGdtYWlsLmNvbV1cbiAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE4XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBJTlBVVF9FUlJPUiA9ICdpbnB1dCBpcyBpbnZhbGlkIHR5cGUnO1xuICB2YXIgRklOQUxJWkVfRVJST1IgPSAnZmluYWxpemUgYWxyZWFkeSBjYWxsZWQnO1xuICB2YXIgV0lORE9XID0gdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCc7XG4gIHZhciByb290ID0gV0lORE9XID8gd2luZG93IDoge307XG4gIGlmIChyb290LkpTX1NIQTNfTk9fV0lORE9XKSB7XG4gICAgV0lORE9XID0gZmFsc2U7XG4gIH1cbiAgdmFyIFdFQl9XT1JLRVIgPSAhV0lORE9XICYmIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JztcbiAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xuICBpZiAoTk9ERV9KUykge1xuICAgIHJvb3QgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoV0VCX1dPUktFUikge1xuICAgIHJvb3QgPSBzZWxmO1xuICB9XG4gIHZhciBDT01NT05fSlMgPSAhcm9vdC5KU19TSEEzX05PX0NPTU1PTl9KUyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIEFNRCA9IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZDtcbiAgdmFyIEFSUkFZX0JVRkZFUiA9ICFyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSICYmIHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xuICB2YXIgU0hBS0VfUEFERElORyA9IFszMSwgNzkzNiwgMjAzMTYxNiwgNTIwMDkzNjk2XTtcbiAgdmFyIENTSEFLRV9QQURESU5HID0gWzQsIDEwMjQsIDI2MjE0NCwgNjcxMDg4NjRdO1xuICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xuICB2YXIgUEFERElORyA9IFs2LCAxNTM2LCAzOTMyMTYsIDEwMDY2MzI5Nl07XG4gIHZhciBTSElGVCA9IFswLCA4LCAxNiwgMjRdO1xuICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcbiAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXG4gICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXG4gICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXG4gICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xuICB2YXIgQklUUyA9IFsyMjQsIDI1NiwgMzg0LCA1MTJdO1xuICB2YXIgU0hBS0VfQklUUyA9IFsxMjgsIDI1Nl07XG4gIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknLCAnZGlnZXN0J107XG4gIHZhciBDU0hBS0VfQllURVBBRCA9IHtcbiAgICAnMTI4JzogMTY4LFxuICAgICcyNTYnOiAxMzZcbiAgfTtcblxuICBpZiAocm9vdC5KU19TSEEzX05PX05PREVfSlMgfHwgIUFycmF5LmlzQXJyYXkpIHtcbiAgICBBcnJheS5pc0FycmF5ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG4gIH1cblxuICBpZiAoQVJSQVlfQlVGRkVSICYmIChyb290LkpTX1NIQTNfTk9fQVJSQVlfQlVGRkVSX0lTX1ZJRVcgfHwgIUFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqLmJ1ZmZlciAmJiBvYmouYnVmZmVyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKS51cGRhdGUobWVzc2FnZSlbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2NzaGFrZScgKyBiaXRzXS51cGRhdGUobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbJ2ttYWMnICsgYml0c10udXBkYXRlKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcylbb3V0cHV0VHlwZV0oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjcmVhdGVPdXRwdXRNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZCwgY3JlYXRlTWV0aG9kLCBiaXRzLCBwYWRkaW5nKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBPVVRQVVRfVFlQRVMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xuICAgICAgbWV0aG9kW3R5cGVdID0gY3JlYXRlTWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9O1xuXG4gIHZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBiaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAob3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlU2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVDc2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICBpZiAoIW4gJiYgIXMpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHNbJ3NoYWtlJyArIGJpdHNdLmNyZWF0ZShvdXRwdXRCaXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoW24sIHNdLCB3KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cywgbiwgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cywgbiwgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVDc2hha2VPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLbWFjTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcbiAgICB2YXIgdyA9IENTSEFLRV9CWVRFUEFEW2JpdHNdO1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKGtleSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG5ldyBLbWFjKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLmJ5dGVwYWQoWydLTUFDJywgc10sIHcpLmJ5dGVwYWQoW2tleV0sIHcpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChrZXksIG1lc3NhZ2UsIG91dHB1dEJpdHMsIHMpIHtcbiAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKGtleSwgb3V0cHV0Qml0cywgcykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVLbWFjT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgYWxnb3JpdGhtcyA9IFtcbiAgICB7IG5hbWU6ICdrZWNjYWsnLCBwYWRkaW5nOiBLRUNDQUtfUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGEzJywgcGFkZGluZzogUEFERElORywgYml0czogQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdjc2hha2UnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVDc2hha2VNZXRob2QgfSxcbiAgICB7IG5hbWU6ICdrbWFjJywgcGFkZGluZzogQ1NIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlS21hY01ldGhvZCB9XG4gIF07XG5cbiAgdmFyIG1ldGhvZHMgPSB7fSwgbWV0aG9kTmFtZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsZ29yaXRobXMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYWxnb3JpdGhtID0gYWxnb3JpdGhtc1tpXTtcbiAgICB2YXIgYml0cyA9IGFsZ29yaXRobS5iaXRzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYml0cy5sZW5ndGg7ICsraikge1xuICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArICdfJyArIGJpdHNbal07XG4gICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgbWV0aG9kc1ttZXRob2ROYW1lXSA9IGFsZ29yaXRobS5jcmVhdGVNZXRob2QoYml0c1tqXSwgYWxnb3JpdGhtLnBhZGRpbmcpO1xuICAgICAgaWYgKGFsZ29yaXRobS5uYW1lICE9PSAnc2hhMycpIHtcbiAgICAgICAgdmFyIG5ld01ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArIGJpdHNbal07XG4gICAgICAgIG1ldGhvZE5hbWVzLnB1c2gobmV3TWV0aG9kTmFtZSk7XG4gICAgICAgIG1ldGhvZHNbbmV3TWV0aG9kTmFtZV0gPSBtZXRob2RzW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgICB0aGlzLnMgPSBbXTtcbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xuICAgIHRoaXMub3V0cHV0Qml0cyA9IG91dHB1dEJpdHM7XG4gICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJsb2NrID0gMDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xuICAgIHRoaXMuYnl0ZUNvdW50ID0gdGhpcy5ibG9ja0NvdW50IDw8IDI7XG4gICAgdGhpcy5vdXRwdXRCbG9ja3MgPSBvdXRwdXRCaXRzID4+IDU7XG4gICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xuICAgICAgdGhpcy5zW2ldID0gMDtcbiAgICB9XG4gIH1cblxuICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoRklOQUxJWkVfRVJST1IpO1xuICAgIH1cbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIG1lc3NhZ2U7XG4gICAgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBtZXNzYWdlLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgfVxuICAgICAgbm90U3RyaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBieXRlQ291bnQgPSB0aGlzLmJ5dGVDb3VudCwgbGVuZ3RoID0gbWVzc2FnZS5sZW5ndGgsXG4gICAgICBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBpbmRleCA9IDAsIHMgPSB0aGlzLnMsIGksIGNvZGU7XG5cbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLnJlc2V0KSB7XG4gICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgYmxvY2tzWzBdID0gdGhpcy5ibG9jaztcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm90U3RyaW5nKSB7XG4gICAgICAgIGZvciAoaSA9IHRoaXMuc3RhcnQ7IGluZGV4IDwgbGVuZ3RoICYmIGkgPCBieXRlQ291bnQ7ICsraW5kZXgpIHtcbiAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBtZXNzYWdlW2luZGV4XSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gY29kZSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4YzAgfCAoY29kZSA+PiA2KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ZTAgfCAoY29kZSA+PiAxMikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gNikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKG1lc3NhZ2UuY2hhckNvZGVBdCgrK2luZGV4KSAmIDB4M2ZmKSk7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiAxMikgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RCeXRlSW5kZXggPSBpO1xuICAgICAgaWYgKGkgPj0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XG4gICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgZihzKTtcbiAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoeCwgcmlnaHQpIHtcbiAgICB2YXIgbyA9IHggJiAyNTUsIG4gPSAxO1xuICAgIHZhciBieXRlcyA9IFtvXTtcbiAgICB4ID0geCA+PiA4O1xuICAgIG8gPSB4ICYgMjU1O1xuICAgIHdoaWxlIChvID4gMCkge1xuICAgICAgYnl0ZXMudW5zaGlmdChvKTtcbiAgICAgIHggPSB4ID4+IDg7XG4gICAgICBvID0geCAmIDI1NTtcbiAgICAgICsrbjtcbiAgICB9XG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICBieXRlcy5wdXNoKG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG4pO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZShieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzLmxlbmd0aDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgbm90U3RyaW5nLCB0eXBlID0gdHlwZW9mIHN0cjtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgfSBlbHNlIGlmIChBUlJBWV9CVUZGRVIgJiYgc3RyLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHN0ciA9IG5ldyBVaW50OEFycmF5KHN0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc3RyKSkge1xuICAgICAgICAgIGlmICghQVJSQVlfQlVGRkVSIHx8ICFBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYnl0ZXMgPSAwLCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgIGJ5dGVzID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcbiAgICAgICAgICBieXRlcyArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIGJ5dGVzICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZSA9IDB4MTAwMDAgKyAoKChjb2RlICYgMHgzZmYpIDw8IDEwKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgzZmYpKTtcbiAgICAgICAgICBieXRlcyArPSA0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlKGJ5dGVzICogOCk7XG4gICAgdGhpcy51cGRhdGUoc3RyKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5ieXRlcGFkID0gZnVuY3Rpb24gKHN0cnMsIHcpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmVuY29kZSh3KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzICs9IHRoaXMuZW5jb2RlU3RyaW5nKHN0cnNbaV0pO1xuICAgIH1cbiAgICB2YXIgcGFkZGluZ0J5dGVzID0gdyAtIGJ5dGVzICUgdztcbiAgICB2YXIgemVyb3MgPSBbXTtcbiAgICB6ZXJvcy5sZW5ndGggPSBwYWRkaW5nQnl0ZXM7XG4gICAgdGhpcy51cGRhdGUoemVyb3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVkID0gdHJ1ZTtcbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGkgPSB0aGlzLmxhc3RCeXRlSW5kZXgsIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnM7XG4gICAgYmxvY2tzW2kgPj4gMl0gfD0gdGhpcy5wYWRkaW5nW2kgJiAzXTtcbiAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xuICAgICAgYmxvY2tzWzBdID0gYmxvY2tzW2Jsb2NrQ291bnRdO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGJsb2NrQ291bnQgKyAxOyArK2kpIHtcbiAgICAgICAgYmxvY2tzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgIHNbaV0gXj0gYmxvY2tzW2ldO1xuICAgIH1cbiAgICBmKHMpO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUudG9TdHJpbmcgPSBLZWNjYWsucHJvdG90eXBlLmhleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGhleCA9ICcnLCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdICtcbiAgICAgICAgICBIRVhfQ0hBUlNbKGJsb2NrID4+IDI4KSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAyNCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgICBpID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV4dHJhQnl0ZXMpIHtcbiAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXTtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZpbmFsaXplKCk7XG5cbiAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXG4gICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5vdXRwdXRCaXRzID4+IDM7XG4gICAgdmFyIGJ1ZmZlcjtcbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKChvdXRwdXRCbG9ja3MgKyAxKSA8PCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcbiAgICB9XG4gICAgdmFyIGFycmF5ID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50ICYmIGogPCBvdXRwdXRCbG9ja3M7ICsraSwgKytqKSB7XG4gICAgICAgIGFycmF5W2pdID0gc1tpXTtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYXJyYXlbaV0gPSBzW2ldO1xuICAgICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ1ZmZlciA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXlCdWZmZXI7XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5kaWdlc3QgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgM10gPSAoYmxvY2sgPj4gMjQpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChqICUgYmxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBmKHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IChibG9jayA+PiA4KSAmIDB4RkY7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMl0gPSAoYmxvY2sgPj4gMTYpICYgMHhGRjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykge1xuICAgIEtlY2Nhay5jYWxsKHRoaXMsIGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpO1xuICB9XG5cbiAgS21hYy5wcm90b3R5cGUgPSBuZXcgS2VjY2FrKCk7XG5cbiAgS21hYy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbmNvZGUodGhpcy5vdXRwdXRCaXRzLCB0cnVlKTtcbiAgICByZXR1cm4gS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHZhciBmID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXG4gICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXG4gICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXG4gICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XG4gICAgZm9yIChuID0gMDsgbiA8IDQ4OyBuICs9IDIpIHtcbiAgICAgIGMwID0gc1swXSBeIHNbMTBdIF4gc1syMF0gXiBzWzMwXSBeIHNbNDBdO1xuICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XG4gICAgICBjMiA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXTtcbiAgICAgIGMzID0gc1szXSBeIHNbMTNdIF4gc1syM10gXiBzWzMzXSBeIHNbNDNdO1xuICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XG4gICAgICBjNSA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XTtcbiAgICAgIGM2ID0gc1s2XSBeIHNbMTZdIF4gc1syNl0gXiBzWzM2XSBeIHNbNDZdO1xuICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XG4gICAgICBjOCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XTtcbiAgICAgIGM5ID0gc1s5XSBeIHNbMTldIF4gc1syOV0gXiBzWzM5XSBeIHNbNDldO1xuXG4gICAgICBoID0gYzggXiAoKGMyIDw8IDEpIHwgKGMzID4+PiAzMSkpO1xuICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcbiAgICAgIHNbMF0gXj0gaDtcbiAgICAgIHNbMV0gXj0gbDtcbiAgICAgIHNbMTBdIF49IGg7XG4gICAgICBzWzExXSBePSBsO1xuICAgICAgc1syMF0gXj0gaDtcbiAgICAgIHNbMjFdIF49IGw7XG4gICAgICBzWzMwXSBePSBoO1xuICAgICAgc1szMV0gXj0gbDtcbiAgICAgIHNbNDBdIF49IGg7XG4gICAgICBzWzQxXSBePSBsO1xuICAgICAgaCA9IGMwIF4gKChjNCA8PCAxKSB8IChjNSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XG4gICAgICBzWzJdIF49IGg7XG4gICAgICBzWzNdIF49IGw7XG4gICAgICBzWzEyXSBePSBoO1xuICAgICAgc1sxM10gXj0gbDtcbiAgICAgIHNbMjJdIF49IGg7XG4gICAgICBzWzIzXSBePSBsO1xuICAgICAgc1szMl0gXj0gaDtcbiAgICAgIHNbMzNdIF49IGw7XG4gICAgICBzWzQyXSBePSBoO1xuICAgICAgc1s0M10gXj0gbDtcbiAgICAgIGggPSBjMiBeICgoYzYgPDwgMSkgfCAoYzcgPj4+IDMxKSk7XG4gICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xuICAgICAgc1s0XSBePSBoO1xuICAgICAgc1s1XSBePSBsO1xuICAgICAgc1sxNF0gXj0gaDtcbiAgICAgIHNbMTVdIF49IGw7XG4gICAgICBzWzI0XSBePSBoO1xuICAgICAgc1syNV0gXj0gbDtcbiAgICAgIHNbMzRdIF49IGg7XG4gICAgICBzWzM1XSBePSBsO1xuICAgICAgc1s0NF0gXj0gaDtcbiAgICAgIHNbNDVdIF49IGw7XG4gICAgICBoID0gYzQgXiAoKGM4IDw8IDEpIHwgKGM5ID4+PiAzMSkpO1xuICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcbiAgICAgIHNbNl0gXj0gaDtcbiAgICAgIHNbN10gXj0gbDtcbiAgICAgIHNbMTZdIF49IGg7XG4gICAgICBzWzE3XSBePSBsO1xuICAgICAgc1syNl0gXj0gaDtcbiAgICAgIHNbMjddIF49IGw7XG4gICAgICBzWzM2XSBePSBoO1xuICAgICAgc1szN10gXj0gbDtcbiAgICAgIHNbNDZdIF49IGg7XG4gICAgICBzWzQ3XSBePSBsO1xuICAgICAgaCA9IGM2IF4gKChjMCA8PCAxKSB8IChjMSA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XG4gICAgICBzWzhdIF49IGg7XG4gICAgICBzWzldIF49IGw7XG4gICAgICBzWzE4XSBePSBoO1xuICAgICAgc1sxOV0gXj0gbDtcbiAgICAgIHNbMjhdIF49IGg7XG4gICAgICBzWzI5XSBePSBsO1xuICAgICAgc1szOF0gXj0gaDtcbiAgICAgIHNbMzldIF49IGw7XG4gICAgICBzWzQ4XSBePSBoO1xuICAgICAgc1s0OV0gXj0gbDtcblxuICAgICAgYjAgPSBzWzBdO1xuICAgICAgYjEgPSBzWzFdO1xuICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XG4gICAgICBiMzMgPSAoc1sxMF0gPDwgNCkgfCAoc1sxMV0gPj4+IDI4KTtcbiAgICAgIGIxNCA9IChzWzIwXSA8PCAzKSB8IChzWzIxXSA+Pj4gMjkpO1xuICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XG4gICAgICBiNDYgPSAoc1szMV0gPDwgOSkgfCAoc1szMF0gPj4+IDIzKTtcbiAgICAgIGI0NyA9IChzWzMwXSA8PCA5KSB8IChzWzMxXSA+Pj4gMjMpO1xuICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xuICAgICAgYjI5ID0gKHNbNDFdIDw8IDE4KSB8IChzWzQwXSA+Pj4gMTQpO1xuICAgICAgYjIwID0gKHNbMl0gPDwgMSkgfCAoc1szXSA+Pj4gMzEpO1xuICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xuICAgICAgYjIgPSAoc1sxM10gPDwgMTIpIHwgKHNbMTJdID4+PiAyMCk7XG4gICAgICBiMyA9IChzWzEyXSA8PCAxMikgfCAoc1sxM10gPj4+IDIwKTtcbiAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcbiAgICAgIGIzNSA9IChzWzIzXSA8PCAxMCkgfCAoc1syMl0gPj4+IDIyKTtcbiAgICAgIGIxNiA9IChzWzMzXSA8PCAxMykgfCAoc1szMl0gPj4+IDE5KTtcbiAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcbiAgICAgIGI0OCA9IChzWzQyXSA8PCAyKSB8IChzWzQzXSA+Pj4gMzApO1xuICAgICAgYjQ5ID0gKHNbNDNdIDw8IDIpIHwgKHNbNDJdID4+PiAzMCk7XG4gICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XG4gICAgICBiNDEgPSAoc1s0XSA8PCAzMCkgfCAoc1s1XSA+Pj4gMik7XG4gICAgICBiMjIgPSAoc1sxNF0gPDwgNikgfCAoc1sxNV0gPj4+IDI2KTtcbiAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xuICAgICAgYjQgPSAoc1syNV0gPDwgMTEpIHwgKHNbMjRdID4+PiAyMSk7XG4gICAgICBiNSA9IChzWzI0XSA8PCAxMSkgfCAoc1syNV0gPj4+IDIxKTtcbiAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcbiAgICAgIGIzNyA9IChzWzM1XSA8PCAxNSkgfCAoc1szNF0gPj4+IDE3KTtcbiAgICAgIGIxOCA9IChzWzQ1XSA8PCAyOSkgfCAoc1s0NF0gPj4+IDMpO1xuICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XG4gICAgICBiMTAgPSAoc1s2XSA8PCAyOCkgfCAoc1s3XSA+Pj4gNCk7XG4gICAgICBiMTEgPSAoc1s3XSA8PCAyOCkgfCAoc1s2XSA+Pj4gNCk7XG4gICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcbiAgICAgIGI0MyA9IChzWzE2XSA8PCAyMykgfCAoc1sxN10gPj4+IDkpO1xuICAgICAgYjI0ID0gKHNbMjZdIDw8IDI1KSB8IChzWzI3XSA+Pj4gNyk7XG4gICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcbiAgICAgIGI2ID0gKHNbMzZdIDw8IDIxKSB8IChzWzM3XSA+Pj4gMTEpO1xuICAgICAgYjcgPSAoc1szN10gPDwgMjEpIHwgKHNbMzZdID4+PiAxMSk7XG4gICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcbiAgICAgIGIzOSA9IChzWzQ2XSA8PCAyNCkgfCAoc1s0N10gPj4+IDgpO1xuICAgICAgYjMwID0gKHNbOF0gPDwgMjcpIHwgKHNbOV0gPj4+IDUpO1xuICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xuICAgICAgYjEyID0gKHNbMThdIDw8IDIwKSB8IChzWzE5XSA+Pj4gMTIpO1xuICAgICAgYjEzID0gKHNbMTldIDw8IDIwKSB8IChzWzE4XSA+Pj4gMTIpO1xuICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XG4gICAgICBiNDUgPSAoc1syOF0gPDwgNykgfCAoc1syOV0gPj4+IDI1KTtcbiAgICAgIGIyNiA9IChzWzM4XSA8PCA4KSB8IChzWzM5XSA+Pj4gMjQpO1xuICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XG4gICAgICBiOCA9IChzWzQ4XSA8PCAxNCkgfCAoc1s0OV0gPj4+IDE4KTtcbiAgICAgIGI5ID0gKHNbNDldIDw8IDE0KSB8IChzWzQ4XSA+Pj4gMTgpO1xuXG4gICAgICBzWzBdID0gYjAgXiAofmIyICYgYjQpO1xuICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcbiAgICAgIHNbMTBdID0gYjEwIF4gKH5iMTIgJiBiMTQpO1xuICAgICAgc1sxMV0gPSBiMTEgXiAofmIxMyAmIGIxNSk7XG4gICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcbiAgICAgIHNbMjFdID0gYjIxIF4gKH5iMjMgJiBiMjUpO1xuICAgICAgc1szMF0gPSBiMzAgXiAofmIzMiAmIGIzNCk7XG4gICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcbiAgICAgIHNbNDBdID0gYjQwIF4gKH5iNDIgJiBiNDQpO1xuICAgICAgc1s0MV0gPSBiNDEgXiAofmI0MyAmIGI0NSk7XG4gICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xuICAgICAgc1szXSA9IGIzIF4gKH5iNSAmIGI3KTtcbiAgICAgIHNbMTJdID0gYjEyIF4gKH5iMTQgJiBiMTYpO1xuICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XG4gICAgICBzWzIyXSA9IGIyMiBeICh+YjI0ICYgYjI2KTtcbiAgICAgIHNbMjNdID0gYjIzIF4gKH5iMjUgJiBiMjcpO1xuICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XG4gICAgICBzWzMzXSA9IGIzMyBeICh+YjM1ICYgYjM3KTtcbiAgICAgIHNbNDJdID0gYjQyIF4gKH5iNDQgJiBiNDYpO1xuICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XG4gICAgICBzWzRdID0gYjQgXiAofmI2ICYgYjgpO1xuICAgICAgc1s1XSA9IGI1IF4gKH5iNyAmIGI5KTtcbiAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xuICAgICAgc1sxNV0gPSBiMTUgXiAofmIxNyAmIGIxOSk7XG4gICAgICBzWzI0XSA9IGIyNCBeICh+YjI2ICYgYjI4KTtcbiAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xuICAgICAgc1szNF0gPSBiMzQgXiAofmIzNiAmIGIzOCk7XG4gICAgICBzWzM1XSA9IGIzNSBeICh+YjM3ICYgYjM5KTtcbiAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xuICAgICAgc1s0NV0gPSBiNDUgXiAofmI0NyAmIGI0OSk7XG4gICAgICBzWzZdID0gYjYgXiAofmI4ICYgYjApO1xuICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcbiAgICAgIHNbMTZdID0gYjE2IF4gKH5iMTggJiBiMTApO1xuICAgICAgc1sxN10gPSBiMTcgXiAofmIxOSAmIGIxMSk7XG4gICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcbiAgICAgIHNbMjddID0gYjI3IF4gKH5iMjkgJiBiMjEpO1xuICAgICAgc1szNl0gPSBiMzYgXiAofmIzOCAmIGIzMCk7XG4gICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcbiAgICAgIHNbNDZdID0gYjQ2IF4gKH5iNDggJiBiNDApO1xuICAgICAgc1s0N10gPSBiNDcgXiAofmI0OSAmIGI0MSk7XG4gICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xuICAgICAgc1s5XSA9IGI5IF4gKH5iMSAmIGIzKTtcbiAgICAgIHNbMThdID0gYjE4IF4gKH5iMTAgJiBiMTIpO1xuICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XG4gICAgICBzWzI4XSA9IGIyOCBeICh+YjIwICYgYjIyKTtcbiAgICAgIHNbMjldID0gYjI5IF4gKH5iMjEgJiBiMjMpO1xuICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XG4gICAgICBzWzM5XSA9IGIzOSBeICh+YjMxICYgYjMzKTtcbiAgICAgIHNbNDhdID0gYjQ4IF4gKH5iNDAgJiBiNDIpO1xuICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XG5cbiAgICAgIHNbMF0gXj0gUkNbbl07XG4gICAgICBzWzFdIF49IFJDW24gKyAxXTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKENPTU1PTl9KUykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gbWV0aG9kcztcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0aG9kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJvb3RbbWV0aG9kTmFtZXNbaV1dID0gbWV0aG9kc1ttZXRob2ROYW1lc1tpXV07XG4gICAgfVxuICAgIGlmIChBTUQpIHtcbiAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXRob2RzO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/js-sha3/src/sha3.js\n");

/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("module.exports = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL21pbmltYWxpc3RpYy1hc3NlcnQvaW5kZXguanM/ZGEzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/minimalistic-assert/index.js\n");

            /***/
        }),

        /***/
        "./src/main.ts":
        /*!***********************************!*\
          !*** ./src/main.ts + 231 modules ***!
          \***********************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

            "use strict";
            eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n;// CONCATENATED MODULE: ./src/errors/GeneralError.ts\nclass GeneralError extends Error {\r\n    constructor(e) {\r\n        super();\r\n        this.code = 0;\r\n        this.stack = \"\";\r\n        if (!e.message) {\r\n            this.message = e.toString();\r\n        }\r\n        else if (e.message.data) {\r\n            this.code = e.message.data.code;\r\n            this.message = e.message.data.message;\r\n            this.error = e;\r\n            this.headers = e.message.headers;\r\n            this.stack = e.stack;\r\n        }\r\n        else if (typeof (e.data) == 'object') {\r\n            this.code = e.data.code;\r\n            this.message = e.data.message;\r\n            this.stack = e.stack;\r\n        }\r\n        else if (e.message) {\r\n            this.message = e.message;\r\n        }\r\n        else {\r\n            this.message = e.toString();\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/SwitchNetwork.html\n// Module\nvar code = \"<div id=\\\"switchNetworkInfo\\\">\\r\\n    You can choose any of these networks.\\r\\n    <div>\\r\\n        <h3>Mainnet - real money & stocks</h3>\\r\\n        {{#each mainNetworks}}\\r\\n        <button href=\\\"\\\" class=\\\"setNetwork\\\"\\r\\n                data-chainid=\\\"{{ChainId}}\\\">{{ChainName}}\\r\\n        </button>\\r\\n        {{/each}}\\r\\n    </div>\\r\\n    <div>\\r\\n        <h3>Testnet - fake money & stocks</h3>\\r\\n        {{#each testNetworks}}\\r\\n        <button href=\\\"\\\" class=\\\"setNetwork\\\"\\r\\n                data-chainid=\\\"{{ChainId}}\\\">{{ChainName}}\\r\\n        </button>\\r\\n        {{/each}}\\r\\n    </div>\\r\\n</div>\\r\\n<div id=\\\"jsSwitchNetworkNotWorking\\\" class=\\\"d-none\\\">\\r\\n    It seem as we can't add the network automatically for your, so you need to add it your self.\\r\\n    This is the information you need to add the network. You will need to figure out where to\\r\\n    add new network for your wallet, as it difference between wallets.\\r\\n    <form>\\r\\n        <label>ChainId:\\r\\n            <input id=\\\"switchChainId\\\"/>\\r\\n        </label>\\r\\n        <label>Chain name\\r\\n            <input id=\\\"switchChainName\\\"/>\\r\\n        </label>\\r\\n        <label>Currency name\\r\\n            <input id=\\\"switchCurrencyName\\\"/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Symbol\\r\\n            <input id=\\\"switchSymbol\\\"/>\\r\\n        </label>\\r\\n        <label>Decimal\\r\\n            <input id=\\\"switchDecimal\\\"/>\\r\\n        </label>\\r\\n        <label>Rpc Url\\r\\n            <input id=\\\"switchRpcUrl\\\"/>\\r\\n        </label>\\r\\n    </form>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const SwitchNetwork = (code);\n;// CONCATENATED MODULE: ./src/html/modal/Modal.html\n// Module\nvar Modal_code = \"<dialog id=\\\"liminal_market_modal_div\\\" data-title=\\\"{{{title}}}\\\">\\r\\n    <article>\\r\\n        <header>\\r\\n            <span>{{title}}</span>\\r\\n            <a href=\\\"#close\\\" aria-label=\\\"Close\\\" class=\\\"close\\\" id=\\\"liminal_market_modal_close\\\"></a>\\r\\n        </header>\\r\\n        {{{content}}}\\r\\n    </article>\\r\\n\\r\\n</dialog>\";\n// Exports\n/* harmony default export */ const modal_Modal = (Modal_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Modal.ts\n\r\nclass Modal {\r\n    constructor() {\r\n        this.modalId = 'liminal_market_modal_div';\r\n    }\r\n    hideModal() {\r\n        let modalDiv = document.getElementById(this.modalId);\r\n        modalDiv === null || modalDiv === void 0 ? void 0 : modalDiv.removeAttribute('open');\r\n        if (this.onHide) {\r\n            this.onHide();\r\n        }\r\n    }\r\n    showModal(title, content, reuseModalIfSameTitle = false, onHide, hideOnOutsideClick = true) {\r\n        var _a;\r\n        let modalDiv = document.getElementById(this.modalId);\r\n        if (modalDiv) {\r\n            let modalTitle = modalDiv.dataset.title;\r\n            if (reuseModalIfSameTitle && modalTitle && modalTitle === title) {\r\n                modalDiv.setAttribute('open', '');\r\n                return false;\r\n            }\r\n        }\r\n        let template = Handlebars.compile(modal_Modal);\r\n        let obj = {\r\n            title: title, content: content\r\n        };\r\n        let html = template(obj);\r\n        if (modalDiv) {\r\n            document.body.removeChild(modalDiv);\r\n        }\r\n        document.body.insertAdjacentHTML('beforeend', html);\r\n        modalDiv = document.getElementById(this.modalId);\r\n        modalDiv.setAttribute('open', '');\r\n        if (hideOnOutsideClick) {\r\n            modalDiv.addEventListener('mousedown', (evt) => {\r\n                if (evt.target && evt.target.id === 'liminal_market_modal_div') {\r\n                    this.hideModal();\r\n                }\r\n            });\r\n        }\r\n        let liminal_market_modal_close = document.getElementById('liminal_market_modal_close');\r\n        if (liminal_market_modal_close)\r\n            liminal_market_modal_close.style.display = 'block';\r\n        (_a = document.getElementById('liminal_market_modal_close')) === null || _a === void 0 ? void 0 : _a.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            this.hideModal();\r\n        });\r\n        this.onHide = onHide;\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/broker/Security.ts\nclass Security {\r\n    constructor() {\r\n        this.Class = \"\";\r\n        this.Exchange = \"\";\r\n        this.Symbol = \"\";\r\n        this.Name = \"\";\r\n        this.Status = \"\";\r\n        this.Tradable = false;\r\n        this.Fractionable = false;\r\n        this.Logo = \"\";\r\n        this.Favorite = 0;\r\n        this.LogoPath = \"/img/logos/\";\r\n        this.LogoPath = \"/img/logos/\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/broker/SecuritiesService.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass SecuritiesService {\r\n    constructor() {\r\n        this.securities = new Map();\r\n        this.symbols = [\"MSFT\", \"AAPL\", \"AMZN\", \"TSLA\", \"GOOGL\", \"GOOG\", \"GME\", \"META\", \"NVDA\", \"BRK.B\", \"JPM\", \"HD\", \"JNJ\", \"UNH\", \"PG\", \"BAC\", \"V\", \"ADBE\", \"NFLX\", \"CRM\", \"PFE\", \"DIS\", \"MA\", \"XOM\", \"TMO\", \"COST\"];\r\n        this.securities = new Map();\r\n        this.page = 1;\r\n    }\r\n    static getInstance() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!SecuritiesService.instance) {\r\n                SecuritiesService.instance = new SecuritiesService();\r\n                SecuritiesService.instance.securities = yield SecuritiesService.instance.getSecurities();\r\n            }\r\n            return SecuritiesService.instance;\r\n        });\r\n    }\r\n    getSecurities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.securities.size != 0)\r\n                return this.securities;\r\n            const response = yield fetch('/securities/securities.json');\r\n            const results = yield response.json();\r\n            for (let i = 0; i < results.length; i++) {\r\n                this.securities.set(results[i].Symbol, Object.assign(new Security, results[i]));\r\n            }\r\n            this.securitiesArray = Array.from(this.securities);\r\n            return this.securities;\r\n        });\r\n    }\r\n    getSecurityBySymbol(symbol) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let securities = yield this.getSecurities();\r\n            let security = securities.get(symbol);\r\n            return (security) ? security : new Security();\r\n        });\r\n    }\r\n    getTopSecurities() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let securities = yield this.getSecurities();\r\n            let topSecurities = new Array();\r\n            for (const symbol of this.symbols) {\r\n                let security = securities.get(symbol);\r\n                if (security) {\r\n                    topSecurities.push(security);\r\n                }\r\n            }\r\n            return topSecurities;\r\n        });\r\n    }\r\n    getPaginatingSecurities(page) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (page == 0)\r\n                return this.getTopSecurities();\r\n            let securitiesOnPage = new Array();\r\n            let i = page * this.symbols.length;\r\n            let pageCount = i + 10;\r\n            for (; i < pageCount && i < this.securitiesArray.length; i++) {\r\n                securitiesOnPage.push(this.securitiesArray[i][1]);\r\n            }\r\n            return securitiesOnPage;\r\n        });\r\n    }\r\n    find(search) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let results = new Array();\r\n            search = search.toLocaleLowerCase();\r\n            this.securities.forEach(function (security) {\r\n                if (security.Symbol.toLowerCase().indexOf(search) != -1 ||\r\n                    security.Name.toLowerCase().indexOf(search) != -1) {\r\n                    results.push(security);\r\n                }\r\n            });\r\n            return results;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/util/LoadingHelper.ts\nclass LoadingHelper {\r\n    static setLoading(element) {\r\n        if (LoadingHelper.lastElement) {\r\n            LoadingHelper.lastElement.removeAttribute('aria-busy');\r\n        }\r\n        if (!element)\r\n            return;\r\n        element.setAttribute('aria-busy', 'true');\r\n        LoadingHelper.lastElement = element;\r\n    }\r\n    static removeLoading() {\r\n        if (this.lastElement) {\r\n            this.lastElement.removeAttribute('aria-busy');\r\n        }\r\n    }\r\n}\r\nLoadingHelper.lastElement = undefined;\r\n\n;// CONCATENATED MODULE: ./src/util/WalletHelper.ts\nvar WalletHelper_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass WalletHelper {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    getAUsdAsset() {\r\n        return {\r\n            Logo: '../ausd.png'\r\n        };\r\n    }\r\n    addTokenToWallet(address, symbol, fallbackTimeout) {\r\n        return WalletHelper_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            const asset = (symbol == 'aUSD') ? this.getAUsdAsset() : yield securitiesService.getSecurityBySymbol(symbol);\r\n            let web3 = this.moralis.web3;\r\n            if (!web3) {\r\n                web3 = yield AuthenticateService.enableWeb3(this.moralis);\r\n                if (!web3) {\r\n                    fallbackTimeout();\r\n                    return;\r\n                }\r\n            }\r\n            if (!web3.provider.request) {\r\n                fallbackTimeout();\r\n                return;\r\n            }\r\n            let timeout = (WalletHelper.addTokenFallbackLoaded === undefined) ? 2 * 1000 : 200;\r\n            setTimeout(() => {\r\n                if (WalletHelper.addTokenFallbackLoaded !== false) {\r\n                    WalletHelper.addTokenFallbackLoaded = true;\r\n                    if (fallbackTimeout)\r\n                        fallbackTimeout();\r\n                }\r\n            }, timeout);\r\n            const wasAdded = yield web3.provider.request({\r\n                method: 'wallet_watchAsset',\r\n                params: {\r\n                    type: 'ERC20',\r\n                    options: {\r\n                        address: address,\r\n                        symbol: symbol,\r\n                        decimals: 18,\r\n                        image: 'https://app.liminal.market/img/logos/' + asset.Logo,\r\n                    },\r\n                },\r\n            }).then((result) => {\r\n                WalletHelper.addTokenFallbackLoaded = false;\r\n                return true;\r\n            }).catch((error) => {\r\n                console.log(error);\r\n                return false;\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n            return wasAdded;\r\n        });\r\n    }\r\n    ;\r\n    isWebview(ua) {\r\n        // if it says it's a webview, let's go with that\r\n        let rules = ['WebView',\r\n            // iOS webview will be the same as safari but missing \"Safari\"\r\n            '(iPhone|iPod|iPad)(?!.*Safari)',\r\n            // Android Lollipop and Above: webview will be the same as native but it will contain \"wv\"\r\n            // Android KitKat to lollipop webview will put {version}.0.0.0\r\n            'Android.*(wv|.0.0.0)',\r\n            // old chrome android webview agent\r\n            'Linux; U; Android',\r\n            'SDK'\r\n        ];\r\n        let webviewRegExp = new RegExp('(' + rules.join('|') + ')', 'ig');\r\n        return !!ua.match(webviewRegExp);\r\n    }\r\n    isMagic() {\r\n        return WalletHelper_awaiter(this, void 0, void 0, function* () {\r\n            const walletInfo = yield this.moralis.connector.magic.connect.getWalletInfo();\r\n            const walletType = walletInfo.walletType;\r\n            console.log('walletType', walletType);\r\n            return (walletType === \"magic\");\r\n        });\r\n    }\r\n    switchNetwork(network) {\r\n        return WalletHelper_awaiter(this, void 0, void 0, function* () {\r\n            NetworkInfo.setNetworkByChainId(network.ChainId);\r\n            return true;\r\n        });\r\n    }\r\n    static hideMagicWallet() {\r\n        let magicIframe = document.querySelector('.magic-iframe');\r\n        if (magicIframe && magicIframe.style.display == 'block')\r\n            magicIframe.style.display = 'none';\r\n    }\r\n}\r\nWalletHelper.addTokenFallbackLoaded = undefined;\r\n\n;// CONCATENATED MODULE: ./src/networks/NetworkType.ts\nvar NetworkType;\r\n(function (NetworkType) {\r\n    NetworkType[NetworkType[\"Mainnet\"] = 0] = \"Mainnet\";\r\n    NetworkType[NetworkType[\"Testnet\"] = 1] = \"Testnet\";\r\n})(NetworkType || (NetworkType = {}));\r\n\n;// CONCATENATED MODULE: ./src/services/broker/MarketService.ts\nvar MarketService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass MarketService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    isMarketOpen() {\r\n        return MarketService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('isOpen');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/enums/WalletType.ts\nvar WalletType;\r\n(function (WalletType) {\r\n    WalletType[\"Metamask\"] = \"metamask\";\r\n    WalletType[\"WalletConnect\"] = \"walletConnect\";\r\n    WalletType[\"CoinbaseWallet\"] = \"coinbase\";\r\n    WalletType[\"Web3Auth\"] = \"web3Auth\";\r\n    WalletType[\"MagicLink\"] = \"MagicLink\";\r\n    WalletType[\"Unknown\"] = \"unknown\";\r\n})(WalletType || (WalletType = {}));\r\n\n;// CONCATENATED MODULE: ./src/wallet/ProviderInfo.ts\n\r\nclass ProviderInfo {\r\n    constructor(web3Provider) {\r\n        this.ProviderName = 'unknown';\r\n        this.WalletName = '';\r\n        this.WalletUrl = '';\r\n        this.WalletType = WalletType.Unknown;\r\n        this.UserAddress = '';\r\n        this.InternalWallet = false;\r\n        if (!web3Provider || !web3Provider.provider)\r\n            return;\r\n        this.web3Provider = web3Provider;\r\n        if (this.web3Provider.connection && this.web3Provider.connection.url == 'metamask') {\r\n            this.loadMetamask(web3Provider);\r\n        }\r\n        else if (this.web3Provider.provider.wc) {\r\n            this.loadWalletConnect(web3Provider);\r\n        }\r\n        else if (this.web3Provider.provider.isMagic) {\r\n            this.loadMagicConnect(web3Provider);\r\n        }\r\n        else {\r\n            this.loadCustom(web3Provider);\r\n        }\r\n        ProviderInfo.Instance = this;\r\n    }\r\n    loadMetamask(walletConnectionInfo) {\r\n        this.ProviderName = 'metamask';\r\n        this.WalletName = \"Metamask\";\r\n        this.WalletUrl = 'https://metamask.io/';\r\n        this.WalletType = WalletType.Metamask;\r\n        this.UserAddress = walletConnectionInfo.provider.selectedAddress;\r\n    }\r\n    loadWalletConnect(walletConnectionInfo) {\r\n        var _a;\r\n        let wc = walletConnectionInfo.provider.wc;\r\n        this.ProviderName = \"walletConnect\";\r\n        this.WalletName = wc._peerMeta.name;\r\n        this.WalletUrl = (_a = wc._peerMeta.url) !== null && _a !== void 0 ? _a : '';\r\n        this.WalletType = WalletType.WalletConnect;\r\n    }\r\n    loadCustom(provider) {\r\n        this.ProviderName = 'web3auth';\r\n        this.WalletName = 'Torus';\r\n        this.WalletUrl = 'https://app.tor.us/';\r\n        this.WalletType = WalletType.Web3Auth;\r\n    }\r\n    loadMagicConnect(walletConnectionInfo) {\r\n        this.ProviderName = 'MagicLink';\r\n        this.WalletName = 'MagicLink';\r\n        this.WalletType = WalletType.MagicLink;\r\n        this.InternalWallet = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/UserService.ts\nvar UserService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass UserService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    logOut() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield this.moralis.connector.magic.connect.disconnect();\r\n            }\r\n            catch (e) {\r\n                console.error('logout magicUser', e);\r\n            }\r\n            try {\r\n                return yield this.moralis.User.logOut();\r\n            }\r\n            catch (e) {\r\n                console.error('logout moralisUser', e);\r\n            }\r\n        });\r\n    }\r\n    isLoggedIn() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let user = yield this.moralis.User.currentAsync();\r\n            if (!user) {\r\n                return;\r\n            }\r\n            if (!this.moralis.isWeb3Enabled()) {\r\n                let result = yield AuthenticateService.enableWeb3(this.moralis)\r\n                    .catch(reason => {\r\n                    console.error('enableWeb3 error:', reason);\r\n                    this.logOut();\r\n                });\r\n                if (!result)\r\n                    return;\r\n            }\r\n            let authenticationService = new AuthenticateService(this.moralis);\r\n            yield authenticationService.authenticateUser((web3Provider) => {\r\n                user.providerInfo = new ProviderInfo(web3Provider);\r\n            }, (loggedInUser) => {\r\n                user = loggedInUser;\r\n            });\r\n            return user;\r\n        });\r\n    }\r\n    isMarketOpenOrUserOffHours() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let marketService = new MarketService(this.moralis);\r\n            let isOpen = yield marketService.isMarketOpen();\r\n            if (isOpen)\r\n                return true;\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            //TODO: Remove on mainnet launch\r\n            if (!networkInfo.TestNetwork)\r\n                return false;\r\n            return false;\r\n        });\r\n    }\r\n    getUser() {\r\n        return this.moralis.User.current();\r\n    }\r\n    getAlpacaId() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let user = this.getUser();\r\n            if (!user)\r\n                return '';\r\n            return (yield user.fetch()).get('alpacaId').toString();\r\n        });\r\n    }\r\n    getAccount() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let user = this.getUser();\r\n            if (!user)\r\n                return;\r\n            return yield this.moralis.Cloud.run('account');\r\n        });\r\n    }\r\n    getEthAddress() {\r\n        var _a;\r\n        return (_a = this.getUser()) === null || _a === void 0 ? void 0 : _a.get('ethAddress');\r\n    }\r\n    kycActionRequired() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            let kycResults = yield this.moralis.Cloud.run('kycActionRequired');\r\n            return kycResults;\r\n        });\r\n    }\r\n    updateName(given_name, middle_name, family_name) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('updateName', {\r\n                given_name: given_name,\r\n                middle_name: middle_name,\r\n                family_name: family_name\r\n            });\r\n        });\r\n    }\r\n    updateContact(data) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('updateContact', data);\r\n        });\r\n    }\r\n    updateTrustedContact(data) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('updateTrustedContact', data);\r\n        });\r\n    }\r\n    createAchRelationship(account_owner_name, bank_account_type, bank_account_number, bank_routing_number) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('createAchRelationship', {\r\n                account_owner_name, bank_account_type, bank_account_number, bank_routing_number\r\n            });\r\n        });\r\n    }\r\n    getBankRelationship() {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('getBankRelationship');\r\n        });\r\n    }\r\n    getLatestTransfers(direction) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('getTransfers', { direction: direction });\r\n        });\r\n    }\r\n    createTransfer(amount, direction) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('createTransfer', { amount: amount, direction: direction });\r\n        });\r\n    }\r\n    deleteTransfer(id) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('deleteTransfer', { id: id });\r\n        });\r\n    }\r\n    registerWireTransferRelationship(params) {\r\n        return UserService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('createWireRelationship', params);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/SwitchNetworkModal.ts\nvar SwitchNetworkModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SwitchNetworkModal {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(SwitchNetwork);\r\n        let testNetworks = NetworkInfo.getNetworks(NetworkType.Testnet);\r\n        let mainNetworks = NetworkInfo.getNetworks(NetworkType.Mainnet);\r\n        let content = template({ testNetworks, mainNetworks });\r\n        let modal = new Modal();\r\n        modal.showModal('Switch network', content, false);\r\n        let setNetworkLinks = document.querySelectorAll('.setNetwork');\r\n        setNetworkLinks.forEach(setNetworkLink => {\r\n            setNetworkLink.addEventListener('click', (evt) => SwitchNetworkModal_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                let dataset = evt.target.dataset;\r\n                this.selectedNetwork = NetworkInfo.getNetworkInfoByChainId(parseInt(dataset.chainid));\r\n                if (!this.selectedNetwork)\r\n                    throw new GeneralError('Could not find chainId:' + dataset.chainid);\r\n                let walletHelper = new WalletHelper(this.moralis);\r\n                let successAddingNetwork = yield walletHelper.switchNetwork(this.selectedNetwork)\r\n                    .catch((error) => {\r\n                    let jsSwitchNetworkNotWorking = document.getElementById('jsSwitchNetworkNotWorking');\r\n                    if (!jsSwitchNetworkNotWorking)\r\n                        throw error;\r\n                    jsSwitchNetworkNotWorking.classList.remove('d-none');\r\n                    let switchNetworkInfo = document.getElementById('switchNetworkInfo');\r\n                    switchNetworkInfo.classList.add('d-none');\r\n                    document.getElementById('switchChainId').value = dataset.chainid + ' or it might be: ' + '0x' + parseInt(dataset.chainid).toString(16);\r\n                    document.getElementById('switchChainName').value = this.selectedNetwork.Name;\r\n                    document.getElementById('switchCurrencyName').value = this.selectedNetwork.NativeCurrencyName;\r\n                    document.getElementById('switchSymbol').value = this.selectedNetwork.NativeSymbol;\r\n                    document.getElementById('switchDecimal').value = this.selectedNetwork.NativeDecimal.toString();\r\n                    document.getElementById('switchRpcUrl').value = this.selectedNetwork.RpcUrl;\r\n                });\r\n                if (successAddingNetwork) {\r\n                    modal.hideModal();\r\n                    let userService = new UserService(this.moralis);\r\n                    yield userService.logOut();\r\n                    location.reload();\r\n                }\r\n            }));\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/logger/lib.esm/_version.js\nconst version = \"logger/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/logger/lib.esm/index.js\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\n\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nclass Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/properties/lib.esm/_version.js\nconst _version_version = \"properties/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/properties/lib.esm/index.js\n\nvar lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nconst logger = new Logger(_version_version);\nfunction defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nfunction getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nfunction resolveProperties(object) {\n    return lib_esm_awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nfunction checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nfunction shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nfunction deepCopy(object) {\n    return _deepCopy(object);\n}\nclass Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/_version.js\nconst lib_esm_version_version = \"providers/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js\nconst abstract_signer_lib_esm_version_version = \"abstract-signer/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-signer/lib.esm/index.js\n\nvar abstract_signer_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\nconst lib_esm_logger = new Logger(abstract_signer_lib_esm_version_version);\nconst allowedTransactionKeys = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n;\n;\nclass Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        lib_esm_logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"call\");\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                lib_esm_logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = shallowCopy(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        }\n        else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    lib_esm_logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to) => abstract_signer_lib_esm_awaiter(this, void 0, void 0, function* () {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.resolveName(to);\n                    if (address == null) {\n                        lib_esm_logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error) => { });\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                lib_esm_logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            }\n            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                lib_esm_logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            }\n            else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            }\n            else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        }\n                        else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    }\n                    else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            lib_esm_logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    }\n                    else {\n                        // getFeeData has failed us.\n                        lib_esm_logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                }\n                else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return lib_esm_logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            }\n            else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results) => {\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        lib_esm_logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield resolveProperties(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            lib_esm_logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: (operation || \"_checkProvider\")\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nclass VoidSigner extends Signer {\n    constructor(address, provider) {\n        lib_esm_logger.checkNew(new.target, VoidSigner);\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(() => {\n            lib_esm_logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n}\n//# sourceMappingURL=index.js.map\n// EXTERNAL MODULE: ./node_modules/bn.js/lib/bn.js\nvar bn = __webpack_require__(\"./node_modules/bn.js/lib/bn.js\");\nvar bn_default = /*#__PURE__*/__webpack_require__.n(bn);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bytes/lib.esm/_version.js\nconst bytes_lib_esm_version_version = \"bytes/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bytes/lib.esm/index.js\n\n\n\nconst bytes_lib_esm_logger = new Logger(bytes_lib_esm_version_version);\n///////////////////////////////\nfunction isHexable(value) {\n    return !!(value.toHexString);\n}\nfunction addSlice(array) {\n    if (array.slice) {\n        return array;\n    }\n    array.slice = function () {\n        const args = Array.prototype.slice.call(arguments);\n        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n    };\n    return array;\n}\nfunction isBytesLike(value) {\n    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n}\nfunction isInteger(value) {\n    return (typeof (value) === \"number\" && value == value && (value % 1) === 0);\n}\nfunction isBytes(value) {\n    if (value == null) {\n        return false;\n    }\n    if (value.constructor === Uint8Array) {\n        return true;\n    }\n    if (typeof (value) === \"string\") {\n        return false;\n    }\n    if (!isInteger(value.length) || value.length < 0) {\n        return false;\n    }\n    for (let i = 0; i < value.length; i++) {\n        const v = value[i];\n        if (!isInteger(v) || v < 0 || v >= 256) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction arrayify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        bytes_lib_esm_logger.checkSafeUint53(value, \"invalid arrayify value\");\n        const result = [];\n        while (value) {\n            result.unshift(value & 0xff);\n            value = parseInt(String(value / 256));\n        }\n        if (result.length === 0) {\n            result.push(0);\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        value = value.toHexString();\n    }\n    if (isHexString(value)) {\n        let hex = value.substring(2);\n        if (hex.length % 2) {\n            if (options.hexPad === \"left\") {\n                hex = \"0x0\" + hex.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                hex += \"0\";\n            }\n            else {\n                bytes_lib_esm_logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        const result = [];\n        for (let i = 0; i < hex.length; i += 2) {\n            result.push(parseInt(hex.substring(i, i + 2), 16));\n        }\n        return addSlice(new Uint8Array(result));\n    }\n    if (isBytes(value)) {\n        return addSlice(new Uint8Array(value));\n    }\n    return bytes_lib_esm_logger.throwArgumentError(\"invalid arrayify value\", \"value\", value);\n}\nfunction concat(items) {\n    const objects = items.map(item => arrayify(item));\n    const length = objects.reduce((accum, item) => (accum + item.length), 0);\n    const result = new Uint8Array(length);\n    objects.reduce((offset, object) => {\n        result.set(object, offset);\n        return offset + object.length;\n    }, 0);\n    return addSlice(result);\n}\nfunction stripZeros(value) {\n    let result = arrayify(value);\n    if (result.length === 0) {\n        return result;\n    }\n    // Find the first non-zero entry\n    let start = 0;\n    while (start < result.length && result[start] === 0) {\n        start++;\n    }\n    // If we started with zeros, strip them\n    if (start) {\n        result = result.slice(start);\n    }\n    return result;\n}\nfunction zeroPad(value, length) {\n    value = arrayify(value);\n    if (value.length > length) {\n        bytes_lib_esm_logger.throwArgumentError(\"value out of range\", \"value\", arguments[0]);\n    }\n    const result = new Uint8Array(length);\n    result.set(value, length - value.length);\n    return addSlice(result);\n}\nfunction isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (length && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    return true;\n}\nconst HexCharacters = \"0123456789abcdef\";\nfunction hexlify(value, options) {\n    if (!options) {\n        options = {};\n    }\n    if (typeof (value) === \"number\") {\n        bytes_lib_esm_logger.checkSafeUint53(value, \"invalid hexlify value\");\n        let hex = \"\";\n        while (value) {\n            hex = HexCharacters[value & 0xf] + hex;\n            value = Math.floor(value / 16);\n        }\n        if (hex.length) {\n            if (hex.length % 2) {\n                hex = \"0\" + hex;\n            }\n            return \"0x\" + hex;\n        }\n        return \"0x00\";\n    }\n    if (typeof (value) === \"bigint\") {\n        value = value.toString(16);\n        if (value.length % 2) {\n            return (\"0x0\" + value);\n        }\n        return \"0x\" + value;\n    }\n    if (options.allowMissingPrefix && typeof (value) === \"string\" && value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    if (isHexable(value)) {\n        return value.toHexString();\n    }\n    if (isHexString(value)) {\n        if (value.length % 2) {\n            if (options.hexPad === \"left\") {\n                value = \"0x0\" + value.substring(2);\n            }\n            else if (options.hexPad === \"right\") {\n                value += \"0\";\n            }\n            else {\n                bytes_lib_esm_logger.throwArgumentError(\"hex data is odd-length\", \"value\", value);\n            }\n        }\n        return value.toLowerCase();\n    }\n    if (isBytes(value)) {\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            let v = value[i];\n            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n        }\n        return result;\n    }\n    return bytes_lib_esm_logger.throwArgumentError(\"invalid hexlify value\", \"value\", value);\n}\n/*\nfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n    if (typeof(value) === \"string\" && value.length % 2 && value.substring(0, 2) === \"0x\") {\n        return \"0x0\" + value.substring(2);\n    }\n    return value;\n}\n*/\nfunction hexDataLength(data) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        return null;\n    }\n    return (data.length - 2) / 2;\n}\nfunction hexDataSlice(data, offset, endOffset) {\n    if (typeof (data) !== \"string\") {\n        data = hexlify(data);\n    }\n    else if (!isHexString(data) || (data.length % 2)) {\n        bytes_lib_esm_logger.throwArgumentError(\"invalid hexData\", \"value\", data);\n    }\n    offset = 2 + 2 * offset;\n    if (endOffset != null) {\n        return \"0x\" + data.substring(offset, 2 + 2 * endOffset);\n    }\n    return \"0x\" + data.substring(offset);\n}\nfunction hexConcat(items) {\n    let result = \"0x\";\n    items.forEach((item) => {\n        result += hexlify(item).substring(2);\n    });\n    return result;\n}\nfunction hexValue(value) {\n    const trimmed = hexStripZeros(hexlify(value, { hexPad: \"left\" }));\n    if (trimmed === \"0x\") {\n        return \"0x0\";\n    }\n    return trimmed;\n}\nfunction hexStripZeros(value) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    if (!isHexString(value)) {\n        bytes_lib_esm_logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    value = value.substring(2);\n    let offset = 0;\n    while (offset < value.length && value[offset] === \"0\") {\n        offset++;\n    }\n    return \"0x\" + value.substring(offset);\n}\nfunction hexZeroPad(value, length) {\n    if (typeof (value) !== \"string\") {\n        value = hexlify(value);\n    }\n    else if (!isHexString(value)) {\n        bytes_lib_esm_logger.throwArgumentError(\"invalid hex string\", \"value\", value);\n    }\n    if (value.length > 2 * length + 2) {\n        bytes_lib_esm_logger.throwArgumentError(\"value out of range\", \"value\", arguments[1]);\n    }\n    while (value.length < 2 * length + 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    return value;\n}\nfunction splitSignature(signature) {\n    const result = {\n        r: \"0x\",\n        s: \"0x\",\n        _vs: \"0x\",\n        recoveryParam: 0,\n        v: 0,\n        yParityAndS: \"0x\",\n        compact: \"0x\"\n    };\n    if (isBytesLike(signature)) {\n        let bytes = arrayify(signature);\n        // Get the r, s and v\n        if (bytes.length === 64) {\n            // EIP-2098; pull the v from the top bit of s and clear it\n            result.v = 27 + (bytes[32] >> 7);\n            bytes[32] &= 0x7f;\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n        }\n        else if (bytes.length === 65) {\n            result.r = hexlify(bytes.slice(0, 32));\n            result.s = hexlify(bytes.slice(32, 64));\n            result.v = bytes[64];\n        }\n        else {\n            bytes_lib_esm_logger.throwArgumentError(\"invalid signature string\", \"signature\", signature);\n        }\n        // Allow a recid to be used as the v\n        if (result.v < 27) {\n            if (result.v === 0 || result.v === 1) {\n                result.v += 27;\n            }\n            else {\n                bytes_lib_esm_logger.throwArgumentError(\"signature invalid v byte\", \"signature\", signature);\n            }\n        }\n        // Compute recoveryParam from v\n        result.recoveryParam = 1 - (result.v % 2);\n        // Compute _vs from recoveryParam and s\n        if (result.recoveryParam) {\n            bytes[32] |= 0x80;\n        }\n        result._vs = hexlify(bytes.slice(32, 64));\n    }\n    else {\n        result.r = signature.r;\n        result.s = signature.s;\n        result.v = signature.v;\n        result.recoveryParam = signature.recoveryParam;\n        result._vs = signature._vs;\n        // If the _vs is available, use it to populate missing s, v and recoveryParam\n        // and verify non-missing s, v and recoveryParam\n        if (result._vs != null) {\n            const vs = zeroPad(arrayify(result._vs), 32);\n            result._vs = hexlify(vs);\n            // Set or check the recid\n            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);\n            if (result.recoveryParam == null) {\n                result.recoveryParam = recoveryParam;\n            }\n            else if (result.recoveryParam !== recoveryParam) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature recoveryParam mismatch _vs\", \"signature\", signature);\n            }\n            // Set or check the s\n            vs[0] &= 0x7f;\n            const s = hexlify(vs);\n            if (result.s == null) {\n                result.s = s;\n            }\n            else if (result.s !== s) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature v mismatch _vs\", \"signature\", signature);\n            }\n        }\n        // Use recid and v to populate each other\n        if (result.recoveryParam == null) {\n            if (result.v == null) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature missing v and recoveryParam\", \"signature\", signature);\n            }\n            else if (result.v === 0 || result.v === 1) {\n                result.recoveryParam = result.v;\n            }\n            else {\n                result.recoveryParam = 1 - (result.v % 2);\n            }\n        }\n        else {\n            if (result.v == null) {\n                result.v = 27 + result.recoveryParam;\n            }\n            else {\n                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));\n                if (result.recoveryParam !== recId) {\n                    bytes_lib_esm_logger.throwArgumentError(\"signature recoveryParam mismatch v\", \"signature\", signature);\n                }\n            }\n        }\n        if (result.r == null || !isHexString(result.r)) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature missing or invalid r\", \"signature\", signature);\n        }\n        else {\n            result.r = hexZeroPad(result.r, 32);\n        }\n        if (result.s == null || !isHexString(result.s)) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature missing or invalid s\", \"signature\", signature);\n        }\n        else {\n            result.s = hexZeroPad(result.s, 32);\n        }\n        const vs = arrayify(result.s);\n        if (vs[0] >= 128) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature s out of range\", \"signature\", signature);\n        }\n        if (result.recoveryParam) {\n            vs[0] |= 0x80;\n        }\n        const _vs = hexlify(vs);\n        if (result._vs) {\n            if (!isHexString(result._vs)) {\n                bytes_lib_esm_logger.throwArgumentError(\"signature invalid _vs\", \"signature\", signature);\n            }\n            result._vs = hexZeroPad(result._vs, 32);\n        }\n        // Set or check the _vs\n        if (result._vs == null) {\n            result._vs = _vs;\n        }\n        else if (result._vs !== _vs) {\n            bytes_lib_esm_logger.throwArgumentError(\"signature _vs mismatch v and s\", \"signature\", signature);\n        }\n    }\n    result.yParityAndS = result._vs;\n    result.compact = result.r + result.yParityAndS.substring(2);\n    return result;\n}\nfunction joinSignature(signature) {\n    signature = splitSignature(signature);\n    return hexlify(concat([\n        signature.r,\n        signature.s,\n        (signature.recoveryParam ? \"0x1c\" : \"0x1b\")\n    ]));\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bignumber/lib.esm/_version.js\nconst bignumber_lib_esm_version_version = \"bignumber/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\n\n/**\n *  BigNumber\n *\n *  A wrapper around the BN.js object. We use the BN.js library\n *  because it is used by elliptic, so it is required regardless.\n *\n */\n\nvar BN = (bn_default()).BN;\n\n\n\nconst bignumber_logger = new Logger(bignumber_lib_esm_version_version);\nconst _constructorGuard = {};\nconst MAX_SAFE = 0x1fffffffffffff;\nfunction isBigNumberish(value) {\n    return (value != null) && (BigNumber.isBigNumber(value) ||\n        (typeof (value) === \"number\" && (value % 1) === 0) ||\n        (typeof (value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n        isHexString(value) ||\n        (typeof (value) === \"bigint\") ||\n        isBytes(value));\n}\n// Only warn about passing 10 into radix once\nlet _warnedToStringRadix = false;\nclass BigNumber {\n    constructor(constructorGuard, hex) {\n        bignumber_logger.checkNew(new.target, BigNumber);\n        if (constructorGuard !== _constructorGuard) {\n            bignumber_logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new (BigNumber)\"\n            });\n        }\n        this._hex = hex;\n        this._isBigNumber = true;\n        Object.freeze(this);\n    }\n    fromTwos(value) {\n        return toBigNumber(toBN(this).fromTwos(value));\n    }\n    toTwos(value) {\n        return toBigNumber(toBN(this).toTwos(value));\n    }\n    abs() {\n        if (this._hex[0] === \"-\") {\n            return BigNumber.from(this._hex.substring(1));\n        }\n        return this;\n    }\n    add(other) {\n        return toBigNumber(toBN(this).add(toBN(other)));\n    }\n    sub(other) {\n        return toBigNumber(toBN(this).sub(toBN(other)));\n    }\n    div(other) {\n        const o = BigNumber.from(other);\n        if (o.isZero()) {\n            throwFault(\"division-by-zero\", \"div\");\n        }\n        return toBigNumber(toBN(this).div(toBN(other)));\n    }\n    mul(other) {\n        return toBigNumber(toBN(this).mul(toBN(other)));\n    }\n    mod(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"division-by-zero\", \"mod\");\n        }\n        return toBigNumber(toBN(this).umod(value));\n    }\n    pow(other) {\n        const value = toBN(other);\n        if (value.isNeg()) {\n            throwFault(\"negative-power\", \"pow\");\n        }\n        return toBigNumber(toBN(this).pow(value));\n    }\n    and(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"and\");\n        }\n        return toBigNumber(toBN(this).and(value));\n    }\n    or(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"or\");\n        }\n        return toBigNumber(toBN(this).or(value));\n    }\n    xor(other) {\n        const value = toBN(other);\n        if (this.isNegative() || value.isNeg()) {\n            throwFault(\"unbound-bitwise-result\", \"xor\");\n        }\n        return toBigNumber(toBN(this).xor(value));\n    }\n    mask(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"mask\");\n        }\n        return toBigNumber(toBN(this).maskn(value));\n    }\n    shl(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shl\");\n        }\n        return toBigNumber(toBN(this).shln(value));\n    }\n    shr(value) {\n        if (this.isNegative() || value < 0) {\n            throwFault(\"negative-width\", \"shr\");\n        }\n        return toBigNumber(toBN(this).shrn(value));\n    }\n    eq(other) {\n        return toBN(this).eq(toBN(other));\n    }\n    lt(other) {\n        return toBN(this).lt(toBN(other));\n    }\n    lte(other) {\n        return toBN(this).lte(toBN(other));\n    }\n    gt(other) {\n        return toBN(this).gt(toBN(other));\n    }\n    gte(other) {\n        return toBN(this).gte(toBN(other));\n    }\n    isNegative() {\n        return (this._hex[0] === \"-\");\n    }\n    isZero() {\n        return toBN(this).isZero();\n    }\n    toNumber() {\n        try {\n            return toBN(this).toNumber();\n        }\n        catch (error) {\n            throwFault(\"overflow\", \"toNumber\", this.toString());\n        }\n        return null;\n    }\n    toBigInt() {\n        try {\n            return BigInt(this.toString());\n        }\n        catch (e) { }\n        return bignumber_logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\n            value: this.toString()\n        });\n    }\n    toString() {\n        // Lots of people expect this, which we do not support, so check (See: #889)\n        if (arguments.length > 0) {\n            if (arguments[0] === 10) {\n                if (!_warnedToStringRadix) {\n                    _warnedToStringRadix = true;\n                    bignumber_logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\n                }\n            }\n            else if (arguments[0] === 16) {\n                bignumber_logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n            else {\n                bignumber_logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, {});\n            }\n        }\n        return toBN(this).toString(10);\n    }\n    toHexString() {\n        return this._hex;\n    }\n    toJSON(key) {\n        return { type: \"BigNumber\", hex: this.toHexString() };\n    }\n    static from(value) {\n        if (value instanceof BigNumber) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n                return new BigNumber(_constructorGuard, toHex(value));\n            }\n            if (value.match(/^-?[0-9]+$/)) {\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\n            }\n            return bignumber_logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\n        }\n        if (typeof (value) === \"number\") {\n            if (value % 1) {\n                throwFault(\"underflow\", \"BigNumber.from\", value);\n            }\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n                throwFault(\"overflow\", \"BigNumber.from\", value);\n            }\n            return BigNumber.from(String(value));\n        }\n        const anyValue = value;\n        if (typeof (anyValue) === \"bigint\") {\n            return BigNumber.from(anyValue.toString());\n        }\n        if (isBytes(anyValue)) {\n            return BigNumber.from(hexlify(anyValue));\n        }\n        if (anyValue) {\n            // Hexable interface (takes priority)\n            if (anyValue.toHexString) {\n                const hex = anyValue.toHexString();\n                if (typeof (hex) === \"string\") {\n                    return BigNumber.from(hex);\n                }\n            }\n            else {\n                // For now, handle legacy JSON-ified values (goes away in v6)\n                let hex = anyValue._hex;\n                // New-form JSON\n                if (hex == null && anyValue.type === \"BigNumber\") {\n                    hex = anyValue.hex;\n                }\n                if (typeof (hex) === \"string\") {\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\n                        return BigNumber.from(hex);\n                    }\n                }\n            }\n        }\n        return bignumber_logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\n    }\n    static isBigNumber(value) {\n        return !!(value && value._isBigNumber);\n    }\n}\n// Normalize the hex string\nfunction toHex(value) {\n    // For BN, call on the hex string\n    if (typeof (value) !== \"string\") {\n        return toHex(value.toString(16));\n    }\n    // If negative, prepend the negative sign to the normalized positive value\n    if (value[0] === \"-\") {\n        // Strip off the negative sign\n        value = value.substring(1);\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\n        if (value[0] === \"-\") {\n            bignumber_logger.throwArgumentError(\"invalid hex\", \"value\", value);\n        }\n        // Call toHex on the positive component\n        value = toHex(value);\n        // Do not allow \"-0x00\"\n        if (value === \"0x00\") {\n            return value;\n        }\n        // Negate the value\n        return \"-\" + value;\n    }\n    // Add a \"0x\" prefix if missing\n    if (value.substring(0, 2) !== \"0x\") {\n        value = \"0x\" + value;\n    }\n    // Normalize zero\n    if (value === \"0x\") {\n        return \"0x00\";\n    }\n    // Make the string even length\n    if (value.length % 2) {\n        value = \"0x0\" + value.substring(2);\n    }\n    // Trim to smallest even-length string\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\n        value = \"0x\" + value.substring(4);\n    }\n    return value;\n}\nfunction toBigNumber(value) {\n    return BigNumber.from(toHex(value));\n}\nfunction toBN(value) {\n    const hex = BigNumber.from(value).toHexString();\n    if (hex[0] === \"-\") {\n        return (new BN(\"-\" + hex.substring(3), 16));\n    }\n    return new BN(hex.substring(2), 16);\n}\nfunction throwFault(fault, operation, value) {\n    const params = { fault: fault, operation: operation };\n    if (value != null) {\n        params.value = value;\n    }\n    return bignumber_logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\n}\n// value should have no prefix\nfunction _base36To16(value) {\n    return (new BN(value, 36)).toString(16);\n}\n// value should have no prefix\nfunction _base16To36(value) {\n    return (new BN(value, 16)).toString(36);\n}\n//# sourceMappingURL=bignumber.js.map\n// EXTERNAL MODULE: ./node_modules/js-sha3/src/sha3.js\nvar sha3 = __webpack_require__(\"./node_modules/js-sha3/src/sha3.js\");\nvar sha3_default = /*#__PURE__*/__webpack_require__.n(sha3);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/keccak256/lib.esm/index.js\n\n\n\nfunction keccak256(data) {\n    return '0x' + sha3_default().keccak_256(arrayify(data));\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/rlp/lib.esm/_version.js\nconst rlp_lib_esm_version_version = \"rlp/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/rlp/lib.esm/index.js\n\n//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\nconst rlp_lib_esm_logger = new Logger(rlp_lib_esm_version_version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!isBytesLike(object)) {\n        rlp_lib_esm_logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call(arrayify(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nfunction encode(object) {\n    return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            rlp_lib_esm_logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        rlp_lib_esm_logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            rlp_lib_esm_logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            rlp_lib_esm_logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            rlp_lib_esm_logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\nfunction decode(data) {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        rlp_lib_esm_logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/address/lib.esm/_version.js\nconst address_lib_esm_version_version = \"address/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/address/lib.esm/index.js\n\n\n\n\n\n\n\nconst address_lib_esm_logger = new Logger(address_lib_esm_version_version);\nfunction getChecksumAddress(address) {\n    if (!isHexString(address, 20)) {\n        address_lib_esm_logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = arrayify(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// Shims for environments that are missing some required constants and functions\nconst MAX_SAFE_INTEGER = 0x1fffffffffffff;\nfunction log10(x) {\n    if (Math.log10) {\n        return Math.log10(x);\n    }\n    return Math.log(x) / Math.LN10;\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\nconst safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nfunction getAddress(address) {\n    let result = null;\n    if (typeof (address) !== \"string\") {\n        address_lib_esm_logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (address.substring(0, 2) !== \"0x\") {\n            address = \"0x\" + address;\n        }\n        result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n            address_lib_esm_logger.throwArgumentError(\"bad address checksum\", \"address\", address);\n        }\n        // Maybe ICAP? (we only support direct mode)\n    }\n    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        if (address.substring(2, 4) !== ibanChecksum(address)) {\n            address_lib_esm_logger.throwArgumentError(\"bad icap checksum\", \"address\", address);\n        }\n        result = _base36To16(address.substring(4));\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        result = getChecksumAddress(\"0x\" + result);\n    }\n    else {\n        address_lib_esm_logger.throwArgumentError(\"invalid address\", \"address\", address);\n    }\n    return result;\n}\nfunction isAddress(address) {\n    try {\n        getAddress(address);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nfunction getIcapAddress(address) {\n    let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\nfunction getContractAddress(transaction) {\n    let from = null;\n    try {\n        from = getAddress(transaction.from);\n    }\n    catch (error) {\n        address_lib_esm_logger.throwArgumentError(\"missing from address\", \"transaction\", transaction);\n    }\n    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));\n    return getAddress(hexDataSlice(keccak256(encode([from, nonce])), 12));\n}\nfunction getCreate2Address(from, salt, initCodeHash) {\n    if (hexDataLength(salt) !== 32) {\n        address_lib_esm_logger.throwArgumentError(\"salt must be 32 bytes\", \"salt\", salt);\n    }\n    if (hexDataLength(initCodeHash) !== 32) {\n        address_lib_esm_logger.throwArgumentError(\"initCodeHash must be 32 bytes\", \"initCodeHash\", initCodeHash);\n    }\n    return getAddress(hexDataSlice(keccak256(concat([\"0xff\", getAddress(from), salt, initCodeHash])), 12));\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/_version.js\nconst hash_lib_esm_version_version = \"hash/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/strings/lib.esm/_version.js\nconst strings_lib_esm_version_version = \"strings/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/strings/lib.esm/utf8.js\n\n\n\n\nconst utf8_logger = new Logger(strings_lib_esm_version_version);\n///////////////////////////////\nvar UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nvar Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return utf8_logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nconst Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = arrayify(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nfunction toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        utf8_logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return arrayify(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nfunction _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nfunction toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nfunction toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/id.js\n\n\nfunction id(text) {\n    return keccak256(toUtf8Bytes(text));\n}\n//# sourceMappingURL=id.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/typed-data.js\nvar typed_data_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\nconst typed_data_logger = new Logger(hash_lib_esm_version_version);\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            typed_data_logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return typed_data_logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return typed_data_logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return typed_data_logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                typed_data_logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    typed_data_logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                typed_data_logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    typed_data_logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nclass TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    typed_data_logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    typed_data_logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    typed_data_logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            typed_data_logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            typed_data_logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                typed_data_logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    typed_data_logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return typed_data_logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            typed_data_logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                typed_data_logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return typed_data_logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                typed_data_logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return typed_data_awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            typed_data_logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            typed_data_logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return typed_data_logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n//# sourceMappingURL=typed-data.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/constants/lib.esm/bignumbers.js\n\nconst bignumbers_NegativeOne = ( /*#__PURE__*/BigNumber.from(-1));\nconst bignumbers_Zero = ( /*#__PURE__*/BigNumber.from(0));\nconst bignumbers_One = ( /*#__PURE__*/BigNumber.from(1));\nconst Two = ( /*#__PURE__*/BigNumber.from(2));\nconst WeiPerEther = ( /*#__PURE__*/BigNumber.from(\"1000000000000000000\"));\nconst bignumbers_MaxUint256 = ( /*#__PURE__*/BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\nconst MinInt256 = ( /*#__PURE__*/BigNumber.from(\"-0x8000000000000000000000000000000000000000000000000000000000000000\"));\nconst MaxInt256 = ( /*#__PURE__*/BigNumber.from(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"));\n\n//# sourceMappingURL=bignumbers.js.map\n// EXTERNAL MODULE: ./node_modules/hash.js/lib/hash.js\nvar hash = __webpack_require__(\"./node_modules/hash.js/lib/hash.js\");\nvar hash_default = /*#__PURE__*/__webpack_require__.n(hash);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, basedir, module) {\n\treturn module = {\n\t\tpath: basedir,\n\t\texports: {},\n\t\trequire: function (path, base) {\n\t\t\treturn commonjsRequire(path, (base === undefined || base === null) ? module.path : base);\n\t\t}\n\t}, fn(module, module.exports), module.exports;\n}\n\nfunction getDefaultExportFromNamespaceIfPresent (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;\n}\n\nfunction getDefaultExportFromNamespaceIfNotNamed (n) {\n\treturn n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;\n}\n\nfunction getAugmentedNamespace(n) {\n\tif (n.__esModule) return n;\n\tvar a = Object.defineProperty({}, '__esModule', {value: true});\n\tObject.keys(n).forEach(function (k) {\n\t\tvar d = Object.getOwnPropertyDescriptor(n, k);\n\t\tObject.defineProperty(a, k, d.get ? d : {\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn n[k];\n\t\t\t}\n\t\t});\n\t});\n\treturn a;\n}\n\nfunction commonjsRequire () {\n\tthrow new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nvar minimalisticAssert = assert;\n\nfunction assert(val, msg) {\n  if (!val)\n    throw new Error(msg || 'Assertion failed');\n}\n\nassert.equal = function assertEqual(l, r, msg) {\n  if (l != r)\n    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));\n};\n\nvar utils_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\nfunction toArray(msg, enc) {\n  if (Array.isArray(msg))\n    return msg.slice();\n  if (!msg)\n    return [];\n  var res = [];\n  if (typeof msg !== 'string') {\n    for (var i = 0; i < msg.length; i++)\n      res[i] = msg[i] | 0;\n    return res;\n  }\n  if (enc === 'hex') {\n    msg = msg.replace(/[^a-z0-9]+/ig, '');\n    if (msg.length % 2 !== 0)\n      msg = '0' + msg;\n    for (var i = 0; i < msg.length; i += 2)\n      res.push(parseInt(msg[i] + msg[i + 1], 16));\n  } else {\n    for (var i = 0; i < msg.length; i++) {\n      var c = msg.charCodeAt(i);\n      var hi = c >> 8;\n      var lo = c & 0xff;\n      if (hi)\n        res.push(hi, lo);\n      else\n        res.push(lo);\n    }\n  }\n  return res;\n}\nutils.toArray = toArray;\n\nfunction zero2(word) {\n  if (word.length === 1)\n    return '0' + word;\n  else\n    return word;\n}\nutils.zero2 = zero2;\n\nfunction toHex(msg) {\n  var res = '';\n  for (var i = 0; i < msg.length; i++)\n    res += zero2(msg[i].toString(16));\n  return res;\n}\nutils.toHex = toHex;\n\nutils.encode = function encode(arr, enc) {\n  if (enc === 'hex')\n    return toHex(arr);\n  else\n    return arr;\n};\n});\n\nvar utils_1$1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar utils = exports;\n\n\n\n\nutils.assert = minimalisticAssert;\nutils.toArray = utils_1.toArray;\nutils.zero2 = utils_1.zero2;\nutils.toHex = utils_1.toHex;\nutils.encode = utils_1.encode;\n\n// Represent num in a w-NAF form\nfunction getNAF(num, w, bits) {\n  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n  naf.fill(0);\n\n  var ws = 1 << (w + 1);\n  var k = num.clone();\n\n  for (var i = 0; i < naf.length; i++) {\n    var z;\n    var mod = k.andln(ws - 1);\n    if (k.isOdd()) {\n      if (mod > (ws >> 1) - 1)\n        z = (ws >> 1) - mod;\n      else\n        z = mod;\n      k.isubn(z);\n    } else {\n      z = 0;\n    }\n\n    naf[i] = z;\n    k.iushrn(1);\n  }\n\n  return naf;\n}\nutils.getNAF = getNAF;\n\n// Represent k1, k2 in a Joint Sparse Form\nfunction getJSF(k1, k2) {\n  var jsf = [\n    [],\n    [],\n  ];\n\n  k1 = k1.clone();\n  k2 = k2.clone();\n  var d1 = 0;\n  var d2 = 0;\n  var m8;\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase\n    var m14 = (k1.andln(3) + d1) & 3;\n    var m24 = (k2.andln(3) + d2) & 3;\n    if (m14 === 3)\n      m14 = -1;\n    if (m24 === 3)\n      m24 = -1;\n    var u1;\n    if ((m14 & 1) === 0) {\n      u1 = 0;\n    } else {\n      m8 = (k1.andln(7) + d1) & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2)\n        u1 = -m14;\n      else\n        u1 = m14;\n    }\n    jsf[0].push(u1);\n\n    var u2;\n    if ((m24 & 1) === 0) {\n      u2 = 0;\n    } else {\n      m8 = (k2.andln(7) + d2) & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2)\n        u2 = -m24;\n      else\n        u2 = m24;\n    }\n    jsf[1].push(u2);\n\n    // Second phase\n    if (2 * d1 === u1 + 1)\n      d1 = 1 - d1;\n    if (2 * d2 === u2 + 1)\n      d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n  }\n\n  return jsf;\n}\nutils.getJSF = getJSF;\n\nfunction cachedProperty(obj, name, computer) {\n  var key = '_' + name;\n  obj.prototype[name] = function cachedProperty() {\n    return this[key] !== undefined ? this[key] :\n      this[key] = computer.call(this);\n  };\n}\nutils.cachedProperty = cachedProperty;\n\nfunction parseBytes(bytes) {\n  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :\n    bytes;\n}\nutils.parseBytes = parseBytes;\n\nfunction intFromLE(bytes) {\n  return new (bn_default())(bytes, 'hex', 'le');\n}\nutils.intFromLE = intFromLE;\n});\n\n'use strict';\n\n\n\nvar getNAF = utils_1$1.getNAF;\nvar getJSF = utils_1$1.getJSF;\nvar assert$1 = utils_1$1.assert;\n\nfunction BaseCurve(type, conf) {\n  this.type = type;\n  this.p = new (bn_default())(conf.p, 16);\n\n  // Use Montgomery, when there is no fast reduction for the prime\n  this.red = conf.prime ? bn_default().red(conf.prime) : bn_default().mont(this.p);\n\n  // Useful for many curves\n  this.zero = new (bn_default())(0).toRed(this.red);\n  this.one = new (bn_default())(1).toRed(this.red);\n  this.two = new (bn_default())(2).toRed(this.red);\n\n  // Curve configuration, optional\n  this.n = conf.n && new (bn_default())(conf.n, 16);\n  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n  // Temporary arrays\n  this._wnafT1 = new Array(4);\n  this._wnafT2 = new Array(4);\n  this._wnafT3 = new Array(4);\n  this._wnafT4 = new Array(4);\n\n  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n  // Generalized Greg Maxwell's trick\n  var adjustCount = this.n && this.p.div(this.n);\n  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n    this.redN = null;\n  } else {\n    this._maxwellTrick = true;\n    this.redN = this.n.toRed(this.red);\n  }\n}\nvar base = BaseCurve;\n\nBaseCurve.prototype.point = function point() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype.validate = function validate() {\n  throw new Error('Not implemented');\n};\n\nBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n  assert$1(p.precomputed);\n  var doubles = p._getDoubles();\n\n  var naf = getNAF(k, 1, this._bitLength);\n  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n  I /= 3;\n\n  // Translate into more windowed form\n  var repr = [];\n  var j;\n  var nafW;\n  for (j = 0; j < naf.length; j += doubles.step) {\n    nafW = 0;\n    for (var l = j + doubles.step - 1; l >= j; l--)\n      nafW = (nafW << 1) + naf[l];\n    repr.push(nafW);\n  }\n\n  var a = this.jpoint(null, null, null);\n  var b = this.jpoint(null, null, null);\n  for (var i = I; i > 0; i--) {\n    for (j = 0; j < repr.length; j++) {\n      nafW = repr[j];\n      if (nafW === i)\n        b = b.mixedAdd(doubles.points[j]);\n      else if (nafW === -i)\n        b = b.mixedAdd(doubles.points[j].neg());\n    }\n    a = a.add(b);\n  }\n  return a.toP();\n};\n\nBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n  var w = 4;\n\n  // Precompute window\n  var nafPoints = p._getNAFPoints(w);\n  w = nafPoints.wnd;\n  var wnd = nafPoints.points;\n\n  // Get NAF form\n  var naf = getNAF(k, w, this._bitLength);\n\n  // Add `this`*(N+1) for every w-NAF index\n  var acc = this.jpoint(null, null, null);\n  for (var i = naf.length - 1; i >= 0; i--) {\n    // Count zeroes\n    for (var l = 0; i >= 0 && naf[i] === 0; i--)\n      l++;\n    if (i >= 0)\n      l++;\n    acc = acc.dblp(l);\n\n    if (i < 0)\n      break;\n    var z = naf[i];\n    assert$1(z !== 0);\n    if (p.type === 'affine') {\n      // J +- P\n      if (z > 0)\n        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n    } else {\n      // J +- J\n      if (z > 0)\n        acc = acc.add(wnd[(z - 1) >> 1]);\n      else\n        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n    }\n  }\n  return p.type === 'affine' ? acc.toP() : acc;\n};\n\nBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n  points,\n  coeffs,\n  len,\n  jacobianResult) {\n  var wndWidth = this._wnafT1;\n  var wnd = this._wnafT2;\n  var naf = this._wnafT3;\n\n  // Fill all arrays\n  var max = 0;\n  var i;\n  var j;\n  var p;\n  for (i = 0; i < len; i++) {\n    p = points[i];\n    var nafPoints = p._getNAFPoints(defW);\n    wndWidth[i] = nafPoints.wnd;\n    wnd[i] = nafPoints.points;\n  }\n\n  // Comb small window NAFs\n  for (i = len - 1; i >= 1; i -= 2) {\n    var a = i - 1;\n    var b = i;\n    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n      max = Math.max(naf[a].length, max);\n      max = Math.max(naf[b].length, max);\n      continue;\n    }\n\n    var comb = [\n      points[a], /* 1 */\n      null, /* 3 */\n      null, /* 5 */\n      points[b], /* 7 */\n    ];\n\n    // Try to avoid Projective points, if possible\n    if (points[a].y.cmp(points[b].y) === 0) {\n      comb[1] = points[a].add(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].add(points[b].neg());\n    } else {\n      comb[1] = points[a].toJ().mixedAdd(points[b]);\n      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n    }\n\n    var index = [\n      -3, /* -1 -1 */\n      -1, /* -1 0 */\n      -5, /* -1 1 */\n      -7, /* 0 -1 */\n      0, /* 0 0 */\n      7, /* 0 1 */\n      5, /* 1 -1 */\n      1, /* 1 0 */\n      3,  /* 1 1 */\n    ];\n\n    var jsf = getJSF(coeffs[a], coeffs[b]);\n    max = Math.max(jsf[0].length, max);\n    naf[a] = new Array(max);\n    naf[b] = new Array(max);\n    for (j = 0; j < max; j++) {\n      var ja = jsf[0][j] | 0;\n      var jb = jsf[1][j] | 0;\n\n      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n      naf[b][j] = 0;\n      wnd[a] = comb;\n    }\n  }\n\n  var acc = this.jpoint(null, null, null);\n  var tmp = this._wnafT4;\n  for (i = max; i >= 0; i--) {\n    var k = 0;\n\n    while (i >= 0) {\n      var zero = true;\n      for (j = 0; j < len; j++) {\n        tmp[j] = naf[j][i] | 0;\n        if (tmp[j] !== 0)\n          zero = false;\n      }\n      if (!zero)\n        break;\n      k++;\n      i--;\n    }\n    if (i >= 0)\n      k++;\n    acc = acc.dblp(k);\n    if (i < 0)\n      break;\n\n    for (j = 0; j < len; j++) {\n      var z = tmp[j];\n      p;\n      if (z === 0)\n        continue;\n      else if (z > 0)\n        p = wnd[j][(z - 1) >> 1];\n      else if (z < 0)\n        p = wnd[j][(-z - 1) >> 1].neg();\n\n      if (p.type === 'affine')\n        acc = acc.mixedAdd(p);\n      else\n        acc = acc.add(p);\n    }\n  }\n  // Zeroify references\n  for (i = 0; i < len; i++)\n    wnd[i] = null;\n\n  if (jacobianResult)\n    return acc;\n  else\n    return acc.toP();\n};\n\nfunction BasePoint(curve, type) {\n  this.curve = curve;\n  this.type = type;\n  this.precomputed = null;\n}\nBaseCurve.BasePoint = BasePoint;\n\nBasePoint.prototype.eq = function eq(/*other*/) {\n  throw new Error('Not implemented');\n};\n\nBasePoint.prototype.validate = function validate() {\n  return this.curve.validate(this);\n};\n\nBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n  bytes = utils_1$1.toArray(bytes, enc);\n\n  var len = this.p.byteLength();\n\n  // uncompressed, hybrid-odd, hybrid-even\n  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n      bytes.length - 1 === 2 * len) {\n    if (bytes[0] === 0x06)\n      assert$1(bytes[bytes.length - 1] % 2 === 0);\n    else if (bytes[0] === 0x07)\n      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n    var res =  this.point(bytes.slice(1, 1 + len),\n      bytes.slice(1 + len, 1 + 2 * len));\n\n    return res;\n  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n              bytes.length - 1 === len) {\n    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n  }\n  throw new Error('Unknown point format');\n};\n\nBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n  return this.encode(enc, true);\n};\n\nBasePoint.prototype._encode = function _encode(compact) {\n  var len = this.curve.p.byteLength();\n  var x = this.getX().toArray('be', len);\n\n  if (compact)\n    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n  return [ 0x04 ].concat(x, this.getY().toArray('be', len));\n};\n\nBasePoint.prototype.encode = function encode(enc, compact) {\n  return utils_1$1.encode(this._encode(compact), enc);\n};\n\nBasePoint.prototype.precompute = function precompute(power) {\n  if (this.precomputed)\n    return this;\n\n  var precomputed = {\n    doubles: null,\n    naf: null,\n    beta: null,\n  };\n  precomputed.naf = this._getNAFPoints(8);\n  precomputed.doubles = this._getDoubles(4, power);\n  precomputed.beta = this._getBeta();\n  this.precomputed = precomputed;\n\n  return this;\n};\n\nBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n  if (!this.precomputed)\n    return false;\n\n  var doubles = this.precomputed.doubles;\n  if (!doubles)\n    return false;\n\n  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n};\n\nBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n  if (this.precomputed && this.precomputed.doubles)\n    return this.precomputed.doubles;\n\n  var doubles = [ this ];\n  var acc = this;\n  for (var i = 0; i < power; i += step) {\n    for (var j = 0; j < step; j++)\n      acc = acc.dbl();\n    doubles.push(acc);\n  }\n  return {\n    step: step,\n    points: doubles,\n  };\n};\n\nBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n  if (this.precomputed && this.precomputed.naf)\n    return this.precomputed.naf;\n\n  var res = [ this ];\n  var max = (1 << wnd) - 1;\n  var dbl = max === 1 ? null : this.dbl();\n  for (var i = 1; i < max; i++)\n    res[i] = res[i - 1].add(dbl);\n  return {\n    wnd: wnd,\n    points: res,\n  };\n};\n\nBasePoint.prototype._getBeta = function _getBeta() {\n  return null;\n};\n\nBasePoint.prototype.dblp = function dblp(k) {\n  var r = this;\n  for (var i = 0; i < k; i++)\n    r = r.dbl();\n  return r;\n};\n\nvar inherits_browser = createCommonjsModule(function (module) {\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor;\n      var TempCtor = function () {};\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    }\n  };\n}\n});\n\n'use strict';\n\n\n\n\n\n\nvar assert$2 = utils_1$1.assert;\n\nfunction ShortCurve(conf) {\n  base.call(this, 'short', conf);\n\n  this.a = new (bn_default())(conf.a, 16).toRed(this.red);\n  this.b = new (bn_default())(conf.b, 16).toRed(this.red);\n  this.tinv = this.two.redInvm();\n\n  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n  // If the curve is endomorphic, precalculate beta and lambda\n  this.endo = this._getEndomorphism(conf);\n  this._endoWnafT1 = new Array(4);\n  this._endoWnafT2 = new Array(4);\n}\ninherits_browser(ShortCurve, base);\nvar short_1 = ShortCurve;\n\nShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n  // No efficient endomorphism\n  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n    return;\n\n  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n  var beta;\n  var lambda;\n  if (conf.beta) {\n    beta = new (bn_default())(conf.beta, 16).toRed(this.red);\n  } else {\n    var betas = this._getEndoRoots(this.p);\n    // Choose the smallest beta\n    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n    beta = beta.toRed(this.red);\n  }\n  if (conf.lambda) {\n    lambda = new (bn_default())(conf.lambda, 16);\n  } else {\n    // Choose the lambda that is matching selected beta\n    var lambdas = this._getEndoRoots(this.n);\n    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n      lambda = lambdas[0];\n    } else {\n      lambda = lambdas[1];\n      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n    }\n  }\n\n  // Get basis vectors, used for balanced length-two representation\n  var basis;\n  if (conf.basis) {\n    basis = conf.basis.map(function(vec) {\n      return {\n        a: new (bn_default())(vec.a, 16),\n        b: new (bn_default())(vec.b, 16),\n      };\n    });\n  } else {\n    basis = this._getEndoBasis(lambda);\n  }\n\n  return {\n    beta: beta,\n    lambda: lambda,\n    basis: basis,\n  };\n};\n\nShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n  // Find roots of for x^2 + x + 1 in F\n  // Root = (-1 +- Sqrt(-3)) / 2\n  //\n  var red = num === this.p ? this.red : bn_default().mont(num);\n  var tinv = new (bn_default())(2).toRed(red).redInvm();\n  var ntinv = tinv.redNeg();\n\n  var s = new (bn_default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n  var l1 = ntinv.redAdd(s).fromRed();\n  var l2 = ntinv.redSub(s).fromRed();\n  return [ l1, l2 ];\n};\n\nShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n  // aprxSqrt >= sqrt(this.n)\n  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n  // 3.74\n  // Run EGCD, until r(L + 1) < aprxSqrt\n  var u = lambda;\n  var v = this.n.clone();\n  var x1 = new (bn_default())(1);\n  var y1 = new (bn_default())(0);\n  var x2 = new (bn_default())(0);\n  var y2 = new (bn_default())(1);\n\n  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n  var a0;\n  var b0;\n  // First vector\n  var a1;\n  var b1;\n  // Second vector\n  var a2;\n  var b2;\n\n  var prevR;\n  var i = 0;\n  var r;\n  var x;\n  while (u.cmpn(0) !== 0) {\n    var q = v.div(u);\n    r = v.sub(q.mul(u));\n    x = x2.sub(q.mul(x1));\n    var y = y2.sub(q.mul(y1));\n\n    if (!a1 && r.cmp(aprxSqrt) < 0) {\n      a0 = prevR.neg();\n      b0 = x1;\n      a1 = r.neg();\n      b1 = x;\n    } else if (a1 && ++i === 2) {\n      break;\n    }\n    prevR = r;\n\n    v = u;\n    u = r;\n    x2 = x1;\n    x1 = x;\n    y2 = y1;\n    y1 = y;\n  }\n  a2 = r.neg();\n  b2 = x;\n\n  var len1 = a1.sqr().add(b1.sqr());\n  var len2 = a2.sqr().add(b2.sqr());\n  if (len2.cmp(len1) >= 0) {\n    a2 = a0;\n    b2 = b0;\n  }\n\n  // Normalize signs\n  if (a1.negative) {\n    a1 = a1.neg();\n    b1 = b1.neg();\n  }\n  if (a2.negative) {\n    a2 = a2.neg();\n    b2 = b2.neg();\n  }\n\n  return [\n    { a: a1, b: b1 },\n    { a: a2, b: b2 },\n  ];\n};\n\nShortCurve.prototype._endoSplit = function _endoSplit(k) {\n  var basis = this.endo.basis;\n  var v1 = basis[0];\n  var v2 = basis[1];\n\n  var c1 = v2.b.mul(k).divRound(this.n);\n  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n  var p1 = c1.mul(v1.a);\n  var p2 = c2.mul(v2.a);\n  var q1 = c1.mul(v1.b);\n  var q2 = c2.mul(v2.b);\n\n  // Calculate answer\n  var k1 = k.sub(p1).sub(p2);\n  var k2 = q1.add(q2).neg();\n  return { k1: k1, k2: k2 };\n};\n\nShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n  x = new (bn_default())(x, 16);\n  if (!x.red)\n    x = x.toRed(this.red);\n\n  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n  var y = y2.redSqrt();\n  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n    throw new Error('invalid point');\n\n  // XXX Is there any way to tell if the number is odd without converting it\n  // to non-red form?\n  var isOdd = y.fromRed().isOdd();\n  if (odd && !isOdd || !odd && isOdd)\n    y = y.redNeg();\n\n  return this.point(x, y);\n};\n\nShortCurve.prototype.validate = function validate(point) {\n  if (point.inf)\n    return true;\n\n  var x = point.x;\n  var y = point.y;\n\n  var ax = this.a.redMul(x);\n  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n};\n\nShortCurve.prototype._endoWnafMulAdd =\n    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n      var npoints = this._endoWnafT1;\n      var ncoeffs = this._endoWnafT2;\n      for (var i = 0; i < points.length; i++) {\n        var split = this._endoSplit(coeffs[i]);\n        var p = points[i];\n        var beta = p._getBeta();\n\n        if (split.k1.negative) {\n          split.k1.ineg();\n          p = p.neg(true);\n        }\n        if (split.k2.negative) {\n          split.k2.ineg();\n          beta = beta.neg(true);\n        }\n\n        npoints[i * 2] = p;\n        npoints[i * 2 + 1] = beta;\n        ncoeffs[i * 2] = split.k1;\n        ncoeffs[i * 2 + 1] = split.k2;\n      }\n      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n      // Clean-up references to points and coefficients\n      for (var j = 0; j < i * 2; j++) {\n        npoints[j] = null;\n        ncoeffs[j] = null;\n      }\n      return res;\n    };\n\nfunction Point(curve, x, y, isRed) {\n  base.BasePoint.call(this, curve, 'affine');\n  if (x === null && y === null) {\n    this.x = null;\n    this.y = null;\n    this.inf = true;\n  } else {\n    this.x = new (bn_default())(x, 16);\n    this.y = new (bn_default())(y, 16);\n    // Force redgomery representation when loading from JSON\n    if (isRed) {\n      this.x.forceRed(this.curve.red);\n      this.y.forceRed(this.curve.red);\n    }\n    if (!this.x.red)\n      this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red)\n      this.y = this.y.toRed(this.curve.red);\n    this.inf = false;\n  }\n}\ninherits_browser(Point, base.BasePoint);\n\nShortCurve.prototype.point = function point(x, y, isRed) {\n  return new Point(this, x, y, isRed);\n};\n\nShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n  return Point.fromJSON(this, obj, red);\n};\n\nPoint.prototype._getBeta = function _getBeta() {\n  if (!this.curve.endo)\n    return;\n\n  var pre = this.precomputed;\n  if (pre && pre.beta)\n    return pre.beta;\n\n  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n  if (pre) {\n    var curve = this.curve;\n    var endoMul = function(p) {\n      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n    };\n    pre.beta = beta;\n    beta.precomputed = {\n      beta: null,\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(endoMul),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(endoMul),\n      },\n    };\n  }\n  return beta;\n};\n\nPoint.prototype.toJSON = function toJSON() {\n  if (!this.precomputed)\n    return [ this.x, this.y ];\n\n  return [ this.x, this.y, this.precomputed && {\n    doubles: this.precomputed.doubles && {\n      step: this.precomputed.doubles.step,\n      points: this.precomputed.doubles.points.slice(1),\n    },\n    naf: this.precomputed.naf && {\n      wnd: this.precomputed.naf.wnd,\n      points: this.precomputed.naf.points.slice(1),\n    },\n  } ];\n};\n\nPoint.fromJSON = function fromJSON(curve, obj, red) {\n  if (typeof obj === 'string')\n    obj = JSON.parse(obj);\n  var res = curve.point(obj[0], obj[1], red);\n  if (!obj[2])\n    return res;\n\n  function obj2point(obj) {\n    return curve.point(obj[0], obj[1], red);\n  }\n\n  var pre = obj[2];\n  res.precomputed = {\n    beta: null,\n    doubles: pre.doubles && {\n      step: pre.doubles.step,\n      points: [ res ].concat(pre.doubles.points.map(obj2point)),\n    },\n    naf: pre.naf && {\n      wnd: pre.naf.wnd,\n      points: [ res ].concat(pre.naf.points.map(obj2point)),\n    },\n  };\n  return res;\n};\n\nPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC Point Infinity>';\n  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +\n      ' y: ' + this.y.fromRed().toString(16, 2) + '>';\n};\n\nPoint.prototype.isInfinity = function isInfinity() {\n  return this.inf;\n};\n\nPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.inf)\n    return p;\n\n  // P + O = P\n  if (p.inf)\n    return this;\n\n  // P + P = 2P\n  if (this.eq(p))\n    return this.dbl();\n\n  // P + (-P) = O\n  if (this.neg().eq(p))\n    return this.curve.point(null, null);\n\n  // P + Q = O\n  if (this.x.cmp(p.x) === 0)\n    return this.curve.point(null, null);\n\n  var c = this.y.redSub(p.y);\n  if (c.cmpn(0) !== 0)\n    c = c.redMul(this.x.redSub(p.x).redInvm());\n  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.dbl = function dbl() {\n  if (this.inf)\n    return this;\n\n  // 2P = O\n  var ys1 = this.y.redAdd(this.y);\n  if (ys1.cmpn(0) === 0)\n    return this.curve.point(null, null);\n\n  var a = this.curve.a;\n\n  var x2 = this.x.redSqr();\n  var dyinv = ys1.redInvm();\n  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n  return this.curve.point(nx, ny);\n};\n\nPoint.prototype.getX = function getX() {\n  return this.x.fromRed();\n};\n\nPoint.prototype.getY = function getY() {\n  return this.y.fromRed();\n};\n\nPoint.prototype.mul = function mul(k) {\n  k = new (bn_default())(k, 16);\n  if (this.isInfinity())\n    return this;\n  else if (this._hasDoubles(k))\n    return this.curve._fixedNafMul(this, k);\n  else if (this.curve.endo)\n    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n  else\n    return this.curve._wnafMul(this, k);\n};\n\nPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n};\n\nPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n  var points = [ this, p2 ];\n  var coeffs = [ k1, k2 ];\n  if (this.curve.endo)\n    return this.curve._endoWnafMulAdd(points, coeffs, true);\n  else\n    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n};\n\nPoint.prototype.eq = function eq(p) {\n  return this === p ||\n         this.inf === p.inf &&\n             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n};\n\nPoint.prototype.neg = function neg(_precompute) {\n  if (this.inf)\n    return this;\n\n  var res = this.curve.point(this.x, this.y.redNeg());\n  if (_precompute && this.precomputed) {\n    var pre = this.precomputed;\n    var negate = function(p) {\n      return p.neg();\n    };\n    res.precomputed = {\n      naf: pre.naf && {\n        wnd: pre.naf.wnd,\n        points: pre.naf.points.map(negate),\n      },\n      doubles: pre.doubles && {\n        step: pre.doubles.step,\n        points: pre.doubles.points.map(negate),\n      },\n    };\n  }\n  return res;\n};\n\nPoint.prototype.toJ = function toJ() {\n  if (this.inf)\n    return this.curve.jpoint(null, null, null);\n\n  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n  return res;\n};\n\nfunction JPoint(curve, x, y, z) {\n  base.BasePoint.call(this, curve, 'jacobian');\n  if (x === null && y === null && z === null) {\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = new (bn_default())(0);\n  } else {\n    this.x = new (bn_default())(x, 16);\n    this.y = new (bn_default())(y, 16);\n    this.z = new (bn_default())(z, 16);\n  }\n  if (!this.x.red)\n    this.x = this.x.toRed(this.curve.red);\n  if (!this.y.red)\n    this.y = this.y.toRed(this.curve.red);\n  if (!this.z.red)\n    this.z = this.z.toRed(this.curve.red);\n\n  this.zOne = this.z === this.curve.one;\n}\ninherits_browser(JPoint, base.BasePoint);\n\nShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n  return new JPoint(this, x, y, z);\n};\n\nJPoint.prototype.toP = function toP() {\n  if (this.isInfinity())\n    return this.curve.point(null, null);\n\n  var zinv = this.z.redInvm();\n  var zinv2 = zinv.redSqr();\n  var ax = this.x.redMul(zinv2);\n  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n  return this.curve.point(ax, ay);\n};\n\nJPoint.prototype.neg = function neg() {\n  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n};\n\nJPoint.prototype.add = function add(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p;\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 12M + 4S + 7A\n  var pz2 = p.z.redSqr();\n  var z2 = this.z.redSqr();\n  var u1 = this.x.redMul(pz2);\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y.redMul(pz2.redMul(p.z));\n  var s2 = p.y.redMul(z2.redMul(this.z));\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(p.z).redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mixedAdd = function mixedAdd(p) {\n  // O + P = P\n  if (this.isInfinity())\n    return p.toJ();\n\n  // P + O = P\n  if (p.isInfinity())\n    return this;\n\n  // 8M + 3S + 7A\n  var z2 = this.z.redSqr();\n  var u1 = this.x;\n  var u2 = p.x.redMul(z2);\n  var s1 = this.y;\n  var s2 = p.y.redMul(z2).redMul(this.z);\n\n  var h = u1.redSub(u2);\n  var r = s1.redSub(s2);\n  if (h.cmpn(0) === 0) {\n    if (r.cmpn(0) !== 0)\n      return this.curve.jpoint(null, null, null);\n    else\n      return this.dbl();\n  }\n\n  var h2 = h.redSqr();\n  var h3 = h2.redMul(h);\n  var v = u1.redMul(h2);\n\n  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n  var nz = this.z.redMul(h);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.dblp = function dblp(pow) {\n  if (pow === 0)\n    return this;\n  if (this.isInfinity())\n    return this;\n  if (!pow)\n    return this.dbl();\n\n  var i;\n  if (this.curve.zeroA || this.curve.threeA) {\n    var r = this;\n    for (i = 0; i < pow; i++)\n      r = r.dbl();\n    return r;\n  }\n\n  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n  // N = 1 => 6M + 6S + 9A\n  var a = this.curve.a;\n  var tinv = this.curve.tinv;\n\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  // Reuse results\n  var jyd = jy.redAdd(jy);\n  for (i = 0; i < pow; i++) {\n    var jx2 = jx.redSqr();\n    var jyd2 = jyd.redSqr();\n    var jyd4 = jyd2.redSqr();\n    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n    var t1 = jx.redMul(jyd2);\n    var nx = c.redSqr().redISub(t1.redAdd(t1));\n    var t2 = t1.redISub(nx);\n    var dny = c.redMul(t2);\n    dny = dny.redIAdd(dny).redISub(jyd4);\n    var nz = jyd.redMul(jz);\n    if (i + 1 < pow)\n      jz4 = jz4.redMul(jyd4);\n\n    jx = nx;\n    jz = nz;\n    jyd = dny;\n  }\n\n  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n};\n\nJPoint.prototype.dbl = function dbl() {\n  if (this.isInfinity())\n    return this;\n\n  if (this.curve.zeroA)\n    return this._zeroDbl();\n  else if (this.curve.threeA)\n    return this._threeDbl();\n  else\n    return this._dbl();\n};\n\nJPoint.prototype._zeroDbl = function _zeroDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 14A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a; a = 0\n    var m = xx.redAdd(xx).redIAdd(xx);\n    // T = M ^ 2 - 2*S\n    var t = m.redSqr().redISub(s).redISub(s);\n\n    // 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2*Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n    //     #doubling-dbl-2009-l\n    // 2M + 5S + 13A\n\n    // A = X1^2\n    var a = this.x.redSqr();\n    // B = Y1^2\n    var b = this.y.redSqr();\n    // C = B^2\n    var c = b.redSqr();\n    // D = 2 * ((X1 + B)^2 - A - C)\n    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n    d = d.redIAdd(d);\n    // E = 3 * A\n    var e = a.redAdd(a).redIAdd(a);\n    // F = E^2\n    var f = e.redSqr();\n\n    // 8 * C\n    var c8 = c.redIAdd(c);\n    c8 = c8.redIAdd(c8);\n    c8 = c8.redIAdd(c8);\n\n    // X3 = F - 2 * D\n    nx = f.redISub(d).redISub(d);\n    // Y3 = E * (D - X3) - 8 * C\n    ny = e.redMul(d.redISub(nx)).redISub(c8);\n    // Z3 = 2 * Y1 * Z1\n    nz = this.y.redMul(this.z);\n    nz = nz.redIAdd(nz);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._threeDbl = function _threeDbl() {\n  var nx;\n  var ny;\n  var nz;\n  // Z = 1\n  if (this.zOne) {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n    //     #doubling-mdbl-2007-bl\n    // 1M + 5S + 15A\n\n    // XX = X1^2\n    var xx = this.x.redSqr();\n    // YY = Y1^2\n    var yy = this.y.redSqr();\n    // YYYY = YY^2\n    var yyyy = yy.redSqr();\n    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n    s = s.redIAdd(s);\n    // M = 3 * XX + a\n    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n    // T = M^2 - 2 * S\n    var t = m.redSqr().redISub(s).redISub(s);\n    // X3 = T\n    nx = t;\n    // Y3 = M * (S - T) - 8 * YYYY\n    var yyyy8 = yyyy.redIAdd(yyyy);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    yyyy8 = yyyy8.redIAdd(yyyy8);\n    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n    // Z3 = 2 * Y1\n    nz = this.y.redAdd(this.y);\n  } else {\n    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S\n\n    // delta = Z1^2\n    var delta = this.z.redSqr();\n    // gamma = Y1^2\n    var gamma = this.y.redSqr();\n    // beta = X1 * gamma\n    var beta = this.x.redMul(gamma);\n    // alpha = 3 * (X1 - delta) * (X1 + delta)\n    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n    // X3 = alpha^2 - 8 * beta\n    var beta4 = beta.redIAdd(beta);\n    beta4 = beta4.redIAdd(beta4);\n    var beta8 = beta4.redAdd(beta4);\n    nx = alpha.redSqr().redISub(beta8);\n    // Z3 = (Y1 + Z1)^2 - gamma - delta\n    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n    var ggamma8 = gamma.redSqr();\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ggamma8 = ggamma8.redIAdd(ggamma8);\n    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n  }\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype._dbl = function _dbl() {\n  var a = this.curve.a;\n\n  // 4M + 6S + 10A\n  var jx = this.x;\n  var jy = this.y;\n  var jz = this.z;\n  var jz4 = jz.redSqr().redSqr();\n\n  var jx2 = jx.redSqr();\n  var jy2 = jy.redSqr();\n\n  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n  var jxd4 = jx.redAdd(jx);\n  jxd4 = jxd4.redIAdd(jxd4);\n  var t1 = jxd4.redMul(jy2);\n  var nx = c.redSqr().redISub(t1.redAdd(t1));\n  var t2 = t1.redISub(nx);\n\n  var jyd8 = jy2.redSqr();\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  jyd8 = jyd8.redIAdd(jyd8);\n  var ny = c.redMul(t2).redISub(jyd8);\n  var nz = jy.redAdd(jy).redMul(jz);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.trpl = function trpl() {\n  if (!this.curve.zeroA)\n    return this.dbl().add(this);\n\n  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n  // 5M + 10S + ...\n\n  // XX = X1^2\n  var xx = this.x.redSqr();\n  // YY = Y1^2\n  var yy = this.y.redSqr();\n  // ZZ = Z1^2\n  var zz = this.z.redSqr();\n  // YYYY = YY^2\n  var yyyy = yy.redSqr();\n  // M = 3 * XX + a * ZZ2; a = 0\n  var m = xx.redAdd(xx).redIAdd(xx);\n  // MM = M^2\n  var mm = m.redSqr();\n  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n  e = e.redIAdd(e);\n  e = e.redAdd(e).redIAdd(e);\n  e = e.redISub(mm);\n  // EE = E^2\n  var ee = e.redSqr();\n  // T = 16*YYYY\n  var t = yyyy.redIAdd(yyyy);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  t = t.redIAdd(t);\n  // U = (M + E)^2 - MM - EE - T\n  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n  // X3 = 4 * (X1 * EE - 4 * YY * U)\n  var yyu4 = yy.redMul(u);\n  yyu4 = yyu4.redIAdd(yyu4);\n  yyu4 = yyu4.redIAdd(yyu4);\n  var nx = this.x.redMul(ee).redISub(yyu4);\n  nx = nx.redIAdd(nx);\n  nx = nx.redIAdd(nx);\n  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  ny = ny.redIAdd(ny);\n  // Z3 = (Z1 + E)^2 - ZZ - EE\n  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n  return this.curve.jpoint(nx, ny, nz);\n};\n\nJPoint.prototype.mul = function mul(k, kbase) {\n  k = new (bn_default())(k, kbase);\n\n  return this.curve._wnafMul(this, k);\n};\n\nJPoint.prototype.eq = function eq(p) {\n  if (p.type === 'affine')\n    return this.eq(p.toJ());\n\n  if (this === p)\n    return true;\n\n  // x1 * z2^2 == x2 * z1^2\n  var z2 = this.z.redSqr();\n  var pz2 = p.z.redSqr();\n  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n    return false;\n\n  // y1 * z2^3 == y2 * z1^3\n  var z3 = z2.redMul(this.z);\n  var pz3 = pz2.redMul(p.z);\n  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n};\n\nJPoint.prototype.eqXToP = function eqXToP(x) {\n  var zs = this.z.redSqr();\n  var rx = x.toRed(this.curve.red).redMul(zs);\n  if (this.x.cmp(rx) === 0)\n    return true;\n\n  var xc = x.clone();\n  var t = this.curve.redN.redMul(zs);\n  for (;;) {\n    xc.iadd(this.curve.n);\n    if (xc.cmp(this.curve.p) >= 0)\n      return false;\n\n    rx.redIAdd(t);\n    if (this.x.cmp(rx) === 0)\n      return true;\n  }\n};\n\nJPoint.prototype.inspect = function inspect() {\n  if (this.isInfinity())\n    return '<EC JPoint Infinity>';\n  return '<EC JPoint x: ' + this.x.toString(16, 2) +\n      ' y: ' + this.y.toString(16, 2) +\n      ' z: ' + this.z.toString(16, 2) + '>';\n};\n\nJPoint.prototype.isInfinity = function isInfinity() {\n  // XXX This code assumes that zero is always zero in red\n  return this.z.cmpn(0) === 0;\n};\n\nvar curve_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curve = exports;\n\ncurve.base = base;\ncurve.short = short_1;\ncurve.mont = /*RicMoo:ethers:require(./mont)*/(null);\ncurve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);\n});\n\nvar curves_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar curves = exports;\n\n\n\n\n\nvar assert = utils_1$1.assert;\n\nfunction PresetCurve(options) {\n  if (options.type === 'short')\n    this.curve = new curve_1.short(options);\n  else if (options.type === 'edwards')\n    this.curve = new curve_1.edwards(options);\n  else\n    this.curve = new curve_1.mont(options);\n  this.g = this.curve.g;\n  this.n = this.curve.n;\n  this.hash = options.hash;\n\n  assert(this.g.validate(), 'Invalid curve');\n  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');\n}\ncurves.PresetCurve = PresetCurve;\n\nfunction defineCurve(name, options) {\n  Object.defineProperty(curves, name, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      var curve = new PresetCurve(options);\n      Object.defineProperty(curves, name, {\n        configurable: true,\n        enumerable: true,\n        value: curve,\n      });\n      return curve;\n    },\n  });\n}\n\ndefineCurve('p192', {\n  type: 'short',\n  prime: 'p192',\n  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',\n  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',\n  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',\n    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',\n  ],\n});\n\ndefineCurve('p224', {\n  type: 'short',\n  prime: 'p224',\n  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',\n  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',\n  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',\n  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',\n    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',\n  ],\n});\n\ndefineCurve('p256', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',\n  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',\n  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',\n  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',\n    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',\n  ],\n});\n\ndefineCurve('p384', {\n  type: 'short',\n  prime: null,\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 ffffffff',\n  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'fffffffe ffffffff 00000000 00000000 fffffffc',\n  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +\n     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',\n  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +\n     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',\n  hash: (hash_default()).sha384,\n  gRed: false,\n  g: [\n    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +\n    '5502f25d bf55296c 3a545e38 72760ab7',\n    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +\n    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',\n  ],\n});\n\ndefineCurve('p521', {\n  type: 'short',\n  prime: null,\n  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff',\n  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff ffffffff ffffffff fffffffc',\n  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +\n     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +\n     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',\n  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +\n     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +\n     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',\n  hash: (hash_default()).sha512,\n  gRed: false,\n  g: [\n    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +\n    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +\n    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',\n    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +\n    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +\n    '3fad0761 353c7086 a272c240 88be9476 9fd16650',\n  ],\n});\n\ndefineCurve('curve25519', {\n  type: 'mont',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '76d06',\n  b: '1',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '9',\n  ],\n});\n\ndefineCurve('ed25519', {\n  type: 'edwards',\n  prime: 'p25519',\n  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',\n  a: '-1',\n  c: '1',\n  // -121665 * (121666^(-1)) (mod P)\n  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',\n  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',\n  hash: (hash_default()).sha256,\n  gRed: false,\n  g: [\n    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',\n\n    // 4/5\n    '6666666666666666666666666666666666666666666666666666666666666658',\n  ],\n});\n\nvar pre;\ntry {\n  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();\n} catch (e) {\n  pre = undefined;\n}\n\ndefineCurve('secp256k1', {\n  type: 'short',\n  prime: 'k256',\n  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n  a: '0',\n  b: '7',\n  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n  h: '1',\n  hash: (hash_default()).sha256,\n\n  // Precomputed endomorphism\n  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n  basis: [\n    {\n      a: '3086d221a7d46bcde86c90e49284eb15',\n      b: '-e4437ed6010e88286f547fa90abfe4c3',\n    },\n    {\n      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n      b: '3086d221a7d46bcde86c90e49284eb15',\n    },\n  ],\n\n  gRed: false,\n  g: [\n    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n    pre,\n  ],\n});\n});\n\n'use strict';\n\n\n\n\n\nfunction HmacDRBG(options) {\n  if (!(this instanceof HmacDRBG))\n    return new HmacDRBG(options);\n  this.hash = options.hash;\n  this.predResist = !!options.predResist;\n\n  this.outLen = this.hash.outSize;\n  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n  this._reseed = null;\n  this.reseedInterval = null;\n  this.K = null;\n  this.V = null;\n\n  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');\n  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');\n  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n  this._init(entropy, nonce, pers);\n}\nvar hmacDrbg = HmacDRBG;\n\nHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n  var seed = entropy.concat(nonce).concat(pers);\n\n  this.K = new Array(this.outLen / 8);\n  this.V = new Array(this.outLen / 8);\n  for (var i = 0; i < this.V.length; i++) {\n    this.K[i] = 0x00;\n    this.V[i] = 0x01;\n  }\n\n  this._update(seed);\n  this._reseed = 1;\n  this.reseedInterval = 0x1000000000000;  // 2^48\n};\n\nHmacDRBG.prototype._hmac = function hmac() {\n  return new (hash_default()).hmac(this.hash, this.K);\n};\n\nHmacDRBG.prototype._update = function update(seed) {\n  var kmac = this._hmac()\n                 .update(this.V)\n                 .update([ 0x00 ]);\n  if (seed)\n    kmac = kmac.update(seed);\n  this.K = kmac.digest();\n  this.V = this._hmac().update(this.V).digest();\n  if (!seed)\n    return;\n\n  this.K = this._hmac()\n               .update(this.V)\n               .update([ 0x01 ])\n               .update(seed)\n               .digest();\n  this.V = this._hmac().update(this.V).digest();\n};\n\nHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n  // Optional entropy enc\n  if (typeof entropyEnc !== 'string') {\n    addEnc = add;\n    add = entropyEnc;\n    entropyEnc = null;\n  }\n\n  entropy = utils_1.toArray(entropy, entropyEnc);\n  add = utils_1.toArray(add, addEnc);\n\n  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');\n\n  this._update(entropy.concat(add || []));\n  this._reseed = 1;\n};\n\nHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n  if (this._reseed > this.reseedInterval)\n    throw new Error('Reseed is required');\n\n  // Optional encoding\n  if (typeof enc !== 'string') {\n    addEnc = add;\n    add = enc;\n    enc = null;\n  }\n\n  // Optional additional data\n  if (add) {\n    add = utils_1.toArray(add, addEnc || 'hex');\n    this._update(add);\n  }\n\n  var temp = [];\n  while (temp.length < len) {\n    this.V = this._hmac().update(this.V).digest();\n    temp = temp.concat(this.V);\n  }\n\n  var res = temp.slice(0, len);\n  this._update(add);\n  this._reseed++;\n  return utils_1.encode(res, enc);\n};\n\n'use strict';\n\n\n\nvar assert$3 = utils_1$1.assert;\n\nfunction KeyPair(ec, options) {\n  this.ec = ec;\n  this.priv = null;\n  this.pub = null;\n\n  // KeyPair(ec, { priv: ..., pub: ... })\n  if (options.priv)\n    this._importPrivate(options.priv, options.privEnc);\n  if (options.pub)\n    this._importPublic(options.pub, options.pubEnc);\n}\nvar key = KeyPair;\n\nKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n  if (pub instanceof KeyPair)\n    return pub;\n\n  return new KeyPair(ec, {\n    pub: pub,\n    pubEnc: enc,\n  });\n};\n\nKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n  if (priv instanceof KeyPair)\n    return priv;\n\n  return new KeyPair(ec, {\n    priv: priv,\n    privEnc: enc,\n  });\n};\n\nKeyPair.prototype.validate = function validate() {\n  var pub = this.getPublic();\n\n  if (pub.isInfinity())\n    return { result: false, reason: 'Invalid public key' };\n  if (!pub.validate())\n    return { result: false, reason: 'Public key is not a point' };\n  if (!pub.mul(this.ec.curve.n).isInfinity())\n    return { result: false, reason: 'Public key * N != O' };\n\n  return { result: true, reason: null };\n};\n\nKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n  // compact is optional argument\n  if (typeof compact === 'string') {\n    enc = compact;\n    compact = null;\n  }\n\n  if (!this.pub)\n    this.pub = this.ec.g.mul(this.priv);\n\n  if (!enc)\n    return this.pub;\n\n  return this.pub.encode(enc, compact);\n};\n\nKeyPair.prototype.getPrivate = function getPrivate(enc) {\n  if (enc === 'hex')\n    return this.priv.toString(16, 2);\n  else\n    return this.priv;\n};\n\nKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n  this.priv = new (bn_default())(key, enc || 16);\n\n  // Ensure that the priv won't be bigger than n, otherwise we may fail\n  // in fixed multiplication method\n  this.priv = this.priv.umod(this.ec.curve.n);\n};\n\nKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n  if (key.x || key.y) {\n    // Montgomery points only have an `x` coordinate.\n    // Weierstrass/Edwards points on the other hand have both `x` and\n    // `y` coordinates.\n    if (this.ec.curve.type === 'mont') {\n      assert$3(key.x, 'Need x coordinate');\n    } else if (this.ec.curve.type === 'short' ||\n               this.ec.curve.type === 'edwards') {\n      assert$3(key.x && key.y, 'Need both x and y coordinate');\n    }\n    this.pub = this.ec.curve.point(key.x, key.y);\n    return;\n  }\n  this.pub = this.ec.curve.decodePoint(key, enc);\n};\n\n// ECDH\nKeyPair.prototype.derive = function derive(pub) {\n  if(!pub.validate()) {\n    assert$3(pub.validate(), 'public point not validated');\n  }\n  return pub.mul(this.priv).getX();\n};\n\n// ECDSA\nKeyPair.prototype.sign = function sign(msg, enc, options) {\n  return this.ec.sign(msg, this, enc, options);\n};\n\nKeyPair.prototype.verify = function verify(msg, signature) {\n  return this.ec.verify(msg, signature, this);\n};\n\nKeyPair.prototype.inspect = function inspect() {\n  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +\n         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';\n};\n\n'use strict';\n\n\n\n\nvar assert$4 = utils_1$1.assert;\n\nfunction Signature(options, enc) {\n  if (options instanceof Signature)\n    return options;\n\n  if (this._importDER(options, enc))\n    return;\n\n  assert$4(options.r && options.s, 'Signature without r or s');\n  this.r = new (bn_default())(options.r, 16);\n  this.s = new (bn_default())(options.s, 16);\n  if (options.recoveryParam === undefined)\n    this.recoveryParam = null;\n  else\n    this.recoveryParam = options.recoveryParam;\n}\nvar signature = Signature;\n\nfunction Position() {\n  this.place = 0;\n}\n\nfunction getLength(buf, p) {\n  var initial = buf[p.place++];\n  if (!(initial & 0x80)) {\n    return initial;\n  }\n  var octetLen = initial & 0xf;\n\n  // Indefinite length or overflow\n  if (octetLen === 0 || octetLen > 4) {\n    return false;\n  }\n\n  var val = 0;\n  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n    val <<= 8;\n    val |= buf[off];\n    val >>>= 0;\n  }\n\n  // Leading zeroes\n  if (val <= 0x7f) {\n    return false;\n  }\n\n  p.place = off;\n  return val;\n}\n\nfunction rmPadding(buf) {\n  var i = 0;\n  var len = buf.length - 1;\n  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n    i++;\n  }\n  if (i === 0) {\n    return buf;\n  }\n  return buf.slice(i);\n}\n\nSignature.prototype._importDER = function _importDER(data, enc) {\n  data = utils_1$1.toArray(data, enc);\n  var p = new Position();\n  if (data[p.place++] !== 0x30) {\n    return false;\n  }\n  var len = getLength(data, p);\n  if (len === false) {\n    return false;\n  }\n  if ((len + p.place) !== data.length) {\n    return false;\n  }\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var rlen = getLength(data, p);\n  if (rlen === false) {\n    return false;\n  }\n  var r = data.slice(p.place, rlen + p.place);\n  p.place += rlen;\n  if (data[p.place++] !== 0x02) {\n    return false;\n  }\n  var slen = getLength(data, p);\n  if (slen === false) {\n    return false;\n  }\n  if (data.length !== slen + p.place) {\n    return false;\n  }\n  var s = data.slice(p.place, slen + p.place);\n  if (r[0] === 0) {\n    if (r[1] & 0x80) {\n      r = r.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n  if (s[0] === 0) {\n    if (s[1] & 0x80) {\n      s = s.slice(1);\n    } else {\n      // Leading zeroes\n      return false;\n    }\n  }\n\n  this.r = new (bn_default())(r);\n  this.s = new (bn_default())(s);\n  this.recoveryParam = null;\n\n  return true;\n};\n\nfunction constructLength(arr, len) {\n  if (len < 0x80) {\n    arr.push(len);\n    return;\n  }\n  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n  arr.push(octets | 0x80);\n  while (--octets) {\n    arr.push((len >>> (octets << 3)) & 0xff);\n  }\n  arr.push(len);\n}\n\nSignature.prototype.toDER = function toDER(enc) {\n  var r = this.r.toArray();\n  var s = this.s.toArray();\n\n  // Pad values\n  if (r[0] & 0x80)\n    r = [ 0 ].concat(r);\n  // Pad values\n  if (s[0] & 0x80)\n    s = [ 0 ].concat(s);\n\n  r = rmPadding(r);\n  s = rmPadding(s);\n\n  while (!s[0] && !(s[1] & 0x80)) {\n    s = s.slice(1);\n  }\n  var arr = [ 0x02 ];\n  constructLength(arr, r.length);\n  arr = arr.concat(r);\n  arr.push(0x02);\n  constructLength(arr, s.length);\n  var backHalf = arr.concat(s);\n  var res = [ 0x30 ];\n  constructLength(res, backHalf.length);\n  res = res.concat(backHalf);\n  return utils_1$1.encode(res, enc);\n};\n\n'use strict';\n\n\n\n\n\nvar rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nvar assert$5 = utils_1$1.assert;\n\n\n\n\nfunction EC(options) {\n  if (!(this instanceof EC))\n    return new EC(options);\n\n  // Shortcut `elliptic.ec(curve-name)`\n  if (typeof options === 'string') {\n    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),\n      'Unknown curve ' + options);\n\n    options = curves_1[options];\n  }\n\n  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n  if (options instanceof curves_1.PresetCurve)\n    options = { curve: options };\n\n  this.curve = options.curve.curve;\n  this.n = this.curve.n;\n  this.nh = this.n.ushrn(1);\n  this.g = this.curve.g;\n\n  // Point on curve\n  this.g = options.curve.g;\n  this.g.precompute(options.curve.n.bitLength() + 1);\n\n  // Hash for function for DRBG\n  this.hash = options.hash || options.curve.hash;\n}\nvar ec = EC;\n\nEC.prototype.keyPair = function keyPair(options) {\n  return new key(this, options);\n};\n\nEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n  return key.fromPrivate(this, priv, enc);\n};\n\nEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n  return key.fromPublic(this, pub, enc);\n};\n\nEC.prototype.genKeyPair = function genKeyPair(options) {\n  if (!options)\n    options = {};\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n    entropy: options.entropy || rand(this.hash.hmacStrength),\n    entropyEnc: options.entropy && options.entropyEnc || 'utf8',\n    nonce: this.n.toArray(),\n  });\n\n  var bytes = this.n.byteLength();\n  var ns2 = this.n.sub(new (bn_default())(2));\n  for (;;) {\n    var priv = new (bn_default())(drbg.generate(bytes));\n    if (priv.cmp(ns2) > 0)\n      continue;\n\n    priv.iaddn(1);\n    return this.keyFromPrivate(priv);\n  }\n};\n\nEC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {\n  var delta = msg.byteLength() * 8 - this.n.bitLength();\n  if (delta > 0)\n    msg = msg.ushrn(delta);\n  if (!truncOnly && msg.cmp(this.n) >= 0)\n    return msg.sub(this.n);\n  else\n    return msg;\n};\n\nEC.prototype.sign = function sign(msg, key, enc, options) {\n  if (typeof enc === 'object') {\n    options = enc;\n    enc = null;\n  }\n  if (!options)\n    options = {};\n\n  key = this.keyFromPrivate(key, enc);\n  msg = this._truncateToN(new (bn_default())(msg, 16));\n\n  // Zero-extend key to provide enough entropy\n  var bytes = this.n.byteLength();\n  var bkey = key.getPrivate().toArray('be', bytes);\n\n  // Zero-extend nonce to have the same byte size as N\n  var nonce = msg.toArray('be', bytes);\n\n  // Instantiate Hmac_DRBG\n  var drbg = new hmacDrbg({\n    hash: this.hash,\n    entropy: bkey,\n    nonce: nonce,\n    pers: options.pers,\n    persEnc: options.persEnc || 'utf8',\n  });\n\n  // Number of bytes to generate\n  var ns1 = this.n.sub(new (bn_default())(1));\n\n  for (var iter = 0; ; iter++) {\n    var k = options.k ?\n      options.k(iter) :\n      new (bn_default())(drbg.generate(this.n.byteLength()));\n    k = this._truncateToN(k, true);\n    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n      continue;\n\n    var kp = this.g.mul(k);\n    if (kp.isInfinity())\n      continue;\n\n    var kpX = kp.getX();\n    var r = kpX.umod(this.n);\n    if (r.cmpn(0) === 0)\n      continue;\n\n    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n    s = s.umod(this.n);\n    if (s.cmpn(0) === 0)\n      continue;\n\n    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n    // Use complement of `s`, if it is > `n / 2`\n    if (options.canonical && s.cmp(this.nh) > 0) {\n      s = this.n.sub(s);\n      recoveryParam ^= 1;\n    }\n\n    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n  }\n};\n\nEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n  msg = this._truncateToN(new (bn_default())(msg, 16));\n  key = this.keyFromPublic(key, enc);\n  signature$1 = new signature(signature$1, 'hex');\n\n  // Perform primitive values validation\n  var r = signature$1.r;\n  var s = signature$1.s;\n  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n    return false;\n  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n    return false;\n\n  // Validate signature\n  var sinv = s.invm(this.n);\n  var u1 = sinv.mul(msg).umod(this.n);\n  var u2 = sinv.mul(r).umod(this.n);\n  var p;\n\n  if (!this.curve._maxwellTrick) {\n    p = this.g.mulAdd(u1, key.getPublic(), u2);\n    if (p.isInfinity())\n      return false;\n\n    return p.getX().umod(this.n).cmp(r) === 0;\n  }\n\n  // NOTE: Greg Maxwell's trick, inspired by:\n  // https://git.io/vad3K\n\n  p = this.g.jmulAdd(u1, key.getPublic(), u2);\n  if (p.isInfinity())\n    return false;\n\n  // Compare `p.x` of Jacobian point with `r`,\n  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n  // inverse of `p.z^2`\n  return p.eqXToP(r);\n};\n\nEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n  assert$5((3 & j) === j, 'The recovery param is more than two bits');\n  signature$1 = new signature(signature$1, enc);\n\n  var n = this.n;\n  var e = new (bn_default())(msg);\n  var r = signature$1.r;\n  var s = signature$1.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = j & 1;\n  var isSecondKey = j >> 1;\n  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n    throw new Error('Unable to find sencond key candinate');\n\n  // 1.1. Let x = r + jn.\n  if (isSecondKey)\n    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n  else\n    r = this.curve.pointFromX(r, isYOdd);\n\n  var rInv = signature$1.r.invm(n);\n  var s1 = n.sub(e).mul(rInv).umod(n);\n  var s2 = s.mul(rInv).umod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n  //               Q = r^-1 (sR + -eG)\n  return this.g.mulAdd(s1, r, s2);\n};\n\nEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n  signature$1 = new signature(signature$1, enc);\n  if (signature$1.recoveryParam !== null)\n    return signature$1.recoveryParam;\n\n  for (var i = 0; i < 4; i++) {\n    var Qprime;\n    try {\n      Qprime = this.recoverPubKey(e, signature$1, i);\n    } catch (e) {\n      continue;\n    }\n\n    if (Qprime.eq(Q))\n      return i;\n  }\n  throw new Error('Unable to find valid recovery factor');\n};\n\nvar elliptic_1 = createCommonjsModule(function (module, exports) {\n'use strict';\n\nvar elliptic = exports;\n\nelliptic.version = /*RicMoo:ethers*/{ version: \"6.5.4\" }.version;\nelliptic.utils = utils_1$1;\nelliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });\nelliptic.curve = curve_1;\nelliptic.curves = curves_1;\n\n// Protocols\nelliptic.ec = ec;\nelliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);\n});\n\nvar EC$1 = elliptic_1.ec;\n\n\n//# sourceMappingURL=elliptic.js.map\n\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/signing-key/lib.esm/_version.js\nconst signing_key_lib_esm_version_version = \"signing-key/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/signing-key/lib.esm/index.js\n\n\n\n\n\n\nconst signing_key_lib_esm_logger = new Logger(signing_key_lib_esm_version_version);\nlet _curve = null;\nfunction getCurve() {\n    if (!_curve) {\n        _curve = new EC$1(\"secp256k1\");\n    }\n    return _curve;\n}\nclass SigningKey {\n    constructor(privateKey) {\n        defineReadOnly(this, \"curve\", \"secp256k1\");\n        defineReadOnly(this, \"privateKey\", hexlify(privateKey));\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        defineReadOnly(this, \"publicKey\", \"0x\" + keyPair.getPublic(false, \"hex\"));\n        defineReadOnly(this, \"compressedPublicKey\", \"0x\" + keyPair.getPublic(true, \"hex\"));\n        defineReadOnly(this, \"_isSigningKey\", true);\n    }\n    _addPoint(other) {\n        const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));\n        const p1 = getCurve().keyFromPublic(arrayify(other));\n        return \"0x\" + p0.pub.add(p1.pub).encodeCompressed(\"hex\");\n    }\n    signDigest(digest) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const digestBytes = arrayify(digest);\n        if (digestBytes.length !== 32) {\n            signing_key_lib_esm_logger.throwArgumentError(\"bad digest length\", \"digest\", digest);\n        }\n        const signature = keyPair.sign(digestBytes, { canonical: true });\n        return splitSignature({\n            recoveryParam: signature.recoveryParam,\n            r: hexZeroPad(\"0x\" + signature.r.toString(16), 32),\n            s: hexZeroPad(\"0x\" + signature.s.toString(16), 32),\n        });\n    }\n    computeSharedSecret(otherKey) {\n        const keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));\n        const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));\n        return hexZeroPad(\"0x\" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n    }\n    static isSigningKey(value) {\n        return !!(value && value._isSigningKey);\n    }\n}\nfunction recoverPublicKey(digest, signature) {\n    const sig = splitSignature(signature);\n    const rs = { r: arrayify(sig.r), s: arrayify(sig.s) };\n    return \"0x\" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode(\"hex\", false);\n}\nfunction computePublicKey(key, compressed) {\n    const bytes = arrayify(key);\n    if (bytes.length === 32) {\n        const signingKey = new SigningKey(bytes);\n        if (compressed) {\n            return \"0x\" + getCurve().keyFromPrivate(bytes).getPublic(true, \"hex\");\n        }\n        return signingKey.publicKey;\n    }\n    else if (bytes.length === 33) {\n        if (compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(false, \"hex\");\n    }\n    else if (bytes.length === 65) {\n        if (!compressed) {\n            return hexlify(bytes);\n        }\n        return \"0x\" + getCurve().keyFromPublic(bytes).getPublic(true, \"hex\");\n    }\n    return signing_key_lib_esm_logger.throwArgumentError(\"invalid public or private key\", \"key\", \"[REDACTED]\");\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/transactions/lib.esm/_version.js\nconst transactions_lib_esm_version_version = \"transactions/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/transactions/lib.esm/index.js\n\n\n\n\n\n\n\n\n\n\n\nconst transactions_lib_esm_logger = new Logger(transactions_lib_esm_version_version);\nvar TransactionTypes;\n(function (TransactionTypes) {\n    TransactionTypes[TransactionTypes[\"legacy\"] = 0] = \"legacy\";\n    TransactionTypes[TransactionTypes[\"eip2930\"] = 1] = \"eip2930\";\n    TransactionTypes[TransactionTypes[\"eip1559\"] = 2] = \"eip1559\";\n})(TransactionTypes || (TransactionTypes = {}));\n;\n///////////////////////////////\nfunction handleAddress(value) {\n    if (value === \"0x\") {\n        return null;\n    }\n    return getAddress(value);\n}\nfunction handleNumber(value) {\n    if (value === \"0x\") {\n        return bignumbers_Zero;\n    }\n    return BigNumber.from(value);\n}\n// Legacy Transaction Fields\nconst transactionFields = [\n    { name: \"nonce\", maxLength: 32, numeric: true },\n    { name: \"gasPrice\", maxLength: 32, numeric: true },\n    { name: \"gasLimit\", maxLength: 32, numeric: true },\n    { name: \"to\", length: 20 },\n    { name: \"value\", maxLength: 32, numeric: true },\n    { name: \"data\" },\n];\nconst lib_esm_allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true\n};\nfunction computeAddress(key) {\n    const publicKey = computePublicKey(key);\n    return getAddress(hexDataSlice(keccak256(hexDataSlice(publicKey, 1)), 12));\n}\nfunction recoverAddress(digest, signature) {\n    return computeAddress(recoverPublicKey(arrayify(digest), signature));\n}\nfunction formatNumber(value, name) {\n    const result = stripZeros(BigNumber.from(value).toHexString());\n    if (result.length > 32) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid length for \" + name, (\"transaction:\" + name), value);\n    }\n    return result;\n}\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: (storageKeys || []).map((storageKey, index) => {\n            if (hexDataLength(storageKey) !== 32) {\n                transactions_lib_esm_logger.throwArgumentError(\"invalid access list storageKey\", `accessList[${addr}:${index}]`, storageKey);\n            }\n            return storageKey.toLowerCase();\n        })\n    };\n}\nfunction accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                if (set.length > 2) {\n                    transactions_lib_esm_logger.throwArgumentError(\"access list expected to be [ address, storageKeys[] ]\", `value[${index}]`, set);\n                }\n                return accessSetify(set[0], set[1]);\n            }\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\nfunction formatAccessList(value) {\n    return accessListify(value).map((set) => [set.address, set.storageKeys]);\n}\nfunction _serializeEip1559(transaction, signature) {\n    // If there is an explicit gasPrice, make sure it matches the\n    // EIP-1559 fees; otherwise they may not understand what they\n    // think they are setting in terms of fee.\n    if (transaction.gasPrice != null) {\n        const gasPrice = BigNumber.from(transaction.gasPrice);\n        const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);\n        if (!gasPrice.eq(maxFeePerGas)) {\n            transactions_lib_esm_logger.throwArgumentError(\"mismatch EIP-1559 gasPrice != maxFeePerGas\", \"tx\", {\n                gasPrice, maxFeePerGas\n            });\n        }\n    }\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.maxPriorityFeePerGas || 0, \"maxPriorityFeePerGas\"),\n        formatNumber(transaction.maxFeePerGas || 0, \"maxFeePerGas\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x02\", encode(fields)]);\n}\nfunction _serializeEip2930(transaction, signature) {\n    const fields = [\n        formatNumber(transaction.chainId || 0, \"chainId\"),\n        formatNumber(transaction.nonce || 0, \"nonce\"),\n        formatNumber(transaction.gasPrice || 0, \"gasPrice\"),\n        formatNumber(transaction.gasLimit || 0, \"gasLimit\"),\n        ((transaction.to != null) ? getAddress(transaction.to) : \"0x\"),\n        formatNumber(transaction.value || 0, \"value\"),\n        (transaction.data || \"0x\"),\n        (formatAccessList(transaction.accessList || []))\n    ];\n    if (signature) {\n        const sig = splitSignature(signature);\n        fields.push(formatNumber(sig.recoveryParam, \"recoveryParam\"));\n        fields.push(stripZeros(sig.r));\n        fields.push(stripZeros(sig.s));\n    }\n    return hexConcat([\"0x01\", encode(fields)]);\n}\n// Legacy Transactions and EIP-155\nfunction _serialize(transaction, signature) {\n    checkProperties(transaction, lib_esm_allowedTransactionKeys);\n    const raw = [];\n    transactionFields.forEach(function (fieldInfo) {\n        let value = transaction[fieldInfo.name] || ([]);\n        const options = {};\n        if (fieldInfo.numeric) {\n            options.hexPad = \"left\";\n        }\n        value = arrayify(hexlify(value, options));\n        // Fixed-width field\n        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n            transactions_lib_esm_logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n        }\n        // Variable-width (with a maximum)\n        if (fieldInfo.maxLength) {\n            value = stripZeros(value);\n            if (value.length > fieldInfo.maxLength) {\n                transactions_lib_esm_logger.throwArgumentError(\"invalid length for \" + fieldInfo.name, (\"transaction:\" + fieldInfo.name), value);\n            }\n        }\n        raw.push(hexlify(value));\n    });\n    let chainId = 0;\n    if (transaction.chainId != null) {\n        // A chainId was provided; if non-zero we'll use EIP-155\n        chainId = transaction.chainId;\n        if (typeof (chainId) !== \"number\") {\n            transactions_lib_esm_logger.throwArgumentError(\"invalid transaction.chainId\", \"transaction\", transaction);\n        }\n    }\n    else if (signature && !isBytesLike(signature) && signature.v > 28) {\n        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n        chainId = Math.floor((signature.v - 35) / 2);\n    }\n    // We have an EIP-155 transaction (chainId was specified and non-zero)\n    if (chainId !== 0) {\n        raw.push(hexlify(chainId)); // @TODO: hexValue?\n        raw.push(\"0x\");\n        raw.push(\"0x\");\n    }\n    // Requesting an unsigned transaction\n    if (!signature) {\n        return encode(raw);\n    }\n    // The splitSignature will ensure the transaction has a recoveryParam in the\n    // case that the signTransaction function only adds a v.\n    const sig = splitSignature(signature);\n    // We pushed a chainId and null r, s on for hashing only; remove those\n    let v = 27 + sig.recoveryParam;\n    if (chainId !== 0) {\n        raw.pop();\n        raw.pop();\n        raw.pop();\n        v += chainId * 2 + 8;\n        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n        if (sig.v > 28 && sig.v !== v) {\n            transactions_lib_esm_logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n        }\n    }\n    else if (sig.v !== v) {\n        transactions_lib_esm_logger.throwArgumentError(\"transaction.chainId/signature.v mismatch\", \"signature\", signature);\n    }\n    raw.push(hexlify(v));\n    raw.push(stripZeros(arrayify(sig.r)));\n    raw.push(stripZeros(arrayify(sig.s)));\n    return encode(raw);\n}\nfunction serialize(transaction, signature) {\n    // Legacy and EIP-155 Transactions\n    if (transaction.type == null || transaction.type === 0) {\n        if (transaction.accessList != null) {\n            transactions_lib_esm_logger.throwArgumentError(\"untyped transactions do not support accessList; include type: 1\", \"transaction\", transaction);\n        }\n        return _serialize(transaction, signature);\n    }\n    // Typed Transactions (EIP-2718)\n    switch (transaction.type) {\n        case 1:\n            return _serializeEip2930(transaction, signature);\n        case 2:\n            return _serializeEip1559(transaction, signature);\n        default:\n            break;\n    }\n    return transactions_lib_esm_logger.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"serializeTransaction\",\n        transactionType: transaction.type\n    });\n}\nfunction _parseEipSignature(tx, fields, serialize) {\n    try {\n        const recid = handleNumber(fields[0]).toNumber();\n        if (recid !== 0 && recid !== 1) {\n            throw new Error(\"bad recid\");\n        }\n        tx.v = recid;\n    }\n    catch (error) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid v for transaction type: 1\", \"v\", fields[0]);\n    }\n    tx.r = hexZeroPad(fields[1], 32);\n    tx.s = hexZeroPad(fields[2], 32);\n    try {\n        const digest = keccak256(serialize(tx));\n        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });\n    }\n    catch (error) {\n        console.log(error);\n    }\n}\nfunction _parseEip1559(payload) {\n    const transaction = decode(payload.slice(1));\n    if (transaction.length !== 9 && transaction.length !== 12) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid component count for transaction type: 2\", \"payload\", hexlify(payload));\n    }\n    const maxPriorityFeePerGas = handleNumber(transaction[2]);\n    const maxFeePerGas = handleNumber(transaction[3]);\n    const tx = {\n        type: 2,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        maxPriorityFeePerGas: maxPriorityFeePerGas,\n        maxFeePerGas: maxFeePerGas,\n        gasPrice: null,\n        gasLimit: handleNumber(transaction[4]),\n        to: handleAddress(transaction[5]),\n        value: handleNumber(transaction[6]),\n        data: transaction[7],\n        accessList: accessListify(transaction[8]),\n    };\n    // Unsigned EIP-1559 Transaction\n    if (transaction.length === 9) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);\n    return tx;\n}\nfunction _parseEip2930(payload) {\n    const transaction = decode(payload.slice(1));\n    if (transaction.length !== 8 && transaction.length !== 11) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid component count for transaction type: 1\", \"payload\", hexlify(payload));\n    }\n    const tx = {\n        type: 1,\n        chainId: handleNumber(transaction[0]).toNumber(),\n        nonce: handleNumber(transaction[1]).toNumber(),\n        gasPrice: handleNumber(transaction[2]),\n        gasLimit: handleNumber(transaction[3]),\n        to: handleAddress(transaction[4]),\n        value: handleNumber(transaction[5]),\n        data: transaction[6],\n        accessList: accessListify(transaction[7])\n    };\n    // Unsigned EIP-2930 Transaction\n    if (transaction.length === 8) {\n        return tx;\n    }\n    tx.hash = keccak256(payload);\n    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);\n    return tx;\n}\n// Legacy Transactions and EIP-155\nfunction _parse(rawTransaction) {\n    const transaction = decode(rawTransaction);\n    if (transaction.length !== 9 && transaction.length !== 6) {\n        transactions_lib_esm_logger.throwArgumentError(\"invalid raw transaction\", \"rawTransaction\", rawTransaction);\n    }\n    const tx = {\n        nonce: handleNumber(transaction[0]).toNumber(),\n        gasPrice: handleNumber(transaction[1]),\n        gasLimit: handleNumber(transaction[2]),\n        to: handleAddress(transaction[3]),\n        value: handleNumber(transaction[4]),\n        data: transaction[5],\n        chainId: 0\n    };\n    // Legacy unsigned transaction\n    if (transaction.length === 6) {\n        return tx;\n    }\n    try {\n        tx.v = BigNumber.from(transaction[6]).toNumber();\n    }\n    catch (error) {\n        console.log(error);\n        return tx;\n    }\n    tx.r = hexZeroPad(transaction[7], 32);\n    tx.s = hexZeroPad(transaction[8], 32);\n    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {\n        // EIP-155 unsigned transaction\n        tx.chainId = tx.v;\n        tx.v = 0;\n    }\n    else {\n        // Signed Transaction\n        tx.chainId = Math.floor((tx.v - 35) / 2);\n        if (tx.chainId < 0) {\n            tx.chainId = 0;\n        }\n        let recoveryParam = tx.v - 27;\n        const raw = transaction.slice(0, 6);\n        if (tx.chainId !== 0) {\n            raw.push(hexlify(tx.chainId));\n            raw.push(\"0x\");\n            raw.push(\"0x\");\n            recoveryParam -= tx.chainId * 2 + 8;\n        }\n        const digest = keccak256(encode(raw));\n        try {\n            tx.from = recoverAddress(digest, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam: recoveryParam });\n        }\n        catch (error) {\n            console.log(error);\n        }\n        tx.hash = keccak256(rawTransaction);\n    }\n    tx.type = null;\n    return tx;\n}\nfunction parse(rawTransaction) {\n    const payload = arrayify(rawTransaction);\n    // Legacy and EIP-155 Transactions\n    if (payload[0] > 0x7f) {\n        return _parse(payload);\n    }\n    // Typed Transaction (EIP-2718)\n    switch (payload[0]) {\n        case 1:\n            return _parseEip2930(payload);\n        case 2:\n            return _parseEip1559(payload);\n        default:\n            break;\n    }\n    return transactions_lib_esm_logger.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"parseTransaction\",\n        transactionType: payload[0]\n    });\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/base64/lib.esm/base64.js\n\n\nfunction base64_decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nfunction base64_encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/web/lib.esm/_version.js\nconst web_lib_esm_version_version = \"web/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/web/lib.esm/geturl.js\n\nvar geturl_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nfunction getUrl(href, options) {\n    return geturl_awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n            body: (options.body || undefined),\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key) => {\n                headers[key.toLowerCase()] = value;\n            });\n        }\n        else {\n            ((response.headers).keys)().forEach((key) => {\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: arrayify(new Uint8Array(body)),\n        };\n    });\n}\n//# sourceMappingURL=geturl.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/web/lib.esm/index.js\n\nvar web_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst web_lib_esm_logger = new Logger(web_lib_esm_version_version);\n\nfunction staller(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return hexlify(value);\n    }\n    return value;\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nfunction _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    web_lib_esm_logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    const throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    web_lib_esm_logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = ((typeof (connection) === \"object\") ? !!(connection.errorPassThrough) : false);\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            web_lib_esm_logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                web_lib_esm_logger.throwError(\"basic authentication requires a secure https url\", Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64_encode(toUtf8Bytes(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n    }\n    const reData = new RegExp(\"^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": dataMatch[1] },\n                body: base64_decode(dataMatch[2])\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            web_lib_esm_logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(web_lib_esm_logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return web_lib_esm_awaiter(this, void 0, void 0, function* () {\n            for (let attempt = 0; attempt < attemptLimit; attempt++) {\n                let response = null;\n                try {\n                    response = yield getUrl(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        }\n                        else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                }\n                                else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        web_lib_esm_logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                }\n                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    web_lib_esm_logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    }\n                    catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        web_lib_esm_logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return web_lib_esm_logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nfunction fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response) => {\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            }\n            catch (error) {\n                web_lib_esm_logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n        // Create a connection with the content-type set for JSON\n        const updated = (typeof (connection) === \"string\") ? ({ url: connection }) : shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nfunction poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = shallowCopy(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js\nconst abstract_provider_lib_esm_version_version = \"abstract-provider/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/abstract-provider/lib.esm/index.js\n\nvar abstract_provider_lib_esm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst abstract_provider_lib_esm_logger = new Logger(abstract_provider_lib_esm_version_version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nclass ForkEvent extends Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nclass BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry) {\n        if (!isHexString(blockHash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\nclass TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!isHexString(hash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nclass TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!isHexString(beforeHash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            abstract_provider_lib_esm_logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nclass Provider {\n    constructor() {\n        abstract_provider_lib_esm_logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return abstract_provider_lib_esm_awaiter(this, void 0, void 0, function* () {\n            const { block, gasPrice } = yield resolveProperties({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error) => {\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/basex/lib.esm/index.js\n/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n\nclass BaseX {\n    constructor(alphabet) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n        defineReadOnly(this, \"_alphabetMap\", {});\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = arrayify(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return arrayify(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\n\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/constants/lib.esm/hashes.js\nconst HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/strings/lib.esm/idna.js\n\n\nfunction bytes2(data) {\n    if ((data.length % 4) !== 0) {\n        throw new Error(\"bad data\");\n    }\n    let result = [];\n    for (let i = 0; i < data.length; i += 4) {\n        result.push(parseInt(data.substring(i, i + 4), 16));\n    }\n    return result;\n}\nfunction createTable(data, func) {\n    if (!func) {\n        func = function (value) { return [parseInt(value, 16)]; };\n    }\n    let lo = 0;\n    let result = {};\n    data.split(\",\").forEach((pair) => {\n        let comps = pair.split(\":\");\n        lo += parseInt(comps[0], 16);\n        result[lo] = func(comps[1]);\n    });\n    return result;\n}\nfunction createRangeTable(data) {\n    let hi = 0;\n    return data.split(\",\").map((v) => {\n        let comps = v.split(\"-\");\n        if (comps.length === 1) {\n            comps[1] = \"0\";\n        }\n        else if (comps[1] === \"\") {\n            comps[1] = \"1\";\n        }\n        let lo = hi + parseInt(comps[0], 16);\n        hi = parseInt(comps[1], 16);\n        return { l: lo, h: hi };\n    });\n}\nfunction matchMap(value, ranges) {\n    let lo = 0;\n    for (let i = 0; i < ranges.length; i++) {\n        let range = ranges[i];\n        lo += range.l;\n        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n            if (range.e && range.e.indexOf(value - lo) !== -1) {\n                continue;\n            }\n            return range;\n        }\n    }\n    return null;\n}\nconst Table_A_1_ranges = createRangeTable(\"221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d\");\n// @TODO: Make this relative...\nconst Table_B_1_flags = \"ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff\".split(\",\").map((v) => parseInt(v, 16));\nconst Table_B_2_ranges = [\n    { h: 25, s: 32, l: 65 },\n    { h: 30, s: 32, e: [23], l: 127 },\n    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n    { h: 14, s: 1, l: 57, d: 2 },\n    { h: 44, s: 1, l: 17, d: 2 },\n    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n    { h: 16, s: 1, l: 68, d: 2 },\n    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n    { h: 26, s: 32, e: [17], l: 435 },\n    { h: 22, s: 1, l: 71, d: 2 },\n    { h: 15, s: 80, l: 40 },\n    { h: 31, s: 32, l: 16 },\n    { h: 32, s: 1, l: 80, d: 2 },\n    { h: 52, s: 1, l: 42, d: 2 },\n    { h: 12, s: 1, l: 55, d: 2 },\n    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n    { h: 14, s: 1, l: 48, d: 2 },\n    { h: 37, s: 48, l: 49 },\n    { h: 148, s: 1, l: 6351, d: 2 },\n    { h: 88, s: 1, l: 160, d: 2 },\n    { h: 15, s: 16, l: 704 },\n    { h: 25, s: 26, l: 854 },\n    { h: 25, s: 32, l: 55915 },\n    { h: 37, s: 40, l: 1247 },\n    { h: 25, s: -119711, l: 53248 },\n    { h: 25, s: -119763, l: 52 },\n    { h: 25, s: -119815, l: 52 },\n    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n    { h: 25, s: -119919, l: 52 },\n    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n    { h: 25, s: -120075, l: 52 },\n    { h: 25, s: -120127, l: 52 },\n    { h: 25, s: -120179, l: 52 },\n    { h: 25, s: -120231, l: 52 },\n    { h: 25, s: -120283, l: 52 },\n    { h: 25, s: -120335, l: 52 },\n    { h: 24, s: -119543, e: [17], l: 56 },\n    { h: 24, s: -119601, e: [17], l: 58 },\n    { h: 24, s: -119659, e: [17], l: 58 },\n    { h: 24, s: -119717, e: [17], l: 58 },\n    { h: 24, s: -119775, e: [17], l: 58 }\n];\nconst Table_B_2_lut_abs = createTable(\"b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3\");\nconst Table_B_2_lut_rel = createTable(\"179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7\");\nconst Table_B_2_complex = createTable(\"df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D\", bytes2);\nconst Table_C_ranges = createRangeTable(\"80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001\");\nfunction flatten(values) {\n    return values.reduce((accum, value) => {\n        value.forEach((value) => { accum.push(value); });\n        return accum;\n    }, []);\n}\nfunction _nameprepTableA1(codepoint) {\n    return !!matchMap(codepoint, Table_A_1_ranges);\n}\nfunction _nameprepTableB2(codepoint) {\n    let range = matchMap(codepoint, Table_B_2_ranges);\n    if (range) {\n        return [codepoint + range.s];\n    }\n    let codes = Table_B_2_lut_abs[codepoint];\n    if (codes) {\n        return codes;\n    }\n    let shift = Table_B_2_lut_rel[codepoint];\n    if (shift) {\n        return [codepoint + shift[0]];\n    }\n    let complex = Table_B_2_complex[codepoint];\n    if (complex) {\n        return complex;\n    }\n    return null;\n}\nfunction _nameprepTableC(codepoint) {\n    return !!matchMap(codepoint, Table_C_ranges);\n}\nfunction nameprep(value) {\n    // This allows platforms with incomplete normalize to bypass\n    // it for very basic names which the built-in toLowerCase\n    // will certainly handle correctly\n    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n        return value.toLowerCase();\n    }\n    // Get the code points (keeping the current normalization)\n    let codes = toUtf8CodePoints(value);\n    codes = flatten(codes.map((code) => {\n        // Substitute Table B.1 (Maps to Nothing)\n        if (Table_B_1_flags.indexOf(code) >= 0) {\n            return [];\n        }\n        if (code >= 0xfe00 && code <= 0xfe0f) {\n            return [];\n        }\n        // Substitute Table B.2 (Case Folding)\n        let codesTableB2 = _nameprepTableB2(code);\n        if (codesTableB2) {\n            return codesTableB2;\n        }\n        // No Substitution\n        return [code];\n    }));\n    // Normalize using form KC\n    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);\n    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n    codes.forEach((code) => {\n        if (_nameprepTableC(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_PROHIBITED\");\n        }\n    });\n    // Prohibit Unassigned Code Points (Table A.1)\n    codes.forEach((code) => {\n        if (_nameprepTableA1(code)) {\n            throw new Error(\"STRINGPREP_CONTAINS_UNASSIGNED\");\n        }\n    });\n    // IDNA extras\n    let name = _toUtf8String(codes);\n    // IDNA: 4.2.3.1\n    if (name.substring(0, 1) === \"-\" || name.substring(2, 4) === \"--\" || name.substring(name.length - 1) === \"-\") {\n        throw new Error(\"invalid hyphen\");\n    }\n    // IDNA: 4.2.4\n    if (name.length > 63) {\n        throw new Error(\"too long\");\n    }\n    return name;\n}\n//# sourceMappingURL=idna.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/hash/lib.esm/namehash.js\n\n\n\n\n\nconst namehash_logger = new Logger(hash_lib_esm_version_version);\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nconst Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nfunction isValidName(name) {\n    try {\n        const comps = name.split(\".\");\n        for (let i = 0; i < comps.length; i++) {\n            if (nameprep(comps[i]).length === 0) {\n                throw new Error(\"empty\");\n            }\n        }\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nfunction namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        namehash_logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let current = name;\n    let result = Zeros;\n    while (current.length) {\n        const partition = current.match(Partition);\n        if (partition == null || partition[2] === \"\") {\n            namehash_logger.throwArgumentError(\"invalid ENS address; missing component\", \"name\", name);\n        }\n        const label = toUtf8Bytes(nameprep(partition[3]));\n        result = keccak256(concat([result, keccak256(label)]));\n        current = partition[2] || \"\";\n    }\n    return hexlify(result);\n}\nfunction dnsEncode(name) {\n    return hexlify(concat(name.split(\".\").map((comp) => {\n        // We jam in an _ prefix to fill in with the length later\n        // Note: Nameprep throws if the component is over 63 bytes\n        const bytes = toUtf8Bytes(\"_\" + nameprep(comp));\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/networks/lib.esm/_version.js\nconst networks_lib_esm_version_version = \"networks/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/networks/lib.esm/index.js\n\n\n\nconst networks_lib_esm_logger = new Logger(networks_lib_esm_version_version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\"];\n            try {\n                const provider = new providers.PocketProvider(network);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: { chainId: 137, name: \"matic\" },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: { chainId: 10, name: \"optimism\" },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nfunction getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            networks_lib_esm_logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        networks_lib_esm_logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/sha2/lib.esm/types.js\nvar SupportedAlgorithm;\n(function (SupportedAlgorithm) {\n    SupportedAlgorithm[\"sha256\"] = \"sha256\";\n    SupportedAlgorithm[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithm || (SupportedAlgorithm = {}));\n;\n//# sourceMappingURL=types.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/sha2/lib.esm/_version.js\nconst sha2_lib_esm_version_version = \"sha2/5.6.0\";\n//# sourceMappingURL=_version.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/sha2/lib.esm/sha2.js\n\n\n//const _ripemd160 = _hash.ripemd160;\n\n\n\n\nconst sha2_logger = new Logger(sha2_lib_esm_version_version);\nfunction ripemd160(data) {\n    return \"0x\" + (hash_default().ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\nfunction sha256(data) {\n    return \"0x\" + (hash_default().sha256().update(arrayify(data)).digest(\"hex\"));\n}\nfunction sha512(data) {\n    return \"0x\" + (hash_default().sha512().update(arrayify(data)).digest(\"hex\"));\n}\nfunction computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithm[algorithm]) {\n        sha2_logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash_default().hmac((hash_default())[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map\n// EXTERNAL MODULE: ./node_modules/bech32/index.js\nvar bech32 = __webpack_require__(\"./node_modules/bech32/index.js\");\nvar bech32_default = /*#__PURE__*/__webpack_require__.n(bech32);\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/constants/lib.esm/addresses.js\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/formatter.js\n\n\n\n\n\n\n\n\n\nconst formatter_logger = new Logger(lib_esm_version_version);\nclass Formatter {\n    constructor() {\n        formatter_logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return formatter_logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return formatter_logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parse(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        formatter_logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    formatter_logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                formatter_logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nfunction isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nfunction isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nfunction showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/base-provider.js\n\nvar base_provider_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst base_provider_logger = new Logger(lib_esm_version_version);\n\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        base_provider_logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        base_provider_logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nclass base_provider_Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        base_provider_logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = arrayify(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return hexConcat(result);\n}\nclass Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = hexConcat([\"0x9061b923\", encodeBytes([dnsEncode(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((arrayify(result).length % 32) === 4) {\n                    base_provider_logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            base_provider_logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32_default().toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32_default().encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                base_provider_logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            return base_provider_logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nclass BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        base_provider_logger.checkNew(new.target, Provider);\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                base_provider_logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    base_provider_logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = (tx.from || \"0x0000000000000000000000000000000000000000\").toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return base_provider_logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return base_provider_logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                base_provider_logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", base_provider_logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // Filter from the last known event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild\n                            if (filter.toBlock - this._maxFilterBlockRange > filter.fromBlock) {\n                                filter.fromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            return base_provider_logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = base_provider_logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => base_provider_awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => base_provider_awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(base_provider_logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(base_provider_logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            base_provider_logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => base_provider_awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                base_provider_logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                base_provider_logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n                try {\n                    const data = hexDataSlice(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = hexDataSlice(data, 0, 32);\n                    if (!BigNumber.from(sender).eq(txSender)) {\n                        base_provider_logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = hexDataSlice(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            base_provider_logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                        base_provider_logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = hexDataSlice(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        base_provider_logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return base_provider_logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                base_provider_logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                base_provider_logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    base_provider_logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => base_provider_awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => base_provider_awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => base_provider_awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    base_provider_logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcar resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                base_provider_logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + namehash(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                base_provider_logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resovler\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + namehash(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return base_provider_awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + namehash(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return base_provider_logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new base_provider_Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js\n\nvar json_rpc_provider_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\n\nconst json_rpc_provider_logger = new Logger(lib_esm_version_version);\n\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n        json_rpc_provider_logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    const transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        json_rpc_provider_logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        json_rpc_provider_logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        json_rpc_provider_logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        json_rpc_provider_logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        json_rpc_provider_logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst json_rpc_provider_constructorGuard = {};\nclass JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        json_rpc_provider_logger.checkNew(new.target, JsonRpcSigner);\n        super();\n        if (constructorGuard !== json_rpc_provider_constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            json_rpc_provider_logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return json_rpc_provider_logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(json_rpc_provider_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                json_rpc_provider_logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    json_rpc_provider_logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    json_rpc_provider_logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return json_rpc_provider_logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n        });\n    }\n    _legacySignMessage(message) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst json_rpc_provider_allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nclass JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        json_rpc_provider_logger.checkNew(new.target, JsonRpcProvider);\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return json_rpc_provider_logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return json_rpc_provider_logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(json_rpc_provider_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return json_rpc_provider_awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-a559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                json_rpc_provider_logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(json_rpc_provider_allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map\n;// CONCATENATED MODULE: ./node_modules/@ethersproject/providers/lib.esm/web3-provider.js\n\n\n\n\nconst web3_provider_logger = new Logger(lib_esm_version_version);\n\nlet _nextId = 1;\nfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n    const fetcher = \"Web3LegacyFetcher\";\n    return function (method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (_nextId++),\n            jsonrpc: \"2.0\"\n        };\n        return new Promise((resolve, reject) => {\n            this.emit(\"debug\", {\n                action: \"request\",\n                fetcher,\n                request: deepCopy(request),\n                provider: this\n            });\n            sendFunc(request, (error, response) => {\n                if (error) {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        fetcher,\n                        error,\n                        request,\n                        provider: this\n                    });\n                    return reject(error);\n                }\n                this.emit(\"debug\", {\n                    action: \"response\",\n                    fetcher,\n                    request,\n                    response,\n                    provider: this\n                });\n                if (response.error) {\n                    const error = new Error(response.error.message);\n                    error.code = response.error.code;\n                    error.data = response.error.data;\n                    return reject(error);\n                }\n                resolve(response.result);\n            });\n        });\n    };\n}\nfunction buildEip1193Fetcher(provider) {\n    return function (method, params) {\n        if (params == null) {\n            params = [];\n        }\n        const request = { method, params };\n        this.emit(\"debug\", {\n            action: \"request\",\n            fetcher: \"Eip1193Fetcher\",\n            request: deepCopy(request),\n            provider: this\n        });\n        return provider.request(request).then((response) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                response,\n                provider: this\n            });\n            return response;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                fetcher: \"Eip1193Fetcher\",\n                request,\n                error,\n                provider: this\n            });\n            throw error;\n        });\n    };\n}\nclass Web3Provider extends JsonRpcProvider {\n    constructor(provider, network) {\n        web3_provider_logger.checkNew(new.target, Web3Provider);\n        if (provider == null) {\n            web3_provider_logger.throwArgumentError(\"missing provider\", \"provider\", provider);\n        }\n        let path = null;\n        let jsonRpcFetchFunc = null;\n        let subprovider = null;\n        if (typeof (provider) === \"function\") {\n            path = \"unknown:\";\n            jsonRpcFetchFunc = provider;\n        }\n        else {\n            path = provider.host || provider.path || \"\";\n            if (!path && provider.isMetaMask) {\n                path = \"metamask\";\n            }\n            subprovider = provider;\n            if (provider.request) {\n                if (path === \"\") {\n                    path = \"eip-1193:\";\n                }\n                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n            }\n            else if (provider.sendAsync) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n            }\n            else if (provider.send) {\n                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n            }\n            else {\n                web3_provider_logger.throwArgumentError(\"unsupported provider\", \"provider\", provider);\n            }\n            if (!path) {\n                path = \"unknown:\";\n            }\n        }\n        super(path, network);\n        defineReadOnly(this, \"jsonRpcFetchFunc\", jsonRpcFetchFunc);\n        defineReadOnly(this, \"provider\", subprovider);\n    }\n    send(method, params) {\n        return this.jsonRpcFetchFunc(method, params);\n    }\n}\n//# sourceMappingURL=web3-provider.js.map\n// EXTERNAL MODULE: ./node_modules/events/events.js\nvar events = __webpack_require__(\"./node_modules/events/events.js\");\nvar events_default = /*#__PURE__*/__webpack_require__.n(events);\n;// CONCATENATED MODULE: ./src/wallet/events.ts\n// Events being emitted by an eip-1193 provider\r\n// See https://eips.ethereum.org/EIPS/eip-1193#events\r\nconst EthereumEvents = Object.freeze({\r\n    CONNECT: 'connect',\r\n    DISCONNECT: 'disconnect',\r\n    CHAIN_CHANGED: 'chainChanged',\r\n    ACCOUNTS_CHANGED: 'accountsChanged',\r\n});\r\n// Events emitted by the connectors,\r\n// The InternalWeb3Provider of Moralis will listen to these\r\nconst ConnectorEvents = Object.freeze({\r\n    CONNECT: 'connect',\r\n    DISCONNECT: 'disconnect',\r\n    CHAIN_CHANGED: 'chainChanged',\r\n    ACCOUNT_CHANGED: 'accountChanged',\r\n});\r\n\n;// CONCATENATED MODULE: ./src/wallet/AbstractWeb3Connector.ts\nvar AbstractWeb3Connector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * Abstract connector to connect EIP-1193 providers to Moralis\r\n *\r\n * It should implement at least:\r\n * - activate()\r\n * - Emit ConnectorEvent.CHAIN_CHANGED when the chain has changed (if possible)\r\n * - Emit ConnectorEvent.ACCOUNT_CHANGED when the account has changed (if possible)\r\n * - type: a name to identify\r\n * - network: the network type that is used (eg. 'evm')\r\n */\r\nclass AbstractWeb3Connector extends (events_default()) {\r\n    constructor() {\r\n        super();\r\n        this.type = 'abstract';\r\n        this.network = 'evm';\r\n        this.account = null;\r\n        this.chainId = null;\r\n        this.provider = null;\r\n        this.handleAccountsChanged = this.handleAccountsChanged.bind(this);\r\n        this.handleChainChanged = this.handleChainChanged.bind(this);\r\n        this.handleConnect = this.handleConnect.bind(this);\r\n        this.handleDisconnect = this.handleDisconnect.bind(this);\r\n    }\r\n    subscribeToEvents(provider) {\r\n        if (provider && provider.on) {\r\n            provider.on(EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);\r\n            provider.on(EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);\r\n            provider.on(EthereumEvents.CONNECT, this.handleConnect);\r\n            provider.on(EthereumEvents.DISCONNECT, this.handleDisconnect);\r\n        }\r\n    }\r\n    unsubscribeToEvents(provider) {\r\n        if (provider && provider.removeListener) {\r\n            provider.removeListener(EthereumEvents.CHAIN_CHANGED, this.handleChainChanged);\r\n            provider.removeListener(EthereumEvents.ACCOUNTS_CHANGED, this.handleAccountsChanged);\r\n            provider.removeListener(EthereumEvents.CONNECT, this.handleConnect);\r\n            provider.removeListener(EthereumEvents.DISCONNECT, this.handleDisconnect);\r\n        }\r\n    }\r\n    /**\r\n     * Activates the provider.\r\n     * Should returns an object with:\r\n     * - provider: A valid EIP-1193 provider\r\n     * - chainId(optional): the chainId that has been connected to (in hex format)\r\n     * - account(optional): the address that is connected to the provider\r\n     */\r\n    activate() {\r\n        return AbstractWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            throw new Error('Not implemented: activate()');\r\n        });\r\n    }\r\n    /**\r\n     * Updates account and emit event, on EIP-1193 accountsChanged events\r\n     */\r\n    handleAccountsChanged(accounts) {\r\n        const account = accounts && accounts[0] ? accounts[0].toLowerCase() : null;\r\n        this.account = account;\r\n        this.emit(ConnectorEvents.ACCOUNT_CHANGED, account);\r\n    }\r\n    /**\r\n     * Updates chainId and emit event, on EIP-1193 accountsChanged events\r\n     */\r\n    handleChainChanged(chainId) {\r\n        const newChainId = chainId;\r\n        this.chainId = newChainId;\r\n        this.emit(ConnectorEvents.CHAIN_CHANGED, newChainId);\r\n    }\r\n    handleConnect(connectInfo) {\r\n        this.emit(ConnectorEvents.CONNECT, connectInfo);\r\n    }\r\n    handleDisconnect(error) {\r\n        this.emit(ConnectorEvents.DISCONNECT, error);\r\n    }\r\n    /**\r\n     * Cleans all active listners, connections and stale references\r\n     */\r\n    deactivate() {\r\n        return AbstractWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            this.unsubscribeToEvents(this.provider);\r\n            this.account = null;\r\n            this.chainId = null;\r\n        });\r\n    }\r\n}\r\n/* harmony default export */ const wallet_AbstractWeb3Connector = (AbstractWeb3Connector);\r\n\n;// CONCATENATED MODULE: ./node_modules/@magic-sdk/types/dist/es/index.mjs\nvar a=(n=>(n.MissingApiKey=\"MISSING_API_KEY\",n.ModalNotReady=\"MODAL_NOT_READY\",n.MalformedResponse=\"MALFORMED_RESPONSE\",n.InvalidArgument=\"INVALID_ARGUMENT\",n.ExtensionNotInitialized=\"EXTENSION_NOT_INITIALIZED\",n.IncompatibleExtensions=\"INCOMPATIBLE_EXTENSIONS\",n))(a||{}),m=(_=>(_.SyncWeb3Method=\"SYNC_WEB3_METHOD\",_.DuplicateIframe=\"DUPLICATE_IFRAME\",_.ReactNativeEndpointConfiguration=\"REACT_NATIVE_ENDPOINT_CONFIGURATION\",_.DeprecationNotice=\"DEPRECATION_NOTICE\",_))(m||{}),p=(e=>(e[e.ParseError=-32700]=\"ParseError\",e[e.InvalidRequest=-32600]=\"InvalidRequest\",e[e.MethodNotFound=-32601]=\"MethodNotFound\",e[e.InvalidParams=-32602]=\"InvalidParams\",e[e.InternalError=-32603]=\"InternalError\",e[e.MagicLinkFailedVerification=-1e4]=\"MagicLinkFailedVerification\",e[e.MagicLinkExpired=-10001]=\"MagicLinkExpired\",e[e.MagicLinkRateLimited=-10002]=\"MagicLinkRateLimited\",e[e.MagicLinkInvalidRedirectURL=-10006]=\"MagicLinkInvalidRedirectURL\",e[e.UserAlreadyLoggedIn=-10003]=\"UserAlreadyLoggedIn\",e[e.UpdateEmailFailed=-10004]=\"UpdateEmailFailed\",e[e.UserRequestEditEmail=-10005]=\"UserRequestEditEmail\",e[e.InactiveRecipient=-10010]=\"InactiveRecipient\",e[e.AccessDeniedToUser=-10011]=\"AccessDeniedToUser\",e))(p||{});var u=(t=>(t.LoginWithSms=\"magic_auth_login_with_sms\",t.LoginWithEmailOTP=\"magic_auth_login_with_email_otp\",t.LoginWithMagicLink=\"magic_auth_login_with_magic_link\",t.LoginWithCredential=\"magic_auth_login_with_credential\",t.GetIdToken=\"magic_auth_get_id_token\",t.GenerateIdToken=\"magic_auth_generate_id_token\",t.GetMetadata=\"magic_auth_get_metadata\",t.IsLoggedIn=\"magic_auth_is_logged_in\",t.Logout=\"magic_auth_logout\",t.UpdateEmail=\"magic_auth_update_email\",t.UserSettings=\"magic_auth_settings\",t.UserSettingsTestMode=\"magic_auth_settings_testing_mode\",t.LoginWithSmsTestMode=\"magic_auth_login_with_sms_testing_mode\",t.LoginWithEmailOTPTestMode=\"magic_auth_login_with_email_otp_testing_mode\",t.LoginWithMagicLinkTestMode=\"magic_login_with_magic_link_testing_mode\",t.LoginWithCredentialTestMode=\"magic_auth_login_with_credential_testing_mode\",t.GetIdTokenTestMode=\"magic_auth_get_id_token_testing_mode\",t.GenerateIdTokenTestMode=\"magic_auth_generate_id_token_testing_mode\",t.GetMetadataTestMode=\"magic_auth_get_metadata_testing_mode\",t.IsLoggedInTestMode=\"magic_auth_is_logged_in_testing_mode\",t.LogoutTestMode=\"magic_auth_logout_testing_mode\",t.UpdateEmailTestMode=\"magic_auth_update_email_testing_mode\",t))(u||{});var g=(i=>(i.MAGIC_HANDLE_RESPONSE=\"MAGIC_HANDLE_RESPONSE\",i.MAGIC_OVERLAY_READY=\"MAGIC_OVERLAY_READY\",i.MAGIC_SHOW_OVERLAY=\"MAGIC_SHOW_OVERLAY\",i.MAGIC_HIDE_OVERLAY=\"MAGIC_HIDE_OVERLAY\",i.MAGIC_HANDLE_EVENT=\"MAGIC_HANDLE_EVENT\",i))(g||{}),o=(s=>(s.MAGIC_HANDLE_REQUEST=\"MAGIC_HANDLE_REQUEST\",s))(o||{});var l=(s=>(s.Harmony=\"HARMONY\",s))(l||{});\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@magic-sdk/provider/dist/es/index.mjs\nvar yt=Object.create;var U=Object.defineProperty,Rt=Object.defineProperties,Tt=Object.getOwnPropertyDescriptor,vt=Object.getOwnPropertyDescriptors,xt=Object.getOwnPropertyNames,be=Object.getOwnPropertySymbols,It=Object.getPrototypeOf,Me=Object.prototype.hasOwnProperty,Pt=Object.prototype.propertyIsEnumerable;var Ne=(t,e,n)=>e in t?U(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,z=(t,e)=>{for(var n in e||(e={}))Me.call(e,n)&&Ne(t,n,e[n]);if(be)for(var n of be(e))Pt.call(e,n)&&Ne(t,n,e[n]);return t},we=(t,e)=>Rt(t,vt(e)),$t=t=>U(t,\"__esModule\",{value:!0});var bt=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Mt=(t,e)=>{for(var n in e)U(t,n,{get:e[n],enumerable:!0})},Nt=(t,e,n,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of xt(e))!Me.call(t,s)&&(n||s!==\"default\")&&U(t,s,{get:()=>e[s],enumerable:!(r=Tt(e,s))||r.enumerable});return t},wt=(t,e)=>Nt($t(U(t!=null?yt(It(t)):{},\"default\",!e&&t&&t.__esModule?{get:()=>t.default,enumerable:!0}:{value:t,enumerable:!0})),t);var I=(t,e,n)=>new Promise((r,s)=>{var o=c=>{try{i(n.next(c))}catch(p){s(p)}},a=c=>{try{i(n.throw(c))}catch(p){s(p)}},i=c=>c.done?r(c.value):Promise.resolve(c.value).then(o,a);i((n=n.apply(t,e)).next())});var nt=bt((fr,fe)=>{\"use strict\";var $n=Object.prototype.hasOwnProperty,T=\"~\";function B(){}Object.create&&(B.prototype=Object.create(null),new B().__proto__||(T=!1));function bn(t,e,n){this.fn=t,this.context=e,this.once=n||!1}function tt(t,e,n,r,s){if(typeof n!=\"function\")throw new TypeError(\"The listener must be a function\");var o=new bn(n,r||t,s),a=T?T+e:e;return t._events[a]?t._events[a].fn?t._events[a]=[t._events[a],o]:t._events[a].push(o):(t._events[a]=o,t._eventsCount++),t}function oe(t,e){--t._eventsCount===0?t._events=new B:delete t._events[e]}function y(){this._events=new B,this._eventsCount=0}y.prototype.eventNames=function(){var e=[],n,r;if(this._eventsCount===0)return e;for(r in n=this._events)$n.call(n,r)&&e.push(T?r.slice(1):r);return Object.getOwnPropertySymbols?e.concat(Object.getOwnPropertySymbols(n)):e};y.prototype.listeners=function(e){var n=T?T+e:e,r=this._events[n];if(!r)return[];if(r.fn)return[r.fn];for(var s=0,o=r.length,a=new Array(o);s<o;s++)a[s]=r[s].fn;return a};y.prototype.listenerCount=function(e){var n=T?T+e:e,r=this._events[n];return r?r.fn?1:r.length:0};y.prototype.emit=function(e,n,r,s,o,a){var i=T?T+e:e;if(!this._events[i])return!1;var c=this._events[i],p=arguments.length,l,u;if(c.fn){switch(c.once&&this.removeListener(e,c.fn,void 0,!0),p){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,n),!0;case 3:return c.fn.call(c.context,n,r),!0;case 4:return c.fn.call(c.context,n,r,s),!0;case 5:return c.fn.call(c.context,n,r,s,o),!0;case 6:return c.fn.call(c.context,n,r,s,o,a),!0}for(u=1,l=new Array(p-1);u<p;u++)l[u-1]=arguments[u];c.fn.apply(c.context,l)}else{var v=c.length,M;for(u=0;u<v;u++)switch(c[u].once&&this.removeListener(e,c[u].fn,void 0,!0),p){case 1:c[u].fn.call(c[u].context);break;case 2:c[u].fn.call(c[u].context,n);break;case 3:c[u].fn.call(c[u].context,n,r);break;case 4:c[u].fn.call(c[u].context,n,r,s);break;default:if(!l)for(M=1,l=new Array(p-1);M<p;M++)l[M-1]=arguments[M];c[u].fn.apply(c[u].context,l)}}return!0};y.prototype.on=function(e,n,r){return tt(this,e,n,r,!1)};y.prototype.once=function(e,n,r){return tt(this,e,n,r,!0)};y.prototype.removeListener=function(e,n,r,s){var o=T?T+e:e;if(!this._events[o])return this;if(!n)return oe(this,o),this;var a=this._events[o];if(a.fn)a.fn===n&&(!s||a.once)&&(!r||a.context===r)&&oe(this,o);else{for(var i=0,c=[],p=a.length;i<p;i++)(a[i].fn!==n||s&&!a[i].once||r&&a[i].context!==r)&&c.push(a[i]);c.length?this._events[o]=c.length===1?c[0]:c:oe(this,o)}return this};y.prototype.removeAllListeners=function(e){var n;return e?(n=T?T+e:e,this._events[n]&&oe(this,n)):(this._events=new B,this._eventsCount=0),this};y.prototype.off=y.prototype.removeListener;y.prototype.addListener=y.prototype.on;y.prefixed=T;y.EventEmitter=y;typeof fe!=\"undefined\"&&(fe.exports=y)});function At(t){let e={exports:{}};return t(e,e.exports),e.exports}var Lt=Number.MAX_SAFE_INTEGER||9007199254740991;var me={SEMVER_SPEC_VERSION:\"2.0.0\",MAX_LENGTH:256,MAX_SAFE_INTEGER:Lt,MAX_SAFE_COMPONENT_LENGTH:16},St=typeof process==\"object\"&&process.env&&process.env.NODE_DEBUG&&/\\bsemver\\b/i.test(process.env.NODE_DEBUG)?(...t)=>console.error(\"SEMVER\",...t):()=>{},d=St,K=At(function(t,e){let{MAX_SAFE_COMPONENT_LENGTH:n}=me,r=(e=t.exports={}).re=[],s=e.src=[],o=e.t={},a=0,i=(c,p,l)=>{let u=a++;d(u,p),o[c]=u,s[u]=p,r[u]=new RegExp(p,l?\"g\":void 0)};i(\"NUMERICIDENTIFIER\",\"0|[1-9]\\\\d*\"),i(\"NUMERICIDENTIFIERLOOSE\",\"[0-9]+\"),i(\"NONNUMERICIDENTIFIER\",\"\\\\d*[a-zA-Z-][a-zA-Z0-9-]*\"),i(\"MAINVERSION\",`(${s[o.NUMERICIDENTIFIER]})\\\\.(${s[o.NUMERICIDENTIFIER]})\\\\.(${s[o.NUMERICIDENTIFIER]})`),i(\"MAINVERSIONLOOSE\",`(${s[o.NUMERICIDENTIFIERLOOSE]})\\\\.(${s[o.NUMERICIDENTIFIERLOOSE]})\\\\.(${s[o.NUMERICIDENTIFIERLOOSE]})`),i(\"PRERELEASEIDENTIFIER\",`(?:${s[o.NUMERICIDENTIFIER]}|${s[o.NONNUMERICIDENTIFIER]})`),i(\"PRERELEASEIDENTIFIERLOOSE\",`(?:${s[o.NUMERICIDENTIFIERLOOSE]}|${s[o.NONNUMERICIDENTIFIER]})`),i(\"PRERELEASE\",`(?:-(${s[o.PRERELEASEIDENTIFIER]}(?:\\\\.${s[o.PRERELEASEIDENTIFIER]})*))`),i(\"PRERELEASELOOSE\",`(?:-?(${s[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\\\.${s[o.PRERELEASEIDENTIFIERLOOSE]})*))`),i(\"BUILDIDENTIFIER\",\"[0-9A-Za-z-]+\"),i(\"BUILD\",`(?:\\\\+(${s[o.BUILDIDENTIFIER]}(?:\\\\.${s[o.BUILDIDENTIFIER]})*))`),i(\"FULLPLAIN\",`v?${s[o.MAINVERSION]}${s[o.PRERELEASE]}?${s[o.BUILD]}?`),i(\"FULL\",`^${s[o.FULLPLAIN]}$`),i(\"LOOSEPLAIN\",`[v=\\\\s]*${s[o.MAINVERSIONLOOSE]}${s[o.PRERELEASELOOSE]}?${s[o.BUILD]}?`),i(\"LOOSE\",`^${s[o.LOOSEPLAIN]}$`),i(\"GTLT\",\"((?:<|>)?=?)\"),i(\"XRANGEIDENTIFIERLOOSE\",`${s[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\\\*`),i(\"XRANGEIDENTIFIER\",`${s[o.NUMERICIDENTIFIER]}|x|X|\\\\*`),i(\"XRANGEPLAIN\",`[v=\\\\s]*(${s[o.XRANGEIDENTIFIER]})(?:\\\\.(${s[o.XRANGEIDENTIFIER]})(?:\\\\.(${s[o.XRANGEIDENTIFIER]})(?:${s[o.PRERELEASE]})?${s[o.BUILD]}?)?)?`),i(\"XRANGEPLAINLOOSE\",`[v=\\\\s]*(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:${s[o.PRERELEASELOOSE]})?${s[o.BUILD]}?)?)?`),i(\"XRANGE\",`^${s[o.GTLT]}\\\\s*${s[o.XRANGEPLAIN]}$`),i(\"XRANGELOOSE\",`^${s[o.GTLT]}\\\\s*${s[o.XRANGEPLAINLOOSE]}$`),i(\"COERCE\",`(^|[^\\\\d])(\\\\d{1,${n}})(?:\\\\.(\\\\d{1,${n}}))?(?:\\\\.(\\\\d{1,${n}}))?(?:$|[^\\\\d])`),i(\"COERCERTL\",s[o.COERCE],!0),i(\"LONETILDE\",\"(?:~>?)\"),i(\"TILDETRIM\",`(\\\\s*)${s[o.LONETILDE]}\\\\s+`,!0),e.tildeTrimReplace=\"$1~\",i(\"TILDE\",`^${s[o.LONETILDE]}${s[o.XRANGEPLAIN]}$`),i(\"TILDELOOSE\",`^${s[o.LONETILDE]}${s[o.XRANGEPLAINLOOSE]}$`),i(\"LONECARET\",\"(?:\\\\^)\"),i(\"CARETTRIM\",`(\\\\s*)${s[o.LONECARET]}\\\\s+`,!0),e.caretTrimReplace=\"$1^\",i(\"CARET\",`^${s[o.LONECARET]}${s[o.XRANGEPLAIN]}$`),i(\"CARETLOOSE\",`^${s[o.LONECARET]}${s[o.XRANGEPLAINLOOSE]}$`),i(\"COMPARATORLOOSE\",`^${s[o.GTLT]}\\\\s*(${s[o.LOOSEPLAIN]})$|^$`),i(\"COMPARATOR\",`^${s[o.GTLT]}\\\\s*(${s[o.FULLPLAIN]})$|^$`),i(\"COMPARATORTRIM\",`(\\\\s*)${s[o.GTLT]}\\\\s*(${s[o.LOOSEPLAIN]}|${s[o.XRANGEPLAIN]})`,!0),e.comparatorTrimReplace=\"$1$2$3\",i(\"HYPHENRANGE\",`^\\\\s*(${s[o.XRANGEPLAIN]})\\\\s+-\\\\s+(${s[o.XRANGEPLAIN]})\\\\s*$`),i(\"HYPHENRANGELOOSE\",`^\\\\s*(${s[o.XRANGEPLAINLOOSE]})\\\\s+-\\\\s+(${s[o.XRANGEPLAINLOOSE]})\\\\s*$`),i(\"STAR\",\"(<|>)?=?\\\\s*\\\\*\"),i(\"GTE0\",\"^\\\\s*>=\\\\s*0.0.0\\\\s*$\"),i(\"GTE0PRE\",\"^\\\\s*>=\\\\s*0.0.0-0\\\\s*$\")}),Ae=/^[0-9]+$/,Le=(t,e)=>{let n=Ae.test(t),r=Ae.test(e);return n&&r&&(t=+t,e=+e),t===e?0:n&&!r?-1:r&&!n?1:t<e?-1:1},Ot=(t,e)=>Le(e,t),Ct={compareIdentifiers:Le,rcompareIdentifiers:Ot},{MAX_LENGTH:Se,MAX_SAFE_INTEGER:Y}=me,{re:Oe,t:Ce}=K,{compareIdentifiers:j}=Ct,E=class{constructor(e,n){if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),e instanceof E){if(e.loose===!!n.loose&&e.includePrerelease===!!n.includePrerelease)return e;e=e.version}else if(typeof e!=\"string\")throw new TypeError(`Invalid Version: ${e}`);if(e.length>Se)throw new TypeError(`version is longer than ${Se} characters`);d(\"SemVer\",e,n),this.options=n,this.loose=!!n.loose,this.includePrerelease=!!n.includePrerelease;let r=e.trim().match(n.loose?Oe[Ce.LOOSE]:Oe[Ce.FULL]);if(!r)throw new TypeError(`Invalid Version: ${e}`);if(this.raw=e,this.major=+r[1],this.minor=+r[2],this.patch=+r[3],this.major>Y||this.major<0)throw new TypeError(\"Invalid major version\");if(this.minor>Y||this.minor<0)throw new TypeError(\"Invalid minor version\");if(this.patch>Y||this.patch<0)throw new TypeError(\"Invalid patch version\");r[4]?this.prerelease=r[4].split(\".\").map(s=>{if(/^[0-9]+$/.test(s)){let o=+s;if(o>=0&&o<Y)return o}return s}):this.prerelease=[],this.build=r[5]?r[5].split(\".\"):[],this.format()}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(\".\")}`),this.version}toString(){return this.version}compare(e){if(d(\"SemVer.compare\",this.version,this.options,e),!(e instanceof E)){if(typeof e==\"string\"&&e===this.version)return 0;e=new E(e,this.options)}return e.version===this.version?0:this.compareMain(e)||this.comparePre(e)}compareMain(e){return e instanceof E||(e=new E(e,this.options)),j(this.major,e.major)||j(this.minor,e.minor)||j(this.patch,e.patch)}comparePre(e){if(e instanceof E||(e=new E(e,this.options)),this.prerelease.length&&!e.prerelease.length)return-1;if(!this.prerelease.length&&e.prerelease.length)return 1;if(!this.prerelease.length&&!e.prerelease.length)return 0;let n=0;do{let r=this.prerelease[n],s=e.prerelease[n];if(d(\"prerelease compare\",n,r,s),r===void 0&&s===void 0)return 0;if(s===void 0)return 1;if(r===void 0)return-1;if(r!==s)return j(r,s)}while(++n)}compareBuild(e){e instanceof E||(e=new E(e,this.options));let n=0;do{let r=this.build[n],s=e.build[n];if(d(\"prerelease compare\",n,r,s),r===void 0&&s===void 0)return 0;if(s===void 0)return 1;if(r===void 0)return-1;if(r!==s)return j(r,s)}while(++n)}inc(e,n){switch(e){case\"premajor\":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc(\"pre\",n);break;case\"preminor\":this.prerelease.length=0,this.patch=0,this.minor++,this.inc(\"pre\",n);break;case\"prepatch\":this.prerelease.length=0,this.inc(\"patch\",n),this.inc(\"pre\",n);break;case\"prerelease\":this.prerelease.length===0&&this.inc(\"patch\",n),this.inc(\"pre\",n);break;case\"major\":this.minor===0&&this.patch===0&&this.prerelease.length!==0||this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case\"minor\":this.patch===0&&this.prerelease.length!==0||this.minor++,this.patch=0,this.prerelease=[];break;case\"patch\":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case\"pre\":if(this.prerelease.length===0)this.prerelease=[0];else{let r=this.prerelease.length;for(;--r>=0;)typeof this.prerelease[r]==\"number\"&&(this.prerelease[r]++,r=-2);r===-1&&this.prerelease.push(0)}n&&(this.prerelease[0]===n?isNaN(this.prerelease[1])&&(this.prerelease=[n,0]):this.prerelease=[n,0]);break;default:throw new Error(`invalid increment argument: ${e}`)}return this.format(),this.raw=this.version,this}},_t=(t,e,n)=>new E(t,n).compare(new E(e,n)),k=_t,Dt=(t,e,n)=>k(t,e,n)===0,kt=Dt,Jt=(t,e,n)=>k(t,e,n)!==0,qt=Jt,Gt=(t,e,n)=>k(t,e,n)>0,Ut=Gt,Kt=(t,e,n)=>k(t,e,n)>=0,jt=Kt,Ft=(t,e,n)=>k(t,e,n)<0,Wt=Ft,Xt=(t,e,n)=>k(t,e,n)<=0,Bt=Xt,Ht=(t,e,n,r)=>{switch(e){case\"===\":return typeof t==\"object\"&&(t=t.version),typeof n==\"object\"&&(n=n.version),t===n;case\"!==\":return typeof t==\"object\"&&(t=t.version),typeof n==\"object\"&&(n=n.version),t!==n;case\"\":case\"=\":case\"==\":return kt(t,n,r);case\"!=\":return qt(t,n,r);case\">\":return Ut(t,n,r);case\">=\":return jt(t,n,r);case\"<\":return Wt(t,n,r);case\"<=\":return Bt(t,n,r);default:throw new TypeError(`Invalid operator: ${e}`)}},Ee=Ht,F=Symbol(\"SemVer ANY\"),O=class{static get ANY(){return F}constructor(e,n){if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),e instanceof O){if(e.loose===!!n.loose)return e;e=e.value}d(\"comparator\",e,n),this.options=n,this.loose=!!n.loose,this.parse(e),this.semver===F?this.value=\"\":this.value=this.operator+this.semver.version,d(\"comp\",this)}parse(e){let n=this.options.loose?_e[De.COMPARATORLOOSE]:_e[De.COMPARATOR],r=e.match(n);if(!r)throw new TypeError(`Invalid comparator: ${e}`);this.operator=r[1]!==void 0?r[1]:\"\",this.operator===\"=\"&&(this.operator=\"\"),r[2]?this.semver=new E(r[2],this.options.loose):this.semver=F}toString(){return this.value}test(e){if(d(\"Comparator.test\",e,this.options.loose),this.semver===F||e===F)return!0;if(typeof e==\"string\")try{e=new E(e,this.options)}catch(n){return!1}return Ee(e,this.operator,this.semver,this.options)}intersects(e,n){if(!(e instanceof O))throw new TypeError(\"a Comparator is required\");if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),this.operator===\"\")return this.value===\"\"||new N(e.value,n).test(this.value);if(e.operator===\"\")return e.value===\"\"||new N(this.value,n).test(e.semver);let r=!(this.operator!==\">=\"&&this.operator!==\">\"||e.operator!==\">=\"&&e.operator!==\">\"),s=!(this.operator!==\"<=\"&&this.operator!==\"<\"||e.operator!==\"<=\"&&e.operator!==\"<\"),o=this.semver.version===e.semver.version,a=!(this.operator!==\">=\"&&this.operator!==\"<=\"||e.operator!==\">=\"&&e.operator!==\"<=\"),i=Ee(this.semver,\"<\",e.semver,n)&&(this.operator===\">=\"||this.operator===\">\")&&(e.operator===\"<=\"||e.operator===\"<\"),c=Ee(this.semver,\">\",e.semver,n)&&(this.operator===\"<=\"||this.operator===\"<\")&&(e.operator===\">=\"||e.operator===\">\");return r||s||o&&a||i||c}},{re:_e,t:De}=K,N=class{constructor(e,n){if(n&&typeof n==\"object\"||(n={loose:!!n,includePrerelease:!1}),e instanceof N)return e.loose===!!n.loose&&e.includePrerelease===!!n.includePrerelease?e:new N(e.raw,n);if(e instanceof O)return this.raw=e.value,this.set=[[e]],this.format(),this;if(this.options=n,this.loose=!!n.loose,this.includePrerelease=!!n.includePrerelease,this.raw=e,this.set=e.split(/\\s*\\|\\|\\s*/).map(r=>this.parseRange(r.trim())).filter(r=>r.length),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${e}`);this.format()}format(){return this.range=this.set.map(e=>e.join(\" \").trim()).join(\"||\").trim(),this.range}toString(){return this.range}parseRange(e){let{loose:n}=this.options;e=e.trim();let r=n?es_g[f.HYPHENRANGELOOSE]:es_g[f.HYPHENRANGE];e=e.replace(r,cn(this.options.includePrerelease)),d(\"hyphen replace\",e),e=e.replace(es_g[f.COMPARATORTRIM],Vt),d(\"comparator trim\",e,es_g[f.COMPARATORTRIM]),e=(e=(e=e.replace(es_g[f.TILDETRIM],zt)).replace(es_g[f.CARETTRIM],Yt)).split(/\\s+/).join(\" \");let s=n?es_g[f.COMPARATORLOOSE]:es_g[f.COMPARATOR];return e.split(\" \").map(o=>Zt(o,this.options)).join(\" \").split(/\\s+/).map(o=>an(o,this.options)).filter(this.options.loose?o=>!!o.match(s):()=>!0).map(o=>new O(o,this.options))}intersects(e,n){if(!(e instanceof N))throw new TypeError(\"a Range is required\");return this.set.some(r=>ke(r,n)&&e.set.some(s=>ke(s,n)&&r.every(o=>s.every(a=>o.intersects(a,n)))))}test(e){if(!e)return!1;if(typeof e==\"string\")try{e=new E(e,this.options)}catch(n){return!1}for(let n=0;n<this.set.length;n++)if(ln(this.set[n],e,this.options))return!0;return!1}},{re:es_g,t:f,comparatorTrimReplace:Vt,tildeTrimReplace:zt,caretTrimReplace:Yt}=K,ke=(t,e)=>{let n=!0,r=t.slice(),s=r.pop();for(;n&&r.length;)n=r.every(o=>s.intersects(o,e)),s=r.pop();return n},Zt=(t,e)=>(d(\"comp\",t,e),t=tn(t,e),d(\"caret\",t),t=Qt(t,e),d(\"tildes\",t),t=rn(t,e),d(\"xrange\",t),t=on(t,e),d(\"stars\",t),t),R=t=>!t||t.toLowerCase()===\"x\"||t===\"*\",Qt=(t,e)=>t.trim().split(/\\s+/).map(n=>en(n,e)).join(\" \"),en=(t,e)=>{let n=e.loose?es_g[f.TILDELOOSE]:es_g[f.TILDE];return t.replace(n,(r,s,o,a,i)=>{let c;return d(\"tilde\",t,r,s,o,a,i),R(s)?c=\"\":R(o)?c=`>=${s}.0.0 <${+s+1}.0.0-0`:R(a)?c=`>=${s}.${o}.0 <${s}.${+o+1}.0-0`:i?(d(\"replaceTilde pr\",i),c=`>=${s}.${o}.${a}-${i} <${s}.${+o+1}.0-0`):c=`>=${s}.${o}.${a} <${s}.${+o+1}.0-0`,d(\"tilde return\",c),c})},tn=(t,e)=>t.trim().split(/\\s+/).map(n=>nn(n,e)).join(\" \"),nn=(t,e)=>{d(\"caret\",t,e);let n=e.loose?es_g[f.CARETLOOSE]:es_g[f.CARET],r=e.includePrerelease?\"-0\":\"\";return t.replace(n,(s,o,a,i,c)=>{let p;return d(\"caret\",t,s,o,a,i,c),R(o)?p=\"\":R(a)?p=`>=${o}.0.0${r} <${+o+1}.0.0-0`:R(i)?p=o===\"0\"?`>=${o}.${a}.0${r} <${o}.${+a+1}.0-0`:`>=${o}.${a}.0${r} <${+o+1}.0.0-0`:c?(d(\"replaceCaret pr\",c),p=o===\"0\"?a===\"0\"?`>=${o}.${a}.${i}-${c} <${o}.${a}.${+i+1}-0`:`>=${o}.${a}.${i}-${c} <${o}.${+a+1}.0-0`:`>=${o}.${a}.${i}-${c} <${+o+1}.0.0-0`):(d(\"no pr\"),p=o===\"0\"?a===\"0\"?`>=${o}.${a}.${i}${r} <${o}.${a}.${+i+1}-0`:`>=${o}.${a}.${i}${r} <${o}.${+a+1}.0-0`:`>=${o}.${a}.${i} <${+o+1}.0.0-0`),d(\"caret return\",p),p})},rn=(t,e)=>(d(\"replaceXRanges\",t,e),t.split(/\\s+/).map(n=>sn(n,e)).join(\" \")),sn=(t,e)=>{t=t.trim();let n=e.loose?es_g[f.XRANGELOOSE]:es_g[f.XRANGE];return t.replace(n,(r,s,o,a,i,c)=>{d(\"xRange\",t,r,s,o,a,i,c);let p=R(o),l=p||R(a),u=l||R(i),v=u;return s===\"=\"&&v&&(s=\"\"),c=e.includePrerelease?\"-0\":\"\",p?r=s===\">\"||s===\"<\"?\"<0.0.0-0\":\"*\":s&&v?(l&&(a=0),i=0,s===\">\"?(s=\">=\",l?(o=+o+1,a=0,i=0):(a=+a+1,i=0)):s===\"<=\"&&(s=\"<\",l?o=+o+1:a=+a+1),s===\"<\"&&(c=\"-0\"),r=`${s+o}.${a}.${i}${c}`):l?r=`>=${o}.0.0${c} <${+o+1}.0.0-0`:u&&(r=`>=${o}.${a}.0${c} <${o}.${+a+1}.0-0`),d(\"xRange return\",r),r})},on=(t,e)=>(d(\"replaceStars\",t,e),t.trim().replace(es_g[f.STAR],\"\")),an=(t,e)=>(d(\"replaceGTE0\",t,e),t.trim().replace(es_g[e.includePrerelease?f.GTE0PRE:f.GTE0],\"\")),cn=t=>(e,n,r,s,o,a,i,c,p,l,u,v,M)=>`${n=R(r)?\"\":R(s)?`>=${r}.0.0${t?\"-0\":\"\"}`:R(o)?`>=${r}.${s}.0${t?\"-0\":\"\"}`:a?`>=${n}`:`>=${n}${t?\"-0\":\"\"}`} ${c=R(p)?\"\":R(l)?`<${+p+1}.0.0-0`:R(u)?`<${p}.${+l+1}.0-0`:v?`<=${p}.${l}.${u}-${v}`:t?`<${p}.${l}.${+u+1}-0`:`<=${c}`}`.trim(),ln=(t,e,n)=>{for(let r=0;r<t.length;r++)if(!t[r].test(e))return!1;if(e.prerelease.length&&!n.includePrerelease){for(let r=0;r<t.length;r++)if(d(t[r].semver),t[r].semver!==O.ANY&&t[r].semver.prerelease.length>0){let s=t[r].semver;if(s.major===e.major&&s.minor===e.minor&&s.patch===e.patch)return!0}return!1}return!0},Je=(t,e,n)=>{try{e=new N(e,n)}catch(r){return!1}return e.test(t)};var{MAX_LENGTH:pn}=me,{re:qe,t:Ge}=K,un=(t,e)=>{if(e&&typeof e==\"object\"||(e={loose:!!e,includePrerelease:!1}),t instanceof E)return t;if(typeof t!=\"string\"||t.length>pn||!(e.loose?qe[Ge.LOOSE]:qe[Ge.FULL]).test(t))return null;try{return new E(t,e)}catch(n){return null}},dn=un,{re:Z,t:Q}=K,Ue=(t,e)=>{if(t instanceof E)return t;if(typeof t==\"number\"&&(t=String(t)),typeof t!=\"string\")return null;let n=null;if((e=e||{}).rtl){let r;for(;(r=Z[Q.COERCERTL].exec(t))&&(!n||n.index+n[0].length!==t.length);)n&&r.index+r[0].length===n.index+n[0].length||(n=r),Z[Q.COERCERTL].lastIndex=r.index+r[1].length+r[2].length;Z[Q.COERCERTL].lastIndex=-1}else n=t.match(Z[Q.COERCE]);return n===null?null:dn(`${n[2]}.${n[3]||\"0\"}.${n[4]||\"0\"}`,e)};function mn(t){return String.fromCharCode(parseInt(t.slice(1),16))}function En(t){return`%${`00${t.charCodeAt(0).toString(16)}`.slice(-2)}`}function hn(t){return btoa(encodeURIComponent(t).replace(/%[0-9A-F]{2}/g,mn))}function fn(t){return decodeURIComponent(Array.from(atob(t),En).join(\"\"))}function ee(t){return hn(JSON.stringify(t))}function Ke(t){return JSON.parse(fn(t))}function $(t){return typeof t==\"undefined\"}function Rn(t){return t===null}function te(t){return Rn(t)||$(t)}function er(t){return te(t)?!1:!$(t.jsonrpc)&&!$(t.id)&&!$(t.method)&&!$(t.params)}function je(t){return te(t)?!1:!$(t.jsonrpc)&&!$(t.id)&&(!$(t.result)||!$(t.error))}function tr(t){return te(t)?!1:typeof t==\"string\"&&Object.values(u).includes(t)}function Fe(t){return te(t)?!1:typeof t==\"number\"&&Object.values(p).includes(t)}function ne(t){if(!t)return!0;for(let e in t)if(Object.hasOwnProperty.call(t,e))return!1;return!0}var es_m={};function Tn(t,e){return Object.assign(es_m,e),t}var We={\"magic-sdk\":\"magic-sdk\",\"@magic-sdk/react-native\":\"magic-sdk-rn\"};var b=class extends Error{constructor(e,n){super(`Magic SDK Error: [${e}] ${n}`);this.code=e;this.rawMessage=n;this.__proto__=Error;Object.setPrototypeOf(this,b.prototype)}},w=class extends Error{constructor(e){super();this.__proto__=Error;let n=Number(e==null?void 0:e.code);this.rawMessage=(e==null?void 0:e.message)||\"Internal error\",this.code=Fe(n)?n:p.InternalError,this.message=`Magic RPC Error: [${this.code}] ${this.rawMessage}`,Object.setPrototypeOf(this,w.prototype)}},W=class{constructor(e,n){this.code=e;this.rawMessage=n;this.message=`Magic SDK Warning: [${e}] ${n}`}log(){console.warn(this.message)}},X=class extends Error{constructor(e,n,r,s){super(`Magic Extension Error (${e.name}): [${n}] ${r}`);this.code=n;this.rawMessage=r;this.data=s;this.__proto__=Error;Object.setPrototypeOf(this,X.prototype)}},se=class{constructor(e,n,r){this.code=n;this.rawMessage=r;this.message=`Magic Extension Warning (${e.name}): [${n}] ${r}`}log(){console.warn(this.message)}};function Xe(){return new b(a.MissingApiKey,\"Please provide an API key that you acquired from the Magic developer dashboard.\")}function cr(){return new b(a.ModalNotReady,\"Modal is not ready.\")}function Be(){return new b(a.MalformedResponse,\"Response from the Magic iframe is malformed.\")}function He(t){return new b(a.ExtensionNotInitialized,`Extensions must be initialized with a Magic SDK instance before \\`Extension.${t}\\` can be accessed. Do not invoke \\`Extension.${t}\\` inside an extension constructor.`)}function Ve(t){let e=`Some extensions are incompatible with \\`${es_m.sdkName}@${es_m.version}\\`:`;return t.filter(n=>typeof n.compat!=\"undefined\"&&n.compat!==null).forEach(n=>{let r=n.compat[es_m.sdkName];typeof r==\"string\"?e+=`\n  - Extension \\`${n.name}\\` supports version(s) \\`${r}\\``:r||(e+=`\n  - Extension \\`${n.name}\\` does not support ${es_m.platform} environments.`)}),new b(a.IncompatibleExtensions,e)}function ze(t){let e=n=>{let r=n+1,s=r%10,o=r%100;return s===1&&o!==11?`${r}st`:s===2&&o!==12?`${r}nd`:s===3&&o!==13?`${r}rd`:`${r}th`};return new b(a.InvalidArgument,`Invalid ${e(t.argument)} argument given to \\`${t.procedure}\\`.\n  Expected: \\`${t.expected}\\`\n  Received: \\`${t.received}\\``)}function lr(){return new W(m.DuplicateIframe,\"Duplicate iframes found.\")}function Ye(){return new W(m.SyncWeb3Method,\"Non-async web3 methods are deprecated in web3 > 1.0 and are not supported by the Magic web3 provider. Please use an async method instead.\")}function Ze(){return new W(m.ReactNativeEndpointConfiguration,`CUSTOM DOMAINS ARE NOT SUPPORTED WHEN USING MAGIC SDK WITH REACT NATIVE! The \\`endpoint\\` parameter SHOULD NOT be provided. The Magic \\`<iframe>\\` is automatically wrapped by a WebView pointed at \\`${es_m.defaultEndpoint}\\`. Changing this default behavior will lead to unexpected results and potentially security-threatening bugs.`)}function pr(t){let{method:e,removalVersions:n,useInstead:r}=t,s=n[es_m.sdkName],o=r?` Use \\`${r}\\` instead.`:\"\",a=`\\`${e}\\` will be removed from \\`${es_m.sdkName}\\` in version \\`${s}\\`.${o}`;return new W(m.DeprecationNotice,a)}function*xn(){let t=0;for(;;)t<Number.MAX_SAFE_INTEGER?yield++t:t=0}var In=xn();function he(){return In.next().value}var Qe=Symbol(\"Payload pre-processed by Magic SDK\");function et(t){return Object.defineProperty(t,Qe,{value:!0,enumerable:!1}),t}function Pn(t){return!!t[Qe]}function C(t){var e,n,r;return Pn(t)||(t.jsonrpc=(e=t.jsonrpc)!=null?e:\"2.0\",t.id=he(),t.method=(n=t.method)!=null?n:\"noop\",t.params=(r=t.params)!=null?r:[],et(t)),t}function h(t,e=[]){return et({params:e,method:t,jsonrpc:\"2.0\",id:he()})}var _=class{constructor(e){e instanceof _?(this._jsonrpc=e.payload.jsonrpc,this._id=e.payload.id,this._result=e.payload.result,this._error=e.payload.error):je(e)?(this._jsonrpc=e.jsonrpc,this._id=e.id,this._result=e.result,this._error=e.error):(this._jsonrpc=e.jsonrpc,this._id=e.id,this._result=void 0,this._error=void 0)}applyError(e){return this._error=e,this}applyResult(e){return this._result=e,this}get hasError(){return typeof this._error!=\"undefined\"&&this._error!==null}get hasResult(){return typeof this._result!=\"undefined\"}get payload(){return{jsonrpc:this._jsonrpc,id:this._id,result:this._result,error:this._error}}};var rt=wt(nt()),st=class extends rt.default{};function ie(){let t=new st;return{emitter:t,createChainingEmitterMethod:(r,s)=>(...o)=>(t[r].apply(t,o),s),createBoundEmitterMethod:r=>(...s)=>t[r].apply(t,s)}}var ot=Symbol(\"isPromiEvent\");function it(t){return!!t[ot]}function ae(t){let e=ge(t),{createBoundEmitterMethod:n,createChainingEmitterMethod:r}=ie(),s=Symbol(\"Promise.then\"),o=Symbol(\"Promise.catch\"),a=Symbol(\"Promise.finally\"),i=(l,u)=>(...v)=>{let M=u[l].apply(u,v);return c(M)},c=l=>Object.assign(l,{[ot]:!0,[s]:l[s]||l.then,[o]:l[o]||l.catch,[a]:l[a]||l.finally,then:i(s,l),catch:i(o,l),finally:i(a,l),on:r(\"on\",l),once:r(\"once\",l),addListener:r(\"addListener\",l),off:r(\"off\",l),removeListener:r(\"removeListener\",l),removeAllListeners:r(\"removeAllListeners\",l),emit:n(\"emit\"),eventNames:n(\"eventNames\"),listeners:n(\"listeners\"),listenerCount:n(\"listenerCount\")}),p=c(e.then(l=>(p.emit(\"done\",l),p.emit(\"settled\"),l),l=>{throw p.emit(\"error\",l),p.emit(\"settled\"),l}));return p}function ge(t){return new Promise((e,n)=>{let r=t(e,n);Promise.resolve(r).catch(n)})}var P=class{constructor(e){this.sdk=e}get overlay(){return this.sdk.overlay}request(e){let n=this.overlay.post(o.MAGIC_HANDLE_REQUEST,C(e)),r=ae((o,a)=>{n.then(i=>{if(s(),i.hasError)a(new w(i.payload.error));else if(i.hasResult)o(i.payload.result);else throw Be()}).catch(i=>{s(),a(i)})}),s=this.overlay.on(g.MAGIC_HANDLE_EVENT,o=>{var i;let{response:a}=o.data;if(a.id===e.id&&((i=a.result)==null?void 0:i.event)){let{event:c,params:p=[]}=a.result;r.emit(c,...p)}});return r}};var ye=class extends P{loginWithMagicLink(e){let{email:n,showUI:r=!0,redirectURI:s}=e,o=h(this.sdk.testMode?u.LoginWithMagicLinkTestMode:u.LoginWithMagicLink,[{email:n,showUI:r,redirectURI:s}]);return this.request(o)}loginWithSMS(e){let{phoneNumber:n}=e,r=h(this.sdk.testMode?u.LoginWithSmsTestMode:u.LoginWithSms,[{phoneNumber:n,showUI:!0}]);return this.request(r)}loginWithEmailOTP(e){let{email:n}=e,r=h(this.sdk.testMode?u.LoginWithEmailOTPTestMode:u.LoginWithEmailOTP,[{email:n,showUI:!0}]);return this.request(r)}loginWithCredential(e){let n=e!=null?e:\"\";if(!e&&es_m.platform===\"web\"){n=window.location.search;let s=window.location.origin+window.location.pathname;window.history.replaceState(null,\"\",s)}let r=h(this.sdk.testMode?u.LoginWithCredentialTestMode:u.LoginWithCredential,[n]);return this.request(r)}};var H={};Mt(H,{clear:()=>wn,getItem:()=>D,iterate:()=>On,key:()=>Ln,keys:()=>Sn,length:()=>An,removeItem:()=>le,setItem:()=>q});var ce;function L(t){return(...e)=>I(this,null,function*(){return ce||(ce=yield es_m.configureStorage()),yield ce.ready(),ce[t](...e)})}var D=L(\"getItem\"),q=L(\"setItem\"),le=L(\"removeItem\"),wn=L(\"clear\"),An=L(\"length\"),Ln=L(\"key\"),Sn=L(\"keys\"),On=L(\"iterate\");function at(){let t=window.crypto.getRandomValues(new Uint8Array(16));t[6]=t[6]&15|64,t[8]=t[8]&191|128;let e=\"\";return e+=t[0].toString(16),e+=t[1].toString(16),e+=t[2].toString(16),e+=t[3].toString(16),e+=\"-\",e+=t[4].toString(16),e+=t[5].toString(16),e+=\"-\",e+=t[6].toString(16),e+=t[7].toString(16),e+=\"-\",e+=t[8].toString(16),e+=t[9].toString(16),e+=\"-\",e+=t[10].toString(16),e+=t[11].toString(16),e+=t[12].toString(16),e+=t[13].toString(16),e+=t[14].toString(16),e+=t[15].toString(16),e}var Re=\"STORE_KEY_PRIVATE_KEY\",pe=\"STORE_KEY_PUBLIC_JWK\",Te=\"ECDSA\",ct=\"P-256\",Cn={name:Te,namedCurve:ct},_n={name:Te,namedCurve:ct};function lt(){le(pe),le(Re)}function pt(){return I(this,null,function*(){let t=yield Dn();if(!t){console.info(\"unable to create public key or webcrypto is unsupported\");return}let{subtle:e}=window.crypto,n=yield D(Re);if(!n||!e){console.info(\"unable to find private key or webcrypto unsupported\");return}let r={iat:Math.floor(new Date().getTime()/1e3),jti:at()},s={typ:\"dpop+jwt\",alg:\"ES256\",jwk:t},o={protected:ut(JSON.stringify(s)),claims:ut(JSON.stringify(r))},a=qn(`${o.protected}.${o.claims}`),i={name:Te,hash:{name:\"SHA-256\"}},c=Un(new Uint8Array(yield e.sign(i,n,a)));return`${o.protected}.${o.claims}.${c}`})}function Dn(){return I(this,null,function*(){if(!Jn()){console.info(\"webcrypto is not supported\");return}return(yield D(pe))||(yield kn()),D(pe)})}function kn(){return I(this,null,function*(){let t=null,{subtle:e}=window.crypto,n=yield e.generateKey(Cn,!0,[\"sign\"]),r=yield e.exportKey(\"jwk\",n.privateKey);t=yield e.exportKey(\"jwk\",n.publicKey);let s=yield e.importKey(\"jwk\",r,_n,!1,[\"sign\"]);yield q(Re,s),yield q(pe,t)})}function Jn(){let t=typeof window!=\"undefined\"&&!!window.crypto,e=t&&!!window.crypto.subtle;return t&&e}function ut(t){return dt(Gn(t))}function qn(t){return new TextEncoder().encode(t)}function dt(t){return btoa(t).replace(/\\+/g,\"-\").replace(/\\//g,\"_\").replace(/=+/g,\"\")}function Gn(t){return encodeURIComponent(t).replace(/%([0-9A-F]{2})/g,(n,r)=>String.fromCharCode(parseInt(r,16)))}function Un(t){let e=\"\";return t.forEach(n=>{e+=String.fromCharCode(n)}),dt(e)}var ve=class extends P{getIdToken(e){let n=h(this.sdk.testMode?u.GetIdTokenTestMode:u.GetIdToken,[e]);return this.request(n)}generateIdToken(e){let n=h(this.sdk.testMode?u.GenerateIdTokenTestMode:u.GenerateIdToken,[e]);return this.request(n)}getMetadata(){let e=h(this.sdk.testMode?u.GetMetadataTestMode:u.GetMetadata);return this.request(e)}updateEmail(e){let{email:n,showUI:r=!0}=e,s=h(this.sdk.testMode?u.UpdateEmailTestMode:u.UpdateEmail,[{email:n,showUI:r}]);return this.request(s)}isLoggedIn(){let e=h(this.sdk.testMode?u.IsLoggedInTestMode:u.IsLoggedIn);return this.request(e)}logout(){lt();let e=h(this.sdk.testMode?u.LogoutTestMode:u.Logout);return this.request(e)}showSettings(){let e=h(this.sdk.testMode?u.UserSettingsTestMode:u.UserSettings);return this.request(e)}};var{createBoundEmitterMethod:ue,createChainingEmitterMethod:G}=ie(),xe=class extends P{constructor(){super(...arguments);this.isMagic=!0;this.on=G(\"on\",this);this.once=G(\"once\",this);this.addListener=G(\"addListener\",this);this.off=G(\"off\",this);this.removeListener=G(\"removeListener\",this);this.removeAllListeners=G(\"removeAllListeners\",this);this.emit=ue(\"emit\");this.eventNames=ue(\"eventNames\");this.listeners=ue(\"listeners\");this.listenerCount=ue(\"listenerCount\")}sendAsync(e,n){if(!n)throw ze({procedure:\"Magic.rpcProvider.sendAsync\",argument:1,expected:\"function\",received:n===null?\"null\":typeof n});if(Array.isArray(e))this.overlay.post(o.MAGIC_HANDLE_REQUEST,e.map(r=>{let s=C(r);return this.prefixPayloadMethodForTestMode(s),s})).then(r=>{n(null,r.map(s=>we(z({},s.payload),{error:s.hasError?new w(s.payload.error):null})))});else{let r=C(e);this.prefixPayloadMethodForTestMode(r),this.overlay.post(o.MAGIC_HANDLE_REQUEST,r).then(s=>{n(s.hasError?new w(s.payload.error):null,s.payload)})}}send(e,n){if(typeof e==\"string\"){let s=h(e,Array.isArray(n)?n:[]);return this.request(s)}if(Array.isArray(e)||!!n){this.sendAsync(e,n);return}let r=Ye();return r.log(),new _(e).applyError({code:-32603,message:r.rawMessage}).payload}enable(){let e=h(\"eth_accounts\");return this.request(e)}request(e){return this.prefixPayloadMethodForTestMode(e),super.request(e)}prefixPayloadMethodForTestMode(e){let n=\"testMode/eth/\";this.sdk.testMode&&(e.method=`${n}${e.method}`)}};function Ie(t,e){return e?new URL(t,e):new URL(t)}var Et=[\"request\",\"overlay\",\"sdk\"];function Kn(t){let e=Object.getPrototypeOf(t),n=[e];for(;e!==P.prototype;)e=Object.getPrototypeOf(e),n.push(e);return n}var Pe=class extends P{constructor(){super(void 0);this.__sdk_access_field_descriptors__=new Map;this.__is_initialized__=!1;this.utils={createPromiEvent:ae,isPromiEvent:it,encodeJSON:ee,decodeJSON:Ke,createJsonRpcRequestPayload:h,standardizeJsonRpcRequestPayload:C,storage:H};let e=[this,...Kn(this)];Et.forEach(n=>{let r=e.map(i=>Object.getOwnPropertyDescriptor(i,n)),s=r.findIndex(i=>!!i),o=s>0,a=r[s];a&&(this.__sdk_access_field_descriptors__.set(n,{descriptor:a,isPrototypeField:o}),Object.defineProperty(this,n,{configurable:!0,get:()=>{throw He(n)}}))})}init(e){this.__is_initialized__||(Et.forEach(n=>{if(this.__sdk_access_field_descriptors__.has(n)){let{descriptor:r,isPrototypeField:s}=this.__sdk_access_field_descriptors__.get(n);s?delete this[n]:Object.defineProperty(this,n,r)}}),this.sdk=e,this.__is_initialized__=!0)}createDeprecationWarning(e){let{method:n,removalVersion:r,useInstead:s}=e,o=s?` Use \\`${s}\\` instead.`:\"\",a=`\\`${n}\\` will be removed from this Extension in version \\`${r}\\`.${o}`;return new se(this,\"DEPRECATION_NOTICE\",a)}createWarning(e,n){return new se(this,e,n)}createError(e,n,r){return new X(this,e,n,r)}},ht=class extends Pe{},S=class extends Pe{};S.Internal=ht,S.Anonymous=\"anonymous extension\";function ft(t){return t.compat&&t.compat[es_m.sdkName]!=null?typeof t.compat[es_m.sdkName]==\"string\"?Je(Ue(es_m.version),t.compat[es_m.sdkName]):!!t.compat[es_m.sdkName]:!0}function jn(t){var s;let e=(s=t==null?void 0:t.extensions)!=null?s:[],n={},r=[];if(Array.isArray(e)?e.forEach(o=>{ft(o)?(o.init(this),(o.name||o.name!==S.Anonymous)&&(this[o.name]=o),o instanceof S.Internal&&(ne(o.config)||(n[o.name]=o.config))):r.push(o)}):Object.keys(e).forEach(o=>{if(ft(e[o])){e[o].init(this);let a=e[o];this[o]=a,a instanceof S.Internal&&(ne(a.config)||(n[e[o].name]=a.config))}else r.push(e[o])}),r.length)throw Ve(r);return n}var V=class{constructor(e,n){this.apiKey=e;var a;if(!e)throw Xe();es_m.platform===\"react-native\"&&(n==null?void 0:n.endpoint)&&Ze().log();let{defaultEndpoint:r,version:s}=es_m;this.testMode=!!(n==null?void 0:n.testMode),this.endpoint=Ie((a=n==null?void 0:n.endpoint)!=null?a:r).origin,this.auth=new ye(this),this.user=new ve(this),this.rpcProvider=new xe(this);let o=jn.call(this,n);this.parameters=ee(z({API_KEY:this.apiKey,DOMAIN_ORIGIN:window.location?window.location.origin:\"\",ETH_NETWORK:n==null?void 0:n.network,host:Ie(this.endpoint).host,sdk:We[es_m.sdkName],version:s,ext:ne(o)?void 0:o,locale:(n==null?void 0:n.locale)||\"en_US\"},es_m.bundleId?{bundleId:es_m.bundleId}:{}))}get overlay(){if(!V.__overlays__.has(this.parameters)){let e=new es_m.ViewController(this.endpoint,this.parameters);e.init(),V.__overlays__.set(this.parameters,e)}return V.__overlays__.get(this.parameters)}preload(){return I(this,null,function*(){yield this.overlay.ready})}},$e=V;$e.__overlays__=new Map;function Fn(t,e){return e&&Array.isArray(t)?t.find(n=>n.id===e):t}function Wn(t,e){var s;let n=(s=e.data.response)==null?void 0:s.id,r=Fn(t,n);if(n&&r){let o=new _(r).applyResult(e.data.response.result).applyError(e.data.response.error);return{id:n,response:o}}return{}}function Xn(t,e){return I(this,null,function*(){let n=yield D(\"rt\"),r;if(es_m.platform===\"web\")try{r=yield pt()}catch(s){console.error(\"webcrypto error\",s)}return r?n?{msgType:t,payload:e,jwt:r,rt:n}:{msgType:t,payload:e,jwt:r}:{msgType:t,payload:e}})}function Bn(t){return I(this,null,function*(){!t.data.rt||(yield q(\"rt\",t.data.rt))})}var gt=class{constructor(e,n){this.endpoint=e;this.parameters=n;this.messageHandlers=new Set;this.ready=this.waitForReady(),this.listen()}post(e,n){return I(this,null,function*(){return ge(r=>I(this,null,function*(){yield this.ready;let s=[],o=Array.isArray(n)?n.map(p=>p.id):[],a=yield Xn(`${e}-${this.parameters}`,n);yield this._post(a);let i=p=>l=>{let{id:u,response:v}=Wn(n,l);Bn(l),u&&v&&Array.isArray(n)&&o.includes(u)?(s.push(v),s.length===n.length&&(p(),r(s))):u&&v&&!Array.isArray(n)&&u===n.id&&(p(),r(v))},c=this.on(g.MAGIC_HANDLE_RESPONSE,i(()=>c()))}))})}on(e,n){let r=n.bind(window),s=o=>{o.data.msgType===`${e}-${this.parameters}`&&r(o)};return this.messageHandlers.add(s),()=>this.messageHandlers.delete(s)}waitForReady(){return new Promise(e=>{this.on(g.MAGIC_OVERLAY_READY,()=>e())})}listen(){this.on(g.MAGIC_HIDE_OVERLAY,()=>{this.hideOverlay()}),this.on(g.MAGIC_SHOW_OVERLAY,()=>{this.showOverlay()})}};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@magic-sdk/commons/dist/es/index.mjs\n\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/magic-sdk/dist/es/index.mjs\nvar Zr=Object.create;var es_De=Object.defineProperty;var qr=Object.getOwnPropertyDescriptor;var kr=Object.getOwnPropertyNames;var es_et=Object.getPrototypeOf,es_rt=Object.prototype.hasOwnProperty;var tt=p=>es_De(p,\"__esModule\",{value:!0});var es_ve=(p=>typeof require!=\"undefined\"?require:typeof Proxy!=\"undefined\"?new Proxy(p,{get:(g,O)=>(typeof require!=\"undefined\"?require:g)[O]}):p)(function(p){if(typeof require!=\"undefined\")return require.apply(this,arguments);throw new Error('Dynamic require of \"'+p+'\" is not supported')});var es_$e=(p,g)=>()=>(g||p((g={exports:{}}).exports,g),g.exports);var es_nt=(p,g,O,L)=>{if(g&&typeof g==\"object\"||typeof g==\"function\")for(let M of kr(g))!es_rt.call(p,M)&&(O||M!==\"default\")&&es_De(p,M,{get:()=>g[M],enumerable:!(L=qr(g,M))||L.enumerable});return p},es_Ze=(p,g)=>es_nt(tt(es_De(p!=null?Zr(es_et(p)):{},\"default\",!g&&p&&p.__esModule?{get:()=>p.default,enumerable:!0}:{value:p,enumerable:!0})),p);var es_se=(p,g,O)=>new Promise((L,M)=>{var Q=S=>{try{Y(O.next(S))}catch(P){M(P)}},C=S=>{try{Y(O.throw(S))}catch(P){M(P)}},Y=S=>S.done?L(S.value):Promise.resolve(S.value).then(Q,C);Y((O=O.apply(p,g)).next())});var es_ke=es_$e((qe,Ne)=>{(function(p){if(typeof qe==\"object\"&&typeof Ne!=\"undefined\")Ne.exports=p();else if(typeof define==\"function\"&&define.amd)define([],p);else{var g;typeof window!=\"undefined\"?g=window:typeof global!=\"undefined\"?g=global:typeof self!=\"undefined\"?g=self:g=this,g.localforage=p()}})(function(){var p,g,O;return function L(M,Q,C){function Y(K,Z){if(!Q[K]){if(!M[K]){var m=typeof es_ve==\"function\"&&es_ve;if(!Z&&m)return m(K,!0);if(S)return S(K,!0);var w=new Error(\"Cannot find module '\"+K+\"'\");throw w.code=\"MODULE_NOT_FOUND\",w}var N=Q[K]={exports:{}};M[K][0].call(N.exports,function(z){var q=M[K][1][z];return Y(q||z)},N,N.exports,L,M,Q,C)}return Q[K].exports}for(var S=typeof es_ve==\"function\"&&es_ve,P=0;P<C.length;P++)Y(C[P]);return Y}({1:[function(L,M,Q){(function(C){\"use strict\";var Y=C.MutationObserver||C.WebKitMutationObserver,S;if(Y){var P=0,K=new Y(z),Z=C.document.createTextNode(\"\");K.observe(Z,{characterData:!0}),S=function(){Z.data=P=++P%2}}else if(!C.setImmediate&&typeof C.MessageChannel!=\"undefined\"){var m=new C.MessageChannel;m.port1.onmessage=z,S=function(){m.port2.postMessage(0)}}else\"document\"in C&&\"onreadystatechange\"in C.document.createElement(\"script\")?S=function(){var F=C.document.createElement(\"script\");F.onreadystatechange=function(){z(),F.onreadystatechange=null,F.parentNode.removeChild(F),F=null},C.document.documentElement.appendChild(F)}:S=function(){setTimeout(z,0)};var w,N=[];function z(){w=!0;for(var F,k,U=N.length;U;){for(k=N,N=[],F=-1;++F<U;)k[F]();U=N.length}w=!1}M.exports=q;function q(F){N.push(F)===1&&!w&&S()}}).call(this,typeof global!=\"undefined\"?global:typeof self!=\"undefined\"?self:typeof window!=\"undefined\"?window:{})},{}],2:[function(L,M,Q){\"use strict\";var C=L(1);function Y(){}var S={},P=[\"REJECTED\"],K=[\"FULFILLED\"],Z=[\"PENDING\"];M.exports=m;function m(h){if(typeof h!=\"function\")throw new TypeError(\"resolver must be a function\");this.state=Z,this.queue=[],this.outcome=void 0,h!==Y&&q(this,h)}m.prototype.catch=function(h){return this.then(null,h)},m.prototype.then=function(h,R){if(typeof h!=\"function\"&&this.state===K||typeof R!=\"function\"&&this.state===P)return this;var I=new this.constructor(Y);if(this.state!==Z){var B=this.state===K?h:R;N(I,B,this.outcome)}else this.queue.push(new w(I,h,R));return I};function w(h,R,I){this.promise=h,typeof R==\"function\"&&(this.onFulfilled=R,this.callFulfilled=this.otherCallFulfilled),typeof I==\"function\"&&(this.onRejected=I,this.callRejected=this.otherCallRejected)}w.prototype.callFulfilled=function(h){S.resolve(this.promise,h)},w.prototype.otherCallFulfilled=function(h){N(this.promise,this.onFulfilled,h)},w.prototype.callRejected=function(h){S.reject(this.promise,h)},w.prototype.otherCallRejected=function(h){N(this.promise,this.onRejected,h)};function N(h,R,I){C(function(){var B;try{B=R(I)}catch(H){return S.reject(h,H)}B===h?S.reject(h,new TypeError(\"Cannot resolve promise with itself\")):S.resolve(h,B)})}S.resolve=function(h,R){var I=F(z,R);if(I.status===\"error\")return S.reject(h,I.value);var B=I.value;if(B)q(h,B);else{h.state=K,h.outcome=R;for(var H=-1,j=h.queue.length;++H<j;)h.queue[H].callFulfilled(R)}return h},S.reject=function(h,R){h.state=P,h.outcome=R;for(var I=-1,B=h.queue.length;++I<B;)h.queue[I].callRejected(R);return h};function z(h){var R=h&&h.then;if(h&&(typeof h==\"object\"||typeof h==\"function\")&&typeof R==\"function\")return function(){R.apply(h,arguments)}}function q(h,R){var I=!1;function B($){I||(I=!0,S.reject(h,$))}function H($){I||(I=!0,S.resolve(h,$))}function j(){R(H,B)}var J=F(j);J.status===\"error\"&&B(J.value)}function F(h,R){var I={};try{I.value=h(R),I.status=\"success\"}catch(B){I.status=\"error\",I.value=B}return I}m.resolve=k;function k(h){return h instanceof this?h:S.resolve(new this(Y),h)}m.reject=U;function U(h){var R=new this(Y);return S.reject(R,h)}m.all=ae;function ae(h){var R=this;if(Object.prototype.toString.call(h)!==\"[object Array]\")return this.reject(new TypeError(\"must be an array\"));var I=h.length,B=!1;if(!I)return this.resolve([]);for(var H=new Array(I),j=0,J=-1,$=new this(Y);++J<I;)ee(h[J],J);return $;function ee(oe,a){R.resolve(oe).then(s,function(v){B||(B=!0,S.reject($,v))});function s(v){H[a]=v,++j===I&&!B&&(B=!0,S.resolve($,H))}}}m.race=re;function re(h){var R=this;if(Object.prototype.toString.call(h)!==\"[object Array]\")return this.reject(new TypeError(\"must be an array\"));var I=h.length,B=!1;if(!I)return this.resolve([]);for(var H=-1,j=new this(Y);++H<I;)J(h[H]);return j;function J($){R.resolve($).then(function(ee){B||(B=!0,S.resolve(j,ee))},function(ee){B||(B=!0,S.reject(j,ee))})}}},{\"1\":1}],3:[function(L,M,Q){(function(C){\"use strict\";typeof C.Promise!=\"function\"&&(C.Promise=L(2))}).call(this,typeof global!=\"undefined\"?global:typeof self!=\"undefined\"?self:typeof window!=\"undefined\"?window:{})},{\"2\":2}],4:[function(L,M,Q){\"use strict\";var C=typeof Symbol==\"function\"&&typeof Symbol.iterator==\"symbol\"?function(e){return typeof e}:function(e){return e&&typeof Symbol==\"function\"&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e};function Y(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function S(){try{if(typeof indexedDB!=\"undefined\")return indexedDB;if(typeof webkitIndexedDB!=\"undefined\")return webkitIndexedDB;if(typeof mozIndexedDB!=\"undefined\")return mozIndexedDB;if(typeof OIndexedDB!=\"undefined\")return OIndexedDB;if(typeof msIndexedDB!=\"undefined\")return msIndexedDB}catch{return}}var P=S();function K(){try{if(!P||!P.open)return!1;var e=typeof openDatabase!=\"undefined\"&&/(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)&&!/BlackBerry/.test(navigator.platform),t=typeof fetch==\"function\"&&fetch.toString().indexOf(\"[native code\")!==-1;return(!e||t)&&typeof indexedDB!=\"undefined\"&&typeof IDBKeyRange!=\"undefined\"}catch{return!1}}function Z(e,t){e=e||[],t=t||{};try{return new Blob(e,t)}catch(n){if(n.name!==\"TypeError\")throw n;for(var r=typeof BlobBuilder!=\"undefined\"?BlobBuilder:typeof MSBlobBuilder!=\"undefined\"?MSBlobBuilder:typeof MozBlobBuilder!=\"undefined\"?MozBlobBuilder:WebKitBlobBuilder,o=new r,i=0;i<e.length;i+=1)o.append(e[i]);return o.getBlob(t.type)}}typeof Promise==\"undefined\"&&L(3);var m=Promise;function w(e,t){t&&e.then(function(r){t(null,r)},function(r){t(r)})}function N(e,t,r){typeof t==\"function\"&&e.then(t),typeof r==\"function\"&&e.catch(r)}function z(e){return typeof e!=\"string\"&&(console.warn(e+\" used as a key, but it is not a string.\"),e=String(e)),e}function q(){if(arguments.length&&typeof arguments[arguments.length-1]==\"function\")return arguments[arguments.length-1]}var F=\"local-forage-detect-blob-support\",k=void 0,U={},ae=Object.prototype.toString,re=\"readonly\",h=\"readwrite\";function R(e){for(var t=e.length,r=new ArrayBuffer(t),o=new Uint8Array(r),i=0;i<t;i++)o[i]=e.charCodeAt(i);return r}function I(e){return new m(function(t){var r=e.transaction(F,h),o=Z([\"\"]);r.objectStore(F).put(o,\"key\"),r.onabort=function(i){i.preventDefault(),i.stopPropagation(),t(!1)},r.oncomplete=function(){var i=navigator.userAgent.match(/Chrome\\/(\\d+)/),n=navigator.userAgent.match(/Edge\\//);t(n||!i||parseInt(i[1],10)>=43)}}).catch(function(){return!1})}function B(e){return typeof k==\"boolean\"?m.resolve(k):I(e).then(function(t){return k=t,k})}function H(e){var t=U[e.name],r={};r.promise=new m(function(o,i){r.resolve=o,r.reject=i}),t.deferredOperations.push(r),t.dbReady?t.dbReady=t.dbReady.then(function(){return r.promise}):t.dbReady=r.promise}function j(e){var t=U[e.name],r=t.deferredOperations.pop();if(r)return r.resolve(),r.promise}function J(e,t){var r=U[e.name],o=r.deferredOperations.pop();if(o)return o.reject(t),o.promise}function $(e,t){return new m(function(r,o){if(U[e.name]=U[e.name]||G(),e.db)if(t)H(e),e.db.close();else return r(e.db);var i=[e.name];t&&i.push(e.version);var n=P.open.apply(P,i);t&&(n.onupgradeneeded=function(f){var u=n.result;try{u.createObjectStore(e.storeName),f.oldVersion<=1&&u.createObjectStore(F)}catch(c){if(c.name===\"ConstraintError\")console.warn('The database \"'+e.name+'\" has been upgraded from version '+f.oldVersion+\" to version \"+f.newVersion+', but the storage \"'+e.storeName+'\" already exists.');else throw c}}),n.onerror=function(f){f.preventDefault(),o(n.error)},n.onsuccess=function(){r(n.result),j(e)}})}function ee(e){return $(e,!1)}function oe(e){return $(e,!0)}function a(e,t){if(!e.db)return!0;var r=!e.db.objectStoreNames.contains(e.storeName),o=e.version<e.db.version,i=e.version>e.db.version;if(o&&(e.version!==t&&console.warn('The database \"'+e.name+`\" can't be downgraded from version `+e.db.version+\" to version \"+e.version+\".\"),e.version=e.db.version),i||r){if(r){var n=e.db.version+1;n>e.version&&(e.version=n)}return!0}return!1}function s(e){return new m(function(t,r){var o=new FileReader;o.onerror=r,o.onloadend=function(i){var n=btoa(i.target.result||\"\");t({__local_forage_encoded_blob:!0,data:n,type:e.type})},o.readAsBinaryString(e)})}function v(e){var t=R(atob(e.data));return Z([t],{type:e.type})}function b(e){return e&&e.__local_forage_encoded_blob}function _(e){var t=this,r=t._initReady().then(function(){var o=U[t._dbInfo.name];if(o&&o.dbReady)return o.dbReady});return N(r,e,e),r}function E(e){H(e);for(var t=U[e.name],r=t.forages,o=0;o<r.length;o++){var i=r[o];i._dbInfo.db&&(i._dbInfo.db.close(),i._dbInfo.db=null)}return e.db=null,ee(e).then(function(n){return e.db=n,a(e)?oe(e):n}).then(function(n){e.db=t.db=n;for(var f=0;f<r.length;f++)r[f]._dbInfo.db=n}).catch(function(n){throw J(e,n),n})}function D(e,t,r,o){o===void 0&&(o=1);try{var i=e.db.transaction(e.storeName,t);r(null,i)}catch(n){if(o>0&&(!e.db||n.name===\"InvalidStateError\"||n.name===\"NotFoundError\"))return m.resolve().then(function(){if(!e.db||n.name===\"NotFoundError\"&&!e.db.objectStoreNames.contains(e.storeName)&&e.version<=e.db.version)return e.db&&(e.version=e.db.version+1),oe(e)}).then(function(){return E(e).then(function(){D(e,t,r,o-1)})}).catch(r);r(n)}}function G(){return{forages:[],db:null,dbReady:null,deferredOperations:[]}}function fe(e){var t=this,r={db:null};if(e)for(var o in e)r[o]=e[o];var i=U[r.name];i||(i=G(),U[r.name]=i),i.forages.push(t),t._initReady||(t._initReady=t.ready,t.ready=_);var n=[];function f(){return m.resolve()}for(var u=0;u<i.forages.length;u++){var c=i.forages[u];c!==t&&n.push(c._initReady().catch(f))}var l=i.forages.slice(0);return m.all(n).then(function(){return r.db=i.db,ee(r)}).then(function(d){return r.db=d,a(r,t._defaultConfig.version)?oe(r):d}).then(function(d){r.db=i.db=d,t._dbInfo=r;for(var y=0;y<l.length;y++){var A=l[y];A!==t&&(A._dbInfo.db=r.db,A._dbInfo.version=r.version)}})}function ie(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){D(r._dbInfo,re,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=c.get(e);l.onsuccess=function(){var d=l.result;d===void 0&&(d=null),b(d)&&(d=v(d)),i(d)},l.onerror=function(){n(l.error)}}catch(d){n(d)}})}).catch(n)});return w(o,t),o}function ce(e,t){var r=this,o=new m(function(i,n){r.ready().then(function(){D(r._dbInfo,re,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=c.openCursor(),d=1;l.onsuccess=function(){var y=l.result;if(y){var A=y.value;b(A)&&(A=v(A));var T=e(A,y.key,d++);T!==void 0?i(T):y.continue()}else i()},l.onerror=function(){n(l.error)}}catch(y){n(y)}})}).catch(n)});return w(o,t),o}function nr(e,t,r){var o=this;e=z(e);var i=new m(function(n,f){var u;o.ready().then(function(){return u=o._dbInfo,ae.call(t)===\"[object Blob]\"?B(u.db).then(function(c){return c?t:s(t)}):t}).then(function(c){D(o._dbInfo,h,function(l,d){if(l)return f(l);try{var y=d.objectStore(o._dbInfo.storeName);c===null&&(c=void 0);var A=y.put(c,e);d.oncomplete=function(){c===void 0&&(c=null),n(c)},d.onabort=d.onerror=function(){var T=A.error?A.error:A.transaction.error;f(T)}}catch(T){f(T)}})}).catch(f)});return w(i,r),i}function or(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){D(r._dbInfo,h,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=c.delete(e);u.oncomplete=function(){i()},u.onerror=function(){n(l.error)},u.onabort=function(){var d=l.error?l.error:l.transaction.error;n(d)}}catch(d){n(d)}})}).catch(n)});return w(o,t),o}function ir(e){var t=this,r=new m(function(o,i){t.ready().then(function(){D(t._dbInfo,h,function(n,f){if(n)return i(n);try{var u=f.objectStore(t._dbInfo.storeName),c=u.clear();f.oncomplete=function(){o()},f.onabort=f.onerror=function(){var l=c.error?c.error:c.transaction.error;i(l)}}catch(l){i(l)}})}).catch(i)});return w(r,e),r}function ar(e){var t=this,r=new m(function(o,i){t.ready().then(function(){D(t._dbInfo,re,function(n,f){if(n)return i(n);try{var u=f.objectStore(t._dbInfo.storeName),c=u.count();c.onsuccess=function(){o(c.result)},c.onerror=function(){i(c.error)}}catch(l){i(l)}})}).catch(i)});return w(r,e),r}function fr(e,t){var r=this,o=new m(function(i,n){if(e<0){i(null);return}r.ready().then(function(){D(r._dbInfo,re,function(f,u){if(f)return n(f);try{var c=u.objectStore(r._dbInfo.storeName),l=!1,d=c.openKeyCursor();d.onsuccess=function(){var y=d.result;if(!y){i(null);return}e===0||l?i(y.key):(l=!0,y.advance(e))},d.onerror=function(){n(d.error)}}catch(y){n(y)}})}).catch(n)});return w(o,t),o}function ur(e){var t=this,r=new m(function(o,i){t.ready().then(function(){D(t._dbInfo,re,function(n,f){if(n)return i(n);try{var u=f.objectStore(t._dbInfo.storeName),c=u.openKeyCursor(),l=[];c.onsuccess=function(){var d=c.result;if(!d){o(l);return}l.push(d.key),d.continue()},c.onerror=function(){i(c.error)}}catch(d){i(d)}})}).catch(i)});return w(r,e),r}function sr(e,t){t=q.apply(this,arguments);var r=this.config();e=typeof e!=\"function\"&&e||{},e.name||(e.name=e.name||r.name,e.storeName=e.storeName||r.storeName);var o=this,i;if(!e.name)i=m.reject(\"Invalid arguments\");else{var n=e.name===r.name&&o._dbInfo.db,f=n?m.resolve(o._dbInfo.db):ee(e).then(function(u){var c=U[e.name],l=c.forages;c.db=u;for(var d=0;d<l.length;d++)l[d]._dbInfo.db=u;return u});e.storeName?i=f.then(function(u){if(!!u.objectStoreNames.contains(e.storeName)){var c=u.version+1;H(e);var l=U[e.name],d=l.forages;u.close();for(var y=0;y<d.length;y++){var A=d[y];A._dbInfo.db=null,A._dbInfo.version=c}var T=new m(function(x,V){var W=P.open(e.name,c);W.onerror=function(X){var de=W.result;de.close(),V(X)},W.onupgradeneeded=function(){var X=W.result;X.deleteObjectStore(e.storeName)},W.onsuccess=function(){var X=W.result;X.close(),x(X)}});return T.then(function(x){l.db=x;for(var V=0;V<d.length;V++){var W=d[V];W._dbInfo.db=x,j(W._dbInfo)}}).catch(function(x){throw(J(e,x)||m.resolve()).catch(function(){}),x})}}):i=f.then(function(u){H(e);var c=U[e.name],l=c.forages;u.close();for(var d=0;d<l.length;d++){var y=l[d];y._dbInfo.db=null}var A=new m(function(T,x){var V=P.deleteDatabase(e.name);V.onerror=V.onblocked=function(W){var X=V.result;X&&X.close(),x(W)},V.onsuccess=function(){var W=V.result;W&&W.close(),T(W)}});return A.then(function(T){c.db=T;for(var x=0;x<l.length;x++){var V=l[x];j(V._dbInfo)}}).catch(function(T){throw(J(e,T)||m.resolve()).catch(function(){}),T})})}return w(i,t),i}var cr={_driver:\"asyncStorage\",_initStorage:fe,_support:K(),iterate:ce,getItem:ie,setItem:nr,removeItem:or,clear:ir,length:ar,key:fr,keys:ur,dropInstance:sr};function lr(){return typeof openDatabase==\"function\"}var te=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",dr=\"~~local_forage_type~\",xe=/^~~local_forage_type~([^~]+)~/,he=\"__lfsc__:\",ge=he.length,be=\"arbf\",_e=\"blob\",Oe=\"si08\",Ce=\"ui08\",Le=\"uic8\",Pe=\"si16\",Me=\"si32\",Fe=\"ur16\",Ue=\"ui32\",Ye=\"fl32\",ze=\"fl64\",We=ge+be.length,Ke=Object.prototype.toString;function He(e){var t=e.length*.75,r=e.length,o,i=0,n,f,u,c;e[e.length-1]===\"=\"&&(t--,e[e.length-2]===\"=\"&&t--);var l=new ArrayBuffer(t),d=new Uint8Array(l);for(o=0;o<r;o+=4)n=te.indexOf(e[o]),f=te.indexOf(e[o+1]),u=te.indexOf(e[o+2]),c=te.indexOf(e[o+3]),d[i++]=n<<2|f>>4,d[i++]=(f&15)<<4|u>>2,d[i++]=(u&3)<<6|c&63;return l}function we(e){var t=new Uint8Array(e),r=\"\",o;for(o=0;o<t.length;o+=3)r+=te[t[o]>>2],r+=te[(t[o]&3)<<4|t[o+1]>>4],r+=te[(t[o+1]&15)<<2|t[o+2]>>6],r+=te[t[o+2]&63];return t.length%3===2?r=r.substring(0,r.length-1)+\"=\":t.length%3===1&&(r=r.substring(0,r.length-2)+\"==\"),r}function vr(e,t){var r=\"\";if(e&&(r=Ke.call(e)),e&&(r===\"[object ArrayBuffer]\"||e.buffer&&Ke.call(e.buffer)===\"[object ArrayBuffer]\")){var o,i=he;e instanceof ArrayBuffer?(o=e,i+=be):(o=e.buffer,r===\"[object Int8Array]\"?i+=Oe:r===\"[object Uint8Array]\"?i+=Ce:r===\"[object Uint8ClampedArray]\"?i+=Le:r===\"[object Int16Array]\"?i+=Pe:r===\"[object Uint16Array]\"?i+=Fe:r===\"[object Int32Array]\"?i+=Me:r===\"[object Uint32Array]\"?i+=Ue:r===\"[object Float32Array]\"?i+=Ye:r===\"[object Float64Array]\"?i+=ze:t(new Error(\"Failed to get type for BinaryArray\"))),t(i+we(o))}else if(r===\"[object Blob]\"){var n=new FileReader;n.onload=function(){var f=dr+e.type+\"~\"+we(this.result);t(he+_e+f)},n.readAsArrayBuffer(e)}else try{t(JSON.stringify(e))}catch(f){console.error(\"Couldn't convert value into a JSON string: \",e),t(null,f)}}function hr(e){if(e.substring(0,ge)!==he)return JSON.parse(e);var t=e.substring(We),r=e.substring(ge,We),o;if(r===_e&&xe.test(t)){var i=t.match(xe);o=i[1],t=t.substring(i[0].length)}var n=He(t);switch(r){case be:return n;case _e:return Z([n],{type:o});case Oe:return new Int8Array(n);case Ce:return new Uint8Array(n);case Le:return new Uint8ClampedArray(n);case Pe:return new Int16Array(n);case Fe:return new Uint16Array(n);case Me:return new Int32Array(n);case Ue:return new Uint32Array(n);case Ye:return new Float32Array(n);case ze:return new Float64Array(n);default:throw new Error(\"Unkown type: \"+r)}}var Ee={serialize:vr,deserialize:hr,stringToBuffer:He,bufferToString:we};function Ve(e,t,r,o){e.executeSql(\"CREATE TABLE IF NOT EXISTS \"+t.storeName+\" (id INTEGER PRIMARY KEY, key unique, value)\",[],r,o)}function mr(e){var t=this,r={db:null};if(e)for(var o in e)r[o]=typeof e[o]!=\"string\"?e[o].toString():e[o];var i=new m(function(n,f){try{r.db=openDatabase(r.name,String(r.version),r.description,r.size)}catch(u){return f(u)}r.db.transaction(function(u){Ve(u,r,function(){t._dbInfo=r,n()},function(c,l){f(l)})},f)});return r.serializer=Ee,i}function ne(e,t,r,o,i,n){e.executeSql(r,o,i,function(f,u){u.code===u.SYNTAX_ERR?f.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name = ?\",[t.storeName],function(c,l){l.rows.length?n(c,u):Ve(c,t,function(){c.executeSql(r,o,i,n)},n)},n):n(f,u)},n)}function yr(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"SELECT * FROM \"+f.storeName+\" WHERE key = ? LIMIT 1\",[e],function(c,l){var d=l.rows.length?l.rows.item(0).value:null;d&&(d=f.serializer.deserialize(d)),i(d)},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function pr(e,t){var r=this,o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"SELECT * FROM \"+f.storeName,[],function(c,l){for(var d=l.rows,y=d.length,A=0;A<y;A++){var T=d.item(A),x=T.value;if(x&&(x=f.serializer.deserialize(x)),x=e(x,T.key,A+1),x!==void 0){i(x);return}}i()},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function Ge(e,t,r,o){var i=this;e=z(e);var n=new m(function(f,u){i.ready().then(function(){t===void 0&&(t=null);var c=t,l=i._dbInfo;l.serializer.serialize(t,function(d,y){y?u(y):l.db.transaction(function(A){ne(A,l,\"INSERT OR REPLACE INTO \"+l.storeName+\" (key, value) VALUES (?, ?)\",[e,d],function(){f(c)},function(T,x){u(x)})},function(A){if(A.code===A.QUOTA_ERR){if(o>0){f(Ge.apply(i,[e,c,r,o-1]));return}u(A)}})})}).catch(u)});return w(n,r),n}function gr(e,t,r){return Ge.apply(this,[e,t,r,1])}function br(e,t){var r=this;e=z(e);var o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"DELETE FROM \"+f.storeName+\" WHERE key = ?\",[e],function(){i()},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function _r(e){var t=this,r=new m(function(o,i){t.ready().then(function(){var n=t._dbInfo;n.db.transaction(function(f){ne(f,n,\"DELETE FROM \"+n.storeName,[],function(){o()},function(u,c){i(c)})})}).catch(i)});return w(r,e),r}function wr(e){var t=this,r=new m(function(o,i){t.ready().then(function(){var n=t._dbInfo;n.db.transaction(function(f){ne(f,n,\"SELECT COUNT(key) as c FROM \"+n.storeName,[],function(u,c){var l=c.rows.item(0).c;o(l)},function(u,c){i(c)})})}).catch(i)});return w(r,e),r}function Er(e,t){var r=this,o=new m(function(i,n){r.ready().then(function(){var f=r._dbInfo;f.db.transaction(function(u){ne(u,f,\"SELECT key FROM \"+f.storeName+\" WHERE id = ? LIMIT 1\",[e+1],function(c,l){var d=l.rows.length?l.rows.item(0).key:null;i(d)},function(c,l){n(l)})})}).catch(n)});return w(o,t),o}function Ir(e){var t=this,r=new m(function(o,i){t.ready().then(function(){var n=t._dbInfo;n.db.transaction(function(f){ne(f,n,\"SELECT key FROM \"+n.storeName,[],function(u,c){for(var l=[],d=0;d<c.rows.length;d++)l.push(c.rows.item(d).key);o(l)},function(u,c){i(c)})})}).catch(i)});return w(r,e),r}function Sr(e){return new m(function(t,r){e.transaction(function(o){o.executeSql(\"SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\",[],function(i,n){for(var f=[],u=0;u<n.rows.length;u++)f.push(n.rows.item(u).name);t({db:e,storeNames:f})},function(i,n){r(n)})},function(o){r(o)})})}function Ar(e,t){t=q.apply(this,arguments);var r=this.config();e=typeof e!=\"function\"&&e||{},e.name||(e.name=e.name||r.name,e.storeName=e.storeName||r.storeName);var o=this,i;return e.name?i=new m(function(n){var f;e.name===r.name?f=o._dbInfo.db:f=openDatabase(e.name,\"\",\"\",0),e.storeName?n({db:f,storeNames:[e.storeName]}):n(Sr(f))}).then(function(n){return new m(function(f,u){n.db.transaction(function(c){function l(T){return new m(function(x,V){c.executeSql(\"DROP TABLE IF EXISTS \"+T,[],function(){x()},function(W,X){V(X)})})}for(var d=[],y=0,A=n.storeNames.length;y<A;y++)d.push(l(n.storeNames[y]));m.all(d).then(function(){f()}).catch(function(T){u(T)})},function(c){u(c)})})}):i=m.reject(\"Invalid arguments\"),w(i,t),i}var Rr={_driver:\"webSQLStorage\",_initStorage:mr,_support:lr(),iterate:pr,getItem:yr,setItem:gr,removeItem:br,clear:_r,length:wr,key:Er,keys:Ir,dropInstance:Ar};function Dr(){try{return typeof localStorage!=\"undefined\"&&\"setItem\"in localStorage&&!!localStorage.setItem}catch{return!1}}function je(e,t){var r=e.name+\"/\";return e.storeName!==t.storeName&&(r+=e.storeName+\"/\"),r}function Nr(){var e=\"_localforage_support_test\";try{return localStorage.setItem(e,!0),localStorage.removeItem(e),!1}catch{return!0}}function Tr(){return!Nr()||localStorage.length>0}function Br(e){var t=this,r={};if(e)for(var o in e)r[o]=e[o];return r.keyPrefix=je(e,t._defaultConfig),Tr()?(t._dbInfo=r,r.serializer=Ee,m.resolve()):m.reject()}function xr(e){var t=this,r=t.ready().then(function(){for(var o=t._dbInfo.keyPrefix,i=localStorage.length-1;i>=0;i--){var n=localStorage.key(i);n.indexOf(o)===0&&localStorage.removeItem(n)}});return w(r,e),r}function Or(e,t){var r=this;e=z(e);var o=r.ready().then(function(){var i=r._dbInfo,n=localStorage.getItem(i.keyPrefix+e);return n&&(n=i.serializer.deserialize(n)),n});return w(o,t),o}function Cr(e,t){var r=this,o=r.ready().then(function(){for(var i=r._dbInfo,n=i.keyPrefix,f=n.length,u=localStorage.length,c=1,l=0;l<u;l++){var d=localStorage.key(l);if(d.indexOf(n)===0){var y=localStorage.getItem(d);if(y&&(y=i.serializer.deserialize(y)),y=e(y,d.substring(f),c++),y!==void 0)return y}}});return w(o,t),o}function Lr(e,t){var r=this,o=r.ready().then(function(){var i=r._dbInfo,n;try{n=localStorage.key(e)}catch{n=null}return n&&(n=n.substring(i.keyPrefix.length)),n});return w(o,t),o}function Pr(e){var t=this,r=t.ready().then(function(){for(var o=t._dbInfo,i=localStorage.length,n=[],f=0;f<i;f++){var u=localStorage.key(f);u.indexOf(o.keyPrefix)===0&&n.push(u.substring(o.keyPrefix.length))}return n});return w(r,e),r}function Mr(e){var t=this,r=t.keys().then(function(o){return o.length});return w(r,e),r}function Fr(e,t){var r=this;e=z(e);var o=r.ready().then(function(){var i=r._dbInfo;localStorage.removeItem(i.keyPrefix+e)});return w(o,t),o}function Ur(e,t,r){var o=this;e=z(e);var i=o.ready().then(function(){t===void 0&&(t=null);var n=t;return new m(function(f,u){var c=o._dbInfo;c.serializer.serialize(t,function(l,d){if(d)u(d);else try{localStorage.setItem(c.keyPrefix+e,l),f(n)}catch(y){(y.name===\"QuotaExceededError\"||y.name===\"NS_ERROR_DOM_QUOTA_REACHED\")&&u(y),u(y)}})})});return w(i,r),i}function Yr(e,t){if(t=q.apply(this,arguments),e=typeof e!=\"function\"&&e||{},!e.name){var r=this.config();e.name=e.name||r.name,e.storeName=e.storeName||r.storeName}var o=this,i;return e.name?i=new m(function(n){e.storeName?n(je(e,o._defaultConfig)):n(e.name+\"/\")}).then(function(n){for(var f=localStorage.length-1;f>=0;f--){var u=localStorage.key(f);u.indexOf(n)===0&&localStorage.removeItem(u)}}):i=m.reject(\"Invalid arguments\"),w(i,t),i}var zr={_driver:\"localStorageWrapper\",_initStorage:Br,_support:Dr(),iterate:Cr,getItem:Or,setItem:Ur,removeItem:Fr,clear:xr,length:Mr,key:Lr,keys:Pr,dropInstance:Yr},Wr=function(t,r){return t===r||typeof t==\"number\"&&typeof r==\"number\"&&isNaN(t)&&isNaN(r)},Kr=function(t,r){for(var o=t.length,i=0;i<o;){if(Wr(t[i],r))return!0;i++}return!1},Xe=Array.isArray||function(e){return Object.prototype.toString.call(e)===\"[object Array]\"},le={},Qe={},ue={INDEXEDDB:cr,WEBSQL:Rr,LOCALSTORAGE:zr},Hr=[ue.INDEXEDDB._driver,ue.WEBSQL._driver,ue.LOCALSTORAGE._driver],me=[\"dropInstance\"],Ie=[\"clear\",\"getItem\",\"iterate\",\"key\",\"keys\",\"length\",\"removeItem\",\"setItem\"].concat(me),Vr={description:\"\",driver:Hr.slice(),name:\"localforage\",size:4980736,storeName:\"keyvaluepairs\",version:1};function Gr(e,t){e[t]=function(){var r=arguments;return e.ready().then(function(){return e[t].apply(e,r)})}}function Se(){for(var e=1;e<arguments.length;e++){var t=arguments[e];if(t)for(var r in t)t.hasOwnProperty(r)&&(Xe(t[r])?arguments[0][r]=t[r].slice():arguments[0][r]=t[r])}return arguments[0]}var jr=function(){function e(t){Y(this,e);for(var r in ue)if(ue.hasOwnProperty(r)){var o=ue[r],i=o._driver;this[r]=i,le[i]||this.defineDriver(o)}this._defaultConfig=Se({},Vr),this._config=Se({},this._defaultConfig,t),this._driverSet=null,this._initDriver=null,this._ready=!1,this._dbInfo=null,this._wrapLibraryMethodsWithReady(),this.setDriver(this._config.driver).catch(function(){})}return e.prototype.config=function(r){if((typeof r==\"undefined\"?\"undefined\":C(r))===\"object\"){if(this._ready)return new Error(\"Can't call config() after localforage has been used.\");for(var o in r){if(o===\"storeName\"&&(r[o]=r[o].replace(/\\W/g,\"_\")),o===\"version\"&&typeof r[o]!=\"number\")return new Error(\"Database version must be a number.\");this._config[o]=r[o]}return\"driver\"in r&&r.driver?this.setDriver(this._config.driver):!0}else return typeof r==\"string\"?this._config[r]:this._config},e.prototype.defineDriver=function(r,o,i){var n=new m(function(f,u){try{var c=r._driver,l=new Error(\"Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver\");if(!r._driver){u(l);return}for(var d=Ie.concat(\"_initStorage\"),y=0,A=d.length;y<A;y++){var T=d[y],x=!Kr(me,T);if((x||r[T])&&typeof r[T]!=\"function\"){u(l);return}}var V=function(){for(var de=function(Jr){return function(){var $r=new Error(\"Method \"+Jr+\" is not implemented by the current driver\"),Je=m.reject($r);return w(Je,arguments[arguments.length-1]),Je}},Ae=0,Qr=me.length;Ae<Qr;Ae++){var Re=me[Ae];r[Re]||(r[Re]=de(Re))}};V();var W=function(de){le[c]&&console.info(\"Redefining LocalForage driver: \"+c),le[c]=r,Qe[c]=de,f()};\"_support\"in r?r._support&&typeof r._support==\"function\"?r._support().then(W,u):W(!!r._support):W(!0)}catch(X){u(X)}});return N(n,o,i),n},e.prototype.driver=function(){return this._driver||null},e.prototype.getDriver=function(r,o,i){var n=le[r]?m.resolve(le[r]):m.reject(new Error(\"Driver not found.\"));return N(n,o,i),n},e.prototype.getSerializer=function(r){var o=m.resolve(Ee);return N(o,r),o},e.prototype.ready=function(r){var o=this,i=o._driverSet.then(function(){return o._ready===null&&(o._ready=o._initDriver()),o._ready});return N(i,r,r),i},e.prototype.setDriver=function(r,o,i){var n=this;Xe(r)||(r=[r]);var f=this._getSupportedDrivers(r);function u(){n._config.driver=n.driver()}function c(y){return n._extend(y),u(),n._ready=n._initStorage(n._config),n._ready}function l(y){return function(){var A=0;function T(){for(;A<y.length;){var x=y[A];return A++,n._dbInfo=null,n._ready=null,n.getDriver(x).then(c).catch(T)}u();var V=new Error(\"No available storage method found.\");return n._driverSet=m.reject(V),n._driverSet}return T()}}var d=this._driverSet!==null?this._driverSet.catch(function(){return m.resolve()}):m.resolve();return this._driverSet=d.then(function(){var y=f[0];return n._dbInfo=null,n._ready=null,n.getDriver(y).then(function(A){n._driver=A._driver,u(),n._wrapLibraryMethodsWithReady(),n._initDriver=l(f)})}).catch(function(){u();var y=new Error(\"No available storage method found.\");return n._driverSet=m.reject(y),n._driverSet}),N(this._driverSet,o,i),this._driverSet},e.prototype.supports=function(r){return!!Qe[r]},e.prototype._extend=function(r){Se(this,r)},e.prototype._getSupportedDrivers=function(r){for(var o=[],i=0,n=r.length;i<n;i++){var f=r[i];this.supports(f)&&o.push(f)}return o},e.prototype._wrapLibraryMethodsWithReady=function(){for(var r=0,o=Ie.length;r<o;r++)Gr(this,Ie[r])},e.prototype.createInstance=function(r){return new e(r)},e}(),Xr=new jr;M.exports=Xr},{\"3\":3}]},{},[4])(4)})});var rr=es_$e((ye,er)=>{(function(p,g){typeof ye==\"object\"&&typeof er!=\"undefined\"?g(ye):typeof define==\"function\"&&define.amd?define(\"localforage-driver-memory\",[\"exports\"],g):g(p.LocalforageDriverMemory={})})(typeof self!=\"undefined\"?self:ye,function(p){\"use strict\";var g=\"localforage-driver-memory\";function O(a){var s=typeof Symbol==\"function\"&&a[Symbol.iterator],v=0;return s?s.call(a):{next:function(){return a&&v>=a.length&&(a=void 0),{value:a&&a[v++],done:!a}}}}function L(a,s){a=a||[],s=s||{};try{return new Blob(a,s)}catch(E){if(E.name!==\"TypeError\")throw E;for(var v=typeof BlobBuilder!=\"undefined\"?BlobBuilder:typeof MSBlobBuilder!=\"undefined\"?MSBlobBuilder:typeof MozBlobBuilder!=\"undefined\"?MozBlobBuilder:WebKitBlobBuilder,b=new v,_=0;_<a.length;_+=1)b.append(a[_]);return b.getBlob(s.type)}}var M=/^~~local_forage_type~([^~]+)~/,Q=\"__lfsc__:\".length,C=Q+\"arbf\".length,Y=Object.prototype.toString;function S(a){var s=a.length*.75,v=a.length;a[a.length-1]===\"=\"&&(s--,a[a.length-2]===\"=\"&&s--);for(var b=new ArrayBuffer(s),_=new Uint8Array(b),E=0,D=0;E<v;E+=4){var G=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E]),fe=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E+1]),ie=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E+2]),ce=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".indexOf(a[E+3]);_[D++]=G<<2|fe>>4,_[D++]=(fe&15)<<4|ie>>2,_[D++]=(ie&3)<<6|ce&63}return b}function P(a){for(var s=new Uint8Array(a),v=\"\",b=0;b<s.length;b+=3)v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[s[b]>>2],v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[(s[b]&3)<<4|s[b+1]>>4],v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[(s[b+1]&15)<<2|s[b+2]>>6],v+=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"[s[b+2]&63];return s.length%3===2?v=v.substring(0,v.length-1)+\"=\":s.length%3===1&&(v=v.substring(0,v.length-2)+\"==\"),v}function K(a,s){var v=\"\";if(a&&(v=Y.call(a)),a&&(v===\"[object ArrayBuffer]\"||a.buffer&&Y.call(a.buffer)===\"[object ArrayBuffer]\")){var b=void 0,_=\"__lfsc__:\";a instanceof ArrayBuffer?(b=a,_+=\"arbf\"):(b=a.buffer,v===\"[object Int8Array]\"?_+=\"si08\":v===\"[object Uint8Array]\"?_+=\"ui08\":v===\"[object Uint8ClampedArray]\"?_+=\"uic8\":v===\"[object Int16Array]\"?_+=\"si16\":v===\"[object Uint16Array]\"?_+=\"ur16\":v===\"[object Int32Array]\"?_+=\"si32\":v===\"[object Uint32Array]\"?_+=\"ui32\":v===\"[object Float32Array]\"?_+=\"fl32\":v===\"[object Float64Array]\"?_+=\"fl64\":s(new Error(\"Failed to get type for BinaryArray\"))),s(_+P(b))}else if(v===\"[object Blob]\"){var E=new FileReader;E.onload=function(){var D=\"~~local_forage_type~\"+a.type+\"~\"+P(this.result);s(\"__lfsc__:blob\"+D)},E.readAsArrayBuffer(a)}else try{s(JSON.stringify(a))}catch(D){console.error(\"Couldn't convert value into a JSON string: \",a),s(null,D)}}function Z(a){if(a.substring(0,Q)!==\"__lfsc__:\")return JSON.parse(a);var s=a.substring(C),v=a.substring(Q,C),b;if(v===\"blob\"&&M.test(s)){var _=s.match(M);b=_[1],s=s.substring(_[0].length)}var E=S(s);switch(v){case\"arbf\":return E;case\"blob\":return L([E],{type:b});case\"si08\":return new Int8Array(E);case\"ui08\":return new Uint8Array(E);case\"uic8\":return new Uint8ClampedArray(E);case\"si16\":return new Int16Array(E);case\"ur16\":return new Uint16Array(E);case\"si32\":return new Int32Array(E);case\"ui32\":return new Uint32Array(E);case\"fl32\":return new Float32Array(E);case\"fl64\":return new Float64Array(E);default:throw new Error(\"Unkown type: \"+v)}}function m(a){var s,v;if(a===null||typeof a!=\"object\"||\"isActiveClone\"in a)return a;var b=a instanceof Date?new Date(a):a.constructor();try{for(var _=O(Object.keys(a)),E=_.next();!E.done;E=_.next()){var D=E.value;Object.prototype.hasOwnProperty.call(a,D)&&(a.isActiveClone=null,b[D]=m(a[D]),delete a.isActiveClone)}}catch(G){s={error:G}}finally{try{E&&!E.done&&(v=_.return)&&v.call(_)}finally{if(s)throw s.error}}return b}function w(a,s){return(a.name||s.name)+\"/\"+(a.storeName||s.storeName)+\"/\"}function N(a,s){s&&a.then(function(v){s(null,v)},function(v){s(v)})}function z(){for(var a=[],s=0;s<arguments.length;s++)a[s]=arguments[s];if(arguments.length&&typeof arguments[arguments.length-1]==\"function\")return arguments[arguments.length-1]}function q(a,s){var v=this;if(s=z.apply(this,arguments),a=typeof a!=\"function\"&&a||{},!a.name){var b=this.config();a.name=a.name||b.name,a.storeName=a.storeName||b.storeName}var _;return a.name?_=new Promise(function(E){a.storeName?E(w(a,v._defaultConfig)):E(a.name+\"/\")}):_=Promise.reject(\"Invalid arguments\"),{promise:_,callback:s}}function F(a){return typeof a!=\"string\"&&(console.warn(a+\" used as a key, but it is not a string.\"),a=String(a)),a}var k={bufferToString:P,deserialize:Z,serialize:K,stringToBuffer:S},U={},ae=function(){function a(s){this.kp=s,this.data={}}return a.resolve=function(s){return U[s]||(U[s]=new a(s)),U[s]},a.prototype.clear=function(){this.data={}},a.prototype.drop=function(){this.clear(),delete U[this.kp]},a.prototype.get=function(s){return this.data[s]},a.prototype.key=function(s){return this.keys()[s]},a.prototype.keys=function(){return Object.keys(this.data)},a.prototype.rm=function(s){delete this.data[s]},a.prototype.set=function(s,v){this.data[s]=v},a}();function re(a){var s=a?m(a):{},v=w(s,this._defaultConfig),b=ae.resolve(v);return this._dbInfo=s,this._dbInfo.serializer=k,this._dbInfo.keyPrefix=v,this._dbInfo.mStore=b,Promise.resolve()}function h(a){var s=this,v=this.ready().then(function(){s._dbInfo.mStore.clear()});return N(v,a),v}function R(a,s){var v=q.apply(this,arguments),b=v.promise,_=v.callback,E=b.then(function(D){ae.resolve(D).drop()});return N(E,_),b}function I(a,s){var v=this;a=F(a);var b=this.ready().then(function(){var _=v._dbInfo.mStore.get(a);return _==null?null:v._dbInfo.serializer.deserialize(_)});return N(b,s),b}function B(a,s){var v=this,b=this.ready().then(function(){for(var _=v._dbInfo.mStore,E=_.keys(),D=0;D<E.length;D++){var G=_.get(E[D]);if(G&&(G=v._dbInfo.serializer.deserialize(G)),G=a(G,E[D],D+1),G!==void 0)return G}});return N(b,s),b}function H(a,s){var v=this,b=this.ready().then(function(){var _;try{_=v._dbInfo.mStore.key(a),_===void 0&&(_=null)}catch{_=null}return _});return N(b,s),b}function j(a){var s=this,v=this.ready().then(function(){return s._dbInfo.mStore.keys()});return N(v,a),v}function J(a){var s=this.keys().then(function(v){return v.length});return N(s,a),s}function $(a,s){var v=this;a=F(a);var b=this.ready().then(function(){v._dbInfo.mStore.rm(a)});return N(b,s),b}function ee(a,s,v){var b=this;a=F(a);var _=this.ready().then(function(){s===void 0&&(s=null);var E=s;return new Promise(function(D,G){b._dbInfo.serializer.serialize(s,function(fe,ie){if(ie)G(ie);else try{b._dbInfo.mStore.set(a,fe),D(E)}catch(ce){G(ce)}})})});return N(_,v),_}var oe=!0;p._support=oe,p._driver=g,p._initStorage=re,p.clear=h,p.dropInstance=R,p.getItem=I,p.iterate=B,p.key=H,p.keys=j,p.length=J,p.removeItem=$,p.setItem=ee,Object.defineProperty(p,\"__esModule\",{value:!0})})});var es_pe=es_Ze(es_ke()),es_Be=es_Ze(rr());var es_ft={display:\"none\",position:\"fixed\",top:\"0\",right:\"0\",width:\"100%\",height:\"100%\",borderRadius:\"0\",border:\"none\",zIndex:\"2147483647\"};function es_ut(p){for(let[g,O]of Object.entries(es_ft))p.style[g]=O}function es_st(p){let g=[].slice.call(document.querySelectorAll(\".magic-iframe\"));return Boolean(g.find(O=>O.src.includes(p)))}var es_Te=class extends gt{constructor(){super(...arguments);this.activeElement=null}init(){this.test=\"hello\",this.iframe=new Promise(g=>{let O=()=>{if(es_st(encodeURIComponent(this.parameters)))lr().log();else{let L=document.createElement(\"iframe\");L.classList.add(\"magic-iframe\"),L.dataset.magicIframeLabel=Ie(this.endpoint).host,L.title=\"Secure Modal\",L.src=Ie(`/send?params=${encodeURIComponent(this.parameters)}`,this.endpoint).href,es_ut(L),document.body.appendChild(L),g(L)}};[\"loaded\",\"interactive\",\"complete\"].includes(document.readyState)?O():window.addEventListener(\"load\",O,!1)}),window.addEventListener(\"message\",g=>{var O;if(g.origin===this.endpoint&&g.data&&g.data.msgType&&this.messageHandlers.size){g.data.response=(O=g.data.response)!=null?O:{};for(let L of this.messageHandlers.values())L(g)}})}showOverlay(){return es_se(this,null,function*(){let g=yield this.iframe;g.style.display=\"block\",this.activeElement=document.activeElement,g.focus()})}hideOverlay(){return es_se(this,null,function*(){var O;let g=yield this.iframe;g.style.display=\"none\",((O=this.activeElement)==null?void 0:O.focus)&&this.activeElement.focus(),this.activeElement=null})}_post(g){return es_se(this,null,function*(){let O=yield this.iframe;if(O&&O.contentWindow)O.contentWindow.postMessage(g,this.endpoint);else throw cr()})}};var es_t=Tn($e,{platform:\"web\",sdkName:\"magic-sdk\",version:\"10.0.0\",defaultEndpoint:\"https://auth.magic.link/\",ViewController:es_Te,configureStorage:()=>es_se(void 0,null,function*(){let p=es_pe.default.createInstance({name:\"MagicAuthLocalStorageDB\",storeName:\"MagicAuthLocalStorage\"});return yield p.defineDriver(es_Be),yield p.setDriver([es_pe.default.INDEXEDDB,es_pe.default.LOCALSTORAGE,es_Be._driver]),p})});\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/@magic-ext/connect/dist/es/index.mjs\nvar s=(t=>(t.GetWalletInfo=\"mc_get_wallet_info\",t.ShowWallet=\"mc_wallet\",t.RequestUserInfo=\"mc_request_user_info\",t.Disconnect=\"mc_disconnect\",t))(s||{});var es_l=class extends S.Internal{constructor(){super(...arguments);this.name=\"connect\";this.config={mc:!0}}getWalletInfo(){let e=this.utils.createJsonRpcRequestPayload(\"mc_get_wallet_info\");return this.request(e)}showWallet(){let e=this.utils.createJsonRpcRequestPayload(\"mc_wallet\");return this.request(e)}requestUserInfo(e){let n=this.utils.createJsonRpcRequestPayload(\"mc_request_user_info\",e?[e]:[]);return this.request(n)}disconnect(){let e=this.utils.createJsonRpcRequestPayload(\"mc_disconnect\");return this.request(e)}};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./src/wallet/MagicWeb3Connector.ts\nvar MagicWeb3Connector_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/* global window */\r\n\r\n\r\n\r\n\r\n\r\nclass MagicWeb3Connector extends wallet_AbstractWeb3Connector {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = 'MagicLink';\r\n        this.deactivate = () => MagicWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            this.unsubscribeToEvents(this.provider);\r\n            if (this.magic) {\r\n                yield this.magic.connect.disconnect().catch((e) => {\r\n                    console.error('error to disconnect:', e);\r\n                });\r\n            }\r\n            this.account = null;\r\n            this.chainId = null;\r\n            this.provider = null;\r\n        });\r\n    }\r\n    activate() {\r\n        return MagicWeb3Connector_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            console.log('networkInfo', networkInfo);\r\n            let customNetwork = { rpcUrl: networkInfo.RpcUrl, chainId: networkInfo.ChainId };\r\n            this.magic = new es_t('pk_live_EA9DDC458FE21B24', {\r\n                extensions: [new es_l()],\r\n                network: customNetwork\r\n            });\r\n            // @ts-ignore\r\n            let ether = new Web3Provider(this.magic.rpcProvider);\r\n            let accounts = yield ether.listAccounts();\r\n            // Assign Constants\r\n            this.account = accounts[0];\r\n            this.provider = ether.provider;\r\n            this.chainId = `0x${networkInfo.ChainId.toString(16)}`;\r\n            this.subscribeToEvents(this.provider);\r\n            return {\r\n                provider: this.provider,\r\n                account: this.account,\r\n                chainId: this.chainId,\r\n            };\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/AuthenticateService.ts\nvar AuthenticateService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass AuthenticateService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    static enableWeb3(moralis) {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            if (moralis.isWeb3Enabled()) {\r\n                return moralis.provider;\r\n            }\r\n            let options = { connector: MagicWeb3Connector };\r\n            let result = yield moralis.enableWeb3(options);\r\n            return result;\r\n        });\r\n    }\r\n    authenticateUser(enableWeb3Callback, authenticatedCallback) {\r\n        return AuthenticateService_awaiter(this, void 0, void 0, function* () {\r\n            let chainId = NetworkInfo.getInstance().ChainId;\r\n            let web3Provider = yield AuthenticateService.enableWeb3(this.moralis);\r\n            if (enableWeb3Callback) {\r\n                enableWeb3Callback(web3Provider);\r\n            }\r\n            let user = this.moralis.User.current();\r\n            if (user) {\r\n                if (authenticatedCallback)\r\n                    authenticatedCallback(user);\r\n                return;\r\n            }\r\n            if (web3Provider.network.chainId != chainId) {\r\n                let userNetwork = NetworkInfo.getNetworkInfoByChainId(web3Provider.network.chainId);\r\n                if (userNetwork) {\r\n                    NetworkInfo.setNetworkByChainId(web3Provider.network.chainId);\r\n                }\r\n                else {\r\n                    let modal = new SwitchNetworkModal(this.moralis);\r\n                    modal.show();\r\n                    return;\r\n                }\r\n            }\r\n            let obj = { signingMessage: \"You are logging into Liminal.market.\\n\\n\", connector: MagicWeb3Connector };\r\n            user = yield this.moralis.authenticate(obj)\r\n                .then(result => {\r\n                console.log(result);\r\n                return result;\r\n            })\r\n                .catch((reason) => {\r\n                console.log(reason);\r\n                throw new GeneralError(reason);\r\n            });\r\n            if (authenticatedCallback) {\r\n                authenticatedCallback(user);\r\n            }\r\n            else {\r\n                location.reload();\r\n            }\r\n        });\r\n    }\r\n    getUser() {\r\n        return this.moralis.User.current();\r\n    }\r\n    getEthAddress() {\r\n        let user = this.getUser();\r\n        if (!user)\r\n            return '';\r\n        let ethAddress = user.get('ethAddress');\r\n        return ethAddress;\r\n    }\r\n    isWalletConnected() {\r\n        return this.moralis.isWeb3Enabled();\r\n    }\r\n    isUserLoggedIn() {\r\n        return (this.moralis.User.current() !== null);\r\n    }\r\n    getChainId() {\r\n        if (!this.moralis.chainId)\r\n            return 0;\r\n        return parseInt(this.moralis.chainId, 16);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/Network.ts\nvar Network_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass Network {\r\n    constructor() {\r\n        this.ServerUrl = \"\";\r\n        this.AppId = \"\";\r\n        this.ChainId = 0;\r\n        this.Name = \"\";\r\n        this.ChainName = '';\r\n        this.NativeCurrencyName = \"\";\r\n        this.NativeSymbol = \"\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = '';\r\n        this.BlockExplorer = '';\r\n        this.TestNetwork = true;\r\n        this.FaucetUrl = '';\r\n        this.BuyUrl = '';\r\n    }\r\n    addNetworkToWallet(moralis) {\r\n        return Network_awaiter(this, void 0, void 0, function* () {\r\n            const web3 = yield AuthenticateService.enableWeb3(moralis);\r\n            if (!web3 || !web3.provider.request)\r\n                return;\r\n            web3.provider.request({\r\n                method: 'wallet_addEthereumChain',\r\n                params: [{\r\n                        chainId: '0x' + this.ChainId.toString(16),\r\n                        chainName: this.ChainName,\r\n                        nativeCurrency: {\r\n                            name: this.NativeCurrencyName,\r\n                            symbol: this.NativeSymbol,\r\n                            decimals: this.NativeDecimal\r\n                        },\r\n                        rpcUrls: [this.RpcUrl],\r\n                        blockExplorerUrls: [this.BlockExplorer]\r\n                    }]\r\n            }).catch((error) => {\r\n                console.log(error);\r\n            });\r\n        });\r\n    }\r\n    hasEnoughNativeTokens(moralis) {\r\n        return Network_awaiter(this, void 0, void 0, function* () {\r\n            //TODO: remove later, Moralis doesnt support getNativeBalance on localhost so it's always true\r\n            if (this.Name == 'localhost') {\r\n                return true;\r\n            }\r\n            else {\r\n                const options = { chain: '0x' + this.ChainId.toString(16) };\r\n                const result = yield moralis.Web3API.account.getNativeBalance(options);\r\n                const balance = parseFloat(Moralis.Units.FromWei(result.balance, 18));\r\n                if (balance < 0.005) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n    ;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/TestNetwork.ts\n\r\nclass TestNetwork extends Network {\r\n    constructor() {\r\n        super();\r\n        if (window.location.host.indexOf('localhost') == -1) {\r\n            this.ServerUrl = \"https://f8t1vrrwtboa.usemoralis.com:2053/server\";\r\n            this.AppId = \"XZhp3wQobrKiCib0Bf4FPVKAUhbHM9SvTLKOKvBb\";\r\n        }\r\n        else {\r\n            this.ServerUrl = \"https://pkkenhl7syns.grandmoralis.com:2053/server\";\r\n            this.AppId = \"QpShD4VYQT6N7evc2vMu3VtEKSEGjQPSbuJNhlIq\";\r\n        }\r\n        this.TestNetwork = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/localhost-network.ts\n\r\n//localhost\r\nclass localhostNetwork extends TestNetwork {\r\n    constructor() {\r\n        super();\r\n        this.ChainId = 31337;\r\n        this.Name = \"localhost\";\r\n        this.ChainName = 'localhost test';\r\n        this.NativeCurrencyName = \"Ethereum\";\r\n        this.NativeSymbol = \"ETH\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = 'https://rinkeby.infura.io/';\r\n        this.BlockExplorer = 'https://rinkeby.etherscan.io';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/mumbai-network.ts\n\r\nclass mumbaiNetwork extends TestNetwork {\r\n    constructor() {\r\n        super();\r\n        this.ChainId = 80001;\r\n        this.Name = \"mumbai\";\r\n        this.ChainName = 'Polygon Mumbai';\r\n        this.NativeCurrencyName = \"Matic\";\r\n        this.NativeSymbol = \"MATIC\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = 'https://matic-mumbai.chainstacklabs.com/';\r\n        this.BlockExplorer = 'https://mumbai.polygonscan.com/';\r\n        this.FaucetUrl = 'https://faucet.polygon.technology/';\r\n        this.BuyUrl = 'https://www.moonpay.com/buy/matic';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/util/CookieHelper.ts\nclass CookieHelper {\r\n    constructor(document) {\r\n        this.document = document;\r\n    }\r\n    setCookie(name, value) {\r\n        let date = new Date();\r\n        this.deleteCookie(name);\r\n        this.document.cookie = name + \"=\" + value + \"; expires=Mon, 2 Dec \" + (date.getFullYear() + 1) + \" 12:00:00 UTC;path=/;SameSite=Strict\";\r\n    }\r\n    getCookieValue(name) {\r\n        var _a;\r\n        return ((_a = this.document.cookie.match('(^|;)\\\\s*' + name + '\\\\s*=\\\\s*([^;]+)')) === null || _a === void 0 ? void 0 : _a.pop()) || '';\r\n    }\r\n    setCookieProvider(providerName) {\r\n        this.setCookie(\"provider\", providerName);\r\n    }\r\n    deleteCookie(name) {\r\n        this.document.cookie = name + \"=0; expires=Mon, 2 Dec 2020 12:00:00 UTC;path=/\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/MainNetwork.ts\n\r\nclass MainNetwork extends Network {\r\n    constructor() {\r\n        super();\r\n        this.ServerUrl = \"https://rokinwgcthqy.grandmoralis.com:2053/server\";\r\n        this.AppId = \"FqJxfp9xng1SbovOToR2fnFjnBJju2Ko67nmTfFF\";\r\n        this.TestNetwork = false;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/polygon-network.ts\n\r\nclass polygonNetwork extends MainNetwork {\r\n    constructor() {\r\n        super();\r\n        this.ChainId = 137;\r\n        this.Name = \"polygon\";\r\n        this.ChainName = 'Polygon Mainnet';\r\n        this.NativeCurrencyName = \"Matic\";\r\n        this.NativeSymbol = \"MATIC\";\r\n        this.NativeDecimal = 18;\r\n        this.RpcUrl = 'https://polygon-rpc.com/';\r\n        this.BlockExplorer = 'https://polygonscan.com/';\r\n        this.FaucetUrl = 'https://faucet.polygon.technology/';\r\n        this.BuyUrl = 'https://www.moonpay.com/buy/matic';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/networks/NetworkInfo.ts\n\r\n\r\n\r\n\r\n\r\nconst networkInfos = [localhostNetwork, mumbaiNetwork, polygonNetwork];\r\nclass NetworkInfo {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    static getInstance() {\r\n        if (NetworkInfo.instance)\r\n            return NetworkInfo.instance;\r\n        NetworkInfo.instance = this.getNetworkInfo();\r\n        return NetworkInfo.instance;\r\n    }\r\n    static loadNetwork(networkName) {\r\n        NetworkInfo.instance = this.getNetworkInfo(networkName);\r\n    }\r\n    static setNetworkByChainId(chainId) {\r\n        let network = this.getNetworkInfoByChainId(chainId);\r\n        if (network) {\r\n            NetworkInfo.instance = network;\r\n            let cookieHelper = new CookieHelper(document);\r\n            cookieHelper.setCookie('network', network.Name);\r\n        }\r\n    }\r\n    static getNetworks(networkType) {\r\n        let networks = new Array();\r\n        let isLocalhost = window.location.host.indexOf('localhost') != -1;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (!isLocalhost && tmp.Name == \"localhost\")\r\n                return;\r\n            if (networkType === undefined) {\r\n                networks.push(tmp);\r\n            }\r\n            else {\r\n                console.log(networkType);\r\n                if (networkType == NetworkType.Mainnet && !tmp.TestNetwork) {\r\n                    networks.push(tmp);\r\n                }\r\n                else if (networkType == NetworkType.Testnet && tmp.TestNetwork) {\r\n                    networks.push(tmp);\r\n                }\r\n            }\r\n        });\r\n        return networks;\r\n    }\r\n    static getNetworkInfoByChainId(chainId) {\r\n        let networkInfo;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (tmp.ChainId == chainId) {\r\n                networkInfo = tmp;\r\n            }\r\n        });\r\n        return networkInfo;\r\n    }\r\n    static getNetworkInfo(networkName) {\r\n        let cookieHelper = new CookieHelper(document);\r\n        if (!networkName)\r\n            networkName = cookieHelper.getCookieValue('network');\r\n        if (!networkName)\r\n            networkName = 'polygon';\r\n        let networkInfo = null;\r\n        networkInfos.forEach(networkInfoType => {\r\n            let tmp = new networkInfoType();\r\n            if (tmp.Name == networkName) {\r\n                networkInfo = tmp;\r\n            }\r\n        });\r\n        if (networkInfo)\r\n            return networkInfo;\r\n        console.error(\"Network '\" + networkName + \"' could not be found. Defaulting to Polygon network.\");\r\n        return new polygonNetwork();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/ConnectionService.ts\nvar ConnectionService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass ConnectionService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.options = { serverUrl: '', appId: '' };\r\n    }\r\n    getOptions() {\r\n        return this.options;\r\n    }\r\n    start() {\r\n        return ConnectionService_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            this.options = { serverUrl: networkInfo.ServerUrl, appId: networkInfo.AppId };\r\n            yield this.moralis.start(this.options).catch(function (err) {\r\n                if (err.message.indexOf('Invalid session token') != -1) {\r\n                    Moralis.User.logOut();\r\n                    console.log('Invalid session token');\r\n                }\r\n            });\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/localhost-contract-addresses.ts\nclass localhostContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0x172A9DA328BC71f4354f4f17Db5630552cC9420d\";\r\n        this.AUSD_ADDRESS = \"0xCd40ae7648E53B92e338CCaAF78734397D2Fe2A4\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x54eb4fA482d50e0369D333193De804898317A2A5\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0xF5A39660A894698074593A5B1fBd33697dCa4091\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/mumbai-contract-addresses.ts\nclass mumbaiContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0x9e2B28D9F841300bE3B64e505dEcA36c35250609\";\r\n        this.AUSD_ADDRESS = \"0x38F2B1E9F11937dD276D64521535b15280A7F137\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x6e9C29e416dc9F7A6A03ffebaB3f02Ef62a1baE4\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0xc6B29dfd4FD756EF94b3A3FF7a531F4467BDDA75\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/fuji-contract-addresses.ts\nclass fujiContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0x0594D04FDB5C98Fb7F777a799139424Ae2414AaD\";\r\n        this.AUSD_ADDRESS = \"0xbAc482aE0b0d652854df377be566445984A021ED\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x098A512B017408008a23ECe22843788799CDebFd\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0x77E6A62Be8398B18d2dA81CDB6Eb097bD8132ccB\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/polygon-contract-addresses.ts\nclass polygonContractAddresses {\r\n    constructor() {\r\n        this.KYC_ADDRESS = \"0xc7dA98E282cc30BD4fe0a7dE38372F876DB577E4\";\r\n        this.AUSD_ADDRESS = \"0x9B780e71C2a8492E805e17616EB878f2e3874E21\";\r\n        this.LIMINAL_MARKET_ADDRESS = \"0x8B4fc0bcaED76a6569525d8Fe51E57cAd32FDd94\";\r\n        this.MARKET_CALENDAR_ADDRESS = \"0x77b54CbF3e1370af13da41196B4d99cd02eBcC44\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/contracts/ContractInfo.ts\n\r\n\r\n\r\n\r\n\r\nclass ContractInfo {\r\n    static getContractInfo(networkName) {\r\n        let contractInfos = {\r\n            localhostContractAddresses: localhostContractAddresses, mumbaiContractAddresses: mumbaiContractAddresses, fujiContractAddresses: fujiContractAddresses,\r\n            polygonContractAddresses: polygonContractAddresses\r\n        };\r\n        if (!networkName) {\r\n            networkName = NetworkInfo.getInstance().Name;\r\n        }\r\n        const contractInfoType = contractInfos[networkName + 'ContractAddresses'];\r\n        return new contractInfoType();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/InfoBarType.ts\nvar InfoBarType;\r\n(function (InfoBarType) {\r\n    InfoBarType[\"Info\"] = \"infoBar\";\r\n    InfoBarType[\"Warning\"] = \"warningBar\";\r\n    InfoBarType[\"Error\"] = \"errorBar\";\r\n})(InfoBarType || (InfoBarType = {}));\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/InfoBar.ts\n\r\nclass InfoBar {\r\n    static show(message, type, timeoutInSeconds = 4) {\r\n        let infoBar = document.getElementById('infoBar');\r\n        if (!infoBar) {\r\n            infoBar = document.createElement('div');\r\n            infoBar.classList.add('notificationBar');\r\n            infoBar.id = 'infoBar';\r\n            document.body.insertAdjacentElement('afterbegin', infoBar);\r\n        }\r\n        infoBar.innerHTML = message;\r\n        infoBar.classList.remove('hidden');\r\n        infoBar.classList.remove(InfoBarType.Info);\r\n        infoBar.classList.remove(InfoBarType.Warning);\r\n        infoBar.classList.remove(InfoBarType.Error);\r\n        infoBar.classList.add(type);\r\n        if (timeoutInSeconds > 0) {\r\n            setTimeout(() => {\r\n                infoBar === null || infoBar === void 0 ? void 0 : infoBar.classList.add('hidden');\r\n            }, timeoutInSeconds * 1000);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/WalletMissing.html\n// Module\nvar WalletMissing_code = \"\\r\\nYou need to set up a wallet in your browser before you can use liminal.market.\\r\\n<br/><br/>\\r\\nTo make it simple, we would like to suggest two options. In your browser or your phone.\\r\\n<ul>\\r\\n    <li>For the browser we recommend <a href=\\\"https://metamask.io/download/\\\"\\r\\n                                                                         target=\\\"_blank\\\">Metamask</a>.\\r\\n    </li>\\r\\n    <li>\\r\\n        For your phone, we like <a href=\\\"https://www.tokenpocket.pro/en/download/app\\\" target=\\\"_blank\\\">Token Poket</a>\\r\\n    </li>\\r\\n</ul>\\r\\n<br/>\\r\\nBut, you have <a href=\\\"https://ethereum.org/en/wallets/\\\" target=\\\"_blank\\\">many options</a> if you want to learn more.\";\n// Exports\n/* harmony default export */ const WalletMissing = (WalletMissing_code);\n;// CONCATENATED MODULE: ./src/errors/PredefinedErrorHandlers.ts\n\r\n\r\n\r\n\r\n\r\nclass PredefinedErrorHandlers {\r\n    constructor() {\r\n        this.errorMessageMapping = new Map();\r\n        this.SentLoginRequest = \"We have sent request to you wallet to login. Open your wallet to login\";\r\n        this.errorMessageMapping.set('chain not supported', () => {\r\n            let div = 'Network is not supported. <a href=\"\" id=\"switchNetworkLink\">Click me to switch to supported network</a>';\r\n            InfoBar.show(div, InfoBarType.Warning, 120);\r\n            let switchNetworkLink = document.getElementById('switchNetworkLink');\r\n            switchNetworkLink === null || switchNetworkLink === void 0 ? void 0 : switchNetworkLink.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let modal = new SwitchNetworkModal(Moralis);\r\n                modal.show();\r\n            });\r\n        });\r\n        this.errorMessageMapping.set('already processing eth_requestaccounts', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('request of type \\'wallet_requestPermissions\\' already pending', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('already has been called, but is not finished yet', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('request is already in progress', this.SentLoginRequest);\r\n        this.errorMessageMapping.set('web3 instance', () => {\r\n            let elements = document.querySelectorAll(\".liminal_market_connect_wallet\");\r\n            if (elements.length > 0) {\r\n                elements[0].dispatchEvent(new MouseEvent('click'));\r\n                return;\r\n            }\r\n        });\r\n        this.errorMessageMapping.set('user rejected the request', () => {\r\n            Moralis.User.logOut();\r\n            window.location.reload();\r\n        });\r\n        this.errorMessageMapping.set('Non ethereum enabled browser', () => {\r\n            let modal = new Modal();\r\n            let template = Handlebars.compile(WalletMissing);\r\n            modal.showModal('New to blockchain?', template(null), false, () => {\r\n                //window.location.reload();\r\n            });\r\n        });\r\n    }\r\n    handle(message) {\r\n        let handled = false;\r\n        this.errorMessageMapping.forEach((value, key) => {\r\n            if (!handled && message.toLowerCase().indexOf(key.toLowerCase()) != -1) {\r\n                if (typeof value == 'string') {\r\n                    InfoBar.show(value.toString(), InfoBarType.Warning, 10);\r\n                }\r\n                else {\r\n                    value();\r\n                }\r\n                handled = true;\r\n                return handled;\r\n            }\r\n        });\r\n        return handled;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/ErrorInfo.ts\n\r\n\r\n\r\nclass ErrorInfo {\r\n    constructor(errorInfo) {\r\n        this.errorInfo = errorInfo;\r\n    }\r\n    getErrorInfo() {\r\n        return this.errorInfo;\r\n    }\r\n    static report(error) {\r\n        LoadingHelper.removeLoading();\r\n        if (!error)\r\n            return;\r\n        let errorHandler = new PredefinedErrorHandlers();\r\n        if (errorHandler.handle(error.message)) {\r\n            return;\r\n        }\r\n        if (error.callback) {\r\n            error.callback();\r\n            return;\r\n        }\r\n        if (error) {\r\n            console.error(error.toString());\r\n        }\r\n        //InfoBar.show(error.message, InfoBarType.Error);\r\n    }\r\n    static log(obj) {\r\n        ErrorInfo.report(new GeneralError(obj));\r\n    }\r\n    static info(obj) {\r\n        ErrorInfo.report(new GeneralError(obj));\r\n    }\r\n    static error(obj) {\r\n        console.log(obj);\r\n        ErrorInfo.report(new GeneralError(obj));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/MarketIsClosed.html\n// Module\nvar MarketIsClosed_code = \"<div class=\\\"center\\\">\\r\\n    The stock market is currently closed.<br/>\\r\\nIt is usually open monday to friday between 9:30 AM and 4:00 PM EST (9:30 - 16:00 EST).\\r\\n    <br/><br/>\\r\\nToday is {{dayOfWeek}}\\r\\n<br /><br/>\\r\\nYour current time is {{currentTime}} ({{GMT}})\\r\\n    <br/><br/>\\r\\nThat means the market is open your time between\\r\\n{{openFrom}} - {{openTo}}\\r\\n</div>\";\n// Exports\n/* harmony default export */ const MarketIsClosed = (MarketIsClosed_code);\n;// CONCATENATED MODULE: ./src/util/DateHelper.ts\nclass DateHelper {\r\n    static isOlderThen(date, minutes) {\r\n        let currentTime = new Date().getTime();\r\n        return (currentTime > (date.getTime() + minutes * 60 * 1000));\r\n    }\r\n    ;\r\n    static getWeekday() {\r\n        const weekday = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\r\n        const d = new Date();\r\n        return weekday[d.getDay()];\r\n    }\r\n    static getOpenAndCloseHours() {\r\n        const d = new Date();\r\n        let openHour = 9 + 4 + (-1 * (d.getTimezoneOffset() / 60));\r\n        let closeHour = 16 + 4 + (-1 * (d.getTimezoneOffset() / 60));\r\n        return [openHour + ':30', closeHour + ':00'];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/BlockchainError.ts\n\r\n\r\n\r\n\r\nclass BlockchainError extends GeneralError {\r\n    constructor(e) {\r\n        super(e);\r\n        this.message = e.toString();\r\n        if (this.userDeniedTransactionSignature()) {\r\n            this.code = BlockchainError.UserCancelled;\r\n        }\r\n        else if (this.addressIsNotValidKYC()) {\r\n            this.code = BlockchainError.AddressIsNotValidKYC;\r\n        }\r\n        else if (this.isMarketClosed()) {\r\n            this.code = BlockchainError.MarketIsClosed;\r\n            this.callback = this.marketIsClosedModal;\r\n        }\r\n        if (e.data && e.data.message) {\r\n            let msg = e.data.message;\r\n            let searchStr = 'reverted with reason string';\r\n            let idx = msg.indexOf(searchStr) + searchStr.length;\r\n            if (idx != -1) {\r\n                this.message = msg.substring(idx).trim().replace(/'/g, '');\r\n                this.code = BlockchainError.ErrorFromContract;\r\n            }\r\n        }\r\n    }\r\n    userDeniedTransactionSignature() {\r\n        return this.message.indexOf('denied transaction signature') !== -1;\r\n    }\r\n    addressIsNotValidKYC() {\r\n        return this.message.indexOf('address is not kyc valid') !== -1;\r\n    }\r\n    isMarketClosed() {\r\n        let searchStr = 'Market is closed';\r\n        return this.message.indexOf(searchStr) !== -1;\r\n    }\r\n    marketIsClosedModal() {\r\n        let [openHour, closeHour] = DateHelper.getOpenAndCloseHours();\r\n        let time = new Date().toTimeString().split(' ');\r\n        let obj = {\r\n            currentTime: time[0],\r\n            GMT: time[1],\r\n            dayOfWeek: DateHelper.getWeekday(),\r\n            openFrom: openHour,\r\n            openTo: closeHour\r\n        };\r\n        let modal = new Modal();\r\n        let template = Handlebars.compile(MarketIsClosed);\r\n        modal.showModal('Market is closed', template(obj));\r\n    }\r\n}\r\nBlockchainError.ErrorFromContract = -1;\r\nBlockchainError.UserCancelled = 1;\r\nBlockchainError.AddressIsNotValidKYC = 2;\r\nBlockchainError.MarketIsClosed = 3;\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/BlockchainService.ts\nvar BlockchainService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass BlockchainService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    executeFunction(options) {\r\n        return BlockchainService_awaiter(this, void 0, void 0, function* () {\r\n            if (typeof ethereum != 'undefined' && ethereum && ethereum.chainId) {\r\n                let networkInfo = NetworkInfo.getNetworkInfoByChainId(ethereum.chainId);\r\n                if (!networkInfo) {\r\n                    throw new GeneralError('chain not supported');\r\n                }\r\n            }\r\n            return yield this.moralis.executeFunction(options);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/LiminalMarketService.ts\nvar LiminalMarketService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass LiminalMarketService extends BlockchainService {\r\n    constructor(moralis) {\r\n        super(moralis);\r\n    }\r\n    getSymbolContractAddress(symbol) {\r\n        return LiminalMarketService_awaiter(this, void 0, void 0, function* () {\r\n            const options = yield this.getOptions(\"getSecurityToken\", {\r\n                symbol: symbol\r\n            });\r\n            let result = yield this.executeFunction(options)\r\n                .then((value) => {\r\n                return value.toString();\r\n            }).catch((reason) => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                throw ErrorInfo.report(blockchainError);\r\n            });\r\n            return result;\r\n        });\r\n    }\r\n    getOptions(functionName, params) {\r\n        return LiminalMarketService_awaiter(this, void 0, void 0, function* () {\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let abi = yield this.getLiminalMarketAbi();\r\n            const options = {\r\n                contractAddress: contractInfo.LIMINAL_MARKET_ADDRESS,\r\n                functionName: functionName,\r\n                abi: abi,\r\n                params: params,\r\n            };\r\n            return options;\r\n        });\r\n    }\r\n    getLiminalMarketAbi() {\r\n        return LiminalMarketService_awaiter(this, void 0, void 0, function* () {\r\n            if (LiminalMarketService.LiminalMarketInfo)\r\n                return LiminalMarketService.LiminalMarketInfo.abi;\r\n            let response = yield fetch('../abi/LiminalMarket.json');\r\n            LiminalMarketService.LiminalMarketInfo = yield response.json();\r\n            return LiminalMarketService.LiminalMarketInfo.abi;\r\n        });\r\n    }\r\n    createToken(symbol, creatingToken) {\r\n        return LiminalMarketService_awaiter(this, void 0, void 0, function* () {\r\n            let salt = (new Date().getTime() + (Math.random() * 100000)).toString();\r\n            salt = salt.substring(0, salt.indexOf('.'));\r\n            const liminalOptions = yield this.getOptions(\"createToken\", {\r\n                symbol: symbol,\r\n                salt: salt\r\n            });\r\n            let result = yield this.executeFunction(liminalOptions)\r\n                .then(result => {\r\n                return result;\r\n            }).catch(reason => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                if (blockchainError.userDeniedTransactionSignature()) {\r\n                    return blockchainError;\r\n                }\r\n                throw ErrorInfo.report(blockchainError);\r\n            });\r\n            if (result instanceof BlockchainError)\r\n                return result;\r\n            creatingToken();\r\n            yield result.wait();\r\n            return yield this.getSymbolContractAddress(symbol);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/SecuritiesList.html\n// Module\nvar SecuritiesList_code = \"<figure>\\r\\n    <table id=\\\"liminal_market_securities_table\\\" role=\\\"grid\\\">\\r\\n    <thead>\\r\\n    <tr>\\r\\n        <th colspan=\\\"2\\\"><input autocomplete=\\\"off\\\" type=\\\"search\\\" id=\\\"search_for_symbol\\\" placeholder=\\\"Search for name or symbol in {{securitiesCount}} stocks\\\"></th>\\r\\n    </tr>\\r\\n    </thead>\\r\\n    <tbody id=\\\"{{tbodyId}}\\\">\\r\\n    {{>securities}}\\r\\n    </tbody>\\r\\n</table>\\r\\n<span id=\\\"liminal_market_load_more\\\"></span>\\r\\n</figure>\";\n// Exports\n/* harmony default export */ const elements_SecuritiesList = (SecuritiesList_code);\n;// CONCATENATED MODULE: ./src/html/elements/Securities.html\n// Module\nvar Securities_code = \"{{#each securities}}\\r\\n<tr data-symbol=\\\"{{{Symbol}}}\\\" data-logo=\\\"{{LogoPath}}{{Logo}}\\\" data-name=\\\"{{Name}}\\\">\\r\\n    <td class=\\\"symbol_logo\\\"><img src=\\\"{{LogoPath}}{{Logo}}\\\"/></td>\\r\\n    <td class=\\\"security_information\\\">\\r\\n        <strong>{{Name}}</strong><br/>\\r\\n        <nav class=\\\"security_extra\\\">\\r\\n            <ul>\\r\\n                <li>\\r\\n                    <a href=\\\"https://strike.market/stocks/{{Symbol}}\\\" target=\\\"_blank\\\">{{Symbol}}</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n            <ul>\\r\\n                <li>\\r\\n                    <a href=\\\"\\\" class=\\\"getAddress\\\" data-symbol=\\\"{{Symbol}}\\\">Get address</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n            <ul>\\r\\n                <li>\\r\\n                    <a href=\\\"\\\" class=\\\"addToWallet\\\" data-symbol=\\\"{{Symbol}}\\\">Add to wallet</a>\\r\\n                </li>\\r\\n            </ul>\\r\\n        </nav>\\r\\n    </td>\\r\\n</tr>\\r\\n{{/each}}\";\n// Exports\n/* harmony default export */ const Securities = (Securities_code);\n;// CONCATENATED MODULE: ./src/util/CopyHelper.ts\nvar CopyHelper_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass CopyHelper {\r\n    fallbackCopyTextToClipboard(text) {\r\n        let textArea = document.createElement(\"textarea\");\r\n        textArea.value = text;\r\n        // Avoid scrolling to bottom\r\n        textArea.style.top = \"0\";\r\n        textArea.style.left = \"0\";\r\n        textArea.style.position = \"fixed\";\r\n        document.body.appendChild(textArea);\r\n        textArea.focus();\r\n        textArea.select();\r\n        try {\r\n            let successful = document.execCommand('copy');\r\n            return successful;\r\n        }\r\n        catch (err) {\r\n            console.error(err);\r\n            return false;\r\n        }\r\n        finally {\r\n            document.body.removeChild(textArea);\r\n        }\r\n    }\r\n    copyTextToClipboard(text) {\r\n        return CopyHelper_awaiter(this, void 0, void 0, function* () {\r\n            if (!navigator.clipboard) {\r\n                return this.fallbackCopyTextToClipboard(text);\r\n            }\r\n            let result = yield navigator.clipboard.writeText(text).then(ble => {\r\n                console.log('ble', ble);\r\n                return true;\r\n            }).\r\n                catch(function (err) {\r\n                console.info(err);\r\n                return false;\r\n            });\r\n            console.log(result);\r\n            return result;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/AddressInfo.html\n// Module\nvar AddressInfo_code = \"<article id=\\\"symbolInfoToCopy\\\">\\r\\n    This is the address for the symbol {{symbol}}.\\r\\n    <br/>\\r\\n    <input value=\\\"{{address}}\\\"/>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const AddressInfo = (AddressInfo_code);\n;// CONCATENATED MODULE: ./src/html/elements/ContractAddressNotFound.html\n// Module\nvar ContractAddressNotFound_code = \"<tr id=\\\"symbolInfoToCopy\\\">\\r\\n    <td colspan=\\\"4\\\">\\r\\n        <article>\\r\\n        This symbol has never been bought and does not exist. Buy this symbol and address will become available.\\r\\n        </article>\\r\\n    </td>\\r\\n</tr>\";\n// Exports\n/* harmony default export */ const ContractAddressNotFound = (ContractAddressNotFound_code);\n;// CONCATENATED MODULE: ./node_modules/bignumber.js/bignumber.mjs\n/*\r\n *      bignumber.js v9.1.0\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\nvar\r\n  isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n  mathceil = Math.ceil,\r\n  mathfloor = Math.floor,\r\n\r\n  bignumberError = '[BigNumber Error] ',\r\n  tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n  BASE = 1e14,\r\n  LOG_BASE = 14,\r\n  bignumber_MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n  // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n  POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n  SQRT_BASE = 1e7,\r\n\r\n  // EDITABLE\r\n  // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n  // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n  MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n/*\r\n * Create and return a BigNumber constructor.\r\n */\r\nfunction clone(configObject) {\r\n  var div, convertBase, parseNumeric,\r\n    P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n    ONE = new BigNumber(1),\r\n\r\n\r\n    //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n    // The default values below must be integers within the inclusive ranges stated.\r\n    // The values can also be changed at run-time using BigNumber.set.\r\n\r\n    // The maximum number of decimal places for operations involving division.\r\n    DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n    // The rounding mode used when rounding to the above decimal places, and when using\r\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n    // UP         0 Away from zero.\r\n    // DOWN       1 Towards zero.\r\n    // CEIL       2 Towards +Infinity.\r\n    // FLOOR      3 Towards -Infinity.\r\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n    ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n    // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n    // The exponent value at and beneath which toString returns exponential notation.\r\n    // Number type: -7\r\n    TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n    // The exponent value at and above which toString returns exponential notation.\r\n    // Number type: 21\r\n    TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n    // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n    // The minimum exponent value, beneath which underflow to zero occurs.\r\n    // Number type: -324  (5e-324)\r\n    MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n    // The maximum exponent value, above which overflow to Infinity occurs.\r\n    // Number type:  308  (1.7976931348623157e+308)\r\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n    MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n    // Whether to use cryptographically-secure random number generation, if available.\r\n    CRYPTO = false,                          // true or false\r\n\r\n    // The modulo mode used when calculating the modulus: a mod n.\r\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n    // The remainder (r) is calculated as: r = a - n * q.\r\n    //\r\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n    // DOWN      1 The remainder has the same sign as the dividend.\r\n    //             This modulo mode is commonly known as 'truncated division' and is\r\n    //             equivalent to (a % n) in JavaScript.\r\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n    //             The remainder is always positive.\r\n    //\r\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n    // modes are commonly used for the modulus operation.\r\n    // Although the other rounding modes can also be used, they may not give useful results.\r\n    MODULO_MODE = 1,                         // 0 to 9\r\n\r\n    // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n    POW_PRECISION = 0,                       // 0 to MAX\r\n\r\n    // The format specification used by the BigNumber.prototype.toFormat method.\r\n    FORMAT = {\r\n      prefix: '',\r\n      groupSize: 3,\r\n      secondaryGroupSize: 0,\r\n      groupSeparator: ',',\r\n      decimalSeparator: '.',\r\n      fractionGroupSize: 0,\r\n      fractionGroupSeparator: '\\xA0',        // non-breaking space\r\n      suffix: ''\r\n    },\r\n\r\n    // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n    // '-', '.', whitespace, or repeated character.\r\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n    ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',\r\n    alphabetHasNormalDecimalDigits = true;\r\n\r\n\r\n  //------------------------------------------------------------------------------------------\r\n\r\n\r\n  // CONSTRUCTOR\r\n\r\n\r\n  /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */\r\n  function BigNumber(v, b) {\r\n    var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n      x = this;\r\n\r\n    // Enable constructor call without `new`.\r\n    if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n    if (b == null) {\r\n\r\n      if (v && v._isBigNumber === true) {\r\n        x.s = v.s;\r\n\r\n        if (!v.c || v.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n        } else if (v.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = v.e;\r\n          x.c = v.c.slice();\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n        // Use `1 / n` to handle minus zero also.\r\n        x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n        // Fast path for integers, where n < 2147483648 (2**31).\r\n        if (v === ~~v) {\r\n          for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n          if (e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else {\r\n            x.e = e;\r\n            x.c = [v];\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        str = String(v);\r\n      } else {\r\n\r\n        if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n      // Exponential form?\r\n      if ((i = str.search(/e/i)) > 0) {\r\n\r\n        // Determine exponent.\r\n        if (e < 0) e = i;\r\n        e += +str.slice(i + 1);\r\n        str = str.substring(0, i);\r\n      } else if (e < 0) {\r\n\r\n        // Integer.\r\n        e = str.length;\r\n      }\r\n\r\n    } else {\r\n\r\n      // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n      intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n      // Allow exponential notation to be used with base 10 argument, while\r\n      // also rounding to DECIMAL_PLACES as with other bases.\r\n      if (b == 10 && alphabetHasNormalDecimalDigits) {\r\n        x = new BigNumber(v);\r\n        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n      }\r\n\r\n      str = String(v);\r\n\r\n      if (isNum = typeof v == 'number') {\r\n\r\n        // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n        if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n          throw Error\r\n           (tooManyDigits + v);\r\n        }\r\n      } else {\r\n        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n      }\r\n\r\n      alphabet = ALPHABET.slice(0, b);\r\n      e = i = 0;\r\n\r\n      // Check that str is a valid base b number.\r\n      // Don't use RegExp, so alphabet can contain special characters.\r\n      for (len = str.length; i < len; i++) {\r\n        if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n          if (c == '.') {\r\n\r\n            // If '.' is not the first character and it has not be found before.\r\n            if (i > e) {\r\n              e = len;\r\n              continue;\r\n            }\r\n          } else if (!caseChanged) {\r\n\r\n            // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n            if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n              caseChanged = true;\r\n              i = -1;\r\n              e = 0;\r\n              continue;\r\n            }\r\n          }\r\n\r\n          return parseNumeric(x, String(v), isNum, b);\r\n        }\r\n      }\r\n\r\n      // Prevent later check for length on converted number.\r\n      isNum = false;\r\n      str = convertBase(str, b, 10, x.s);\r\n\r\n      // Decimal point?\r\n      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n      else e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n    if (str = str.slice(i, ++len)) {\r\n      len -= i;\r\n\r\n      // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n      if (isNum && BigNumber.DEBUG &&\r\n        len > 15 && (v > bignumber_MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n          throw Error\r\n           (tooManyDigits + (x.s * v));\r\n      }\r\n\r\n       // Overflow?\r\n      if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        x.c = x.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      } else {\r\n        x.e = e;\r\n        x.c = [];\r\n\r\n        // Transform base\r\n\r\n        // e is the base 10 exponent.\r\n        // i is where to slice str to get the first element of the coefficient array.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n        if (i < len) {\r\n          if (i) x.c.push(+str.slice(0, i));\r\n\r\n          for (len -= LOG_BASE; i < len;) {\r\n            x.c.push(+str.slice(i, i += LOG_BASE));\r\n          }\r\n\r\n          i = LOG_BASE - (str = str.slice(i)).length;\r\n        } else {\r\n          i -= len;\r\n        }\r\n\r\n        for (; i--; str += '0');\r\n        x.c.push(+str);\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.c = [x.e = 0];\r\n    }\r\n  }\r\n\r\n\r\n  // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n  BigNumber.clone = clone;\r\n\r\n  BigNumber.ROUND_UP = 0;\r\n  BigNumber.ROUND_DOWN = 1;\r\n  BigNumber.ROUND_CEIL = 2;\r\n  BigNumber.ROUND_FLOOR = 3;\r\n  BigNumber.ROUND_HALF_UP = 4;\r\n  BigNumber.ROUND_HALF_DOWN = 5;\r\n  BigNumber.ROUND_HALF_EVEN = 6;\r\n  BigNumber.ROUND_HALF_CEIL = 7;\r\n  BigNumber.ROUND_HALF_FLOOR = 8;\r\n  BigNumber.EUCLID = 9;\r\n\r\n\r\n  /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */\r\n  BigNumber.config = BigNumber.set = function (obj) {\r\n    var p, v;\r\n\r\n    if (obj != null) {\r\n\r\n      if (typeof obj == 'object') {\r\n\r\n        // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          DECIMAL_PLACES = v;\r\n        }\r\n\r\n        // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n        // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 8, p);\r\n          ROUNDING_MODE = v;\r\n        }\r\n\r\n        // EXPONENTIAL_AT {number|number[]}\r\n        // Integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n        // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, 0, p);\r\n            intCheck(v[1], 0, MAX, p);\r\n            TO_EXP_NEG = v[0];\r\n            TO_EXP_POS = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n          }\r\n        }\r\n\r\n        // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n        // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n        // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n        if (obj.hasOwnProperty(p = 'RANGE')) {\r\n          v = obj[p];\r\n          if (v && v.pop) {\r\n            intCheck(v[0], -MAX, -1, p);\r\n            intCheck(v[1], 1, MAX, p);\r\n            MIN_EXP = v[0];\r\n            MAX_EXP = v[1];\r\n          } else {\r\n            intCheck(v, -MAX, MAX, p);\r\n            if (v) {\r\n              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' cannot be zero: ' + v);\r\n            }\r\n          }\r\n        }\r\n\r\n        // CRYPTO {boolean} true or false.\r\n        // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n        // '[BigNumber Error] crypto unavailable'\r\n        if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n          v = obj[p];\r\n          if (v === !!v) {\r\n            if (v) {\r\n              if (typeof crypto != 'undefined' && crypto &&\r\n               (crypto.getRandomValues || crypto.randomBytes)) {\r\n                CRYPTO = v;\r\n              } else {\r\n                CRYPTO = !v;\r\n                throw Error\r\n                 (bignumberError + 'crypto unavailable');\r\n              }\r\n            } else {\r\n              CRYPTO = v;\r\n            }\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' not true or false: ' + v);\r\n          }\r\n        }\r\n\r\n        // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n        // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, 9, p);\r\n          MODULO_MODE = v;\r\n        }\r\n\r\n        // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n        // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n        if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n          v = obj[p];\r\n          intCheck(v, 0, MAX, p);\r\n          POW_PRECISION = v;\r\n        }\r\n\r\n        // FORMAT {object}\r\n        // '[BigNumber Error] FORMAT not an object: {v}'\r\n        if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n          v = obj[p];\r\n          if (typeof v == 'object') FORMAT = v;\r\n          else throw Error\r\n           (bignumberError + p + ' not an object: ' + v);\r\n        }\r\n\r\n        // ALPHABET {string}\r\n        // '[BigNumber Error] ALPHABET invalid: {v}'\r\n        if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n          v = obj[p];\r\n\r\n          // Disallow if less than two characters,\r\n          // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n          if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n            alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';\r\n            ALPHABET = v;\r\n          } else {\r\n            throw Error\r\n             (bignumberError + p + ' invalid: ' + v);\r\n          }\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Object expected: {v}'\r\n        throw Error\r\n         (bignumberError + 'Object expected: ' + obj);\r\n      }\r\n    }\r\n\r\n    return {\r\n      DECIMAL_PLACES: DECIMAL_PLACES,\r\n      ROUNDING_MODE: ROUNDING_MODE,\r\n      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n      RANGE: [MIN_EXP, MAX_EXP],\r\n      CRYPTO: CRYPTO,\r\n      MODULO_MODE: MODULO_MODE,\r\n      POW_PRECISION: POW_PRECISION,\r\n      FORMAT: FORMAT,\r\n      ALPHABET: ALPHABET\r\n    };\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */\r\n  BigNumber.isBigNumber = function (v) {\r\n    if (!v || v._isBigNumber !== true) return false;\r\n    if (!BigNumber.DEBUG) return true;\r\n\r\n    var i, n,\r\n      c = v.c,\r\n      e = v.e,\r\n      s = v.s;\r\n\r\n    out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n      if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n        // If the first element is zero, the BigNumber value must be zero.\r\n        if (c[0] === 0) {\r\n          if (e === 0 && c.length === 1) return true;\r\n          break out;\r\n        }\r\n\r\n        // Calculate number of digits that c[0] should have, based on the exponent.\r\n        i = (e + 1) % LOG_BASE;\r\n        if (i < 1) i += LOG_BASE;\r\n\r\n        // Calculate number of digits of c[0].\r\n        //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n        if (String(c[0]).length == i) {\r\n\r\n          for (i = 0; i < c.length; i++) {\r\n            n = c[i];\r\n            if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n          }\r\n\r\n          // Last element cannot be zero, unless it is the only element.\r\n          if (n !== 0) return true;\r\n        }\r\n      }\r\n\r\n    // Infinity/NaN\r\n    } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n      return true;\r\n    }\r\n\r\n    throw Error\r\n      (bignumberError + 'Invalid BigNumber: ' + v);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.maximum = BigNumber.max = function () {\r\n    return maxOrMin(arguments, P.lt);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.minimum = BigNumber.min = function () {\r\n    return maxOrMin(arguments, P.gt);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */\r\n  BigNumber.random = (function () {\r\n    var pow2_53 = 0x20000000000000;\r\n\r\n    // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n    // Check if Math.random() produces more than 32 bits of randomness.\r\n    // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n    // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n    var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n     ? function () { return mathfloor(Math.random() * pow2_53); }\r\n     : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n       (Math.random() * 0x800000 | 0); };\r\n\r\n    return function (dp) {\r\n      var a, b, e, k, v,\r\n        i = 0,\r\n        c = [],\r\n        rand = new BigNumber(ONE);\r\n\r\n      if (dp == null) dp = DECIMAL_PLACES;\r\n      else intCheck(dp, 0, MAX);\r\n\r\n      k = mathceil(dp / LOG_BASE);\r\n\r\n      if (CRYPTO) {\r\n\r\n        // Browsers supporting crypto.getRandomValues.\r\n        if (crypto.getRandomValues) {\r\n\r\n          a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n          for (; i < k;) {\r\n\r\n            // 53 bits:\r\n            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n            // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n            //                                     11111 11111111 11111111\r\n            // 0x20000 is 2^21.\r\n            v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n            // Rejection sampling:\r\n            // 0 <= v < 9007199254740992\r\n            // Probability that v >= 9e15, is\r\n            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n            if (v >= 9e15) {\r\n              b = crypto.getRandomValues(new Uint32Array(2));\r\n              a[i] = b[0];\r\n              a[i + 1] = b[1];\r\n            } else {\r\n\r\n              // 0 <= v <= 8999999999999999\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 2;\r\n            }\r\n          }\r\n          i = k / 2;\r\n\r\n        // Node.js supporting crypto.randomBytes.\r\n        } else if (crypto.randomBytes) {\r\n\r\n          // buffer\r\n          a = crypto.randomBytes(k *= 7);\r\n\r\n          for (; i < k;) {\r\n\r\n            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n            // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n            // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n            // 0 <= v < 9007199254740992\r\n            v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n               (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n               (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n            if (v >= 9e15) {\r\n              crypto.randomBytes(7).copy(a, i);\r\n            } else {\r\n\r\n              // 0 <= (v % 1e14) <= 99999999999999\r\n              c.push(v % 1e14);\r\n              i += 7;\r\n            }\r\n          }\r\n          i = k / 7;\r\n        } else {\r\n          CRYPTO = false;\r\n          throw Error\r\n           (bignumberError + 'crypto unavailable');\r\n        }\r\n      }\r\n\r\n      // Use Math.random.\r\n      if (!CRYPTO) {\r\n\r\n        for (; i < k;) {\r\n          v = random53bitInt();\r\n          if (v < 9e15) c[i++] = v % 1e14;\r\n        }\r\n      }\r\n\r\n      k = c[--i];\r\n      dp %= LOG_BASE;\r\n\r\n      // Convert trailing digits to zeros according to dp.\r\n      if (k && dp) {\r\n        v = POWS_TEN[LOG_BASE - dp];\r\n        c[i] = mathfloor(k / v) * v;\r\n      }\r\n\r\n      // Remove trailing elements which are zero.\r\n      for (; c[i] === 0; c.pop(), i--);\r\n\r\n      // Zero?\r\n      if (i < 0) {\r\n        c = [e = 0];\r\n      } else {\r\n\r\n        // Remove leading elements which are zero and adjust exponent accordingly.\r\n        for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n        // Count the digits of the first element of c to determine leading zeros, and...\r\n        for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n        // adjust the exponent accordingly.\r\n        if (i < LOG_BASE) e -= LOG_BASE - i;\r\n      }\r\n\r\n      rand.e = e;\r\n      rand.c = c;\r\n      return rand;\r\n    };\r\n  })();\r\n\r\n\r\n   /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */\r\n  BigNumber.sum = function () {\r\n    var i = 1,\r\n      args = arguments,\r\n      sum = new BigNumber(args[0]);\r\n    for (; i < args.length;) sum = sum.plus(args[i++]);\r\n    return sum;\r\n  };\r\n\r\n\r\n  // PRIVATE FUNCTIONS\r\n\r\n\r\n  // Called by BigNumber and BigNumber.prototype.toString.\r\n  convertBase = (function () {\r\n    var decimal = '0123456789';\r\n\r\n    /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */\r\n    function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n      var j,\r\n        arr = [0],\r\n        arrL,\r\n        i = 0,\r\n        len = str.length;\r\n\r\n      for (; i < len;) {\r\n        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n        arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n        for (j = 0; j < arr.length; j++) {\r\n\r\n          if (arr[j] > baseOut - 1) {\r\n            if (arr[j + 1] == null) arr[j + 1] = 0;\r\n            arr[j + 1] += arr[j] / baseOut | 0;\r\n            arr[j] %= baseOut;\r\n          }\r\n        }\r\n      }\r\n\r\n      return arr.reverse();\r\n    }\r\n\r\n    // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n    // If the caller is toString, we are converting from base 10 to baseOut.\r\n    // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n    return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n      var alphabet, d, e, k, r, x, xc, y,\r\n        i = str.indexOf('.'),\r\n        dp = DECIMAL_PLACES,\r\n        rm = ROUNDING_MODE;\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        k = POW_PRECISION;\r\n\r\n        // Unlimited precision.\r\n        POW_PRECISION = 0;\r\n        str = str.replace('.', '');\r\n        y = new BigNumber(baseIn);\r\n        x = y.pow(str.length - i);\r\n        POW_PRECISION = k;\r\n\r\n        // Convert str as if an integer, then restore the fraction part by dividing the\r\n        // result by its base raised to a power.\r\n\r\n        y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n         10, baseOut, decimal);\r\n        y.e = y.c.length;\r\n      }\r\n\r\n      // Convert the number as integer.\r\n\r\n      xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n       ? (alphabet = ALPHABET, decimal)\r\n       : (alphabet = decimal, ALPHABET));\r\n\r\n      // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n      e = k = xc.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xc[--k] == 0; xc.pop());\r\n\r\n      // Zero?\r\n      if (!xc[0]) return alphabet.charAt(0);\r\n\r\n      // Does str represent an integer? If so, no need for the division.\r\n      if (i < 0) {\r\n        --e;\r\n      } else {\r\n        x.c = xc;\r\n        x.e = e;\r\n\r\n        // The sign is needed for correct rounding.\r\n        x.s = sign;\r\n        x = div(x, y, dp, rm, baseOut);\r\n        xc = x.c;\r\n        r = x.r;\r\n        e = x.e;\r\n      }\r\n\r\n      // xc now represents str converted to baseOut.\r\n\r\n      // THe index of the rounding digit.\r\n      d = e + dp + 1;\r\n\r\n      // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n      i = xc[d];\r\n\r\n      // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n      k = baseOut / 2;\r\n      r = r || d < 0 || xc[d + 1] != null;\r\n\r\n      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n            : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n      // If the index of the rounding digit is not greater than zero, or xc represents\r\n      // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n      // such as 0.00001.\r\n      if (d < 1 || !xc[0]) {\r\n\r\n        // 1^-dp or 0\r\n        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n      } else {\r\n\r\n        // Truncate xc to the required number of decimal places.\r\n        xc.length = d;\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (--baseOut; ++xc[--d] > baseOut;) {\r\n            xc[d] = 0;\r\n\r\n            if (!d) {\r\n              ++e;\r\n              xc = [1].concat(xc);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (k = xc.length; !xc[--k];);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n        // Add leading zeros, decimal point and trailing zeros as required.\r\n        str = toFixedPoint(str, e, alphabet.charAt(0));\r\n      }\r\n\r\n      // The caller will add the sign.\r\n      return str;\r\n    };\r\n  })();\r\n\r\n\r\n  // Perform division in the specified base. Called by div and convertBase.\r\n  div = (function () {\r\n\r\n    // Assume non-zero x and k.\r\n    function multiply(x, k, base) {\r\n      var m, temp, xlo, xhi,\r\n        carry = 0,\r\n        i = x.length,\r\n        klo = k % SQRT_BASE,\r\n        khi = k / SQRT_BASE | 0;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        xlo = x[i] % SQRT_BASE;\r\n        xhi = x[i] / SQRT_BASE | 0;\r\n        m = khi * xlo + xhi * klo;\r\n        temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n        x[i] = temp % base;\r\n      }\r\n\r\n      if (carry) x = [carry].concat(x);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, cmp;\r\n\r\n      if (aL != bL) {\r\n        cmp = aL > bL ? 1 : -1;\r\n      } else {\r\n\r\n        for (i = cmp = 0; i < aL; i++) {\r\n\r\n          if (a[i] != b[i]) {\r\n            cmp = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return cmp;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n    }\r\n\r\n    // x: dividend, y: divisor.\r\n    return function (x, y, dp, rm, base) {\r\n      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n        yL, yz,\r\n        s = x.s == y.s ? 1 : -1,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n        return new BigNumber(\r\n\r\n         // Return NaN if either NaN, or both Infinity or 0.\r\n         !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n          xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n       );\r\n      }\r\n\r\n      q = new BigNumber(s);\r\n      qc = q.c = [];\r\n      e = x.e - y.e;\r\n      s = dp + e + 1;\r\n\r\n      if (!base) {\r\n        base = BASE;\r\n        e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n        s = s / LOG_BASE | 0;\r\n      }\r\n\r\n      // Result exponent may be one less then the current value of e.\r\n      // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n      for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n      if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n      if (s < 0) {\r\n        qc.push(1);\r\n        more = true;\r\n      } else {\r\n        xL = xc.length;\r\n        yL = yc.length;\r\n        i = 0;\r\n        s += 2;\r\n\r\n        // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n        n = mathfloor(base / (yc[0] + 1));\r\n\r\n        // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n        // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n        if (n > 1) {\r\n          yc = multiply(yc, n, base);\r\n          xc = multiply(xc, n, base);\r\n          yL = yc.length;\r\n          xL = xc.length;\r\n        }\r\n\r\n        xi = yL;\r\n        rem = xc.slice(0, yL);\r\n        remL = rem.length;\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL < yL; rem[remL++] = 0);\r\n        yz = yc.slice();\r\n        yz = [0].concat(yz);\r\n        yc0 = yc[0];\r\n        if (yc[1] >= base / 2) yc0++;\r\n        // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n        // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n        do {\r\n          n = 0;\r\n\r\n          // Compare divisor and remainder.\r\n          cmp = compare(yc, rem, yL, remL);\r\n\r\n          // If divisor < remainder.\r\n          if (cmp < 0) {\r\n\r\n            // Calculate trial digit, n.\r\n\r\n            rem0 = rem[0];\r\n            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n            // n is how many times the divisor goes into the current remainder.\r\n            n = mathfloor(rem0 / yc0);\r\n\r\n            //  Algorithm:\r\n            //  product = divisor multiplied by trial digit (n).\r\n            //  Compare product and remainder.\r\n            //  If product is greater than remainder:\r\n            //    Subtract divisor from product, decrement trial digit.\r\n            //  Subtract product from remainder.\r\n            //  If product was less than remainder at the last compare:\r\n            //    Compare new remainder and divisor.\r\n            //    If remainder is greater than divisor:\r\n            //      Subtract divisor from remainder, increment trial digit.\r\n\r\n            if (n > 1) {\r\n\r\n              // n may be > base only when base is 3.\r\n              if (n >= base) n = base - 1;\r\n\r\n              // product = divisor * trial digit.\r\n              prod = multiply(yc, n, base);\r\n              prodL = prod.length;\r\n              remL = rem.length;\r\n\r\n              // Compare product and remainder.\r\n              // If product > remainder then trial digit n too high.\r\n              // n is 1 too high about 5% of the time, and is not known to have\r\n              // ever been more than 1 too high.\r\n              while (compare(prod, rem, prodL, remL) == 1) {\r\n                n--;\r\n\r\n                // Subtract divisor from product.\r\n                subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                prodL = prod.length;\r\n                cmp = 1;\r\n              }\r\n            } else {\r\n\r\n              // n is 0 or 1, cmp is -1.\r\n              // If n is 0, there is no need to compare yc and rem again below,\r\n              // so change cmp to 1 to avoid it.\r\n              // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n              if (n == 0) {\r\n\r\n                // divisor < remainder, so n must be at least 1.\r\n                cmp = n = 1;\r\n              }\r\n\r\n              // product = divisor\r\n              prod = yc.slice();\r\n              prodL = prod.length;\r\n            }\r\n\r\n            if (prodL < remL) prod = [0].concat(prod);\r\n\r\n            // Subtract product from remainder.\r\n            subtract(rem, prod, remL, base);\r\n            remL = rem.length;\r\n\r\n             // If product was < remainder.\r\n            if (cmp == -1) {\r\n\r\n              // Compare divisor and new remainder.\r\n              // If divisor < new remainder, subtract divisor from remainder.\r\n              // Trial digit n too low.\r\n              // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n              while (compare(yc, rem, yL, remL) < 1) {\r\n                n++;\r\n\r\n                // Subtract divisor from remainder.\r\n                subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                remL = rem.length;\r\n              }\r\n            }\r\n          } else if (cmp === 0) {\r\n            n++;\r\n            rem = [0];\r\n          } // else cmp === 1 and n will be 0\r\n\r\n          // Add the next digit, n, to the result array.\r\n          qc[i++] = n;\r\n\r\n          // Update the remainder.\r\n          if (rem[0]) {\r\n            rem[remL++] = xc[xi] || 0;\r\n          } else {\r\n            rem = [xc[xi]];\r\n            remL = 1;\r\n          }\r\n        } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n        more = rem[0] != null;\r\n\r\n        // Leading zero?\r\n        if (!qc[0]) qc.splice(0, 1);\r\n      }\r\n\r\n      if (base == BASE) {\r\n\r\n        // To calculate q.e, first get the number of digits of qc[0].\r\n        for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n      // Caller is convertBase.\r\n      } else {\r\n        q.e = e;\r\n        q.r = +more;\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */\r\n  function format(n, i, rm, id) {\r\n    var c0, e, ne, len, str;\r\n\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n\r\n    if (!n.c) return n.toString();\r\n\r\n    c0 = n.c[0];\r\n    ne = n.e;\r\n\r\n    if (i == null) {\r\n      str = coeffToString(n.c);\r\n      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n       ? toExponential(str, ne)\r\n       : toFixedPoint(str, ne, '0');\r\n    } else {\r\n      n = round(new BigNumber(n), i, rm);\r\n\r\n      // n.e may have changed if the value was rounded up.\r\n      e = n.e;\r\n\r\n      str = coeffToString(n.c);\r\n      len = str.length;\r\n\r\n      // toPrecision returns exponential notation if the number of significant digits\r\n      // specified is less than the number of digits necessary to represent the integer\r\n      // part of the value in fixed-point notation.\r\n\r\n      // Exponential notation.\r\n      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n        // Append zeros?\r\n        for (; len < i; str += '0', len++);\r\n        str = toExponential(str, e);\r\n\r\n      // Fixed-point notation.\r\n      } else {\r\n        i -= ne;\r\n        str = toFixedPoint(str, e, '0');\r\n\r\n        // Append zeros?\r\n        if (e + 1 > len) {\r\n          if (--i > 0) for (str += '.'; i--; str += '0');\r\n        } else {\r\n          i += e - len;\r\n          if (i > 0) {\r\n            if (e + 1 == len) str += '.';\r\n            for (; i--; str += '0');\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return n.s < 0 && c0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Handle BigNumber.max and BigNumber.min.\r\n  function maxOrMin(args, method) {\r\n    var n,\r\n      i = 1,\r\n      m = new BigNumber(args[0]);\r\n\r\n    for (; i < args.length; i++) {\r\n      n = new BigNumber(args[i]);\r\n\r\n      // If any number is NaN, return NaN.\r\n      if (!n.s) {\r\n        m = n;\r\n        break;\r\n      } else if (method.call(m, n)) {\r\n        m = n;\r\n      }\r\n    }\r\n\r\n    return m;\r\n  }\r\n\r\n\r\n  /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */\r\n  function normalise(n, c, e) {\r\n    var i = 1,\r\n      j = c.length;\r\n\r\n     // Remove trailing zeros.\r\n    for (; !c[--j]; c.pop());\r\n\r\n    // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n    for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n    // Overflow?\r\n    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n      // Infinity.\r\n      n.c = n.e = null;\r\n\r\n    // Underflow?\r\n    } else if (e < MIN_EXP) {\r\n\r\n      // Zero.\r\n      n.c = [n.e = 0];\r\n    } else {\r\n      n.e = e;\r\n      n.c = c;\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n\r\n  // Handle values that fail the validity test in BigNumber.\r\n  parseNumeric = (function () {\r\n    var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n      dotAfter = /^([^.]+)\\.$/,\r\n      dotBefore = /^\\.([^.]+)$/,\r\n      isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n      whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n    return function (x, str, isNum, b) {\r\n      var base,\r\n        s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n      // No exception on Infinity or NaN.\r\n      if (isInfinityOrNaN.test(s)) {\r\n        x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n      } else {\r\n        if (!isNum) {\r\n\r\n          // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n          s = s.replace(basePrefix, function (m, p1, p2) {\r\n            base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n            return !b || b == base ? p1 : m;\r\n          });\r\n\r\n          if (b) {\r\n            base = b;\r\n\r\n            // E.g. '1.' to '1', '.1' to '0.1'\r\n            s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n          }\r\n\r\n          if (str != s) return new BigNumber(s, base);\r\n        }\r\n\r\n        // '[BigNumber Error] Not a number: {n}'\r\n        // '[BigNumber Error] Not a base {b} number: {n}'\r\n        if (BigNumber.DEBUG) {\r\n          throw Error\r\n            (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n        }\r\n\r\n        // NaN\r\n        x.s = null;\r\n      }\r\n\r\n      x.c = x.e = null;\r\n    }\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */\r\n  function round(x, sd, rm, r) {\r\n    var d, i, j, k, n, ni, rd,\r\n      xc = x.c,\r\n      pows10 = POWS_TEN;\r\n\r\n    // if x is not Infinity or NaN...\r\n    if (xc) {\r\n\r\n      // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n      // ni is the index of n within x.c.\r\n      // d is the number of digits of n.\r\n      // i is the index of rd within n including leading zeros.\r\n      // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n      out: {\r\n\r\n        // Get the number of digits of the first element of xc.\r\n        for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n        i = sd - d;\r\n\r\n        // If the rounding digit is in the first element of xc...\r\n        if (i < 0) {\r\n          i += LOG_BASE;\r\n          j = sd;\r\n          n = xc[ni = 0];\r\n\r\n          // Get the rounding digit at index j of n.\r\n          rd = n / pows10[d - j - 1] % 10 | 0;\r\n        } else {\r\n          ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n          if (ni >= xc.length) {\r\n\r\n            if (r) {\r\n\r\n              // Needed by sqrt.\r\n              for (; xc.length <= ni; xc.push(0));\r\n              n = rd = 0;\r\n              d = 1;\r\n              i %= LOG_BASE;\r\n              j = i - LOG_BASE + 1;\r\n            } else {\r\n              break out;\r\n            }\r\n          } else {\r\n            n = k = xc[ni];\r\n\r\n            // Get the number of digits of n.\r\n            for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n            // Get the index of rd within n.\r\n            i %= LOG_BASE;\r\n\r\n            // Get the index of rd within n, adjusted for leading zeros.\r\n            // The number of leading zeros of n is given by LOG_BASE - d.\r\n            j = i - LOG_BASE + d;\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n          }\r\n        }\r\n\r\n        r = r || sd < 0 ||\r\n\r\n        // Are there any non-zero digits after the rounding digit?\r\n        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n         xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n        r = rm < 4\r\n         ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n         : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n           rm == (x.s < 0 ? 8 : 7));\r\n\r\n        if (sd < 1 || !xc[0]) {\r\n          xc.length = 0;\r\n\r\n          if (r) {\r\n\r\n            // Convert sd to decimal places.\r\n            sd -= x.e + 1;\r\n\r\n            // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n            x.e = -sd || 0;\r\n          } else {\r\n\r\n            // Zero.\r\n            xc[0] = x.e = 0;\r\n          }\r\n\r\n          return x;\r\n        }\r\n\r\n        // Remove excess digits.\r\n        if (i == 0) {\r\n          xc.length = ni;\r\n          k = 1;\r\n          ni--;\r\n        } else {\r\n          xc.length = ni + 1;\r\n          k = pows10[LOG_BASE - i];\r\n\r\n          // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n          // j > 0 means i > number of leading zeros of n.\r\n          xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n        }\r\n\r\n        // Round up?\r\n        if (r) {\r\n\r\n          for (; ;) {\r\n\r\n            // If the digit to be rounded up is in the first element of xc...\r\n            if (ni == 0) {\r\n\r\n              // i will be the length of xc[0] before k is added.\r\n              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n              j = xc[0] += k;\r\n              for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n              // if i != k the length has increased.\r\n              if (i != k) {\r\n                x.e++;\r\n                if (xc[0] == BASE) xc[0] = 1;\r\n              }\r\n\r\n              break;\r\n            } else {\r\n              xc[ni] += k;\r\n              if (xc[ni] != BASE) break;\r\n              xc[ni--] = 0;\r\n              k = 1;\r\n            }\r\n          }\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = xc.length; xc[--i] === 0; xc.pop());\r\n      }\r\n\r\n      // Overflow? Infinity.\r\n      if (x.e > MAX_EXP) {\r\n        x.c = x.e = null;\r\n\r\n      // Underflow? Zero.\r\n      } else if (x.e < MIN_EXP) {\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function valueOf(n) {\r\n    var str,\r\n      e = n.e;\r\n\r\n    if (e === null) return n.toString();\r\n\r\n    str = coeffToString(n.c);\r\n\r\n    str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n      ? toExponential(str, e)\r\n      : toFixedPoint(str, e, '0');\r\n\r\n    return n.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new BigNumber(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */\r\n  P.comparedTo = function (y, b) {\r\n    return compare(this, new BigNumber(y, b));\r\n  };\r\n\r\n\r\n  /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.decimalPlaces = P.dp = function (dp, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), dp + x.e + 1, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n    // Subtract the number of trailing zeros of the last number.\r\n    if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n    if (n < 0) n = 0;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.dividedBy = P.div = function (y, b) {\r\n    return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */\r\n  P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n    return div(this, new BigNumber(y, b), 0, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */\r\n  P.exponentiatedBy = P.pow = function (n, m) {\r\n    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n      x = this;\r\n\r\n    n = new BigNumber(n);\r\n\r\n    // Allow NaN and Infinity, but not other non-integers.\r\n    if (n.c && !n.isInteger()) {\r\n      throw Error\r\n        (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n    }\r\n\r\n    if (m != null) m = new BigNumber(m);\r\n\r\n    // Exponent of MAX_SAFE_INTEGER is 15.\r\n    nIsBig = n.e > 14;\r\n\r\n    // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n      // The sign of the result of pow when x is negative depends on the evenness of n.\r\n      // If +n overflows to Infinity, the evenness of n would be not be known.\r\n      y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n      return m ? y.mod(m) : y;\r\n    }\r\n\r\n    nIsNeg = n.s < 0;\r\n\r\n    if (m) {\r\n\r\n      // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n      if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n      isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n      if (isModExp) x = x.mod(m);\r\n\r\n    // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n    // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n      // [1, 240000000]\r\n      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n      // [80000000000000]  [99999750000000]\r\n      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n      // If x is negative and n is odd, k = -0, else k = 0.\r\n      k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n      // If x >= 1, k = Infinity.\r\n      if (x.e > -1) k = 1 / k;\r\n\r\n      // If n is negative return 0, else return Infinity.\r\n      return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n    } else if (POW_PRECISION) {\r\n\r\n      // Truncating each coefficient array to a length of k after each multiplication\r\n      // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n      // i.e. there will be a minimum of 28 guard digits retained.\r\n      k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n    }\r\n\r\n    if (nIsBig) {\r\n      half = new BigNumber(0.5);\r\n      if (nIsNeg) n.s = 1;\r\n      nIsOdd = isOdd(n);\r\n    } else {\r\n      i = Math.abs(+valueOf(n));\r\n      nIsOdd = i % 2;\r\n    }\r\n\r\n    y = new BigNumber(ONE);\r\n\r\n    // Performs 54 loop iterations for n of 9007199254740991.\r\n    for (; ;) {\r\n\r\n      if (nIsOdd) {\r\n        y = y.times(x);\r\n        if (!y.c) break;\r\n\r\n        if (k) {\r\n          if (y.c.length > k) y.c.length = k;\r\n        } else if (isModExp) {\r\n          y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (i) {\r\n        i = mathfloor(i / 2);\r\n        if (i === 0) break;\r\n        nIsOdd = i % 2;\r\n      } else {\r\n        n = n.times(half);\r\n        round(n, n.e + 1, 1);\r\n\r\n        if (n.e > 14) {\r\n          nIsOdd = isOdd(n);\r\n        } else {\r\n          i = +valueOf(n);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        }\r\n      }\r\n\r\n      x = x.times(x);\r\n\r\n      if (k) {\r\n        if (x.c && x.c.length > k) x.c.length = k;\r\n      } else if (isModExp) {\r\n        x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n      }\r\n    }\r\n\r\n    if (isModExp) return y;\r\n    if (nIsNeg) y = ONE.div(y);\r\n\r\n    return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */\r\n  P.integerValue = function (rm) {\r\n    var n = new BigNumber(this);\r\n    if (rm == null) rm = ROUNDING_MODE;\r\n    else intCheck(rm, 0, 8);\r\n    return round(n, n.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isEqualTo = P.eq = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.c;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isGreaterThan = P.gt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */\r\n  P.isInteger = function () {\r\n    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */\r\n  P.isLessThan = P.lt = function (y, b) {\r\n    return compare(this, new BigNumber(y, b)) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */\r\n  P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n    return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */\r\n  P.isNegative = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */\r\n  P.isPositive = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.c && this.c[0] == 0;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.minus = function (y, b) {\r\n    var i, j, t, xLTy,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n    if (a != b) {\r\n      y.s = -b;\r\n      return x.plus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Either Infinity?\r\n      if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n      // Either zero?\r\n      if (!xc[0] || !yc[0]) {\r\n\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n         // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n         ROUNDING_MODE == 3 ? -0 : 0);\r\n      }\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Determine which is the bigger number.\r\n    if (a = xe - ye) {\r\n\r\n      if (xLTy = a < 0) {\r\n        a = -a;\r\n        t = xc;\r\n      } else {\r\n        ye = xe;\r\n        t = yc;\r\n      }\r\n\r\n      t.reverse();\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      for (b = a; b--; t.push(0));\r\n      t.reverse();\r\n    } else {\r\n\r\n      // Exponents equal. Check digit by digit.\r\n      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n      for (a = b = 0; b < j; b++) {\r\n\r\n        if (xc[b] != yc[b]) {\r\n          xLTy = xc[b] < yc[b];\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // x < y? Point xc to the array of the bigger number.\r\n    if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n    b = (j = yc.length) - (i = xc.length);\r\n\r\n    // Append zeros to xc if shorter.\r\n    // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n    if (b > 0) for (; b--; xc[i++] = 0);\r\n    b = BASE - 1;\r\n\r\n    // Subtract yc from xc.\r\n    for (; j > a;) {\r\n\r\n      if (xc[--j] < yc[j]) {\r\n        for (i = j; i && !xc[--i]; xc[i] = b);\r\n        --xc[i];\r\n        xc[j] += BASE;\r\n      }\r\n\r\n      xc[j] -= yc[j];\r\n    }\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n    // Zero?\r\n    if (!xc[0]) {\r\n\r\n      // Following IEEE 754 (2008) 6.3,\r\n      // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n      y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n      y.c = [y.e = 0];\r\n      return y;\r\n    }\r\n\r\n    // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n    // for finite x and y.\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */\r\n  P.modulo = P.mod = function (y, b) {\r\n    var q, s,\r\n      x = this;\r\n\r\n    y = new BigNumber(y, b);\r\n\r\n    // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n    if (!x.c || !y.s || y.c && !y.c[0]) {\r\n      return new BigNumber(NaN);\r\n\r\n    // Return x if y is Infinity or x is zero.\r\n    } else if (!y.c || x.c && !x.c[0]) {\r\n      return new BigNumber(x);\r\n    }\r\n\r\n    if (MODULO_MODE == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // r = x - qy    where  0 <= r < abs(y)\r\n      s = y.s;\r\n      y.s = 1;\r\n      q = div(x, y, 0, 3);\r\n      y.s = s;\r\n      q.s *= s;\r\n    } else {\r\n      q = div(x, y, 0, MODULO_MODE);\r\n    }\r\n\r\n    y = x.minus(q.times(y));\r\n\r\n    // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n    if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n    return y;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */\r\n  P.multipliedBy = P.times = function (y, b) {\r\n    var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n      base, sqrtBase,\r\n      x = this,\r\n      xc = x.c,\r\n      yc = (y = new BigNumber(y, b)).c;\r\n\r\n    // Either NaN, Infinity or 0?\r\n    if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n      // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n      if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n        y.c = y.e = y.s = null;\r\n      } else {\r\n        y.s *= x.s;\r\n\r\n        // Return Infinity if either is Infinity.\r\n        if (!xc || !yc) {\r\n          y.c = y.e = null;\r\n\r\n        // Return 0 if either is 0.\r\n        } else {\r\n          y.c = [0];\r\n          y.e = 0;\r\n        }\r\n      }\r\n\r\n      return y;\r\n    }\r\n\r\n    e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n    y.s *= x.s;\r\n    xcL = xc.length;\r\n    ycL = yc.length;\r\n\r\n    // Ensure xc points to longer array and xcL to its length.\r\n    if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n    // Initialise the result array with zeros.\r\n    for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n    base = BASE;\r\n    sqrtBase = SQRT_BASE;\r\n\r\n    for (i = ycL; --i >= 0;) {\r\n      c = 0;\r\n      ylo = yc[i] % sqrtBase;\r\n      yhi = yc[i] / sqrtBase | 0;\r\n\r\n      for (k = xcL, j = i + k; j > i;) {\r\n        xlo = xc[--k] % sqrtBase;\r\n        xhi = xc[k] / sqrtBase | 0;\r\n        m = yhi * xlo + xhi * ylo;\r\n        xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n        c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n        zc[j--] = xlo % base;\r\n      }\r\n\r\n      zc[j] = c;\r\n    }\r\n\r\n    if (c) {\r\n      ++e;\r\n    } else {\r\n      zc.splice(0, 1);\r\n    }\r\n\r\n    return normalise(y, zc, e);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */\r\n  P.negated = function () {\r\n    var x = new BigNumber(this);\r\n    x.s = -x.s || null;\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */\r\n  P.plus = function (y, b) {\r\n    var t,\r\n      x = this,\r\n      a = x.s;\r\n\r\n    y = new BigNumber(y, b);\r\n    b = y.s;\r\n\r\n    // Either NaN?\r\n    if (!a || !b) return new BigNumber(NaN);\r\n\r\n    // Signs differ?\r\n     if (a != b) {\r\n      y.s = -b;\r\n      return x.minus(y);\r\n    }\r\n\r\n    var xe = x.e / LOG_BASE,\r\n      ye = y.e / LOG_BASE,\r\n      xc = x.c,\r\n      yc = y.c;\r\n\r\n    if (!xe || !ye) {\r\n\r\n      // Return Infinity if either Infinity.\r\n      if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n      // Either zero?\r\n      // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n      if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n    }\r\n\r\n    xe = bitFloor(xe);\r\n    ye = bitFloor(ye);\r\n    xc = xc.slice();\r\n\r\n    // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n    if (a = xe - ye) {\r\n      if (a > 0) {\r\n        ye = xe;\r\n        t = yc;\r\n      } else {\r\n        a = -a;\r\n        t = xc;\r\n      }\r\n\r\n      t.reverse();\r\n      for (; a--; t.push(0));\r\n      t.reverse();\r\n    }\r\n\r\n    a = xc.length;\r\n    b = yc.length;\r\n\r\n    // Point xc to the longer array, and b to the shorter length.\r\n    if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n    // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n    for (a = 0; b;) {\r\n      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n    }\r\n\r\n    if (a) {\r\n      xc = [a].concat(xc);\r\n      ++ye;\r\n    }\r\n\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    // ye = MAX_EXP + 1 possible\r\n    return normalise(y, xc, ye);\r\n  };\r\n\r\n\r\n  /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.precision = P.sd = function (sd, rm) {\r\n    var c, n, v,\r\n      x = this;\r\n\r\n    if (sd != null && sd !== !!sd) {\r\n      intCheck(sd, 1, MAX);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      return round(new BigNumber(x), sd, rm);\r\n    }\r\n\r\n    if (!(c = x.c)) return null;\r\n    v = c.length - 1;\r\n    n = v * LOG_BASE + 1;\r\n\r\n    if (v = c[v]) {\r\n\r\n      // Subtract the number of trailing zeros of the last element.\r\n      for (; v % 10 == 0; v /= 10, n--);\r\n\r\n      // Add the number of digits of the first element.\r\n      for (v = c[0]; v >= 10; v /= 10, n++);\r\n    }\r\n\r\n    if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */\r\n  P.shiftedBy = function (k) {\r\n    intCheck(k, -bignumber_MAX_SAFE_INTEGER, bignumber_MAX_SAFE_INTEGER);\r\n    return this.times('1e' + k);\r\n  };\r\n\r\n\r\n  /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, r, rep, t,\r\n      x = this,\r\n      c = x.c,\r\n      s = x.s,\r\n      e = x.e,\r\n      dp = DECIMAL_PLACES + 4,\r\n      half = new BigNumber('0.5');\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !c || !c[0]) {\r\n      return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n    }\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+valueOf(x));\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = coeffToString(c);\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(+n);\r\n      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new BigNumber(n);\r\n    } else {\r\n      r = new BigNumber(s + '');\r\n    }\r\n\r\n    // Check for zero.\r\n    // r could be zero if MIN_EXP is changed after the this value was created.\r\n    // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n    // coeffToString to throw.\r\n    if (r.c[0]) {\r\n      e = r.e;\r\n      s = e + dp;\r\n      if (s < 3) s = 0;\r\n\r\n      // Newton-Raphson iteration.\r\n      for (; ;) {\r\n        t = r;\r\n        r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n        if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n          // The exponent of r may here be one less than the final result exponent,\r\n          // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n          // are indexed correctly.\r\n          if (r.e < e) --s;\r\n          n = n.slice(s - 3, s + 1);\r\n\r\n          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n          // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n          // iteration.\r\n          if (n == '9999' || !rep && n == '4999') {\r\n\r\n            // On the first iteration only, check to see if rounding up gives the\r\n            // exact result as the nines may infinitely repeat.\r\n            if (!rep) {\r\n              round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n              if (t.times(t).eq(x)) {\r\n                r = t;\r\n                break;\r\n              }\r\n            }\r\n\r\n            dp += 4;\r\n            s += 4;\r\n            rep = 1;\r\n          } else {\r\n\r\n            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n            // result. If not, then there are further digits and m will be truthy.\r\n            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n              // Truncate to the first rounding digit.\r\n              round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n              m = !r.times(r).eq(x);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp++;\r\n    }\r\n    return format(this, dp, rm, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    if (dp != null) {\r\n      intCheck(dp, 0, MAX);\r\n      dp = dp + this.e + 1;\r\n    }\r\n    return format(this, dp, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */\r\n  P.toFormat = function (dp, rm, format) {\r\n    var str,\r\n      x = this;\r\n\r\n    if (format == null) {\r\n      if (dp != null && rm && typeof rm == 'object') {\r\n        format = rm;\r\n        rm = null;\r\n      } else if (dp && typeof dp == 'object') {\r\n        format = dp;\r\n        dp = rm = null;\r\n      } else {\r\n        format = FORMAT;\r\n      }\r\n    } else if (typeof format != 'object') {\r\n      throw Error\r\n        (bignumberError + 'Argument not an object: ' + format);\r\n    }\r\n\r\n    str = x.toFixed(dp, rm);\r\n\r\n    if (x.c) {\r\n      var i,\r\n        arr = str.split('.'),\r\n        g1 = +format.groupSize,\r\n        g2 = +format.secondaryGroupSize,\r\n        groupSeparator = format.groupSeparator || '',\r\n        intPart = arr[0],\r\n        fractionPart = arr[1],\r\n        isNeg = x.s < 0,\r\n        intDigits = isNeg ? intPart.slice(1) : intPart,\r\n        len = intDigits.length;\r\n\r\n      if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n      if (g1 > 0 && len > 0) {\r\n        i = len % g1 || g1;\r\n        intPart = intDigits.substr(0, i);\r\n        for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n        if (isNeg) intPart = '-' + intPart;\r\n      }\r\n\r\n      str = fractionPart\r\n       ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n        ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n         '$&' + (format.fractionGroupSeparator || ''))\r\n        : fractionPart)\r\n       : intPart;\r\n    }\r\n\r\n    return (format.prefix || '') + str + (format.suffix || '');\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */\r\n  P.toFraction = function (md) {\r\n    var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n      x = this,\r\n      xc = x.c;\r\n\r\n    if (md != null) {\r\n      n = new BigNumber(md);\r\n\r\n      // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n        throw Error\r\n          (bignumberError + 'Argument ' +\r\n            (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n      }\r\n    }\r\n\r\n    if (!xc) return new BigNumber(x);\r\n\r\n    d = new BigNumber(ONE);\r\n    n1 = d0 = new BigNumber(ONE);\r\n    d1 = n0 = new BigNumber(ONE);\r\n    s = coeffToString(xc);\r\n\r\n    // Determine initial denominator.\r\n    // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n    e = d.e = s.length - x.e - 1;\r\n    d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n    md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n    exp = MAX_EXP;\r\n    MAX_EXP = 1 / 0;\r\n    n = new BigNumber(s);\r\n\r\n    // n0 = d1 = 0\r\n    n0.c[0] = 0;\r\n\r\n    for (; ;)  {\r\n      q = div(n, d, 0, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.comparedTo(md) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      n1 = n0.plus(q.times(d2 = n1));\r\n      n0 = d2;\r\n      d = n.minus(q.times(d2 = d));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = div(md.minus(d0), d1, 0, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n    e = e * 2;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n    MAX_EXP = exp;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */\r\n  P.toNumber = function () {\r\n    return +valueOf(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    if (sd != null) intCheck(sd, 1, MAX);\r\n    return format(this, sd, rm, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */\r\n  P.toString = function (b) {\r\n    var str,\r\n      n = this,\r\n      s = n.s,\r\n      e = n.e;\r\n\r\n    // Infinity or NaN?\r\n    if (e === null) {\r\n      if (s) {\r\n        str = 'Infinity';\r\n        if (s < 0) str = '-' + str;\r\n      } else {\r\n        str = 'NaN';\r\n      }\r\n    } else {\r\n      if (b == null) {\r\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n         ? toExponential(coeffToString(n.c), e)\r\n         : toFixedPoint(coeffToString(n.c), e, '0');\r\n      } else if (b === 10 && alphabetHasNormalDecimalDigits) {\r\n        n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n        str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n      } else {\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n        str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n      }\r\n\r\n      if (s < 0 && n.c[0]) str = '-' + str;\r\n    }\r\n\r\n    return str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    return valueOf(this);\r\n  };\r\n\r\n\r\n  P._isBigNumber = true;\r\n\r\n  P[Symbol.toStringTag] = 'BigNumber';\r\n\r\n  // Node.js v10.12.0+\r\n  P[Symbol.for('nodejs.util.inspect.custom')] = P.valueOf;\r\n\r\n  if (configObject != null) BigNumber.set(configObject);\r\n\r\n  return BigNumber;\r\n}\r\n\r\n\r\n// PRIVATE HELPER FUNCTIONS\r\n\r\n// These functions don't need access to variables,\r\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\nfunction bitFloor(n) {\r\n  var i = n | 0;\r\n  return n > 0 || n === i ? i : i - 1;\r\n}\r\n\r\n\r\n// Return a coefficient array as a string of base 10 digits.\r\nfunction coeffToString(a) {\r\n  var s, z,\r\n    i = 1,\r\n    j = a.length,\r\n    r = a[0] + '';\r\n\r\n  for (; i < j;) {\r\n    s = a[i++] + '';\r\n    z = LOG_BASE - s.length;\r\n    for (; z--; s = '0' + s);\r\n    r += s;\r\n  }\r\n\r\n  // Determine trailing zeros.\r\n  for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n  return r.slice(0, j + 1 || 1);\r\n}\r\n\r\n\r\n// Compare the value of BigNumbers x and y.\r\nfunction compare(x, y) {\r\n  var a, b,\r\n    xc = x.c,\r\n    yc = y.c,\r\n    i = x.s,\r\n    j = y.s,\r\n    k = x.e,\r\n    l = y.e;\r\n\r\n  // Either NaN?\r\n  if (!i || !j) return null;\r\n\r\n  a = xc && !xc[0];\r\n  b = yc && !yc[0];\r\n\r\n  // Either zero?\r\n  if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n  // Signs differ?\r\n  if (i != j) return i;\r\n\r\n  a = i < 0;\r\n  b = k == l;\r\n\r\n  // Either Infinity?\r\n  if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n  // Compare exponents.\r\n  if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n  j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n  // Compare digit by digit.\r\n  for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n  // Compare lengths.\r\n  return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n}\r\n\r\n\r\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */\r\nfunction intCheck(n, min, max, name) {\r\n  if (n < min || n > max || n !== mathfloor(n)) {\r\n    throw Error\r\n     (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n       ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n       : ' not a primitive number: ') + String(n));\r\n  }\r\n}\r\n\r\n\r\n// Assumes finite n.\r\nfunction isOdd(n) {\r\n  var k = n.c.length - 1;\r\n  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n}\r\n\r\n\r\nfunction toExponential(str, e) {\r\n  return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n   (e < 0 ? 'e' : 'e+') + e;\r\n}\r\n\r\n\r\nfunction toFixedPoint(str, e, z) {\r\n  var len, zs;\r\n\r\n  // Negative exponent?\r\n  if (e < 0) {\r\n\r\n    // Prepend zeros.\r\n    for (zs = z + '.'; ++e; zs += z);\r\n    str = zs + str;\r\n\r\n  // Positive exponent\r\n  } else {\r\n    len = str.length;\r\n\r\n    // Append zeros.\r\n    if (++e > len) {\r\n      for (zs = z, e -= len; --e; zs += z);\r\n      str += zs;\r\n    } else if (e < len) {\r\n      str = str.slice(0, e) + '.' + str.slice(e);\r\n    }\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\n\r\n// EXPORT\r\n\r\n\r\nvar bignumber_BigNumber = clone();\r\n\r\n/* harmony default export */ const bignumber = (bignumber_BigNumber);\r\n\n;// CONCATENATED MODULE: ./src/util/Helper.ts\n\r\nconst showContainer = function (id) {\r\n    let containers = document.querySelectorAll('.container');\r\n    for (let i = 0; i < containers.length; i++) {\r\n        let element = containers[i];\r\n        if (element.id == id) {\r\n            element.classList.remove('d-none');\r\n            element.style.display = 'block';\r\n        }\r\n        else {\r\n            element.style.display = 'none';\r\n        }\r\n    }\r\n};\r\nconst roundNumber = function (number) {\r\n    return Math.round(number * 100) / 100;\r\n};\r\nconst roundNumberDecimal = function (number, decimal) {\r\n    let hundred = parseInt('1' + '0'.repeat(decimal));\r\n    return Math.round(number * hundred) / hundred;\r\n};\r\nconst roundBigNumber = function (number) {\r\n    return new bignumber(Math.round(number.toNumber() * 100) / 100);\r\n};\r\nconst roundBigNumberDecimal = function (number, decimal) {\r\n    let hundred = parseInt('1' + '0'.repeat(decimal));\r\n    return new bignumber(Math.round(number.toNumber() * hundred) / hundred);\r\n};\r\nconst Helper_AddressZero = \"0x0000000000000000000000000000000000000000\";\r\nconst isJSON = function (str) {\r\n    try {\r\n        JSON.parse(str);\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n};\r\nconst ethereumInstalled = function () {\r\n    try {\r\n        return (typeof ethereum !== 'undefined');\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n};\r\nconst shortEth = function (ethAddress) {\r\n    if (!ethAddress)\r\n        return '';\r\n    return ethAddress.substring(0, 6) + \"...\" + ethAddress.substring(ethAddress.length - 4);\r\n};\r\nconst upperFirstLetter = function (text) {\r\n    return text[0].toUpperCase() + text.substring(1);\r\n};\r\nconst showBar = function (text) {\r\n    let header = document.querySelector('header');\r\n    if (!header)\r\n        return;\r\n    let warningHtml = '<div class=\"errorBar\">' + text + '</div>';\r\n    header.insertAdjacentHTML('beforebegin', warningHtml);\r\n};\r\n\n;// CONCATENATED MODULE: ./src/html/elements/AddToWallet.html\n// Module\nvar AddToWallet_code = \"<article>\\r\\n    Some wallets detect automatically the coins that are registered to your address.\\r\\n    Those that don't do automatic detection, you need to add them manually.\\r\\n    <br/><br/>\\r\\n    This is the address for the symbol {{symbol}},\\r\\n    you need to copy it and import the token in your wallet\\r\\n    <br/><br/>\\r\\n    Contract address:<br/>\\r\\n    <input value=\\\"{{address}}\\\"/>\\r\\n    Symbol:<br/>\\r\\n    <input value=\\\"{{symbol}}\\\"/>\\r\\n    Decimal:<br/>\\r\\n    <input value=\\\"18\\\"/>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const AddToWallet = (AddToWallet_code);\n;// CONCATENATED MODULE: ./src/ui/elements/SecuritiesList.ts\nvar SecuritiesList_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SecuritiesList {\r\n    constructor(moralis) {\r\n        this.tbodyId = 'liminal_market_securities_list';\r\n        this.onSelectSymbol = undefined;\r\n        this.moralis = moralis;\r\n        this.page = 0;\r\n        this.loadmore = true;\r\n    }\r\n    render() {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            let securitiesCount = securitiesService.securitiesArray.length;\r\n            let securities = yield securitiesService.getPaginatingSecurities(this.page++);\r\n            Handlebars.registerPartial(\"securities\", Securities);\r\n            let template = Handlebars.compile(elements_SecuritiesList);\r\n            let obj = {\r\n                tbodyId: this.tbodyId,\r\n                securities: securities,\r\n                securitiesCount: securitiesCount\r\n            };\r\n            return template(obj);\r\n        });\r\n    }\r\n    bindEvents(onSelectSymbol) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            this.bindOnClickEvent(onSelectSymbol);\r\n            yield this.bindSearchEvent();\r\n            this.bindLoadMore();\r\n        });\r\n    }\r\n    bindOnClickEvent(onSelectSymbol) {\r\n        let table = document.getElementById('liminal_market_securities_table');\r\n        if (!table) {\r\n            ErrorInfo.report(new GeneralError(\"Page could not load correctly, try reloading\"));\r\n            return;\r\n        }\r\n        this.onSelectSymbol = onSelectSymbol;\r\n        table.onclick = (evt) => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            yield this.handleClick(evt);\r\n        });\r\n    }\r\n    handleClick(evt) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let element = evt.target;\r\n            if (element.tagName.toLocaleLowerCase() === 'a') {\r\n                yield this.addToWalletOrGetAddress(evt, element);\r\n                return;\r\n            }\r\n            let parentTr = element.parentElement;\r\n            if (!parentTr)\r\n                return;\r\n            if (parentTr.tagName.toLocaleLowerCase() !== 'tr') {\r\n                parentTr = parentTr.parentElement;\r\n            }\r\n            let symbol = parentTr.dataset.symbol;\r\n            if (!symbol)\r\n                return;\r\n            let name = parentTr.dataset.name;\r\n            let logo = parentTr.dataset.logo;\r\n            if (this.onSelectSymbol) {\r\n                this.onSelectSymbol(symbol, name, logo);\r\n            }\r\n        });\r\n    }\r\n    bindSearchEvent() {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let searchForSymbol = document.getElementById('search_for_symbol');\r\n            if (!searchForSymbol)\r\n                return;\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            let timeout = null;\r\n            searchForSymbol.addEventListener('keyup', (evt) => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n                if (timeout != null)\r\n                    clearTimeout(timeout);\r\n                timeout = setTimeout(() => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n                    let search = evt.target.value;\r\n                    if (!search || search.length < 2) {\r\n                        this.loadmore = true;\r\n                        yield this.showTopSecurities(securitiesService);\r\n                        return;\r\n                    }\r\n                    this.loadmore = false;\r\n                    let securities = yield securitiesService.find(search);\r\n                    this.loadSecuritiesToDom(securities);\r\n                }), 500);\r\n            }));\r\n        });\r\n    }\r\n    showTopSecurities(securitiesService) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let securities = yield securitiesService.getTopSecurities();\r\n            this.loadSecuritiesToDom(securities);\r\n        });\r\n    }\r\n    loadSecuritiesToDom(securities) {\r\n        let tbody = document.getElementById(this.tbodyId);\r\n        if (!tbody)\r\n            return;\r\n        let template = Handlebars.compile(Securities);\r\n        let obj = {\r\n            securities: securities\r\n        };\r\n        let content = template(obj);\r\n        tbody.innerHTML = content;\r\n    }\r\n    bindLoadMore() {\r\n        const el = document.querySelector('#liminal_market_load_more');\r\n        const observer = new window.IntersectionObserver(([entry]) => SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (entry.isIntersecting) {\r\n                yield this.loadMore();\r\n            }\r\n        }), {\r\n            root: null,\r\n            threshold: 0.1, // set offset 0.1 means trigger if atleast 10% of element in viewport\r\n        });\r\n        observer.observe(el);\r\n    }\r\n    loadMore() {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.loadmore)\r\n                return;\r\n            let tbody = document.getElementById(this.tbodyId);\r\n            if (!tbody)\r\n                return;\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            let securities = yield securitiesService.getPaginatingSecurities(this.page++);\r\n            let template = Handlebars.compile(Securities);\r\n            let obj = {\r\n                securities: securities\r\n            };\r\n            let content = template(obj);\r\n            tbody.insertAdjacentHTML('beforeend', content);\r\n        });\r\n    }\r\n    addToWalletOrGetAddress(event, element) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            let className = element.className;\r\n            if (className != 'getAddress' && className != 'addToWallet') {\r\n                return;\r\n            }\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n            let symbol = element.dataset.symbol;\r\n            if (!symbol)\r\n                return;\r\n            LoadingHelper.setLoading(element);\r\n            let liminalMarketService = new LiminalMarketService(this.moralis);\r\n            let address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n            if (className == 'getAddress') {\r\n                yield this.showGetAddress(element, symbol, address);\r\n            }\r\n            else {\r\n                yield this.showAddToWallet(element, symbol, address);\r\n            }\r\n            LoadingHelper.removeLoading();\r\n        });\r\n    }\r\n    showGetAddress(element, symbol, address) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (address !== Helper_AddressZero) {\r\n                let copyHelper = new CopyHelper();\r\n                let success = yield copyHelper.copyTextToClipboard(address);\r\n                if (success) {\r\n                    element.innerText = 'Copied';\r\n                    return;\r\n                }\r\n            }\r\n            this.renderContractInfoToString(element, address, symbol, AddressInfo);\r\n        });\r\n    }\r\n    showAddToWallet(element, symbol, address) {\r\n        return SecuritiesList_awaiter(this, void 0, void 0, function* () {\r\n            if (address !== Helper_AddressZero) {\r\n                let walletHelper = new WalletHelper(this.moralis);\r\n                let added = yield walletHelper.addTokenToWallet(address, symbol, () => {\r\n                    LoadingHelper.removeLoading();\r\n                    this.renderContractInfoToString(element, address, symbol, AddToWallet);\r\n                });\r\n                if (added) {\r\n                    return '';\r\n                }\r\n            }\r\n            this.renderContractInfoToString(element, address, symbol, AddToWallet);\r\n        });\r\n    }\r\n    renderContractInfoToString(element, address, symbol, template) {\r\n        let symbolInfoToCopy = document.getElementById('symbolInfoToCopy');\r\n        if (symbolInfoToCopy)\r\n            symbolInfoToCopy.remove();\r\n        let content = '';\r\n        if (address === Helper_AddressZero) {\r\n            let template = Handlebars.compile(ContractAddressNotFound);\r\n            content = template(null);\r\n        }\r\n        else {\r\n            let template = Handlebars.compile(AddressInfo);\r\n            let obj = {\r\n                symbol: symbol,\r\n                address: address\r\n            };\r\n            content = template(obj);\r\n        }\r\n        element.parentElement.parentElement.parentElement.insertAdjacentHTML('afterend', content);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/UserInfo.html\n// Module\nvar UserInfo_code = \"<div id=\\\"userMenuPanel\\\">\\r\\n    <a href=\\\"#\\\" id=\\\"userInfoAction\\\" aria-expanded=\\\"false\\\">\\r\\n        <img src=\\\"https://effigy.im/a/{{ethAddress}}.png\\\" width=\\\"24\\\">\\r\\n        <span id=\\\"user_info_ethAddress\\\">{{shortEthAddress}}</span>\\r\\n    </a>\\r\\n\\r\\n    <div id=\\\"userInfoDropdown\\\" class=\\\"d-none\\\">\\r\\n        <div class=\\\"grid account_info\\\">\\r\\n            <h6>Account</h6>\\r\\n            <a id=\\\"disconnectFromNetwork\\\" href=\\\"#\\\">Disconnect</a>\\r\\n\\r\\n        </div>\\r\\n        <div class=\\\"edit_account\\\">\\r\\n            <a id=\\\"editName\\\" href=\\\"#\\\">Edit name</a><br/>\\r\\n            <a id=\\\"editContact\\\" href=\\\"#\\\">Edit contact info</a><br/>\\r\\n            <a id=\\\"editTrustedContact\\\" href=\\\"#\\\">Edit trusted contact</a>\\r\\n        </div>\\r\\n        <hr/>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <img src=\\\"https://effigy.im/a/{{ethAddress}}.png\\\">\\r\\n            </div>\\r\\n            <div>\\r\\n                <strong class=\\\"d-block\\\"><a href=\\\"{{blockchainExplorer}}{{ethAddress}}\\\" target=\\\"_blank\\\">{{shortEthAddress}}</a></strong>\\r\\n                <br/>\\r\\n                {{#if isMagic}}\\r\\n                <a href=\\\"#\\\" id=\\\"wallet\\\">Open my wallet</a>\\r\\n                {{/if}}\\r\\n                <a href=\\\"https://info.liminal.market/#/chain/{{chainId}}/{{ethAddress}}\\\" target=\\\"_blank\\\">View\\r\\n                    positions</a>\\r\\n            </div>\\r\\n        </div>\\r\\n        <hr/>\\r\\n        <div class=\\\"hidden\\\" id=\\\"userInfoAUsdBalance\\\">\\r\\n            <div class=\\\"grid\\\">\\r\\n                <div><img src=\\\"https://app.liminal.market/img/ausd.png\\\"></div>\\r\\n                <div>\\r\\n                    <strong class=\\\"d-block\\\">aUSD <span id=\\\"user_info_ausd_balance\\\"></span></strong>\\r\\n                    <a href=\\\"\\\" class=\\\"add_aUSD_to_wallet\\\">Add aUSD to wallet</a>\\r\\n                </div>\\r\\n            </div>\\r\\n            <div id=\\\"fund_account_options\\\">\\r\\n                <h6>Fund your account</h6>\\r\\n                <div class=\\\"grid\\\">\\r\\n                    <a href=\\\"#\\\" class=\\\"fund_account\\\">Fund my account</a>\\r\\n                    <a href=\\\"#\\\" id=\\\"withdraw_from_account\\\">Withdraw from account</a>\\r\\n                </div>\\r\\n            </div>\\r\\n            <hr/>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <strong class=\\\"d-block\\\">Network</strong>\\r\\n            <small>{{networkName}}<br/>\\r\\n                <a href=\\\"#\\\" id=\\\"switch_network\\\">Change network</a>\\r\\n            </small>\\r\\n        </div>\\r\\n\\r\\n    </div>\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const elements_UserInfo = (UserInfo_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycEditName.html\n// Module\nvar KycEditName_code = \"<fieldset id=\\\"kycEditName\\\">\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        <strong>Warning</strong><br/>\\r\\n        You can only change the name once. Be careful of what you change.\\r\\n        <br/><br/>\\r\\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\\r\\n        trades\\r\\n        until it has been approved.\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"given_name\\\">Legal First name</label>\\r\\n        <input required id=\\\"given_name\\\" name=\\\"given_name\\\"\\r\\n               placeholder=\\\"Ron\\\"\\r\\n               value=\\\"{{given_name}}\\\" autocomplete=\\\"given-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"middle_name\\\">Legal Middle name</label>\\r\\n        <input id=\\\"middle_name\\\" name=\\\"middle_name\\\"\\r\\n               placeholder=\\\"\\\"\\r\\n               value=\\\"{{middle_name}}\\\" autocomplete=\\\"additional-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"family_name\\\">Legal Last name</label>\\r\\n        <input required id=\\\"family_name\\\" name=\\\"family_name\\\"\\r\\n               placeholder=\\\"Swanson\\\"\\r\\n               value=\\\"{{family_name}}\\\" autocomplete=\\\"family-name\\\">\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"buttons\\\">\\r\\n        <button id=\\\"kycEditNameConfirm\\\">Confirm</button>\\r\\n    </div>\\r\\n</fieldset>\\r\\n\\r\\n<fieldset class=\\\"hidden\\\" id=\\\"confirmNameFieldset\\\">\\r\\n    <div class=\\\"confirm_name\\\">\\r\\n        <label for=\\\"confirm_name\\\" id=\\\"label_confirm_name\\\">Please type</label>\\r\\n        <input name=\\\"confirm_name\\\" id=\\\"confirm_name\\\"/>\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"input_error\\\" id=\\\"kycEditNameError\\\"></div>\\r\\n\\r\\n    <div class=\\\"buttons grid\\\">\\r\\n        <button id=\\\"kycEditNameBack\\\">Back</button>\\r\\n        <button type=\\\"submit\\\" id=\\\"kycEditNameSave\\\">Confirm</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const KycEditName = (KycEditName_code);\n;// CONCATENATED MODULE: ./src/util/StringHelper.ts\nclass StringHelper {\r\n    static isNullOrEmpty(str) {\r\n        return !str || str.toString().trim().length == 0;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycEditNameForm.ts\nvar KycEditNameForm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass KycEditNameForm {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        return KycEditNameForm_awaiter(this, void 0, void 0, function* () {\r\n            let kycEditNameError = document.getElementById('kycEditNameError');\r\n            if (kycEditNameError)\r\n                kycEditNameError.style.display = 'none';\r\n            let userService = new UserService(Moralis);\r\n            let account = yield userService.getAccount();\r\n            let given_name = account.identity.given_name;\r\n            let middle_name = account.identity.middle_name;\r\n            let family_name = account.identity.family_name;\r\n            let template = Handlebars.compile(KycEditName);\r\n            let content = template({ given_name: given_name, middle_name: middle_name, family_name: family_name });\r\n            this.modal.showModal('Edit name', content);\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let kycEditNameConfirm = document.getElementById('kycEditNameConfirm');\r\n        kycEditNameConfirm === null || kycEditNameConfirm === void 0 ? void 0 : kycEditNameConfirm.addEventListener('click', (evt) => KycEditNameForm_awaiter(this, void 0, void 0, function* () {\r\n            var _a, _b;\r\n            let given_name = document.getElementById('given_name');\r\n            let middle_name = document.getElementById('middle_name');\r\n            let family_name = document.getElementById('family_name');\r\n            if (StringHelper.isNullOrEmpty(given_name.value)) {\r\n                this.showError('Given name cannot be empty');\r\n                return;\r\n            }\r\n            if (StringHelper.isNullOrEmpty(family_name.value)) {\r\n                this.showError('Family name cannot be empty');\r\n                return;\r\n            }\r\n            let full_name = this.getFullName();\r\n            let label_confirm_name = document.getElementById('label_confirm_name');\r\n            if (!label_confirm_name) {\r\n                //TODO: report error in form\r\n                return;\r\n            }\r\n            label_confirm_name.innerHTML = 'Please type in the full name \"' + full_name + '\" in the box below to confirm. You WILL NOT be able to change it again.';\r\n            (_a = document.getElementById('confirmNameFieldset')) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n            (_b = document.getElementById('kycEditName')) === null || _b === void 0 ? void 0 : _b.classList.add('hidden');\r\n        }));\r\n        let kycEditNameBack = document.getElementById('kycEditNameBack');\r\n        kycEditNameBack === null || kycEditNameBack === void 0 ? void 0 : kycEditNameBack.addEventListener('click', (evt) => {\r\n            var _a, _b;\r\n            (_a = document.getElementById('confirmNameFieldset')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n            (_b = document.getElementById('kycEditName')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');\r\n        });\r\n        let confirm_name = document.getElementById('confirm_name');\r\n        if (!confirm_name) {\r\n            //TODO: report error in form\r\n            return;\r\n        }\r\n        let kycEditNameSave = document.getElementById('kycEditNameSave');\r\n        kycEditNameSave.disabled = true;\r\n        confirm_name.setAttribute('aria-invalid', 'true');\r\n        confirm_name.addEventListener('keyup', (evt) => {\r\n            if (confirm_name.value == this.getFullName()) {\r\n                confirm_name.setAttribute('aria-invalid', 'false');\r\n                kycEditNameSave.disabled = false;\r\n            }\r\n            else {\r\n                confirm_name.setAttribute('aria-invalid', 'true');\r\n                kycEditNameSave.disabled = true;\r\n            }\r\n        });\r\n        kycEditNameSave === null || kycEditNameSave === void 0 ? void 0 : kycEditNameSave.addEventListener('click', (evt) => KycEditNameForm_awaiter(this, void 0, void 0, function* () {\r\n            let confirm_name = document.getElementById('confirm_name');\r\n            if (confirm_name && confirm_name.value != this.getFullName()) {\r\n                alert(confirm_name.value + ' is not same as ' + this.getFullName() + '. Go over the name and make sure it is identical');\r\n                return;\r\n            }\r\n            let given_name = document.getElementById('given_name');\r\n            let middle_name = document.getElementById('middle_name');\r\n            let family_name = document.getElementById('family_name');\r\n            LoadingHelper.setLoading(kycEditNameSave);\r\n            let userService = new UserService(Moralis);\r\n            yield userService.updateName(given_name.value, middle_name.value, family_name.value)\r\n                .then((response) => {\r\n                if (response.message) {\r\n                    this.showError(response.message);\r\n                    return;\r\n                }\r\n                this.modal.hideModal();\r\n            }).catch(reason => {\r\n                if (reason.message) {\r\n                    this.showError(JSON.parse(reason.message).message);\r\n                }\r\n                else {\r\n                    this.showError(reason);\r\n                }\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n    showError(message) {\r\n        let kycEditNameError = document.getElementById('kycEditNameError');\r\n        if (!kycEditNameError)\r\n            return;\r\n        kycEditNameError.innerHTML = message;\r\n        kycEditNameError.style.display = 'block';\r\n    }\r\n    getFullName() {\r\n        let given_name = document.getElementById('given_name');\r\n        let middle_name = document.getElementById('middle_name');\r\n        let family_name = document.getElementById('family_name');\r\n        return given_name.value + ' ' + (!StringHelper.isNullOrEmpty(middle_name.value) ? middle_name.value + ' ' : '') + family_name.value;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycEditContactForm.html\n// Module\nvar KycEditContactForm_code = \"<fieldset id=\\\"kycEditContactFieldset\\\">\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        <strong>Warning</strong><br/>\\r\\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\\r\\n        trades until it has been approved.\\r\\n    </div>\\r\\n    <form id=\\\"kycEditContactForm\\\">\\r\\n        <div>\\r\\n            <label for=\\\"email_address\\\">Email</label>\\r\\n            <input type=\\\"email\\\" required class=\\\"form-control\\\" id=\\\"email_address\\\" name=\\\"email_address\\\"\\r\\n                   placeholder=\\\"name@example.com\\\" autocomplete=\\\"email\\\"\\r\\n                   value=\\\"\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"phone_number\\\">Phone</label>\\r\\n            <input type=\\\"tel\\\" class=\\\"form-control\\\" id=\\\"phone_number\\\" name=\\\"phone_number\\\"\\r\\n                   placeholder=\\\"+1-555-666-7788\\\" autocomplete=\\\"tel\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"street_address\\\">Permanent Residential Address</label>\\r\\n            <div class=\\\"explain\\\">It must be a physical address, not a PO box.</div>\\r\\n            <input required id=\\\"street_address\\\" name=\\\"street_address\\\"\\r\\n                   placeholder=\\\"20 N San Mateo Dr\\\" value=\\\"\\\" autocomplete=\\\"address-line1\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"unit\\\">Unit / Apt #</label>\\r\\n            <input id=\\\"unit\\\" name=\\\"unit\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"city\\\">City</label>\\r\\n            <input id=\\\"city\\\" name=\\\"city\\\" placeholder=\\\"Pawnee\\\"\\r\\n                   value=\\\"\\\" autocomplete=\\\"address-level2\\\">\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"postal_code\\\">Postal code</label>\\r\\n            <input required id=\\\"postal_code\\\" autocomplete=\\\"postal-code\\\" name=\\\"postal_code\\\"\\r\\n                   placeholder=\\\"94401\\\"\\r\\n                   value=\\\"\\\">\\r\\n        </div>\\r\\n        {{#if usa}}\\r\\n        <div id=\\\"state_div\\\">\\r\\n            <label for=\\\"state\\\">State (2 letters)</label>\\r\\n            <input required maxlength=\\\"2\\\" id=\\\"state\\\" name=\\\"state\\\" placeholder=\\\"NY\\\"\\r\\n                   value=\\\"\\\" autocomplete=\\\"address-level1\\\">\\r\\n        </div>\\r\\n        {{/if}}\\r\\n        <div class=\\\"input_error\\\" id=\\\"kycEditContactError\\\"></div>\\r\\n        <div class=\\\"buttons\\\">\\r\\n            <button type=\\\"submit\\\" id=\\\"kycEditContactSave\\\">Save</button>\\r\\n        </div>\\r\\n    </form>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycEditContactForm = (KycEditContactForm_code);\n;// CONCATENATED MODULE: ./src/util/FormHelper.ts\n\r\nclass FormHelper {\r\n    static getParams(selector) {\r\n        let form = document.querySelector(selector);\r\n        if (!form)\r\n            return;\r\n        let data = new FormData(form);\r\n        return this.serialize(data);\r\n    }\r\n    static serialize(data) {\r\n        let obj = {};\r\n        for (let [key, value] of data) {\r\n            if (obj[key] !== undefined) {\r\n                if (!Array.isArray(obj[key])) {\r\n                    obj[key] = [obj[key]];\r\n                }\r\n                obj[key].push(value);\r\n            }\r\n            else {\r\n                obj[key] = value;\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    static fillInputs(properties, item) {\r\n        properties.forEach((value) => {\r\n            let input = document.querySelector('input[name=' + value + ']');\r\n            if (input) {\r\n                if (input.type == 'radio') {\r\n                    console.log('checkbox', input, item[value]);\r\n                    input.value = item[value];\r\n                }\r\n                else {\r\n                    input.value = item[value];\r\n                }\r\n                input.dispatchEvent(new Event('change'));\r\n            }\r\n            else {\r\n                let select = document.querySelector('select[name=' + value + ']');\r\n                if (select) {\r\n                    select.value = item[value];\r\n                    select.dispatchEvent(new Event('change'));\r\n                }\r\n            }\r\n        });\r\n    }\r\n    static validate(selector) {\r\n        let inputs = document.querySelectorAll(selector + ' input[required], ' + selector + ' select[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            input.setAttribute('aria-invalid', 'false');\r\n            if (StringHelper.isNullOrEmpty(input.value)) {\r\n                input.setAttribute('aria-invalid', 'true');\r\n                input.focus();\r\n                input.addEventListener('change', (evt) => {\r\n                    if (!StringHelper.isNullOrEmpty(input.value)) {\r\n                        input.setAttribute('aria-invalid', 'false');\r\n                    }\r\n                });\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycEditContactForm.ts\nvar KycEditContactForm_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycEditContactForm {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        return KycEditContactForm_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(this.moralis);\r\n            let account = yield userService.getAccount();\r\n            let usa = account.identity.country_of_tax_residence == 'USA';\r\n            let template = Handlebars.compile(Kyc_KycEditContactForm);\r\n            this.modal.showModal('Edit contact information', template({ usa: usa }));\r\n            let contactProperties = Object.getOwnPropertyNames(account.contact);\r\n            FormHelper.fillInputs(contactProperties, account.contact);\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let kycEditContactSave = document.getElementById('kycEditContactSave');\r\n        kycEditContactSave === null || kycEditContactSave === void 0 ? void 0 : kycEditContactSave.addEventListener('click', (evt) => KycEditContactForm_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.validate())\r\n                return;\r\n            LoadingHelper.setLoading(kycEditContactSave);\r\n            let data = FormHelper.getParams('#kycEditContactForm');\r\n            let userService = new UserService(Moralis);\r\n            yield userService.updateContact(data).then((response) => {\r\n                if (response.message) {\r\n                    this.showError(response.message);\r\n                    return;\r\n                }\r\n                let accountInfo = response;\r\n                let email_address = document.getElementById('email_address');\r\n                if (accountInfo.contact.email_address != (email_address === null || email_address === void 0 ? void 0 : email_address.value)) {\r\n                    this.showError('Email was not changed. The email ' + (email_address === null || email_address === void 0 ? void 0 : email_address.value) + ' is already registered under different account.');\r\n                    return;\r\n                }\r\n                this.modal.hideModal();\r\n            }).catch(reason => {\r\n                if (reason.message) {\r\n                    this.showError(JSON.parse(reason.message).message);\r\n                }\r\n                else {\r\n                    this.showError(reason);\r\n                }\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n    showError(message) {\r\n        let kycEditNameError = document.getElementById('kycEditContactError');\r\n        if (!kycEditNameError)\r\n            return;\r\n        kycEditNameError.innerHTML = message;\r\n        kycEditNameError.style.display = 'block';\r\n    }\r\n    validate() {\r\n        let inputs = document.querySelectorAll('#kycEditContactFieldset input[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (StringHelper.isNullOrEmpty(input.value)) {\r\n                input.setAttribute('aria-invalid', 'true');\r\n                input.addEventListener('change', (evt) => {\r\n                    if (!StringHelper.isNullOrEmpty(input.value)) {\r\n                        input.setAttribute('aria-invalid', 'false');\r\n                    }\r\n                });\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycEditTrustedContact.html\n// Module\nvar KycEditTrustedContact_code = \"<fieldset class=\\\"kycTrustedContact\\\">\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        <strong>Warning</strong><br/>\\r\\n        After you change this information a new KYC process will be started, and you will NOT be able to do any\\r\\n        trades until it has been approved.\\r\\n    </div>\\r\\n\\r\\n    <form id=\\\"kycTrustedContactForm\\\" method=\\\"post\\\">\\r\\n        <div class=\\\"explain\\\">\\r\\n            A trusted contact is a person you authorize your financial firm to contact in limited circumstances,\\r\\n            such as if there is a concern about activity in your account and they have been unable to get in touch with\\r\\n            you.\\r\\n            <br/><br/>\\r\\n            A trusted contact may be a family member, attorney, accountant or another third-party who you believe would\\r\\n            respect your privacy and know how to handle the responsibility.\\r\\n            The trusted person should be 18 years old or older.\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"given_name\\\">Legal given name of trusted contact</label>\\r\\n            <input required id=\\\"given_name\\\" name=\\\"given_name\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"family_name\\\">Legal family name of trusted contact</label>\\r\\n            <input required id=\\\"family_name\\\" name=\\\"family_name\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            If you fill in name, you are required to fill in one of the following, email, phone or address\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"contact_missing_info\\\"></div>\\r\\n        <div>\\r\\n            <label for=\\\"email_address\\\">Email of trusted contact</label>\\r\\n            <input id=\\\"email_address\\\" type=\\\"email\\\" name=\\\"email_address\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"phone_number\\\">Phone of trusted contact</label>\\r\\n            <input id=\\\"phone_number\\\" type=\\\"tel\\\" name=\\\"phone_number\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"street_address\\\">Address of trusted contact</label>\\r\\n            <input id=\\\"street_address\\\" name=\\\"street_address\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"city\\\">City of trusted contact</label>\\r\\n            <input id=\\\"city\\\" name=\\\"city\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"state\\\">State of trusted contact</label>\\r\\n            <input id=\\\"state\\\" name=\\\"state\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"postal_code\\\">Postal code of trusted contact</label>\\r\\n            <input id=\\\"postal_code\\\" name=\\\"postal_code\\\"/>\\r\\n        </div>\\r\\n        <div>\\r\\n            <label for=\\\"country\\\">Country of trusted contact</label>\\r\\n            <select required id=\\\"country\\\" required name=\\\"country\\\">\\r\\n                <option value=\\\"\\\"></option>\\r\\n                {{#each countries}}\\r\\n                <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n                {{/each}}\\r\\n            </select>\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"kycEditNameError\\\"></div>\\r\\n        <div class=\\\"buttons\\\">\\r\\n            <button type=\\\"submit\\\" id=\\\"trustedContactSubmit\\\">Submit</button>\\r\\n        </div>\\r\\n    </form>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycEditTrustedContact = (KycEditTrustedContact_code);\n;// CONCATENATED MODULE: ./src/util/CountryHelper.ts\nclass CountryHelper {\r\n}\r\nCountryHelper.Countries = [\r\n    { \"name\": \"United States of America\", \"code\": \"USA\" },\r\n    { \"name\": \"United Kingdom\", \"code\": \"GBR\" },\r\n    { \"name\": \"Afghanistan\", \"code\": \"AFG\" }, { \"name\": \"Albania\", \"code\": \"ALB\" }, {\r\n        \"name\": \"Algeria\",\r\n        \"code\": \"DZA\"\r\n    }, { \"name\": \"American Samoa\", \"code\": \"ASM\" }, { \"name\": \"Andorra\", \"code\": \"AND\" }, {\r\n        \"name\": \"Angola\",\r\n        \"code\": \"AGO\"\r\n    }, { \"name\": \"Anguilla\", \"code\": \"AIA\" }, { \"name\": \"Antarctica\", \"code\": \"ATA\" }, {\r\n        \"name\": \"Antigua and Barbuda\",\r\n        \"code\": \"ATG\"\r\n    }, { \"name\": \"Argentina\", \"code\": \"ARG\" }, { \"name\": \"Armenia\", \"code\": \"ARM\" }, {\r\n        \"name\": \"Aruba\",\r\n        \"code\": \"ABW\"\r\n    }, { \"name\": \"Australia\", \"code\": \"AUS\" }, { \"name\": \"Austria\", \"code\": \"AUT\" }, {\r\n        \"name\": \"Azerbaijan\",\r\n        \"code\": \"AZE\"\r\n    }, { \"name\": \"land Islands\", \"code\": \"ALA\" }, { \"name\": \"Bahamas\", \"code\": \"BHS\" }, {\r\n        \"name\": \"Bahrain\",\r\n        \"code\": \"BHR\"\r\n    }, { \"name\": \"Bangladesh\", \"code\": \"BGD\" }, { \"name\": \"Barbados\", \"code\": \"BRB\" }, {\r\n        \"name\": \"Belarus\",\r\n        \"code\": \"BLR\"\r\n    }, { \"name\": \"Belgium\", \"code\": \"BEL\" }, { \"name\": \"Belize\", \"code\": \"BLZ\" }, {\r\n        \"name\": \"Benin\",\r\n        \"code\": \"BEN\"\r\n    }, { \"name\": \"Bermuda\", \"code\": \"BMU\" }, {\r\n        \"name\": \"Bhutan\",\r\n        \"code\": \"BTN\"\r\n    }, { \"name\": \"Bolivia (Plurinational State of)\", \"code\": \"BOL\" }, {\r\n        \"name\": \"Bonaire, Sint Eustatius and Saba\",\r\n        \"code\": \"BES\"\r\n    }, { \"name\": \"Bosnia and Herzegovina\", \"code\": \"BIH\" }, {\r\n        \"name\": \"Botswana\",\r\n        \"code\": \"BWA\"\r\n    }, { \"name\": \"Bouvet Island\", \"code\": \"BVT\" }, {\r\n        \"name\": \"Brazil\",\r\n        \"code\": \"BRA\"\r\n    }, { \"name\": \"British Indian Ocean Territory\", \"code\": \"IOT\" }, {\r\n        \"name\": \"Brunei Darussalam\",\r\n        \"code\": \"BRN\"\r\n    }, { \"name\": \"Bulgaria\", \"code\": \"BGR\" }, { \"name\": \"Burkina Faso\", \"code\": \"BFA\" }, {\r\n        \"name\": \"Burundi\",\r\n        \"code\": \"BDI\"\r\n    }, { \"name\": \"Cabo Verde\", \"code\": \"CPV\" }, { \"name\": \"Cambodia\", \"code\": \"KHM\" }, {\r\n        \"name\": \"Cameroon\",\r\n        \"code\": \"CMR\"\r\n    }, { \"name\": \"Canada\", \"code\": \"CAN\" }, {\r\n        \"name\": \"Cayman Islands\",\r\n        \"code\": \"CYM\"\r\n    }, { \"name\": \"Central African Republic\", \"code\": \"CAF\" }, { \"name\": \"Chad\", \"code\": \"TCD\" }, {\r\n        \"name\": \"Chile\",\r\n        \"code\": \"CHL\"\r\n    }, { \"name\": \"China\", \"code\": \"CHN\" }, {\r\n        \"name\": \"Christmas Island\",\r\n        \"code\": \"CXR\"\r\n    }, { \"name\": \"Cocos (Keeling) Islands\", \"code\": \"CCK\" }, { \"name\": \"Colombia\", \"code\": \"COL\" }, {\r\n        \"name\": \"Comoros\",\r\n        \"code\": \"COM\"\r\n    }, { \"name\": \"Congo (the Democratic Republic of the)\", \"code\": \"COD\" }, {\r\n        \"name\": \"Congo\",\r\n        \"code\": \"COG\"\r\n    }, { \"name\": \"Cook Islands\", \"code\": \"COK\" }, { \"name\": \"Costa Rica\", \"code\": \"CRI\" }, {\r\n        \"name\": \"Croatia\",\r\n        \"code\": \"HRV\"\r\n    }, { \"name\": \"Cuba\", \"code\": \"CUB\" }, { \"name\": \"Curaao\", \"code\": \"CUW\" }, {\r\n        \"name\": \"Cyprus\",\r\n        \"code\": \"CYP\"\r\n    }, { \"name\": \"Czechia\", \"code\": \"CZE\" }, { \"name\": \"Cte d'Ivoire\", \"code\": \"CIV\" }, {\r\n        \"name\": \"Denmark\",\r\n        \"code\": \"DNK\"\r\n    }, { \"name\": \"Djibouti\", \"code\": \"DJI\" }, { \"name\": \"Dominica\", \"code\": \"DMA\" }, {\r\n        \"name\": \"Dominican Republic\",\r\n        \"code\": \"DOM\"\r\n    }, { \"name\": \"Ecuador\", \"code\": \"ECU\" }, { \"name\": \"Egypt\", \"code\": \"EGY\" }, {\r\n        \"name\": \"El Salvador\",\r\n        \"code\": \"SLV\"\r\n    }, { \"name\": \"Equatorial Guinea\", \"code\": \"GNQ\" }, { \"name\": \"Eritrea\", \"code\": \"ERI\" }, {\r\n        \"name\": \"Estonia\",\r\n        \"code\": \"EST\"\r\n    }, { \"name\": \"Eswatini\", \"code\": \"SWZ\" }, {\r\n        \"name\": \"Ethiopia\",\r\n        \"code\": \"ETH\"\r\n    }, { \"name\": \"Falkland Islands [Malvinas]\", \"code\": \"FLK\" }, {\r\n        \"name\": \"Faroe Islands\",\r\n        \"code\": \"FRO\"\r\n    }, { \"name\": \"Fiji\", \"code\": \"FJI\" }, { \"name\": \"Finland\", \"code\": \"FIN\" }, {\r\n        \"name\": \"France\",\r\n        \"code\": \"FRA\"\r\n    }, { \"name\": \"French Guiana\", \"code\": \"GUF\" }, {\r\n        \"name\": \"French Polynesia\",\r\n        \"code\": \"PYF\"\r\n    }, { \"name\": \"French Southern Territories\", \"code\": \"ATF\" }, { \"name\": \"Gabon\", \"code\": \"GAB\" }, {\r\n        \"name\": \"Gambia\",\r\n        \"code\": \"GMB\"\r\n    }, { \"name\": \"Georgia\", \"code\": \"GEO\" }, { \"name\": \"Germany\", \"code\": \"DEU\" }, {\r\n        \"name\": \"Ghana\",\r\n        \"code\": \"GHA\"\r\n    }, { \"name\": \"Gibraltar\", \"code\": \"GIB\" }, { \"name\": \"Greece\", \"code\": \"GRC\" }, {\r\n        \"name\": \"Greenland\",\r\n        \"code\": \"GRL\"\r\n    }, { \"name\": \"Grenada\", \"code\": \"GRD\" }, { \"name\": \"Guadeloupe\", \"code\": \"GLP\" }, {\r\n        \"name\": \"Guam\",\r\n        \"code\": \"GUM\"\r\n    }, { \"name\": \"Guatemala\", \"code\": \"GTM\" }, { \"name\": \"Guernsey\", \"code\": \"GGY\" }, {\r\n        \"name\": \"Guinea\",\r\n        \"code\": \"GIN\"\r\n    }, { \"name\": \"Guinea-Bissau\", \"code\": \"GNB\" }, { \"name\": \"Guyana\", \"code\": \"GUY\" }, {\r\n        \"name\": \"Haiti\",\r\n        \"code\": \"HTI\"\r\n    }, { \"name\": \"Heard Island and McDonald Islands\", \"code\": \"HMD\" }, {\r\n        \"name\": \"Holy See\",\r\n        \"code\": \"VAT\"\r\n    }, { \"name\": \"Honduras\", \"code\": \"HND\" }, { \"name\": \"Hong Kong\", \"code\": \"HKG\" }, {\r\n        \"name\": \"Hungary\",\r\n        \"code\": \"HUN\"\r\n    }, { \"name\": \"Iceland\", \"code\": \"ISL\" }, { \"name\": \"India\", \"code\": \"IND\" }, {\r\n        \"name\": \"Indonesia\",\r\n        \"code\": \"IDN\"\r\n    }, { \"name\": \"Iran (Islamic Republic of)\", \"code\": \"IRN\" }, { \"name\": \"Iraq\", \"code\": \"IRQ\" }, {\r\n        \"name\": \"Ireland\",\r\n        \"code\": \"IRL\"\r\n    }, { \"name\": \"Isle of Man\", \"code\": \"IMN\" }, { \"name\": \"Israel\", \"code\": \"ISR\" }, {\r\n        \"name\": \"Italy\",\r\n        \"code\": \"ITA\"\r\n    }, { \"name\": \"Jamaica\", \"code\": \"JAM\" }, { \"name\": \"Japan\", \"code\": \"JPN\" }, {\r\n        \"name\": \"Jersey\",\r\n        \"code\": \"JEY\"\r\n    }, { \"name\": \"Jordan\", \"code\": \"JOR\" }, { \"name\": \"Kazakhstan\", \"code\": \"KAZ\" }, {\r\n        \"name\": \"Kenya\",\r\n        \"code\": \"KEN\"\r\n    }, { \"name\": \"Kiribati\", \"code\": \"KIR\" }, {\r\n        \"name\": \"Korea (the Democratic People's Republic of)\",\r\n        \"code\": \"PRK\"\r\n    }, { \"name\": \"Korea (the Republic of)\", \"code\": \"KOR\" }, { \"name\": \"Kuwait\", \"code\": \"KWT\" }, {\r\n        \"name\": \"Kyrgyzstan\",\r\n        \"code\": \"KGZ\"\r\n    }, { \"name\": \"Lao People's Democratic Republic\", \"code\": \"LAO\" }, {\r\n        \"name\": \"Latvia\",\r\n        \"code\": \"LVA\"\r\n    }, { \"name\": \"Lebanon\", \"code\": \"LBN\" }, { \"name\": \"Lesotho\", \"code\": \"LSO\" }, {\r\n        \"name\": \"Liberia\",\r\n        \"code\": \"LBR\"\r\n    }, { \"name\": \"Libya\", \"code\": \"LBY\" }, { \"name\": \"Liechtenstein\", \"code\": \"LIE\" }, {\r\n        \"name\": \"Lithuania\",\r\n        \"code\": \"LTU\"\r\n    }, { \"name\": \"Luxembourg\", \"code\": \"LUX\" }, { \"name\": \"Macao\", \"code\": \"MAC\" }, {\r\n        \"name\": \"Madagascar\",\r\n        \"code\": \"MDG\"\r\n    }, { \"name\": \"Malawi\", \"code\": \"MWI\" }, { \"name\": \"Malaysia\", \"code\": \"MYS\" }, {\r\n        \"name\": \"Maldives\",\r\n        \"code\": \"MDV\"\r\n    }, { \"name\": \"Mali\", \"code\": \"MLI\" }, { \"name\": \"Malta\", \"code\": \"MLT\" }, {\r\n        \"name\": \"Marshall Islands\",\r\n        \"code\": \"MHL\"\r\n    }, { \"name\": \"Martinique\", \"code\": \"MTQ\" }, { \"name\": \"Mauritania\", \"code\": \"MRT\" }, {\r\n        \"name\": \"Mauritius\",\r\n        \"code\": \"MUS\"\r\n    }, { \"name\": \"Mayotte\", \"code\": \"MYT\" }, {\r\n        \"name\": \"Mexico\",\r\n        \"code\": \"MEX\"\r\n    }, { \"name\": \"Micronesia (Federated States of)\", \"code\": \"FSM\" }, {\r\n        \"name\": \"Moldova (the Republic of)\",\r\n        \"code\": \"MDA\"\r\n    }, { \"name\": \"Monaco\", \"code\": \"MCO\" }, { \"name\": \"Mongolia\", \"code\": \"MNG\" }, {\r\n        \"name\": \"Montenegro\",\r\n        \"code\": \"MNE\"\r\n    }, { \"name\": \"Montserrat\", \"code\": \"MSR\" }, { \"name\": \"Morocco\", \"code\": \"MAR\" }, {\r\n        \"name\": \"Mozambique\",\r\n        \"code\": \"MOZ\"\r\n    }, { \"name\": \"Myanmar\", \"code\": \"MMR\" }, { \"name\": \"Namibia\", \"code\": \"NAM\" }, {\r\n        \"name\": \"Nauru\",\r\n        \"code\": \"NRU\"\r\n    }, { \"name\": \"Nepal\", \"code\": \"NPL\" }, { \"name\": \"Netherlands\", \"code\": \"NLD\" }, {\r\n        \"name\": \"New Caledonia\",\r\n        \"code\": \"NCL\"\r\n    }, { \"name\": \"New Zealand\", \"code\": \"NZL\" }, { \"name\": \"Nicaragua\", \"code\": \"NIC\" }, {\r\n        \"name\": \"Niger\",\r\n        \"code\": \"NER\"\r\n    }, { \"name\": \"Nigeria\", \"code\": \"NGA\" }, { \"name\": \"Niue\", \"code\": \"NIU\" }, {\r\n        \"name\": \"Norfolk Island\",\r\n        \"code\": \"NFK\"\r\n    }, { \"name\": \"Northern Mariana Islands\", \"code\": \"MNP\" }, { \"name\": \"Norway\", \"code\": \"NOR\" }, {\r\n        \"name\": \"Oman\",\r\n        \"code\": \"OMN\"\r\n    }, { \"name\": \"Pakistan\", \"code\": \"PAK\" }, { \"name\": \"Palau\", \"code\": \"PLW\" }, {\r\n        \"name\": \"Palestine, State of\",\r\n        \"code\": \"PSE\"\r\n    }, { \"name\": \"Panama\", \"code\": \"PAN\" }, { \"name\": \"Papua New Guinea\", \"code\": \"PNG\" }, {\r\n        \"name\": \"Paraguay\",\r\n        \"code\": \"PRY\"\r\n    }, { \"name\": \"Peru\", \"code\": \"PER\" }, { \"name\": \"Philippines\", \"code\": \"PHL\" }, {\r\n        \"name\": \"Pitcairn\",\r\n        \"code\": \"PCN\"\r\n    }, { \"name\": \"Poland\", \"code\": \"POL\" }, { \"name\": \"Portugal\", \"code\": \"PRT\" }, {\r\n        \"name\": \"Puerto Rico\",\r\n        \"code\": \"PRI\"\r\n    }, { \"name\": \"Qatar\", \"code\": \"QAT\" }, { \"name\": \"Republic of North Macedonia\", \"code\": \"MKD\" }, {\r\n        \"name\": \"Romania\",\r\n        \"code\": \"ROU\"\r\n    }, { \"name\": \"Russian Federation\", \"code\": \"RUS\" }, { \"name\": \"Rwanda\", \"code\": \"RWA\" }, {\r\n        \"name\": \"Runion\",\r\n        \"code\": \"REU\"\r\n    }, { \"name\": \"Saint Barthlemy\", \"code\": \"BLM\" }, {\r\n        \"name\": \"Saint Helena, Ascension and Tristan da Cunha\",\r\n        \"code\": \"SHN\"\r\n    }, { \"name\": \"Saint Kitts and Nevis\", \"code\": \"KNA\" }, {\r\n        \"name\": \"Saint Lucia\",\r\n        \"code\": \"LCA\"\r\n    }, { \"name\": \"Saint Martin (French part)\", \"code\": \"MAF\" }, {\r\n        \"name\": \"Saint Pierre and Miquelon\",\r\n        \"code\": \"SPM\"\r\n    }, { \"name\": \"Saint Vincent and the Grenadines\", \"code\": \"VCT\" }, {\r\n        \"name\": \"Samoa\",\r\n        \"code\": \"WSM\"\r\n    }, { \"name\": \"San Marino\", \"code\": \"SMR\" }, {\r\n        \"name\": \"Sao Tome and Principe\",\r\n        \"code\": \"STP\"\r\n    }, { \"name\": \"Saudi Arabia\", \"code\": \"SAU\" }, { \"name\": \"Senegal\", \"code\": \"SEN\" }, {\r\n        \"name\": \"Serbia\",\r\n        \"code\": \"SRB\"\r\n    }, { \"name\": \"Seychelles\", \"code\": \"SYC\" }, { \"name\": \"Sierra Leone\", \"code\": \"SLE\" }, {\r\n        \"name\": \"Singapore\",\r\n        \"code\": \"SGP\"\r\n    }, { \"name\": \"Sint Maarten (Dutch part)\", \"code\": \"SXM\" }, {\r\n        \"name\": \"Slovakia\",\r\n        \"code\": \"SVK\"\r\n    }, { \"name\": \"Slovenia\", \"code\": \"SVN\" }, { \"name\": \"Solomon Islands\", \"code\": \"SLB\" }, {\r\n        \"name\": \"Somalia\",\r\n        \"code\": \"SOM\"\r\n    }, { \"name\": \"South Africa\", \"code\": \"ZAF\" }, {\r\n        \"name\": \"South Georgia and the South Sandwich Islands\",\r\n        \"code\": \"SGS\"\r\n    }, { \"name\": \"South Sudan\", \"code\": \"SSD\" }, { \"name\": \"Spain\", \"code\": \"ESP\" }, {\r\n        \"name\": \"Sri Lanka\",\r\n        \"code\": \"LKA\"\r\n    }, { \"name\": \"Sudan\", \"code\": \"SDN\" }, { \"name\": \"Suriname\", \"code\": \"SUR\" }, {\r\n        \"name\": \"Svalbard and Jan Mayen\",\r\n        \"code\": \"SJM\"\r\n    }, { \"name\": \"Sweden\", \"code\": \"SWE\" }, { \"name\": \"Switzerland\", \"code\": \"CHE\" }, {\r\n        \"name\": \"Syrian Arab Republic\",\r\n        \"code\": \"SYR\"\r\n    }, { \"name\": \"Taiwan (Province of China)\", \"code\": \"TWN\" }, {\r\n        \"name\": \"Tajikistan\",\r\n        \"code\": \"TJK\"\r\n    }, { \"name\": \"Tanzania, United Republic of\", \"code\": \"TZA\" }, {\r\n        \"name\": \"Thailand\",\r\n        \"code\": \"THA\"\r\n    }, { \"name\": \"Timor-Leste\", \"code\": \"TLS\" }, { \"name\": \"Togo\", \"code\": \"TGO\" }, {\r\n        \"name\": \"Tokelau\",\r\n        \"code\": \"TKL\"\r\n    }, { \"name\": \"Tonga\", \"code\": \"TON\" }, { \"name\": \"Trinidad and Tobago\", \"code\": \"TTO\" }, {\r\n        \"name\": \"Tunisia\",\r\n        \"code\": \"TUN\"\r\n    }, { \"name\": \"Turkey\", \"code\": \"TUR\" }, {\r\n        \"name\": \"Turkmenistan\",\r\n        \"code\": \"TKM\"\r\n    }, { \"name\": \"Turks and Caicos Islands\", \"code\": \"TCA\" }, { \"name\": \"Tuvalu\", \"code\": \"TUV\" }, {\r\n        \"name\": \"Uganda\",\r\n        \"code\": \"UGA\"\r\n    }, { \"name\": \"Ukraine\", \"code\": \"UKR\" }, {\r\n        \"name\": \"United Arab Emirates\",\r\n        \"code\": \"ARE\"\r\n    }, {\r\n        \"name\": \"United Kingdom of Great Britain and Northern Ireland\",\r\n        \"code\": \"GBR\"\r\n    }, { \"name\": \"United States Minor Outlying Islands\", \"code\": \"UMI\" }, {\r\n        \"name\": \"United States of America\",\r\n        \"code\": \"USA\"\r\n    }, { \"name\": \"Uruguay\", \"code\": \"URY\" }, { \"name\": \"Uzbekistan\", \"code\": \"UZB\" }, {\r\n        \"name\": \"Vanuatu\",\r\n        \"code\": \"VUT\"\r\n    }, { \"name\": \"Venezuela (Bolivarian Republic of)\", \"code\": \"VEN\" }, {\r\n        \"name\": \"Viet Nam\",\r\n        \"code\": \"VNM\"\r\n    }, { \"name\": \"Virgin Islands (British)\", \"code\": \"VGB\" }, {\r\n        \"name\": \"Virgin Islands (U.S.)\",\r\n        \"code\": \"VIR\"\r\n    }, { \"name\": \"Wallis and Futuna\", \"code\": \"WLF\" }, { \"name\": \"Western Sahara\", \"code\": \"ESH\" }, {\r\n        \"name\": \"Yemen\",\r\n        \"code\": \"YEM\"\r\n    }, { \"name\": \"Zambia\", \"code\": \"ZMB\" }, { \"name\": \"Zimbabwe\", \"code\": \"ZWE\" }\r\n];\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycEditTrustedContact.ts\nvar KycEditTrustedContact_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycEditTrustedContact {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        return KycEditTrustedContact_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(this.moralis);\r\n            let account = yield userService.getAccount();\r\n            let template = Handlebars.compile(Kyc_KycEditTrustedContact);\r\n            this.modal.showModal('Edit trusted contact', template({ countries: CountryHelper.Countries }));\r\n            if (account.trusted_contact) {\r\n                let contactProperties = Object.getOwnPropertyNames(account.trusted_contact);\r\n                FormHelper.fillInputs(contactProperties, account.trusted_contact);\r\n            }\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let trustedContactSubmit = document.getElementById('trustedContactSubmit');\r\n        trustedContactSubmit === null || trustedContactSubmit === void 0 ? void 0 : trustedContactSubmit.addEventListener('click', (evt) => KycEditTrustedContact_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!FormHelper.validate('#kycTrustedContactForm'))\r\n                return;\r\n            LoadingHelper.setLoading(trustedContactSubmit);\r\n            let params = FormHelper.getParams('#kycTrustedContactForm');\r\n            let userService = new UserService(Moralis);\r\n            yield userService.updateTrustedContact(params).then((response) => {\r\n                if (response.message) {\r\n                    this.showError(response.message);\r\n                    return;\r\n                }\r\n                this.modal.hideModal();\r\n            }).catch(reason => {\r\n                if (reason.message) {\r\n                    this.showError(JSON.parse(reason.message).message);\r\n                }\r\n                else {\r\n                    this.showError(reason);\r\n                }\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n    showError(message) {\r\n        let kycEditNameError = document.getElementById('kycEditNameError');\r\n        if (!kycEditNameError)\r\n            return;\r\n        kycEditNameError.innerHTML = message;\r\n        kycEditNameError.style.display = 'block';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/AUSDService.ts\nvar AUSDService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AUSDService extends BlockchainService {\r\n    constructor(moralis) {\r\n        super(moralis);\r\n    }\r\n    getAUSDBalanceOf(ethAddress) {\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            if (AUSDService.lastUpdate && AUSDService.aUSDAmount &&\r\n                !DateHelper.isOlderThen(AUSDService.lastUpdate, 5)) {\r\n                return AUSDService.aUSDAmount;\r\n            }\r\n            let options = yield this.getOptions(\"balanceOf\", {\r\n                account: ethAddress\r\n            });\r\n            if (!this.moralis.isWeb3Enabled()) {\r\n                //await this.moralis.enableWeb3();\r\n            }\r\n            return yield this.executeFunction(options).then(balanceOf => {\r\n                let amount = this.moralis.Units.FromWei(balanceOf.toString(), 18);\r\n                AUSDService.aUSDAmount = new bignumber(amount);\r\n                AUSDService.lastUpdate = new Date();\r\n                return AUSDService.aUSDAmount;\r\n            }).catch((reason) => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                ErrorInfo.report(blockchainError);\r\n                return new bignumber(0);\r\n            });\r\n        });\r\n    }\r\n    transfer(symbolAddress, qty) {\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            const options = yield this.getOptions('transfer', {\r\n                to: symbolAddress,\r\n                amount: Moralis.Units.Token(qty.toString(), 18)\r\n            });\r\n            let result = yield this.executeFunction(options)\r\n                .then(result => {\r\n                return result;\r\n            })\r\n                .catch(reason => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                throw ErrorInfo.report(blockchainError);\r\n            });\r\n            AUSDService.aUSDAmount = undefined;\r\n            AUSDService.lastUpdate = undefined;\r\n            return result;\r\n        });\r\n    }\r\n    getOptions(functionName, params) {\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let abi = yield this.getAUsdAbi();\r\n            const options = {\r\n                contractAddress: contractInfo.AUSD_ADDRESS,\r\n                functionName: functionName,\r\n                abi: abi,\r\n                params: params,\r\n            };\r\n            return options;\r\n        });\r\n    }\r\n    getAUsdAbi() {\r\n        return AUSDService_awaiter(this, void 0, void 0, function* () {\r\n            if (AUSDService.AUSDInfo)\r\n                return AUSDService.AUSDInfo.abi;\r\n            let response = yield fetch('../abi/aUSD.json');\r\n            AUSDService.AUSDInfo = yield response.json();\r\n            return AUSDService.AUSDInfo.abi;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/funding/FakeFunding.html\n// Module\nvar FakeFunding_code = \"<article>\\r\\n    <div id=\\\"beforeFunding\\\">\\r\\n        To use liminal.market you need some aUSD. aUSD is the same value as USD.\\r\\n        We can give you some aUSD (this is all fake money), so you can play with the system.\\r\\n\\r\\n        First, you need to add aUSD to you wallet.\\r\\n\\r\\n        <button id=\\\"addTokenToWallet\\\">Add aUSD to wallet</button>\\r\\n        <blockquote id=\\\"needToCopy\\\" class=\\\"d-none\\\">\\r\\n            If the button didn't work, you can copy the address here and import it into your wallet\\r\\n            <input value=\\\"{{aUSDAddress}}\\\"/>\\r\\n        </blockquote>\\r\\n        When you have aUSD to you wallet, you can request some money to trade with.\\r\\n\\r\\n        <button id=\\\"requestFakeAUSD\\\">Request some aUSD</button>\\r\\n        <div class=\\\"warningBar notificationBar d-none\\\" id=\\\"fundingError\\\"></div>\\r\\n    </div>\\r\\n    <div id=\\\"afterFunding\\\" class=\\\"d-none center\\\">\\r\\n        We have now sending aUSD to your wallet. This usually takes few minutes, so lets wait.\\r\\n<br /><br />\\r\\n        When you have the aUSD in you wallet, we will tell you.\\r\\n        <div>\\r\\n            <h3>Current aUSD balance</h3>\\r\\n            <div id=\\\"currentAUSDBalance\\\"></div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div id=\\\"errorAfterTryFunding\\\" class=\\\"d-none\\\">\\r\\n        We had an error while trying to fund you. We'll be cracking at the issue soon to fix it.\\r\\n        Try again in few minutes. If not, try again in few hours.\\r\\n    </div>\\r\\n\\r\\n    <a href=\\\"#\\\" id=\\\"registerBankInfo\\\">Register bank information (not needed for Sandbox)</a>\\r\\n</article>\";\n// Exports\n/* harmony default export */ const FakeFunding = (FakeFunding_code);\n;// CONCATENATED MODULE: ./src/services/broker/FundingService.ts\nvar FundingService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass FundingService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    requestFakeFunding() {\r\n        return FundingService_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            return yield this.moralis.Cloud.run('fundUser', { chainId: networkInfo.ChainId });\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/Relationship/SelectFundingType.html\n// Module\nvar SelectFundingType_code = \"<p>Setup your bank relationship with Liminal.market. Please choose the type of transfer you want to make</p>\\r\\n<ul class=\\\"funding_type\\\">\\r\\n    <li><label><input type=\\\"radio\\\" name=\\\"bank_transfer\\\" id=\\\"ach_transfer\\\" value=\\\"1\\\"/> ACH bank transfer (US)</label>\\r\\n    </li>\\r\\n    <li><label><input type=\\\"radio\\\" name=\\\"bank_transfer\\\" id=\\\"wire_transfer\\\" value=\\\"2\\\"/> Wire transfer\\r\\n        (International)</label></li>\\r\\n</ul>\\r\\n<div id=\\\"selectFundingTypeError\\\" class=\\\"input_error\\\"></div>\\r\\n<button id=\\\"next_bank_information\\\">Next: Bank information</button>\\r\\n\";\n// Exports\n/* harmony default export */ const Relationship_SelectFundingType = (SelectFundingType_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/SelectFundingType.ts\n\r\nclass SelectFundingType {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(Relationship_SelectFundingType);\r\n        this.aUsdFund.modal.showModal('Select funding type', template({}));\r\n        this.bindEvent();\r\n    }\r\n    bindEvent() {\r\n        let next_bank_information = document.getElementById('next_bank_information');\r\n        next_bank_information === null || next_bank_information === void 0 ? void 0 : next_bank_information.addEventListener('click', (evt) => {\r\n            this.aUsdFund.hideError('selectFundingTypeError');\r\n            let ach_transfer = document.getElementById('ach_transfer');\r\n            if (ach_transfer === null || ach_transfer === void 0 ? void 0 : ach_transfer.checked) {\r\n                this.aUsdFund.achRelationship.show();\r\n            }\r\n            let wire_transfer = document.getElementById('wire_transfer');\r\n            if (wire_transfer === null || wire_transfer === void 0 ? void 0 : wire_transfer.checked) {\r\n                this.aUsdFund.wireTransferRelationship.show();\r\n            }\r\n            this.aUsdFund.showError('selectFundingTypeError', 'Please select funding type');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/Relationship/ACHRelationship.html\n// Module\nvar ACHRelationship_code = \"<fieldset>\\r\\n    <p>Before you can transfer, you need to set up your bank information</p>\\r\\n\\r\\n    <form id=\\\"achForm\\\">\\r\\n        <div class=\\\"grid\\\">\\r\\n            <label>\\r\\n                Account owner name\\r\\n                <input name=\\\"account_owner_name\\\" required id=\\\"account_owner_name\\\"/>\\r\\n            </label>\\r\\n            <label>Bank Account Type\\r\\n                <select name=\\\"bank_account_type\\\" id=\\\"bank_account_type\\\" required>\\r\\n                    <option value=\\\"\\\"></option>\\r\\n                    <option value=\\\"CHECKING\\\">Checking</option>\\r\\n                    <option value=\\\"SAVINGS\\\">Savings</option>\\r\\n                </select>\\r\\n            </label>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <label>\\r\\n                Bank account number\\r\\n                <input name=\\\"bank_account_number\\\" id=\\\"bank_account_number\\\" required/>\\r\\n            </label>\\r\\n            <label>\\r\\n                Bank routing number\\r\\n                <input name=\\\"bank_routing_number\\\" id=\\\"bank_routing_number\\\" required/>\\r\\n            </label>\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"relationshipError\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <button id=\\\"ach_previous\\\">Previous: Funding type</button>\\r\\n            <button id=\\\"ach_next\\\">Next: Save bank information</button>\\r\\n        </div>\\r\\n\\r\\n    </form>\\r\\n\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Relationship_ACHRelationship = (ACHRelationship_code);\n;// CONCATENATED MODULE: ./src/enums/TransferDirectionEnum.ts\nvar TransferDirectionEnum;\r\n(function (TransferDirectionEnum) {\r\n    TransferDirectionEnum[\"Incoming\"] = \"INCOMING\";\r\n    TransferDirectionEnum[\"Outgoing\"] = \"OUTGOING\";\r\n})(TransferDirectionEnum || (TransferDirectionEnum = {}));\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/RelationshipBase.ts\nvar RelationshipBase_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass RelationshipBase {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show(title, html, param) {\r\n        let template = Handlebars.compile(html);\r\n        this.aUsdFund.modal.showModal(title, template(param));\r\n        this.bindEvents();\r\n    }\r\n    handleErrorResponse(reason) {\r\n        return RelationshipBase_awaiter(this, void 0, void 0, function* () {\r\n            if (!reason.message) {\r\n                alert(reason);\r\n                return;\r\n            }\r\n            let obj = JSON.parse(reason.message);\r\n            let errorElement = document.getElementById('relationshipError');\r\n            if (!errorElement) {\r\n                let message = (obj.serverError) ? obj.serverError.message : reason.message;\r\n                alert(message);\r\n                return;\r\n            }\r\n            if (obj.serverError.message.indexOf('only one bank association') != -1) {\r\n                let userService = new UserService(this.aUsdFund.moralis);\r\n                let bankRelationship = yield userService.getBankRelationship();\r\n                if (!bankRelationship) {\r\n                    errorElement.innerText = 'We cannot create the bank connection. Something is not working as it should. Please contact us at <a href=\"mailto:info@liminal.market\">info@liminal.market</a>';\r\n                    errorElement.style.display = 'block';\r\n                }\r\n                else {\r\n                    let transfers = yield userService.getLatestTransfers(TransferDirectionEnum.Incoming);\r\n                    yield this.aUsdFund.transferNotification.show(bankRelationship, transfers);\r\n                }\r\n            }\r\n            else {\r\n                errorElement.innerText = obj.serverError.message;\r\n                errorElement.style.display = 'block';\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/ACHRelationship.ts\nvar ACHRelationship_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass ACHRelationship extends RelationshipBase {\r\n    constructor(aUsdFund) {\r\n        super(aUsdFund);\r\n    }\r\n    show() {\r\n        super.show('Bank information', Relationship_ACHRelationship);\r\n    }\r\n    bindEvents() {\r\n        let ach_next = document.getElementById('ach_next');\r\n        ach_next === null || ach_next === void 0 ? void 0 : ach_next.addEventListener('click', (evt) => ACHRelationship_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.validate())\r\n                return;\r\n            let params = FormHelper.getParams('#achForm');\r\n            let userService = new UserService(this.aUsdFund.moralis);\r\n            userService.createAchRelationship(params.account_owner_name, params.bank_account_type, params.bank_account_number, params.bank_routing_number)\r\n                .then(result => {\r\n                this.aUsdFund.firstTransferSetup.show(result);\r\n            })\r\n                .catch((reason) => ACHRelationship_awaiter(this, void 0, void 0, function* () {\r\n                yield this.handleErrorResponse(reason);\r\n            }));\r\n        }));\r\n        let ach_previous = document.getElementById('ach_previous');\r\n        ach_previous === null || ach_previous === void 0 ? void 0 : ach_previous.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            this.aUsdFund.selectFundingType.show();\r\n        });\r\n    }\r\n    validate() {\r\n        if (!FormHelper.validate('#achForm'))\r\n            return false;\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/TransferNotification.html\n// Module\nvar TransferNotification_code = \"<fieldset>\\r\\n\\r\\n\\r\\n    <p>\\r\\n        To fill up your broker account, you need to notify Liminal.market first about your transfer,\\r\\n        we can then match it with your account.\\r\\n        <a href=\\\"#\\\" id=\\\"first_transfer_setup\\\">Need bank information? Click here</a>\\r\\n    </p>\\r\\n    <br/>\\r\\n\\r\\n    {{{moneyTransferred}}}\\r\\n\\r\\n    {{{transfers}}}\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Funding_TransferNotification = (TransferNotification_code);\n;// CONCATENATED MODULE: ./src/html/modal/Funding/TransfersList.html\n// Module\nvar TransfersList_code = \"<hr/>\\r\\n<h3>{{Direction}} transfers</h3>\\r\\n{{#if transfers.length}}\\r\\n<p>Below is a list of transfers, confirmed and not confirmed.</p>\\r\\n<table>\\r\\n    <thead>\\r\\n    <tr>\\r\\n        <th>Amount</th>\\r\\n        <th>Status</th>\\r\\n        <th>Created</th>\\r\\n        <th>Expires</th>\\r\\n    </tr>\\r\\n    </thead>\\r\\n    <tbody>\\r\\n    {{#each transfers}}\\r\\n    <tr>\\r\\n        <td>${{amount}}</td>\\r\\n        <td id=\\\"status_{{id}}\\\">{{status}}</td>\\r\\n        <td>{{dateTimeFormat created_at}}</td>\\r\\n        <td>{{dateTimeFormat expires_at}}</td>\\r\\n        <td id=\\\"delete_{{id}}\\\" class=\\\"{{classByStatus status}}\\\"><a href=\\\"#\\\" class=\\\"deleteTransfer\\\" data-id=\\\"{{id}}\\\">Cancel</a>\\r\\n        </td>\\r\\n    </tr>\\r\\n    {{/each}}\\r\\n    </tbody>\\r\\n</table>\\r\\n{{else}}\\r\\n<p>No transfers registered</p>\\r\\n{{/if}}\";\n// Exports\n/* harmony default export */ const Funding_TransfersList = (TransfersList_code);\n;// CONCATENATED MODULE: ./src/util/HandlebarHelpers.ts\nclass HandlebarHelpers {\r\n    static registerHelpers() {\r\n        Handlebars.registerHelper('perc', function (number) {\r\n            return Math.round(parseFloat(number) * 10000) / 100 + '%';\r\n        });\r\n        Handlebars.registerHelper('round', function (number) {\r\n            return Math.round(parseFloat(number) * 100) / 100;\r\n        });\r\n        Handlebars.registerHelper('round2', function (number) {\r\n            return Math.round(parseFloat(number) * 10000) / 10000;\r\n        });\r\n        Handlebars.registerHelper('classColor', function (number) {\r\n            return (number > 0) ? \"green\" : \"red\";\r\n        });\r\n        Handlebars.registerHelper('dateTimeFormat', function (strDate) {\r\n            let date = new Date(strDate);\r\n            return date.toLocaleString();\r\n        });\r\n        Handlebars.registerHelper('classByStatus', function (status) {\r\n            return (status == 'QUEUED' || status == 'APPROVAL_PENDING') ? '' : 'hidden';\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/TransfersList.ts\nvar TransfersList_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass TransfersList {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.userService = new UserService(this.moralis);\r\n    }\r\n    render(direction, transfers) {\r\n        return TransfersList_awaiter(this, void 0, void 0, function* () {\r\n            HandlebarHelpers.registerHelpers();\r\n            let transfersTemplate = Handlebars.compile(Funding_TransfersList);\r\n            return transfersTemplate({ Direction: direction, transfers: transfers });\r\n        });\r\n    }\r\n    bindEvents() {\r\n        var _a;\r\n        let deleteTransfers = document.querySelectorAll('.deleteTransfer');\r\n        for (let i = 0; i < deleteTransfers.length; i++) {\r\n            (_a = deleteTransfers[i]) === null || _a === void 0 ? void 0 : _a.addEventListener('click', (evt) => TransfersList_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                if (!confirm('Are you sure you want to cancel this withdraw request?')) {\r\n                    return;\r\n                }\r\n                let id = deleteTransfers[i].dataset['id'];\r\n                if (!id)\r\n                    return;\r\n                let userService = new UserService(this.moralis);\r\n                yield userService.deleteTransfer(id)\r\n                    .then(() => {\r\n                    let statusTd = document.getElementById('status_' + id);\r\n                    if (statusTd) {\r\n                        statusTd.innerText = 'CANCELED';\r\n                    }\r\n                    let deleteTd = document.getElementById('delete_' + id);\r\n                    deleteTd === null || deleteTd === void 0 ? void 0 : deleteTd.remove();\r\n                });\r\n            }));\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/FirstTransferSetupBase.ts\nclass FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        this.aUsdFund = aUsdFund;\r\n        this.bankRelationship = bankRelationship;\r\n    }\r\n    render(html) {\r\n        let element = document.getElementById('html_to_fill');\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = html;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/MoneyTransferred.html\n// Module\nvar MoneyTransferred_code = \"<form>\\r\\n    <label>Type in the amount in US Dollars ($) that you transferred\\r\\n        <input name=\\\"amount\\\" class=\\\"amount\\\" type=\\\"tel\\\" id=\\\"amount\\\" minlength=\\\"1\\\" required/>\\r\\n    </label>\\r\\n    <div class=\\\"input_error\\\" id=\\\"transferError\\\"></div>\\r\\n    <button id=\\\"notifyTransfer\\\">Notify Liminal.market of incoming transfer</button>\\r\\n\\r\\n    <input type=\\\"hidden\\\" name=\\\"transfer_type\\\" id=\\\"transfer_type\\\" value=\\\"{{transfer_type}}\\\"/>\\r\\n    <input type=\\\"hidden\\\" name=\\\"relationship_id\\\" id=\\\"relationship_id\\\" value=\\\"{{relationshipId}}\\\"/>\\r\\n    <input type=\\\"hidden\\\" name=\\\"direction\\\" id=\\\"direction\\\" value=\\\"INCOMING\\\"/>\\r\\n</form>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_MoneyTransferred = (MoneyTransferred_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/MoneyTransferred.ts\nvar MoneyTransferred_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass MoneyTransferred extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(FirstTransferSetup_MoneyTransferred);\r\n        super.render(template({}));\r\n        this.bindEvents();\r\n    }\r\n    render() {\r\n        let template = Handlebars.compile(FirstTransferSetup_MoneyTransferred);\r\n        return template({\r\n            transfer_type: this.bankRelationship.transfer_type,\r\n            relationshipId: this.bankRelationship.id\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let notifyTransfer = document.getElementById('notifyTransfer');\r\n        notifyTransfer === null || notifyTransfer === void 0 ? void 0 : notifyTransfer.addEventListener('click', (evt) => MoneyTransferred_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            this.aUsdFund.hideError('transferError');\r\n            let amount = document.getElementById('amount');\r\n            if (StringHelper.isNullOrEmpty(amount.value) || parseFloat(amount.value) < 10) {\r\n                this.aUsdFund.showError('amountError', 'Amount cannot be empty or below $10');\r\n            }\r\n            LoadingHelper.setLoading(notifyTransfer);\r\n            let userService = new UserService(this.aUsdFund.moralis);\r\n            yield userService.createTransfer(amount.value, 'INCOMING')\r\n                .then(() => {\r\n                this.aUsdFund.transferNotified.show(this.bankRelationship, amount.value);\r\n            })\r\n                .catch(reason => {\r\n                let httpError = JSON.parse(reason.message);\r\n                this.aUsdFund.showError('transferError', httpError.serverError.message);\r\n            })\r\n                .finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/TransferNotification.ts\nvar TransferNotification_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass TransferNotification {\r\n    constructor(moralis, aUsdFund) {\r\n        this.moralis = moralis;\r\n        this.aUsdFund = aUsdFund;\r\n        this.transfersList = new TransfersList(this.moralis);\r\n    }\r\n    show(bankRelationship, transfers) {\r\n        return TransferNotification_awaiter(this, void 0, void 0, function* () {\r\n            this.bankRelationship = bankRelationship;\r\n            let template = Handlebars.compile(Funding_TransferNotification);\r\n            let transfersListHtml = yield this.transfersList.render(TransferDirectionEnum.Incoming, transfers);\r\n            this.moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);\r\n            this.aUsdFund.modal.showModal('Create transfer notification', template({\r\n                moneyTransferred: this.moneyTransferred.render(),\r\n                transfers: transfersListHtml\r\n            }));\r\n            this.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        var _a;\r\n        (_a = this.moneyTransferred) === null || _a === void 0 ? void 0 : _a.bindEvents();\r\n        this.transfersList.bindEvents();\r\n        let first_transfer_setup = document.getElementById('first_transfer_setup');\r\n        first_transfer_setup === null || first_transfer_setup === void 0 ? void 0 : first_transfer_setup.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            this.aUsdFund.firstTransferSetup.show(this.bankRelationship);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/Relationship/WireTransferRelationship.html\n// Module\nvar WireTransferRelationship_code = \"<fieldset>\\r\\n    <p>Before you can transfer, you need to set up your bank information</p>\\r\\n    <form id=\\\"wireTransferForm\\\">\\r\\n        <label>Bank name\\r\\n            <input name=\\\"name\\\" required id=\\\"name\\\"/>\\r\\n        </label>\\r\\n        <div class=\\\"input_error\\\" id=\\\"swift_error\\\">BIC/SWIFT code should be 8 or 11 characters</div>\\r\\n        <label>\\r\\n            Bank code (BIC/SWIFT)\\r\\n            <input name=\\\"bank_code\\\" maxlength=\\\"11\\\" id=\\\"bank_code\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Bank Street address\\r\\n            <input name=\\\"street_address\\\" id=\\\"street_address\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Bank Postal code\\r\\n            <input name=\\\"postal_code\\\" id=\\\"postal_code\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Bank City\\r\\n            <input name=\\\"city\\\" id=\\\"city\\\" required/>\\r\\n        </label>\\r\\n\\r\\n        <label>Bank State\\r\\n            <input name=\\\"state_province\\\" id=\\\"state_province\\\" required/>\\r\\n        </label>\\r\\n        <label>\\r\\n            Country where bank account is located\\r\\n            <select required id=\\\"country\\\" required name=\\\"country\\\">\\r\\n                <option value=\\\"\\\"></option>\\r\\n                {{#each countries}}\\r\\n                <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n                {{/each}}\\r\\n            </select>\\r\\n        </label>\\r\\n        <label>\\r\\n            Account number (IBAN)\\r\\n            <input name=\\\"account_number\\\" id=\\\"account_number\\\" required/>\\r\\n        </label>\\r\\n        <input type=\\\"hidden\\\" name=\\\"bank_code_type\\\" value=\\\"BIC\\\"/>\\r\\n        <div id=\\\"relationshipError\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <button id=\\\"wire_transfer_previous\\\">Previous: Funding type</button>\\r\\n            <button id=\\\"save_international_bank_information\\\">Next: Transfer</button>\\r\\n        </div>\\r\\n    </form>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Relationship_WireTransferRelationship = (WireTransferRelationship_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/Relationship/WireTransferRelationship.ts\nvar WireTransferRelationship_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass WireTransferRelationship extends RelationshipBase {\r\n    constructor(aUsdFund) {\r\n        super(aUsdFund);\r\n    }\r\n    show() {\r\n        super.show('Create bank information', Relationship_WireTransferRelationship, { countries: CountryHelper.Countries });\r\n    }\r\n    bindEvents() {\r\n        let wire_transfer_previous = document.getElementById('wire_transfer_previous');\r\n        wire_transfer_previous === null || wire_transfer_previous === void 0 ? void 0 : wire_transfer_previous.addEventListener('click', (evt) => {\r\n            this.aUsdFund.selectFundingType.show();\r\n        });\r\n        let save_international_bank_information = document.getElementById('save_international_bank_information');\r\n        save_international_bank_information === null || save_international_bank_information === void 0 ? void 0 : save_international_bank_information.addEventListener('click', (evt) => WireTransferRelationship_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.validate())\r\n                return;\r\n            let params = FormHelper.getParams('#wireTransferForm');\r\n            let userService = new UserService(this.aUsdFund.moralis);\r\n            yield userService.registerWireTransferRelationship(params)\r\n                .then((bankRelationship) => WireTransferRelationship_awaiter(this, void 0, void 0, function* () {\r\n                let transfers = yield userService.getLatestTransfers(TransferDirectionEnum.Incoming);\r\n                yield this.aUsdFund.transferNotification.show(bankRelationship, transfers);\r\n            }))\r\n                .catch((reason) => WireTransferRelationship_awaiter(this, void 0, void 0, function* () {\r\n                yield this.handleErrorResponse(reason);\r\n            }));\r\n        }));\r\n    }\r\n    validate() {\r\n        let swift_error = document.getElementById('swift_error');\r\n        if (swift_error)\r\n            swift_error.style.display = 'none';\r\n        let writeTransferError = document.getElementById('writeTransferError');\r\n        if (writeTransferError)\r\n            writeTransferError.style.display = 'none';\r\n        if (!FormHelper.validate('#wireTransferForm'))\r\n            return false;\r\n        let bank_code = document.getElementById('bank_code');\r\n        if (bank_code.value.length != 8 && bank_code.value.length != 11) {\r\n            bank_code.setAttribute('aria-invalid', 'true');\r\n            let swift_error = document.getElementById('swift_error');\r\n            if (swift_error)\r\n                swift_error.style.display = 'block';\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/TransferInfo.html\n// Module\nvar TransferInfo_code = \"<h2>You need to transfer your money now</h2>\\r\\n<ul>\\r\\n    <li>Amount: {{amount}}</li>\\r\\n    <li>Account: {{account_number}}</li>\\r\\n</ul>\";\n// Exports\n/* harmony default export */ const TransferInfo = (TransferInfo_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/TransferNotified.ts\n\r\nclass TransferNotified {\r\n    constructor(aUsdFund) {\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show(bankRelationship, amount) {\r\n        let template = Handlebars.compile(TransferInfo);\r\n        let obj = {\r\n            amount,\r\n            account_number: bankRelationship.alpaca_account_number,\r\n            wire: (bankRelationship.transfer_type == 'wire')\r\n        };\r\n        this.aUsdFund.modal.showModal('Transfer information', template(obj));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/FirstTransferSetup.html\n// Module\nvar FirstTransferSetup_code = \"<div id=\\\"html_to_fill\\\">\\r\\n    {{{html}}}\\r\\n</div>\\r\\n\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_FirstTransferSetup = (FirstTransferSetup_code);\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/BankInfo.html\n// Module\nvar BankInfo_code = \"Create the bank information you need in your internet bank\\r\\n<table>\\r\\n    <tr>\\r\\n        <td>Bank name</td>\\r\\n        <td>BMO Harris Bank NA</td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Bank address</td>\\r\\n        <td>BMO Harris Bank\\r\\n            111. W. Monroe Street\\r\\n            Chicago, IL 60603, USA\\r\\n        </td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Recipient - Account name</td>\\r\\n        <td>Alpaca Securities LLC</td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Alpaca address</td>\\r\\n        <td>Alpaca Securities LLC\\r\\n            3 East Third Ave, Suite 233\\r\\n            San Mateo, CA 94401, USA\\r\\n        </td>\\r\\n    </tr>\\r\\n    <tr>\\r\\n        <td>Account number / IBAN</td>\\r\\n        <td>1636877</td>\\r\\n    </tr>\\r\\n    {{#if wire}}\\r\\n    <tr>\\r\\n        <td>SWIFT CODE</td>\\r\\n        <td>HATRUS44</td>\\r\\n    </tr>\\r\\n    {{^}}\\r\\n    <tr>\\r\\n        <td>ABA ROUTING NUMBER (ACH)</td>\\r\\n        <td>071000288</td>\\r\\n    </tr>\\r\\n    {{/if}}\\r\\n    <tr>\\r\\n        <td>Please specify the following in the reference of the wire:</td>\\r\\n        <td>FFC LMKT-{{account_number}}</td>\\r\\n    </tr>\\r\\n</table>\\r\\n<button id=\\\"bank_info_next\\\">Next: I set up the information in my bank</button>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_BankInfo = (BankInfo_code);\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/WireTransferMoney.html\n// Module\nvar WireTransferMoney_code = \"<h3>Transfer money</h3>\\r\\nYou can now log in to your internet bank and transfer the money to Alpaca.\\r\\n<br/><br/>\\r\\nAfter you have transferred the money, you need to let us know the amount that you transferred.\\r\\n\\r\\n<div class=\\\"grid\\\">\\r\\n    <button id=\\\"prev_wire_transfer_money\\\">Previous: See bank information</button>\\r\\n    <button id=\\\"next_wire_transfer_money\\\">Next: I have transferred the money</button>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_WireTransferMoney = (WireTransferMoney_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/WireTransferMoney.ts\n\r\n\r\n\r\n\r\nclass WireTransferMoney extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(FirstTransferSetup_WireTransferMoney);\r\n        this.render(template({}));\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        let next = document.getElementById('next_wire_transfer_money');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);\r\n            moneyTransferred.show();\r\n        });\r\n        let prev = document.getElementById('prev_wire_transfer_money');\r\n        prev === null || prev === void 0 ? void 0 : prev.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let transferSetup = new FirstTransferSetup(Moralis, this.aUsdFund);\r\n            transferSetup.show(this.bankRelationship);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/FirstTransferSetup/ACHTransferAccountNumber.html\n// Module\nvar ACHTransferAccountNumber_code = \"The money should come from bank account number <strong>{{bank_account_number}}</strong>\\r\\n<div class=\\\"grid\\\">\\r\\n    <button id=\\\"next_ach_account_number\\\">Yes, it's coming from {{bank_account_number}}</button>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const FirstTransferSetup_ACHTransferAccountNumber = (ACHTransferAccountNumber_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/ACHTransferAccountNumber.ts\n\r\n\r\n\r\nclass ACHTransferAccountNumber extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let template = Handlebars.compile(FirstTransferSetup_ACHTransferAccountNumber);\r\n        this.render(template({ bank_account_number: this.bankRelationship.alpaca_account_number }));\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        let next = document.getElementById('next_ach_account_number');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let moneyTransferred = new MoneyTransferred(this.aUsdFund, this.bankRelationship);\r\n            moneyTransferred.show();\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/BankInfo.ts\n\r\n\r\n\r\n\r\nclass BankInfo extends FirstTransferSetupBase {\r\n    constructor(aUsdFund, bankRelationship) {\r\n        super(aUsdFund, bankRelationship);\r\n    }\r\n    show() {\r\n        let bankInfoTemplate = Handlebars.compile(FirstTransferSetup_BankInfo);\r\n        let bankInfoHtml = bankInfoTemplate({\r\n            wire: this.bankRelationship.transfer_type == 'wire',\r\n            account_number: this.bankRelationship.alpaca_account_number\r\n        });\r\n        this.render(bankInfoHtml);\r\n        this.bindEvents();\r\n    }\r\n    bindEvents() {\r\n        let next = document.getElementById('bank_info_next');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            if (this.bankRelationship.transfer_type == 'wire') {\r\n                let wireTransferMoney = new WireTransferMoney(this.aUsdFund, this.bankRelationship);\r\n                wireTransferMoney.show();\r\n            }\r\n            else {\r\n                let ach = new ACHTransferAccountNumber(this.aUsdFund, this.bankRelationship);\r\n                ach.show();\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FirstTransferSetup/FirstTransferSetup.ts\n\r\n\r\nclass FirstTransferSetup {\r\n    constructor(moralis, aUsdFund) {\r\n        this.moralis = moralis;\r\n        this.aUsdFund = aUsdFund;\r\n    }\r\n    show(bankRelationship) {\r\n        this.bankRelationship = bankRelationship;\r\n        let template = Handlebars.compile(FirstTransferSetup_FirstTransferSetup);\r\n        this.aUsdFund.modal.showModal('Setup transfer', template({}));\r\n        let bankInfo = new BankInfo(this.aUsdFund, bankRelationship);\r\n        bankInfo.show();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/AUSDFund.ts\nvar AUSDFund_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AUSDFund {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.modal = new Modal();\r\n        this.selectFundingType = new SelectFundingType(this);\r\n        this.achRelationship = new ACHRelationship(this);\r\n        this.wireTransferRelationship = new WireTransferRelationship(this);\r\n        this.firstTransferSetup = new FirstTransferSetup(moralis, this);\r\n        this.transferNotification = new TransferNotification(moralis, this);\r\n        this.transferNotified = new TransferNotified(this);\r\n    }\r\n    show() {\r\n        return AUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(this.moralis);\r\n            let bankRelationship = yield userService.getBankRelationship();\r\n            if (bankRelationship) {\r\n                let transfers = yield userService.getLatestTransfers(TransferDirectionEnum.Incoming);\r\n                if (transfers.length > 0) {\r\n                    yield this.transferNotification.show(bankRelationship, transfers);\r\n                }\r\n                else {\r\n                    this.firstTransferSetup.show(bankRelationship);\r\n                }\r\n            }\r\n            else {\r\n                this.selectFundingType.show();\r\n            }\r\n        });\r\n    }\r\n    showError(elementId, reason) {\r\n        let element = document.getElementById(elementId);\r\n        if (element) {\r\n            element.innerText = reason;\r\n            element.style.display = 'block';\r\n        }\r\n    }\r\n    hideError(elementId) {\r\n        let element = document.getElementById(elementId);\r\n        if (element) {\r\n            element.style.display = 'none';\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/FakeAUSDFund.ts\nvar FakeAUSDFund_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass FakeAUSDFund {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.currentBalance = new bignumber(-1);\r\n        this.modal = new Modal();\r\n    }\r\n    showAUSDFund(callback) {\r\n        //this is real instruction how to transfer to broker\r\n        callback();\r\n    }\r\n    showAUSDFakeFund(callback) {\r\n        let template = Handlebars.compile(FakeFunding);\r\n        let contractInfo = ContractInfo.getContractInfo();\r\n        let content = template({ aUSDAddress: contractInfo.AUSD_ADDRESS });\r\n        this.modal.showModal('Fund my account (Fake money)', content);\r\n        let addToWallet = document.getElementById('addTokenToWallet');\r\n        if (!addToWallet)\r\n            return;\r\n        addToWallet.addEventListener('click', (evt) => FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let walletHelper = new WalletHelper(this.moralis);\r\n            let result = yield walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, 'aUSD', () => {\r\n                this.showCopyField();\r\n            });\r\n            if (!result)\r\n                this.showCopyField();\r\n        }));\r\n        let registerBankInfo = document.getElementById('registerBankInfo');\r\n        registerBankInfo === null || registerBankInfo === void 0 ? void 0 : registerBankInfo.addEventListener('click', (evt) => {\r\n            this.modal.hideModal();\r\n            let aUsdFund = new AUSDFund(this.moralis);\r\n            aUsdFund.show();\r\n        });\r\n        let requestFakeAUSD = document.getElementById('requestFakeAUSD');\r\n        requestFakeAUSD === null || requestFakeAUSD === void 0 ? void 0 : requestFakeAUSD.addEventListener('click', (evt) => FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            requestFakeAUSD.setAttribute('aria-busy', 'true');\r\n            let fundingService = new FundingService(this.moralis);\r\n            let result = yield fundingService.requestFakeFunding()\r\n                .catch((reason) => {\r\n                this.errorWhileFunding({});\r\n            });\r\n            console.log('success', result.success);\r\n            if (!result.success) {\r\n                console.log(result);\r\n                let fundingError = document.getElementById('fundingError');\r\n                if (fundingError) {\r\n                    requestFakeAUSD.removeAttribute('aria-busy');\r\n                    fundingError.classList.remove('d-none');\r\n                    fundingError.innerHTML = result.message;\r\n                    setTimeout(() => {\r\n                        fundingError.classList.add('d-none');\r\n                    }, 10 * 1000);\r\n                }\r\n            }\r\n            else if (result.success) {\r\n                let beforeFunding = document.getElementById('beforeFunding');\r\n                let afterFunding = document.getElementById('afterFunding');\r\n                if (!beforeFunding || !afterFunding)\r\n                    return;\r\n                yield this.loadAUSDBalance();\r\n                beforeFunding.classList.add('d-none');\r\n                afterFunding.classList.remove('d-none');\r\n            }\r\n            else {\r\n                this.errorWhileFunding(result);\r\n            }\r\n            //callback();\r\n        }));\r\n    }\r\n    loadAUSDBalance() {\r\n        return FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n            let currentAUSDBalance = document.getElementById('currentAUSDBalance');\r\n            if (!currentAUSDBalance)\r\n                return;\r\n            let aUSDService = new AUSDService(this.moralis);\r\n            let userService = new UserService(this.moralis);\r\n            let ethAddress = userService.getEthAddress();\r\n            let amount = new bignumber(0);\r\n            if (ethAddress) {\r\n                amount = yield aUSDService.getAUSDBalanceOf(ethAddress);\r\n            }\r\n            currentAUSDBalance.innerHTML = '$' + roundBigNumber(amount).toString();\r\n            if (this.currentBalance.eq(-1)) {\r\n                this.currentBalance = amount;\r\n            }\r\n            if (this.currentBalance.eq(amount)) {\r\n                setTimeout(() => FakeAUSDFund_awaiter(this, void 0, void 0, function* () {\r\n                    yield this.loadAUSDBalance();\r\n                }), 5 * 1000);\r\n            }\r\n            else {\r\n                window.location.reload();\r\n            }\r\n        });\r\n    }\r\n    showCopyField() {\r\n        let needToCopy = document.getElementById('needToCopy');\r\n        if (!needToCopy)\r\n            return;\r\n        needToCopy.classList.remove('d-none');\r\n    }\r\n    errorWhileFunding(result) {\r\n        let beforeFunding = document.getElementById('beforeFunding');\r\n        let errorAfterFunding = document.getElementById('errorAfterTryFunding');\r\n        if (!beforeFunding || !errorAfterFunding)\r\n            return;\r\n        if (result.message) {\r\n            errorAfterFunding.innerHTML = result.message;\r\n        }\r\n        beforeFunding.classList.add('d-none');\r\n        errorAfterFunding.classList.remove('d-none');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Funding/WithdrawModal.html\n// Module\nvar WithdrawModal_code = \"<fieldset id=\\\"withdrawInput\\\">\\r\\n\\r\\n    {{#if bank.bank_code_type}}\\r\\n    Your money will be sent to {{bank.name}} to account number {{bank.account_number}}.\\r\\n    <br/><br/>\\r\\n    Outgoing International Wire Transfers cost is ${{transferCost}}.<br/>\\r\\n    Fees will be deducted from the amount.\\r\\n    {{/if}}\\r\\n    {{#unless bank.bank_code_type}}\\r\\n    Your money will be sent to account number {{bank.bank_account_number}}.\\r\\n    <br/><br/>\\r\\n    ACH transfer costs is ${{transferCost}}. Fees will be deducted from the amount.\\r\\n    {{/unless}}\\r\\n    <form id=\\\"withdrawForm\\\">\\r\\n        <label>Amount to withdraw\\r\\n            <input type=\\\"tel\\\" name=\\\"amount\\\" id=\\\"amount\\\"/>\\r\\n        </label>\\r\\n        <div class=\\\"input_error\\\" id=\\\"withdrawAmountError\\\">The amount is lower than the cost of transfer</div>\\r\\n        <button id=\\\"confirmWithdraw\\\">Confirm withdraw</button>\\r\\n    </form>\\r\\n    {{{Transfers}}}\\r\\n</fieldset>\\r\\n\\r\\n<fieldset id=\\\"withdrawConfirm\\\" class=\\\"hidden\\\">\\r\\n    You are about to withdraw $<span id=\\\"withdrawAmountText\\\"></span> from your account\\r\\n    <div class=\\\"warningBar\\\">\\r\\n        Warning: The fee of this transaction will be $<span id=\\\"feeWarning\\\"></span>\\r\\n        and is <span id=\\\"feePercentage\\\"></span>% of the amount.\\r\\n    </div>\\r\\n    <div class=\\\"input_error\\\" id=\\\"withdrawError\\\"></div>\\r\\n    <button id=\\\"confirmWithdrawButton\\\">Execute transfer</button>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Funding_WithdrawModal = (WithdrawModal_code);\n;// CONCATENATED MODULE: ./src/ui/modals/Funding/WithdrawModal.ts\nvar WithdrawModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass WithdrawModal {\r\n    constructor(moralis) {\r\n        this.wireTransferCost = 50;\r\n        this.achTransferCost = 25;\r\n        this.moralis = moralis;\r\n        this.userService = new UserService(this.moralis);\r\n        this.transferCost = this.wireTransferCost;\r\n        this.transfersList = new TransfersList(this.moralis);\r\n    }\r\n    show() {\r\n        return WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n            let modal = new Modal();\r\n            let bankRelationships = yield this.userService.getBankRelationship();\r\n            if (!bankRelationships) {\r\n                modal.showModal('Withdraw information', \"You haven't setup bank connection. You cannot withdraw from without bank connection\");\r\n                return;\r\n            }\r\n            let transfers = yield this.userService.getLatestTransfers(TransferDirectionEnum.Outgoing);\r\n            let transfersHtml = yield this.transfersList.render(TransferDirectionEnum.Outgoing, transfers);\r\n            let ethAddress = this.userService.getEthAddress();\r\n            let ausdService = new AUSDService(this.moralis);\r\n            this.currentBalance = new bignumber(0);\r\n            if (ethAddress) {\r\n                this.currentBalance = yield ausdService.getAUSDBalanceOf(ethAddress);\r\n            }\r\n            if (this.currentBalance.eq(0)) {\r\n                let tmp = Handlebars.compile(\"Your current balance is $0. There is nothing to withdraw. {{{transfers}}}\");\r\n                modal.showModal('Withdraw information', tmp({ transfers: transfersHtml }));\r\n                return;\r\n            }\r\n            let withdrawTemplate = Handlebars.compile(Funding_WithdrawModal);\r\n            this.bankInfo = bankRelationships;\r\n            this.transferCost = (this.bankInfo.bank_code_type) ? this.wireTransferCost : this.achTransferCost;\r\n            let obj = {\r\n                amount: this.currentBalance,\r\n                transferCost: this.transferCost,\r\n                Transfers: transfersHtml,\r\n                bank: this.bankInfo\r\n            };\r\n            modal.showModal('Withdraw information', withdrawTemplate(obj));\r\n            this.bindEvents();\r\n            this.transfersList.bindEvents();\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let confirmWithdraw = document.getElementById('confirmWithdraw');\r\n        confirmWithdraw === null || confirmWithdraw === void 0 ? void 0 : confirmWithdraw.addEventListener('click', (evt) => WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!this.bankInfo)\r\n                return;\r\n            let amount = document.getElementById('amount');\r\n            if (StringHelper.isNullOrEmpty(amount.value)) {\r\n                amount.setAttribute('aria-invalid', 'true');\r\n                return;\r\n            }\r\n            else if (parseFloat(amount.value) <= this.transferCost) {\r\n                let withdrawAmountError = document.getElementById('withdrawAmountError');\r\n                withdrawAmountError.style.display = 'block';\r\n                amount.setAttribute('aria-invalid', 'true');\r\n                return;\r\n            }\r\n            else {\r\n                amount.setAttribute('aria-invalid', 'false');\r\n            }\r\n            this.showWithdrawConfirmation();\r\n        }));\r\n    }\r\n    showWithdrawConfirmation() {\r\n        if (!this.bankInfo)\r\n            return;\r\n        let amount = document.getElementById('amount');\r\n        let withdrawInput = document.getElementById('withdrawInput');\r\n        withdrawInput === null || withdrawInput === void 0 ? void 0 : withdrawInput.classList.add('hidden');\r\n        let withdrawConfirm = document.getElementById('withdrawConfirm');\r\n        withdrawConfirm === null || withdrawConfirm === void 0 ? void 0 : withdrawConfirm.classList.remove('hidden');\r\n        let withdrawAmountText = document.getElementById('withdrawAmountText');\r\n        let feeWarning = document.getElementById('feeWarning');\r\n        let feePercentage = document.getElementById('feePercentage');\r\n        withdrawAmountText.innerText = amount.value;\r\n        feeWarning.innerText = this.transferCost.toString();\r\n        feePercentage.innerText = roundNumber((this.transferCost / parseFloat(amount.value)) * 100).toString();\r\n        let confirmWithdrawButton = document.getElementById('confirmWithdrawButton');\r\n        confirmWithdrawButton === null || confirmWithdrawButton === void 0 ? void 0 : confirmWithdrawButton.addEventListener('click', (evt) => WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            yield this.userService.createTransfer(amount.value, TransferDirectionEnum.Outgoing)\r\n                .then((response) => WithdrawModal_awaiter(this, void 0, void 0, function* () {\r\n                let transfers = yield this.userService.getLatestTransfers(TransferDirectionEnum.Outgoing);\r\n                withdrawConfirm.innerHTML = yield this.transfersList.render(TransferDirectionEnum.Outgoing, transfers);\r\n                this.transfersList.bindEvents();\r\n            }))\r\n                .catch(reason => {\r\n                let withdrawError = document.getElementById('withdrawError');\r\n                if (!withdrawError)\r\n                    return;\r\n                if (withdrawError && isJSON(reason.message)) {\r\n                    let error = JSON.parse(reason.message);\r\n                    withdrawError.innerText = error.serverError.message;\r\n                }\r\n                else {\r\n                    withdrawError.innerText = reason.toString();\r\n                }\r\n                withdrawError.style.display = 'block';\r\n            });\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/AUsdBalance.ts\nvar AUsdBalance_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass AUsdBalance {\r\n    constructor(moralis, user) {\r\n        this.user = user;\r\n        this.moralis = moralis;\r\n    }\r\n    static forceLoadAUSDBalanceUI(moralis) {\r\n        return AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(moralis);\r\n            let user = userService.getUser();\r\n            let ui = new AUsdBalance(moralis, user);\r\n            AUSDService.lastUpdate = undefined;\r\n            yield ui.loadAUSDBalanceUI();\r\n        });\r\n    }\r\n    loadAUSDBalanceUI() {\r\n        return AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.user)\r\n                return;\r\n            let userInfoAUsdBalance = document.getElementById('userInfoAUsdBalance');\r\n            let frontpageAUsdBalance = document.getElementById('frontpageAUsdBalance');\r\n            if (!userInfoAUsdBalance)\r\n                return;\r\n            if (!this.user.get('alpacaId')) {\r\n                frontpageAUsdBalance === null || frontpageAUsdBalance === void 0 ? void 0 : frontpageAUsdBalance.classList.add('hidden');\r\n                userInfoAUsdBalance === null || userInfoAUsdBalance === void 0 ? void 0 : userInfoAUsdBalance.classList.add('hidden');\r\n                return;\r\n            }\r\n            else {\r\n                frontpageAUsdBalance === null || frontpageAUsdBalance === void 0 ? void 0 : frontpageAUsdBalance.classList.remove('hidden');\r\n                userInfoAUsdBalance === null || userInfoAUsdBalance === void 0 ? void 0 : userInfoAUsdBalance.classList.remove('hidden');\r\n            }\r\n            let aUSDService = new AUSDService(this.moralis);\r\n            let aUsdValueWei = yield aUSDService.getAUSDBalanceOf(this.user.get('ethAddress'));\r\n            let aUsdValue = roundBigNumber(aUsdValueWei);\r\n            let frontpageAUSDBalance = document.getElementById('front_page_aUSD_balance');\r\n            if (frontpageAUSDBalance)\r\n                frontpageAUSDBalance.innerHTML = '$' + aUsdValue;\r\n            let user_info_ausd_balance = document.getElementById('user_info_ausd_balance');\r\n            if (user_info_ausd_balance)\r\n                user_info_ausd_balance.innerHTML = '$' + aUsdValue;\r\n            this.bindEvents();\r\n            let balance_value = document.querySelector('.balance_value');\r\n            if (balance_value) {\r\n                balance_value.innerHTML = '$' + aUsdValue.toFixed();\r\n                balance_value.title = aUsdValueWei.toFixed();\r\n                balance_value.dataset['tooltip'] = aUsdValueWei.toFixed();\r\n            }\r\n            if (aUsdValue.isLessThan(10)) {\r\n                let frontpage_fund_account = document.getElementById('frontpage_fund_account');\r\n                frontpage_fund_account === null || frontpage_fund_account === void 0 ? void 0 : frontpage_fund_account.classList.remove('hidden');\r\n            }\r\n        });\r\n    }\r\n    bindEvents() {\r\n        let networkInfo = NetworkInfo.getInstance();\r\n        let add_aUSD_to_wallet = document.querySelectorAll('.add_aUSD_to_wallet');\r\n        add_aUSD_to_wallet.forEach(element => {\r\n            element.addEventListener('click', (evt) => AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                let contractInfo = ContractInfo.getContractInfo(networkInfo.Name);\r\n                let walletHelper = new WalletHelper(this.moralis);\r\n                yield walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, 'aUSD', () => {\r\n                    let template = Handlebars.compile(AddToWallet);\r\n                    let obj = { symbol: 'aUSD', address: contractInfo.AUSD_ADDRESS };\r\n                    let modal = new Modal();\r\n                    modal.showModal('Add aUSD token', template(obj));\r\n                });\r\n            }));\r\n        });\r\n        let fund_accountButtons = document.querySelectorAll('.fund_account');\r\n        fund_accountButtons.forEach(element => {\r\n            let aUSDFundingModal = new FakeAUSDFund(this.moralis);\r\n            if (networkInfo.TestNetwork) {\r\n                element.innerHTML = 'Click for some aUSD';\r\n                element.addEventListener('click', (evt) => {\r\n                    evt.preventDefault();\r\n                    aUSDFundingModal.showAUSDFakeFund(() => {\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                element.addEventListener('click', (evt) => AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    let aUsdFund = new AUSDFund(this.moralis);\r\n                    yield aUsdFund.show();\r\n                }));\r\n            }\r\n        });\r\n        let withdraw_from_account = document.getElementById('withdraw_from_account');\r\n        withdraw_from_account === null || withdraw_from_account === void 0 ? void 0 : withdraw_from_account.addEventListener('click', (evt) => AUsdBalance_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let withdrawModal = new WithdrawModal(this.moralis);\r\n            yield withdrawModal.show();\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/TestNetworkBanner.html\n// Module\nvar TestNetworkBanner_code = \"<div class=\\\"errorBar\\\">You are running on testnet. No real trades will be executed. <a href=\\\"#\\\"\\r\\n                                                                                      id=\\\"switch_from_test_network\\\">Switch\\r\\n    to mainnet</a></div>\";\n// Exports\n/* harmony default export */ const TestNetworkBanner = (TestNetworkBanner_code);\n;// CONCATENATED MODULE: ./src/ui/elements/UserInfo.ts\nvar UserInfo_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass UserInfo {\r\n    constructor(moralis, providerInfo, user) {\r\n        this.walletLoaded = false;\r\n        this.moralis = moralis;\r\n        this.user = user;\r\n        this.userService = new UserService(this.moralis);\r\n        this.providerInfo = providerInfo;\r\n        this.walletHelper = new WalletHelper(this.moralis);\r\n    }\r\n    render(elementId) {\r\n        return UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.user)\r\n                return;\r\n            this.listenForWalletChanges();\r\n            this.loadUserMenuUI(elementId);\r\n            this.loadIfTestNetwork();\r\n            this.ifTradePage();\r\n            let aUsdBalance = new AUsdBalance(this.moralis, this.user);\r\n            yield aUsdBalance.loadAUSDBalanceUI();\r\n        });\r\n    }\r\n    listenForWalletChanges() {\r\n        this.moralis.onChainChanged(function () {\r\n            location.reload();\r\n        });\r\n        this.moralis.onAccountChanged(function () {\r\n            location.reload();\r\n        });\r\n        this.moralis.onDisconnect(function () {\r\n            location.reload();\r\n        });\r\n        this.moralis.onConnect(function () {\r\n            location.reload();\r\n        });\r\n    }\r\n    loadUserMenuUI(elementId) {\r\n        return UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            if (!this.user)\r\n                return;\r\n            let userInfoDiv = document.getElementById(elementId);\r\n            if (!userInfoDiv)\r\n                return;\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            let obj = {\r\n                ethAddress: this.user.get('ethAddress'),\r\n                shortEthAddress: shortEth(this.user.get('ethAddress')),\r\n                walletName: this.providerInfo.WalletName,\r\n                networkName: networkInfo.ChainName + ((networkInfo.TestNetwork) ? ' - (Test network)' : ''),\r\n                blockchainExplorer: networkInfo.BlockExplorer + '/address/',\r\n                isMagic: yield this.walletHelper.isMagic(),\r\n                chainId: networkInfo.ChainId\r\n            };\r\n            let template = Handlebars.compile(elements_UserInfo);\r\n            let html = template(obj);\r\n            userInfoDiv.innerHTML = html;\r\n            this.bindEvents();\r\n            this.bindUserActionEvents();\r\n        });\r\n    }\r\n    bindUserActionEvents() {\r\n        let editName = document.getElementById('editName');\r\n        editName === null || editName === void 0 ? void 0 : editName.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let kycModal = new KycEditNameForm(this.moralis);\r\n            yield kycModal.show();\r\n        }));\r\n        let editContact = document.getElementById('editContact');\r\n        editContact === null || editContact === void 0 ? void 0 : editContact.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let kycModal = new KycEditContactForm(this.moralis);\r\n            yield kycModal.show();\r\n        }));\r\n        let editTrustedContact = document.getElementById('editTrustedContact');\r\n        editTrustedContact === null || editTrustedContact === void 0 ? void 0 : editTrustedContact.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let kycModal = new KycEditTrustedContact(this.moralis);\r\n            yield kycModal.show();\r\n        }));\r\n    }\r\n    bindEvents() {\r\n        return UserInfo_awaiter(this, void 0, void 0, function* () {\r\n            let userInfoDropdown = document.getElementById('userInfoDropdown');\r\n            if (!userInfoDropdown)\r\n                return;\r\n            document.body.addEventListener('click', (evt) => {\r\n                if (userInfoDropdown && !userInfoDropdown.classList.contains('d-none')) {\r\n                    userInfoDropdown.classList.add('d-none');\r\n                    evt.stopPropagation();\r\n                    evt.preventDefault();\r\n                }\r\n            });\r\n            let userInfoAction = document.getElementById('userInfoAction');\r\n            userInfoAction === null || userInfoAction === void 0 ? void 0 : userInfoAction.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                evt.stopPropagation();\r\n                userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.classList.toggle('d-none');\r\n                userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.addEventListener('click', (evt) => {\r\n                    evt.stopPropagation();\r\n                });\r\n                WalletHelper.hideMagicWallet();\r\n            });\r\n            let disconnectFromNetwork = document.getElementById('disconnectFromNetwork');\r\n            disconnectFromNetwork === null || disconnectFromNetwork === void 0 ? void 0 : disconnectFromNetwork.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                let userService = new UserService(this.moralis);\r\n                yield userService.logOut();\r\n                window.location.reload();\r\n            }));\r\n            let wallet = document.getElementById('wallet');\r\n            wallet === null || wallet === void 0 ? void 0 : wallet.addEventListener('click', (evt) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                LoadingHelper.setLoading(evt.target);\r\n                if (this.walletLoaded) {\r\n                    let magicIframe = document.querySelector('.magic-iframe');\r\n                    if (magicIframe)\r\n                        magicIframe.style.display = 'block';\r\n                    LoadingHelper.removeLoading();\r\n                    userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.classList.add('d-none');\r\n                    return;\r\n                }\r\n                this.moralis.connector.magic.connect.showWallet()\r\n                    .catch((e) => UserInfo_awaiter(this, void 0, void 0, function* () {\r\n                    this.walletLoaded = false;\r\n                    if (e.message.indexOf('User denied account access') != -1) {\r\n                        yield this.userService.logOut();\r\n                        alert('You have been logged out of you wallet and need to log back in. We will now reload the page and you can log in.');\r\n                        location.reload();\r\n                        return;\r\n                    }\r\n                    throw e;\r\n                }));\r\n                let closeMenuInterval = setInterval(() => {\r\n                    let magicIframe = document.querySelector('.magic-iframe');\r\n                    if (!magicIframe)\r\n                        clearInterval(closeMenuInterval);\r\n                    if (magicIframe && magicIframe.style.display == 'block') {\r\n                        LoadingHelper.removeLoading();\r\n                        userInfoDropdown === null || userInfoDropdown === void 0 ? void 0 : userInfoDropdown.classList.add('d-none');\r\n                        this.walletLoaded = true;\r\n                        clearInterval(closeMenuInterval);\r\n                    }\r\n                }, 1000);\r\n            }));\r\n            let switch_network = document.getElementById('switch_network');\r\n            switch_network === null || switch_network === void 0 ? void 0 : switch_network.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let switchNetworkModal = new SwitchNetworkModal(this.moralis);\r\n                switchNetworkModal.show();\r\n            });\r\n        });\r\n    }\r\n    loadIfTestNetwork() {\r\n        if (!this.moralis.isWeb3Enabled())\r\n            return;\r\n        if (!NetworkInfo.getInstance().TestNetwork)\r\n            return;\r\n        let header = document.querySelector('header');\r\n        if (!header)\r\n            return;\r\n        let template = Handlebars.compile(TestNetworkBanner);\r\n        header.insertAdjacentHTML('beforebegin', template({}));\r\n        let switch_from_test_network = document.getElementById('switch_from_test_network');\r\n        switch_from_test_network === null || switch_from_test_network === void 0 ? void 0 : switch_from_test_network.addEventListener('click', (evt) => {\r\n            let switchNetworkModal = new SwitchNetworkModal(this.moralis);\r\n            switchNetworkModal.show();\r\n        });\r\n    }\r\n    ifTradePage() {\r\n        let btn = document.getElementById('liminal_market_execute_trade');\r\n        if (!btn)\r\n            return;\r\n        ExecuteTradeButton.Instance.renderButton();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/ConnectWalletButton.html\n// Module\nvar ConnectWalletButton_code = \"<button class=\\\"liminal_market_connect_wallet outline\\\">Connect wallet</button>\";\n// Exports\n/* harmony default export */ const ConnectWalletButton = (ConnectWalletButton_code);\n;// CONCATENATED MODULE: ./src/ui/modals/ConnectWallet.ts\nvar ConnectWallet_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ConnectWallet {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.providerInfo = new ProviderInfo(null);\r\n    }\r\n    renderButton(elementId) {\r\n        if (!document.getElementById(elementId))\r\n            return;\r\n        document.getElementById(elementId).innerHTML = ConnectWalletButton;\r\n        let elements = document.querySelectorAll(\".liminal_market_connect_wallet\");\r\n        elements.forEach((el) => ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n            el.addEventListener('click', (evt) => ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                yield this.connectWallet(evt.target);\r\n            }));\r\n        }));\r\n    }\r\n    connectWallet(button) {\r\n        return ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n            LoadingHelper.setLoading(button);\r\n            let authenticationService = new AuthenticateService(this.moralis);\r\n            yield authenticationService.authenticateUser((walletConnectionInfo) => {\r\n                this.web3EnabledResult(walletConnectionInfo);\r\n            }, (user) => ConnectWallet_awaiter(this, void 0, void 0, function* () {\r\n                let userInfo = new UserInfo(this.moralis, this.providerInfo, user);\r\n                yield userInfo.render('user_header_info');\r\n                if (document.getElementById('liminal_market_execute_trade')) {\r\n                    let page = new TradePage(this.moralis);\r\n                    yield page.load();\r\n                }\r\n            }))\r\n                .catch((reason) => {\r\n                ErrorInfo.report(reason);\r\n            }).finally(() => {\r\n                LoadingHelper.removeLoading();\r\n            });\r\n        });\r\n    }\r\n    web3EnabledResult(walletConnectionInfo) {\r\n        this.providerInfo = new ProviderInfo(walletConnectionInfo);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/KYCService.ts\nvar KYCService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass KYCService extends BlockchainService {\r\n    constructor(moralis) {\r\n        super(moralis);\r\n    }\r\n    getKYCAbi() {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            if (KYCService.KYCInfo)\r\n                return KYCService.KYCInfo.abi;\r\n            const response = yield fetch(\"../abi/KYC.json\");\r\n            KYCService.KYCInfo = yield response.json();\r\n            return KYCService.KYCInfo.abi;\r\n        });\r\n    }\r\n    hasValidKYC() {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            if (KYCService.KycResponse && KYCService.KycResponse.isValidKyc)\r\n                return KYCService.KycResponse;\r\n            KYCService.KycResponse = (yield this.moralis.Cloud.run('isValidKyc', { chainId: this.moralis.chainId })\r\n                .catch(reason => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                if (blockchainError.addressIsNotValidKYC()) {\r\n                    return false;\r\n                }\r\n                ErrorInfo.report(blockchainError);\r\n                return false;\r\n            }));\r\n            if (KYCService.KycResponse.alpacaId) {\r\n                let user = this.moralis.User.current();\r\n                user === null || user === void 0 ? void 0 : user.set('alpacaId', KYCService.KycResponse.alpacaId);\r\n                let aUsdBalance = new AUsdBalance(this.moralis, user);\r\n                yield aUsdBalance.loadAUSDBalanceUI();\r\n            }\r\n            return KYCService.KycResponse;\r\n        });\r\n    }\r\n    saveKYCInfo(data) {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            let user = this.moralis.User.current();\r\n            if (!user)\r\n                throw new GeneralError(\"You need to be logged in to do KYC. Please login again.\");\r\n            return yield this.moralis.Cloud.run(\"kycRegistration\", data);\r\n        });\r\n    }\r\n    updateKYCInfo(data) {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            let user = this.moralis.User.current();\r\n            if (!user)\r\n                throw new GeneralError(\"You need to be logged in to do KYC. Please login again.\");\r\n            return yield this.moralis.Cloud.run(\"updateAccount\", data);\r\n        });\r\n    }\r\n    isValidAccountId(str) {\r\n        const regex = new RegExp('^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$');\r\n        return regex.test(str);\r\n    }\r\n    updateDocuments(params) {\r\n        return KYCService_awaiter(this, void 0, void 0, function* () {\r\n            let user = this.moralis.User.current();\r\n            if (!user)\r\n                throw new GeneralError(\"You need to be logged in to do KYC. Please login again.\");\r\n            return yield this.moralis.Cloud.run(\"kycActionRequiredUpdate\", params);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/blockchain/SecurityTokenService.ts\nvar SecurityTokenService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SecurityTokenService extends BlockchainService {\r\n    constructor(moralis) {\r\n        super(moralis);\r\n    }\r\n    getQuantityByAddress(symbol, ethAddress) {\r\n        return SecurityTokenService_awaiter(this, void 0, void 0, function* () {\r\n            let liminalMarketService = new LiminalMarketService(this.moralis);\r\n            let symbolAddress = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n            if (symbolAddress === Helper_AddressZero)\r\n                return new bignumber(0);\r\n            let options = yield this.getOptions('balanceOf', symbolAddress, {\r\n                account: ethAddress\r\n            });\r\n            return yield this.executeFunction(options)\r\n                .then(balanceOf => {\r\n                let amount = this.moralis.Units.FromWei(balanceOf.toString(), 18);\r\n                return new bignumber(amount);\r\n            }).catch(reason => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                ErrorInfo.report(blockchainError);\r\n                return new bignumber(0);\r\n            });\r\n        });\r\n    }\r\n    transfer(symbolAddress, qty) {\r\n        return SecurityTokenService_awaiter(this, void 0, void 0, function* () {\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let options = yield this.getOptions('transfer', symbolAddress, {\r\n                recipient: contractInfo.AUSD_ADDRESS,\r\n                amount: Moralis.Units.Token(qty.toString(), 18)\r\n            });\r\n            let result = yield this.executeFunction(options)\r\n                .then(result => {\r\n                return result;\r\n            })\r\n                .catch(reason => {\r\n                let blockchainError = new BlockchainError(reason);\r\n                throw ErrorInfo.report(blockchainError);\r\n            });\r\n            return result;\r\n        });\r\n    }\r\n    getOptions(functionName, symbolAddress, params) {\r\n        return SecurityTokenService_awaiter(this, void 0, void 0, function* () {\r\n            let securitySymbolAbi = yield this.getSecurityTokenAbi();\r\n            const options = {\r\n                contractAddress: symbolAddress,\r\n                functionName: functionName,\r\n                abi: securitySymbolAbi,\r\n                params: params\r\n            };\r\n            return options;\r\n        });\r\n    }\r\n    getSecurityTokenAbi() {\r\n        return SecurityTokenService_awaiter(this, void 0, void 0, function* () {\r\n            if (SecurityTokenService.SecurityTokenInfo)\r\n                return SecurityTokenService.SecurityTokenInfo.abi;\r\n            let response = yield fetch('../abi/SecurityToken.json');\r\n            SecurityTokenService.SecurityTokenInfo = yield response.json();\r\n            return SecurityTokenService.SecurityTokenInfo.abi;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/Progress.ts\nclass Progress {\r\n    show(message, percentage, warning, hideElements) {\r\n        let progress = document.getElementById('progress');\r\n        if (!progress)\r\n            return;\r\n        if (hideElements) {\r\n            hideElements.forEach((el) => {\r\n                let element = document.getElementById(el);\r\n                if (!element)\r\n                    return;\r\n                element.style.display = 'none';\r\n            });\r\n        }\r\n        progress.style.display = 'block';\r\n        progress.innerHTML = '<div class=\"progress_text\">' + message + '</div>';\r\n        progress.style.width = percentage + '%';\r\n        progress.classList.toggle('progress-bar-striped', (percentage != 100));\r\n        progress.classList.toggle('progress-bar-animated', (percentage != 100));\r\n        if (warning) {\r\n            progress.classList.add('bg-warning');\r\n            progress.classList.add('progress_text_attn');\r\n        }\r\n        else {\r\n            progress.classList.remove('bg-warning');\r\n            progress.classList.remove('progress_text_attn');\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/Subscription.ts\nvar Subscription_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass Subscription {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    getOrderBuyTablePrefix() {\r\n        let networkInfo = NetworkInfo.getInstance();\r\n        return networkInfo.Name;\r\n    }\r\n    ;\r\n    subscribeToTable(tradeType, onUpdateCallback) {\r\n        return Subscription_awaiter(this, void 0, void 0, function* () {\r\n            let tableName = this.getOrderBuyTablePrefix() + 'Order' + tradeType;\r\n            console.log('subscribe to table:' + tableName);\r\n            let query = new this.moralis.Query(tableName);\r\n            let subscription = yield query.subscribe();\r\n            subscription.on('update', (response) => {\r\n                const object = response.toJSON();\r\n                console.log('object updated', JSON.stringify(object), object);\r\n                let ethLink = ' <a class=\"white-link\" target=\"_blank\" href=\"https://mumbai.polygonscan.com/tx/' + object.transaction_hash + '\">View transaction</a>';\r\n                onUpdateCallback(object);\r\n                console.log('status:', object.status);\r\n                let progress = new Progress();\r\n                if ((!object.status && object.confirmed) || object.status == 'money_sent') {\r\n                    progress.show('Blockchain has confirmed, money has been sent to broker.' + ethLink, 56);\r\n                    //blockchain has confirmed, money will arrive soon to broker\r\n                }\r\n                else if (object.status == 'money_arrived') {\r\n                    progress.show('Money has arrived, will now execute your buy order.' + ethLink, 70);\r\n                    //money has arrived to broker, we will now execute your order\r\n                }\r\n                else if (object.status == 'order_requested') {\r\n                    //order has been executed, we are waiting on response from the stock exchange\r\n                    progress.show('Buy order has been executed. We will update you when it has been filled.' + ethLink, 84);\r\n                }\r\n                else if (object.status == 'order_filled') {\r\n                    //order has been filled, you got object.filledQty of shares. You will see it soon in your wallet\r\n                    progress.show('Order has been filled, you will receive ' + object.filledQty + ' ' + Symbol + ' soon into your wallet.' + ethLink, 100);\r\n                }\r\n                else {\r\n                    progress.show('Waiting for blockchain to confirm transaction.', 99);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    ;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/enums/TradeType.ts\nvar TradeType;\r\n(function (TradeType) {\r\n    TradeType[\"Sell\"] = \"Sell\";\r\n    TradeType[\"Buy\"] = \"Buy\";\r\n})(TradeType || (TradeType = {}));\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/ExecuteTradeButton.html\n// Module\nvar ExecuteTradeButton_code = \"<button id=\\\"liminal_market_execute_trade\\\"></button>\";\n// Exports\n/* harmony default export */ const tradepanel_ExecuteTradeButton = (ExecuteTradeButton_code);\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/TradeExecuted.html\n// Module\nvar TradeExecuted_code = \"\\r\\n<article class=\\\"trade_executed\\\">\\r\\n    <nav>\\r\\n    <ul>\\r\\n        <li>\\r\\n            <img src=\\\"{{sellingLogo}}\\\"><br />\\r\\n            {{sellingSymbol}}<br />\\r\\n            {{sellingAmount}}\\r\\n        </li>\\r\\n    </ul>\\r\\n    <ul>\\r\\n        <li> ----> </li>\\r\\n    </ul>\\r\\n    <ul>\\r\\n        <li>\\r\\n            <img src=\\\"{{buyingLogo}}\\\" /><br />\\r\\n            {{buyingSymbol}}<br />\\r\\n            <abbr title=\\\"{{buyingQuantity}}\\\" data-tooltip=\\\"{{buyingQuantity}}\\\">{{buyingRoundQuantity}}</abbr>\\r\\n        </li>\\r\\n    </ul>\\r\\n    </nav>\\r\\n    <div>\\r\\n        If you haven't already, add the {{buyingSymbol}} to your wallet.\\r\\n        <br /><br />\\r\\n        <button id=\\\"addTokenToWallet\\\" data-address=\\\"{{tokenAddress}}\\\">Add {{buyingSymbol}} to wallet</button>\\r\\n        <div id=\\\"addTokenToWalletFailed\\\" class=\\\"d-none\\\">\\r\\n            You can copy the address, to import the token\\r\\n            <input value=\\\"{{tokenAddress}}\\\" />\\r\\n        </div>\\r\\n        <br />\\r\\n        Should be visible in your {{walletName}} on address {{shortEthAddress}}.\\r\\n        <br /><br />\\r\\n        <small>You can view the <a href=\\\"{{blockExplorerLink}}\\\" target=\\\"_blank\\\">block transaction here</a></small>\\r\\n    </div>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const TradeExecuted = (TradeExecuted_code);\n;// CONCATENATED MODULE: ./src/html/modal/FakeNativeTokenNeeded.html\n// Module\nvar FakeNativeTokenNeeded_code = \"You need to have {{symbol}} currency in your wallet. You use {{symbol}} to pay for using the blockchain.\\r\\n\\r\\nTo get some {{symbol}} currency\\r\\n<ol>\\r\\n    <li>Copy your address shown below\\r\\n        <input value=\\\"{{ethAddress}}\\\" />\\r\\n    </li>\\r\\n    <li>Open <a href=\\\"{{faucetUrl}}\\\" id=\\\"getNativeTokens\\\" target=\\\"_blank\\\">{{faucetUrl}}</a></li>\\r\\n    <li>Paste in your address you just copied and click the submit button</li>\\r\\n</ol>\\r\\n\\r\\n<div class=\\\"infoBar d-none\\\" id=\\\"waitingForNativeToken\\\">Waiting for {{symbol}}. Window will close when you have some in\\r\\n    you wallet.\\r\\n    It might take few minutes after you requested it.\\r\\n    <progress></progress>\\r\\n</div>\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\";\n// Exports\n/* harmony default export */ const FakeNativeTokenNeeded = (FakeNativeTokenNeeded_code);\n;// CONCATENATED MODULE: ./src/html/modal/NativeTokenNeeded.html\n// Module\nvar NativeTokenNeeded_code = \"You need to have {{symbol}} currency in your wallet. You use {{symbol}} to pay for using the blockchain.\\r\\n\\r\\nTo get some {{symbol}} currency\\r\\n<ol>\\r\\n    <li>Copy your address shown below\\r\\n        <input value=\\\"{{ethAddress}}\\\" />\\r\\n    </li>\\r\\n    <li>Open <a href=\\\"{{buyUrl}}\\\" target=\\\"_blank\\\">{{buyUrl}}</a></li>\\r\\n    <li>Paste in your address you just copied and click the submit button</li>\\r\\n</ol>\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\";\n// Exports\n/* harmony default export */ const modal_NativeTokenNeeded = (NativeTokenNeeded_code);\n;// CONCATENATED MODULE: ./src/ui/modals/NativeTokenNeeded.ts\nvar NativeTokenNeeded_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass NativeTokenNeeded {\r\n    constructor(moralis, onNativeTokenArrived) {\r\n        this.timeOut = undefined;\r\n        this.moralis = moralis;\r\n        this.onNativeTokenArrived = onNativeTokenArrived;\r\n        this.modal = new Modal();\r\n    }\r\n    show() {\r\n        let networkInfo = NetworkInfo.getInstance();\r\n        let userService = new UserService(this.moralis);\r\n        let ethAddress = userService.getEthAddress();\r\n        if (networkInfo.TestNetwork) {\r\n            let template = Handlebars.compile(FakeNativeTokenNeeded);\r\n            let content = template({ symbol: networkInfo.NativeSymbol, faucetUrl: networkInfo.FaucetUrl, ethAddress: ethAddress });\r\n            this.modal.showModal('Get some ' + networkInfo.NativeSymbol, content, false, () => {\r\n                this.cancelTimer();\r\n            });\r\n        }\r\n        else {\r\n            let template = Handlebars.compile(modal_NativeTokenNeeded);\r\n            let content = template({ symbol: networkInfo.NativeSymbol, buyUrl: networkInfo.BuyUrl, ethAddress: ethAddress });\r\n            this.modal.showModal('Get some ' + networkInfo.NativeSymbol, content, false, () => {\r\n                this.cancelTimer();\r\n            });\r\n        }\r\n        let link = document.getElementById('getNativeTokens');\r\n        if (!link)\r\n            return;\r\n        link.addEventListener('click', () => NativeTokenNeeded_awaiter(this, void 0, void 0, function* () {\r\n            let waitingForNativeToken = document.getElementById('waitingForNativeToken');\r\n            waitingForNativeToken === null || waitingForNativeToken === void 0 ? void 0 : waitingForNativeToken.classList.remove('d-none');\r\n            yield this.checkForNativeTokens();\r\n        }));\r\n    }\r\n    cancelTimer() {\r\n        if (this.timeOut)\r\n            clearTimeout(this.timeOut);\r\n    }\r\n    checkForNativeTokens() {\r\n        return NativeTokenNeeded_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            let hasEnoughNativeTokens = yield networkInfo.hasEnoughNativeTokens(this.moralis);\r\n            if (hasEnoughNativeTokens) {\r\n                this.modal.hideModal();\r\n                this.onNativeTokenArrived();\r\n            }\r\n            else {\r\n                this.timeOut = setTimeout(() => this.checkForNativeTokens(), 5 * 1000);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycActionRequired.html\n// Module\nvar KycActionRequired_code = \"<div id=\\\"kycActionRequiredDiv\\\">\\r\\n\\r\\n    {{#if Other}}\\r\\n    <strong>This is the message from KYC processor we received</strong>\\r\\n    <blockquote>\\r\\n        {{Other}}\\r\\n    </blockquote>\\r\\n    {{/if}}\\r\\n    <form novalidate id=\\\"kycActionRequiredForm\\\" name=\\\"kycActionRequiredForm\\\" onsubmit=\\\"return false;\\\">\\r\\n        {{{KycInfo}}}\\r\\n        {{#if SubmitData}}\\r\\n        <div class=\\\"input_error\\\" id=\\\"kycActionRequiredError\\\"></div>\\r\\n        <div class=\\\"buttons\\\">\\r\\n            <button type=\\\"submit\\\" id=\\\"kycActionRequiredSubmit\\\">Send new information</button>\\r\\n        </div>\\r\\n        {{/if}}\\r\\n    </form>\\r\\n</div>\\r\\n\\r\\n<div id=\\\"kycActionRequiredSubmittedDiv\\\" class=\\\"hidden center\\\">\\r\\n    <h3>You documents have been submitted.<br/>We will email you when your account is ready.</h3>\\r\\n    You can close this window.\\r\\n</div>\";\n// Exports\n/* harmony default export */ const Kyc_KycActionRequired = (KycActionRequired_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/WeDontKnowWhy.html\n// Module\nvar WeDontKnowWhy_code = \"<fieldset>\\r\\n    Your application has been rejected during KYC process.<br/><br/>\\r\\n    We don't have the information on why that happened, but you can email us at\\r\\n    <a href='mailto:info@liminal.market?subject=My application was rejected&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\\r\\n    and we can find out, and we should be able to solve it together.\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const WeDontKnowWhy = (WeDontKnowWhy_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/IDENTITY_VERIFICATION.html\n// Module\nvar IDENTITY_VERIFICATION_code = \"<fieldset>\\r\\n    <p>\\r\\n        Identity needs to be verified.\\r\\n        This means you need to upload\\r\\n        a new photo of your id. You might try another type of ID, such as\\r\\n        driver's license if you tried passport before\\r\\n    </p>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Photo ID Front (Front of passport)\\\"}}}\\r\\n    </div>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification_2\\\" \\\"Photo ID Back (Passport picture of ID) \\\"}}}\\r\\n    </div>\\r\\n\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const IDENTITY_VERIFICATION = (IDENTITY_VERIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/ADDRESS_VERIFICATION.html\n// Module\nvar ADDRESS_VERIFICATION_code = \"<fieldset>\\r\\n    <p>\\r\\n        Address needs to be verified. Please upload document that confirms your address.\\r\\n        A bill from the government or utility company in that last 30 days with your name it should work.\\r\\n    </p>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"address_verification\\\" \\\"Picture of address verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const ADDRESS_VERIFICATION = (ADDRESS_VERIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/AFFILIATED.html\n// Module\nvar AFFILIATED_code = \"<fieldset>\\r\\n    Further information needs to be submitted if account owner is affiliated to finra or an exchange\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const AFFILIATED = (AFFILIATED_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/CONTROL_PERSON.html\n// Module\nvar CONTROL_PERSON_code = \"<fieldset>\\r\\n    Further information needs to be submitted if account owner is a control person\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const CONTROL_PERSON = (CONTROL_PERSON_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/COUNTRY_NOT_SUPPORTED.html\n// Module\nvar COUNTRY_NOT_SUPPORTED_code = \"<fieldset>\\r\\n    The account owners country of tax residence is not supported by our KYC providers.\\r\\n    In this case, well manually perform KYC on the user\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const COUNTRY_NOT_SUPPORTED = (COUNTRY_NOT_SUPPORTED_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/DATE_OF_BIRTH.html\n// Module\nvar DATE_OF_BIRTH_code = \"<fieldset>\\r\\n    Date of birth needs to be verified. Please upload document that confirms your date of birth.\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"date_of_birth_verification\\\" \\\"Date of birth verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const DATE_OF_BIRTH = (DATE_OF_BIRTH_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/FAMILY_MEMBER_PEP.html\n// Module\nvar FAMILY_MEMBER_PEP_code = \"<fieldset>\\r\\n    Further information needs to be submitted if family member is a politically exposed person\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const FAMILY_MEMBER_PEP = (FAMILY_MEMBER_PEP_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/INVALID_IDENTITY_PASSPORT.html\n// Module\nvar INVALID_IDENTITY_PASSPORT_code = \"<fieldset>\\r\\n    Identity needs to be verified via a government issued ID.\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Photo ID Front (Front of passport)\\\"}}}\\r\\n    </div>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification_2\\\" \\\"Photo ID Back (Passport picture of ID) \\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const INVALID_IDENTITY_PASSPORT = (INVALID_IDENTITY_PASSPORT_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/PEP.html\n// Module\nvar PEP_code = \"<fieldset>\\r\\n    Further information needs to be submitted if account owner is politically exposed person\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const PEP = (PEP_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/SELFIE_VERIFICATION.html\n// Module\nvar SELFIE_VERIFICATION_code = \"<fieldset>\\r\\n    Identity needs to be verified via a live selfie of the account owner\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Live selfie verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const SELFIE_VERIFICATION = (SELFIE_VERIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/TAX_IDENTIFICATION.html\n// Module\nvar TAX_IDENTIFICATION_code = \"<fieldset>\\r\\n    Tax ID number needs to be verified. Please upload document that confirms your Tax Id\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"tax_id_verification\\\" \\\"Tax id verification\\\"}}}\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const TAX_IDENTIFICATION = (TAX_IDENTIFICATION_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/VISA_TYPE_OTHER.html\n// Module\nvar VISA_TYPE_OTHER_code = \"<fieldset>\\r\\n    Further information needs to be submitted about account owners visa\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const VISA_TYPE_OTHER = (VISA_TYPE_OTHER_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/ActionRequired/W8BEN_CORRECTION.html\n// Module\nvar W8BEN_CORRECTION_code = \"<fieldset>\\r\\n    Identifying information submitted by the user was incorrect so a new, corrected, W8BEN needs to be submitted\\r\\n    <br/>\\r\\n    Please contact us at <a href=\\\"mailto:info@liminal.market\\\">info@liminal.market</a> for further information\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const W8BEN_CORRECTION = (W8BEN_CORRECTION_code);\n;// CONCATENATED MODULE: ./src/html/elements/FileUpload.html\n// Module\nvar FileUpload_code = \"<div>\\r\\n    <label for=\\\"{{inputId}}\\\">{{label}}</label>\\r\\n    <input type=\\\"file\\\" required id=\\\"{{inputId}}\\\" accept=\\\"{{accept}}\\\" capture=\\\"{{capture}}\\\"/>\\r\\n    <input type=\\\"hidden\\\" id=\\\"{{inputId}}_base64\\\" name=\\\"{{inputId}}_base64\\\"/>\\r\\n    <div class=\\\"error hidden\\\" id=\\\"{{inputId}}_error\\\"></div>\\r\\n</div>\\r\\n<div id=\\\"{{inputId}}_preview\\\">\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const elements_FileUpload = (FileUpload_code);\n;// CONCATENATED MODULE: ./src/ui/elements/FileUpload.ts\n\r\nclass FileUpload {\r\n    constructor(inputId, label, accept = \"image/png,image/jpeg,.pdf\", capture = 'environment') {\r\n        this.maxFileSize = 8 * 1024 * 1024 * 10; //10MB\r\n        this.accept = \"image/*,.pdf\";\r\n        this.capture = 'environment';\r\n        this.inputId = inputId;\r\n        this.label = label;\r\n        this.accept = accept;\r\n        this.capture = capture;\r\n    }\r\n    render() {\r\n        let template = Handlebars.compile(elements_FileUpload);\r\n        return template(this);\r\n    }\r\n    bindEvents() {\r\n        let fileInput = document.getElementById(this.inputId);\r\n        fileInput === null || fileInput === void 0 ? void 0 : fileInput.addEventListener('change', (evt) => {\r\n            this.processFile(fileInput);\r\n        });\r\n    }\r\n    processFile(element) {\r\n        this.hideFileRelatedInfo(element.id);\r\n        let files = element.files;\r\n        if (!files)\r\n            return;\r\n        let file = files[0];\r\n        if (!file) {\r\n            this.showFileRelatedInfo(element.id, 'No file selected. Please select file.');\r\n            this.setBase64Input(element.id, '');\r\n            return;\r\n        }\r\n        if (file.size > this.maxFileSize) {\r\n            this.showFileRelatedInfo(element.id, 'File ' + file.name + ' is to large. Files cannot be larger then 10MB. You need to make it smaller before submitting your application');\r\n            this.setBase64Input(element.id, '');\r\n            return;\r\n        }\r\n        let reader = new FileReader();\r\n        reader.addEventListener('load', () => {\r\n            this.setBase64Input(element.id, reader.result);\r\n        });\r\n        reader.addEventListener('error', () => {\r\n            this.showFileRelatedInfo(element.id, 'Could not read file ' + file.name + '. Either the file is corrupt or your browser does not allow us to read it');\r\n        });\r\n        reader.readAsDataURL(file);\r\n    }\r\n    setBase64Input(elementId, value) {\r\n        let base64Input = document.getElementById(elementId + '_base64');\r\n        base64Input.value = value;\r\n        let previewElement = document.getElementById(elementId + '_preview');\r\n        if (!previewElement)\r\n            return;\r\n        if (value.indexOf('data:image') != -1) {\r\n            previewElement.innerHTML = '<img src=\"' + base64Input.value + '\" />';\r\n        }\r\n        else {\r\n            previewElement.innerHTML = '';\r\n        }\r\n    }\r\n    showFileRelatedInfo(elementId, text) {\r\n        let fileRelatedInfo = document.getElementById(elementId + '_error');\r\n        if (!fileRelatedInfo)\r\n            return;\r\n        fileRelatedInfo.innerHTML = text;\r\n        fileRelatedInfo.classList.remove('hidden');\r\n    }\r\n    hideFileRelatedInfo(elementId) {\r\n        let fileRelatedInfo = document.getElementById(elementId + '_error');\r\n        if (!fileRelatedInfo)\r\n            return;\r\n        fileRelatedInfo.classList.add('hidden');\r\n    }\r\n    static registerHandler() {\r\n        Handlebars.registerHelper('fileUpload', (id, label) => {\r\n            let fileUpload = new FileUpload(id, label);\r\n            FileUpload.fileUploads.push(fileUpload);\r\n            return fileUpload.render();\r\n        });\r\n    }\r\n}\r\nFileUpload.fileUploads = [];\r\n\n;// CONCATENATED MODULE: ./src/util/FormValidator.ts\n\r\nclass FormValidator {\r\n    constructor(selector) {\r\n        this.selector = selector;\r\n    }\r\n    validateRequiredFields() {\r\n        let inputs = document.querySelectorAll(this.selector + ' input[required], ' + this.selector + ' select[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (this.isMissingInputFromUser(input)) {\r\n                let obj = {\r\n                    message: 'You must fill into this field',\r\n                    inputName: input.id,\r\n                    labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                    pattern: input.pattern\r\n                };\r\n                this.handle(obj);\r\n                return false;\r\n            }\r\n            if (input.pattern) {\r\n                let pattern = input.pattern;\r\n                let matches = input.value.match(pattern);\r\n                if (matches == null) {\r\n                    let obj = {\r\n                        message: 'This is not valid date format, please use YYYY-MM-DD (year-month-date)',\r\n                        inputName: input.id,\r\n                        labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                        pattern: input.pattern\r\n                    };\r\n                    this.handle(obj);\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    isMissingInputFromUser(input) {\r\n        return ((input.type == 'checkbox' && !input.checked) || StringHelper.isNullOrEmpty(input.value));\r\n    }\r\n    removeMissingInfo(errorDivId, focusElementId) {\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.style.display = 'none';\r\n        if (!focusElementId)\r\n            return;\r\n        let focusElement = document.getElementById(focusElementId);\r\n        if (focusElement) {\r\n            focusElement.removeAttribute('aria-invalid');\r\n        }\r\n    }\r\n    setMissingInfo(errorDivId, text, focusElementId) {\r\n        var _a, _b;\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = text;\r\n        if (text == '') {\r\n            element.style.display = 'none';\r\n        }\r\n        else {\r\n            element.style.display = 'block';\r\n            if (focusElementId) {\r\n                (_a = document.getElementById(focusElementId)) === null || _a === void 0 ? void 0 : _a.focus();\r\n                (_b = document.getElementById(focusElementId)) === null || _b === void 0 ? void 0 : _b.setAttribute('aria-invalid', 'true');\r\n            }\r\n        }\r\n    }\r\n    handle(obj) {\r\n        let input = document.getElementById(obj.inputName);\r\n        if (!input)\r\n            return;\r\n        let inputError = input.parentElement.querySelector('.input_error');\r\n        if (inputError) {\r\n            inputError.scrollIntoView({ block: 'center' });\r\n            return;\r\n        }\r\n        input.setAttribute('aria-invalid', 'true');\r\n        input.insertAdjacentHTML(\"beforebegin\", '<div class=\"input_error\" style=\"display: block\" id=\"input_error_' + obj.inputName + '\">' + obj.message + '</div>');\r\n        input.focus();\r\n        if (obj.pattern) {\r\n            input.setAttribute('pattern', obj.pattern);\r\n        }\r\n        input.addEventListener('blur', (evt) => {\r\n            evt.preventDefault();\r\n            setTimeout(() => {\r\n                let input = evt.target;\r\n                let pattern = input.getAttribute('pattern');\r\n                if ((pattern && input.value.match(pattern)) || (input.required && input.value) || input.checked) {\r\n                    input.removeAttribute('aria-invalid');\r\n                    let errorMessage = document.getElementById('input_error_' + obj.inputName);\r\n                    if (errorMessage)\r\n                        errorMessage.remove();\r\n                }\r\n            }, 800);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycActionRequired.ts\nvar KycActionRequired_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycActionRequired {\r\n    constructor(executeTradeButton) {\r\n        this.modal = new Modal();\r\n        this.templates = new Map();\r\n        this.executeTradeButton = executeTradeButton;\r\n        this.templates.set('WeDontKnowWhyHtml', WeDontKnowWhy);\r\n        this.templates.set('ADDRESS_VERIFICATION', ADDRESS_VERIFICATION);\r\n        this.templates.set('AFFILIATED', AFFILIATED);\r\n        this.templates.set('CONTROL_PERSON', CONTROL_PERSON);\r\n        this.templates.set('COUNTRY_NOT_SUPPORTED', COUNTRY_NOT_SUPPORTED);\r\n        this.templates.set('DATE_OF_BIRTH', DATE_OF_BIRTH);\r\n        this.templates.set('FAMILY_MEMBER_PEP', FAMILY_MEMBER_PEP);\r\n        this.templates.set('IDENTITY_VERIFICATION', IDENTITY_VERIFICATION);\r\n        this.templates.set('INVALID_IDENTITY_PASSPORT', INVALID_IDENTITY_PASSPORT);\r\n        this.templates.set('PEP', PEP);\r\n        this.templates.set('SELFIE_VERIFICATION', SELFIE_VERIFICATION);\r\n        this.templates.set('TAX_IDENTIFICATION', TAX_IDENTIFICATION);\r\n        this.templates.set('VISA_TYPE_OTHER', VISA_TYPE_OTHER);\r\n        this.templates.set('W8BEN_CORRECTION', W8BEN_CORRECTION);\r\n        FileUpload.registerHandler();\r\n    }\r\n    show() {\r\n        return KycActionRequired_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(Moralis);\r\n            let kycResult = yield userService.kycActionRequired();\r\n            if (!kycResult)\r\n                return;\r\n            let kycInfo = this.getKycMessages(kycResult.messages);\r\n            let template = Handlebars.compile(Kyc_KycActionRequired);\r\n            let content = template({\r\n                json: JSON.stringify(kycResult),\r\n                KycInfo: kycInfo,\r\n                Other: kycResult.additional_information,\r\n                SubmitData: kycInfo.indexOf('<input') != -1\r\n            });\r\n            this.modal.showModal('Action required', content, false, () => {\r\n            }, false);\r\n            let kycActionRequiredForm = document.getElementById('kycActionRequiredForm');\r\n            kycActionRequiredForm === null || kycActionRequiredForm === void 0 ? void 0 : kycActionRequiredForm.addEventListener('submit', (evt) => KycActionRequired_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                this.hideError();\r\n                let submitBtn = document.getElementById('kycActionRequiredSubmit');\r\n                LoadingHelper.setLoading(submitBtn);\r\n                let formValidator = new FormValidator('#kycActionRequiredForm');\r\n                if (!formValidator.validateRequiredFields())\r\n                    return;\r\n                let params = FormHelper.getParams('#kycActionRequiredForm');\r\n                let kycService = new KYCService(Moralis);\r\n                yield kycService.updateDocuments(params)\r\n                    .then(() => {\r\n                    let kycActionRequiredDiv = document.getElementById('kycActionRequiredDiv');\r\n                    kycActionRequiredDiv === null || kycActionRequiredDiv === void 0 ? void 0 : kycActionRequiredDiv.classList.add('hidden');\r\n                    let kycActionRequiredSubmittedDiv = document.getElementById('kycActionRequiredSubmittedDiv');\r\n                    kycActionRequiredSubmittedDiv === null || kycActionRequiredSubmittedDiv === void 0 ? void 0 : kycActionRequiredSubmittedDiv.classList.remove('hidden');\r\n                    this.executeTradeButton.checkKycIsDone();\r\n                    this.executeTradeButton.renderButton();\r\n                })\r\n                    .catch(reason => {\r\n                    this.showError(reason);\r\n                }).finally(() => {\r\n                    LoadingHelper.removeLoading();\r\n                });\r\n            }));\r\n            for (let i = 0; i < FileUpload.fileUploads.length; i++) {\r\n                FileUpload.fileUploads[i].bindEvents();\r\n            }\r\n        });\r\n    }\r\n    getKycMessages(messages) {\r\n        let kycInfo = '';\r\n        for (let i = 0; i < messages.length; i++) {\r\n            let htmlTemplate = this.templates.get(messages[i].key);\r\n            if (!htmlTemplate) {\r\n                //TODO: Here we should to logger, critical that we dont know why\r\n                continue;\r\n            }\r\n            let template = Handlebars.compile(htmlTemplate);\r\n            kycInfo += template({ message: messages[i].message });\r\n        }\r\n        if (kycInfo == '') {\r\n            let html = this.templates.get('WeDontKnowWhyHtml');\r\n            let template = Handlebars.compile(html);\r\n            kycInfo = template({});\r\n        }\r\n        return kycInfo;\r\n    }\r\n    hideError() {\r\n        let kycActionRequiredError = document.getElementById('kycActionRequiredError');\r\n        if (!kycActionRequiredError)\r\n            return;\r\n        kycActionRequiredError.style.display = 'none';\r\n    }\r\n    showError(reason) {\r\n        let kycActionRequiredError = document.getElementById('kycActionRequiredError');\r\n        if (!kycActionRequiredError)\r\n            return;\r\n        kycActionRequiredError.innerHTML = 'Error occurred while saving your documents. Reason:' + reason;\r\n        kycActionRequiredError.style.display = 'block';\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/KYCModal.html\n// Module\nvar KYCModal_code = \"<div id=\\\"kyc_reg\\\">\\r\\n\\r\\n    <form id=\\\"kyc_wizard_form\\\" name=\\\"kyc_wizard_form\\\" novalidate onsubmit=\\\"return false\\\">\\r\\n        {{{KycContactHtml}}}\\r\\n        {{{KycIdentityHtml}}}\\r\\n        {{{KycTrustedContactHtml}}}\\r\\n        {{{KycDisclosureHtml}}}\\r\\n        {{{KycUploadHtml}}}\\r\\n        {{{KycAccountAgreementHtml}}}\\r\\n    </form>\\r\\n</div>\\r\\n\\r\\n<div id=\\\"waiting_for_kyc_reg\\\" class=\\\"hidden\\\">\\r\\n    KYC is being processed. This may take about 4-5 minutes. Window will close when it's done.\\r\\n    <br/><br/>\\r\\n    You can close the window, we will email you when KYC is finished.\\r\\n\\r\\n    <progress></progress>\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const KYCModal = (KYCModal_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycContact.html\n// Module\nvar KycContact_code = \"<fieldset class=\\\"kycContact hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"explain\\\">\\r\\n        To be able to trade on the stock market, we need to get your information.\\r\\n        This is a requirement from the financial regulators.\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"email_address\\\">Email</label>\\r\\n        <input type=\\\"email\\\" required class=\\\"form-control\\\" id=\\\"email_address\\\" name=\\\"email_address\\\"\\r\\n               placeholder=\\\"name@example.com\\\" autocomplete=\\\"email\\\"\\r\\n               value=\\\"\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"phone_number\\\">Phone</label>\\r\\n        <input type=\\\"tel\\\" class=\\\"form-control\\\" id=\\\"phone_number\\\" name=\\\"phone_number\\\"\\r\\n               placeholder=\\\"+1-555-666-7788\\\" autocomplete=\\\"tel\\\" value=\\\"\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"street_address\\\">Permanent Residential Address</label>\\r\\n        <div class=\\\"explain\\\">It must be a physical address, not a PO box.</div>\\r\\n        <input required id=\\\"street_address\\\" name=\\\"street_address\\\"\\r\\n               placeholder=\\\"20 N San Mateo Dr\\\" value=\\\"\\\" autocomplete=\\\"address-line1\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"unit\\\">Unit / Apt #</label>\\r\\n        <input id=\\\"unit\\\" name=\\\"unit\\\" value=\\\"\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"city\\\">City</label>\\r\\n        <input id=\\\"city\\\" name=\\\"city\\\" placeholder=\\\"Pawnee\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"address-level2\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"postal_code\\\">Postal code</label>\\r\\n        <input required id=\\\"postal_code\\\" autocomplete=\\\"postal-code\\\" name=\\\"postal_code\\\"\\r\\n               placeholder=\\\"94401\\\"\\r\\n               value=\\\"\\\">\\r\\n    </div>\\r\\n    <div id=\\\"state_div\\\">\\r\\n        <label for=\\\"state\\\">State (2 letters)</label>\\r\\n        <input maxlength=\\\"2\\\" id=\\\"state\\\" name=\\\"state\\\" placeholder=\\\"NY\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"address-level1\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"country_of_tax_residence\\\">Country of tax residence</label>\\r\\n        {{#if edit}}\\r\\n        <input name=\\\"country_of_tax_residence\\\" readonly id=\\\"country_of_tax_residence\\\"/>\\r\\n        {{/if}}\\r\\n        {{#unless edit}}\\r\\n        <select required id=\\\"country_of_tax_residence\\\" name=\\\"country_of_tax_residence\\\" autocomplete=\\\"country\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n        {{/unless}}\\r\\n    </div>\\r\\n    <div class=\\\"buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"contact_next\\\">Next: Identity</button>\\r\\n    </div>\\r\\n</fieldset>\\r\\n\";\n// Exports\n/* harmony default export */ const Kyc_KycContact = (KycContact_code);\n;// CONCATENATED MODULE: ./src/errors/cloud/KycValidatorError.ts\nvar KycValidatorError_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\nclass KycValidatorError {\r\n    constructor(error, kycForm) {\r\n        var _a, _b;\r\n        this.validValues = '';\r\n        this.inputName = '';\r\n        this.labelText = '';\r\n        this.pattern = '';\r\n        let obj = {};\r\n        try {\r\n            if (!error.inputName) {\r\n                obj = JSON.parse(error);\r\n            }\r\n            else {\r\n                obj = error;\r\n            }\r\n            this.message = (_a = obj.message) === null || _a === void 0 ? void 0 : _a.replace(/_/g, ' ');\r\n            this.validValues = (_b = obj.validValues) === null || _b === void 0 ? void 0 : _b.replace(/_/g, ' ');\r\n            this.inputName = obj.inputName;\r\n            this.labelText = obj.labelText;\r\n            this.pattern = obj.pattern;\r\n            this.onshow = obj.onshow;\r\n        }\r\n        catch (e) {\r\n            this.message = error.messsage;\r\n        }\r\n        this.kycForm = kycForm;\r\n    }\r\n    handle() {\r\n        if (StringHelper.isNullOrEmpty(this.inputName)) {\r\n            let activeFieldset = document.querySelector(this.kycForm.activeFieldsetSelector);\r\n            let inputError = activeFieldset.querySelector('.input_error');\r\n            if (inputError) {\r\n                if (this.validValues) {\r\n                    inputError.innerHTML = this.validValues.toString();\r\n                }\r\n                else {\r\n                    if (this.message && this.message.indexOf('Invalid function') != -1 || this.message.indexOf('Unable to connect to the Parse API') != -1) {\r\n                        inputError.innerHTML = 'We just deployed new version of our website. This can cause interruption. Please wait 30 seconds and submit again';\r\n                    }\r\n                    else {\r\n                        inputError.innerHTML = this.message;\r\n                    }\r\n                }\r\n                inputError.style.display = 'block';\r\n                inputError.scrollIntoView();\r\n            }\r\n            return;\r\n        }\r\n        let input = document.getElementById(this.inputName);\r\n        if (!input)\r\n            return;\r\n        let inputError = input.parentElement.querySelector('.input_error');\r\n        if (inputError) {\r\n            inputError.scrollIntoView({ block: 'center' });\r\n            return;\r\n        }\r\n        input.setAttribute('aria-invalid', 'true');\r\n        let errorInput = '<div class=\"input_error\" style=\"display: block\" id=\"input_error_' + this.inputName + '\">' + this.message + '</div>';\r\n        if (input.clientWidth < 300) {\r\n            let div = this.getDivToDisplayErrorMessage(input);\r\n            div.insertAdjacentHTML(\"beforebegin\", errorInput);\r\n        }\r\n        else {\r\n            input.insertAdjacentHTML(\"beforebegin\", errorInput);\r\n        }\r\n        input.focus();\r\n        if (this.pattern) {\r\n            input.setAttribute('pattern', this.pattern);\r\n        }\r\n        input.addEventListener('blur', (evt) => {\r\n            evt.preventDefault();\r\n            setTimeout(() => {\r\n                let input = evt.target;\r\n                let pattern = input.getAttribute('pattern');\r\n                if ((pattern && input.value.match(pattern)) || (input.type != 'checkbox' && input.type != 'radio' && input.required && input.value) || input.checked) {\r\n                    input.removeAttribute('aria-invalid');\r\n                    let errorMessage = document.getElementById('input_error_' + this.inputName);\r\n                    if (errorMessage)\r\n                        errorMessage.remove();\r\n                }\r\n            }, 800);\r\n        });\r\n        let fieldsetElement = input.closest('fieldset[data-form=\"1\"]');\r\n        if (fieldsetElement) {\r\n            let className = fieldsetElement.className.replace('hidden', '').trim();\r\n            this.kycForm.show(className);\r\n            input.scrollIntoView(false);\r\n        }\r\n        if (this.onshow) {\r\n            let link = document.getElementById(this.onshow.id);\r\n            if (!link)\r\n                return;\r\n            link.addEventListener('click', (evt) => KycValidatorError_awaiter(this, void 0, void 0, function* () {\r\n                evt.preventDefault();\r\n                yield Moralis.Cloud.run(this.onshow.functionName, this.onshow.params);\r\n                document.getElementById('input_error_' + this.inputName).innerHTML = 'Email has been sent to ' + this.onshow.params.email;\r\n            }));\r\n        }\r\n    }\r\n    getDivToDisplayErrorMessage(input, counter = 1) {\r\n        let div = input.parentElement.closest('div');\r\n        if (!div)\r\n            return input;\r\n        if (div.clientWidth > 300 || counter > 5) {\r\n            return div;\r\n        }\r\n        return this.getDivToDisplayErrorMessage(div, ++counter);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycBase.ts\n\r\n\r\n\r\nclass KycBase {\r\n    constructor(kycForm) {\r\n        this.kycForm = kycForm;\r\n        FileUpload.registerHandler();\r\n    }\r\n    showFieldset(selector, header) {\r\n        var _a;\r\n        this.hideFieldsets();\r\n        (_a = document.querySelector(selector)) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n        document.querySelector('#liminal_market_modal_div > article > header > span').innerHTML = header;\r\n        document.querySelector('#liminal_market_modal_div > article').scrollTop = 0;\r\n        this.kycForm.activeFieldsetSelector = selector;\r\n    }\r\n    showRequiredMarker() {\r\n        let inputs = document.querySelectorAll('input, select');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (!input.id)\r\n                continue;\r\n            let label = document.querySelector('label[for=' + input.id + ']');\r\n            if (!label)\r\n                continue;\r\n            if (input.required) {\r\n                if (label.innerHTML.indexOf('*') == -1) {\r\n                    label.innerHTML += '*';\r\n                }\r\n            }\r\n            else {\r\n                if (label.innerHTML.indexOf('*') != -1) {\r\n                    label.innerHTML = label.innerHTML.replace('*', '');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setRequired(inputId) {\r\n        var _a;\r\n        (_a = document.getElementById(inputId)) === null || _a === void 0 ? void 0 : _a.setAttribute('required', 'required');\r\n    }\r\n    removeRequired(inputId) {\r\n        var _a;\r\n        (_a = document.getElementById(inputId)) === null || _a === void 0 ? void 0 : _a.removeAttribute('required');\r\n    }\r\n    bind(selector, eventName, action) {\r\n        let elements = document.querySelectorAll(selector);\r\n        for (let i = 0; i < elements.length; i++) {\r\n            elements[i].addEventListener(eventName, (evt) => {\r\n                action(evt);\r\n            });\r\n        }\r\n    }\r\n    bindFileUploads() {\r\n        for (let i = 0; i < FileUpload.fileUploads.length; i++) {\r\n            FileUpload.fileUploads[i].bindEvents();\r\n        }\r\n    }\r\n    hideFieldsets() {\r\n        let fieldsets = document.querySelectorAll('#kyc_wizard_form > fieldset');\r\n        for (let i = 0; i < fieldsets.length; i++) {\r\n            fieldsets[i].classList.add('hidden');\r\n        }\r\n    }\r\n    validateRequiredFields(selector) {\r\n        let inputs = document.querySelectorAll(selector + ' input[required], ' + selector + ' select[required]');\r\n        for (let i = 0; i < inputs.length; i++) {\r\n            let input = inputs[i];\r\n            if (this.isMissingInputFromUser(input)) {\r\n                let obj = {\r\n                    message: 'You must fill into this field',\r\n                    inputName: input.id,\r\n                    labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                    pattern: input.pattern\r\n                };\r\n                let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n                kycValidationError.handle();\r\n                return false;\r\n            }\r\n            if (input.pattern) {\r\n                let pattern = input.pattern;\r\n                let matches = input.value.match(pattern);\r\n                if (matches == null) {\r\n                    let obj = {\r\n                        message: 'This is not valid date format, please use YYYY-MM-DD (year-month-date)',\r\n                        inputName: input.id,\r\n                        labelText: document.querySelector('label[for=' + input.id + ']').innerHTML,\r\n                        pattern: input.pattern\r\n                    };\r\n                    let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n                    kycValidationError.handle();\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    showElement(elementId) {\r\n        var _a;\r\n        (_a = document.getElementById(elementId)) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n    }\r\n    hideElement(elementId) {\r\n        var _a;\r\n        (_a = document.getElementById(elementId)) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n    }\r\n    setLabel(elementId, text) {\r\n        let element = document.getElementById('tax_id_label');\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = text;\r\n    }\r\n    isMissingInputFromUser(input) {\r\n        return ((input.type == 'checkbox' && !input.checked) || StringHelper.isNullOrEmpty(input.value));\r\n    }\r\n    removeMissingInfo(errorDivId, focusElementId) {\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.style.display = 'none';\r\n        if (!focusElementId)\r\n            return;\r\n        let focusElement = document.getElementById(focusElementId);\r\n        if (focusElement) {\r\n            focusElement.removeAttribute('aria-invalid');\r\n        }\r\n    }\r\n    setMissingInfo(errorDivId, text, focusElementId) {\r\n        var _a, _b;\r\n        let element = document.getElementById(errorDivId);\r\n        if (!element)\r\n            return;\r\n        element.innerHTML = text;\r\n        if (text == '') {\r\n            element.style.display = 'none';\r\n        }\r\n        else {\r\n            element.style.display = 'block';\r\n            if (focusElementId) {\r\n                (_a = document.getElementById(focusElementId)) === null || _a === void 0 ? void 0 : _a.focus();\r\n                (_b = document.getElementById(focusElementId)) === null || _b === void 0 ? void 0 : _b.setAttribute('aria-invalid', 'true');\r\n            }\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycContact.ts\n\r\n\r\n\r\nclass KycContact extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.usTaxResidence = false;\r\n    }\r\n    render(edit = false) {\r\n        let template = Handlebars.compile(Kyc_KycContact);\r\n        return template({ edit: edit, countries: CountryHelper.Countries });\r\n    }\r\n    show() {\r\n        this.showFieldset('.kycContact', 'Contact information');\r\n    }\r\n    bindEvents() {\r\n        this.bind('#country_of_tax_residence', 'change', (evt) => {\r\n            var _a, _b;\r\n            let input = evt.target;\r\n            this.usTaxResidence = (input.value.toUpperCase() == 'USA');\r\n            if (this.usTaxResidence) {\r\n                (_a = document.getElementById('state_div')) === null || _a === void 0 ? void 0 : _a.classList.remove('hidden');\r\n                this.kycForm.setSteps(5);\r\n                this.setRequired('state');\r\n            }\r\n            else {\r\n                this.kycForm.setSteps(6);\r\n                this.removeRequired('state');\r\n                (_b = document.getElementById('state_div')) === null || _b === void 0 ? void 0 : _b.classList.add('hidden');\r\n            }\r\n        });\r\n        let showIdentityButton = document.getElementById('contact_next');\r\n        if (showIdentityButton) {\r\n            showIdentityButton.addEventListener('click', (evt) => {\r\n                if (!this.validateRequiredFields('.kycContact'))\r\n                    return;\r\n                this.kycForm.kycIdentity.show();\r\n            });\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycIdentity.html\n// Module\nvar KycIdentity_code = \"<fieldset class=\\\"kycIdentity hidden\\\" data-form=\\\"1\\\">\\r\\n    <div>\\r\\n        <label for=\\\"given_name\\\">Legal First name</label>\\r\\n        <input required id=\\\"given_name\\\" name=\\\"given_name\\\"\\r\\n               placeholder=\\\"Ron\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"given-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"middle_name\\\">Legal Middle name</label>\\r\\n        <input id=\\\"middle_name\\\" name=\\\"middle_name\\\"\\r\\n               placeholder=\\\"\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"additional-name\\\">\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"family_name\\\">Legal Last name</label>\\r\\n        <input required id=\\\"family_name\\\" name=\\\"family_name\\\"\\r\\n               placeholder=\\\"Swanson\\\"\\r\\n               value=\\\"\\\" autocomplete=\\\"family-name\\\">\\r\\n    </div>\\r\\n    {{#unless edit}}\\r\\n    <div>\\r\\n        <label for=\\\"date_of_birth\\\">Date of birth</label>\\r\\n        <input type=\\\"date\\\" required id=\\\"date_of_birth\\\" name=\\\"date_of_birth\\\"\\r\\n               placeholder=\\\"1978-11-24\\\" pattern=\\\"\\\\d{4}-\\\\d{2}-\\\\d{2}\\\" value=\\\"\\\" autocomplete=\\\"bday\\\">\\r\\n    </div>\\r\\n\\r\\n    <div id=\\\"citizen_of_usa_question\\\" class=\\\"hidden\\\">\\r\\n        <label for=\\\"citizen_yes\\\">Are you a citizen of the United States?</label>\\r\\n        <fieldset>\\r\\n            <label>\\r\\n                <input type=\\\"radio\\\" id=\\\"citizen_yes\\\"\\r\\n                       name=\\\"citizen\\\" value=\\\"1\\\"> Yes\\r\\n            </label>\\r\\n            <label>\\r\\n                <input type=\\\"radio\\\" id=\\\"citizen_no\\\"\\r\\n                       name=\\\"citizen\\\" value=\\\"0\\\"> No\\r\\n            </label>\\r\\n            <fieldset id=\\\"citizen_no_type_options\\\" class=\\\"hidden\\\">\\r\\n                <label>\\r\\n                    <input type=\\\"radio\\\" name=\\\"permanent_resident\\\" id=\\\"citizen_no_type_options_1\\\" value=\\\"1\\\"/> Green Card\\r\\n                    / Permanent Resident\\r\\n                </label>\\r\\n                <label><input type=\\\"radio\\\" name=\\\"permanent_resident\\\" id=\\\"citizen_no_type_options_2\\\" value=\\\"0\\\"/>\\r\\n                    Visa</label>\\r\\n            </fieldset>\\r\\n        </fieldset>\\r\\n    </div>\\r\\n    <div id=\\\"tax_id_type_options\\\">\\r\\n        <label for=\\\"tax_id_type\\\">Tax Id Type</label>\\r\\n        <select required id=\\\"tax_id_type\\\" name=\\\"tax_id_type\\\" placeholder=\\\"USA_SSN\\\">\\r\\n            <option value=\\\"USA_SSN\\\"></option>\\r\\n            <option value=\\\"ARG_AR_CUIT\\\">Argentina CUIT</option>\\r\\n            <option value=\\\"AUS_TFN\\\">Australian Tax File Number</option>\\r\\n            <option value=\\\"AUS_ABN\\\">Australian Business Number</option>\\r\\n            <option value=\\\"BOL_NIT\\\">Bolivia NIT</option>\\r\\n            <option value=\\\"BRA_CPF\\\">Brazil CPF</option>\\r\\n            <option value=\\\"CHL_RUT\\\">Chile RUT</option>\\r\\n            <option value=\\\"COL_NIT\\\">Colombia NIT</option>\\r\\n            <option value=\\\"CRI_NITE\\\">Costa Rica NITE</option>\\r\\n            <option value=\\\"DEU_TAX_ID\\\">Germany Tax ID (Identifikationsnummer)</option>\\r\\n            <option value=\\\"DOM_RNC\\\">Dominican Republic RNC</option>\\r\\n            <option value=\\\"ECU_RUC\\\">Ecuador RUC</option>\\r\\n            <option value=\\\"FRA_SPI\\\">France SPI (Reference Tax Number)</option>\\r\\n            <option value=\\\"GBR_UTR\\\">UK UTR (Unique Taxpayer Reference)</option>\\r\\n            <option value=\\\"GBR_NINO\\\">UK NINO (National Insurance Number)</option>\\r\\n            <option value=\\\"GTM_NIT\\\">Guatemala NIT</option>\\r\\n            <option value=\\\"HND_RTN\\\">Honduras RTN</option>\\r\\n            <option value=\\\"HUN_TIN\\\">Hungary TIN Number</option>\\r\\n            <option value=\\\"IDN_KTP\\\">Indonesia KTP</option>\\r\\n            <option value=\\\"IND_PAN\\\">India PAN Number</option>\\r\\n            <option value=\\\"ISR_TAX_ID\\\">Israel Tax ID (Teudat Zehut)</option>\\r\\n            <option value=\\\"ITA_TAX_ID\\\">Italy Tax ID (Codice Fiscale)</option>\\r\\n            <option value=\\\"JPN_TAX_ID\\\">Japan Tax ID (Koijin Bango)</option>\\r\\n            <option value=\\\"MEX_RFC\\\">Mexico RFC</option>\\r\\n            <option value=\\\"NIC_RUC\\\">Nicaragua RUC</option>\\r\\n            <option value=\\\"NLD_TIN\\\">Netherlands TIN Number</option>\\r\\n            <option value=\\\"PAN_RUC\\\">Panama RUC</option>\\r\\n            <option value=\\\"PER_RUC\\\">Peru RUC</option>\\r\\n            <option value=\\\"PRY_RUC\\\">Paraguay RUC</option>\\r\\n            <option value=\\\"SGP_NRIC\\\">Singapore NRIC</option>\\r\\n            <option value=\\\"SGP_FIN\\\">Singapore FIN</option>\\r\\n            <option value=\\\"SGP_ASGD\\\">Singapore ASGD</option>\\r\\n            <option value=\\\"SGP_ITR\\\">Singapore ITR</option>\\r\\n            <option value=\\\"SLV_NIT\\\">El Salvador NIT</option>\\r\\n            <option value=\\\"SWE_TAX_ID\\\">Sweden Tax ID (Personnummer)</option>\\r\\n            <option value=\\\"URY_RUT\\\">Uruguay RUT</option>\\r\\n            <option value=\\\"VEN_RIF\\\">Venezuela RIF</option>\\r\\n            <option value=\\\"NOT_SPECIFIED\\\">Other Tax IDs</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label id=\\\"tax_id_label\\\" for=\\\"tax_id\\\">Tax Id (SSN)</label>\\r\\n        <input required id=\\\"tax_id\\\" name=\\\"tax_id\\\"\\r\\n               placeholder=\\\"666-55-4321\\\"\\r\\n               value=\\\"\\\">\\r\\n    </div>\\r\\n    <div id=\\\"country_of_birth_option\\\">\\r\\n        <label for=\\\"country_of_birth\\\">Country of birth</label>\\r\\n        <select id=\\\"country_of_birth\\\" name=\\\"country_of_birth\\\">\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    <div id=\\\"country_of_citizenship_option\\\">\\r\\n        <label for=\\\"country_of_citizenship\\\">Country of citizenship</label>\\r\\n        <select required id=\\\"country_of_citizenship\\\" name=\\\"country_of_citizenship\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    <div id=\\\"visa_type_option\\\" class=\\\"hidden\\\">\\r\\n        <div>\\r\\n            <label for=\\\"visa_type\\\">Visa type - <a\\r\\n                    href=\\\"https://travel.state.gov/content/travel/en/us-visas/visa-information-resources/all-visa-categories.html\\\"\\r\\n                    target=\\\"_blank\\\">Visa\\r\\n                information</a></label>\\r\\n            <select id=\\\"visa_type\\\" name=\\\"visa_type\\\">\\r\\n                <option value=\\\"\\\"></option>\\r\\n                <option value=\\\"B1\\\" selected>USA Visa Category B-1</option>\\r\\n                <option value=\\\"B2\\\">USA Visa Category B-2</option>\\r\\n                <option value=\\\"DACA\\\">USA Visa Category DACA</option>\\r\\n                <option value=\\\"E1\\\">USA Visa Category E-1</option>\\r\\n                <option value=\\\"E2\\\">USA Visa Category E-2</option>\\r\\n                <option value=\\\"E3\\\">USA Visa Category E-3</option>\\r\\n                <option value=\\\"F1\\\">USA Visa Category F-1</option>\\r\\n                <option value=\\\"G4\\\">USA Visa Category G-4</option>\\r\\n                <option value=\\\"H1B\\\">USA Visa Category H-1B</option>\\r\\n                <option value=\\\"J1\\\">USA Visa Category J-1</option>\\r\\n                <option value=\\\"L1\\\">USA Visa Category L-1</option>\\r\\n                <option value=\\\"OTHER\\\">Any other USA Visa Category</option>\\r\\n                <option value=\\\"O1\\\">USA Visa Category O-1</option>\\r\\n                <option value=\\\"TN1\\\">USA Visa Category TN-1</option>\\r\\n            </select>\\r\\n        </div>\\r\\n        <div id=\\\"visa_expiration_date_option\\\">\\r\\n            <label for=\\\"visa_expiration_date\\\">Visa expiration date</label>\\r\\n            <input type=\\\"date\\\" id=\\\"visa_expiration_date\\\"\\r\\n                   name=\\\"visa_expiration_date\\\" placeholder=\\\"2028-05-01\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n        <div id=\\\"date_of_departure_from_usa_option\\\">\\r\\n            <label for=\\\"date_of_departure_from_usa\\\">Date of departure from USA</label>\\r\\n            <input type=\\\"date\\\" id=\\\"date_of_departure_from_usa\\\"\\r\\n                   name=\\\"date_of_departure_from_usa\\\" placeholder=\\\"2028-05-01\\\" value=\\\"\\\">\\r\\n        </div>\\r\\n\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"annual_income\\\">Annual Household Income</label>\\r\\n        <div class=\\\"explain\\\">\\r\\n            Annual household income includes income from sources such as employment, alimony, social security,\\r\\n            investment income, etc.\\r\\n        </div>\\r\\n        <select name=\\\"annual_income\\\" id=\\\"annual_income\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            <option value=\\\"1\\\">0 - $20,000</option>\\r\\n            <option value=\\\"2\\\">$20,000 - $49,999</option>\\r\\n            <option value=\\\"3\\\">$50,000 - $99,999</option>\\r\\n            <option value=\\\"4\\\">$100,000 - $499,999</option>\\r\\n            <option value=\\\"5\\\">$500,000 - $999,999</option>\\r\\n            <option value=\\\"6\\\">$1,000,000 - $9,999,999</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"liquid_net_worth\\\">Liquid Assets</label>\\r\\n        <div class=\\\"explain\\\">Liquid assets is your net worth minus assets that cannot be\\r\\n            converted quickly and easily into cash, such as real estate, business equity,\\r\\n            personal property and automobiles, expected inheritances, assets earmarked for\\r\\n            other purposes, and investments or accounts subject to substantial penalties\\r\\n            if they were sold or if assets were withdrawn from them.\\r\\n        </div>\\r\\n        <select name=\\\"liquid_net_worth\\\" required id=\\\"liquid_net_worth\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            <option value=\\\"1\\\">0 - $20,000</option>\\r\\n            <option value=\\\"2\\\">$20,000 - $49,999</option>\\r\\n            <option value=\\\"3\\\">$50,000 - $99,999</option>\\r\\n            <option value=\\\"4\\\">$100,000 - $499,999</option>\\r\\n            <option value=\\\"5\\\">$500,000 - $999,999</option>\\r\\n            <option value=\\\"1\\\">$1,000,000 - $9,999,999</option>\\r\\n        </select>\\r\\n    </div>\\r\\n\\r\\n    <div>\\r\\n        <label for=\\\"funding_source\\\">Funding source</label>\\r\\n        <select required id=\\\"funding_source\\\" name=\\\"funding_source\\\"\\r\\n                multiple size=\\\"4\\\" aria-label=\\\"size 3 select\\\">\\r\\n            <option value=\\\"employment_income\\\">Employment income</option>\\r\\n            <option value=\\\"investments\\\">Investments</option>\\r\\n            <option value=\\\"inheritance\\\">Inheritance</option>\\r\\n            <option value=\\\"business_income\\\">Business income</option>\\r\\n            <option value=\\\"savings\\\">Savings</option>\\r\\n            <option value=\\\"family\\\">Family</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    {{/unless}}\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"identity_prev\\\">Previous: Contact</button>\\r\\n        <button type=\\\"button\\\" id=\\\"identity_next\\\">Next: Trusted contacts</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycIdentity = (KycIdentity_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycIdentity.ts\n\r\n\r\n\r\n\r\nclass KycIdentity extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.edit = false;\r\n    }\r\n    render(edit = false) {\r\n        this.edit = edit;\r\n        let template = Handlebars.compile(Kyc_KycIdentity);\r\n        return template({ edit: edit, countries: CountryHelper.Countries });\r\n    }\r\n    show() {\r\n        if (this.kycForm.kycContact.usTaxResidence) {\r\n            this.showElement('citizen_of_usa_question');\r\n            this.hideElement('tax_id_type_options');\r\n            this.setLabel('tax_id_label', 'SSN');\r\n        }\r\n        else {\r\n            this.hideElement('citizen_of_usa_question');\r\n            this.setLabel('tax_id_label', 'National Tax Id (SSN)');\r\n            this.showElement('tax_id_type_options');\r\n        }\r\n        this.showFieldset('.kycIdentity', 'Identity');\r\n        this.showElement('country_of_citizenship_option');\r\n        let country_of_citizenship = document.getElementById('country_of_citizenship');\r\n        if (country_of_citizenship) {\r\n            country_of_citizenship.options[1].disabled = false;\r\n        }\r\n    }\r\n    bindEvents() {\r\n        this.bind('#citizen_yes', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                let taxIdType = document.getElementById('tax_id_type');\r\n                if (taxIdType)\r\n                    taxIdType.value = 'USA_SSN';\r\n                let country_of_citizenship = document.getElementById('country_of_citizenship');\r\n                country_of_citizenship.options[1].disabled = false;\r\n                country_of_citizenship.value = 'USA';\r\n                this.hideElement('citizen_no_type_options');\r\n                this.hideElement('visa_type_option');\r\n                this.hideElement('country_of_citizenship_option');\r\n                this.removeRequired('country_of_birth');\r\n                this.removeRequired('visa_type');\r\n                this.removeRequired('visa_expiration_date');\r\n                this.removeRequired('date_of_departure_from_usa');\r\n                document.getElementById('tax_id_label').innerHTML = 'SSN';\r\n                this.hideCitizenErrorMessage();\r\n            }\r\n        });\r\n        this.bind('#citizen_no', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                this.showElement('citizen_no_type_options');\r\n                this.showElement('country_of_citizenship_option');\r\n                this.setRequired('country_of_birth');\r\n                document.getElementById('tax_id_label').innerHTML = 'SSN';\r\n                let country_of_citizenship = document.getElementById('country_of_citizenship');\r\n                country_of_citizenship.options[0].selected = true;\r\n                country_of_citizenship.options[1].disabled = true;\r\n                this.hideCitizenErrorMessage();\r\n            }\r\n        });\r\n        this.bind('#citizen_no_type_options_1', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                this.showElement('country_of_citizenship_option');\r\n                this.hideElement('visa_type_option');\r\n                this.setRequired('country_of_birth');\r\n                this.removeRequired('visa_type');\r\n                this.removeRequired('visa_expiration_date');\r\n                this.removeRequired('date_of_departure_from_usa');\r\n            }\r\n        });\r\n        this.bind('#citizen_no_type_options_2', 'click', (evt) => {\r\n            let input = evt.target;\r\n            if (input.checked) {\r\n                this.showElement('visa_type_option');\r\n                this.showElement('country_of_citizenship_option');\r\n                this.setRequired('country_of_birth');\r\n                this.setRequired('country_of_citizenship');\r\n                this.setRequired('visa_type');\r\n                this.setRequired('visa_expiration_date');\r\n                this.setRequired('date_of_departure_from_usa');\r\n            }\r\n        });\r\n        this.bind('#visa_type', 'change', (evt) => {\r\n            let input = evt.target;\r\n            if (input.value == 'B1' || input.value == 'B2') {\r\n                this.showElement('date_of_departure_from_usa_option');\r\n            }\r\n            else {\r\n                this.hideElement('date_of_departure_from_usa_option');\r\n            }\r\n        });\r\n        this.bindButtons();\r\n    }\r\n    hideCitizenErrorMessage() {\r\n        document.getElementById('citizen_yes').removeAttribute('aria-invalid');\r\n        let errorMessage = document.getElementById('input_error_citizen_yes');\r\n        if (errorMessage)\r\n            errorMessage.remove();\r\n    }\r\n    bindButtons() {\r\n        let showContactButton = document.getElementById('identity_prev');\r\n        showContactButton === null || showContactButton === void 0 ? void 0 : showContactButton.addEventListener('click', (evt) => {\r\n            this.kycForm.kycContact.show();\r\n        });\r\n        let showDisclosuresButton = document.getElementById('identity_next');\r\n        showDisclosuresButton === null || showDisclosuresButton === void 0 ? void 0 : showDisclosuresButton.addEventListener('click', (evt) => {\r\n            if (!this.validateInputs())\r\n                return;\r\n            if (!this.validateRequiredFields('.kycIdentity'))\r\n                return;\r\n            this.kycForm.kycTrustedContact.show();\r\n        });\r\n    }\r\n    validateInputs() {\r\n        if (this.edit)\r\n            return true;\r\n        let citizen_yes = document.getElementById('citizen_yes');\r\n        let citizen_no = document.getElementById('citizen_no');\r\n        if (!this.kycForm.kycContact.usTaxResidence) {\r\n            citizen_yes.checked = false;\r\n            citizen_no.checked = false;\r\n            return true;\r\n        }\r\n        if (!citizen_yes.checked && !citizen_no.checked) {\r\n            let obj = {\r\n                message: 'You must select either option',\r\n                inputName: 'citizen_yes',\r\n                labelText: document.querySelector('label[for=citizen_yes]').innerHTML\r\n            };\r\n            let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n            kycValidationError.handle();\r\n            return false;\r\n        }\r\n        let greenCardOption = document.getElementById('citizen_no_type_options_1');\r\n        let visaOption = document.getElementById('citizen_no_type_options_2');\r\n        if (citizen_no.checked && !greenCardOption.checked && !visaOption.checked) {\r\n            let obj = {\r\n                message: 'You must select either option, \"Green Card / Permanent Resident\" or \"Visa\"',\r\n                inputName: 'citizen_no',\r\n                labelText: ''\r\n            };\r\n            let kycValidationError = new KycValidatorError(obj, this.kycForm);\r\n            kycValidationError.handle();\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycDisclosures.html\n// Module\nvar KycDisclosures_code = \"<fieldset class=\\\"kycDisclosures hidden\\\" data-form=\\\"1\\\">\\r\\n    {{#unless edit}}\\r\\n    <div>\\r\\n        <label for=\\\"employment_status\\\">Employment status</label>\\r\\n        <select id=\\\"employment_status\\\" required name=\\\"employment_status\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            <option value=\\\"employed\\\">Employed</option>\\r\\n            <option value=\\\"unemployed\\\">Unemployed</option>\\r\\n            <option value=\\\"retired\\\">Retired</option>\\r\\n            <option value=\\\"student\\\">Student</option>\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"employer_name\\\">Employer name</label>\\r\\n        <input name=\\\"employer_name\\\" id=\\\"employer_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"employer_address\\\">Employer address</label>\\r\\n        <input name=\\\"employer_address\\\" id=\\\"employer_address\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"employment_position\\\">Occupation / Job title</label>\\r\\n        <input name=\\\"employment_position\\\" id=\\\"employment_position\\\" autocomplete=\\\"organization-title\\\"/>\\r\\n    </div>\\r\\n    {{/unless}}\\r\\n    <div class=\\\"disclosure_selections\\\">\\r\\n        Do any of the following apply to you or a member of your immediate family?\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"is_affiliated_exchange_or_finra\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"is_affiliated_exchange_or_finra\\\" name=\\\"is_affiliated_exchange_or_finra\\\"\\r\\n                           role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                Affiliated or work with a US registered broker-dealer or\\r\\n                FINRA.\\r\\n                <small class=\\\"explain\\\">Are you or an immediate family member affiliated with or employed by a stock\\r\\n                    exchange, regulatory body, member firm of an exchange, FINRA or a municipal securities\\r\\n                    broker-dealer?</small>\\r\\n\\r\\n                <div id=\\\"is_affiliated_exchange_or_finra_extra\\\"></div>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"is_control_person\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"is_control_person\\\" name=\\\"is_control_person\\\" role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n\\r\\n                Senior executive at or a 10% or greater shareholder of a publicly traded company.\\r\\n                <small class=\\\"explain\\\">Are you or an immediate family member an officer or 10% or greater shareholder of\\r\\n                    a publicly traded company, subject to the US Securities Exchange Act 1934?</small>\\r\\n                <div id=\\\"is_control_person_extra\\\"></div>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"is_politically_exposed\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"is_politically_exposed\\\" name=\\\"is_politically_exposed\\\" role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                I am a senior political figure.\\r\\n                <small class=\\\"explain\\\">Are you currently or formerly a Politically Exposed Person or Public Official\\r\\n                    (PEP)? <a href=\\\"https://www.google.com/search?q=%E2%80%9CPolitically+Exposed+Person%E2%80%9D+(PEP)\\\"\\r\\n                              target=\\\"_blank\\\">What is PEP?</a> </a></small>\\r\\n                <div id=\\\"is_politically_exposed_extra\\\"></div>\\r\\n            </div>\\r\\n            </label>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"immediate_family_exposed\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"immediate_family_exposed\\\" name=\\\"immediate_family_exposed\\\" role=\\\"switch\\\">\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                I am a family member or relative of a senior political figure.\\r\\n                <small class=\\\"explain\\\">Are you an immediate family member currently or formerly a Politically Exposed\\r\\n                    Person or Public Official (PEP)? <a\\r\\n                            href=\\\"https://www.google.com/search?q=%E2%80%9CPolitically+Exposed+Person%E2%80%9D+(PEP)\\\"\\r\\n                            target=\\\"_blank\\\">What is PEP?</a></small>\\r\\n                <div id=\\\"immediate_family_exposed_extra\\\"></div>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"none_above\\\">\\r\\n                    <input type=\\\"checkbox\\\" id=\\\"none_above\\\" name=\\\"none_above\\\" role=\\\"switch\\\"></label>\\r\\n            </div>\\r\\n            <div>\\r\\n                None of the above apply to me or my family.\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"input_error\\\" id=\\\"none_above_error\\\"></div>\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"disclosures_prev\\\">Previous: Trusted contact</button>\\r\\n        <button type=\\\"button\\\" id=\\\"disclosures_next\\\">Next: Agreements</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycDisclosures = (KycDisclosures_code);\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycAffiliateOrControlled.html\n// Module\nvar KycAffiliateOrControlled_code = \"<fieldset id=\\\"affiliate_or_controlled\\\">\\r\\n    <div>You need to fill in the following information</div>\\r\\n    <div>\\r\\n        <label for=\\\"company_name\\\">Company name</label>\\r\\n        <input name=\\\"company_name\\\" required id=\\\"company_name\\\" autocomplete=\\\"organization\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_street_address\\\">Company street address</label>\\r\\n        <input name=\\\"company_street_address\\\" required id=\\\"company_street_address\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_city\\\">Company city</label>\\r\\n        <input name=\\\"company_city\\\" required id=\\\"company_city\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_state\\\">Company state</label>\\r\\n        <input name=\\\"company_state\\\" required id=\\\"company_state\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_country\\\">Company country</label>\\r\\n        <select required id=\\\"company_country\\\" required name=\\\"company_country\\\">\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"company_compliance_email\\\">Company compliance officer email</label>\\r\\n        <input name=\\\"company_compliance_email\\\" required id=\\\"company_compliance_email\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <div class=\\\"explain\\\">\\r\\n            In accordance with applicable FINRA rules, user will need to obtain a letter written\\r\\n            and signed by a compliance officer on company letterhead explicitly granting permission for\\r\\n            the applicant to carry the account and explicitly stating whether or not the firm requires\\r\\n            access to duplicate account statements and/or trade confirmations.\\r\\n\\r\\n            If the firm would like online access your duplicate account statements and/or trade confirmations,\\r\\n            include in the letter the applicant's full name and the following information for the interested\\r\\n            party: First and last name, title, email address, telephone number.\\r\\n\\r\\n        </div>\\r\\n        {{{fileUpload \\\"account_approval_letter\\\" \\\"Account approval letter\\\"}}}\\r\\n\\r\\n    </div>\\r\\n</fieldset>\\r\\n\";\n// Exports\n/* harmony default export */ const Kyc_KycAffiliateOrControlled = (KycAffiliateOrControlled_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycAffiliateOrControlled.ts\n\r\n\r\n\r\nclass KycAffiliateOrControlled extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render() {\r\n        let kycAffiliateOrControlledTemplate = Handlebars.compile(Kyc_KycAffiliateOrControlled);\r\n        return kycAffiliateOrControlledTemplate({ countries: CountryHelper.Countries });\r\n    }\r\n    bindEvents() {\r\n        this.bindFileUploads();\r\n        let company_country = document.getElementById('company_country');\r\n        company_country === null || company_country === void 0 ? void 0 : company_country.addEventListener('change', (evt) => {\r\n            let select = evt.target;\r\n            if (select.value === 'USA') {\r\n                this.setRequired('company_state');\r\n            }\r\n            else {\r\n                this.removeRequired('company_state');\r\n            }\r\n        });\r\n    }\r\n    validate() {\r\n        let company_name = document.getElementById('company_name');\r\n        if (!company_name)\r\n            return true;\r\n        return this.validateRequiredFields('#affiliate_or_controlled');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycImmediateFamily.html\n// Module\nvar KycImmediateFamily_code = \"<fieldset id=\\\"immediate_family\\\">\\r\\n    <div>Since you chose that your immediate family member, you need to fill in the following information</div>\\r\\n    <div>\\r\\n        <label for=\\\"disclosure_given_name\\\">Given name of political person</label>\\r\\n        <input name=\\\"disclosure_given_name\\\" id=\\\"disclosure_given_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"disclosure_family_name\\\">Family name of political person</label>\\r\\n        <input name=\\\"disclosure_family_name\\\" id=\\\"disclosure_family_name\\\"/>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycImmediateFamily = (KycImmediateFamily_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycImmediateFamily.ts\n\r\n\r\nclass KycImmediateFamily extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render() {\r\n        let kycImmediateFamilyTemplate = Handlebars.compile(Kyc_KycImmediateFamily);\r\n        return kycImmediateFamilyTemplate({});\r\n    }\r\n    bindEvents() {\r\n    }\r\n    validate() {\r\n        let disclosure_given_name = document.getElementById('disclosure_given_name');\r\n        if (!disclosure_given_name)\r\n            return true;\r\n        return this.validateRequiredFields('#immediate_family');\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycDisclosures.ts\n\r\n\r\n\r\n\r\nclass KycDisclosures extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.kycAffiliatedOrControlled = new KycAffiliateOrControlled(this.kycForm);\r\n        this.kycImmediateFamily = new KycImmediateFamily(this.kycForm);\r\n    }\r\n    render(edit = false) {\r\n        let template = Handlebars.compile(Kyc_KycDisclosures);\r\n        return template({ edit: edit });\r\n    }\r\n    show() {\r\n        if (this.kycForm.steps == 5) {\r\n            document.getElementById('disclosures_next').innerText = 'Next: Agreements';\r\n        }\r\n        else {\r\n            document.getElementById('disclosures_next').innerText = 'Next: Upload documents';\r\n        }\r\n        this.showFieldset('.kycDisclosures', 'Disclosures');\r\n    }\r\n    bindEvents() {\r\n        let is_affiliated_exchange_or_finra = document.getElementById('is_affiliated_exchange_or_finra');\r\n        is_affiliated_exchange_or_finra === null || is_affiliated_exchange_or_finra === void 0 ? void 0 : is_affiliated_exchange_or_finra.addEventListener('click', (evt) => {\r\n            this.loadAffiliatedOrControlComponent('is_affiliated_exchange_or_finra');\r\n        });\r\n        let is_control_person = document.getElementById('is_control_person');\r\n        is_control_person === null || is_control_person === void 0 ? void 0 : is_control_person.addEventListener('click', (evt) => {\r\n            this.loadAffiliatedOrControlComponent('is_control_person');\r\n        });\r\n        let immediate_family_exposed = document.getElementById('immediate_family_exposed');\r\n        immediate_family_exposed === null || immediate_family_exposed === void 0 ? void 0 : immediate_family_exposed.addEventListener('click', (evt) => {\r\n            this.loadPep('immediate_family_exposed');\r\n        });\r\n        let is_politically_exposed = document.getElementById('is_politically_exposed');\r\n        is_politically_exposed === null || is_politically_exposed === void 0 ? void 0 : is_politically_exposed.addEventListener('click', (evt) => {\r\n            this.uncheck('immediate_family_exposed');\r\n        });\r\n        let none_above = document.getElementById('none_above');\r\n        none_above === null || none_above === void 0 ? void 0 : none_above.addEventListener('click', (evt) => {\r\n            this.removeMissingInfo('none_above_error');\r\n            none_above.removeAttribute('aria-invalid');\r\n        });\r\n        let prev = document.getElementById('disclosures_prev');\r\n        prev === null || prev === void 0 ? void 0 : prev.addEventListener('click', (evt) => {\r\n            this.kycForm.kycTrustedContact.show();\r\n        });\r\n        let next = document.getElementById('disclosures_next');\r\n        next === null || next === void 0 ? void 0 : next.addEventListener('click', (evt) => {\r\n            if (!this.validateFields())\r\n                return;\r\n            if (this.kycForm.steps == 5) {\r\n                this.kycForm.kycAccountAgreement.show();\r\n            }\r\n            else {\r\n                this.kycForm.kycUpload.show();\r\n            }\r\n        });\r\n    }\r\n    loadAffiliatedOrControlComponent(elementId) {\r\n        if (elementId == 'is_affiliated_exchange_or_finra') {\r\n            this.uncheck('is_control_person');\r\n        }\r\n        else {\r\n            this.uncheck('is_affiliated_exchange_or_finra');\r\n        }\r\n        let element = document.getElementById(elementId);\r\n        let extra = document.getElementById(elementId + '_extra');\r\n        if (!extra)\r\n            return;\r\n        if (element.checked) {\r\n            extra.innerHTML = this.kycAffiliatedOrControlled.render();\r\n            this.kycAffiliatedOrControlled.bindEvents();\r\n        }\r\n        else {\r\n            extra.innerHTML = '';\r\n        }\r\n    }\r\n    loadPep(elementId) {\r\n        if (elementId == 'immediate_family_exposed') {\r\n            this.uncheck('is_politically_exposed');\r\n        }\r\n        else {\r\n            this.uncheck('immediate_family_exposed');\r\n        }\r\n        let element = document.getElementById(elementId);\r\n        let extra = document.getElementById(elementId + '_extra');\r\n        if (!extra)\r\n            return;\r\n        if (element.checked) {\r\n            extra.innerHTML = this.kycImmediateFamily.render();\r\n            this.kycImmediateFamily.bindEvents();\r\n        }\r\n        else {\r\n            extra.innerHTML = '';\r\n        }\r\n    }\r\n    uncheck(elementId) {\r\n        let element = document.getElementById(elementId);\r\n        element.checked = false;\r\n        let extra = document.getElementById(elementId + '_extra');\r\n        extra.innerHTML = '';\r\n    }\r\n    validateFields() {\r\n        if (!this.validateRequiredFields('.kycDisclosures'))\r\n            return false;\r\n        if (!this.kycImmediateFamily.validate())\r\n            return false;\r\n        if (!this.kycAffiliatedOrControlled.validate())\r\n            return false;\r\n        let is_affiliated_exchange_or_finra = document.getElementById('is_affiliated_exchange_or_finra');\r\n        let is_control_person = document.getElementById('is_control_person');\r\n        let is_politically_exposed = document.getElementById('is_politically_exposed');\r\n        let immediate_family_exposed = document.getElementById('immediate_family_exposed');\r\n        let none_above = document.getElementById('none_above');\r\n        if (!none_above.checked && !is_affiliated_exchange_or_finra.checked && !is_control_person.checked\r\n            && !is_politically_exposed.checked && !immediate_family_exposed.checked) {\r\n            this.setMissingInfo('none_above_error', 'You must select, \"None of the above apply to me or my family.\" if nothing is selected', 'none_above');\r\n            return false;\r\n        }\r\n        if (none_above.checked && (is_affiliated_exchange_or_finra.checked || is_control_person.checked\r\n            || is_politically_exposed.checked || immediate_family_exposed.checked)) {\r\n            this.setMissingInfo('none_above_error', 'You cannot have \"None of the above apply to me or my family.\" selected and other options selected. Please select only one', 'none_above');\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycAccountAgreement.html\n// Module\nvar KycAccountAgreement_code = \"<fieldset class=\\\"kycAccountAgreement hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"kycAccountAgreementGrid\\\">\\r\\n        <div id=\\\"account_agreement_error\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"account_agreement\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"account_agreement\\\" id=\\\"account_agreement\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                <label for=\\\"account_agreement\\\">\\r\\n                    I agree to <a href=\\\"https://files.alpaca.markets/disclosures/library/AcctAppMarginAndCustAgmt.pdf\\\"\\r\\n                                  target=\\\"_blank\\\">Alpaca Customer Agreement</a>\\r\\n                </label>\\r\\n            </div>\\r\\n        </div>\\r\\n        <div id=\\\"customer_agreement_error\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"customer_agreement\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"customer_agreement\\\" id=\\\"customer_agreement\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                <label for=\\\"customer_agreement\\\">\\r\\n                    Customer Agreement Acknowledgement</label>\\r\\n                <div class=\\\"explain\\\">\\r\\n                    I have read, understood, and agree to be bound by Alpaca Securities LLC and Liminal.market Inc.\\r\\n                    account\\r\\n                    terms,\\r\\n                    and all other terms, disclosures and disclaimers applicable to me, as referenced in the Alpaca\\r\\n                    Customer\\r\\n                    Agreement.\\r\\n                    I also acknowledge that the Alpaca Customer Agreement contains a pre-dispute arbitration clause\\r\\n                    in\\r\\n                    Section\\r\\n                    43.\\r\\n                </div>\\r\\n\\r\\n            </div>\\r\\n\\r\\n        </div>\\r\\n        <div id=\\\"digital_signature_error\\\" class=\\\"input_error\\\"></div>\\r\\n        <div class=\\\"grid\\\">\\r\\n            <div>\\r\\n                <label for=\\\"digital_signature\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"digital_signature\\\" id=\\\"digital_signature\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div>\\r\\n                <label for=\\\"digital_signature\\\">\\r\\n                    Digital Signature Acknowledgement</label>\\r\\n                <div class=\\\"explain\\\">\\r\\n                    I understand I am signing this agreement electronically,\\r\\n                    and that my electronic signature will have the same effect as physically signing and returning\\r\\n                    the\\r\\n                    Application Agreement.\\r\\n                </div>\\r\\n\\r\\n            </div>\\r\\n        </div>\\r\\n        <div class=\\\"grid hidden\\\" id=\\\"w8disclosure_div\\\">\\r\\n            <div>\\r\\n                <label for=\\\"w8disclosure\\\">\\r\\n                    <input required type=\\\"checkbox\\\" name=\\\"w8disclosure\\\" id=\\\"w8disclosure\\\" value=\\\"1\\\"/>\\r\\n                </label>\\r\\n            </div>\\r\\n            <div><label for=\\\"w8disclosure\\\">\\r\\n                I certify that I am not a US citizen, US resident alien or other US person for US tax purposes,\\r\\n                and I am submitting the applicable Form W-8 BEN with this form to certify my foreign status and,\\r\\n                if applicable, claim tax treaty benefits. </label>\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"account_agreement_prev\\\">Previous: Upload documents</button>\\r\\n        <button type=\\\"submit\\\" id=\\\"submitKYC\\\">Confirm identity</button>\\r\\n    </div>\\r\\n    <div class=\\\"alert alert-danger\\\" id=\\\"kycError\\\" role=\\\"alert\\\"></div>\\r\\n</fieldset>\\r\\n\";\n// Exports\n/* harmony default export */ const Kyc_KycAccountAgreement = (KycAccountAgreement_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycAccountAgreement.ts\nvar KycAccountAgreement_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KycAccountAgreement extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render(edit = false) {\r\n        let template = Handlebars.compile(Kyc_KycAccountAgreement);\r\n        return template({ edit: edit });\r\n    }\r\n    show() {\r\n        var _a, _b;\r\n        this.showFieldset('.kycAccountAgreement', 'Agreements');\r\n        if (this.kycForm.steps == 5) {\r\n            document.getElementById('account_agreement_prev').innerText = 'Previous: Disclosure';\r\n        }\r\n        else {\r\n            document.getElementById('account_agreement_prev').innerText = 'Previous: Upload documents';\r\n        }\r\n        if (this.kycForm.kycContact.usTaxResidence) {\r\n            (_a = document.getElementById('w8disclosure_div')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n        }\r\n        else {\r\n            (_b = document.getElementById('w8disclosure_div')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');\r\n        }\r\n    }\r\n    bindEvents() {\r\n        let account_agreement_prev = document.getElementById('account_agreement_prev');\r\n        account_agreement_prev === null || account_agreement_prev === void 0 ? void 0 : account_agreement_prev.addEventListener('click', (evt) => {\r\n            if (this.kycForm.steps == 5) {\r\n                this.kycForm.kycDisclosures.show();\r\n            }\r\n            else {\r\n                this.kycForm.kycUpload.show();\r\n            }\r\n        });\r\n        this.bindSubmitKyc();\r\n    }\r\n    bindSubmitKyc(edit = false) {\r\n        let submitKYC = document.getElementById('submitKYC');\r\n        if (!submitKYC)\r\n            return;\r\n        submitKYC.addEventListener('click', (evt) => KycAccountAgreement_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            if (!edit && !this.validate())\r\n                return;\r\n            let account_agreement_prev = document.getElementById('account_agreement_prev');\r\n            //if (account_agreement_prev) account_agreement_prev.classList.add('hidden');\r\n            let liminal_market_modal_close = document.getElementById('liminal_market_modal_close');\r\n            // if (liminal_market_modal_close) liminal_market_modal_close.style.display = 'none';\r\n            let submitBtn = evt.target;\r\n            LoadingHelper.setLoading(submitBtn);\r\n            let params = FormHelper.getParams('#kyc_wizard_form');\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            params.chainId = networkInfo.ChainId;\r\n            let kycService = new KYCService(Moralis);\r\n            let result = yield kycService.saveKYCInfo(params)\r\n                .catch((reason) => {\r\n                if (account_agreement_prev)\r\n                    account_agreement_prev.classList.remove('hidden');\r\n                LoadingHelper.removeLoading();\r\n                if (reason.message) {\r\n                    let kycError = new KycValidatorError(reason.message, this.kycForm);\r\n                    kycError.handle();\r\n                }\r\n                else {\r\n                    console.log(reason);\r\n                }\r\n            });\r\n            if (result) {\r\n                this.kycForm.kycWaiting.show();\r\n                ExecuteTradeButton.Instance.renderButton();\r\n            }\r\n            else {\r\n                if (account_agreement_prev)\r\n                    account_agreement_prev.classList.remove('hidden');\r\n                LoadingHelper.removeLoading();\r\n            }\r\n        }));\r\n    }\r\n    validate() {\r\n        let account_agreement = document.getElementById('account_agreement');\r\n        if (!(account_agreement === null || account_agreement === void 0 ? void 0 : account_agreement.checked)) {\r\n            this.setMissingInfo('account_agreement_error', 'You need to agree to agreements', 'account_agreement');\r\n            return false;\r\n        }\r\n        else {\r\n            this.removeMissingInfo('account_agreement_error', 'account_agreement');\r\n        }\r\n        let customer_agreement = document.getElementById('customer_agreement');\r\n        if (!(customer_agreement === null || customer_agreement === void 0 ? void 0 : customer_agreement.checked)) {\r\n            this.setMissingInfo('customer_agreement_error', 'You need to agree to customer agrement', 'customer_agreement');\r\n            return false;\r\n        }\r\n        else {\r\n            this.removeMissingInfo('customer_agreement_error', 'customer_agreement');\r\n        }\r\n        let digital_signature = document.getElementById('digital_signature');\r\n        if (!(digital_signature === null || digital_signature === void 0 ? void 0 : digital_signature.checked)) {\r\n            this.setMissingInfo('digital_signature_error', 'You need to sign', 'digital_signature');\r\n            return false;\r\n        }\r\n        else {\r\n            this.removeMissingInfo('digital_signature_error', 'digital_signature');\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycTrustedContact.html\n// Module\nvar KycTrustedContact_code = \"<fieldset class=\\\"kycTrustedContact hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"explain\\\">\\r\\n        A trusted contact is a person you authorize your financial firm to contact in limited circumstances,\\r\\n        such as if there is a concern about activity in your account and they have been unable to get in touch with you.\\r\\n        <br/><br/>\\r\\n        A trusted contact may be a family member, attorney, accountant or another third-party who you believe would\\r\\n        respect your privacy and know how to handle the responsibility.\\r\\n        The trusted person should be 18 years old or older.\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_first_name\\\">Legal first name of trusted contact</label>\\r\\n        <input id=\\\"trusted_first_name\\\" name=\\\"trusted_first_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_last_name\\\">Legal last name of trusted contact</label>\\r\\n        <input id=\\\"trusted_last_name\\\" name=\\\"trusted_last_name\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        If you fill in name, you are required to fill in one of the following, email, phone or address\\r\\n    </div>\\r\\n    <div class=\\\"input_error\\\" id=\\\"trusted_contact_missing_info\\\"></div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_email\\\">Email of trusted contact</label>\\r\\n        <input id=\\\"trusted_email\\\" type=\\\"email\\\" name=\\\"trusted_email\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_phone\\\">Phone of trusted contact</label>\\r\\n        <input id=\\\"trusted_phone\\\" type=\\\"tel\\\" name=\\\"trusted_phone\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_street_address\\\">Address of trusted contact</label>\\r\\n        <input id=\\\"trusted_street_address\\\" name=\\\"trusted_street_address\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_city\\\">City of trusted contact</label>\\r\\n        <input id=\\\"trusted_city\\\" name=\\\"trusted_city\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_state\\\">State of trusted contact</label>\\r\\n        <input id=\\\"trusted_state\\\" name=\\\"trusted_state\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_postal_code\\\">Postal code of trusted contact</label>\\r\\n        <input id=\\\"trusted_postal_code\\\" name=\\\"trusted_postal_code\\\"/>\\r\\n    </div>\\r\\n    <div>\\r\\n        <label for=\\\"trusted_country\\\">Country of trusted contact</label>\\r\\n        <select required id=\\\"trusted_country\\\" required name=\\\"trusted_country\\\">\\r\\n            <option value=\\\"\\\"></option>\\r\\n            {{#each countries}}\\r\\n            <option value=\\\"{{code}}\\\">{{name}}</option>\\r\\n            {{/each}}\\r\\n        </select>\\r\\n    </div>\\r\\n    {{#unless edit}}\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"trustedContact_prev\\\">Previous: Identity</button>\\r\\n        <button type=\\\"button\\\" id=\\\"trustedContact_next\\\">Next: Disclosures</button>\\r\\n    </div>\\r\\n    {{/unless}}\\r\\n    {{#if edit}}\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"trustedContact_prev\\\">Previous: Identity</button>\\r\\n        <button type=\\\"submit\\\" id=\\\"submitKYC\\\">Update account</button>\\r\\n    </div>\\r\\n    <div class=\\\"alert alert-danger\\\" id=\\\"kycError\\\" role=\\\"alert\\\"></div>\\r\\n    {{/if}}\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycTrustedContact = (KycTrustedContact_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycTrustedContact.ts\n\r\n\r\n\r\n\r\n\r\nclass KycTrustedContact extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n        this.edit = false;\r\n    }\r\n    render(edit = false) {\r\n        this.edit = edit;\r\n        let template = Handlebars.compile(Kyc_KycTrustedContact);\r\n        return template({ edit: edit, countries: CountryHelper.Countries });\r\n    }\r\n    show() {\r\n        this.showFieldset('.kycTrustedContact', 'Trusted contact');\r\n    }\r\n    bindEvents() {\r\n        let showPrev = document.getElementById('trustedContact_prev');\r\n        showPrev === null || showPrev === void 0 ? void 0 : showPrev.addEventListener('click', (evt) => {\r\n            this.kycForm.kycIdentity.show();\r\n        });\r\n        let showNext = document.getElementById('trustedContact_next');\r\n        showNext === null || showNext === void 0 ? void 0 : showNext.addEventListener('click', (evt) => {\r\n            if (!this.validate())\r\n                return;\r\n            this.kycForm.kycDisclosures.show();\r\n        });\r\n        if (this.edit) {\r\n            let kycAccount = new KycAccountAgreement(this.kycForm);\r\n            if (!this.validate())\r\n                return;\r\n            kycAccount.bindSubmitKyc(this.edit);\r\n        }\r\n    }\r\n    validate() {\r\n        this.setMissingInfo('trusted_contact_missing_info', '');\r\n        let trusted_first_name = document.getElementById('trusted_first_name');\r\n        if (trusted_first_name && !StringHelper.isNullOrEmpty(trusted_first_name.value)) {\r\n            let trusted_email = document.getElementById('trusted_email');\r\n            let trusted_phone = document.getElementById('trusted_phone');\r\n            let trusted_street_address = document.getElementById('trusted_street_address');\r\n            let trusted_city = document.getElementById('trusted_city');\r\n            let trusted_postal_code = document.getElementById('trusted_postal_code');\r\n            let trusted_country = document.getElementById('trusted_country');\r\n            if (StringHelper.isNullOrEmpty(trusted_email.value) && StringHelper.isNullOrEmpty(trusted_phone.value)\r\n                && StringHelper.isNullOrEmpty(trusted_street_address.value)) {\r\n                this.setMissingInfo('trusted_contact_missing_info', 'You need to fill in either email, phone or address');\r\n                return;\r\n            }\r\n            if (!StringHelper.isNullOrEmpty(trusted_email.value) && trusted_email.value.indexOf('@') == -1) {\r\n                this.setMissingInfo('trusted_contact_missing_info', 'Email is not valid. It must contain @ sign');\r\n                return;\r\n            }\r\n            if (!StringHelper.isNullOrEmpty(trusted_street_address.value) &&\r\n                (StringHelper.isNullOrEmpty(trusted_city.value) ||\r\n                    StringHelper.isNullOrEmpty(trusted_postal_code.value) ||\r\n                    StringHelper.isNullOrEmpty(trusted_country.value))) {\r\n                this.setMissingInfo('trusted_contact_missing_info', 'You need fill inn into City, Postal code and Country when filling the street address');\r\n                return;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycUpload.html\n// Module\nvar KycUpload_code = \"<fieldset class=\\\"kycUpload hidden\\\" data-form=\\\"1\\\">\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification\\\" \\\"Photo ID Front (Front of passport)\\\"}}}\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"identity_verification_2\\\" \\\"Photo ID Back (Passport picture of ID) \\\"}}}\\r\\n    </div>\\r\\n    <div class=\\\"grid\\\">\\r\\n        {{{fileUpload \\\"address_verification\\\" \\\"Picture of address verification\\\"}}}\\r\\n    </div>\\r\\n\\r\\n    <div class=\\\"grid buttons\\\">\\r\\n        <button type=\\\"button\\\" id=\\\"upload_prev\\\">Previous: Disclosures</button>\\r\\n        <button type=\\\"button\\\" id=\\\"upload_next\\\">Next: Agreements</button>\\r\\n    </div>\\r\\n</fieldset>\";\n// Exports\n/* harmony default export */ const Kyc_KycUpload = (KycUpload_code);\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycUpload.ts\n\r\n\r\nclass KycUpload extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    render() {\r\n        let template = Handlebars.compile(Kyc_KycUpload);\r\n        return template({});\r\n    }\r\n    show() {\r\n        this.showFieldset('.kycUpload', 'Upload documents');\r\n    }\r\n    bindEvents() {\r\n        this.bindFileUploads();\r\n        let upload_prev = document.getElementById('upload_prev');\r\n        upload_prev === null || upload_prev === void 0 ? void 0 : upload_prev.addEventListener('click', (evt) => {\r\n            this.kycForm.kycDisclosures.show();\r\n        });\r\n        let upload_next = document.getElementById('upload_next');\r\n        upload_next === null || upload_next === void 0 ? void 0 : upload_next.addEventListener('click', (evt) => {\r\n            if (!this.validateRequiredFields('.kycUpload'))\r\n                return;\r\n            this.kycForm.kycAccountAgreement.show();\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycWaiting.ts\nvar KycWaiting_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass KycWaiting extends KycBase {\r\n    constructor(kycForm) {\r\n        super(kycForm);\r\n    }\r\n    show() {\r\n        var _a, _b;\r\n        (_a = document.getElementById('kyc_reg')) === null || _a === void 0 ? void 0 : _a.classList.add('hidden');\r\n        (_b = document.getElementById('waiting_for_kyc_reg')) === null || _b === void 0 ? void 0 : _b.classList.remove('hidden');\r\n        document.querySelector('#liminal_market_modal_div > article > header > span').innerHTML = 'Waiting for KYC to be approved';\r\n        this.kycForm.timeout = setTimeout(() => KycWaiting_awaiter(this, void 0, void 0, function* () {\r\n            yield this.checkKycStatus();\r\n        }), 5 * 1000);\r\n    }\r\n    checkKycStatus() {\r\n        return KycWaiting_awaiter(this, void 0, void 0, function* () {\r\n            let kycService = new KYCService(Moralis);\r\n            let kycResponse = yield kycService.hasValidKYC();\r\n            if (kycResponse.isValidKyc || kycResponse.status == \"ACTION_REQUIRED\") {\r\n                clearTimeout(this.kycForm.timeout);\r\n                this.kycForm.modal.hideModal();\r\n            }\r\n            else {\r\n                this.kycForm.timeout = setTimeout(() => {\r\n                    this.checkKycStatus();\r\n                }, 5 * 1000);\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYCForm.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass KYCForm {\r\n    constructor(onHide) {\r\n        this.steps = 5;\r\n        this.timeout = undefined;\r\n        this.activeFieldsetSelector = '.kycContact';\r\n        this.modal = new Modal();\r\n        this.onHide = onHide;\r\n        this.kycContact = new KycContact(this);\r\n        this.kycIdentity = new KycIdentity(this);\r\n        this.kycTrustedContact = new KycTrustedContact(this);\r\n        this.kycDisclosures = new KycDisclosures(this);\r\n        this.kycAccountAgreement = new KycAccountAgreement(this);\r\n        this.kycUpload = new KycUpload(this);\r\n        this.kycWaiting = new KycWaiting(this);\r\n    }\r\n    show(className) {\r\n        let kycForm = new KYCForm(() => {\r\n        });\r\n        const ble = className;\r\n        this[ble].show();\r\n        this.activeFieldsetSelector = className;\r\n    }\r\n    showKYCForm(edit = false) {\r\n        let template = Handlebars.compile(KYCModal);\r\n        let obj = {\r\n            KycContactHtml: this.kycContact.render(),\r\n            KycIdentityHtml: this.kycIdentity.render(),\r\n            KycDisclosureHtml: this.kycDisclosures.render(),\r\n            KycTrustedContactHtml: this.kycTrustedContact.render(),\r\n            KycAccountAgreementHtml: this.kycAccountAgreement.render(),\r\n            KycUploadHtml: this.kycUpload.render()\r\n        };\r\n        let content = template(obj);\r\n        let newModal = this.modal.showModal('KYC & AML', content, true, () => {\r\n            this.clearTimeout();\r\n            this.onHide();\r\n        }, false);\r\n        let taxResidence = document.getElementById('country_of_tax_residence');\r\n        if (taxResidence) {\r\n            this.steps = (taxResidence.value == 'USA') ? 5 : 6;\r\n        }\r\n        if (newModal) {\r\n            this.kycContact.bindEvents();\r\n            this.kycIdentity.bindEvents();\r\n            this.kycTrustedContact.bindEvents();\r\n            this.kycDisclosures.bindEvents();\r\n            this.kycUpload.bindEvents();\r\n            this.kycAccountAgreement.bindEvents();\r\n            document.getElementById('kyc_wizard_form').addEventListener('keyup', (evt) => {\r\n                if (evt.key == 'Enter') {\r\n                    evt.preventDefault();\r\n                    evt.stopPropagation();\r\n                }\r\n            });\r\n        }\r\n        this.kycContact.show();\r\n    }\r\n    setSteps(steps) {\r\n        this.steps = steps;\r\n    }\r\n    clearTimeout() {\r\n        if (this.timeout)\r\n            clearTimeout(this.timeout);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/modals/KYC/KycStatusHandler.ts\nvar KycStatusHandler_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass KycStatusHandler {\r\n    constructor(kycResponse, executeTradeButton) {\r\n        this.kycResponse = kycResponse;\r\n        this.executeTradeButton = executeTradeButton;\r\n    }\r\n    getButtonText() {\r\n        let txt = 'Finish KYC';\r\n        switch (this.kycResponse.status) {\r\n            case 'SUBMITTED':\r\n            case 'ONBOARDING':\r\n            case 'INACTIVE':\r\n            case 'APPROVED':\r\n            case 'EDITED':\r\n            case 'APPROVAL_PENDING':\r\n                txt = 'Submitted to KYC processor';\r\n                break;\r\n            case 'ACTION_REQUIRED':\r\n                txt = 'Action required. Click to continue';\r\n                break;\r\n            case 'REJECTED':\r\n                txt = 'Your application was rejected';\r\n                break;\r\n            case 'DISABLED':\r\n                txt = 'Your account has been disabled';\r\n                break;\r\n            case 'ACTIVE':\r\n            case 'ACCOUNT_UPDATED':\r\n                txt = 'You are approved. KYC is being sent to blockchain. Give it few minutes';\r\n                break;\r\n            case 'ACCOUNT_CLOSED':\r\n                txt = 'Your account has been closed';\r\n                break;\r\n        }\r\n        return txt + '<small>Click for more info</small>';\r\n    }\r\n    getButtonClickEvent(executeTradeButton) {\r\n        switch (this.kycResponse.status) {\r\n            case 'SUBMITTED':\r\n            case 'ONBOARDING':\r\n            case 'INACTIVE':\r\n            case 'APPROVED':\r\n            case 'EDITED':\r\n            case 'APPROVAL_PENDING':\r\n                return this.showModal('Application is being processed', \"You need to wait for KYC to be approved. Then you'll be able to do trades. \" +\r\n                    \"This usually takes few minutes for the first submission, but can take longer for second submission. \" +\r\n                    \"We will email you when you are approved or if there are problems<br /><br />\" +\r\n                    \"If this status has been for more than 1 day, and you haven't gotten any email from us. Please email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application is being processed for to long&body=Hi, can you help me to find out what the problem is, the KYC process has not changed for some time? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\");\r\n            case 'ACTION_REQUIRED':\r\n                return () => KycStatusHandler_awaiter(this, void 0, void 0, function* () {\r\n                    let kycActionRequired = new KycActionRequired(executeTradeButton);\r\n                    yield kycActionRequired.show();\r\n                });\r\n            case 'REJECTED':\r\n                return this.showModal('Application was rejected', \"Your application has been rejected during KYC process.<br /><br />\" +\r\n                    \"We don't have the information on why that happened, but you can email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application was rejected&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\" +\r\n                    \" and we can find out, and we should be able to solve it together.\");\r\n            case 'DISABLED':\r\n                return this.showModal('Application was disabled', \"Your account has been disabled.<br /><br />\" +\r\n                    \"We don't have the information on why that happened, but you can email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application was disabled&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\" +\r\n                    \" and we can find out, and we should be able to solve it together.\");\r\n            case 'ACCOUNT_CLOSED':\r\n                return this.showModal('Application was closed', \"Your account has been closed.<br /><br />\" +\r\n                    \"We don't have the information on why that happened, but you can email us at \" +\r\n                    \"<a target='_blank' href='mailto:info@liminal.market?subject=My application was closed&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market'>info@liminal.market</a>\" +\r\n                    \" and we can find out, and we should be able to solve it together.\");\r\n            case 'ACCOUNT_UPDATED':\r\n            case 'ACTIVE':\r\n                return this.showModal('Account soon ready', 'Your account has been approved...<br /><br/>' +\r\n                    '..but, after we approve your account, we write the information to the blockchain.' +\r\n                    ' This usually takes just few(2-3) minutes.<br /><br/> If this is taking longer, ' +\r\n                    'please email us at <a target=\"_blank\" href=\"mailto:info@liminal.market?subject=KYC is being written to blockchain&body=Hi, can you help me to find out what the problem is? My name is _______ and I used the email _______ to register at liminal.market\">info@liminal.market</a>');\r\n        }\r\n        return () => {\r\n            let kycForm = new KYCForm(() => KycStatusHandler_awaiter(this, void 0, void 0, function* () {\r\n                yield this.executeTradeButton.renderButton();\r\n            }));\r\n            kycForm.showKYCForm();\r\n        };\r\n    }\r\n    showModal(title, content) {\r\n        return () => {\r\n            let modal = new Modal();\r\n            modal.showModal(title, content);\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/Kyc/KycApproved.html\n// Module\nvar KycApproved_code = \"<h2>You are account has been approved</h2>\\r\\n<p>We have approved your account. You can now fund your account and start to trade.\\r\\n\\r\\n    <button id=\\\"kycApprovedFund\\\">Fund account</button>\\r\\n</p>\";\n// Exports\n/* harmony default export */ const KycApproved = (KycApproved_code);\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/ExecuteTradeButton.ts\nvar ExecuteTradeButton_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ExecuteTradeButton {\r\n    constructor(moralis, sellTradeInput, buyTradeInput) {\r\n        this.hasBuyingPower = false;\r\n        this.moralis = moralis;\r\n        this.sellTradeInput = sellTradeInput;\r\n        this.buyTradeInput = buyTradeInput;\r\n        this.authenticateService = new AuthenticateService(this.moralis);\r\n        this.template = Handlebars.compile(tradepanel_ExecuteTradeButton);\r\n        this.button = document.getElementById('liminal_market_execute_trade');\r\n        ExecuteTradeButton.Instance = this;\r\n    }\r\n    renderButton() {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            this.button.outerHTML = this.button.outerHTML;\r\n            this.button = document.getElementById('liminal_market_execute_trade');\r\n            this.loadingButton(this.button);\r\n            //wallet connected\r\n            if (!this.walletIsConnected(this.button)) {\r\n                return;\r\n            }\r\n            //user logged in\r\n            if (!this.userIsLoggedIn(this.button)) {\r\n                return;\r\n            }\r\n            //chain id correct\r\n            if (!this.chainIdIsCorrect(this.button)) {\r\n                return;\r\n            }\r\n            //native token is available\r\n            if (!(yield this.userHasNativeToken(this.button))) {\r\n                return;\r\n            }\r\n            //kyc is done\r\n            if (!(yield this.kycIsDone(this.button))) {\r\n                return;\r\n            }\r\n            //ausd is setup\r\n            if (!(yield this.userHasAUSD(this.button))) {\r\n                return;\r\n            }\r\n            //ausd > buy amount\r\n            if (!(yield this.userHasEnoughQty(this.button))) {\r\n                return;\r\n            }\r\n            if (!this.hasQuantityAndSymbol(this.button)) {\r\n                return;\r\n            }\r\n            if (!(yield this.isMarketOpen(this.button))) {\r\n                return;\r\n            }\r\n            this.enableExecuteTrade(this.button);\r\n        });\r\n    }\r\n    enableExecuteTrade(button) {\r\n        //if (this.sellTradeInput.quantity.eq(0)) return;\r\n        //execute trade can be done\r\n        button.innerHTML = 'Execute trade';\r\n        button.classList.replace('disabled', 'enabled');\r\n        this.stopLoadingButton(button);\r\n        button.addEventListener('click', () => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            this.loadingButton(button);\r\n            let providerInfo = ProviderInfo.Instance;\r\n            button.innerHTML = 'Confirm transaction in your ' + providerInfo.WalletName + ' wallet';\r\n            if (this.sellTradeInput.symbol == 'aUSD') {\r\n                let liminalMarketService = new LiminalMarketService(this.moralis);\r\n                let symbolAddress = yield liminalMarketService.getSymbolContractAddress(this.buyTradeInput.symbol);\r\n                if (symbolAddress === Helper_AddressZero) {\r\n                    let result = yield liminalMarketService.createToken(this.buyTradeInput.symbol, () => {\r\n                        button.innerHTML = 'Creating token. Give it few seconds';\r\n                    }).finally(() => {\r\n                        this.stopLoadingButton(button);\r\n                        button.innerHTML = 'Execute trade';\r\n                    });\r\n                    if (result instanceof BlockchainError)\r\n                        return;\r\n                    symbolAddress = result;\r\n                }\r\n                yield this.executeTransfer(symbolAddress, button);\r\n            }\r\n            else {\r\n                let liminalMarketService = new LiminalMarketService(this.moralis);\r\n                let symbolAddress = yield liminalMarketService.getSymbolContractAddress(this.sellTradeInput.symbol);\r\n                let securityTokenService = new SecurityTokenService(this.moralis);\r\n                yield securityTokenService.transfer(symbolAddress, this.sellTradeInput.quantity)\r\n                    .catch(reason => {\r\n                    console.log('CATCH - securityTokenService.transfer', reason);\r\n                })\r\n                    .then(transaction => {\r\n                    console.log('THEN - securityTokenService.transfer', transaction);\r\n                    if (!transaction)\r\n                        return;\r\n                    this.monitorExecuteTrade(transaction, TradeType.Sell);\r\n                }).finally(() => {\r\n                    this.stopLoadingButton(button);\r\n                    button.innerHTML = 'Execute trade';\r\n                });\r\n            }\r\n        }));\r\n    }\r\n    executeTransfer(symbolAddress, button) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let aUsdService = new AUSDService(this.moralis);\r\n            yield aUsdService.transfer(symbolAddress, this.sellTradeInput.quantity)\r\n                .catch(reason => {\r\n                console.log('CATCH - aUsdService.transfer', reason);\r\n            }).then(transaction => {\r\n                if (!transaction)\r\n                    return;\r\n                this.monitorExecuteTrade(transaction, TradeType.Buy);\r\n                this.setProgressText('Sending to blockchain', transaction.hash);\r\n            }).finally(() => {\r\n                this.stopLoadingButton(button);\r\n                button.innerHTML = 'Execute trade';\r\n            });\r\n        });\r\n    }\r\n    getBuyingSharesObj(object) {\r\n        let ethAddress = object.walletAddress;\r\n        let tokenAddress = object.tokenAddress;\r\n        let buyingQuantity = object.filled_qty;\r\n        let sellingAmount = '$' + new bignumber(object.amount).div(Math.pow(10, 18)).toFixed();\r\n        return {\r\n            sellingLogo: '/img/logos/aUSD.png',\r\n            sellingSymbol: 'aUSD',\r\n            sellingAmount: sellingAmount,\r\n            buyingLogo: '/img/logos/' + object.symbol + '.png',\r\n            buyingSymbol: object.symbol,\r\n            buyingQuantity: buyingQuantity,\r\n            buyingRoundQuantity: roundNumberDecimal(buyingQuantity, 6) + ' shares',\r\n            shortEthAddress: shortEth(ethAddress),\r\n            tokenAddress: tokenAddress\r\n        };\r\n    }\r\n    getSellSharesObj(object) {\r\n        let ethAddress = object.sender;\r\n        let tokenAddress = object.recipient;\r\n        let buyingQuantity = new bignumber(object.filled_avg_price).multipliedBy(new bignumber(object.filled_qty));\r\n        let sellingAmount = object.filled_qty;\r\n        return {\r\n            sellingLogo: '/img/logos/' + object.symbol + '.png',\r\n            sellingSymbol: object.symbol,\r\n            sellingAmount: sellingAmount + ' shares',\r\n            buyingLogo: '/img/logos/aUSD.png',\r\n            buyingSymbol: 'aUSD',\r\n            buyingQuantity: buyingQuantity.toFixed(),\r\n            buyingRoundQuantity: '$' + roundBigNumberDecimal(buyingQuantity, 6).toFixed(),\r\n            shortEthAddress: shortEth(ethAddress),\r\n            tokenAddress: tokenAddress\r\n        };\r\n    }\r\n    showTradeExecuted(object) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let providerInfo = ProviderInfo.Instance;\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            let isBuy = (object.side == 'buy');\r\n            let obj = (isBuy) ? this.getBuyingSharesObj(object) : this.getSellSharesObj(object);\r\n            obj.walletName = providerInfo.WalletName;\r\n            obj.blockExplorerLink = networkInfo.BlockExplorer + '/tx/' + object.transaction_hash;\r\n            let template = Handlebars.compile(TradeExecuted);\r\n            let content = template(obj);\r\n            let modal = new Modal();\r\n            modal.showModal('Trade executed', content);\r\n            let addTokenToWallet = document.getElementById('addTokenToWallet');\r\n            if (!addTokenToWallet)\r\n                return;\r\n            addTokenToWallet.addEventListener('click', (evt) => {\r\n                let address = evt.target.dataset.address;\r\n                let walletHelper = new WalletHelper(this.moralis);\r\n                walletHelper.addTokenToWallet(address, this.buyTradeInput.symbol, () => {\r\n                    let addTokenToWalletFailed = document.getElementById('addTokenToWalletFailed');\r\n                    if (!addTokenToWalletFailed)\r\n                        return;\r\n                    addTokenToWalletFailed.classList.remove('d-none');\r\n                });\r\n            });\r\n        });\r\n    }\r\n    monitorExecuteTrade(transaction, tradeType) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let subscription = new Subscription(this.moralis);\r\n            yield subscription.subscribeToTable(tradeType, (object) => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n                let user = this.moralis.User.current();\r\n                if (!user)\r\n                    return;\r\n                if (object.walletAddress != user.get('ethAddress')) {\r\n                    return;\r\n                }\r\n                if (object.status == 'order_filled') {\r\n                    yield this.showTradeExecuted(object);\r\n                    yield AUsdBalance.forceLoadAUSDBalanceUI(this.moralis);\r\n                    let executingTrade = document.getElementById('executing-trade-progress');\r\n                    if (!executingTrade)\r\n                        return;\r\n                    executingTrade.classList.add('d-none');\r\n                }\r\n                else if (object.status == 'order_failed') {\r\n                    let modal = new Modal();\r\n                    modal.showModal('Order failed', 'We could not finish your order.');\r\n                }\r\n                else if (!object.status) {\r\n                    this.setProgressText('Received order sending to stock exchange', object.transaction_hash);\r\n                }\r\n                else if (object.status == 'order_requested') {\r\n                    this.setProgressText('Sent to stock exchange', object.transaction_hash);\r\n                    yield AUsdBalance.forceLoadAUSDBalanceUI(this.moralis);\r\n                }\r\n            }));\r\n            let executingTrade = document.getElementById('executing-trade-progress');\r\n            if (!executingTrade)\r\n                return;\r\n            executingTrade.classList.remove('d-none');\r\n        });\r\n    }\r\n    loadingButton(button) {\r\n        button.setAttribute('aria-busy', 'true');\r\n    }\r\n    stopLoadingButton(button) {\r\n        button.removeAttribute('aria-busy');\r\n    }\r\n    walletIsConnected(button) {\r\n        let walletConnected = this.authenticateService.isWalletConnected();\r\n        if (walletConnected)\r\n            return true;\r\n        button.innerHTML = 'Connect wallet';\r\n        button.addEventListener('click', (evt) => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let connectWallet = new ConnectWallet(this.moralis);\r\n            yield connectWallet.connectWallet(evt.target);\r\n        }));\r\n        this.stopLoadingButton(button);\r\n        return false;\r\n    }\r\n    userIsLoggedIn(button) {\r\n        let userLoggedIn = this.authenticateService.isUserLoggedIn();\r\n        if (userLoggedIn)\r\n            return true;\r\n        button.innerHTML = 'Login';\r\n        button.addEventListener('click', () => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            yield this.authenticateService.authenticateUser();\r\n        }));\r\n        this.stopLoadingButton(button);\r\n        return false;\r\n    }\r\n    chainIdIsCorrect(button) {\r\n        let chainId = this.authenticateService.getChainId();\r\n        let networkInfo = NetworkInfo.getInstance();\r\n        if (chainId === networkInfo.ChainId)\r\n            return true;\r\n        let usersWalletNetwork = NetworkInfo.getNetworkInfoByChainId(chainId);\r\n        if (usersWalletNetwork) {\r\n            NetworkInfo.setNetworkByChainId(chainId);\r\n            return true;\r\n        }\r\n        button.innerHTML = 'Switch Network';\r\n        button.addEventListener('click', () => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            yield networkInfo.addNetworkToWallet(this.moralis);\r\n        }));\r\n        this.stopLoadingButton(button);\r\n        return false;\r\n    }\r\n    userHasNativeToken(button) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            let hasEnoughNativeTokens = yield networkInfo.hasEnoughNativeTokens(this.moralis);\r\n            if (hasEnoughNativeTokens)\r\n                return true;\r\n            button.classList.replace('enabled', 'disabled');\r\n            button.innerHTML = 'You need ' + networkInfo.NativeCurrencyName + ' tokens. Click me for some tokens';\r\n            button.addEventListener('click', () => {\r\n                let nativeTokenNeededModal = new NativeTokenNeeded(this.moralis, () => {\r\n                    this.renderButton();\r\n                });\r\n                nativeTokenNeededModal.show();\r\n            });\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    kycIsDone(button, intervalCheck = false) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let kycService = new KYCService(this.moralis);\r\n            let ethAddress = this.authenticateService.getEthAddress();\r\n            if (ethAddress === '') {\r\n                console.log('no ETH address, kyc check failed');\r\n                return false;\r\n            }\r\n            let kycResponse = yield kycService.hasValidKYC();\r\n            if (!kycResponse.isValidKyc && kycResponse.status == 'ACTIVE') {\r\n                this.kycIdDoneTimeout = setInterval(() => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n                    this.loadingButton(button);\r\n                    kycResponse = yield kycService.hasValidKYC();\r\n                    if (kycResponse.isValidKyc) {\r\n                        this.hasBuyingPower = kycResponse.hasBuyingPower;\r\n                        clearInterval(this.kycIdDoneTimeout);\r\n                        yield this.renderButton();\r\n                    }\r\n                }), 10 * 1000);\r\n            }\r\n            if (kycResponse.isValidKyc) {\r\n                if (intervalCheck) {\r\n                    clearInterval(this.kycIdDoneTimeout);\r\n                    let template = Handlebars.compile(KycApproved);\r\n                    let modal = new Modal();\r\n                    modal.showModal('Account approved', template({}));\r\n                    let fundAccount = document.getElementById('kycApprovedFund');\r\n                    fundAccount === null || fundAccount === void 0 ? void 0 : fundAccount.addEventListener('click', (evt) => {\r\n                        modal.hideModal();\r\n                        let ausdFund = new FakeAUSDFund(this.moralis);\r\n                        ausdFund.showAUSDFakeFund(() => {\r\n                            this.renderButton();\r\n                        });\r\n                    });\r\n                }\r\n                return true;\r\n            }\r\n            let kycStatusHandler = new KycStatusHandler(kycResponse, this);\r\n            button.innerHTML = kycStatusHandler.getButtonText();\r\n            button.addEventListener('click', kycStatusHandler.getButtonClickEvent(this));\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    checkKycIsDone() {\r\n        if (this.kycIdDoneTimeout)\r\n            return;\r\n        this.kycIdDoneTimeout = setInterval(() => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            yield this.kycIsDone(this.button, true);\r\n        }), 10 * 1000);\r\n    }\r\n    userHasAUSD(button) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let ausdService = new AUSDService(this.moralis);\r\n            let balance = yield ausdService.getAUSDBalanceOf(this.authenticateService.getEthAddress());\r\n            if (balance.isGreaterThan(0))\r\n                return true;\r\n            if (this.hasBuyingPower) {\r\n                button.innerHTML = 'We are funding your aUSD token';\r\n                this.checkBalanceInterval = setInterval(() => ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n                    AUSDService.lastUpdate = undefined;\r\n                    let balance = yield ausdService.getAUSDBalanceOf(this.authenticateService.getEthAddress());\r\n                    if (balance.isGreaterThan(0)) {\r\n                        yield AUsdBalance.forceLoadAUSDBalanceUI(this.moralis);\r\n                        clearInterval(this.checkBalanceInterval);\r\n                        yield this.renderButton();\r\n                    }\r\n                }), 10 * 1000);\r\n                return false;\r\n            }\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            if (networkInfo.TestNetwork) {\r\n                button.innerHTML = 'You need aUSD. Click here to get some';\r\n                button.addEventListener('click', () => {\r\n                    let ausdFund = new FakeAUSDFund(this.moralis);\r\n                    ausdFund.showAUSDFakeFund(() => {\r\n                        this.renderButton();\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                button.innerHTML = 'You need aUSD. Click here for instructions';\r\n                button.addEventListener('click', () => {\r\n                    let ausdFund = new FakeAUSDFund(this.moralis);\r\n                    ausdFund.showAUSDFund(() => {\r\n                        this.renderButton();\r\n                    });\r\n                });\r\n            }\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    userHasEnoughQty(button) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let ausdService = new AUSDService(this.moralis);\r\n            if (this.sellTradeInput.symbol == 'aUSD') {\r\n                let balance = yield ausdService.getAUSDBalanceOf(this.authenticateService.getEthAddress());\r\n                if (balance.isGreaterThanOrEqualTo(this.sellTradeInput.quantity))\r\n                    return true;\r\n                button.innerHTML = \"You don't have enough aUSD. Click for more funding\";\r\n                button.addEventListener('click', () => {\r\n                    let networkInfo = NetworkInfo.getInstance();\r\n                    let ausdFund = new FakeAUSDFund(this.moralis);\r\n                    if (networkInfo.TestNetwork) {\r\n                        ausdFund.showAUSDFakeFund(() => {\r\n                            this.renderButton();\r\n                        });\r\n                    }\r\n                    else {\r\n                        ausdFund.showAUSDFund(() => {\r\n                            this.renderButton();\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                let securityTokenService = new SecurityTokenService(this.moralis);\r\n                let authenticateService = new AuthenticateService(this.moralis);\r\n                let ethAddress = authenticateService.getEthAddress();\r\n                let userQuantity = yield securityTokenService.getQuantityByAddress(this.sellTradeInput.symbol, ethAddress);\r\n                if (this.sellTradeInput.quantity <= userQuantity)\r\n                    return true;\r\n                button.innerHTML = \"You don't have enough \" + this.sellTradeInput.symbol;\r\n                button.classList.replace('disable', 'enable');\r\n            }\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    isMarketOpen(button) {\r\n        return ExecuteTradeButton_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(this.moralis);\r\n            let isMarketOpen = yield userService.isMarketOpenOrUserOffHours();\r\n            if (isMarketOpen)\r\n                return true;\r\n            button.innerHTML = 'Market is closed';\r\n            button.classList.replace('enabled', 'disabled');\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        });\r\n    }\r\n    hasQuantityAndSymbol(button) {\r\n        if (this.sellTradeInput.quantity.eq(0)) {\r\n            button.innerHTML = 'Type in quantity';\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        }\r\n        if (this.buyTradeInput.name == '') {\r\n            button.innerHTML = 'Select stock to buy';\r\n            this.stopLoadingButton(button);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    setProgressText(text, hash) {\r\n        let progressText = document.getElementById('progress-text');\r\n        if (progressText) {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            progressText.innerHTML = text + '<br /><a href=\"' + networkInfo.BlockExplorer + '/tx/' + hash + '\" target=\"_blank\" style=\"font-size:10px\">View</a>';\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/TradeInput.html\n// Module\nvar TradeInput_code = \"<article class=\\\"{{tradeType}}Inputs tradeInputArticle\\\">\\r\\n    <div class=\\\"grid tradeInput\\\">\\r\\n        <div class=\\\"select_token\\\">\\r\\n            <a id=\\\"{{tradeType}}SelectStock\\\" href=\\\"#\\\" role=\\\"button\\\">\\r\\n                <img src=\\\"{{logo}}\\\"/>\\r\\n                {{symbol}}\\r\\n            </a>\\r\\n        </div>\\r\\n        <div class=\\\"trade_input\\\"><input autocomplete=\\\"off\\\" autocorrect=\\\"off\\\" type=\\\"tel\\\" spellcheck=\\\"false\\\"\\r\\n                                        value=\\\"{{strQuantity}}\\\" placeholder=\\\"0.0\\\"/></div>\\r\\n        <div class=\\\"balance\\\">Balance : <abbr title=\\\"{{balance}}\\\" data-tooltip=\\\"{{balance}}\\\" class=\\\"balance_value\\\">{{abbrBalance}}</abbr>\\r\\n            <a href=\\\"\\\" class=\\\"balance_max\\\">Max</a></div>\\r\\n        <div class=\\\"price_per_share\\\"></div>\\r\\n    </div>\\r\\n    <progress class=\\\"progress d-none\\\" value=\\\"0\\\" max=\\\"1\\\"></progress>\\r\\n    <div class=\\\"exceeds_wallet_balance d-none\\\">Exceeds wallet balance</div>\\r\\n</article>\\r\\n\";\n// Exports\n/* harmony default export */ const TradeInput = (TradeInput_code);\n;// CONCATENATED MODULE: ./src/ui/modals/SecuritiesListModal.ts\nvar SecuritiesListModal_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass SecuritiesListModal {\r\n    constructor(moralis) {\r\n        this.tbodyId = 'liminal_market_securities_list';\r\n        this.moralis = moralis;\r\n        this.page = 0;\r\n        this.loadmore = true;\r\n        this.modal = new Modal();\r\n    }\r\n    showModal(onSelectSymbol) {\r\n        return SecuritiesListModal_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesList = new SecuritiesList(this.moralis);\r\n            let content = yield securitiesList.render();\r\n            let newInstance = this.modal.showModal('Select stock to buy', content, true);\r\n            //if (newInstance)\r\n            {\r\n                yield securitiesList.bindEvents(onSelectSymbol);\r\n            }\r\n        });\r\n    }\r\n    hideModal() {\r\n        this.modal.hideModal();\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/services/backend/TradeInfo.ts\nclass TradeInfo {\r\n    constructor(price, lastTrade) {\r\n        this.price = price;\r\n        this.lastTrade = lastTrade;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/cloud/HttpError.ts\n\r\n\r\nclass HttpError {\r\n    constructor(obj) {\r\n        this.method = obj.method;\r\n        this.url = obj.url;\r\n        this.body = obj.body;\r\n        this.serverError = obj.serverError;\r\n    }\r\n    handle() {\r\n        console.log(this);\r\n        ErrorInfo.report(new GeneralError('Error doing request. Server response was:' + this.serverError.data.message));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/errors/CloudError.ts\n\r\n\r\n\r\nclass CloudError extends GeneralError {\r\n    constructor(e) {\r\n        super(e);\r\n        try {\r\n            let obj = JSON.parse(e.message);\r\n            if (obj.name) {\r\n                let errorHandler = CloudError.getActionInstance(obj.name, obj);\r\n                if (errorHandler) {\r\n                    errorHandler.handle();\r\n                    return;\r\n                }\r\n            }\r\n            ErrorInfo.error(obj);\r\n        }\r\n        catch (jsonError) {\r\n            ErrorInfo.error(e);\r\n        }\r\n    }\r\n    static getActionInstance(action, obj) {\r\n        let tmp = undefined;\r\n        for (let i = 0; i < CloudError.Errors.length; i++) {\r\n            if (CloudError.Errors[i].name === action) {\r\n                let errorHandler = CloudError.Errors[i];\r\n                return new errorHandler(obj);\r\n            }\r\n        }\r\n        return tmp;\r\n    }\r\n}\r\nCloudError.Errors = [\r\n    HttpError\r\n];\r\n\n;// CONCATENATED MODULE: ./src/services/backend/StockPriceService.ts\nvar StockPriceService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass StockPriceService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    getSymbolPrice(symbol, tradeType) {\r\n        return StockPriceService_awaiter(this, void 0, void 0, function* () {\r\n            const params = {\r\n                symbol: symbol\r\n            };\r\n            let result = yield this.moralis.Cloud.run(\"getSymbolPrice\", params)\r\n                .catch((e) => {\r\n                throw new CloudError(e);\r\n            });\r\n            let quote = result.quote;\r\n            let price = (tradeType == TradeType.Sell) ? quote.ap : quote.bp;\r\n            let tradeInfo = new TradeInfo(price, quote.t);\r\n            return tradeInfo;\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/PricePerShare.html\n// Module\nvar PricePerShare_code = \"<abbr title=\\\"Last trade was {{lastTraded}}\\\" data-tooltip=\\\"Last trade was {{lastTraded}}\\\">{{text}}</abbr>\";\n// Exports\n/* harmony default export */ const PricePerShare = (PricePerShare_code);\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/TradePanelInput.ts\nvar TradePanelInput_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TradePanelInput {\r\n    constructor(moralis, symbol, name, logo, address, tradeType) {\r\n        this.isDirty = false;\r\n        this.moralis = moralis;\r\n        this.symbol = symbol;\r\n        this.name = name;\r\n        this.logo = logo;\r\n        this.address = address;\r\n        this.tradeType = tradeType;\r\n        this.quantity = new bignumber(0);\r\n        this.strQuantity = '';\r\n        this.balance = new bignumber(0);\r\n        this.lastPrice = 0;\r\n        this.qtyPerDollar = 0;\r\n        this.lastTraded = '';\r\n        this.template = Handlebars.compile(TradeInput);\r\n        this.pricePerShareTemplate = Handlebars.compile(PricePerShare);\r\n    }\r\n    setOtherTradePanelInput(tradePanelInput) {\r\n        this.otherTradePanelInput = tradePanelInput;\r\n    }\r\n    renderToString() {\r\n        return this.template(this);\r\n    }\r\n    render(bindEvents = true) {\r\n        let element = document.querySelector('.' + this.tradeType + 'Inputs');\r\n        element.outerHTML = this.renderToString();\r\n        if (bindEvents) {\r\n            this.bindEvents();\r\n        }\r\n    }\r\n    bindEvents() {\r\n        this.bindQuantityListener();\r\n        this.bindSelectStockButton();\r\n        this.bindMaxLink();\r\n    }\r\n    setSymbol(symbol, name, logo) {\r\n        this.symbol = symbol;\r\n        this.name = name;\r\n        this.logo = logo;\r\n        this.isDirty = true;\r\n    }\r\n    bindSelectStockButton() {\r\n        let selectStock = document.querySelector('#' + this.tradeType + 'SelectStock');\r\n        if (!selectStock)\r\n            return;\r\n        selectStock.addEventListener('click', (evt) => TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            let securityList = new SecuritiesListModal(this.moralis);\r\n            yield securityList.showModal((symbol, name, logo) => TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n                securityList.hideModal();\r\n                if (this.otherTradePanelInput && this.symbol == 'aUSD' && symbol != this.symbol) {\r\n                    this.otherTradePanelInput.setSymbol(this.symbol, this.name, this.logo);\r\n                }\r\n                this.symbol = symbol;\r\n                this.name = name;\r\n                this.logo = logo;\r\n                let liminalMarketService = new LiminalMarketService(this.moralis);\r\n                this.address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                this.render();\r\n                this.loadBalance().then();\r\n                yield this.loadLastTrade();\r\n                if (this.onUpdate)\r\n                    this.onUpdate();\r\n            }));\r\n        }));\r\n    }\r\n    bindQuantityListener() {\r\n        let qtyInput = document.querySelector('.' + this.tradeType + 'Inputs .trade_input input');\r\n        if (!qtyInput)\r\n            return;\r\n        let inputTimer;\r\n        qtyInput.addEventListener('keyup', (evt) => {\r\n            if (inputTimer)\r\n                clearTimeout(inputTimer);\r\n            inputTimer = setTimeout(() => {\r\n                let inputValue = evt.target.value;\r\n                this.setQuantity(inputValue);\r\n                this.loadProgressbar();\r\n                if (this.otherTradePanelInput)\r\n                    this.otherTradePanelInput.updateQuantity();\r\n                if (this.onUpdate)\r\n                    this.onUpdate();\r\n            }, 300);\r\n        });\r\n    }\r\n    bindMaxLink() {\r\n        let maxBalanceDom = document.querySelector('.' + this.tradeType + 'Inputs .balance_max');\r\n        if (!maxBalanceDom)\r\n            return;\r\n        maxBalanceDom.addEventListener('click', (evt) => {\r\n            evt.preventDefault();\r\n            let qtyInput = document.querySelector('.' + this.tradeType + 'Inputs .trade_input input');\r\n            if (!qtyInput)\r\n                return;\r\n            qtyInput.value = this.balance.toFixed();\r\n            this.setQuantity(qtyInput.value);\r\n            this.loadProgressbar();\r\n            if (this.otherTradePanelInput)\r\n                this.otherTradePanelInput.updateQuantity();\r\n            if (this.onUpdate)\r\n                this.onUpdate();\r\n        });\r\n    }\r\n    loadBalance() {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            this.balance = new bignumber(0);\r\n            let userService = new UserService(this.moralis);\r\n            let ethAddress = userService.getEthAddress();\r\n            let balanceDom = document.querySelector('.' + this.tradeType + 'Inputs .balance_value');\r\n            if (!balanceDom)\r\n                return;\r\n            if (this.symbol === 'aUSD') {\r\n                if (ethAddress) {\r\n                    let aUsdService = new AUSDService(this.moralis);\r\n                    this.balance = yield aUsdService.getAUSDBalanceOf(ethAddress);\r\n                }\r\n                balanceDom.innerHTML = '$' + roundBigNumber(this.balance).toString();\r\n            }\r\n            else if (this.name !== '') {\r\n                this.balance = new bignumber(0);\r\n                if (ethAddress) {\r\n                    let securityTokenService = new SecurityTokenService(this.moralis);\r\n                    this.balance = yield securityTokenService.getQuantityByAddress(this.symbol, ethAddress);\r\n                }\r\n                balanceDom.innerHTML = roundBigNumberDecimal(this.balance, 6).toString();\r\n            }\r\n            balanceDom.dataset.tooltip = this.balance.toString();\r\n            balanceDom.title = this.balance.toString();\r\n            this.loadProgressbar();\r\n            this.toggleMaxBalanceLink();\r\n        });\r\n    }\r\n    loadLastTrade() {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            if (this.symbol === 'aUSD') {\r\n                this.lastPrice = 1;\r\n                this.qtyPerDollar = 1;\r\n                return;\r\n            }\r\n            if (!this.otherTradePanelInput || this.name == '')\r\n                return;\r\n            let aUsdPricePerShare = document.querySelector('.' + this.otherTradePanelInput.tradeType + 'Inputs .price_per_share');\r\n            if (!aUsdPricePerShare)\r\n                return;\r\n            let pricePerShare = document.querySelector('.' + this.tradeType + 'Inputs .price_per_share');\r\n            if (!pricePerShare)\r\n                return;\r\n            aUsdPricePerShare.setAttribute('aria-busy', 'true');\r\n            pricePerShare.setAttribute('aria-busy', 'true');\r\n            let stockPriceService = new StockPriceService(this.moralis);\r\n            let tradeInfo = yield stockPriceService.getSymbolPrice(this.symbol, this.otherTradePanelInput.tradeType);\r\n            this.lastPrice = tradeInfo.price;\r\n            this.lastTraded = tradeInfo.lastTrade.toString();\r\n            this.qtyPerDollar = 1 / this.lastPrice;\r\n            let pricePerShareHtml = {\r\n                lastTraded: this.lastTraded,\r\n                text: ' $' + this.lastPrice + ' per share'\r\n            };\r\n            pricePerShare.innerHTML = this.pricePerShareTemplate(pricePerShareHtml);\r\n            let pricePerAUsdHtml = {\r\n                lastTraded: this.lastTraded,\r\n                text: '1 aUSD  ' + roundNumberDecimal(this.qtyPerDollar, 6) + ' ' + this.symbol\r\n            };\r\n            aUsdPricePerShare.innerHTML = this.pricePerShareTemplate(pricePerAUsdHtml);\r\n            this.updateQuantity();\r\n            aUsdPricePerShare.removeAttribute('aria-busy');\r\n            pricePerShare.removeAttribute('aria-busy');\r\n        });\r\n    }\r\n    updateQuantity() {\r\n        if (!this.otherTradePanelInput)\r\n            return;\r\n        let qtyInput = document.querySelector('.' + this.tradeType + 'Inputs .trade_input input');\r\n        if (!qtyInput)\r\n            return;\r\n        if (this.symbol === 'aUSD') {\r\n            qtyInput.value = this.otherTradePanelInput.quantity.div(this.otherTradePanelInput.qtyPerDollar).toString();\r\n        }\r\n        else {\r\n            qtyInput.value = this.otherTradePanelInput.quantity.multipliedBy(this.qtyPerDollar).toString();\r\n        }\r\n        this.setQuantity(qtyInput.value);\r\n        this.loadProgressbar();\r\n    }\r\n    loadProgressbar() {\r\n        if (this.quantity.eq(0) || this.balance.eq(0) || this.tradeType == TradeType.Buy)\r\n            return;\r\n        let progressDom = document.querySelector('.' + this.tradeType + 'Inputs .progress');\r\n        if (!progressDom)\r\n            return;\r\n        let percentage = this.quantity.div(this.balance).toNumber();\r\n        progressDom.value = percentage;\r\n        progressDom.classList.remove('d-none');\r\n        let exceedsBalance = document.querySelector('.' + this.tradeType + 'Inputs .exceeds_wallet_balance');\r\n        if (percentage > 1) {\r\n            exceedsBalance.classList.remove('d-none');\r\n            progressDom.setAttribute('aria-invalid', 'true');\r\n        }\r\n        else {\r\n            exceedsBalance.classList.add('d-none');\r\n        }\r\n    }\r\n    static switchPanels(sellTradePanelInput, buyTradePanelInput) {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            let sellSymbol = sellTradePanelInput.symbol;\r\n            let sellName = sellTradePanelInput.name;\r\n            let sellLogo = sellTradePanelInput.logo;\r\n            let sellQuantity = sellTradePanelInput.quantity;\r\n            sellTradePanelInput.setSymbol(buyTradePanelInput.symbol, buyTradePanelInput.name, buyTradePanelInput.logo);\r\n            sellTradePanelInput.quantity = buyTradePanelInput.quantity;\r\n            buyTradePanelInput.setSymbol(sellSymbol, sellName, sellLogo);\r\n            buyTradePanelInput.quantity = sellQuantity;\r\n            yield sellTradePanelInput.updatePanel();\r\n            yield buyTradePanelInput.updatePanel();\r\n            return [sellTradePanelInput, buyTradePanelInput];\r\n        });\r\n    }\r\n    setQuantity(value) {\r\n        if (value == '' || value == '0')\r\n            return;\r\n        this.quantity = new bignumber(value);\r\n        this.strQuantity = value;\r\n    }\r\n    quantityFormatted() {\r\n        return (this.symbol === 'aUSD') ? '$' + this.quantity : this.quantity;\r\n    }\r\n    updatePanel() {\r\n        return TradePanelInput_awaiter(this, void 0, void 0, function* () {\r\n            this.updateQuantity();\r\n            this.render(true);\r\n            yield this.loadBalance();\r\n            yield this.loadLastTrade();\r\n        });\r\n    }\r\n    toggleMaxBalanceLink() {\r\n        let maxBalanceDom = document.querySelector('.' + this.tradeType + 'Inputs .balance_max');\r\n        if (!maxBalanceDom)\r\n            return;\r\n        if (this.balance.eq(0)) {\r\n            maxBalanceDom.classList.add('d-none');\r\n        }\r\n        else {\r\n            maxBalanceDom.classList.remove('d-none');\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/tradepanel/TradeSwitch.html\n// Module\nvar TradeSwitch_code = \"<div class=\\\"grid tradeSwitch\\\">\\r\\n    <a title=\\\"Switch the trade\\\" href=\\\"\\\" class=\\\"switchBtn\\\" class=\\\"outline\\\"></a>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const tradepanel_TradeSwitch = (TradeSwitch_code);\n;// CONCATENATED MODULE: ./src/ui/elements/tradepanel/TradeSwitch.ts\nvar TradeSwitch_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass TradeSwitch {\r\n    constructor() {\r\n        this.template = undefined;\r\n        this.template = Handlebars.compile(tradepanel_TradeSwitch);\r\n    }\r\n    renderToString() {\r\n        return this.template();\r\n    }\r\n    render() {\r\n        let dom = document.querySelector('.tradeSwitch');\r\n        if (!dom)\r\n            return;\r\n        dom.outerHTML = this.renderToString();\r\n    }\r\n    bindEvents(sellTradePanelInput, buyTradePanelInput, executeTradeButton) {\r\n        let dom = document.querySelector('.switchBtn');\r\n        if (!dom)\r\n            return;\r\n        dom.addEventListener('click', (evt) => TradeSwitch_awaiter(this, void 0, void 0, function* () {\r\n            evt.preventDefault();\r\n            [sellTradePanelInput, buyTradePanelInput] = yield TradePanelInput.switchPanels(sellTradePanelInput, buyTradePanelInput);\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/TradePanel.ts\nvar TradePanel_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\nclass TradePanel {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.quantity = 0;\r\n    }\r\n    render(elementId, symbol, name, logo, address) {\r\n        return TradePanel_awaiter(this, void 0, void 0, function* () {\r\n            let element = document.getElementById(elementId);\r\n            if (!element)\r\n                return;\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let sellTradeInput = new TradePanelInput(this.moralis, \"aUSD\", \"aUSD at Broker\", \"/img/ausd.png\", contractInfo.AUSD_ADDRESS, TradeType.Sell);\r\n            let buyTradeInput;\r\n            if (!symbol) {\r\n                buyTradeInput = new TradePanelInput(this.moralis, \"Select stock\", \"\", \"\", \"\", TradeType.Buy);\r\n            }\r\n            else {\r\n                buyTradeInput = new TradePanelInput(this.moralis, symbol, name, logo, address, TradeType.Buy);\r\n            }\r\n            sellTradeInput.setOtherTradePanelInput(buyTradeInput);\r\n            buyTradeInput.setOtherTradePanelInput(sellTradeInput);\r\n            let tradeSwitch = new TradeSwitch();\r\n            let sellInput = sellTradeInput.renderToString();\r\n            let buyInput = buyTradeInput.renderToString();\r\n            let switchHtml = tradeSwitch.renderToString();\r\n            element.innerHTML = sellInput + switchHtml + buyInput;\r\n            yield sellTradeInput.loadBalance();\r\n            yield buyTradeInput.loadBalance();\r\n            if (symbol) {\r\n                yield buyTradeInput.loadLastTrade();\r\n            }\r\n            sellTradeInput.bindEvents();\r\n            buyTradeInput.bindEvents();\r\n            let executeTradeButton = new ExecuteTradeButton(this.moralis, sellTradeInput, buyTradeInput);\r\n            yield executeTradeButton.renderButton();\r\n            tradeSwitch.bindEvents(sellTradeInput, buyTradeInput, executeTradeButton);\r\n            sellTradeInput.onUpdate = () => {\r\n                if (buyTradeInput.isDirty)\r\n                    buyTradeInput.updatePanel();\r\n                executeTradeButton.renderButton();\r\n            };\r\n            buyTradeInput.onUpdate = () => {\r\n                if (sellTradeInput.isDirty)\r\n                    sellTradeInput.updatePanel();\r\n                executeTradeButton.renderButton();\r\n            };\r\n        });\r\n    }\r\n    formatBuyPanel(symbol, name, logo, tradeType, contractAddress) {\r\n        document.getElementById('liminal_market_select_symbol').innerHTML = symbol;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/pages/trade.html\n// Module\nvar trade_code = \"<div id=\\\"tradingPanel\\\">\\r\\n    <a href=\\\"#use_wallet_for_orders\\\" id=\\\"use_wallet_for_orders_link\\\" class=\\\"not_visible\\\">Trade in your wallet instead of\\r\\n        here</a>\\r\\n    <article id=\\\"liminal_market_trade_panel\\\"></article>\\r\\n    <div id=\\\"executing-trade-progress\\\" class=\\\"d-none\\\">\\r\\n        <div id=\\\"progress-text\\\"></div>\\r\\n        <progress></progress>\\r\\n    </div>\\r\\n    <button id=\\\"liminal_market_execute_trade\\\"></button>\\r\\n\\r\\n    <article id=\\\"use_wallet_for_orders\\\">\\r\\n\\r\\n        <h3>How to buy in wallet</h3>\\r\\n        <ul>\\r\\n            <li>If you haven't added aUSD to your wallet, now is the time - <small><a href=\\\"\\\" id=\\\"addAUSDToWallet\\\">Click\\r\\n                here to add aUSD to wallet</a></small></li>\\r\\n            <li><a href=\\\"\\\" class=\\\"findSymbol\\\">Find symbol</a> you want to buy & click \\\"Get address\\\"</li>\\r\\n            <li>Go to your wallet and find the aUSD token, click \\\"Send\\\"</li>\\r\\n            <li>Paste in the address you just copied for the Receiver.\\r\\n                <ul>\\r\\n                    <li><em>Note: If you can, save the address to your contact list for easy access next time</em></li>\\r\\n                </ul>\\r\\n            </li>\\r\\n\\r\\n            <li>Type in the amount & click Confirm</li>\\r\\n            <li>You have now bought the shares, don't forget to <a href=\\\"\\\" class=\\\"findSymbol\\\">add the token to wallet</a>. &#127881;</li>\\r\\n        </ul>\\r\\n        <div style=\\\"text-align: center;\\\">\\r\\n            <!--\\r\\n                        <iframe width=\\\"380\\\" height=\\\"500\\\" src=\\\"https://www.youtube.com/embed/m1iNotgaic4?autoplay=1&cc_load_policy=1&playlist=m1iNotgaic4&loop=1\\\" title=\\\"YouTube video player\\\" frameborder=\\\"0\\\" allow=\\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\\\" allowfullscreen></iframe>\\r\\n            -->\\r\\n        </div>\\r\\n\\r\\n\\r\\n        <h3>Sell your securities</h3>\\r\\n\\r\\n        <ul>\\r\\n            <li>Find the token you want so sell in you wallet and click Send</li>\\r\\n            <li>Put the in the aUSD address<br/><input id=\\\"aUsdAddress\\\" value=\\\"{{AUSDAddress}}\\\">\\r\\n                <ul>\\r\\n                    <li><em>Note: If you can, save the address to your contact list for easy access next time</em></li>\\r\\n                </ul>\\r\\n            </li>\\r\\n            <li>Type in the quantity of shares you want to sell & click Confirm</li>\\r\\n            <li>You have now sold the shares &#127881;</li>\\r\\n        </ul>\\r\\n\\r\\n    </article>\\r\\n</div>\";\n// Exports\n/* harmony default export */ const trade = (trade_code);\n;// CONCATENATED MODULE: ./src/html/modal/CopyTokenAddressToAddToWallet.html\n// Module\nvar CopyTokenAddressToAddToWallet_code = \"\\r\\n\\r\\n    You can copy the address of {{symbol}} and import it into your wallet\\r\\n    <input id=\\\"tokenAddress\\\" value=\\\"{{tokenAddress}}\\\" />\\r\\n\\r\\n\";\n// Exports\n/* harmony default export */ const CopyTokenAddressToAddToWallet = (CopyTokenAddressToAddToWallet_code);\n;// CONCATENATED MODULE: ./src/ui/pages/TradePage.ts\nvar TradePage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass TradePage {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    load(symbol, name, logo, address) {\r\n        return TradePage_awaiter(this, void 0, void 0, function* () {\r\n            let mainContainer = document.getElementById('main_container');\r\n            if (!mainContainer)\r\n                return;\r\n            let contractInfo = ContractInfo.getContractInfo();\r\n            let template = Handlebars.compile(trade);\r\n            mainContainer.innerHTML = template({ AUSDAddress: contractInfo.AUSD_ADDRESS });\r\n            let tradePanel = new TradePanel(this.moralis);\r\n            yield tradePanel.render('liminal_market_trade_panel');\r\n            if (symbol) {\r\n                yield this.selectSymbol(symbol, name, logo, address);\r\n            }\r\n            let user = new UserService(this.moralis);\r\n            let ethAddress = user.getEthAddress();\r\n            let aUSDService = new AUSDService(this.moralis);\r\n            let ausdAmount = new bignumber(0);\r\n            if (ethAddress) {\r\n                ausdAmount = yield aUSDService.getAUSDBalanceOf(ethAddress);\r\n            }\r\n            let userWallet = document.getElementById('use_wallet_for_orders');\r\n            let userWalletLink = document.getElementById('use_wallet_for_orders_link');\r\n            if (ausdAmount.eq(0)) {\r\n                userWallet === null || userWallet === void 0 ? void 0 : userWallet.classList.add('hidden');\r\n                userWalletLink === null || userWalletLink === void 0 ? void 0 : userWalletLink.classList.add('not_visible');\r\n            }\r\n            else {\r\n                userWallet === null || userWallet === void 0 ? void 0 : userWallet.classList.remove('hidden');\r\n                userWalletLink === null || userWalletLink === void 0 ? void 0 : userWalletLink.classList.remove('not_visible');\r\n            }\r\n            let findSymbols = document.querySelectorAll('.findSymbol');\r\n            findSymbols === null || findSymbols === void 0 ? void 0 : findSymbols.forEach(findSymbol => {\r\n                findSymbol.addEventListener('click', (evt) => {\r\n                    evt.preventDefault();\r\n                    let securitiesModal = new SecuritiesListModal(this.moralis);\r\n                    securitiesModal.showModal(() => {\r\n                        securitiesModal.hideModal();\r\n                    });\r\n                });\r\n            });\r\n            let addAUSDToWallet = document.getElementById('addAUSDToWallet');\r\n            addAUSDToWallet === null || addAUSDToWallet === void 0 ? void 0 : addAUSDToWallet.addEventListener('click', (evt) => {\r\n                evt.preventDefault();\r\n                let walletHelper = new WalletHelper(this.moralis);\r\n                walletHelper.addTokenToWallet(contractInfo.AUSD_ADDRESS, 'aUSD', () => {\r\n                    let modal = new Modal();\r\n                    let template = Handlebars.compile(CopyTokenAddressToAddToWallet);\r\n                    let content = template({ symbol: 'aUSD', tokenAddress: contractInfo.AUSD_ADDRESS });\r\n                    modal.showModal('Add aUSD to wallet', content);\r\n                });\r\n            });\r\n        });\r\n    }\r\n    ;\r\n    selectSymbol(symbol, name, logo, address) {\r\n        return TradePage_awaiter(this, void 0, void 0, function* () {\r\n            let tradePanel = new TradePanel(this.moralis);\r\n            yield tradePanel.render('liminal_market_trade_panel', symbol, name, logo, address);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/pages/stockspage.html\n// Module\nvar stockspage_code = \"\\r\\n<article id=\\\"stockList\\\">\\r\\n <div id=\\\"ua\\\"></div>\\r\\n <div id=\\\"list_of_securities\\\">{{{securities}}}</div>\\r\\n\\r\\n</article>\";\n// Exports\n/* harmony default export */ const stockspage = (stockspage_code);\n;// CONCATENATED MODULE: ./src/ui/pages/StocksPage.ts\nvar StocksPage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass StocksPage {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    load() {\r\n        return StocksPage_awaiter(this, void 0, void 0, function* () {\r\n            let mainContainer = document.getElementById('main_container');\r\n            if (!mainContainer)\r\n                return;\r\n            let securitiesList = new SecuritiesList(this.moralis);\r\n            let securities = yield securitiesList.render();\r\n            let template = Handlebars.compile(stockspage);\r\n            mainContainer.innerHTML = template({ securities: securities });\r\n            yield securitiesList.loadMore();\r\n            yield securitiesList.bindEvents((symbol, name, logo) => StocksPage_awaiter(this, void 0, void 0, function* () {\r\n                let liminalMarketService = new LiminalMarketService(this.moralis);\r\n                let address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                let tradePage = new TradePage(this.moralis);\r\n                window.scrollTo(0, 0);\r\n                history.pushState(null, 'Buy stocks', '#/trade');\r\n                yield tradePage.load(symbol, name, logo, address);\r\n            }));\r\n        });\r\n    }\r\n    ;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/elements/documents.html\n// Module\nvar documents_code = \"<h3>Documents</h3>\\r\\n<p>These are your documents for your trades, generated by the broker. These documents are trade confirmation & monthly statements.\\r\\n\\tThey are generated at the end of the day, between 06:30PM-07:30PM EST.\\r\\n</p>\\r\\n{{#if result}}\\r\\n<table class=\\\"table table-hover\\\">\\r\\n\\t<thead>\\r\\n\\t\\t<tr>\\r\\n\\t\\t\\t<th>Type</th>\\r\\n\\t\\t\\t<th>Date</th>\\r\\n\\t\\t\\t<th>Download</th>\\r\\n\\t\\t</tr>\\r\\n\\t</thead>\\r\\n\\t<tbody>\\r\\n\\t\\t{{#each result}}\\r\\n\\t\\t<tr>\\r\\n\\t\\t\\t<td title=\\\"{{id}}\\\">{{type}}</a></td>\\r\\n\\t\\t\\t<td>{{date}}</td>\\r\\n\\t\\t\\t<td><a href=\\\"\\\" class=\\\"downloadDoc\\\" data-docid=\\\"{{id}}\\\">Download</a></td>\\r\\n\\t\\t</tr>\\r\\n\\t\\t{{/each}}\\r\\n\\t</tbody>\\r\\n</table>\\r\\n{{/if}}\";\n// Exports\n/* harmony default export */ const elements_documents = (documents_code);\n;// CONCATENATED MODULE: ./src/services/backend/DocumentService.ts\nvar DocumentService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass DocumentService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    getDocuments() {\r\n        return DocumentService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('documents');\r\n        });\r\n    }\r\n    getDocument(documentId) {\r\n        return DocumentService_awaiter(this, void 0, void 0, function* () {\r\n            const params = {\r\n                documentId: documentId\r\n            };\r\n            return yield this.moralis.Cloud.run(\"download\", params);\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/modal/CreateToken.html\n// Module\nvar CreateToken_code = \"Token for {{symbol}} does not exist. You can click the button below to create the token. This will cost a bit of gas.\\r\\n<br /><br />\\r\\nAfter the token has been created we will try to add it to your wallet.\\r\\n<br /><br />\\r\\n<button id=\\\"createTokenBtn\\\">Create token</button>\\r\\n\\r\\n<div class=\\\"d-none\\\" id=\\\"copyAddressInfo\\\">\\r\\n    You can copy the address of the token and import it into your wallet\\r\\n    <input id=\\\"tokenAddress\\\" />\\r\\n\\r\\n</div>\";\n// Exports\n/* harmony default export */ const modal_CreateToken = (CreateToken_code);\n;// CONCATENATED MODULE: ./src/ui/modals/CreateToken.ts\nvar CreateToken_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass CreateToken {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    show(symbol) {\r\n        let modal = new Modal();\r\n        let template = Handlebars.compile(modal_CreateToken);\r\n        modal.showModal(\"Token \" + symbol + \" doesn't exist\", template({ symbol: symbol }));\r\n        let btn = document.getElementById('createTokenBtn');\r\n        if (!btn)\r\n            return;\r\n        btn.addEventListener('click', () => CreateToken_awaiter(this, void 0, void 0, function* () {\r\n            LoadingHelper.setLoading(btn);\r\n            let liminalMarketService = new LiminalMarketService(this.moralis);\r\n            let address = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n            if (address === Helper_AddressZero) {\r\n                let result = yield liminalMarketService.createToken(symbol, () => {\r\n                    btn.innerHTML = 'Creating token. Give it few seconds';\r\n                });\r\n                if (result instanceof BlockchainError && result.code == BlockchainError.UserCancelled) {\r\n                    LoadingHelper.removeLoading();\r\n                    return;\r\n                }\r\n                address = result;\r\n            }\r\n            LoadingHelper.removeLoading();\r\n            btn.innerHTML = 'Add token to wallet';\r\n            let walletHelper = new WalletHelper(this.moralis);\r\n            yield walletHelper.addTokenToWallet(address, symbol, () => {\r\n                let tokenAddressInput = document.getElementById('tokenAddress');\r\n                if (!tokenAddressInput)\r\n                    return;\r\n                tokenAddressInput.innerHTML = address;\r\n                document.getElementById('copyAddressInfo').classList.remove('d-none');\r\n            });\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/html/pages/positions.html\n// Module\nvar positions_code = \"<article class=\\\"loaded-content2\\\">\\r\\n\\t<h3>Positions<!-- <a href=\\\"\\\" role=\\\"button\\\" id=\\\"syncWallet\\\">Sync wallet</a>--></h3>\\r\\n\\t<figure>\\r\\n\\t<table>\\r\\n\\t\\t<thead>\\r\\n\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t<th></th>\\r\\n\\t\\t\\t\\t<th>Symbol</th>\\r\\n\\t\\t\\t\\t<th>Current price</th>\\r\\n\\t\\t\\t\\t<th>Avg. entry value</th>\\r\\n\\t\\t\\t\\t<th>Quantity</th>\\r\\n\\t\\t\\t\\t<th>Market value</th>\\r\\n\\t\\t\\t\\t<th>Unrealize PL</th>\\r\\n\\t\\t\\t\\t<th>Trade</th>\\r\\n\\t\\t\\t\\t<th>Add to wallet</th>\\r\\n\\t\\t\\t</tr>\\r\\n\\t\\t</thead>\\r\\n\\t\\t<tbody>\\r\\n\\t\\t\\t{{#if result}}\\r\\n\\t\\t\\t{{#each result}}\\r\\n\\t\\t\\t<tr>\\r\\n\\t\\t\\t\\t<td class=\\\"symbol_logo\\\"><img id=\\\"symbol_logo_{{symbol}}\\\" src=\\\"/img/logos/default_logo.png\\\" /></td>\\r\\n\\t\\t\\t\\t<td><a href=\\\"https://strike.market/stocks/{{symbol}}\\\" target=\\\"_blank\\\">{{symbol}}</a></td>\\r\\n\\t\\t\\t\\t<td>{{current_price}}</td>\\r\\n\\t\\t\\t\\t<td>{{round2 avg_entry_price}}</td>\\r\\n\\t\\t\\t\\t<td>{{round2 qty}}</td>\\r\\n\\t\\t\\t\\t<td>${{round market_value}}</td>\\r\\n\\t\\t\\t\\t<td class=\\\"{{classColor unrealized_pl}}\\\">${{round unrealized_pl}} ({{perc unrealized_plpc}})</td>\\r\\n\\t\\t\\t\\t<td><a href=\\\"#\\\" class=\\\"tradeSecurity\\\" data-symbol=\\\"{{symbol}}\\\" data-qty={{qty}}>Trade</a></td>\\r\\n\\t\\t\\t\\t<td><a href=\\\"\\\" class=\\\"addToWallet\\\" data-symbol=\\\"{{symbol}}\\\">Add</a></td>\\r\\n\\t\\t\\t</tr>\\r\\n\\t\\t\\t{{/each}}\\r\\n\\t\\t\\t{{/if}}\\r\\n\\t\\t</tbody>\\r\\n\\t</table>\\r\\n\\t</figure>\\r\\n\\t<div id=\\\"documents\\\"></div>\\r\\n\\r\\n</article>\";\n// Exports\n/* harmony default export */ const pages_positions = (positions_code);\n;// CONCATENATED MODULE: ./src/html/modal/SyncStock.html\n// Module\nvar SyncStock_code = \"<article>\\r\\n    If your wallet is out of sync with your position you can sync it here. This happens when you move from\\r\\n    one chain to another. If you like to switch to new chain click the button below.\\r\\n    <br/><br/>\\r\\n    You will be asked to confirm a transaction of {{totalCost}} {{NativeSymbol}} (${{priceInNativeToken}}).\\r\\n    Each stock costs {{costPerShare}} {{NativeSymbol}} to sync. You have total of {{shareCount}} share.\\r\\n    <br/><br/>\\r\\n    <button id=\\\"syncAllPositions\\\">Sync stock to my wallet</button>\\r\\n</article>\";\n// Exports\n/* harmony default export */ const SyncStock = (SyncStock_code);\n;// CONCATENATED MODULE: ./src/services/backend/PositionsService.ts\nvar PositionsService_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass PositionsService {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    getPositions() {\r\n        return PositionsService_awaiter(this, void 0, void 0, function* () {\r\n            return yield this.moralis.Cloud.run('positions');\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/pages/PositionsPage.ts\nvar PositionsPage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PositionsPage {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n        this.documentService = new DocumentService(this.moralis);\r\n    }\r\n    load() {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            let mainContainer = document.getElementById('main_container');\r\n            if (!mainContainer)\r\n                return;\r\n            let positionService = new PositionsService(this.moralis);\r\n            let positions = yield positionService.getPositions();\r\n            HandlebarHelpers.registerHelpers();\r\n            let template = Handlebars.compile(pages_positions);\r\n            mainContainer.innerHTML = template({ result: positions });\r\n            let syncWalletBtn = document.getElementById('syncWallet');\r\n            if (syncWalletBtn) {\r\n                syncWalletBtn.addEventListener('click', (evt) => {\r\n                    evt.preventDefault();\r\n                    this.syncAllTokens();\r\n                });\r\n            }\r\n            let symbols = new Array();\r\n            const sellLinks = document.getElementsByClassName('tradeSecurity');\r\n            for (let i = 0; i < sellLinks.length; i++) {\r\n                let element = sellLinks[i];\r\n                let symbol = element.dataset.symbol;\r\n                if (!symbol)\r\n                    continue;\r\n                symbols.push(symbol);\r\n                sellLinks[i].addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    let element = evt.target;\r\n                    let symbol = element.dataset.symbol;\r\n                    if (!symbol)\r\n                        return;\r\n                    let liminalMarketService = new LiminalMarketService(this.moralis);\r\n                    let contractAddress = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                    let securitiesService = yield SecuritiesService.getInstance();\r\n                    let security = yield securitiesService.getSecurityBySymbol(symbol);\r\n                    let tradePage = new TradePage(this.moralis);\r\n                    yield tradePage.load(symbol, security.Name, security.LogoPath + security.Logo, contractAddress);\r\n                    window.scrollTo(0, 0);\r\n                }));\r\n            }\r\n            const addToWalletLinks = document.getElementsByClassName('addToWallet');\r\n            for (let i = 0; i < addToWalletLinks.length; i++) {\r\n                addToWalletLinks[i].addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    console.log(evt.target);\r\n                    let element = addToWalletLinks[i];\r\n                    let symbol = element.dataset.symbol;\r\n                    let liminalMarketService = new LiminalMarketService(this.moralis);\r\n                    let contractAddress = yield liminalMarketService.getSymbolContractAddress(symbol);\r\n                    if (contractAddress.toString() == Helper_AddressZero) {\r\n                        let createToken = new CreateToken(this.moralis);\r\n                        createToken.show(symbol);\r\n                        return;\r\n                    }\r\n                    let walletHelper = new WalletHelper(this.moralis);\r\n                    yield walletHelper.addTokenToWallet(contractAddress.toString(), symbol, () => {\r\n                        let modal = new Modal();\r\n                        let template = Handlebars.compile(AddressInfo);\r\n                        let content = template({ symbol: symbol, address: contractAddress });\r\n                        modal.showModal('Import token to wallet', content);\r\n                    });\r\n                }));\r\n            }\r\n            yield this.renderSymbolLogos(symbols);\r\n            let docTemplate = Handlebars.compile(elements_documents);\r\n            let documents = yield this.documentService.getDocuments();\r\n            let documentDom = document.getElementById('documents');\r\n            if (!documentDom)\r\n                return;\r\n            documentDom.innerHTML = docTemplate({ result: documents });\r\n            yield this.initDocuments();\r\n        });\r\n    }\r\n    renderSymbolLogos(symbols) {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            let securitiesService = yield SecuritiesService.getInstance();\r\n            const assets = yield securitiesService.getSecurities();\r\n            let asset;\r\n            for (let i = 0; i < symbols.length; i++) {\r\n                asset = assets.get(symbols[i]);\r\n                if (asset) {\r\n                    document.getElementById('symbol_logo_' + symbols[i]).setAttribute('src', '/img/logos/' + asset.Logo);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    syncAllTokens() {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            let costOfSync = yield this.moralis.Cloud.run('costOfSync');\r\n            let template = Handlebars.compile(SyncStock);\r\n            let content = template({\r\n                shareCount: costOfSync.shareCount,\r\n                costPerShare: Moralis.Units.FromWei(costOfSync.costPerShare, 18),\r\n                priceInNativeToken: costOfSync.priceInNativeToken,\r\n                totalCost: Moralis.Units.FromWei(costOfSync.cost, 18),\r\n                NativeSymbol: networkInfo.NativeSymbol\r\n            });\r\n            let modal = new Modal();\r\n            modal.showModal('Sync all stock to wallet', content);\r\n            let syncAllPositions = document.getElementById('syncAllPositions');\r\n            if (syncAllPositions) {\r\n                syncAllPositions.addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                }));\r\n            }\r\n        });\r\n    }\r\n    initDocuments() {\r\n        return PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n            const links = document.getElementsByClassName('downloadDoc');\r\n            const user = this.moralis.User.current();\r\n            if (!user)\r\n                return;\r\n            for (let i = 0; i < links.length; i++) {\r\n                links[i].addEventListener('click', (evt) => PositionsPage_awaiter(this, void 0, void 0, function* () {\r\n                    evt.preventDefault();\r\n                    let documentId = links[i].dataset.docid;\r\n                    if (!documentId)\r\n                        return;\r\n                    let locationUrl = yield this.documentService.getDocument(documentId);\r\n                    if (locationUrl == '') {\r\n                        alert('Could not find document. Please contact us if you should have gotten a document');\r\n                        return;\r\n                    }\r\n                    window.location = locationUrl;\r\n                }));\r\n            }\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/routing/Routing.ts\nvar Routing_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Routing {\r\n    constructor(moralis) {\r\n        this.settings = {\r\n            show_trade: this.showTrade,\r\n            show_positions: this.showPositions,\r\n            show_stocks: this.showStocks,\r\n            show_kyc_action_required: this.showKycActionRequired,\r\n            show_funding: this.showFunding,\r\n            show_kyc: this.showKyc\r\n        };\r\n        this.moralis = moralis;\r\n    }\r\n    loadRoutes() {\r\n        var _a;\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            let path = window.location.hash.replace('#', '').replace('/', '');\r\n            if (path === '')\r\n                path = 'stocks';\r\n            this.attachNavLinks();\r\n            let fn = (_a = this.settings['show_' + path]) !== null && _a !== void 0 ? _a : this.settings['show_stocks'];\r\n            if (typeof fn === 'function') {\r\n                yield fn(this);\r\n            }\r\n            else {\r\n                yield fn(this.settings['show_stocks']);\r\n            }\r\n        });\r\n    }\r\n    showKycActionRequired(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage(routing.moralis);\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/kyc_action_required');\r\n            let button = document.getElementById('liminal_market_execute_trade');\r\n            button === null || button === void 0 ? void 0 : button.dispatchEvent(new MouseEvent('click'));\r\n        });\r\n    }\r\n    showKyc(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage(routing.moralis);\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/kyc');\r\n            let button = document.getElementById('liminal_market_execute_trade');\r\n            button === null || button === void 0 ? void 0 : button.dispatchEvent(new MouseEvent('click'));\r\n        });\r\n    }\r\n    showFunding(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage(routing.moralis);\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/funding');\r\n            let aUSDFundingModal = new FakeAUSDFund(this.moralis);\r\n            let networkInfo = NetworkInfo.getInstance();\r\n            if (networkInfo.TestNetwork) {\r\n                aUSDFundingModal.showAUSDFakeFund(() => {\r\n                });\r\n            }\r\n            else {\r\n                aUSDFundingModal.showAUSDFund(() => {\r\n                });\r\n            }\r\n        });\r\n    }\r\n    showTrade(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new TradePage(routing.moralis);\r\n            yield page.load();\r\n            history.pushState(null, 'Buy stocks', '#/trade');\r\n        });\r\n    }\r\n    showStocks(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new StocksPage(routing.moralis);\r\n            yield page.load();\r\n            history.pushState(null, 'Stocks', '#/stocks');\r\n        });\r\n    }\r\n    showPositions(routing, evt) {\r\n        return Routing_awaiter(this, void 0, void 0, function* () {\r\n            if (evt)\r\n                evt.preventDefault();\r\n            let page = new PositionsPage(routing.moralis);\r\n            yield page.load();\r\n            history.pushState(null, 'Positions', '#/positions');\r\n        });\r\n    }\r\n    attachNavLinks() {\r\n        let router = this;\r\n        let tradeNavLinks = document.querySelectorAll('.tradeNavLink');\r\n        tradeNavLinks.forEach(link => {\r\n            link.addEventListener('click', (evt) => Routing_awaiter(this, void 0, void 0, function* () {\r\n                WalletHelper.hideMagicWallet();\r\n                yield router.showTrade(router, evt);\r\n                link.parentElement.parentElement.parentElement.removeAttribute('open');\r\n            }));\r\n        });\r\n        let investLinks = document.querySelectorAll('.investNavLink');\r\n        investLinks.forEach(link => {\r\n            link.addEventListener('click', (evt) => Routing_awaiter(this, void 0, void 0, function* () {\r\n                WalletHelper.hideMagicWallet();\r\n                yield router.showStocks(router, evt);\r\n                link.parentElement.parentElement.parentElement.removeAttribute('open');\r\n            }));\r\n        });\r\n        let positionLinks = document.querySelectorAll('.positionNavLink');\r\n        positionLinks.forEach(link => {\r\n            link.addEventListener('click', (evt) => Routing_awaiter(this, void 0, void 0, function* () {\r\n                WalletHelper.hideMagicWallet();\r\n                yield router.showPositions(router, evt);\r\n                link.parentElement.parentElement.parentElement.removeAttribute('open');\r\n            }));\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/Header.ts\nclass Header {\r\n    static loadImage() {\r\n        let header = document.querySelector('body > header');\r\n        if (!header)\r\n            return;\r\n        let random = Math.floor(Math.random() * 10);\r\n        header.style.backgroundImage = \"url(/img/header/\" + random + \".jpg)\";\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/ui/elements/AuthenticateUser.ts\nvar AuthenticateUser_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\nclass AuthenticateUser {\r\n    constructor(moralis) {\r\n        this.moralis = moralis;\r\n    }\r\n    authenticate() {\r\n        return AuthenticateUser_awaiter(this, void 0, void 0, function* () {\r\n            let userService = new UserService(this.moralis);\r\n            let user = userService.getUser();\r\n            if (!user) {\r\n                let connectWallet = new ConnectWallet(this.moralis);\r\n                connectWallet.renderButton('user_header_info');\r\n                return;\r\n            }\r\n            let user_header_info = document.getElementById('user_header_info');\r\n            if (user_header_info)\r\n                user_header_info.innerHTML = 'Loading wallet..';\r\n            LoadingHelper.setLoading(user_header_info);\r\n            user = yield userService.isLoggedIn();\r\n            if (user) {\r\n                let userInfo = new UserInfo(this.moralis, user.providerInfo, user);\r\n                yield userInfo.render('user_header_info');\r\n            }\r\n            else {\r\n                //show Connect Wallet button\r\n                let connectWallet = new ConnectWallet(this.moralis);\r\n                connectWallet.renderButton('user_header_info');\r\n            }\r\n            LoadingHelper.removeLoading();\r\n        });\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/main.ts\nvar main_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst start = function () {\r\n    return main_awaiter(this, void 0, void 0, function* () {\r\n        let slowServerTimer = setTimeout(slowServer, 10 * 1000);\r\n        let moralis = Moralis;\r\n        let connectionService = new ConnectionService(moralis);\r\n        connectionService.start().then(() => main_awaiter(this, void 0, void 0, function* () {\r\n            clearTimeout(slowServerTimer);\r\n            let routing = new Routing(moralis);\r\n            yield routing.loadRoutes();\r\n            let authorizeUser = new AuthenticateUser(moralis);\r\n            authorizeUser.authenticate();\r\n        })).catch((reason) => {\r\n            ErrorInfo.report(new GeneralError(\"Server is down. Please try again later.<br /><br />\" + reason));\r\n        });\r\n        let walletHelper = new WalletHelper(moralis);\r\n        if (walletHelper.isWebview(window.navigator.userAgent)) {\r\n            //console = ErrorInfo as any;\r\n        }\r\n        function slowServer() {\r\n            let loading = document.querySelector('.loading');\r\n            if (!loading) {\r\n                clearTimeout(slowServerTimer);\r\n                return;\r\n            }\r\n            loading.innerHTML = 'Hmmm.... our servers are slow. Give it few seconds.';\r\n        }\r\n        Header.loadImage();\r\n    });\r\n};\r\nstart().then();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsS0FBSztBQUN6Qyx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGNBQUU7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBRTtBQUNuQixJQUFJO0FBQ0osaUJBQWlCLGNBQUU7QUFDbkIsaUJBQWlCLGNBQUU7QUFDbkIsaUJBQWlCLGNBQUU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGNBQUU7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUJBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDOztBQUVEOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0EsYUFBYSxxQkFBUztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7O0FBRWIsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBRTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLGNBQUU7QUFDakIsZUFBZSxjQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsY0FBRTtBQUNqQixlQUFlLGNBQUU7QUFDakI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BLDJEQUEyRCxpQ0FBaUM7QUFDNUY7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5QkFBeUI7QUFDakMsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtDQUFrQyxtREFBbUQsR0FBRyxFQUFFO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixFQUFFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixFQUFFO0FBQ3JGO0FBQ0EseUJBQXlCLDBCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyx5QkFBeUIsa0JBQWtCO0FBQzNDLHlCQUF5QixrQkFBa0I7QUFDM0MseUJBQXlCLGtCQUFrQjtBQUMzQyx5QkFBeUIsa0JBQWtCO0FBQzNDLHlCQUF5QixrQkFBa0I7QUFDM0MsNEJBQTRCLGtCQUFrQjtBQUM5Qyx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0EseUJBQXlCLGtCQUFrQjtBQUMzQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdDQUF3QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQyw4Q0FBOEMsbURBQW1ELEdBQUcsRUFBRTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQyw2Q0FBNkMsbURBQW1ELEdBQUcsRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDhDQUE4QyxtREFBbUQsR0FBRyxFQUFFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0EscUNBQXFDLGtFQUFrRSxHQUFHLEVBQUU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCLHlEQUF5RCxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsMkNBQTJDLG1EQUFtRCxHQUFHLEVBQUU7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEMsNkNBQTZDLG1EQUFtRCxHQUFHLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHFEQUFxRCxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0Esa0NBQWtDLG1EQUFtRCxHQUFHLEdBQUc7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUztBQUNyQztBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRTtBQUMvQywwQ0FBMEMsR0FBRyxTQUFTLEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0Esa0NBQWtDLG1EQUFtRCxHQUFHLE1BQU07QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQyxVQUFVLHlCQUF5QjtBQUNuQztBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGtDQUFrQyxtREFBbUQsR0FBRyxHQUFHO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUUsRUFBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUNyRSxNQUFNLEVBQUUsYUFBYTtRQUNyQixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLG1CQUFtQixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQyxFQUFFO1FBQ2pGLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLE1BQU0sRUFBRSxLQUFLO0tBQ2hCLEVBQUUsRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUNwQyxNQUFNLEVBQUUsVUFBVTtRQUNsQixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLDZCQUE2QixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUN2RCxNQUFNLEVBQUUsZUFBZTtRQUN2QixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUUsRUFBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRTtRQUNwRSxNQUFNLEVBQUUsUUFBUTtRQUNoQixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFDLEVBQUU7UUFDekMsTUFBTSxFQUFFLGtCQUFrQjtRQUMxQixNQUFNLEVBQUUsS0FBSztLQUNoQixFQUFFLEVBQUMsTUFBTSxFQUFFLDZCQUE2QixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUMsRUFBRSxFQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBQyxFQUFFO1FBQ3pG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RSxFQUFFO1lBQ2hCLGdCQUFnQixDQUFDLElBQUksWUFBWSxDQUFDLHFEQUFxRCxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFDdkcsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3QyxJQUFJLFlBQVksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFDdEQ7WUFDSSw2QkFBNkI7U0FDaEM7UUFHRCxTQUFTLFVBQVU7WUFDZixJQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1lBQ2pELElBQUksQ0FBQyxPQUFPLEVBQUU7Z0JBQ1YsWUFBWSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUM5QixPQUFPO2FBQ1Y7WUFFRCxPQUFPLENBQUMsU0FBUyxHQUFHLHFEQUFxRDtRQUU3RSxDQUFDO1FBQ0QsZ0JBQWdCLEVBQUUsQ0FBQztJQUV2QixDQUFDO0NBQUE7QUFFRCxLQUFLLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2Vycm9ycy9HZW5lcmFsRXJyb3IudHM/MWQ2NyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL1N3aXRjaE5ldHdvcmsuaHRtbD9iNWMyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvTW9kYWwuaHRtbD8zMGRhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9Nb2RhbC50cz9iOWU2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2Jyb2tlci9TZWN1cml0eS50cz8wMTMxIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2Jyb2tlci9TZWN1cml0aWVzU2VydmljZS50cz8xOGMyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvTG9hZGluZ0hlbHBlci50cz82NTJhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvV2FsbGV0SGVscGVyLnRzP2EzMTYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvbmV0d29ya3MvTmV0d29ya1R5cGUudHM/MWNkMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9icm9rZXIvTWFya2V0U2VydmljZS50cz9iNjE4Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2VudW1zL1dhbGxldFR5cGUudHM/NTljYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy93YWxsZXQvUHJvdmlkZXJJbmZvLnRzPzQ4NGMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZS50cz9iYmFhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9Td2l0Y2hOZXR3b3JrTW9kYWwudHM/YzNkNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9sb2dnZXIvbGliLmVzbS9fdmVyc2lvbi5qcz8yMjk0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzP2ZmYjIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvcGVydGllcy9saWIuZXNtL192ZXJzaW9uLmpzPzE1MmIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvcGVydGllcy9saWIuZXNtL2luZGV4LmpzPzliZGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vX3ZlcnNpb24uanM/NGE0NSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliLmVzbS9fdmVyc2lvbi5qcz9jMmJlIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lci9saWIuZXNtL2luZGV4LmpzPzdjYTUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYnl0ZXMvbGliLmVzbS9fdmVyc2lvbi5qcz8wYjgyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanM/NTQ5ZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9fdmVyc2lvbi5qcz9hOTYwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2JpZ251bWJlci9saWIuZXNtL2JpZ251bWJlci5qcz9lMzZkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2tlY2NhazI1Ni9saWIuZXNtL2luZGV4LmpzPzZmNWEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vX3ZlcnNpb24uanM/MDBjZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9pbmRleC5qcz9lMTY1Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcz81MDAzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9pbmRleC5qcz8zYjFjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9fdmVyc2lvbi5qcz81ODczIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9fdmVyc2lvbi5qcz8yYTQ5Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS91dGY4LmpzPzUyNzMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2lkLmpzPzM1YTgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL3R5cGVkLWRhdGEuanM/ZTEwOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9iaWdudW1iZXJzLmpzPzlkNTYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXkvbGliLmVzbS9lbGxpcHRpYy5qcz9jMjRiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5L2xpYi5lc20vX3ZlcnNpb24uanM/NjIyNCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2luZGV4LmpzP2FlMWMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanM/NzEzYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnMvbGliLmVzbS9pbmRleC5qcz81YWMzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2U2NC9saWIuZXNtL2Jhc2U2NC5qcz8yMDdiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL192ZXJzaW9uLmpzP2UzMDMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vZ2V0dXJsLmpzPzIxZGUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2ViL2xpYi5lc20vaW5kZXguanM/YmFmNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzP2ViNmMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXIvbGliLmVzbS9pbmRleC5qcz9lZGFhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2V4L2xpYi5lc20vaW5kZXguanM/MmNmMiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9oYXNoZXMuanM/NDg3NyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vaWRuYS5qcz84NDI0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9uYW1laGFzaC5qcz8wYTdmIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L25ldHdvcmtzL2xpYi5lc20vX3ZlcnNpb24uanM/M2ZiNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL2luZGV4LmpzPzAxMDkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzP2Q0NTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL192ZXJzaW9uLmpzP2U2NGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3NoYTIuanM/Mzc5NiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9hZGRyZXNzZXMuanM/YzAwYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9mb3JtYXR0ZXIuanM/N2YwNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9iYXNlLXByb3ZpZGVyLmpzP2JjNzkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vanNvbi1ycGMtcHJvdmlkZXIuanM/M2U4MCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS93ZWIzLXByb3ZpZGVyLmpzP2RhNGQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvd2FsbGV0L2V2ZW50cy50cz8yNDZjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3dhbGxldC9BYnN0cmFjdFdlYjNDb25uZWN0b3IudHM/MjFhYyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9AbWFnaWMtc2RrL3R5cGVzL2Rpc3QvZXMvaW5kZXgubWpzPzE4OWQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvQG1hZ2ljLXNkay9wcm92aWRlci9kaXN0L2VzL2luZGV4Lm1qcz80MWY3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BtYWdpYy1zZGsvY29tbW9ucy9kaXN0L2VzL2luZGV4Lm1qcz8wMDkyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL21hZ2ljLXNkay9kaXN0L2VzL2luZGV4Lm1qcz8zMDEzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL0BtYWdpYy1leHQvY29ubmVjdC9kaXN0L2VzL2luZGV4Lm1qcz9lN2ZkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3dhbGxldC9NYWdpY1dlYjNDb25uZWN0b3IudHM/ZTAyOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2UudHM/ZTI1MCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9uZXR3b3Jrcy9OZXR3b3JrLnRzP2JjZGMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvbmV0d29ya3MvVGVzdE5ldHdvcmsudHM/NTg5ZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9uZXR3b3Jrcy9sb2NhbGhvc3QtbmV0d29yay50cz85M2NiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL25ldHdvcmtzL211bWJhaS1uZXR3b3JrLnRzPzUyN2QiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9Db29raWVIZWxwZXIudHM/ZDhkNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9uZXR3b3Jrcy9NYWluTmV0d29yay50cz8xZDc0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL25ldHdvcmtzL3BvbHlnb24tbmV0d29yay50cz9hMTFkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL25ldHdvcmtzL05ldHdvcmtJbmZvLnRzP2ExYzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmFja2VuZC9Db25uZWN0aW9uU2VydmljZS50cz80MzAzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2NvbnRyYWN0cy9sb2NhbGhvc3QtY29udHJhY3QtYWRkcmVzc2VzLnRzPzNjNTIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvY29udHJhY3RzL211bWJhaS1jb250cmFjdC1hZGRyZXNzZXMudHM/YjA3OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9jb250cmFjdHMvZnVqaS1jb250cmFjdC1hZGRyZXNzZXMudHM/ZTU2NiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9jb250cmFjdHMvcG9seWdvbi1jb250cmFjdC1hZGRyZXNzZXMudHM/MzA1ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9jb250cmFjdHMvQ29udHJhY3RJbmZvLnRzP2IyMGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvSW5mb0JhclR5cGUudHM/ODgwNyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy9JbmZvQmFyLnRzPzYxMzciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9XYWxsZXRNaXNzaW5nLmh0bWw/ZmYyNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvUHJlZGVmaW5lZEVycm9ySGFuZGxlcnMudHM/N2Q4ZiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvRXJyb3JJbmZvLnRzPzM3ZmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9NYXJrZXRJc0Nsb3NlZC5odG1sP2MwYjQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9EYXRlSGVscGVyLnRzPzM0NGYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvZXJyb3JzL0Jsb2NrY2hhaW5FcnJvci50cz9mZDVhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2Jsb2NrY2hhaW4vQmxvY2tjaGFpblNlcnZpY2UudHM/MmQ0MyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9ibG9ja2NoYWluL0xpbWluYWxNYXJrZXRTZXJ2aWNlLnRzPzdiODIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9TZWN1cml0aWVzTGlzdC5odG1sPzdmZDMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9TZWN1cml0aWVzLmh0bWw/OGU4NSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91dGlsL0NvcHlIZWxwZXIudHM/MmNiMyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL0FkZHJlc3NJbmZvLmh0bWw/ZmI3NSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL0NvbnRyYWN0QWRkcmVzc05vdEZvdW5kLmh0bWw/YjdlNCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLm1qcz9mOGNjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvSGVscGVyLnRzP2RhZTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9BZGRUb1dhbGxldC5odG1sPzU2ZDYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvU2VjdXJpdGllc0xpc3QudHM/ZjYxMiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL1VzZXJJbmZvLmh0bWw/MzUwOSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNFZGl0TmFtZS5odG1sPzQ5YTMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9TdHJpbmdIZWxwZXIudHM/NGIxNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0VkaXROYW1lRm9ybS50cz84YWI3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0t5Y0VkaXRDb250YWN0Rm9ybS5odG1sPzQxMzAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdXRpbC9Gb3JtSGVscGVyLnRzP2ExNzEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNFZGl0Q29udGFjdEZvcm0udHM/ZDc0MyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNFZGl0VHJ1c3RlZENvbnRhY3QuaHRtbD82YzZiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvQ291bnRyeUhlbHBlci50cz8xOGI2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljRWRpdFRydXN0ZWRDb250YWN0LnRzPzk0OTkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZS50cz9kMGM0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvZnVuZGluZy9GYWtlRnVuZGluZy5odG1sPzkzZTYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvc2VydmljZXMvYnJva2VyL0Z1bmRpbmdTZXJ2aWNlLnRzP2U2OWMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9TZWxlY3RGdW5kaW5nVHlwZS5odG1sP2IyYTAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvUmVsYXRpb25zaGlwL1NlbGVjdEZ1bmRpbmdUeXBlLnRzPzBlMzgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9BQ0hSZWxhdGlvbnNoaXAuaHRtbD82ZTFkIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2VudW1zL1RyYW5zZmVyRGlyZWN0aW9uRW51bS50cz81NTExIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL1JlbGF0aW9uc2hpcC9SZWxhdGlvbnNoaXBCYXNlLnRzPzM4NzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvUmVsYXRpb25zaGlwL0FDSFJlbGF0aW9uc2hpcC50cz82ZTRhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9UcmFuc2Zlck5vdGlmaWNhdGlvbi5odG1sPzFlZGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1RyYW5zZmVyc0xpc3QuaHRtbD8yNjgzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3V0aWwvSGFuZGxlYmFySGVscGVycy50cz9jOWMzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL1RyYW5zZmVyc0xpc3QudHM/MGRjYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvRmlyc3RUcmFuc2ZlclNldHVwQmFzZS50cz83NzEwIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvTW9uZXlUcmFuc2ZlcnJlZC5odG1sP2QwYjEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL01vbmV5VHJhbnNmZXJyZWQudHM/OTdmYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9UcmFuc2Zlck5vdGlmaWNhdGlvbi50cz9mNDgzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9SZWxhdGlvbnNoaXAvV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwLmh0bWw/YWMwZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9SZWxhdGlvbnNoaXAvV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwLnRzP2VmNTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9GdW5kaW5nL1RyYW5zZmVySW5mby5odG1sPzJkMjQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvVHJhbnNmZXJOb3RpZmllZC50cz85NzNjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvRmlyc3RUcmFuc2ZlclNldHVwLmh0bWw/OGRjOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0JhbmtJbmZvLmh0bWw/ZjlhNiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL1dpcmVUcmFuc2Zlck1vbmV5Lmh0bWw/MjdkZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvV2lyZVRyYW5zZmVyTW9uZXkudHM/NWNjMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0FDSFRyYW5zZmVyQWNjb3VudE51bWJlci5odG1sPzg3MTIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0FDSFRyYW5zZmVyQWNjb3VudE51bWJlci50cz81ZTA3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9CYW5rSW5mby50cz9jZDlhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL0ZpcnN0VHJhbnNmZXJTZXR1cC9GaXJzdFRyYW5zZmVyU2V0dXAudHM/Y2Y2YiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9BVVNERnVuZC50cz9mOTBjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9GdW5kaW5nL0Zha2VBVVNERnVuZC50cz9lMzlhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvRnVuZGluZy9XaXRoZHJhd01vZGFsLmh0bWw/NWU3OCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvRnVuZGluZy9XaXRoZHJhd01vZGFsLnRzP2NmZWQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvQVVzZEJhbGFuY2UudHM/NWIzYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL1Rlc3ROZXR3b3JrQmFubmVyLmh0bWw/NTkyYyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy9Vc2VySW5mby50cz8yZjA3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvQ29ubmVjdFdhbGxldEJ1dHRvbi5odG1sPzlmOTMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0Nvbm5lY3RXYWxsZXQudHM/MGZiYyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9ibG9ja2NoYWluL0tZQ1NlcnZpY2UudHM/YWM5OCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9ibG9ja2NoYWluL1NlY3VyaXR5VG9rZW5TZXJ2aWNlLnRzP2MyY2QiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvUHJvZ3Jlc3MudHM/NGMyYiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9iYWNrZW5kL1N1YnNjcmlwdGlvbi50cz8xZTY0Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2VudW1zL1RyYWRlVHlwZS50cz85MDIzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlVHJhZGVCdXR0b24uaHRtbD9mMTllIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvZWxlbWVudHMvdHJhZGVwYW5lbC9UcmFkZUV4ZWN1dGVkLmh0bWw/YjYyMCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0Zha2VOYXRpdmVUb2tlbk5lZWRlZC5odG1sP2FkMTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9OYXRpdmVUb2tlbk5lZWRlZC5odG1sP2ExYjEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL05hdGl2ZVRva2VuTmVlZGVkLnRzPzRmODciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljQWN0aW9uUmVxdWlyZWQuaHRtbD9kMmFiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1dlRG9udEtub3dXaHkuaHRtbD8wMTdiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0lERU5USVRZX1ZFUklGSUNBVElPTi5odG1sPzA1NmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvQUREUkVTU19WRVJJRklDQVRJT04uaHRtbD8xY2UzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0FGRklMSUFURUQuaHRtbD85MjM5Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0NPTlRST0xfUEVSU09OLmh0bWw/ZWExNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9DT1VOVFJZX05PVF9TVVBQT1JURUQuaHRtbD8zNjljIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0RBVEVfT0ZfQklSVEguaHRtbD8yNjg1Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0ZBTUlMWV9NRU1CRVJfUEVQLmh0bWw/N2E3YiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9JTlZBTElEX0lERU5USVRZX1BBU1NQT1JULmh0bWw/YTkwNCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9QRVAuaHRtbD82NDU3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1NFTEZJRV9WRVJJRklDQVRJT04uaHRtbD8yYmZjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1RBWF9JREVOVElGSUNBVElPTi5odG1sPzkwNzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvVklTQV9UWVBFX09USEVSLmh0bWw/NTE5NCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9XOEJFTl9DT1JSRUNUSU9OLmh0bWw/OGQ4MCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL0ZpbGVVcGxvYWQuaHRtbD8zNTg2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL2VsZW1lbnRzL0ZpbGVVcGxvYWQudHM/NjI4YyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91dGlsL0Zvcm1WYWxpZGF0b3IudHM/N2M4ZCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0FjdGlvblJlcXVpcmVkLnRzPzNiMGUiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LWUNNb2RhbC5odG1sPzUwYjkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljQ29udGFjdC5odG1sPzAzMzciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yLnRzPzM1NzkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNCYXNlLnRzPzZiN2QiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNDb250YWN0LnRzPzg2MTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljSWRlbnRpdHkuaHRtbD8zZDk5Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljSWRlbnRpdHkudHM/ZGU2OCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNEaXNjbG9zdXJlcy5odG1sPzMwYTgiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkLmh0bWw/NzIxMyIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZC50cz8zODcxIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvS3ljL0t5Y0ltbWVkaWF0ZUZhbWlseS5odG1sPzE1MmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNJbW1lZGlhdGVGYW1pbHkudHM/NjFhNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y0Rpc2Nsb3N1cmVzLnRzP2RmMDIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljQWNjb3VudEFncmVlbWVudC5odG1sPzQxM2IiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNBY2NvdW50QWdyZWVtZW50LnRzPzMyMDAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9LeWMvS3ljVHJ1c3RlZENvbnRhY3QuaHRtbD9hNTFjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljVHJ1c3RlZENvbnRhY3QudHM/MGY4YSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNVcGxvYWQuaHRtbD83MjE2Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL21vZGFscy9LWUMvS3ljVXBsb2FkLnRzP2JmZTciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQy9LeWNXYWl0aW5nLnRzP2VjZGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0tZQ0Zvcm0udHM/Yzk4NiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9tb2RhbHMvS1lDL0t5Y1N0YXR1c0hhbmRsZXIudHM/NGY1MiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL21vZGFsL0t5Yy9LeWNBcHByb3ZlZC5odG1sP2UyYjEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlVHJhZGVCdXR0b24udHM/NTA3YiIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVJbnB1dC5odG1sP2UwMzYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL1NlY3VyaXRpZXNMaXN0TW9kYWwudHM/YTc2OSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9iYWNrZW5kL1RyYWRlSW5mby50cz8wNTkzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2Vycm9ycy9jbG91ZC9IdHRwRXJyb3IudHM/MzNkNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9lcnJvcnMvQ2xvdWRFcnJvci50cz85YjYzIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvU3RvY2tQcmljZVNlcnZpY2UudHM/YWU5NCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvUHJpY2VQZXJTaGFyZS5odG1sPzYzYTAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvdHJhZGVwYW5lbC9UcmFkZVBhbmVsSW5wdXQudHM/NjhjYSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVTd2l0Y2guaHRtbD8wNjJjIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3VpL2VsZW1lbnRzL3RyYWRlcGFuZWwvVHJhZGVTd2l0Y2gudHM/YzQyMSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9lbGVtZW50cy9UcmFkZVBhbmVsLnRzP2ZhNDQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9wYWdlcy90cmFkZS5odG1sP2Y2ZjYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9Db3B5VG9rZW5BZGRyZXNzVG9BZGRUb1dhbGxldC5odG1sP2RkYzMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvcGFnZXMvVHJhZGVQYWdlLnRzPzBmOTQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9wYWdlcy9zdG9ja3NwYWdlLmh0bWw/YTJjNCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9wYWdlcy9TdG9ja3NQYWdlLnRzPzM4MzciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9lbGVtZW50cy9kb2N1bWVudHMuaHRtbD8zOWNiIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL3NlcnZpY2VzL2JhY2tlbmQvRG9jdW1lbnRTZXJ2aWNlLnRzPzgwYjciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9tb2RhbC9DcmVhdGVUb2tlbi5odG1sPzQ5NmEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvbW9kYWxzL0NyZWF0ZVRva2VuLnRzPzI0ZDYiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvaHRtbC9wYWdlcy9wb3NpdGlvbnMuaHRtbD82ZmE5Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL2h0bWwvbW9kYWwvU3luY1N0b2NrLmh0bWw/MGMxNSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy9zZXJ2aWNlcy9iYWNrZW5kL1Bvc2l0aW9uc1NlcnZpY2UudHM/OGEzOCIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL3NyYy91aS9wYWdlcy9Qb3NpdGlvbnNQYWdlLnRzP2JhZGEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvcm91dGluZy9Sb3V0aW5nLnRzP2Q2NjQiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvSGVhZGVyLnRzP2UyMzAiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9zcmMvdWkvZWxlbWVudHMvQXV0aGVudGljYXRlVXNlci50cz9mMGJhIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vc3JjL21haW4udHM/Y2Q0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBHZW5lcmFsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb2RlIDogbnVtYmVyO1xyXG4gICAgbWVzc2FnZSA6IHN0cmluZztcclxuICAgIGhlYWRlcnMgOiBhbnk7XHJcbiAgICBlcnJvciA6IGFueTtcclxuICAgIHN0YWNrIDogc3RyaW5nO1xyXG4gICAgY2FsbGJhY2s/IDogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihlIDogYW55KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvZGUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhY2sgPSBcIlwiO1xyXG4gICAgICAgIGlmICghZS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGUudG9TdHJpbmcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUubWVzc2FnZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IGUubWVzc2FnZS5kYXRhLmNvZGU7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZS5kYXRhLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBlLm1lc3NhZ2UuaGVhZGVycztcclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IGUuc3RhY2s7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoZS5kYXRhKSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBlLmRhdGEuY29kZTtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZS5kYXRhLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IGUubWVzc2FnZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBpZD1cXFwic3dpdGNoTmV0d29ya0luZm9cXFwiPlxcclxcbiAgICBZb3UgY2FuIGNob29zZSBhbnkgb2YgdGhlc2UgbmV0d29ya3MuXFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8aDM+TWFpbm5ldCAtIHJlYWwgbW9uZXkgJiBzdG9ja3M8L2gzPlxcclxcbiAgICAgICAge3sjZWFjaCBtYWluTmV0d29ya3N9fVxcclxcbiAgICAgICAgPGJ1dHRvbiBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJzZXROZXR3b3JrXFxcIlxcclxcbiAgICAgICAgICAgICAgICBkYXRhLWNoYWluaWQ9XFxcInt7Q2hhaW5JZH19XFxcIj57e0NoYWluTmFtZX19XFxyXFxuICAgICAgICA8L2J1dHRvbj5cXHJcXG4gICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxoMz5UZXN0bmV0IC0gZmFrZSBtb25leSAmIHN0b2NrczwvaDM+XFxyXFxuICAgICAgICB7eyNlYWNoIHRlc3ROZXR3b3Jrc319XFxyXFxuICAgICAgICA8YnV0dG9uIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcInNldE5ldHdvcmtcXFwiXFxyXFxuICAgICAgICAgICAgICAgIGRhdGEtY2hhaW5pZD1cXFwie3tDaGFpbklkfX1cXFwiPnt7Q2hhaW5OYW1lfX1cXHJcXG4gICAgICAgIDwvYnV0dG9uPlxcclxcbiAgICAgICAge3svZWFjaH19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjxkaXYgaWQ9XFxcImpzU3dpdGNoTmV0d29ya05vdFdvcmtpbmdcXFwiIGNsYXNzPVxcXCJkLW5vbmVcXFwiPlxcclxcbiAgICBJdCBzZWVtIGFzIHdlIGNhbid0IGFkZCB0aGUgbmV0d29yayBhdXRvbWF0aWNhbGx5IGZvciB5b3VyLCBzbyB5b3UgbmVlZCB0byBhZGQgaXQgeW91ciBzZWxmLlxcclxcbiAgICBUaGlzIGlzIHRoZSBpbmZvcm1hdGlvbiB5b3UgbmVlZCB0byBhZGQgdGhlIG5ldHdvcmsuIFlvdSB3aWxsIG5lZWQgdG8gZmlndXJlIG91dCB3aGVyZSB0b1xcclxcbiAgICBhZGQgbmV3IG5ldHdvcmsgZm9yIHlvdXIgd2FsbGV0LCBhcyBpdCBkaWZmZXJlbmNlIGJldHdlZW4gd2FsbGV0cy5cXHJcXG4gICAgPGZvcm0+XFxyXFxuICAgICAgICA8bGFiZWw+Q2hhaW5JZDpcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaENoYWluSWRcXFwiLz5cXHJcXG4gICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8bGFiZWw+Q2hhaW4gbmFtZVxcclxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwic3dpdGNoQ2hhaW5OYW1lXFxcIi8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGxhYmVsPkN1cnJlbmN5IG5hbWVcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaEN1cnJlbmN5TmFtZVxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBTeW1ib2xcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaFN5bWJvbFxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5EZWNpbWFsXFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJzd2l0Y2hEZWNpbWFsXFxcIi8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGxhYmVsPlJwYyBVcmxcXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInN3aXRjaFJwY1VybFxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgPC9mb3JtPlxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGlhbG9nIGlkPVxcXCJsaW1pbmFsX21hcmtldF9tb2RhbF9kaXZcXFwiIGRhdGEtdGl0bGU9XFxcInt7e3RpdGxlfX19XFxcIj5cXHJcXG4gICAgPGFydGljbGU+XFxyXFxuICAgICAgICA8aGVhZGVyPlxcclxcbiAgICAgICAgICAgIDxzcGFuPnt7dGl0bGV9fTwvc3Bhbj5cXHJcXG4gICAgICAgICAgICA8YSBocmVmPVxcXCIjY2xvc2VcXFwiIGFyaWEtbGFiZWw9XFxcIkNsb3NlXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGlkPVxcXCJsaW1pbmFsX21hcmtldF9tb2RhbF9jbG9zZVxcXCI+PC9hPlxcclxcbiAgICAgICAgPC9oZWFkZXI+XFxyXFxuICAgICAgICB7e3tjb250ZW50fX19XFxyXFxuICAgIDwvYXJ0aWNsZT5cXHJcXG5cXHJcXG48L2RpYWxvZz5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IE1vZGFsSHRtbCBmcm9tICcuLi8uLi9odG1sL21vZGFsL01vZGFsLmh0bWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWwge1xyXG4gICAgbW9kYWxJZCA9ICdsaW1pbmFsX21hcmtldF9tb2RhbF9kaXYnO1xyXG4gICAgb25IaWRlPyA6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgcHVibGljIGhpZGVNb2RhbCgpIHtcclxuICAgICAgICBsZXQgbW9kYWxEaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1vZGFsSWQpO1xyXG4gICAgICAgIG1vZGFsRGl2Py5yZW1vdmVBdHRyaWJ1dGUoJ29wZW4nKTtcclxuICAgICAgICBpZiAodGhpcy5vbkhpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3dNb2RhbCh0aXRsZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIHJldXNlTW9kYWxJZlNhbWVUaXRsZTogYm9vbGVhbiA9IGZhbHNlLCBvbkhpZGU/OiAoKSA9PiB2b2lkLCBoaWRlT25PdXRzaWRlQ2xpY2sgPSB0cnVlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IG1vZGFsRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tb2RhbElkKTtcclxuICAgICAgICBpZiAobW9kYWxEaXYpIHtcclxuICAgICAgICAgICAgbGV0IG1vZGFsVGl0bGUgPSBtb2RhbERpdi5kYXRhc2V0LnRpdGxlO1xyXG4gICAgICAgICAgICBpZiAocmV1c2VNb2RhbElmU2FtZVRpdGxlICYmIG1vZGFsVGl0bGUgJiYgbW9kYWxUaXRsZSA9PT0gdGl0bGUpIHtcclxuICAgICAgICAgICAgICAgIG1vZGFsRGl2LnNldEF0dHJpYnV0ZSgnb3BlbicsICcnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKE1vZGFsSHRtbCk7XHJcblxyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLCBjb250ZW50OiBjb250ZW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBodG1sID0gdGVtcGxhdGUob2JqKTtcclxuXHJcbiAgICAgICAgaWYgKG1vZGFsRGl2KSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobW9kYWxEaXYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgaHRtbCk7XHJcblxyXG4gICAgICAgIG1vZGFsRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5tb2RhbElkKSE7XHJcbiAgICAgICAgbW9kYWxEaXYuc2V0QXR0cmlidXRlKCdvcGVuJywgJycpO1xyXG5cclxuICAgICAgICBpZiAoaGlkZU9uT3V0c2lkZUNsaWNrKSB7XHJcbiAgICAgICAgICAgIG1vZGFsRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldnQudGFyZ2V0ICYmIChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5pZCA9PT0gJ2xpbWluYWxfbWFya2V0X21vZGFsX2RpdicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlJylcclxuICAgICAgICBpZiAobGltaW5hbF9tYXJrZXRfbW9kYWxfY2xvc2UpIGxpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfbW9kYWxfY2xvc2UnKT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5vbkhpZGUgPSBvbkhpZGU7XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxufSIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3VyaXR5IHtcclxuICAgIENsYXNzIDogc3RyaW5nID0gXCJcIjtcclxuICAgIEV4Y2hhbmdlIDogc3RyaW5nID0gXCJcIjtcclxuICAgIFN5bWJvbCA6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBOYW1lIDogc3RyaW5nID0gXCJcIjtcclxuICAgIFN0YXR1cyA6IHN0cmluZyA9IFwiXCI7XHJcbiAgICBUcmFkYWJsZSA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEZyYWN0aW9uYWJsZSA6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIExvZ28gOiBzdHJpbmcgPSBcIlwiO1xyXG4gICAgRmF2b3JpdGUgOiBudW1iZXIgPSAwO1xyXG4gICAgTG9nb1BhdGggOiBzdHJpbmcgPSBcIi9pbWcvbG9nb3MvXCIgO1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5Mb2dvUGF0aCA9IFwiL2ltZy9sb2dvcy9cIiA7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBTZWN1cml0eSBmcm9tIFwiLi9TZWN1cml0eVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VjdXJpdGllc1NlcnZpY2Uge1xyXG5cclxuICAgIHNlY3VyaXRpZXMgPSBuZXcgTWFwPHN0cmluZywgU2VjdXJpdHk+KCk7XHJcbiAgICBzZWN1cml0aWVzQXJyYXkgOiBhbnk7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZSA6IFNlY3VyaXRpZXNTZXJ2aWNlO1xyXG4gICAgcGFnZTogbnVtYmVyO1xyXG4gICAgc3ltYm9scyA9IFtcIk1TRlRcIiwgXCJBQVBMXCIsIFwiQU1aTlwiLCBcIlRTTEFcIiwgXCJHT09HTFwiLCBcIkdPT0dcIiwgXCJHTUVcIiwgXCJNRVRBXCIsIFwiTlZEQVwiLCBcIkJSSy5CXCIsIFwiSlBNXCIsIFwiSERcIiwgXCJKTkpcIiwgXCJVTkhcIiwgXCJQR1wiLCBcIkJBQ1wiLCBcIlZcIiwgXCJBREJFXCIsIFwiTkZMWFwiLCBcIkNSTVwiLCBcIlBGRVwiLCBcIkRJU1wiLCBcIk1BXCIsIFwiWE9NXCIsIFwiVE1PXCIsIFwiQ09TVFwiXVxyXG5cclxuICAgIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zZWN1cml0aWVzID0gbmV3IE1hcDxzdHJpbmcsIFNlY3VyaXR5PigpO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBnZXRJbnN0YW5jZSgpOiBQcm9taXNlPFNlY3VyaXRpZXNTZXJ2aWNlPiB7XHJcbiAgICAgICAgaWYgKCFTZWN1cml0aWVzU2VydmljZS5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBTZWN1cml0aWVzU2VydmljZS5pbnN0YW5jZSA9IG5ldyBTZWN1cml0aWVzU2VydmljZSgpO1xyXG4gICAgICAgICAgICBTZWN1cml0aWVzU2VydmljZS5pbnN0YW5jZS5zZWN1cml0aWVzID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuaW5zdGFuY2UuZ2V0U2VjdXJpdGllcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU2VjdXJpdGllc1NlcnZpY2UuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFNlY3VyaXRpZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdGllcy5zaXplICE9IDApIHJldHVybiB0aGlzLnNlY3VyaXRpZXM7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9zZWN1cml0aWVzL3NlY3VyaXRpZXMuanNvbicpO1xyXG5cclxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNlY3VyaXRpZXMuc2V0KHJlc3VsdHNbaV0uU3ltYm9sLCBPYmplY3QuYXNzaWduKG5ldyBTZWN1cml0eSwgcmVzdWx0c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlY3VyaXRpZXNBcnJheSA9IEFycmF5LmZyb20odGhpcy5zZWN1cml0aWVzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VjdXJpdGllcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0U2VjdXJpdHlCeVN5bWJvbChzeW1ib2wgOiBzdHJpbmcpIDogUHJvbWlzZTxTZWN1cml0eT4ge1xyXG4gICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgdGhpcy5nZXRTZWN1cml0aWVzKCk7XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0eSA9IHNlY3VyaXRpZXMuZ2V0KHN5bWJvbCk7XHJcbiAgICAgICAgcmV0dXJuIChzZWN1cml0eSkgPyBzZWN1cml0eSA6IG5ldyBTZWN1cml0eSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRUb3BTZWN1cml0aWVzKCkge1xyXG4gICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgdGhpcy5nZXRTZWN1cml0aWVzKCk7XHJcbiAgICAgICAgbGV0IHRvcFNlY3VyaXRpZXMgPSBuZXcgQXJyYXk8U2VjdXJpdHk+KCk7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3Qgc3ltYm9sIG9mIHRoaXMuc3ltYm9scykge1xyXG4gICAgICAgICAgICBsZXQgc2VjdXJpdHkgPSBzZWN1cml0aWVzLmdldChzeW1ib2wpO1xyXG4gICAgICAgICAgICBpZiAoc2VjdXJpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRvcFNlY3VyaXRpZXMucHVzaChzZWN1cml0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvcFNlY3VyaXRpZXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFBhZ2luYXRpbmdTZWN1cml0aWVzKHBhZ2UgOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAocGFnZSA9PSAwKSByZXR1cm4gdGhpcy5nZXRUb3BTZWN1cml0aWVzKCk7XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0aWVzT25QYWdlID0gbmV3IEFycmF5PFNlY3VyaXR5PigpO1xyXG4gICAgICAgIGxldCBpID0gcGFnZSAqIHRoaXMuc3ltYm9scy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHBhZ2VDb3VudCA9IGkgKyAxMDtcclxuICAgICAgICBmb3IgKDtpPHBhZ2VDb3VudCAmJiBpPHRoaXMuc2VjdXJpdGllc0FycmF5Lmxlbmd0aDtpKyspIHtcclxuICAgICAgICAgICAgc2VjdXJpdGllc09uUGFnZS5wdXNoKHRoaXMuc2VjdXJpdGllc0FycmF5W2ldWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlY3VyaXRpZXNPblBhZ2U7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBmaW5kKHNlYXJjaDogc3RyaW5nKSA6IFByb21pc2U8QXJyYXk8U2VjdXJpdHk+PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdHMgPSBuZXcgQXJyYXk8U2VjdXJpdHk+KCk7XHJcbiAgICAgICAgc2VhcmNoID0gc2VhcmNoLnRvTG9jYWxlTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VjdXJpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIChzZWN1cml0eSkge1xyXG4gICAgICAgICAgICBpZiAoc2VjdXJpdHkuU3ltYm9sLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpICE9IC0xIHx8XHJcbiAgICAgICAgICAgICAgICBzZWN1cml0eS5OYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihzZWFyY2gpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goc2VjdXJpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBMb2FkaW5nSGVscGVyIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGxhc3RFbGVtZW50PyA6IEhUTUxFbGVtZW50ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2V0TG9hZGluZyhlbGVtZW50PzogSFRNTEVsZW1lbnQgfCBudWxsKSB7XHJcbiAgICAgICAgaWYgKExvYWRpbmdIZWxwZXIubGFzdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5sYXN0RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm47XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5sYXN0RWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZW1vdmVMb2FkaW5nKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWJ1c3knKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IFNlY3VyaXRpZXNTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9icm9rZXIvU2VjdXJpdGllc1NlcnZpY2VcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4vTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuLi9lcnJvcnMvR2VuZXJhbEVycm9yXCI7XHJcbmltcG9ydCBOZXR3b3JrIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi9zZXJ2aWNlcy9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgUHJvdmlkZXJJbmZvIGZyb20gXCIuLi93YWxsZXQvUHJvdmlkZXJJbmZvXCI7XHJcbmltcG9ydCB7V2FsbGV0VHlwZX0gZnJvbSBcIi4uL2VudW1zL1dhbGxldFR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGxldEhlbHBlciB7XHJcbiAgICBzdGF0aWMgYWRkVG9rZW5GYWxsYmFja0xvYWRlZD86IGJvb2xlYW4gPSB1bmRlZmluZWQ7XHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEFVc2RBc3NldCgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBMb2dvOiAnLi4vYXVzZC5wbmcnXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgYWRkVG9rZW5Ub1dhbGxldChhZGRyZXNzOiBzdHJpbmcsIHN5bWJvbDogc3RyaW5nLCBmYWxsYmFja1RpbWVvdXQ6ICgpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgc2VjdXJpdGllc1NlcnZpY2UgPSBhd2FpdCBTZWN1cml0aWVzU2VydmljZS5nZXRJbnN0YW5jZSgpO1xyXG5cclxuICAgICAgICBjb25zdCBhc3NldCA9IChzeW1ib2wgPT0gJ2FVU0QnKSA/IHRoaXMuZ2V0QVVzZEFzc2V0KCkgOiBhd2FpdCBzZWN1cml0aWVzU2VydmljZS5nZXRTZWN1cml0eUJ5U3ltYm9sKHN5bWJvbCk7XHJcbiAgICAgICAgbGV0IHdlYjMgPSB0aGlzLm1vcmFsaXMud2ViMyBhcyBhbnk7XHJcbiAgICAgICAgaWYgKCF3ZWIzKSB7XHJcbiAgICAgICAgICAgIHdlYjMgPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjModGhpcy5tb3JhbGlzKVxyXG4gICAgICAgICAgICBpZiAoIXdlYjMpIHtcclxuICAgICAgICAgICAgICAgIGZhbGxiYWNrVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghd2ViMy5wcm92aWRlci5yZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIGZhbGxiYWNrVGltZW91dCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0aW1lb3V0ID0gKFdhbGxldEhlbHBlci5hZGRUb2tlbkZhbGxiYWNrTG9hZGVkID09PSB1bmRlZmluZWQpID8gMiAqIDEwMDAgOiAyMDA7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChXYWxsZXRIZWxwZXIuYWRkVG9rZW5GYWxsYmFja0xvYWRlZCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIFdhbGxldEhlbHBlci5hZGRUb2tlbkZhbGxiYWNrTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1RpbWVvdXQpIGZhbGxiYWNrVGltZW91dCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sIHRpbWVvdXQpO1xyXG5cclxuICAgICAgICBjb25zdCB3YXNBZGRlZCA9IGF3YWl0IHdlYjMucHJvdmlkZXIucmVxdWVzdCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF93YXRjaEFzc2V0JyxcclxuICAgICAgICAgICAgcGFyYW1zOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnRVJDMjAnLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBzeW1ib2wsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IDE4LFxyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiAnaHR0cHM6Ly9hcHAubGltaW5hbC5tYXJrZXQvaW1nL2xvZ29zLycgKyBhc3NldC5Mb2dvLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KS50aGVuKChyZXN1bHQ6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBXYWxsZXRIZWxwZXIuYWRkVG9rZW5GYWxsYmFja0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KS5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB3YXNBZGRlZDtcclxuICAgIH07XHJcblxyXG4gICAgcHVibGljIGlzV2Vidmlldyh1YTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgLy8gaWYgaXQgc2F5cyBpdCdzIGEgd2VidmlldywgbGV0J3MgZ28gd2l0aCB0aGF0XHJcbiAgICAgICAgbGV0IHJ1bGVzID0gWydXZWJWaWV3JyxcclxuICAgICAgICAgICAgLy8gaU9TIHdlYnZpZXcgd2lsbCBiZSB0aGUgc2FtZSBhcyBzYWZhcmkgYnV0IG1pc3NpbmcgXCJTYWZhcmlcIlxyXG4gICAgICAgICAgICAnKGlQaG9uZXxpUG9kfGlQYWQpKD8hLipTYWZhcmkpJyxcclxuICAgICAgICAgICAgLy8gQW5kcm9pZCBMb2xsaXBvcCBhbmQgQWJvdmU6IHdlYnZpZXcgd2lsbCBiZSB0aGUgc2FtZSBhcyBuYXRpdmUgYnV0IGl0IHdpbGwgY29udGFpbiBcInd2XCJcclxuICAgICAgICAgICAgLy8gQW5kcm9pZCBLaXRLYXQgdG8gbG9sbGlwb3Agd2VidmlldyB3aWxsIHB1dCB7dmVyc2lvbn0uMC4wLjBcclxuICAgICAgICAgICAgJ0FuZHJvaWQuKih3dnwuMC4wLjApJyxcclxuICAgICAgICAgICAgLy8gb2xkIGNocm9tZSBhbmRyb2lkIHdlYnZpZXcgYWdlbnRcclxuICAgICAgICAgICAgJ0xpbnV4OyBVOyBBbmRyb2lkJyxcclxuICAgICAgICAgICAgJ1NESydcclxuICAgICAgICBdXHJcbiAgICAgICAgbGV0IHdlYnZpZXdSZWdFeHAgPSBuZXcgUmVnRXhwKCcoJyArIHJ1bGVzLmpvaW4oJ3wnKSArICcpJywgJ2lnJyk7XHJcbiAgICAgICAgcmV0dXJuICEhdWEubWF0Y2god2Vidmlld1JlZ0V4cClcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgaXNNYWdpYygpIHtcclxuICAgICAgICBjb25zdCB3YWxsZXRJbmZvID0gYXdhaXQgdGhpcy5tb3JhbGlzLmNvbm5lY3Rvci5tYWdpYy5jb25uZWN0LmdldFdhbGxldEluZm8oKTtcclxuICAgICAgICBjb25zdCB3YWxsZXRUeXBlID0gd2FsbGV0SW5mby53YWxsZXRUeXBlO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCd3YWxsZXRUeXBlJywgd2FsbGV0VHlwZSlcclxuICAgICAgICByZXR1cm4gKHdhbGxldFR5cGUgPT09IFwibWFnaWNcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHN3aXRjaE5ldHdvcmsobmV0d29yazogTmV0d29yayk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIE5ldHdvcmtJbmZvLnNldE5ldHdvcmtCeUNoYWluSWQobmV0d29yay5DaGFpbklkKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgaGlkZU1hZ2ljV2FsbGV0KCkge1xyXG4gICAgICAgIGxldCBtYWdpY0lmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWdpYy1pZnJhbWUnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAobWFnaWNJZnJhbWUgJiYgbWFnaWNJZnJhbWUuc3R5bGUuZGlzcGxheSA9PSAnYmxvY2snKSBtYWdpY0lmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZW51bSBOZXR3b3JrVHlwZSB7XHJcbiAgICBNYWlubmV0ID0gMCxcclxuICAgIFRlc3RuZXQgPSAxXHJcbn0iLCJcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFya2V0U2VydmljZSB7XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGlzTWFya2V0T3BlbigpIDogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oJ2lzT3BlbicpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiZXhwb3J0IGVudW0gV2FsbGV0VHlwZSB7XHJcbiAgICBNZXRhbWFzayA9ICdtZXRhbWFzaycsXHJcbiAgICBXYWxsZXRDb25uZWN0ID0gJ3dhbGxldENvbm5lY3QnLFxyXG4gICAgQ29pbmJhc2VXYWxsZXQgPSAnY29pbmJhc2UnLFxyXG4gICAgV2ViM0F1dGggPSAnd2ViM0F1dGgnLFxyXG4gICAgTWFnaWNMaW5rID0gJ01hZ2ljTGluaycsXHJcbiAgICBVbmtub3duID0gJ3Vua25vd24nXHJcbn0iLCJpbXBvcnQge1dhbGxldFR5cGV9IGZyb20gXCIuLi9lbnVtcy9XYWxsZXRUeXBlXCI7XHJcbmltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3ZpZGVySW5mbyB7XHJcblxyXG4gICAgd2ViM1Byb3ZpZGVyOiBhbnk7XHJcblxyXG4gICAgUHJvdmlkZXJOYW1lOiBzdHJpbmcgPSAndW5rbm93bic7XHJcbiAgICBXYWxsZXROYW1lOiBzdHJpbmcgPSAnJztcclxuICAgIFdhbGxldFVybDogc3RyaW5nID0gJyc7XHJcbiAgICBXYWxsZXRUeXBlOiBXYWxsZXRUeXBlID0gV2FsbGV0VHlwZS5Vbmtub3duO1xyXG4gICAgVXNlckFkZHJlc3M6IHN0cmluZyA9ICcnO1xyXG4gICAgSW50ZXJuYWxXYWxsZXQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBzdGF0aWMgSW5zdGFuY2U6IFByb3ZpZGVySW5mbztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih3ZWIzUHJvdmlkZXI6IGFueSkge1xyXG4gICAgICAgIGlmICghd2ViM1Byb3ZpZGVyIHx8ICF3ZWIzUHJvdmlkZXIucHJvdmlkZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgdGhpcy53ZWIzUHJvdmlkZXIgPSB3ZWIzUHJvdmlkZXI7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLndlYjNQcm92aWRlci5jb25uZWN0aW9uICYmIHRoaXMud2ViM1Byb3ZpZGVyLmNvbm5lY3Rpb24udXJsID09ICdtZXRhbWFzaycpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkTWV0YW1hc2sod2ViM1Byb3ZpZGVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2ViM1Byb3ZpZGVyLnByb3ZpZGVyLndjKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFdhbGxldENvbm5lY3Qod2ViM1Byb3ZpZGVyKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMud2ViM1Byb3ZpZGVyLnByb3ZpZGVyLmlzTWFnaWMpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkTWFnaWNDb25uZWN0KHdlYjNQcm92aWRlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQ3VzdG9tKHdlYjNQcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFByb3ZpZGVySW5mby5JbnN0YW5jZSA9IHRoaXM7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGxvYWRNZXRhbWFzayh3YWxsZXRDb25uZWN0aW9uSW5mbyA6IGFueSkge1xyXG4gICAgICAgIHRoaXMuUHJvdmlkZXJOYW1lID0gJ21ldGFtYXNrJztcclxuICAgICAgICB0aGlzLldhbGxldE5hbWUgPSBcIk1ldGFtYXNrXCI7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRVcmwgPSAnaHR0cHM6Ly9tZXRhbWFzay5pby8nO1xyXG4gICAgICAgIHRoaXMuV2FsbGV0VHlwZSA9IFdhbGxldFR5cGUuTWV0YW1hc2s7XHJcbiAgICAgICAgdGhpcy5Vc2VyQWRkcmVzcyA9IHdhbGxldENvbm5lY3Rpb25JbmZvLnByb3ZpZGVyLnNlbGVjdGVkQWRkcmVzcztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxvYWRXYWxsZXRDb25uZWN0KHdhbGxldENvbm5lY3Rpb25JbmZvOiBhbnkpIHtcclxuICAgICAgICBsZXQgd2MgPSB3YWxsZXRDb25uZWN0aW9uSW5mby5wcm92aWRlci53YztcclxuXHJcbiAgICAgICAgdGhpcy5Qcm92aWRlck5hbWUgPSBcIndhbGxldENvbm5lY3RcIjtcclxuICAgICAgICB0aGlzLldhbGxldE5hbWUgPSB3Yy5fcGVlck1ldGEubmFtZTtcclxuICAgICAgICB0aGlzLldhbGxldFVybCA9IHdjLl9wZWVyTWV0YS51cmwgPz8gJyc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRUeXBlID0gV2FsbGV0VHlwZS5XYWxsZXRDb25uZWN0O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZEN1c3RvbShwcm92aWRlcjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5Qcm92aWRlck5hbWUgPSAnd2ViM2F1dGgnO1xyXG4gICAgICAgIHRoaXMuV2FsbGV0TmFtZSA9ICdUb3J1cyc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRVcmwgPSAnaHR0cHM6Ly9hcHAudG9yLnVzLyc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXRUeXBlID0gV2FsbGV0VHlwZS5XZWIzQXV0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxvYWRNYWdpY0Nvbm5lY3Qod2FsbGV0Q29ubmVjdGlvbkluZm86IGFueSkge1xyXG4gICAgICAgIHRoaXMuUHJvdmlkZXJOYW1lID0gJ01hZ2ljTGluayc7XHJcbiAgICAgICAgdGhpcy5XYWxsZXROYW1lID0gJ01hZ2ljTGluaydcclxuICAgICAgICB0aGlzLldhbGxldFR5cGUgPSBXYWxsZXRUeXBlLk1hZ2ljTGluaztcclxuICAgICAgICB0aGlzLkludGVybmFsV2FsbGV0ID0gdHJ1ZTtcclxuICAgIH1cclxufSIsImltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuaW1wb3J0IE1hcmtldFNlcnZpY2UgZnJvbSBcIi4uL2Jyb2tlci9NYXJrZXRTZXJ2aWNlXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuaW1wb3J0IFByb3ZpZGVySW5mbyBmcm9tIFwiLi4vLi4vd2FsbGV0L1Byb3ZpZGVySW5mb1wiO1xyXG5pbXBvcnQgS3ljUmVzdWx0IGZyb20gXCIuLi8uLi9kdG8vS3ljUmVzdWx0XCI7XHJcbmltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQge1RyYW5zZmVyfSBmcm9tIFwiLi4vLi4vZHRvL2FscGFjYS9UcmFuc2ZlclwiO1xyXG5pbXBvcnQge1RyYW5zZmVyRGlyZWN0aW9uRW51bX0gZnJvbSBcIi4uLy4uL2VudW1zL1RyYW5zZmVyRGlyZWN0aW9uRW51bVwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVzZXJTZXJ2aWNlIHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9nT3V0KCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubW9yYWxpcy5jb25uZWN0b3IubWFnaWMuY29ubmVjdC5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2xvZ291dCBtYWdpY1VzZXInLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5Vc2VyLmxvZ091dCgpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdsb2dvdXQgbW9yYWxpc1VzZXInLCBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGlzTG9nZ2VkSW4oKSB7XHJcbiAgICAgICAgbGV0IHVzZXIgPSBhd2FpdCB0aGlzLm1vcmFsaXMuVXNlci5jdXJyZW50QXN5bmMoKTtcclxuICAgICAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLm1vcmFsaXMuaXNXZWIzRW5hYmxlZCgpKSB7XHJcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjModGhpcy5tb3JhbGlzKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignZW5hYmxlV2ViMyBlcnJvcjonLCByZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nT3V0KCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhdXRoZW50aWNhdGlvblNlcnZpY2UgPSBuZXcgQXV0aGVudGljYXRlU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGF3YWl0IGF1dGhlbnRpY2F0aW9uU2VydmljZS5hdXRoZW50aWNhdGVVc2VyKCh3ZWIzUHJvdmlkZXIpID0+IHtcclxuICAgICAgICAgICAgKHVzZXIgYXMgYW55KS5wcm92aWRlckluZm8gPSBuZXcgUHJvdmlkZXJJbmZvKHdlYjNQcm92aWRlcilcclxuICAgICAgICB9LCAobG9nZ2VkSW5Vc2VyKSA9PiB7XHJcbiAgICAgICAgICAgIHVzZXIgPSBsb2dnZWRJblVzZXI7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB1c2VyO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIGlzTWFya2V0T3Blbk9yVXNlck9mZkhvdXJzKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGxldCBtYXJrZXRTZXJ2aWNlID0gbmV3IE1hcmtldFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICBsZXQgaXNPcGVuID0gYXdhaXQgbWFya2V0U2VydmljZS5pc01hcmtldE9wZW4oKTtcclxuICAgICAgICBpZiAoaXNPcGVuKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvL1RPRE86IFJlbW92ZSBvbiBtYWlubmV0IGxhdW5jaFxyXG4gICAgICAgIGlmICghbmV0d29ya0luZm8uVGVzdE5ldHdvcmspIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRVc2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vcmFsaXMuVXNlci5jdXJyZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldEFscGFjYUlkKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgbGV0IHVzZXIgPSB0aGlzLmdldFVzZXIoKTtcclxuICAgICAgICBpZiAoIXVzZXIpIHJldHVybiAnJztcclxuXHJcbiAgICAgICAgcmV0dXJuIChhd2FpdCB1c2VyLmZldGNoKCkpLmdldCgnYWxwYWNhSWQnKS50b1N0cmluZygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBY2NvdW50KCkge1xyXG4gICAgICAgIGxldCB1c2VyID0gdGhpcy5nZXRVc2VyKCk7XHJcbiAgICAgICAgaWYgKCF1c2VyKSByZXR1cm47XHJcblxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCdhY2NvdW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RXRoQWRkcmVzcygpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFVzZXIoKT8uZ2V0KCdldGhBZGRyZXNzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGt5Y0FjdGlvblJlcXVpcmVkKCk6IFByb21pc2U8S3ljUmVzdWx0PiB7XHJcbiAgICAgICAgbGV0IGt5Y1Jlc3VsdHMgPSBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCdreWNBY3Rpb25SZXF1aXJlZCcpIGFzIEt5Y1Jlc3VsdDtcclxuICAgICAgICByZXR1cm4ga3ljUmVzdWx0cztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlTmFtZShnaXZlbl9uYW1lOiBzdHJpbmcsIG1pZGRsZV9uYW1lOiBzdHJpbmcsIGZhbWlseV9uYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLkNsb3VkLnJ1bigndXBkYXRlTmFtZScsIHtcclxuICAgICAgICAgICAgZ2l2ZW5fbmFtZTogZ2l2ZW5fbmFtZSxcclxuICAgICAgICAgICAgbWlkZGxlX25hbWU6IG1pZGRsZV9uYW1lLFxyXG4gICAgICAgICAgICBmYW1pbHlfbmFtZTogZmFtaWx5X25hbWVcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB1cGRhdGVDb250YWN0KGRhdGE6IGFueSkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCd1cGRhdGVDb250YWN0JywgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHVwZGF0ZVRydXN0ZWRDb250YWN0KGRhdGE6IGFueSkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCd1cGRhdGVUcnVzdGVkQ29udGFjdCcsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVBY2hSZWxhdGlvbnNoaXAoYWNjb3VudF9vd25lcl9uYW1lOiBzdHJpbmcsIGJhbmtfYWNjb3VudF90eXBlOiBzdHJpbmcsIGJhbmtfYWNjb3VudF9udW1iZXI6IHN0cmluZywgYmFua19yb3V0aW5nX251bWJlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oJ2NyZWF0ZUFjaFJlbGF0aW9uc2hpcCcsIHtcclxuICAgICAgICAgICAgYWNjb3VudF9vd25lcl9uYW1lLCBiYW5rX2FjY291bnRfdHlwZSwgYmFua19hY2NvdW50X251bWJlciwgYmFua19yb3V0aW5nX251bWJlclxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRCYW5rUmVsYXRpb25zaGlwKCk6IFByb21pc2U8QmFua1JlbGF0aW9uc2hpcD4ge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCdnZXRCYW5rUmVsYXRpb25zaGlwJykgYXMgQmFua1JlbGF0aW9uc2hpcFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRMYXRlc3RUcmFuc2ZlcnMoZGlyZWN0aW9uOiBUcmFuc2ZlckRpcmVjdGlvbkVudW0pIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLkNsb3VkLnJ1bignZ2V0VHJhbnNmZXJzJywge2RpcmVjdGlvbjogZGlyZWN0aW9ufSkgYXMgVHJhbnNmZXJbXTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY3JlYXRlVHJhbnNmZXIoYW1vdW50OiBzdHJpbmcsIGRpcmVjdGlvbjogc3RyaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oJ2NyZWF0ZVRyYW5zZmVyJyxcclxuICAgICAgICAgICAge2Ftb3VudDogYW1vdW50LCBkaXJlY3Rpb246IGRpcmVjdGlvbn0pXHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgZGVsZXRlVHJhbnNmZXIoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCdkZWxldGVUcmFuc2ZlcicsIHtpZDogaWR9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgcmVnaXN0ZXJXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAocGFyYW1zOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLkNsb3VkLnJ1bignY3JlYXRlV2lyZVJlbGF0aW9uc2hpcCcsIHBhcmFtcyk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgU3dpdGNoTmV0d29ya0h0bWwgZnJvbSAnLi4vLi4vaHRtbC9tb2RhbC9Td2l0Y2hOZXR3b3JrLmh0bWwnO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi9Nb2RhbFwiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi8uLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5pbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuLi8uLi9lcnJvcnMvR2VuZXJhbEVycm9yXCI7XHJcbmltcG9ydCBOZXR3b3JrIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrXCI7XHJcbmltcG9ydCB7TmV0d29ya1R5cGV9IGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrVHlwZVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2l0Y2hOZXR3b3JrTW9kYWwge1xyXG4gICAgbW9yYWxpczogdHlwZW9mIE1vcmFsaXM7XHJcbiAgICBzZWxlY3RlZE5ldHdvcms/OiBOZXR3b3JrO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU3dpdGNoTmV0d29ya0h0bWwpO1xyXG4gICAgICAgIGxldCB0ZXN0TmV0d29ya3MgPSBOZXR3b3JrSW5mby5nZXROZXR3b3JrcyhOZXR3b3JrVHlwZS5UZXN0bmV0KTtcclxuICAgICAgICBsZXQgbWFpbk5ldHdvcmtzID0gTmV0d29ya0luZm8uZ2V0TmV0d29ya3MoTmV0d29ya1R5cGUuTWFpbm5ldCk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZSh7dGVzdE5ldHdvcmtzLCBtYWluTmV0d29ya3N9KTtcclxuXHJcbiAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdTd2l0Y2ggbmV0d29yaycsIGNvbnRlbnQsIGZhbHNlKTtcclxuXHJcbiAgICAgICAgbGV0IHNldE5ldHdvcmtMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZXROZXR3b3JrJyk7XHJcbiAgICAgICAgc2V0TmV0d29ya0xpbmtzLmZvckVhY2goc2V0TmV0d29ya0xpbmsgPT4ge1xyXG4gICAgICAgICAgICBzZXROZXR3b3JrTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkYXRhc2V0ID0gKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmRhdGFzZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTmV0d29yayA9IE5ldHdvcmtJbmZvLmdldE5ldHdvcmtJbmZvQnlDaGFpbklkKHBhcnNlSW50KGRhdGFzZXQuY2hhaW5pZCEpKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3RlZE5ldHdvcmspIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGNoYWluSWQ6JyArIGRhdGFzZXQuY2hhaW5pZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdWNjZXNzQWRkaW5nTmV0d29yayA9IGF3YWl0IHdhbGxldEhlbHBlci5zd2l0Y2hOZXR3b3JrKHRoaXMuc2VsZWN0ZWROZXR3b3JrKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3I6IEdlbmVyYWxFcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQganNTd2l0Y2hOZXR3b3JrTm90V29ya2luZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdqc1N3aXRjaE5ldHdvcmtOb3RXb3JraW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghanNTd2l0Y2hOZXR3b3JrTm90V29ya2luZykgdGhyb3cgZXJyb3I7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqc1N3aXRjaE5ldHdvcmtOb3RXb3JraW5nLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3dpdGNoTmV0d29ya0luZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoTmV0d29ya0luZm8nKSE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaE5ldHdvcmtJbmZvLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hDaGFpbklkJykgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSBkYXRhc2V0LmNoYWluaWQhICsgJyBvciBpdCBtaWdodCBiZTogJyArICcweCcgKyBwYXJzZUludChkYXRhc2V0LmNoYWluaWQhKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoQ2hhaW5OYW1lJykhIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gdGhpcy5zZWxlY3RlZE5ldHdvcmshLk5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoQ3VycmVuY3lOYW1lJykhIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gdGhpcy5zZWxlY3RlZE5ldHdvcmshLk5hdGl2ZUN1cnJlbmN5TmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hTeW1ib2wnKSEgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSB0aGlzLnNlbGVjdGVkTmV0d29yayEuTmF0aXZlU3ltYm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N3aXRjaERlY2ltYWwnKSAhIGFzIEhUTUxJbnB1dEVsZW1lbnQpLnZhbHVlID0gdGhpcy5zZWxlY3RlZE5ldHdvcmshLk5hdGl2ZURlY2ltYWwudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hScGNVcmwnKSEgYXMgSFRNTElucHV0RWxlbWVudCkudmFsdWUgPSB0aGlzLnNlbGVjdGVkTmV0d29yayEuUnBjVXJsO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc0FkZGluZ05ldHdvcmspIHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RhbC5oaWRlTW9kYWwoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdXNlclNlcnZpY2UubG9nT3V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbn0iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwibG9nZ2VyLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5sZXQgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5mdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuICAgICAgICBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3Npbmcuam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcbmV4cG9ydCB2YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlbmVyaWMgRXJyb3JzXG4gICAgLy8gVW5rbm93biBFcnJvclxuICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICAvLyBOb3QgSW1wbGVtZW50ZWRcbiAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuICAgIC8vICAgLSBvcGVyYXRpb25cbiAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuICAgIC8vICAgLSBldmVudCAoXCJub05ldHdvcmtcIiBpcyBub3QgcmUtdGhyb3duIGluIHByb3ZpZGVyLnJlYWR5OyBvdGhlcndpc2UgdGhyb3duKVxuICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgIEVycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXSA9IFwiU0VSVkVSX0VSUk9SXCI7XG4gICAgLy8gVGltZW91dFxuICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuICAgIC8vIEJ1ZmZlciBPdmVycnVuXG4gICAgRXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gICAgLy8gTnVtZXJpYyBGYXVsdFxuICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcbiAgICAvLyAgIC0gZmF1bHQ6IHRoZSByZWFzb24gdGhpcyBmYXVsdGVkXG4gICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBcmd1bWVudCBFcnJvcnNcbiAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3RcbiAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG4gICAgLy8gICAtIHZhbHVlOiBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuICAgIC8vIFRvbyBtYW55IGFyZ3VtZW50c1xuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG4gICAgLy8gQ2FsbCBleGNlcHRpb25cbiAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG4gICAgLy8gIC0gYXJncz86IFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JBcmdzPzogVGhlIEVJUDg0OCBlcnJvciBwYXJhbWV0ZXJzXG4gICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG4gICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG4gICAgLy8gSW5zdWZmaWNpZW50IGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWQgYnkgb25lIHdpdGggYSBoaWdoZXIgZ2FzIHByaWNlXG4gICAgLy8gICAtIHJlYXNvbjogXCJjYW5jZWxsZWRcIiwgXCJyZXBsYWNlZFwiIG9yIFwicmVwcmljZWRcIlxuICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcbiAgICAvLyAgIC0gaGFzaDogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgIC8vICAgLSByZXBsYWNlbWVudDogdGhlIGZ1bGwgVHJhbnNhY3Rpb25zUmVzcG9uc2UgZm9yIHRoZSByZXBsYWNlbWVudFxuICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICBFcnJvckNvZGVbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbjtcbmNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZXhwb3J0IGNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xvZyhsb2dMZXZlbCwgYXJncykge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChMb2dMZXZlbHNbbGV2ZWxdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xvZ0xldmVsID4gTG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLkRFQlVHLCBhcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLklORk8sIGFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBiZWluZyBjZW5zb3JlZFxuICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldICYgMHgwZl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1VaW50OEFycmF5KDB4XCIgKyBoZXggKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgIGxldCB1cmwgPSBcIlwiO1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5VTUVSSUNfRkFVTFQ6IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBcIk5VTUVSSUNfRkFVTFRcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBmYXVsdCA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3ZlcmZsb3dcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuZGVyZmxvd1wiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGl2aXNpb24tYnktemVyb1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLVwiICsgZmF1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5lZ2F0aXZlLXBvd2VyXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJuZWdhdGl2ZS13aWR0aFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiLXVuc3VwcG9ydGVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi11bmJvdW5kLXJlc3VsdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuQ0FMTF9FWENFUFRJT046XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5JTlNVRkZJQ0lFTlRfRlVORFM6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5NSVNTSU5HX05FVzpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLk5PTkNFX0VYUElSRUQ6XG4gICAgICAgICAgICBjYXNlIEVycm9yQ29kZS5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRDpcbiAgICAgICAgICAgIGNhc2UgRXJyb3JDb2RlLlRSQU5TQUNUSU9OX1JFUExBQ0VEOlxuICAgICAgICAgICAgY2FzZSBFcnJvckNvZGUuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQ6XG4gICAgICAgICAgICAgICAgdXJsID0gY29kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IFwiIFsgU2VlOiBodHRwczovXFwvbGlua3MuZXRoZXJzLm9yZy92NS1lcnJvcnMtXCIgKyB1cmwgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2VEZXRhaWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBtZXNzYWdlRGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAVE9ETzogQW55Pz9cbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuICAgIHRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IHRoaXMubWFrZUVycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIHRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgY29kZSwgcGFyYW1zKTtcbiAgICB9XG4gICAgYXNzZXJ0QXJndW1lbnQoY29uZGl0aW9uLCBtZXNzYWdlLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAoISFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNoZWNrTm9ybWFsaXplKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfbm9ybWFsaXplRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgZm9ybTogX25vcm1hbGl6ZUVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1NhZmVVaW50NTModmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwidmFsdWUgbm90IHNhZmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDB4MWZmZmZmZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY2hlY2tTYWZlSW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIGZhdWx0OiBcIm91dC1vZi1zYWZlLXJhbmdlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgJSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJub24taW50ZWdlclwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBcmd1bWVudENvdW50KGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCI6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA8IGV4cGVjdGVkQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgYXJndW1lbnRcIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPiBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHNcIiArIG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZENvdW50OiBleHBlY3RlZENvdW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja05ldyh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja0Fic3RyYWN0KHRhcmdldCwga2luZCkge1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBraW5kKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIgKyBKU09OLnN0cmluZ2lmeShraW5kLm5hbWUpICsgXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2xvYmFsTG9nZ2VyKCkge1xuICAgICAgICBpZiAoIV9nbG9iYWxMb2dnZXIpIHtcbiAgICAgICAgICAgIF9nbG9iYWxMb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0Q2Vuc29yc2hpcChjZW5zb3JzaGlwLCBwZXJtYW5lbnQpIHtcbiAgICAgICAgaWYgKCFjZW5zb3JzaGlwICYmIHBlcm1hbmVudCkge1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfcGVybWFuZW50Q2Vuc29yRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoIWNlbnNvcnNoaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdsb2JhbExvZ2dlcigpLnRocm93RXJyb3IoXCJlcnJvciBjZW5zb3JzaGlwIHBlcm1hbmVudFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG4gICAgICAgIF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMgPSAhIXBlcm1hbmVudDtcbiAgICB9XG4gICAgc3RhdGljIHNldExvZ0xldmVsKGxvZ0xldmVsKSB7XG4gICAgICAgIGNvbnN0IGxldmVsID0gTG9nTGV2ZWxzW2xvZ0xldmVsLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdsb2JhbExvZ2dlcigpLndhcm4oXCJpbnZhbGlkIGxvZyBsZXZlbCAtIFwiICsgbG9nTGV2ZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9sb2dMZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuICAgIH1cbn1cbkxvZ2dlci5lcnJvcnMgPSBFcnJvckNvZGU7XG5Mb2dnZXIubGV2ZWxzID0gTG9nTGV2ZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicHJvcGVydGllcy81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVSZWFkT25seShvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn1cbi8vIENyYXdsIHVwIHRoZSBjb25zdHJ1Y3RvciBjaGFpbiB0byBmaW5kIGEgc3RhdGljIG1ldGhvZFxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0YXRpYyhjdG9yLCBrZXkpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgaWYgKGN0b3Jba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0b3Jba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN0b3IucHJvdG90eXBlIHx8IHR5cGVvZiAoY3Rvci5wcm90b3R5cGUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGN0b3IucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVByb3BlcnRpZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBPYmplY3Qua2V5cyhvYmplY3QpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbigodikgPT4gKHsga2V5OiBrZXksIHZhbHVlOiB2IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIHJldHVybiByZXN1bHRzLnJlZHVjZSgoYWNjdW0sIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgYWNjdW1bKHJlc3VsdC5rZXkpXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUHJvcGVydGllcyhvYmplY3QsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2YgKG9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0XCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICghcHJvcGVydGllc1trZXldKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3Qga2V5IC0gXCIgKyBrZXksIFwidHJhbnNhY3Rpb246XCIgKyBrZXksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG9wYXF1ZSA9IHsgYmlnaW50OiB0cnVlLCBib29sZWFuOiB0cnVlLCBcImZ1bmN0aW9uXCI6IHRydWUsIG51bWJlcjogdHJ1ZSwgc3RyaW5nOiB0cnVlIH07XG5mdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG4gICAgLy8gT3BhcXVlIG9iamVjdHMgYXJlIG5vdCBtdXRhYmxlLCBzbyBzYWZlIHRvIGNvcHkgYnkgYXNzaWdubWVudFxuICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCB8fCBvYmplY3QgPT09IG51bGwgfHwgb3BhcXVlW3R5cGVvZiAob2JqZWN0KV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkgfHwgdHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXlzW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGFjY2Vzc2luZyBhIHZhbHVlIHRyaWdnZXJzIGFuIGVycm9yLCBpdCBpcyBhIGdldHRlclxuICAgICAgICAgICAgICAgIC8vIGRlc2lnbmVkIHRvIGRvIHNvIChlLmcuIFJlc3VsdCkgYW5kIGlzIHRoZXJlZm9yZSBcImZyb3plblwiXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV9pc0Zyb3plbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbi8vIFJldHVybnMgYSBuZXcgY29weSBvZiBvYmplY3QsIHN1Y2ggdGhhdCBubyBwcm9wZXJ0aWVzIG1heSBiZSByZXBsYWNlZC5cbi8vIE5ldyBwcm9wZXJ0aWVzIG1heSBiZSBhZGRlZCBvbmx5IHRvIG9iamVjdHMuXG5mdW5jdGlvbiBfZGVlcENvcHkob2JqZWN0KSB7XG4gICAgaWYgKF9pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIC8vIEFycmF5cyBhcmUgbXV0YWJsZSwgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QubWFwKChpdGVtKSA9PiBkZWVwQ29weShpdGVtKSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChvYmplY3QpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkocmVzdWx0LCBrZXksIGRlZXBDb3B5KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYENhbm5vdCBkZWVwQ29weSAke3R5cGVvZiAob2JqZWN0KX1gLCBcIm9iamVjdFwiLCBvYmplY3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDb3B5KG9iamVjdCkge1xuICAgIHJldHVybiBfZGVlcENvcHkob2JqZWN0KTtcbn1cbmV4cG9ydCBjbGFzcyBEZXNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaW5mbykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbmZvKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBkZWVwQ29weShpbmZvW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInByb3ZpZGVycy81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFic3RyYWN0LXNpZ25lci81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IFtcbiAgICBcImFjY2Vzc0xpc3RcIiwgXCJjY2lwUmVhZEVuYWJsZWRcIiwgXCJjaGFpbklkXCIsIFwiY3VzdG9tRGF0YVwiLCBcImRhdGFcIiwgXCJmcm9tXCIsIFwiZ2FzTGltaXRcIiwgXCJnYXNQcmljZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ0b1wiLCBcInR5cGVcIiwgXCJ2YWx1ZVwiXG5dO1xuY29uc3QgZm9yd2FyZEVycm9ycyA9IFtcbiAgICBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcbiAgICBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG4gICAgTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcbl07XG47XG47XG5leHBvcnQgY2xhc3MgU2lnbmVyIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHN1cGVyXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFNpZ25lcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmVyXCIsIHRydWUpO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgTUFZIG92ZXJyaWRlIHRoZXNlXG4gICAgZ2V0QmFsYW5jZShibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEJhbGFuY2VcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRCYWxhbmNlKHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGVzdGltYXRlcyB0aGUgZ2FzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImVzdGltYXRlR2FzXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBcImZyb21cIiBpZiB1bnNwZWNpZmllZCwgYW5kIGNhbGxzIHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gICAgY2FsbCh0cmFuc2FjdGlvbiwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJjYWxsXCIpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgsIGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBhbGwgZmllbGRzIGluIGEgdHJhbnNhY3Rpb24sIHNpZ25zIGl0IGFuZCBzZW5kcyBpdCB0byB0aGUgbmV0d29ya1xuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFR4ID0geWllbGQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFR4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0Q2hhaW5JZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrLmNoYWluSWQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRHYXNQcmljZVwiKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLmdldEdhc1ByaWNlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRGZWVEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEZlZURhdGFcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRGZWVEYXRhKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXNvbHZlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwicmVzb2x2ZU5hbWVcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENoZWNrcyBhIHRyYW5zYWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gaW52YWxpZCBrZXlzIGFuZCBpZlxuICAgIC8vIG5vIFwiZnJvbVwiIGlzIHByb3ZpZGVkLCBwb3B1bGF0ZXMgaXQuXG4gICAgLy8gLSBkb2VzIE5PVCByZXF1aXJlIGEgcHJvdmlkZXJcbiAgICAvLyAtIGFkZHMgXCJmcm9tXCIgaXMgbm90IHByZXNlbnRcbiAgICAvLyAtIHJldHVybnMgYSBDT1BZIChzYWZlIHRvIG11dGF0ZSB0aGUgcmVzdWx0KVxuICAgIC8vIEJ5IGRlZmF1bHQgY2FsbGVkIGZyb206IChvdmVycmlkaW5nIHRoZXNlIHByZXZlbnRzIGl0KVxuICAgIC8vICAgLSBjYWxsXG4gICAgLy8gICAtIGVzdGltYXRlR2FzXG4gICAgLy8gICAtIHBvcHVsYXRlVHJhbnNhY3Rpb24gKGFuZCB0aGVyZWZvciBzZW5kVHJhbnNhY3Rpb24pXG4gICAgY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKGFsbG93ZWRUcmFuc2FjdGlvbktleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGtleTogXCIgKyBrZXksIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4ID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAodHguZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHByb3ZpZGVkIGFkZHJlc3MgbWF0Y2hlcyB0aGlzIHNpZ25lclxuICAgICAgICAgICAgdHguZnJvbSA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUodHguZnJvbSksXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgIF0pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0udG9Mb3dlckNhc2UoKSAhPT0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgLy8gUG9wdWxhdGVzIEFMTCBrZXlzIGZvciBhIHRyYW5zYWN0aW9uIGFuZCBjaGVja3MgdGhhdCBcImZyb21cIiBtYXRjaGVzXG4gICAgLy8gdGhpcyBTaWduZXIuIFNob3VsZCBiZSB1c2VkIGJ5IHNlbmRUcmFuc2FjdGlvbiBidXQgTk9UIGJ5IHNpZ25UcmFuc2FjdGlvbi5cbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gc2VuZFRyYW5zYWN0aW9uXG4gICAgLy9cbiAgICAvLyBOb3RlczpcbiAgICAvLyAgLSBXZSBhbGxvdyBnYXNQcmljZSBmb3IgRUlQLTE1NTkgYXMgbG9uZyBhcyBpdCBtYXRjaGVzIG1heEZlZVBlckdhc1xuICAgIHBvcHVsYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICBpZiAodHgudG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LnRvID0gUHJvbWlzZS5yZXNvbHZlKHR4LnRvKS50aGVuKCh0bykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUodG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZWQgRU5TIG5hbWUgcmVzb2x2ZXMgdG8gbnVsbFwiLCBcInR4LnRvXCIsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB0aGlzIGVycm9yIGZyb20gY2F1c2luZyBhbiBVbmhhbmRsZWRQcm9taXNlRXhjZXB0aW9uXG4gICAgICAgICAgICAgICAgdHgudG8uY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IG1peGluZyBwcmUtZWlwLTE1NTkgYW5kIGVpcC0xNTU5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IGhhc0VpcDE1NTkgPSAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgfHwgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCAmJiAodHgudHlwZSA9PT0gMiB8fCBoYXNFaXAxNTU5KSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJlaXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBnYXNQcmljZVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCh0eC50eXBlID09PSAwIHx8IHR4LnR5cGUgPT09IDEpICYmIGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJlLWVpcC0xNTU5IHRyYW5zYWN0aW9uIGRvIG5vdCBzdXBwb3J0IG1heEZlZVBlckdhcy9tYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodHgudHlwZSA9PT0gMiB8fCB0eC50eXBlID09IG51bGwpICYmICh0eC5tYXhGZWVQZXJHYXMgIT0gbnVsbCAmJiB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgIC8vIEZ1bGx5LWZvcm1lZCBFSVAtMTU1OSB0cmFuc2FjdGlvbiAoc2tpcCBnZXRGZWVEYXRhKVxuICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgTGVnYWN5IG9yIEVJUC0yOTMwIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNQcmljZVxuICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gdGhpcy5nZXRHYXNQcmljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZ2V0IGZlZSBkYXRhIHRvIGRldGVybWluZSB0aGluZ3NcbiAgICAgICAgICAgICAgICBjb25zdCBmZWVEYXRhID0geWllbGQgdGhpcy5nZXRGZWVEYXRhKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF1dG8tZGV0ZWN0IHRoZSBpbnRlbmRlZCB0eXBlIG9mIHRoaXMgdHJhbnNhY3Rpb24uLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbmV0d29yayBzdXBwb3J0cyBFSVAtMTU1OSFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZ3JhZGUgdHJhbnNhY3Rpb24gZnJvbSBudWxsIHRvIGVpcC0xNTU5XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgbGVnYWN5IGdhc1ByaWNlIHByb3BlcnR5IG9uIGFuIGVpcC0xNTU5IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdXNlIGdhc1ByaWNlIGFzIGJvdGggZmVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXNQcmljZSA9IHR4Lmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9IGdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBmZWUgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmZWVEYXRhLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBzdXBwb3J0IEVJUC0xNTU5Li4uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5idXQgdGhleSBhcmUgdHJ5aW5nIHRvIHVzZSBFSVAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRWlwMTU1OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVJUC0xNTU5XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5nYXNQcmljZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSBmZWVEYXRhLmdhc1ByaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSBzZXQgdW50eXBlZCB0cmFuc2FjdGlvbiB0byBsZWdhY3lcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnR5cGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0RmVlRGF0YSBoYXMgZmFpbGVkIHVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gZ2V0IGNvbnNpc3RlbnQgZmVlIGRhdGFcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2lnbmVyLmdldEZlZURhdGFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHgudHlwZSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHBsaWNpdGx5IHVzaW5nIEVJUC0xNTU5XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC5tYXhGZWVQZXJHYXMgPSBmZWVEYXRhLm1heEZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBmZWVEYXRhLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Lm5vbmNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5ub25jZSA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChcInBlbmRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gdGhpcy5lc3RpbWF0ZUdhcyh0eCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkRXJyb3JzLmluZGV4T2YoZXJyb3IuY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eDogdHhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHguY2hhaW5JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IHRoaXMuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguY2hhaW5JZCA9IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmNoYWluSWQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldENoYWluSWQoKVxuICAgICAgICAgICAgICAgIF0pLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbMV0gIT09IDAgJiYgcmVzdWx0c1swXSAhPT0gcmVzdWx0c1sxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNoYWluSWQgYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gU3ViLWNsYXNzZXMgU0hPVUxEIGxlYXZlIHRoZXNlIGFsb25lXG4gICAgX2NoZWNrUHJvdmlkZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiAob3BlcmF0aW9uIHx8IFwiX2NoZWNrUHJvdmlkZXJcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25lcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVm9pZFNpZ25lciBleHRlbmRzIFNpZ25lciB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdmlkZXIpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIFZvaWRTaWduZXIpO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIgfHwgbnVsbCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKTtcbiAgICB9XG4gICAgX2ZhaWwobWVzc2FnZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogb3BlcmF0aW9uIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gbWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0cmFuc2FjdGlvbnNcIiwgXCJzaWduVHJhbnNhY3Rpb25cIik7XG4gICAgfVxuICAgIF9zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVm9pZFNpZ25lciBjYW5ub3Qgc2lnbiB0eXBlZCBkYXRhXCIsIFwic2lnblR5cGVkRGF0YVwiKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJ5dGVzLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZS50b0hleFN0cmluZyk7XG59XG5mdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuICAgIGlmIChhcnJheS5zbGljZSkge1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIGFycmF5LnNsaWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheSwgYXJncykpKTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzTGlrZSh2YWx1ZSkge1xuICAgIHJldHVybiAoKGlzSGV4U3RyaW5nKHZhbHVlKSAmJiAhKHZhbHVlLmxlbmd0aCAlIDIpKSB8fCBpc0J5dGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmIHZhbHVlID09IHZhbHVlICYmICh2YWx1ZSAlIDEpID09PSAwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNJbnRlZ2VyKHZhbHVlLmxlbmd0aCkgfHwgdmFsdWUubGVuZ3RoIDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoIWlzSW50ZWdlcih2KSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5aWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICh2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoU3RyaW5nKHZhbHVlIC8gMjU2KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsZXQgaGV4ID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBcIjB4MFwiICsgaGV4LnN1YnN0cmluZygyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBoZXggKz0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXJyYXlpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KGl0ZW1zKSB7XG4gICAgY29uc3Qgb2JqZWN0cyA9IGl0ZW1zLm1hcChpdGVtID0+IGFycmF5aWZ5KGl0ZW0pKTtcbiAgICBjb25zdCBsZW5ndGggPSBvYmplY3RzLnJlZHVjZSgoYWNjdW0sIGl0ZW0pID0+IChhY2N1bSArIGl0ZW0ubGVuZ3RoKSwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBvYmplY3RzLnJlZHVjZSgob2Zmc2V0LCBvYmplY3QpID0+IHtcbiAgICAgICAgcmVzdWx0LnNldChvYmplY3QsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQgKyBvYmplY3QubGVuZ3RoO1xuICAgIH0sIDApO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IG5vbi16ZXJvIGVudHJ5XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICB3aGlsZSAoc3RhcnQgPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzdGFydF0gPT09IDApIHtcbiAgICAgICAgc3RhcnQrKztcbiAgICB9XG4gICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIHplcm9zLCBzdHJpcCB0aGVtXG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZShzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICByZXN1bHQuc2V0KHZhbHVlLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEhleENoYXJhY3RlcnMgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbmV4cG9ydCBmdW5jdGlvbiBoZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja1NhZmVVaW50NTModmFsdWUsIFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIpO1xuICAgICAgICBsZXQgaGV4ID0gXCJcIjtcbiAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgICAgICBoZXggPSBIZXhDaGFyYWN0ZXJzW3ZhbHVlICYgMHhmXSArIGhleDtcbiAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCIweFwiICsgaGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4MDBcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgcmV0dXJuIChcIjB4MFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiMFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdiA9IHZhbHVlW2ldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhsaWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xufVxuLypcbmZ1bmN0aW9uIHVub2RkaWZ5KHZhbHVlOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyKTogQnl0ZXNMaWtlIHwgSGV4YWJsZSB8IG51bWJlciB7XG4gICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoICUgMiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhEYXRhTGVuZ3RoKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGRhdGEubGVuZ3RoIC0gMikgLyAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleERhdGFTbGljZShkYXRhLCBvZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4RGF0YVwiLCBcInZhbHVlXCIsIGRhdGEpO1xuICAgIH1cbiAgICBvZmZzZXQgPSAyICsgMiAqIG9mZnNldDtcbiAgICBpZiAoZW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGRhdGEuc3Vic3RyaW5nKG9mZnNldCwgMiArIDIgKiBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhDb25jYXQoaXRlbXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCIweFwiO1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgcmVzdWx0ICs9IGhleGxpZnkoaXRlbSkuc3Vic3RyaW5nKDIpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB0cmltbWVkID0gaGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLCB7IGhleFBhZDogXCJsZWZ0XCIgfSkpO1xuICAgIGlmICh0cmltbWVkID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmltbWVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFN0cmlwWmVyb3ModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgd2hpbGUgKG9mZnNldCA8IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZVtvZmZzZXRdID09PSBcIjBcIikge1xuICAgICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFplcm9QYWQodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleCBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICogbGVuZ3RoICsgMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidmFsdWUgb3V0IG9mIHJhbmdlXCIsIFwidmFsdWVcIiwgYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IDIgKiBsZW5ndGggKyAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgcjogXCIweFwiLFxuICAgICAgICBzOiBcIjB4XCIsXG4gICAgICAgIF92czogXCIweFwiLFxuICAgICAgICByZWNvdmVyeVBhcmFtOiAwLFxuICAgICAgICB2OiAwLFxuICAgICAgICB5UGFyaXR5QW5kUzogXCIweFwiLFxuICAgICAgICBjb21wYWN0OiBcIjB4XCJcbiAgICB9O1xuICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KHNpZ25hdHVyZSk7XG4gICAgICAgIC8vIEdldCB0aGUgciwgcyBhbmQgdlxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSA2NCkge1xuICAgICAgICAgICAgLy8gRUlQLTIwOTg7IHB1bGwgdGhlIHYgZnJvbSB0aGUgdG9wIGJpdCBvZiBzIGFuZCBjbGVhciBpdFxuICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIChieXRlc1szMl0gPj4gNyk7XG4gICAgICAgICAgICBieXRlc1szMl0gJj0gMHg3ZjtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWxsb3cgYSByZWNpZCB0byBiZSB1c2VkIGFzIHRoZSB2XG4gICAgICAgIGlmIChyZXN1bHQudiA8IDI3KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiArPSAyNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCB2IGJ5dGVcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wdXRlIHJlY292ZXJ5UGFyYW0gZnJvbSB2XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAvLyBDb21wdXRlIF92cyBmcm9tIHJlY292ZXJ5UGFyYW0gYW5kIHNcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICBieXRlc1szMl0gfD0gMHg4MDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdC5yID0gc2lnbmF0dXJlLnI7XG4gICAgICAgIHJlc3VsdC5zID0gc2lnbmF0dXJlLnM7XG4gICAgICAgIHJlc3VsdC52ID0gc2lnbmF0dXJlLnY7XG4gICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW07XG4gICAgICAgIHJlc3VsdC5fdnMgPSBzaWduYXR1cmUuX3ZzO1xuICAgICAgICAvLyBJZiB0aGUgX3ZzIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIHBvcHVsYXRlIG1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuICAgICAgICAvLyBhbmQgdmVyaWZ5IG5vbi1taXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgaWYgKHJlc3VsdC5fdnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdnMgPSB6ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLCAzMik7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHJlY2lkXG4gICAgICAgICAgICBjb25zdCByZWNvdmVyeVBhcmFtID0gKCh2c1swXSA+PSAxMjgpID8gMSA6IDApO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgc1xuICAgICAgICAgICAgdnNbMF0gJj0gMHg3ZjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBoZXhsaWZ5KHZzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnMgPSBzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHYgbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlY2lkIGFuZCB2IHRvIHBvcHVsYXRlIGVhY2ggb3RoZXJcbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIHYgYW5kIHJlY292ZXJ5UGFyYW1cIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZXN1bHQudjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gMSAtIChyZXN1bHQudiAlIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNJZCA9IChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkgPyByZXN1bHQudiA6ICgxIC0gKHJlc3VsdC52ICUgMikpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSAhPT0gcmVjSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSByZWNvdmVyeVBhcmFtIG1pc21hdGNoIHZcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5yKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnIgPSBoZXhaZXJvUGFkKHJlc3VsdC5yLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5zID09IG51bGwgfHwgIWlzSGV4U3RyaW5nKHJlc3VsdC5zKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5zLCAzMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdnMgPSBhcnJheWlmeShyZXN1bHQucyk7XG4gICAgICAgIGlmICh2c1swXSA+PSAxMjgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgIHZzWzBdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX3ZzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgIGlmIChyZXN1bHQuX3ZzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvciBjaGVjayB0aGUgX3ZzXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBfdnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIF92cyBtaXNtYXRjaCB2IGFuZCBzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnlQYXJpdHlBbmRTID0gcmVzdWx0Ll92cztcbiAgICByZXN1bHQuY29tcGFjdCA9IHJlc3VsdC5yICsgcmVzdWx0LnlQYXJpdHlBbmRTLnN1YnN0cmluZygyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5TaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgc2lnbmF0dXJlID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICBzaWduYXR1cmUucixcbiAgICAgICAgc2lnbmF0dXJlLnMsXG4gICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG4gICAgXSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJpZ251bWJlci81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBCaWdOdW1iZXJcbiAqXG4gKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcbiAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlc3MuXG4gKlxuICovXG5pbXBvcnQgX0JOIGZyb20gXCJibi5qc1wiO1xudmFyIEJOID0gX0JOLkJOO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5leHBvcnQgZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgaXNIZXhTdHJpbmcodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcbiAgICAgICAgaXNCeXRlcyh2YWx1ZSkpO1xufVxuLy8gT25seSB3YXJuIGFib3V0IHBhc3NpbmcgMTAgaW50byByYWRpeCBvbmNlXG5sZXQgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSBmYWxzZTtcbmV4cG9ydCBjbGFzcyBCaWdOdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcobmV3LnRhcmdldCwgQmlnTnVtYmVyKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5faXNCaWdOdW1iZXIgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBmcm9tVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0b1R3b3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIGFicygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXguc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBzdWIob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIGRpdihvdGhlcikge1xuICAgICAgICBjb25zdCBvID0gQmlnTnVtYmVyLmZyb20ob3RoZXIpO1xuICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImRpdmlzaW9uLWJ5LXplcm9cIiwgXCJkaXZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIG11bChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbW9kKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24tYnktemVyb1wiLCBcIm1vZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS51bW9kKHZhbHVlKSk7XG4gICAgfVxuICAgIHBvdyhvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcIm5lZ2F0aXZlLXBvd2VyXCIsIFwicG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwiYW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcInVuYm91bmQtYml0d2lzZS1yZXN1bHRcIiwgXCJvclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5vcih2YWx1ZSkpO1xuICAgIH1cbiAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmJvdW5kLWJpdHdpc2UtcmVzdWx0XCIsIFwieG9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnhvcih2YWx1ZSkpO1xuICAgIH1cbiAgICBtYXNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcIm1hc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcbiAgICB9XG4gICAgc2hsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJuZWdhdGl2ZS13aWR0aFwiLCBcInNobFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5zaGxuKHZhbHVlKSk7XG4gICAgfVxuICAgIHNocih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwibmVnYXRpdmUtd2lkdGhcIiwgXCJzaHJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc2hybih2YWx1ZSkpO1xuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5lcSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGx0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0KHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgbHRlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmx0ZSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGd0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0KHRvQk4ob3RoZXIpKTtcbiAgICB9XG4gICAgZ3RlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmd0ZSh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faGV4WzBdID09PSBcIi1cIik7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuaXNaZXJvKCk7XG4gICAgfVxuICAgIHRvTnVtYmVyKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcInRvTnVtYmVyXCIsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwidGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBzdXBwb3J0IEJpZ0ludFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIC8vIExvdHMgb2YgcGVvcGxlIGV4cGVjdCB0aGlzLCB3aGljaCB3ZSBkbyBub3Qgc3VwcG9ydCwgc28gY2hlY2sgKFNlZTogIzg4OSlcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdID09PSAxMCkge1xuICAgICAgICAgICAgICAgIGlmICghX3dhcm5lZFRvU3RyaW5nUmFkaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgYW55IHBhcmFtZXRlcnM7IGJhc2UtMTAgaXMgYXNzdW1lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gPT09IDE2KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyB1c2UgYmlnTnVtYmVyLnRvSGV4U3RyaW5nKClcIiwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkJpZ051bWJlci50b1N0cmluZyBkb2VzIG5vdCBhY2NlcHQgcGFyYW1ldGVyc1wiLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS50b1N0cmluZygxMCk7XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGV4O1xuICAgIH1cbiAgICB0b0pTT04oa2V5KSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQmlnTnVtYmVyXCIsIGhleDogdGhpcy50b0hleFN0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eLT8weFswLTlhLWZdKyQvaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/WzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KG5ldyBCTih2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmRlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gTUFYX1NBRkUgfHwgdmFsdWUgPD0gLU1BWF9TQUZFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFueVZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgKGFueVZhbHVlKSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGFueVZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J5dGVzKGFueVZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleGxpZnkoYW55VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW55VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEhleGFibGUgaW50ZXJmYWNlICh0YWtlcyBwcmlvcml0eSlcbiAgICAgICAgICAgIGlmIChhbnlWYWx1ZS50b0hleFN0cmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleCA9IGFueVZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCBoYW5kbGUgbGVnYWN5IEpTT04taWZpZWQgdmFsdWVzIChnb2VzIGF3YXkgaW4gdjYpXG4gICAgICAgICAgICAgICAgbGV0IGhleCA9IGFueVZhbHVlLl9oZXg7XG4gICAgICAgICAgICAgICAgLy8gTmV3LWZvcm0gSlNPTlxuICAgICAgICAgICAgICAgIGlmIChoZXggPT0gbnVsbCAmJiBhbnlWYWx1ZS50eXBlID09PSBcIkJpZ051bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhleCA9IGFueVZhbHVlLmhleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaGV4KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoaGV4KSB8fCAoaGV4WzBdID09PSBcIi1cIiAmJiBpc0hleFN0cmluZyhoZXguc3Vic3RyaW5nKDEpKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCaWdOdW1iZXIgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0JpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQmlnTnVtYmVyKTtcbiAgICB9XG59XG4vLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcbmZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgLy8gRm9yIEJOLCBjYWxsIG9uIHRoZSBoZXggc3RyaW5nXG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB0b0hleCh2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIH1cbiAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuICAgIGlmICh2YWx1ZVswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBuZWdhdGl2ZSBzaWduXG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAvLyBDYW5ub3QgaGF2ZSBtdWx0aXBsZSBuZWdhdGl2ZSBzaWducyAoZS5nLiBcIi0tMHgwNFwiKVxuICAgICAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0b0hleCBvbiB0aGUgcG9zaXRpdmUgY29tcG9uZW50XG4gICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgXCItMHgwMFwiXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gXCIweDAwXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWdhdGUgdGhlIHZhbHVlXG4gICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuICAgIH1cbiAgICAvLyBBZGQgYSBcIjB4XCIgcHJlZml4IGlmIG1pc3NpbmdcbiAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgLy8gTm9ybWFsaXplIHplcm9cbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDAwXCI7XG4gICAgfVxuICAgIC8vIE1ha2UgdGhlIHN0cmluZyBldmVuIGxlbmd0aFxuICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgLy8gVHJpbSB0byBzbWFsbGVzdCBldmVuLWxlbmd0aCBzdHJpbmdcbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKDQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB0b0JpZ051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gdG9CTih2YWx1ZSkge1xuICAgIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpO1xuICAgIGlmIChoZXhbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgIHJldHVybiAobmV3IEJOKFwiLVwiICsgaGV4LnN1YnN0cmluZygzKSwgMTYpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG59XG5mdW5jdGlvbiB0aHJvd0ZhdWx0KGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG4gICAgY29uc3QgcGFyYW1zID0geyBmYXVsdDogZmF1bHQsIG9wZXJhdGlvbjogb3BlcmF0aW9uIH07XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihmYXVsdCwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xufVxuLy8gdmFsdWUgc2hvdWxkIGhhdmUgbm8gcHJlZml4XG5leHBvcnQgZnVuY3Rpb24gX2Jhc2UzNlRvMTYodmFsdWUpIHtcbiAgICByZXR1cm4gKG5ldyBCTih2YWx1ZSwgMzYpKS50b1N0cmluZygxNik7XG59XG4vLyB2YWx1ZSBzaG91bGQgaGF2ZSBubyBwcmVmaXhcbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTE2VG8zNih2YWx1ZSkge1xuICAgIHJldHVybiAobmV3IEJOKHZhbHVlLCAxNikpLnRvU3RyaW5nKDM2KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpZ251bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBzaGEzIGZyb20gXCJqcy1zaGEzXCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG4gICAgcmV0dXJuICcweCcgKyBzaGEzLmtlY2Nha18yNTYoYXJyYXlpZnkoZGF0YSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInJscC81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHBheWxvYWQudW5zaGlmdCgweGMwICsgcGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKCFpc0J5dGVzTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheWlmeShvYmplY3QpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcbiAgICByZXR1cm4gaGV4bGlmeShfZW5jb2RlKG9iamVjdCkpO1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgfVxuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBsb25nIHNlZ21lbnQgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG4gICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaXNIZXhTdHJpbmcsIHN0cmlwWmVyb3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciwgX2Jhc2UxNlRvMzYsIF9iYXNlMzZUbzE2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGFycmF5aWZ5KGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTaGltcyBmb3IgZW52aXJvbm1lbnRzIHRoYXQgYXJlIG1pc3Npbmcgc29tZSByZXF1aXJlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7XG5mdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgaWYgKE1hdGgubG9nMTApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbn1cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlXG5jb25zdCBpYmFuTG9va3VwID0ge307XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcbn1cbi8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcbmNvbnN0IHNhZmVEaWdpdHMgPSBNYXRoLmZsb29yKGxvZzEwKE1BWF9TQUZFX0lOVEVHRVIpKTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pICYmIHJlc3VsdCAhPT0gYWRkcmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIH1cbiAgICBlbHNlIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgIT09IGliYW5DaGVja3N1bShhZGRyZXNzKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBfYmFzZTM2VG8xNihhZGRyZXNzLnN1YnN0cmluZyg0KSk7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGxldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XG4gICAgICAgIGJhc2UzNiA9IFwiMFwiICsgYmFzZTM2O1xuICAgIH1cbiAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcbn1cbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgIGxldCBmcm9tID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmcm9tID0gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSBzdHJpcFplcm9zKGFycmF5aWZ5KEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLm5vbmNlKS50b0hleFN0cmluZygpKSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihlbmNvZGUoW2Zyb20sIG5vbmNlXSkpLCAxMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaCkge1xuICAgIGlmIChoZXhEYXRhTGVuZ3RoKHNhbHQpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBzYWx0KTtcbiAgICB9XG4gICAgaWYgKGhleERhdGFMZW5ndGgoaW5pdENvZGVIYXNoKSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIGluaXRDb2RlSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZ2V0QWRkcmVzcyhmcm9tKSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImhhc2gvNS42LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzdHJpbmdzLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgdmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcbihmdW5jdGlvbiAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtKSB7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXSA9IFwiXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkRcIl0gPSBcIk5GRFwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl0gPSBcIk5GS0NcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG59KShVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG47XG5leHBvcnQgdmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLy8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyA9IGFycmF5aWZ5KGJ5dGVzKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVVRGMTZfU1VSUk9HQVRFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkocmVzdWx0KTtcbn1cbjtcbmZ1bmN0aW9uIGVzY2FwZUNoYXIodmFsdWUpIHtcbiAgICBjb25zdCBoZXggPSAoXCIwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAyNTYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDogcmV0dXJuIFwiXFxcXFxcXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDkyOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAzMiAmJiBjb2RlUG9pbnQgPCAxMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9KS5qb2luKFwiXCIpICsgJ1wiJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCIsImltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmV4cG9ydCBmdW5jdGlvbiBpZCh0ZXh0KSB7XG4gICAgcmV0dXJuIGtlY2NhazI1Nih0b1V0ZjhCeXRlcyh0ZXh0KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZC5qcy5tYXAiLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleENvbmNhdCwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi9pZFwiO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IE5lZ2F0aXZlT25lID0gQmlnTnVtYmVyLmZyb20oLTEpO1xuY29uc3QgWmVybyA9IEJpZ051bWJlci5mcm9tKDApO1xuY29uc3QgT25lID0gQmlnTnVtYmVyLmZyb20oMSk7XG5jb25zdCBNYXhVaW50MjU2ID0gQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGhleENvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gaGV4WmVyb1BhZChPbmUudG9IZXhTdHJpbmcoKSwgMzIpO1xuY29uc3QgaGV4RmFsc2UgPSBoZXhaZXJvUGFkKFplcm8udG9IZXhTdHJpbmcoKSwgMzIpO1xuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcbiAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IFwiYWRkcmVzc1wiLFxuICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG59O1xuY29uc3QgZG9tYWluRmllbGROYW1lcyA9IFtcbiAgICBcIm5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwiY2hhaW5JZFwiLCBcInZlcmlmeWluZ0NvbnRyYWN0XCIsIFwic2FsdFwiXG5dO1xuZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yIFwiY2hhaW5JZFwiYCwgXCJkb21haW4uY2hhaW5JZFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgXCJ2ZXJpZnlpbmdDb250cmFjdFwiYCwgXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2FsdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgXCJzYWx0XCJgLCBcImRvbWFpbi5zYWx0XCIsIHZhbHVlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKikkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBpZiAod2lkdGggJSA4ICE9PSAwIHx8IHdpZHRoID4gMjU2IHx8IChtYXRjaFsyXSAmJiBtYXRjaFsyXSAhPT0gU3RyaW5nKHdpZHRoKSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gTWF4VWludDI1Ni5tYXNrKHNpZ25lZCA/ICh3aWR0aCAtIDEpIDogd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzTG93ZXIgPSBzaWduZWQgPyBib3VuZHNVcHBlci5hZGQoT25lKS5tdWwoTmVnYXRpdmVPbmUpIDogWmVybztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2Lmx0KGJvdW5kc0xvd2VyKSB8fCB2Lmd0KGJvdW5kc1VwcGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKHYudG9Ud29zKDI1NikudG9IZXhTdHJpbmcoKSwgMzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBieXRlc1hYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCB3aWR0aCA+IDMyIHx8IG1hdGNoWzFdICE9PSBTdHJpbmcod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4WmVyb1BhZChnZXRBZGRyZXNzKHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCghdmFsdWUpID8gaGV4RmFsc2UgOiBoZXhUcnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0oJHtmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4gKHR5cGUgKyBcIiBcIiArIG5hbWUpKS5qb2luKFwiLFwiKX0pYDtcbn1cbmV4cG9ydCBjbGFzcyBUeXBlZERhdGFFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInR5cGVzXCIsIE9iamVjdC5mcmVlemUoZGVlcENvcHkodHlwZXMpKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2VuY29kZXJDYWNoZVwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3R5cGVzXCIsIHt9KTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcbiAgICAgICAgY29uc3QgbGlua3MgPSB7fTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHt9O1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxpbmtzW3R5cGVdID0ge307XG4gICAgICAgICAgICBwYXJlbnRzW3R5cGVdID0gW107XG4gICAgICAgICAgICBzdWJ0eXBlc1t0eXBlXSA9IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHt9O1xuICAgICAgICAgICAgdHlwZXNbbmFtZV0uZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IGZpZWxkLnR5cGUubWF0Y2goL14oW15cXHg1Yl0qKShcXHg1YnwkKS8pWzFdO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlVHlwZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGJhc2UgZW5jb2RpbmcgdHlwZT9cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2Jhc2VUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgcGFyZW50c1tiYXNlVHlwZV0ucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rc1tuYW1lXVtiYXNlVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdWNlIHRoZSBwcmltYXJ5IHR5cGVcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGVzID0gT2JqZWN0LmtleXMocGFyZW50cykuZmlsdGVyKChuKSA9PiAocGFyZW50c1tuXS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgaWYgKHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmltYXJ5VHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByaW1hcnlUeXBlXCIsIHByaW1hcnlUeXBlc1swXSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgaWYgKGZvdW5kW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmtzW3R5cGVdKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50c1tjaGlsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZm91bmQpLmZvckVhY2goKHN1YnR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXNbc3VidHlwZV1bY2hpbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIGZvdW5kW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwge30pO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gT2JqZWN0LmtleXMoc3VidHlwZXNbbmFtZV0pO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy5fdHlwZXNbbmFtZV0gPSBlbmNvZGVUeXBlKG5hbWUsIHR5cGVzW25hbWVdKSArIHN0Lm1hcCgodCkgPT4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSkpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy5fZW5jb2RlckNhY2hlW3R5cGVdO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV0gPSB0aGlzLl9nZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH1cbiAgICBfZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3ViRW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID49IDAgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGVzW3N1YnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoa2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihoZXhDb25jYXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVHlwZSA9IGlkKHRoaXMuX3R5cGVzW3R5cGVdKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWVbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4Q29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl90eXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlKTtcbiAgICB9XG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGhhc2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAkeyBhcnJheUxlbmd0aCB9XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoc3VidHlwZSwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh0eXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkRGF0YUVuY29kZXIodHlwZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UHJpbWFyeVR5cGUodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoU3RydWN0KG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2hEb21haW4oZG9tYWluKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbkZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgdHlwZWQtZGF0YSBkb21haW4ga2V5OiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwiZG9tYWluXCIsIGRvbWFpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGhleENvbmNhdChbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICBzdGF0aWMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgICAgICBkb21haW4gPSBzaGFsbG93Q29weShkb21haW4pO1xuICAgICAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cbiAgICAgICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgIWlzSGV4U3RyaW5nKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXG4gICAgICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0geWllbGQgcmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcbiAgICAgICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xuICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IHNoYWxsb3dDb3B5KHR5cGVzKTtcbiAgICAgICAgaWYgKHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xuICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxuICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogZW5jb2Rlci5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL15ieXRlcyhcXGQqKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGFycmF5aWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgb3IgaW50XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIHN0cmluZ2AsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmNvbnN0IE5lZ2F0aXZlT25lID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oLTEpKTtcbmNvbnN0IFplcm8gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgwKSk7XG5jb25zdCBPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgxKSk7XG5jb25zdCBUd28gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgyKSk7XG5jb25zdCBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5jb25zdCBNYXhVaW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuY29uc3QgTWluSW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCItMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heEludDI1NiA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydCB7IE5lZ2F0aXZlT25lLCBaZXJvLCBPbmUsIFR3bywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVycy5qcy5tYXAiLCJpbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGhhc2ggZnJvbSAnaGFzaC5qcyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgYmFzZWRpciwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7XG5cdFx0cGF0aDogYmFzZWRpcixcblx0XHRleHBvcnRzOiB7fSxcblx0XHRyZXF1aXJlOiBmdW5jdGlvbiAocGF0aCwgYmFzZSkge1xuXHRcdFx0cmV0dXJuIGNvbW1vbmpzUmVxdWlyZShwYXRoLCAoYmFzZSA9PT0gdW5kZWZpbmVkIHx8IGJhc2UgPT09IG51bGwpID8gbW9kdWxlLnBhdGggOiBiYXNlKTtcblx0XHR9XG5cdH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZlByZXNlbnQgKG4pIHtcblx0cmV0dXJuIG4gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sICdkZWZhdWx0JykgPyBuWydkZWZhdWx0J10gOiBuO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbU5hbWVzcGFjZUlmTm90TmFtZWQgKG4pIHtcblx0cmV0dXJuIG4gJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sICdkZWZhdWx0JykgJiYgT2JqZWN0LmtleXMobikubGVuZ3RoID09PSAxID8gblsnZGVmYXVsdCddIDogbjtcbn1cblxuZnVuY3Rpb24gZ2V0QXVnbWVudGVkTmFtZXNwYWNlKG4pIHtcblx0aWYgKG4uX19lc01vZHVsZSkgcmV0dXJuIG47XG5cdHZhciBhID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnX19lc01vZHVsZScsIHt2YWx1ZTogdHJ1ZX0pO1xuXHRPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG5cdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sIGspO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCBrLCBkLmdldCA/IGQgOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBuW2tdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdHRocm93IG5ldyBFcnJvcignRHluYW1pYyByZXF1aXJlcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgQHJvbGx1cC9wbHVnaW4tY29tbW9uanMnKTtcbn1cblxudmFyIG1pbmltYWxpc3RpY0Fzc2VydCA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcblxudmFyIHV0aWxzXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSArPSAyKVxuICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoaSA9IGMgPj4gODtcbiAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuICAgICAgaWYgKGhpKVxuICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXMucHVzaChsbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0FycmF5ID0gdG9BcnJheTtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbnV0aWxzLnplcm8yID0gemVybzI7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbnV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cbnV0aWxzLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShhcnIsIGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdG9IZXgoYXJyKTtcbiAgZWxzZVxuICAgIHJldHVybiBhcnI7XG59O1xufSk7XG5cbnZhciB1dGlsc18xJDEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IGV4cG9ydHM7XG5cblxuXG5cbnV0aWxzLmFzc2VydCA9IG1pbmltYWxpc3RpY0Fzc2VydDtcbnV0aWxzLnRvQXJyYXkgPSB1dGlsc18xLnRvQXJyYXk7XG51dGlscy56ZXJvMiA9IHV0aWxzXzEuemVybzI7XG51dGlscy50b0hleCA9IHV0aWxzXzEudG9IZXg7XG51dGlscy5lbmNvZGUgPSB1dGlsc18xLmVuY29kZTtcblxuLy8gUmVwcmVzZW50IG51bSBpbiBhIHctTkFGIGZvcm1cbmZ1bmN0aW9uIGdldE5BRihudW0sIHcsIGJpdHMpIHtcbiAgdmFyIG5hZiA9IG5ldyBBcnJheShNYXRoLm1heChudW0uYml0TGVuZ3RoKCksIGJpdHMpICsgMSk7XG4gIG5hZi5maWxsKDApO1xuXG4gIHZhciB3cyA9IDEgPDwgKHcgKyAxKTtcbiAgdmFyIGsgPSBudW0uY2xvbmUoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB6O1xuICAgIHZhciBtb2QgPSBrLmFuZGxuKHdzIC0gMSk7XG4gICAgaWYgKGsuaXNPZGQoKSkge1xuICAgICAgaWYgKG1vZCA+ICh3cyA+PiAxKSAtIDEpXG4gICAgICAgIHogPSAod3MgPj4gMSkgLSBtb2Q7XG4gICAgICBlbHNlXG4gICAgICAgIHogPSBtb2Q7XG4gICAgICBrLmlzdWJuKHopO1xuICAgIH0gZWxzZSB7XG4gICAgICB6ID0gMDtcbiAgICB9XG5cbiAgICBuYWZbaV0gPSB6O1xuICAgIGsuaXVzaHJuKDEpO1xuICB9XG5cbiAgcmV0dXJuIG5hZjtcbn1cbnV0aWxzLmdldE5BRiA9IGdldE5BRjtcblxuLy8gUmVwcmVzZW50IGsxLCBrMiBpbiBhIEpvaW50IFNwYXJzZSBGb3JtXG5mdW5jdGlvbiBnZXRKU0YoazEsIGsyKSB7XG4gIHZhciBqc2YgPSBbXG4gICAgW10sXG4gICAgW10sXG4gIF07XG5cbiAgazEgPSBrMS5jbG9uZSgpO1xuICBrMiA9IGsyLmNsb25lKCk7XG4gIHZhciBkMSA9IDA7XG4gIHZhciBkMiA9IDA7XG4gIHZhciBtODtcbiAgd2hpbGUgKGsxLmNtcG4oLWQxKSA+IDAgfHwgazIuY21wbigtZDIpID4gMCkge1xuICAgIC8vIEZpcnN0IHBoYXNlXG4gICAgdmFyIG0xNCA9IChrMS5hbmRsbigzKSArIGQxKSAmIDM7XG4gICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG4gICAgaWYgKG0xNCA9PT0gMylcbiAgICAgIG0xNCA9IC0xO1xuICAgIGlmIChtMjQgPT09IDMpXG4gICAgICBtMjQgPSAtMTtcbiAgICB2YXIgdTE7XG4gICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuICAgICAgdTEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtOCA9IChrMS5hbmRsbig3KSArIGQxKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG4gICAgICAgIHUxID0gLW0xNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTEgPSBtMTQ7XG4gICAgfVxuICAgIGpzZlswXS5wdXNoKHUxKTtcblxuICAgIHZhciB1MjtcbiAgICBpZiAoKG0yNCAmIDEpID09PSAwKSB7XG4gICAgICB1MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG04ID0gKGsyLmFuZGxuKDcpICsgZDIpICYgNztcbiAgICAgIGlmICgobTggPT09IDMgfHwgbTggPT09IDUpICYmIG0xNCA9PT0gMilcbiAgICAgICAgdTIgPSAtbTI0O1xuICAgICAgZWxzZVxuICAgICAgICB1MiA9IG0yNDtcbiAgICB9XG4gICAganNmWzFdLnB1c2godTIpO1xuXG4gICAgLy8gU2Vjb25kIHBoYXNlXG4gICAgaWYgKDIgKiBkMSA9PT0gdTEgKyAxKVxuICAgICAgZDEgPSAxIC0gZDE7XG4gICAgaWYgKDIgKiBkMiA9PT0gdTIgKyAxKVxuICAgICAgZDIgPSAxIC0gZDI7XG4gICAgazEuaXVzaHJuKDEpO1xuICAgIGsyLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBqc2Y7XG59XG51dGlscy5nZXRKU0YgPSBnZXRKU0Y7XG5cbmZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KG9iaiwgbmFtZSwgY29tcHV0ZXIpIHtcbiAgdmFyIGtleSA9ICdfJyArIG5hbWU7XG4gIG9iai5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpc1trZXldICE9PSB1bmRlZmluZWQgPyB0aGlzW2tleV0gOlxuICAgICAgdGhpc1trZXldID0gY29tcHV0ZXIuY2FsbCh0aGlzKTtcbiAgfTtcbn1cbnV0aWxzLmNhY2hlZFByb3BlcnR5ID0gY2FjaGVkUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycgPyB1dGlscy50b0FycmF5KGJ5dGVzLCAnaGV4JykgOlxuICAgIGJ5dGVzO1xufVxudXRpbHMucGFyc2VCeXRlcyA9IHBhcnNlQnl0ZXM7XG5cbmZ1bmN0aW9uIGludEZyb21MRShieXRlcykge1xuICByZXR1cm4gbmV3IEJOKGJ5dGVzLCAnaGV4JywgJ2xlJyk7XG59XG51dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxudmFyIGdldE5BRiA9IHV0aWxzXzEkMS5nZXROQUY7XG52YXIgZ2V0SlNGID0gdXRpbHNfMSQxLmdldEpTRjtcbnZhciBhc3NlcnQkMSA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEJhc2VDdXJ2ZSh0eXBlLCBjb25mKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucCA9IG5ldyBCTihjb25mLnAsIDE2KTtcblxuICAvLyBVc2UgTW9udGdvbWVyeSwgd2hlbiB0aGVyZSBpcyBubyBmYXN0IHJlZHVjdGlvbiBmb3IgdGhlIHByaW1lXG4gIHRoaXMucmVkID0gY29uZi5wcmltZSA/IEJOLnJlZChjb25mLnByaW1lKSA6IEJOLm1vbnQodGhpcy5wKTtcblxuICAvLyBVc2VmdWwgZm9yIG1hbnkgY3VydmVzXG4gIHRoaXMuemVybyA9IG5ldyBCTigwKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMub25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50d28gPSBuZXcgQk4oMikudG9SZWQodGhpcy5yZWQpO1xuXG4gIC8vIEN1cnZlIGNvbmZpZ3VyYXRpb24sIG9wdGlvbmFsXG4gIHRoaXMubiA9IGNvbmYubiAmJiBuZXcgQk4oY29uZi5uLCAxNik7XG4gIHRoaXMuZyA9IGNvbmYuZyAmJiB0aGlzLnBvaW50RnJvbUpTT04oY29uZi5nLCBjb25mLmdSZWQpO1xuXG4gIC8vIFRlbXBvcmFyeSBhcnJheXNcbiAgdGhpcy5fd25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDIgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUMyA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQ0ID0gbmV3IEFycmF5KDQpO1xuXG4gIHRoaXMuX2JpdExlbmd0aCA9IHRoaXMubiA/IHRoaXMubi5iaXRMZW5ndGgoKSA6IDA7XG5cbiAgLy8gR2VuZXJhbGl6ZWQgR3JlZyBNYXh3ZWxsJ3MgdHJpY2tcbiAgdmFyIGFkanVzdENvdW50ID0gdGhpcy5uICYmIHRoaXMucC5kaXYodGhpcy5uKTtcbiAgaWYgKCFhZGp1c3RDb3VudCB8fCBhZGp1c3RDb3VudC5jbXBuKDEwMCkgPiAwKSB7XG4gICAgdGhpcy5yZWROID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9tYXh3ZWxsVHJpY2sgPSB0cnVlO1xuICAgIHRoaXMucmVkTiA9IHRoaXMubi50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbn1cbnZhciBiYXNlID0gQmFzZUN1cnZlO1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl9maXhlZE5hZk11bCA9IGZ1bmN0aW9uIF9maXhlZE5hZk11bChwLCBrKSB7XG4gIGFzc2VydCQxKHAucHJlY29tcHV0ZWQpO1xuICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuICB2YXIgbmFmID0gZ2V0TkFGKGssIDEsIHRoaXMuX2JpdExlbmd0aCk7XG4gIHZhciBJID0gKDEgPDwgKGRvdWJsZXMuc3RlcCArIDEpKSAtIChkb3VibGVzLnN0ZXAgJSAyID09PSAwID8gMiA6IDEpO1xuICBJIC89IDM7XG5cbiAgLy8gVHJhbnNsYXRlIGludG8gbW9yZSB3aW5kb3dlZCBmb3JtXG4gIHZhciByZXByID0gW107XG4gIHZhciBqO1xuICB2YXIgbmFmVztcbiAgZm9yIChqID0gMDsgaiA8IG5hZi5sZW5ndGg7IGogKz0gZG91Ymxlcy5zdGVwKSB7XG4gICAgbmFmVyA9IDA7XG4gICAgZm9yICh2YXIgbCA9IGogKyBkb3VibGVzLnN0ZXAgLSAxOyBsID49IGo7IGwtLSlcbiAgICAgIG5hZlcgPSAobmFmVyA8PCAxKSArIG5hZltsXTtcbiAgICByZXByLnB1c2gobmFmVyk7XG4gIH1cblxuICB2YXIgYSA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICB2YXIgYiA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gSTsgaSA+IDA7IGktLSkge1xuICAgIGZvciAoaiA9IDA7IGogPCByZXByLmxlbmd0aDsgaisrKSB7XG4gICAgICBuYWZXID0gcmVwcltqXTtcbiAgICAgIGlmIChuYWZXID09PSBpKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXSk7XG4gICAgICBlbHNlIGlmIChuYWZXID09PSAtaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuICAgIH1cbiAgICBhID0gYS5hZGQoYik7XG4gIH1cbiAgcmV0dXJuIGEudG9QKCk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuICB2YXIgdyA9IDQ7XG5cbiAgLy8gUHJlY29tcHV0ZSB3aW5kb3dcbiAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcbiAgdyA9IG5hZlBvaW50cy53bmQ7XG4gIHZhciB3bmQgPSBuYWZQb2ludHMucG9pbnRzO1xuXG4gIC8vIEdldCBOQUYgZm9ybVxuICB2YXIgbmFmID0gZ2V0TkFGKGssIHcsIHRoaXMuX2JpdExlbmd0aCk7XG5cbiAgLy8gQWRkIGB0aGlzYCooTisxKSBmb3IgZXZlcnkgdy1OQUYgaW5kZXhcbiAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuICBmb3IgKHZhciBpID0gbmFmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gQ291bnQgemVyb2VzXG4gICAgZm9yICh2YXIgbCA9IDA7IGkgPj0gMCAmJiBuYWZbaV0gPT09IDA7IGktLSlcbiAgICAgIGwrKztcbiAgICBpZiAoaSA+PSAwKVxuICAgICAgbCsrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGwpO1xuXG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG4gICAgdmFyIHogPSBuYWZbaV07XG4gICAgYXNzZXJ0JDEoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gIHBvaW50cyxcbiAgY29lZmZzLFxuICBsZW4sXG4gIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcbiAgdmFyIHduZCA9IHRoaXMuX3duYWZUMjtcbiAgdmFyIG5hZiA9IHRoaXMuX3duYWZUMztcblxuICAvLyBGaWxsIGFsbCBhcnJheXNcbiAgdmFyIG1heCA9IDA7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIHA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcbiAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG4gICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgfVxuXG4gIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcbiAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcbiAgICB2YXIgYSA9IGkgLSAxO1xuICAgIHZhciBiID0gaTtcbiAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcbiAgICAgIG5hZlthXSA9IGdldE5BRihjb2VmZnNbYV0sIHduZFdpZHRoW2FdLCB0aGlzLl9iaXRMZW5ndGgpO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb21iID0gW1xuICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG4gICAgICBudWxsLCAvKiAzICovXG4gICAgICBudWxsLCAvKiA1ICovXG4gICAgICBwb2ludHNbYl0sIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMywgIC8qIDEgMSAqL1xuICAgIF07XG5cbiAgICB2YXIganNmID0gZ2V0SlNGKGNvZWZmc1thXSwgY29lZmZzW2JdKTtcbiAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIG5hZltiXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIGZvciAoaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yIChpID0gbWF4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBrID0gMDtcblxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuICAgICAgICBpZiAodG1wW2pdICE9PSAwKVxuICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghemVybylcbiAgICAgICAgYnJlYWs7XG4gICAgICBrKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgcDtcbiAgICAgIGlmICh6ID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGVsc2UgaWYgKHogPiAwKVxuICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gIH1cbiAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB3bmRbaV0gPSBudWxsO1xuXG4gIGlmIChqYWNvYmlhblJlc3VsdClcbiAgICByZXR1cm4gYWNjO1xuICBlbHNlXG4gICAgcmV0dXJuIGFjYy50b1AoKTtcbn07XG5cbmZ1bmN0aW9uIEJhc2VQb2ludChjdXJ2ZSwgdHlwZSkge1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBudWxsO1xufVxuQmFzZUN1cnZlLkJhc2VQb2ludCA9IEJhc2VQb2ludDtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKC8qb3RoZXIqLykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIGJ5dGVzID0gdXRpbHNfMSQxLnRvQXJyYXkoYnl0ZXMsIGVuYyk7XG5cbiAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cbiAgLy8gdW5jb21wcmVzc2VkLCBoeWJyaWQtb2RkLCBoeWJyaWQtZXZlblxuICBpZiAoKGJ5dGVzWzBdID09PSAweDA0IHx8IGJ5dGVzWzBdID09PSAweDA2IHx8IGJ5dGVzWzBdID09PSAweDA3KSAmJlxuICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuICAgIGlmIChieXRlc1swXSA9PT0gMHgwNilcbiAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMCk7XG4gICAgZWxzZSBpZiAoYnl0ZXNbMF0gPT09IDB4MDcpXG4gICAgICBhc3NlcnQkMShieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDEpO1xuXG4gICAgdmFyIHJlcyA9ICB0aGlzLnBvaW50KGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLFxuICAgICAgYnl0ZXMuc2xpY2UoMSArIGxlbiwgMSArIDIgKiBsZW4pKTtcblxuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoKGJ5dGVzWzBdID09PSAweDAyIHx8IGJ5dGVzWzBdID09PSAweDAzKSAmJlxuICAgICAgICAgICAgICBieXRlcy5sZW5ndGggLSAxID09PSBsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludEZyb21YKGJ5dGVzLnNsaWNlKDEsIDEgKyBsZW4pLCBieXRlc1swXSA9PT0gMHgwMyk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHBvaW50IGZvcm1hdCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkID0gZnVuY3Rpb24gZW5jb2RlQ29tcHJlc3NlZChlbmMpIHtcbiAgcmV0dXJuIHRoaXMuZW5jb2RlKGVuYywgdHJ1ZSk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKGNvbXBhY3QpIHtcbiAgdmFyIGxlbiA9IHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCk7XG4gIHZhciB4ID0gdGhpcy5nZXRYKCkudG9BcnJheSgnYmUnLCBsZW4pO1xuXG4gIGlmIChjb21wYWN0KVxuICAgIHJldHVybiBbIHRoaXMuZ2V0WSgpLmlzRXZlbigpID8gMHgwMiA6IDB4MDMgXS5jb25jYXQoeCk7XG5cbiAgcmV0dXJuIFsgMHgwNCBdLmNvbmNhdCh4LCB0aGlzLmdldFkoKS50b0FycmF5KCdiZScsIGxlbikpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG4gIHJldHVybiB1dGlsc18xJDEuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSwgZW5jKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHByZWNvbXB1dGVkID0ge1xuICAgIGRvdWJsZXM6IG51bGwsXG4gICAgbmFmOiBudWxsLFxuICAgIGJldGE6IG51bGwsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzLFxuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG4gIHZhciByZXMgPSBbIHRoaXMgXTtcbiAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG4gICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgcmV0dXJuIHtcbiAgICB3bmQ6IHduZCxcbiAgICBwb2ludHM6IHJlcyxcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKGspIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKylcbiAgICByID0gci5kYmwoKTtcbiAgcmV0dXJuIHI7XG59O1xuXG52YXIgaW5oZXJpdHNfYnJvd3NlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gICAgfVxuICB9O1xufVxufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cbnZhciBhc3NlcnQkMiA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICBiYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG4gIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcbiAgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO1xuICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxuaW5oZXJpdHNfYnJvd3NlcihTaG9ydEN1cnZlLCBiYXNlKTtcbnZhciBzaG9ydF8xID0gU2hvcnRDdXJ2ZTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9tb3JwaGlzbSA9IGZ1bmN0aW9uIF9nZXRFbmRvbW9ycGhpc20oY29uZikge1xuICAvLyBObyBlZmZpY2llbnQgZW5kb21vcnBoaXNtXG4gIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG4gICAgcmV0dXJuO1xuXG4gIC8vIENvbXB1dGUgYmV0YSBhbmQgbGFtYmRhLCB0aGF0IGxhbWJkYSAqIFAgPSAoYmV0YSAqIFB4OyBQeSlcbiAgdmFyIGJldGE7XG4gIHZhciBsYW1iZGE7XG4gIGlmIChjb25mLmJldGEpIHtcbiAgICBiZXRhID0gbmV3IEJOKGNvbmYuYmV0YSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcbiAgICAvLyBDaG9vc2UgdGhlIHNtYWxsZXN0IGJldGFcbiAgICBiZXRhID0gYmV0YXNbMF0uY21wKGJldGFzWzFdKSA8IDAgPyBiZXRhc1swXSA6IGJldGFzWzFdO1xuICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcbiAgfVxuICBpZiAoY29uZi5sYW1iZGEpIHtcbiAgICBsYW1iZGEgPSBuZXcgQk4oY29uZi5sYW1iZGEsIDE2KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDaG9vc2UgdGhlIGxhbWJkYSB0aGF0IGlzIG1hdGNoaW5nIHNlbGVjdGVkIGJldGFcbiAgICB2YXIgbGFtYmRhcyA9IHRoaXMuX2dldEVuZG9Sb290cyh0aGlzLm4pO1xuICAgIGlmICh0aGlzLmcubXVsKGxhbWJkYXNbMF0pLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMV07XG4gICAgICBhc3NlcnQkMih0aGlzLmcubXVsKGxhbWJkYSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR2V0IGJhc2lzIHZlY3RvcnMsIHVzZWQgZm9yIGJhbGFuY2VkIGxlbmd0aC10d28gcmVwcmVzZW50YXRpb25cbiAgdmFyIGJhc2lzO1xuICBpZiAoY29uZi5iYXNpcykge1xuICAgIGJhc2lzID0gY29uZi5iYXNpcy5tYXAoZnVuY3Rpb24odmVjKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBuZXcgQk4odmVjLmEsIDE2KSxcbiAgICAgICAgYjogbmV3IEJOKHZlYy5iLCAxNiksXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGJhc2lzID0gdGhpcy5fZ2V0RW5kb0Jhc2lzKGxhbWJkYSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJldGE6IGJldGEsXG4gICAgbGFtYmRhOiBsYW1iZGEsXG4gICAgYmFzaXM6IGJhc2lzLFxuICB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9Sb290cyA9IGZ1bmN0aW9uIF9nZXRFbmRvUm9vdHMobnVtKSB7XG4gIC8vIEZpbmQgcm9vdHMgb2YgZm9yIHheMiArIHggKyAxIGluIEZcbiAgLy8gUm9vdCA9ICgtMSArLSBTcXJ0KC0zKSkgLyAyXG4gIC8vXG4gIHZhciByZWQgPSBudW0gPT09IHRoaXMucCA/IHRoaXMucmVkIDogQk4ubW9udChudW0pO1xuICB2YXIgdGludiA9IG5ldyBCTigyKS50b1JlZChyZWQpLnJlZEludm0oKTtcbiAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuICB2YXIgcyA9IG5ldyBCTigzKS50b1JlZChyZWQpLnJlZE5lZygpLnJlZFNxcnQoKS5yZWRNdWwodGludik7XG5cbiAgdmFyIGwxID0gbnRpbnYucmVkQWRkKHMpLmZyb21SZWQoKTtcbiAgdmFyIGwyID0gbnRpbnYucmVkU3ViKHMpLmZyb21SZWQoKTtcbiAgcmV0dXJuIFsgbDEsIGwyIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb0Jhc2lzID0gZnVuY3Rpb24gX2dldEVuZG9CYXNpcyhsYW1iZGEpIHtcbiAgLy8gYXByeFNxcnQgPj0gc3FydCh0aGlzLm4pXG4gIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuICAvLyAzLjc0XG4gIC8vIFJ1biBFR0NELCB1bnRpbCByKEwgKyAxKSA8IGFwcnhTcXJ0XG4gIHZhciB1ID0gbGFtYmRhO1xuICB2YXIgdiA9IHRoaXMubi5jbG9uZSgpO1xuICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gIHZhciB5MSA9IG5ldyBCTigwKTtcbiAgdmFyIHgyID0gbmV3IEJOKDApO1xuICB2YXIgeTIgPSBuZXcgQk4oMSk7XG5cbiAgLy8gTk9URTogYWxsIHZlY3RvcnMgYXJlIHJvb3RzIG9mOiBhICsgYiAqIGxhbWJkYSA9IDAgKG1vZCBuKVxuICB2YXIgYTA7XG4gIHZhciBiMDtcbiAgLy8gRmlyc3QgdmVjdG9yXG4gIHZhciBhMTtcbiAgdmFyIGIxO1xuICAvLyBTZWNvbmQgdmVjdG9yXG4gIHZhciBhMjtcbiAgdmFyIGIyO1xuXG4gIHZhciBwcmV2UjtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcjtcbiAgdmFyIHg7XG4gIHdoaWxlICh1LmNtcG4oMCkgIT09IDApIHtcbiAgICB2YXIgcSA9IHYuZGl2KHUpO1xuICAgIHIgPSB2LnN1YihxLm11bCh1KSk7XG4gICAgeCA9IHgyLnN1YihxLm11bCh4MSkpO1xuICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cbiAgICBpZiAoIWExICYmIHIuY21wKGFwcnhTcXJ0KSA8IDApIHtcbiAgICAgIGEwID0gcHJldlIubmVnKCk7XG4gICAgICBiMCA9IHgxO1xuICAgICAgYTEgPSByLm5lZygpO1xuICAgICAgYjEgPSB4O1xuICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldlIgPSByO1xuXG4gICAgdiA9IHU7XG4gICAgdSA9IHI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHg7XG4gICAgeTIgPSB5MTtcbiAgICB5MSA9IHk7XG4gIH1cbiAgYTIgPSByLm5lZygpO1xuICBiMiA9IHg7XG5cbiAgdmFyIGxlbjEgPSBhMS5zcXIoKS5hZGQoYjEuc3FyKCkpO1xuICB2YXIgbGVuMiA9IGEyLnNxcigpLmFkZChiMi5zcXIoKSk7XG4gIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG4gICAgYTIgPSBhMDtcbiAgICBiMiA9IGIwO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIHNpZ25zXG4gIGlmIChhMS5uZWdhdGl2ZSkge1xuICAgIGExID0gYTEubmVnKCk7XG4gICAgYjEgPSBiMS5uZWcoKTtcbiAgfVxuICBpZiAoYTIubmVnYXRpdmUpIHtcbiAgICBhMiA9IGEyLm5lZygpO1xuICAgIGIyID0gYjIubmVnKCk7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHsgYTogYTEsIGI6IGIxIH0sXG4gICAgeyBhOiBhMiwgYjogYjIgfSxcbiAgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvU3BsaXQgPSBmdW5jdGlvbiBfZW5kb1NwbGl0KGspIHtcbiAgdmFyIGJhc2lzID0gdGhpcy5lbmRvLmJhc2lzO1xuICB2YXIgdjEgPSBiYXNpc1swXTtcbiAgdmFyIHYyID0gYmFzaXNbMV07XG5cbiAgdmFyIGMxID0gdjIuYi5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcbiAgdmFyIGMyID0gdjEuYi5uZWcoKS5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblxuICB2YXIgcDEgPSBjMS5tdWwodjEuYSk7XG4gIHZhciBwMiA9IGMyLm11bCh2Mi5hKTtcbiAgdmFyIHExID0gYzEubXVsKHYxLmIpO1xuICB2YXIgcTIgPSBjMi5tdWwodjIuYik7XG5cbiAgLy8gQ2FsY3VsYXRlIGFuc3dlclxuICB2YXIgazEgPSBrLnN1YihwMSkuc3ViKHAyKTtcbiAgdmFyIGsyID0gcTEuYWRkKHEyKS5uZWcoKTtcbiAgcmV0dXJuIHsgazE6IGsxLCBrMjogazIgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIC8vIFhYWCBJcyB0aGVyZSBhbnkgd2F5IHRvIHRlbGwgaWYgdGhlIG51bWJlciBpcyBvZGQgd2l0aG91dCBjb252ZXJ0aW5nIGl0XG4gIC8vIHRvIG5vbi1yZWQgZm9ybT9cbiAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcbiAgaWYgKG9kZCAmJiAhaXNPZGQgfHwgIW9kZCAmJiBpc09kZClcbiAgICB5ID0geS5yZWROZWcoKTtcblxuICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmluZilcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeCA9IHBvaW50Lng7XG4gIHZhciB5ID0gcG9pbnQueTtcblxuICB2YXIgYXggPSB0aGlzLmEucmVkTXVsKHgpO1xuICB2YXIgcmhzID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZChheCkucmVkSUFkZCh0aGlzLmIpO1xuICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9lbmRvV25hZk11bEFkZCA9XG4gICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCBqYWNvYmlhblJlc3VsdCkge1xuICAgICAgdmFyIG5wb2ludHMgPSB0aGlzLl9lbmRvV25hZlQxO1xuICAgICAgdmFyIG5jb2VmZnMgPSB0aGlzLl9lbmRvV25hZlQyO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gdGhpcy5fZW5kb1NwbGl0KGNvZWZmc1tpXSk7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgYmV0YSA9IHAuX2dldEJldGEoKTtcblxuICAgICAgICBpZiAoc3BsaXQuazEubmVnYXRpdmUpIHtcbiAgICAgICAgICBzcGxpdC5rMS5pbmVnKCk7XG4gICAgICAgICAgcCA9IHAubmVnKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpdC5rMi5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNwbGl0LmsyLmluZWcoKTtcbiAgICAgICAgICBiZXRhID0gYmV0YS5uZWcodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG4gICAgICAgIG5wb2ludHNbaSAqIDIgKyAxXSA9IGJldGE7XG4gICAgICAgIG5jb2VmZnNbaSAqIDJdID0gc3BsaXQuazE7XG4gICAgICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuICAgICAgfVxuICAgICAgdmFyIHJlcyA9IHRoaXMuX3duYWZNdWxBZGQoMSwgbnBvaW50cywgbmNvZWZmcywgaSAqIDIsIGphY29iaWFuUmVzdWx0KTtcblxuICAgICAgLy8gQ2xlYW4tdXAgcmVmZXJlbmNlcyB0byBwb2ludHMgYW5kIGNvZWZmaWNpZW50c1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpICogMjsgaisrKSB7XG4gICAgICAgIG5wb2ludHNbal0gPSBudWxsO1xuICAgICAgICBuY29lZmZzW2pdID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuZnVuY3Rpb24gUG9pbnQoY3VydmUsIHgsIHksIGlzUmVkKSB7XG4gIGJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdhZmZpbmUnKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuICAgIHRoaXMueCA9IG51bGw7XG4gICAgdGhpcy55ID0gbnVsbDtcbiAgICB0aGlzLmluZiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIC8vIEZvcmNlIHJlZGdvbWVyeSByZXByZXNlbnRhdGlvbiB3aGVuIGxvYWRpbmcgZnJvbSBKU09OXG4gICAgaWYgKGlzUmVkKSB7XG4gICAgICB0aGlzLnguZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgICAgdGhpcy55LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLngucmVkKVxuICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMueS5yZWQpXG4gICAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuaW5mID0gZmFsc2U7XG4gIH1cbn1cbmluaGVyaXRzX2Jyb3dzZXIoUG9pbnQsIGJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpLFxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKSxcbiAgICB9LFxuICAgIG5hZjogdGhpcy5wcmVjb21wdXRlZC5uYWYgJiYge1xuICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKSxcbiAgICB9LFxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgfSxcbiAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLm5hZi5wb2ludHMubWFwKG9iajJwb2ludCkpLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IEJOKGssIDE2KTtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBlbHNlIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKSxcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIGJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHNfYnJvd3NlcihKUG9pbnQsIGJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHopIHtcbiAgcmV0dXJuIG5ldyBKUG9pbnQodGhpcywgeCwgeSwgeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRvUCA9IGZ1bmN0aW9uIHRvUCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciB6aW52ID0gdGhpcy56LnJlZEludm0oKTtcbiAgdmFyIHppbnYyID0gemludi5yZWRTcXIoKTtcbiAgdmFyIGF4ID0gdGhpcy54LnJlZE11bCh6aW52Mik7XG4gIHZhciBheSA9IHRoaXMueS5yZWRNdWwoemludjIpLnJlZE11bCh6aW52KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChheCwgYXkpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSwgdGhpcy56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDEyTSArIDRTICsgN0FcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6Mik7XG4gIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICB2YXIgczEgPSB0aGlzLnkucmVkTXVsKHB6Mi5yZWRNdWwocC56KSk7XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIucmVkTXVsKHRoaXMueikpO1xuXG4gIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG4gICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gIHZhciBoMyA9IGgyLnJlZE11bChoKTtcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKHAueikucmVkTXVsKGgpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBmdW5jdGlvbiBtaXhlZEFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHAudG9KKCk7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyA4TSArIDNTICsgN0FcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgdTEgPSB0aGlzLng7XG4gIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuICB2YXIgczEgPSB0aGlzLnk7XG4gIHZhciBzMiA9IHAueS5yZWRNdWwoejIpLnJlZE11bCh0aGlzLnopO1xuXG4gIHZhciBoID0gdTEucmVkU3ViKHUyKTtcbiAgdmFyIHIgPSBzMS5yZWRTdWIoczIpO1xuICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG4gICAgaWYgKHIuY21wbigwKSAhPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpcy5kYmwoKTtcbiAgfVxuXG4gIHZhciBoMiA9IGgucmVkU3FyKCk7XG4gIHZhciBoMyA9IGgyLnJlZE11bChoKTtcbiAgdmFyIHYgPSB1MS5yZWRNdWwoaDIpO1xuXG4gIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuICB2YXIgbnogPSB0aGlzLnoucmVkTXVsKGgpO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZGJscCA9IGZ1bmN0aW9uIGRibHAocG93KSB7XG4gIGlmIChwb3cgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgaWYgKCFwb3cpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgdmFyIGk7XG4gIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwb3c7IGkrKylcbiAgICAgIHIgPSByLmRibCgpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLy8gMU0gKyAyUyArIDFBICsgTiAqICg0UyArIDVNICsgOEEpXG4gIC8vIE4gPSAxID0+IDZNICsgNlMgKyA5QVxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcbiAgdmFyIHRpbnYgPSB0aGlzLmN1cnZlLnRpbnY7XG5cbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIC8vIFJldXNlIHJlc3VsdHNcbiAgdmFyIGp5ZCA9IGp5LnJlZEFkZChqeSk7XG4gIGZvciAoaSA9IDA7IGkgPCBwb3c7IGkrKykge1xuICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgICB2YXIganlkMiA9IGp5ZC5yZWRTcXIoKTtcbiAgICB2YXIganlkNCA9IGp5ZDIucmVkU3FyKCk7XG4gICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgICB2YXIgdDEgPSBqeC5yZWRNdWwoanlkMik7XG4gICAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICAgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuICAgIHZhciBkbnkgPSBjLnJlZE11bCh0Mik7XG4gICAgZG55ID0gZG55LnJlZElBZGQoZG55KS5yZWRJU3ViKGp5ZDQpO1xuICAgIHZhciBueiA9IGp5ZC5yZWRNdWwoanopO1xuICAgIGlmIChpICsgMSA8IHBvdylcbiAgICAgIGp6NCA9IGp6NC5yZWRNdWwoanlkNCk7XG5cbiAgICBqeCA9IG54O1xuICAgIGp6ID0gbno7XG4gICAganlkID0gZG55O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KGp4LCBqeWQucmVkTXVsKHRpbnYpLCBqeik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGlmICh0aGlzLmN1cnZlLnplcm9BKVxuICAgIHJldHVybiB0aGlzLl96ZXJvRGJsKCk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUudGhyZWVBKVxuICAgIHJldHVybiB0aGlzLl90aHJlZURibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX2RibCgpO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5femVyb0RibCA9IGZ1bmN0aW9uIF96ZXJvRGJsKCkge1xuICB2YXIgbng7XG4gIHZhciBueTtcbiAgdmFyIG56O1xuICAvLyBaID0gMVxuICBpZiAodGhpcy56T25lKSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLW1kYmwtMjAwNy1ibFxuICAgIC8vIDFNICsgNVMgKyAxNEFcblxuICAgIC8vIFhYID0gWDFeMlxuICAgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgICAvLyBZWSA9IFkxXjJcbiAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gWVlZWSA9IFlZXjJcbiAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuICAgIHZhciBzID0gdGhpcy54LnJlZEFkZCh5eSkucmVkU3FyKCkucmVkSVN1Yih4eCkucmVkSVN1Yih5eXl5KTtcbiAgICBzID0gcy5yZWRJQWRkKHMpO1xuICAgIC8vIE0gPSAzICogWFggKyBhOyBhID0gMFxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgICAvLyBUID0gTSBeIDIgLSAyKlNcbiAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXG4gICAgLy8gOCAqIFlZWVlcbiAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcbiAgICAvLyBaMyA9IDIqWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctZGJsLTIwMDktbFxuICAgIC8vIDJNICsgNVMgKyAxM0FcblxuICAgIC8vIEEgPSBYMV4yXG4gICAgdmFyIGEgPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gQiA9IFkxXjJcbiAgICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBDID0gQl4yXG4gICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuICAgIC8vIEQgPSAyICogKChYMSArIEIpXjIgLSBBIC0gQylcbiAgICB2YXIgZCA9IHRoaXMueC5yZWRBZGQoYikucmVkU3FyKCkucmVkSVN1YihhKS5yZWRJU3ViKGMpO1xuICAgIGQgPSBkLnJlZElBZGQoZCk7XG4gICAgLy8gRSA9IDMgKiBBXG4gICAgdmFyIGUgPSBhLnJlZEFkZChhKS5yZWRJQWRkKGEpO1xuICAgIC8vIEYgPSBFXjJcbiAgICB2YXIgZiA9IGUucmVkU3FyKCk7XG5cbiAgICAvLyA4ICogQ1xuICAgIHZhciBjOCA9IGMucmVkSUFkZChjKTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cbiAgICAvLyBYMyA9IEYgLSAyICogRFxuICAgIG54ID0gZi5yZWRJU3ViKGQpLnJlZElTdWIoZCk7XG4gICAgLy8gWTMgPSBFICogKEQgLSBYMykgLSA4ICogQ1xuICAgIG55ID0gZS5yZWRNdWwoZC5yZWRJU3ViKG54KSkucmVkSVN1YihjOCk7XG4gICAgLy8gWjMgPSAyICogWTEgKiBaMVxuICAgIG56ID0gdGhpcy55LnJlZE11bCh0aGlzLnopO1xuICAgIG56ID0gbnoucmVkSUFkZChueik7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLl90aHJlZURibCA9IGZ1bmN0aW9uIF90aHJlZURibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMy5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTVBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYVxuICAgIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KS5yZWRJQWRkKHRoaXMuY3VydmUuYSk7XG4gICAgLy8gVCA9IE1eMiAtIDIgKiBTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcbiAgICAvLyBYMyA9IFRcbiAgICBueCA9IHQ7XG4gICAgLy8gWTMgPSBNICogKFMgLSBUKSAtIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyICogWTFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy55KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbCNkb3VibGluZy1kYmwtMjAwMS1iXG4gICAgLy8gM00gKyA1U1xuXG4gICAgLy8gZGVsdGEgPSBaMV4yXG4gICAgdmFyIGRlbHRhID0gdGhpcy56LnJlZFNxcigpO1xuICAgIC8vIGdhbW1hID0gWTFeMlxuICAgIHZhciBnYW1tYSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBiZXRhID0gWDEgKiBnYW1tYVxuICAgIHZhciBiZXRhID0gdGhpcy54LnJlZE11bChnYW1tYSk7XG4gICAgLy8gYWxwaGEgPSAzICogKFgxIC0gZGVsdGEpICogKFgxICsgZGVsdGEpXG4gICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcbiAgICBhbHBoYSA9IGFscGhhLnJlZEFkZChhbHBoYSkucmVkSUFkZChhbHBoYSk7XG4gICAgLy8gWDMgPSBhbHBoYV4yIC0gOCAqIGJldGFcbiAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG4gICAgYmV0YTQgPSBiZXRhNC5yZWRJQWRkKGJldGE0KTtcbiAgICB2YXIgYmV0YTggPSBiZXRhNC5yZWRBZGQoYmV0YTQpO1xuICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG4gICAgLy8gWjMgPSAoWTEgKyBaMSleMiAtIGdhbW1hIC0gZGVsdGFcbiAgICBueiA9IHRoaXMueS5yZWRBZGQodGhpcy56KS5yZWRTcXIoKS5yZWRJU3ViKGdhbW1hKS5yZWRJU3ViKGRlbHRhKTtcbiAgICAvLyBZMyA9IGFscGhhICogKDQgKiBiZXRhIC0gWDMpIC0gOCAqIGdhbW1hXjJcbiAgICB2YXIgZ2dhbW1hOCA9IGdhbW1hLnJlZFNxcigpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIG55ID0gYWxwaGEucmVkTXVsKGJldGE0LnJlZElTdWIobngpKS5yZWRJU3ViKGdnYW1tYTgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24gX2RibCgpIHtcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgLy8gNE0gKyA2UyArIDEwQVxuICB2YXIganggPSB0aGlzLng7XG4gIHZhciBqeSA9IHRoaXMueTtcbiAgdmFyIGp6ID0gdGhpcy56O1xuICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cbiAgdmFyIGp4MiA9IGp4LnJlZFNxcigpO1xuICB2YXIgankyID0gankucmVkU3FyKCk7XG5cbiAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cbiAgdmFyIGp4ZDQgPSBqeC5yZWRBZGQoangpO1xuICBqeGQ0ID0ganhkNC5yZWRJQWRkKGp4ZDQpO1xuICB2YXIgdDEgPSBqeGQ0LnJlZE11bChqeTIpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodDEucmVkQWRkKHQxKSk7XG4gIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXG4gIHZhciBqeWQ4ID0gankyLnJlZFNxcigpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0MikucmVkSVN1YihqeWQ4KTtcbiAgdmFyIG56ID0gankucmVkQWRkKGp5KS5yZWRNdWwoanopO1xuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUudHJwbCA9IGZ1bmN0aW9uIHRycGwoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKS5hZGQodGhpcyk7XG5cbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWwjdHJpcGxpbmctdHBsLTIwMDctYmxcbiAgLy8gNU0gKyAxMFMgKyAuLi5cblxuICAvLyBYWCA9IFgxXjJcbiAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBZWSA9IFkxXjJcbiAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAvLyBaWiA9IFoxXjJcbiAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuICAvLyBZWVlZID0gWVleMlxuICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuICAvLyBNID0gMyAqIFhYICsgYSAqIFpaMjsgYSA9IDBcbiAgdmFyIG0gPSB4eC5yZWRBZGQoeHgpLnJlZElBZGQoeHgpO1xuICAvLyBNTSA9IE1eMlxuICB2YXIgbW0gPSBtLnJlZFNxcigpO1xuICAvLyBFID0gNiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSkgLSBNTVxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gIGUgPSBlLnJlZElBZGQoZSk7XG4gIGUgPSBlLnJlZEFkZChlKS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRJU3ViKG1tKTtcbiAgLy8gRUUgPSBFXjJcbiAgdmFyIGVlID0gZS5yZWRTcXIoKTtcbiAgLy8gVCA9IDE2KllZWVlcbiAgdmFyIHQgPSB5eXl5LnJlZElBZGQoeXl5eSk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIHQgPSB0LnJlZElBZGQodCk7XG4gIC8vIFUgPSAoTSArIEUpXjIgLSBNTSAtIEVFIC0gVFxuICB2YXIgdSA9IG0ucmVkSUFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKG1tKS5yZWRJU3ViKGVlKS5yZWRJU3ViKHQpO1xuICAvLyBYMyA9IDQgKiAoWDEgKiBFRSAtIDQgKiBZWSAqIFUpXG4gIHZhciB5eXU0ID0geXkucmVkTXVsKHUpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuICB2YXIgbnggPSB0aGlzLngucmVkTXVsKGVlKS5yZWRJU3ViKHl5dTQpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICBueCA9IG54LnJlZElBZGQobngpO1xuICAvLyBZMyA9IDggKiBZMSAqIChVICogKFQgLSBVKSAtIEUgKiBFRSlcbiAgdmFyIG55ID0gdGhpcy55LnJlZE11bCh1LnJlZE11bCh0LnJlZElTdWIodSkpLnJlZElTdWIoZS5yZWRNdWwoZWUpKSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIG55ID0gbnkucmVkSUFkZChueSk7XG4gIC8vIFozID0gKFoxICsgRSleMiAtIFpaIC0gRUVcbiAgdmFyIG56ID0gdGhpcy56LnJlZEFkZChlKS5yZWRTcXIoKS5yZWRJU3ViKHp6KS5yZWRJU3ViKGVlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrLCBrYmFzZSkge1xuICBrID0gbmV3IEJOKGssIGtiYXNlKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bCh0aGlzLCBrKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgIHJldHVybiB0aGlzLmVxKHAudG9KKCkpO1xuXG4gIGlmICh0aGlzID09PSBwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIC8vIHgxICogejJeMiA9PSB4MiAqIHoxXjJcbiAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuICBpZiAodGhpcy54LnJlZE11bChwejIpLnJlZElTdWIocC54LnJlZE11bCh6MikpLmNtcG4oMCkgIT09IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIHkxICogejJeMyA9PSB5MiAqIHoxXjNcbiAgdmFyIHozID0gejIucmVkTXVsKHRoaXMueik7XG4gIHZhciBwejMgPSBwejIucmVkTXVsKHAueik7XG4gIHJldHVybiB0aGlzLnkucmVkTXVsKHB6MykucmVkSVN1YihwLnkucmVkTXVsKHozKSkuY21wbigwKSA9PT0gMDtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHpzID0gdGhpcy56LnJlZFNxcigpO1xuICB2YXIgcnggPSB4LnRvUmVkKHRoaXMuY3VydmUucmVkKS5yZWRNdWwoenMpO1xuICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHhjID0geC5jbG9uZSgpO1xuICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuSlBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIEpQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBKUG9pbnQgeDogJyArIHRoaXMueC50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnoudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMuei5jbXBuKDApID09PSAwO1xufTtcblxudmFyIGN1cnZlXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZSA9IGV4cG9ydHM7XG5cbmN1cnZlLmJhc2UgPSBiYXNlO1xuY3VydmUuc2hvcnQgPSBzaG9ydF8xO1xuY3VydmUubW9udCA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKC4vbW9udCkqLyhudWxsKTtcbmN1cnZlLmVkd2FyZHMgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZSguL2Vkd2FyZHMpKi8obnVsbCk7XG59KTtcblxudmFyIGN1cnZlc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmVzID0gZXhwb3J0cztcblxuXG5cblxuXG52YXIgYXNzZXJ0ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5zaG9ydChvcHRpb25zKTtcbiAgZWxzZSBpZiAob3B0aW9ucy50eXBlID09PSAnZWR3YXJkcycpXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLmVkd2FyZHMob3B0aW9ucyk7XG4gIGVsc2VcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEubW9udChvcHRpb25zKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblxuICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcbn1cbmN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjdXJ2ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH0sXG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjI0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AyMjQnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuICBiOiAnYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjQnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjEnLFxuICAgICdiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNCcsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwNTIxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnMDAwMDAwNTEgOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUgYTJkYTcyNWIgJyArXG4gICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcbiAgICAgJzNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJyxcbiAgbjogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG4gICAgICdmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOScsXG4gIGhhc2g6IGhhc2guc2hhNTEyLFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcbiAgICAnMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgJyArXG4gICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyxcbiAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG4gICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuICAgICczZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCcsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG4gIHR5cGU6ICdtb250JyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICc3NmQwNicsXG4gIGI6ICcxJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnOScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnLFxuICBdLFxufSk7XG5cbnZhciBwcmU7XG50cnkge1xuICBwcmUgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZSguL3ByZWNvbXB1dGVkL3NlY3AyNTZrMSkqLyhudWxsKS5jcmFzaCgpO1xufSBjYXRjaCAoZSkge1xuICBwcmUgPSB1bmRlZmluZWQ7XG59XG5cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAnazI1NicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gIGE6ICcwJyxcbiAgYjogJzcnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICBoOiAnMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuXG4gIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gIGxhbWJkYTogJzUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzInLFxuICBiYXNpczogW1xuICAgIHtcbiAgICAgIGE6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICB9LFxuICBdLFxuXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4JyxcbiAgICBwcmUsXG4gIF0sXG59KTtcbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxuZnVuY3Rpb24gSG1hY0RSQkcob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuICAgIHJldHVybiBuZXcgSG1hY0RSQkcob3B0aW9ucyk7XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcbiAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cbiAgdGhpcy5vdXRMZW4gPSB0aGlzLmhhc2gub3V0U2l6ZTtcbiAgdGhpcy5taW5FbnRyb3B5ID0gb3B0aW9ucy5taW5FbnRyb3B5IHx8IHRoaXMuaGFzaC5obWFjU3RyZW5ndGg7XG5cbiAgdGhpcy5fcmVzZWVkID0gbnVsbDtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IG51bGw7XG4gIHRoaXMuSyA9IG51bGw7XG4gIHRoaXMuViA9IG51bGw7XG5cbiAgdmFyIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5lbnRyb3B5LCBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ2hleCcpO1xuICB2YXIgbm9uY2UgPSB1dGlsc18xLnRvQXJyYXkob3B0aW9ucy5ub25jZSwgb3B0aW9ucy5ub25jZUVuYyB8fCAnaGV4Jyk7XG4gIHZhciBwZXJzID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMucGVycywgb3B0aW9ucy5wZXJzRW5jIHx8ICdoZXgnKTtcbiAgbWluaW1hbGlzdGljQXNzZXJ0KGVudHJvcHkubGVuZ3RoID49ICh0aGlzLm1pbkVudHJvcHkgLyA4KSxcbiAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcbiAgdGhpcy5faW5pdChlbnRyb3B5LCBub25jZSwgcGVycyk7XG59XG52YXIgaG1hY0RyYmcgPSBIbWFjRFJCRztcblxuSG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuICB2YXIgc2VlZCA9IGVudHJvcHkuY29uY2F0KG5vbmNlKS5jb25jYXQocGVycyk7XG5cbiAgdGhpcy5LID0gbmV3IEFycmF5KHRoaXMub3V0TGVuIC8gOCk7XG4gIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuVi5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuS1tpXSA9IDB4MDA7XG4gICAgdGhpcy5WW2ldID0gMHgwMTtcbiAgfVxuXG4gIHRoaXMuX3VwZGF0ZShzZWVkKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbiAgdGhpcy5yZXNlZWRJbnRlcnZhbCA9IDB4MTAwMDAwMDAwMDAwMDsgIC8vIDJeNDhcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG4gIHJldHVybiBuZXcgaGFzaC5obWFjKHRoaXMuaGFzaCwgdGhpcy5LKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNlZWQpIHtcbiAgdmFyIGttYWMgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAwIF0pO1xuICBpZiAoc2VlZClcbiAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG4gIHRoaXMuSyA9IGttYWMuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgaWYgKCFzZWVkKVxuICAgIHJldHVybjtcblxuICB0aGlzLksgPSB0aGlzLl9obWFjKClcbiAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDEgXSlcbiAgICAgICAgICAgICAgIC51cGRhdGUoc2VlZClcbiAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcbiAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuICAvLyBPcHRpb25hbCBlbnRyb3B5IGVuY1xuICBpZiAodHlwZW9mIGVudHJvcHlFbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVudHJvcHlFbmM7XG4gICAgZW50cm9weUVuYyA9IG51bGw7XG4gIH1cblxuICBlbnRyb3B5ID0gdXRpbHNfMS50b0FycmF5KGVudHJvcHksIGVudHJvcHlFbmMpO1xuICBhZGQgPSB1dGlsc18xLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuXG4gIG1pbmltYWxpc3RpY0Fzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG5cbiAgdGhpcy5fdXBkYXRlKGVudHJvcHkuY29uY2F0KGFkZCB8fCBbXSkpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG4gIGlmICh0aGlzLl9yZXNlZWQgPiB0aGlzLnJlc2VlZEludGVydmFsKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVzZWVkIGlzIHJlcXVpcmVkJyk7XG5cbiAgLy8gT3B0aW9uYWwgZW5jb2RpbmdcbiAgaWYgKHR5cGVvZiBlbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG5cbiAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhXG4gIGlmIChhZGQpIHtcbiAgICBhZGQgPSB1dGlsc18xLnRvQXJyYXkoYWRkLCBhZGRFbmMgfHwgJ2hleCcpO1xuICAgIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB9XG5cbiAgdmFyIHRlbXAgPSBbXTtcbiAgd2hpbGUgKHRlbXAubGVuZ3RoIDwgbGVuKSB7XG4gICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuICAgIHRlbXAgPSB0ZW1wLmNvbmNhdCh0aGlzLlYpO1xuICB9XG5cbiAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcbiAgdGhpcy5fdXBkYXRlKGFkZCk7XG4gIHRoaXMuX3Jlc2VlZCsrO1xuICByZXR1cm4gdXRpbHNfMS5lbmNvZGUocmVzLCBlbmMpO1xufTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxudmFyIGFzc2VydCQzID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gS2V5UGFpcihlYywgb3B0aW9ucykge1xuICB0aGlzLmVjID0gZWM7XG4gIHRoaXMucHJpdiA9IG51bGw7XG4gIHRoaXMucHViID0gbnVsbDtcblxuICAvLyBLZXlQYWlyKGVjLCB7IHByaXY6IC4uLiwgcHViOiAuLi4gfSlcbiAgaWYgKG9wdGlvbnMucHJpdilcbiAgICB0aGlzLl9pbXBvcnRQcml2YXRlKG9wdGlvbnMucHJpdiwgb3B0aW9ucy5wcml2RW5jKTtcbiAgaWYgKG9wdGlvbnMucHViKVxuICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xufVxudmFyIGtleSA9IEtleVBhaXI7XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHViOiBwdWIsXG4gICAgcHViRW5jOiBlbmMsXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jLFxuICB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHZhciBwdWIgPSB0aGlzLmdldFB1YmxpYygpO1xuXG4gIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcbiAgaWYgKCFwdWIudmFsaWRhdGUoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSAqIE4gIT0gTycgfTtcblxuICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGNvbXBhY3QsIGVuYykge1xuICAvLyBjb21wYWN0IGlzIG9wdGlvbmFsIGFyZ3VtZW50XG4gIGlmICh0eXBlb2YgY29tcGFjdCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBjb21wYWN0O1xuICAgIGNvbXBhY3QgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLnB1YilcbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcblxuICBpZiAoIWVuYylcbiAgICByZXR1cm4gdGhpcy5wdWI7XG5cbiAgcmV0dXJuIHRoaXMucHViLmVuY29kZShlbmMsIGNvbXBhY3QpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHJpdmF0ZSA9IGZ1bmN0aW9uIGdldFByaXZhdGUoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMucHJpdjtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24gX2ltcG9ydFByaXZhdGUoa2V5LCBlbmMpIHtcbiAgdGhpcy5wcml2ID0gbmV3IEJOKGtleSwgZW5jIHx8IDE2KTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJpdiB3b24ndCBiZSBiaWdnZXIgdGhhbiBuLCBvdGhlcndpc2Ugd2UgbWF5IGZhaWxcbiAgLy8gaW4gZml4ZWQgbXVsdGlwbGljYXRpb24gbWV0aG9kXG4gIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHVibGljID0gZnVuY3Rpb24gX2ltcG9ydFB1YmxpYyhrZXksIGVuYykge1xuICBpZiAoa2V5LnggfHwga2V5LnkpIHtcbiAgICAvLyBNb250Z29tZXJ5IHBvaW50cyBvbmx5IGhhdmUgYW4gYHhgIGNvb3JkaW5hdGUuXG4gICAgLy8gV2VpZXJzdHJhc3MvRWR3YXJkcyBwb2ludHMgb24gdGhlIG90aGVyIGhhbmQgaGF2ZSBib3RoIGB4YCBhbmRcbiAgICAvLyBgeWAgY29vcmRpbmF0ZXMuXG4gICAgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ21vbnQnKSB7XG4gICAgICBhc3NlcnQkMyhrZXkueCwgJ05lZWQgeCBjb29yZGluYXRlJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdzaG9ydCcgfHxcbiAgICAgICAgICAgICAgIHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ2Vkd2FyZHMnKSB7XG4gICAgICBhc3NlcnQkMyhrZXkueCAmJiBrZXkueSwgJ05lZWQgYm90aCB4IGFuZCB5IGNvb3JkaW5hdGUnKTtcbiAgICB9XG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLnBvaW50KGtleS54LCBrZXkueSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5kZWNvZGVQb2ludChrZXksIGVuYyk7XG59O1xuXG4vLyBFQ0RIXG5LZXlQYWlyLnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiBkZXJpdmUocHViKSB7XG4gIGlmKCFwdWIudmFsaWRhdGUoKSkge1xuICAgIGFzc2VydCQzKHB1Yi52YWxpZGF0ZSgpLCAncHVibGljIHBvaW50IG5vdCB2YWxpZGF0ZWQnKTtcbiAgfVxuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxudmFyIGFzc2VydCQ0ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuZnVuY3Rpb24gU2lnbmF0dXJlKG9wdGlvbnMsIGVuYykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIFNpZ25hdHVyZSlcbiAgICByZXR1cm4gb3B0aW9ucztcblxuICBpZiAodGhpcy5faW1wb3J0REVSKG9wdGlvbnMsIGVuYykpXG4gICAgcmV0dXJuO1xuXG4gIGFzc2VydCQ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IEJOKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgQk4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xufVxudmFyIHNpZ25hdHVyZSA9IFNpZ25hdHVyZTtcblxuZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gIHRoaXMucGxhY2UgPSAwO1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGgoYnVmLCBwKSB7XG4gIHZhciBpbml0aWFsID0gYnVmW3AucGxhY2UrK107XG4gIGlmICghKGluaXRpYWwgJiAweDgwKSkge1xuICAgIHJldHVybiBpbml0aWFsO1xuICB9XG4gIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG5cbiAgLy8gSW5kZWZpbml0ZSBsZW5ndGggb3Igb3ZlcmZsb3dcbiAgaWYgKG9jdGV0TGVuID09PSAwIHx8IG9jdGV0TGVuID4gNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB2YWwgPSAwO1xuICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG4gICAgdmFsIDw8PSA4O1xuICAgIHZhbCB8PSBidWZbb2ZmXTtcbiAgICB2YWwgPj4+PSAwO1xuICB9XG5cbiAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgaWYgKHZhbCA8PSAweDdmKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcC5wbGFjZSA9IG9mZjtcbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zikge1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKCFidWZbaV0gJiYgIShidWZbaSArIDFdICYgMHg4MCkgJiYgaSA8IGxlbikge1xuICAgIGkrKztcbiAgfVxuICBpZiAoaSA9PT0gMCkge1xuICAgIHJldHVybiBidWY7XG4gIH1cbiAgcmV0dXJuIGJ1Zi5zbGljZShpKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS5faW1wb3J0REVSID0gZnVuY3Rpb24gX2ltcG9ydERFUihkYXRhLCBlbmMpIHtcbiAgZGF0YSA9IHV0aWxzXzEkMS50b0FycmF5KGRhdGEsIGVuYyk7XG4gIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKGxlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKChsZW4gKyBwLnBsYWNlKSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKHJsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKHNsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcbiAgaWYgKHJbMF0gPT09IDApIHtcbiAgICBpZiAoclsxXSAmIDB4ODApIHtcbiAgICAgIHIgPSByLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMZWFkaW5nIHplcm9lc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoc1swXSA9PT0gMCkge1xuICAgIGlmIChzWzFdICYgMHg4MCkge1xuICAgICAgcyA9IHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlYWRpbmcgemVyb2VzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yID0gbmV3IEJOKHIpO1xuICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA8IDB4ODApIHtcbiAgICBhcnIucHVzaChsZW4pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBhcnIucHVzaChvY3RldHMgfCAweDgwKTtcbiAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcbiAgfVxuICBhcnIucHVzaChsZW4pO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcbiAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKVxuICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHNbMF0gJiAweDgwKVxuICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cbiAgciA9IHJtUGFkZGluZyhyKTtcbiAgcyA9IHJtUGFkZGluZyhzKTtcblxuICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuICB2YXIgYXJyID0gWyAweDAyIF07XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHIubGVuZ3RoKTtcbiAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgYXJyLnB1c2goMHgwMik7XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHMubGVuZ3RoKTtcbiAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuICBjb25zdHJ1Y3RMZW5ndGgocmVzLCBiYWNrSGFsZi5sZW5ndGgpO1xuICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcbiAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUocmVzLCBlbmMpO1xufTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cbnZhciByYW5kID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoYnJvcmFuZCkqLyhmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCcpOyB9KTtcbnZhciBhc3NlcnQkNSA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cblxuXG5cbmZ1bmN0aW9uIEVDKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcbiAgICByZXR1cm4gbmV3IEVDKG9wdGlvbnMpO1xuXG4gIC8vIFNob3J0Y3V0IGBlbGxpcHRpYy5lYyhjdXJ2ZS1uYW1lKWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGFzc2VydCQ1KE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJ2ZXNfMSwgb3B0aW9ucyksXG4gICAgICAnVW5rbm93biBjdXJ2ZSAnICsgb3B0aW9ucyk7XG5cbiAgICBvcHRpb25zID0gY3VydmVzXzFbb3B0aW9uc107XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmb3IgYGVsbGlwdGljLmVjKGVsbGlwdGljLmN1cnZlcy5jdXJ2ZU5hbWUpYFxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGN1cnZlc18xLlByZXNldEN1cnZlKVxuICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG5cbiAgdGhpcy5jdXJ2ZSA9IG9wdGlvbnMuY3VydmUuY3VydmU7XG4gIHRoaXMubiA9IHRoaXMuY3VydmUubjtcbiAgdGhpcy5uaCA9IHRoaXMubi51c2hybigxKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuXG4gIC8vIFBvaW50IG9uIGN1cnZlXG4gIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcbiAgdGhpcy5nLnByZWNvbXB1dGUob3B0aW9ucy5jdXJ2ZS5uLmJpdExlbmd0aCgpICsgMSk7XG5cbiAgLy8gSGFzaCBmb3IgZnVuY3Rpb24gZm9yIERSQkdcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoIHx8IG9wdGlvbnMuY3VydmUuaGFzaDtcbn1cbnZhciBlYyA9IEVDO1xuXG5FQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IGtleSh0aGlzLCBvcHRpb25zKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuICByZXR1cm4ga2V5LmZyb21Qcml2YXRlKHRoaXMsIHByaXYsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcbiAgcmV0dXJuIGtleS5mcm9tUHVibGljKHRoaXMsIHB1YiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IGhtYWNEcmJnKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG4gICAgZW50cm9weTogb3B0aW9ucy5lbnRyb3B5IHx8IHJhbmQodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksXG4gICAgZW50cm9weUVuYzogb3B0aW9ucy5lbnRyb3B5ICYmIG9wdGlvbnMuZW50cm9weUVuYyB8fCAndXRmOCcsXG4gICAgbm9uY2U6IHRoaXMubi50b0FycmF5KCksXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gX3RydW5jYXRlVG9OKG1zZywgdHJ1bmNPbmx5KSB7XG4gIHZhciBkZWx0YSA9IG1zZy5ieXRlTGVuZ3RoKCkgKiA4IC0gdGhpcy5uLmJpdExlbmd0aCgpO1xuICBpZiAoZGVsdGEgPiAwKVxuICAgIG1zZyA9IG1zZy51c2hybihkZWx0YSk7XG4gIGlmICghdHJ1bmNPbmx5ICYmIG1zZy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBtc2cuc3ViKHRoaXMubik7XG4gIGVsc2VcbiAgICByZXR1cm4gbXNnO1xufTtcblxuRUMucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywga2V5LCBlbmMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAga2V5ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZShrZXksIGVuYyk7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG5cbiAgLy8gWmVyby1leHRlbmQga2V5IHRvIHByb3ZpZGUgZW5vdWdoIGVudHJvcHlcbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIGJrZXkgPSBrZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIG5vbmNlIHRvIGhhdmUgdGhlIHNhbWUgYnl0ZSBzaXplIGFzIE5cbiAgdmFyIG5vbmNlID0gbXNnLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBobWFjRHJiZyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIGVudHJvcHk6IGJrZXksXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IEJOKDEpKTtcblxuICBmb3IgKHZhciBpdGVyID0gMDsgOyBpdGVyKyspIHtcbiAgICB2YXIgayA9IG9wdGlvbnMuayA/XG4gICAgICBvcHRpb25zLmsoaXRlcikgOlxuICAgICAgbmV3IEJOKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcbiAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG4gICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG4gICAgLy8gVXNlIGNvbXBsZW1lbnQgb2YgYHNgLCBpZiBpdCBpcyA+IGBuIC8gMmBcbiAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG4gICAgICBzID0gdGhpcy5uLnN1YihzKTtcbiAgICAgIHJlY292ZXJ5UGFyYW0gXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUkMSwga2V5LCBlbmMpIHtcbiAgbXNnID0gdGhpcy5fdHJ1bmNhdGVUb04obmV3IEJOKG1zZywgMTYpKTtcbiAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcbiAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCAnaGV4Jyk7XG5cbiAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cbiAgdmFyIHIgPSBzaWduYXR1cmUkMS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZSQxLnM7XG4gIGlmIChyLmNtcG4oMSkgPCAwIHx8IHIuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChzLmNtcG4oMSkgPCAwIHx8IHMuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVmFsaWRhdGUgc2lnbmF0dXJlXG4gIHZhciBzaW52ID0gcy5pbnZtKHRoaXMubik7XG4gIHZhciB1MSA9IHNpbnYubXVsKG1zZykudW1vZCh0aGlzLm4pO1xuICB2YXIgdTIgPSBzaW52Lm11bChyKS51bW9kKHRoaXMubik7XG4gIHZhciBwO1xuXG4gIGlmICghdGhpcy5jdXJ2ZS5fbWF4d2VsbFRyaWNrKSB7XG4gICAgcCA9IHRoaXMuZy5tdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICAgIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBwLmdldFgoKS51bW9kKHRoaXMubikuY21wKHIpID09PSAwO1xuICB9XG5cbiAgLy8gTk9URTogR3JlZyBNYXh3ZWxsJ3MgdHJpY2ssIGluc3BpcmVkIGJ5OlxuICAvLyBodHRwczovL2dpdC5pby92YWQzS1xuXG4gIHAgPSB0aGlzLmcuam11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gQ29tcGFyZSBgcC54YCBvZiBKYWNvYmlhbiBwb2ludCB3aXRoIGByYCxcbiAgLy8gdGhpcyB3aWxsIGRvIGBwLnggPT0gciAqIHAuel4yYCBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIGBwLnhgIGJ5IHRoZVxuICAvLyBpbnZlcnNlIG9mIGBwLnpeMmBcbiAgcmV0dXJuIHAuZXFYVG9QKHIpO1xufTtcblxuRUMucHJvdG90eXBlLnJlY292ZXJQdWJLZXkgPSBmdW5jdGlvbihtc2csIHNpZ25hdHVyZSQxLCBqLCBlbmMpIHtcbiAgYXNzZXJ0JDUoKDMgJiBqKSA9PT0gaiwgJ1RoZSByZWNvdmVyeSBwYXJhbSBpcyBtb3JlIHRoYW4gdHdvIGJpdHMnKTtcbiAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZSQxLnI7XG4gIHZhciBzID0gc2lnbmF0dXJlJDEucztcblxuICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcbiAgdmFyIGlzWU9kZCA9IGogJiAxO1xuICB2YXIgaXNTZWNvbmRLZXkgPSBqID4+IDE7XG4gIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7XG5cbiAgLy8gMS4xLiBMZXQgeCA9IHIgKyBqbi5cbiAgaWYgKGlzU2Vjb25kS2V5KVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgoci5hZGQodGhpcy5jdXJ2ZS5uKSwgaXNZT2RkKTtcbiAgZWxzZVxuICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuICB2YXIgckludiA9IHNpZ25hdHVyZSQxLnIuaW52bShuKTtcbiAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG4gIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUkMSwgUSwgZW5jKSB7XG4gIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZSQxLnJlY292ZXJ5UGFyYW0gIT09IG51bGwpXG4gICAgcmV0dXJuIHNpZ25hdHVyZSQxLnJlY292ZXJ5UGFyYW07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgUXByaW1lO1xuICAgIHRyeSB7XG4gICAgICBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlJDEsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcblxudmFyIGVsbGlwdGljXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbGxpcHRpYyA9IGV4cG9ydHM7XG5cbmVsbGlwdGljLnZlcnNpb24gPSAvKlJpY01vbzpldGhlcnMqL3sgdmVyc2lvbjogXCI2LjUuNFwiIH0udmVyc2lvbjtcbmVsbGlwdGljLnV0aWxzID0gdXRpbHNfMSQxO1xuZWxsaXB0aWMucmFuZCA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKGJyb3JhbmQpKi8oZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQnKTsgfSk7XG5lbGxpcHRpYy5jdXJ2ZSA9IGN1cnZlXzE7XG5lbGxpcHRpYy5jdXJ2ZXMgPSBjdXJ2ZXNfMTtcblxuLy8gUHJvdG9jb2xzXG5lbGxpcHRpYy5lYyA9IGVjO1xuZWxsaXB0aWMuZWRkc2EgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZSguL2VsbGlwdGljL2VkZHNhKSovKG51bGwpO1xufSk7XG5cbnZhciBFQyQxID0gZWxsaXB0aWNfMS5lYztcblxuZXhwb3J0IHsgRUMkMSBhcyBFQyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxsaXB0aWMuanMubWFwXG4iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwic2lnbmluZy1rZXkvNS42LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgRUMgfSBmcm9tIFwiLi9lbGxpcHRpY1wiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnksIGhleFplcm9QYWQsIHNwbGl0U2lnbmF0dXJlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5sZXQgX2N1cnZlID0gbnVsbDtcbmZ1bmN0aW9uIGdldEN1cnZlKCkge1xuICAgIGlmICghX2N1cnZlKSB7XG4gICAgICAgIF9jdXJ2ZSA9IG5ldyBFQyhcInNlY3AyNTZrMVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jdXJ2ZTtcbn1cbmV4cG9ydCBjbGFzcyBTaWduaW5nS2V5IHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY3VydmVcIiwgXCJzZWNwMjU2azFcIik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpdmF0ZUtleVwiLCBoZXhsaWZ5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzU2lnbmluZ0tleVwiLCB0cnVlKTtcbiAgICB9XG4gICAgX2FkZFBvaW50KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHAwID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KHRoaXMucHVibGljS2V5KSk7XG4gICAgICAgIGNvbnN0IHAxID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KG90aGVyKSk7XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBwMC5wdWIuYWRkKHAxLnB1YikuZW5jb2RlQ29tcHJlc3NlZChcImhleFwiKTtcbiAgICB9XG4gICAgc2lnbkRpZ2VzdChkaWdlc3QpIHtcbiAgICAgICAgY29uc3Qga2V5UGFpciA9IGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYXJyYXlpZnkodGhpcy5wcml2YXRlS2V5KSk7XG4gICAgICAgIGNvbnN0IGRpZ2VzdEJ5dGVzID0gYXJyYXlpZnkoZGlnZXN0KTtcbiAgICAgICAgaWYgKGRpZ2VzdEJ5dGVzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgZGlnZXN0IGxlbmd0aFwiLCBcImRpZ2VzdFwiLCBkaWdlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleVBhaXIuc2lnbihkaWdlc3RCeXRlcywgeyBjYW5vbmljYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzcGxpdFNpZ25hdHVyZSh7XG4gICAgICAgICAgICByZWNvdmVyeVBhcmFtOiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSxcbiAgICAgICAgICAgIHI6IGhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnIudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICAgICAgICBzOiBoZXhaZXJvUGFkKFwiMHhcIiArIHNpZ25hdHVyZS5zLnRvU3RyaW5nKDE2KSwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcHV0ZVNoYXJlZFNlY3JldChvdGhlcktleSkge1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3Qgb3RoZXJLZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGFycmF5aWZ5KGNvbXB1dGVQdWJsaWNLZXkob3RoZXJLZXkpKSk7XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKFwiMHhcIiArIGtleVBhaXIuZGVyaXZlKG90aGVyS2V5UGFpci5nZXRQdWJsaWMoKSkudG9TdHJpbmcoMTYpLCAzMik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1NpZ25pbmdLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25pbmdLZXkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBjb25zdCBycyA9IHsgcjogYXJyYXlpZnkoc2lnLnIpLCBzOiBhcnJheWlmeShzaWcucykgfTtcbiAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KGFycmF5aWZ5KGRpZ2VzdCksIHJzLCBzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoa2V5KTtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkoYnl0ZXMpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbmluZ0tleS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMzMpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChieXRlcy5sZW5ndGggPT09IDY1KSB7XG4gICAgICAgIGlmICghY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHB1YmxpYyBvciBwcml2YXRlIGtleVwiLCBcImtleVwiLCBcIltSRURBQ1RFRF1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleENvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhaZXJvUGFkLCBpc0J5dGVzTGlrZSwgc3BsaXRTaWduYXR1cmUsIHN0cmlwWmVyb3MsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBaZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgY2hlY2tQcm9wZXJ0aWVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCAqIGFzIFJMUCBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmxwXCI7XG5pbXBvcnQgeyBjb21wdXRlUHVibGljS2V5LCByZWNvdmVyUHVibGljS2V5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NpZ25pbmcta2V5XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgdmFyIFRyYW5zYWN0aW9uVHlwZXM7XG4oZnVuY3Rpb24gKFRyYW5zYWN0aW9uVHlwZXMpIHtcbiAgICBUcmFuc2FjdGlvblR5cGVzW1RyYW5zYWN0aW9uVHlwZXNbXCJsZWdhY3lcIl0gPSAwXSA9IFwibGVnYWN5XCI7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wiZWlwMjkzMFwiXSA9IDFdID0gXCJlaXAyOTMwXCI7XG4gICAgVHJhbnNhY3Rpb25UeXBlc1tUcmFuc2FjdGlvblR5cGVzW1wiZWlwMTU1OVwiXSA9IDJdID0gXCJlaXAxNTU5XCI7XG59KShUcmFuc2FjdGlvblR5cGVzIHx8IChUcmFuc2FjdGlvblR5cGVzID0ge30pKTtcbjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGhhbmRsZUFkZHJlc3ModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGdldEFkZHJlc3ModmFsdWUpO1xufVxuZnVuY3Rpb24gaGFuZGxlTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFplcm87XG4gICAgfVxuICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG59XG4vLyBMZWdhY3kgVHJhbnNhY3Rpb24gRmllbGRzXG5jb25zdCB0cmFuc2FjdGlvbkZpZWxkcyA9IFtcbiAgICB7IG5hbWU6IFwibm9uY2VcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJnYXNQcmljZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcImdhc0xpbWl0XCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwidG9cIiwgbGVuZ3RoOiAyMCB9LFxuICAgIHsgbmFtZTogXCJ2YWx1ZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcImRhdGFcIiB9LFxuXTtcbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHR5cGU6IHRydWUsIHZhbHVlOiB0cnVlXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGNvbXB1dGVQdWJsaWNLZXkoa2V5KTtcbiAgICByZXR1cm4gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2Uoa2VjY2FrMjU2KGhleERhdGFTbGljZShwdWJsaWNLZXksIDEpKSwgMTIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhyZWNvdmVyUHVibGljS2V5KGFycmF5aWZ5KGRpZ2VzdCksIHNpZ25hdHVyZSkpO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKHZhbHVlLCBuYW1lKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3RyaXBaZXJvcyhCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgbmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBuYW1lKSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWNjZXNzU2V0aWZ5KGFkZHIsIHN0b3JhZ2VLZXlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogZ2V0QWRkcmVzcyhhZGRyKSxcbiAgICAgICAgc3RvcmFnZUtleXM6IChzdG9yYWdlS2V5cyB8fCBbXSkubWFwKChzdG9yYWdlS2V5LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhleERhdGFMZW5ndGgoc3RvcmFnZUtleSkgIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWNjZXNzIGxpc3Qgc3RvcmFnZUtleVwiLCBgYWNjZXNzTGlzdFske2FkZHJ9OiR7aW5kZXh9XWAsIHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VLZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSlcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFjY2Vzc0xpc3RpZnkodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgoc2V0LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2V0KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYWNjZXNzIGxpc3QgZXhwZWN0ZWQgdG8gYmUgWyBhZGRyZXNzLCBzdG9yYWdlS2V5c1tdIF1cIiwgYHZhbHVlWyR7aW5kZXh9XWAsIHNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NTZXRpZnkoc2V0WzBdLCBzZXRbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXQuYWRkcmVzcywgc2V0LnN0b3JhZ2VLZXlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGFkZHIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZUtleXMgPSB2YWx1ZVthZGRyXS5yZWR1Y2UoKGFjY3VtLCBzdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgICBhY2N1bVtzdG9yYWdlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShhZGRyLCBPYmplY3Qua2V5cyhzdG9yYWdlS2V5cykuc29ydCgpKTtcbiAgICB9KTtcbiAgICByZXN1bHQuc29ydCgoYSwgYikgPT4gKGEuYWRkcmVzcy5sb2NhbGVDb21wYXJlKGIuYWRkcmVzcykpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZm9ybWF0QWNjZXNzTGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4gW3NldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXNdKTtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAxNTU5KHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBleHBsaWNpdCBnYXNQcmljZSwgbWFrZSBzdXJlIGl0IG1hdGNoZXMgdGhlXG4gICAgLy8gRUlQLTE1NTkgZmVlczsgb3RoZXJ3aXNlIHRoZXkgbWF5IG5vdCB1bmRlcnN0YW5kIHdoYXQgdGhleVxuICAgIC8vIHRoaW5rIHRoZXkgYXJlIHNldHRpbmcgaW4gdGVybXMgb2YgZmVlLlxuICAgIGlmICh0cmFuc2FjdGlvbi5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGdhc1ByaWNlID0gQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24uZ2FzUHJpY2UpO1xuICAgICAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgfHwgMCk7XG4gICAgICAgIGlmICghZ2FzUHJpY2UuZXEobWF4RmVlUGVyR2FzKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc21hdGNoIEVJUC0xNTU5IGdhc1ByaWNlICE9IG1heEZlZVBlckdhc1wiLCBcInR4XCIsIHtcbiAgICAgICAgICAgICAgICBnYXNQcmljZSwgbWF4RmVlUGVyR2FzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyB8fCAwLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzIHx8IDAsIFwibWF4RmVlUGVyR2FzXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0cmFuc2FjdGlvbi50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHJhbnNhY3Rpb24udG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0cmFuc2FjdGlvbi5kYXRhIHx8IFwiMHhcIiksXG4gICAgICAgIChmb3JtYXRBY2Nlc3NMaXN0KHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgfHwgW10pKVxuICAgIF07XG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBzaWcgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4Q29uY2F0KFtcIjB4MDJcIiwgUkxQLmVuY29kZShmaWVsZHMpXSk7XG59XG5mdW5jdGlvbiBfc2VyaWFsaXplRWlwMjkzMCh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgZmllbGRzID0gW1xuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uY2hhaW5JZCB8fCAwLCBcImNoYWluSWRcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5ub25jZSB8fCAwLCBcIm5vbmNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzUHJpY2UgfHwgMCwgXCJnYXNQcmljZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmdhc0xpbWl0IHx8IDAsIFwiZ2FzTGltaXRcIiksXG4gICAgICAgICgodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkgPyBnZXRBZGRyZXNzKHRyYW5zYWN0aW9uLnRvKSA6IFwiMHhcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi52YWx1ZSB8fCAwLCBcInZhbHVlXCIpLFxuICAgICAgICAodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuICAgICAgICAoZm9ybWF0QWNjZXNzTGlzdCh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0IHx8IFtdKSlcbiAgICBdO1xuICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgY29uc3Qgc2lnID0gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgZmllbGRzLnB1c2goZm9ybWF0TnVtYmVyKHNpZy5yZWNvdmVyeVBhcmFtLCBcInJlY292ZXJ5UGFyYW1cIikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5yKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleENvbmNhdChbXCIweDAxXCIsIFJMUC5lbmNvZGUoZmllbGRzKV0pO1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9ucyBhbmQgRUlQLTE1NVxuZnVuY3Rpb24gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzKTtcbiAgICBjb25zdCByYXcgPSBbXTtcbiAgICB0cmFuc2FjdGlvbkZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZEluZm8pIHtcbiAgICAgICAgbGV0IHZhbHVlID0gdHJhbnNhY3Rpb25bZmllbGRJbmZvLm5hbWVdIHx8IChbXSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGZpZWxkSW5mby5udW1lcmljKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhleFBhZCA9IFwibGVmdFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXJyYXlpZnkoaGV4bGlmeSh2YWx1ZSwgb3B0aW9ucykpO1xuICAgICAgICAvLyBGaXhlZC13aWR0aCBmaWVsZFxuICAgICAgICBpZiAoZmllbGRJbmZvLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IGZpZWxkSW5mby5sZW5ndGggJiYgdmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhcmlhYmxlLXdpZHRoICh3aXRoIGEgbWF4aW11bSlcbiAgICAgICAgaWYgKGZpZWxkSW5mby5tYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gc3RyaXBaZXJvcyh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gZmllbGRJbmZvLm1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByYXcucHVzaChoZXhsaWZ5KHZhbHVlKSk7XG4gICAgfSk7XG4gICAgbGV0IGNoYWluSWQgPSAwO1xuICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcbiAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbi5jaGFpbklkXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpZ25hdHVyZSAmJiAhaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSAmJiBzaWduYXR1cmUudiA+IDI4KSB7XG4gICAgICAgIC8vIE5vIGNoYWluSWQgcHJvdmlkZWQsIGJ1dCB0aGUgc2lnbmF0dXJlIGlzIHNpZ25pbmcgd2l0aCBFSVAtMTU1OyBkZXJpdmUgY2hhaW5JZFxuICAgICAgICBjaGFpbklkID0gTWF0aC5mbG9vcigoc2lnbmF0dXJlLnYgLSAzNSkgLyAyKTtcbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBhbiBFSVAtMTU1IHRyYW5zYWN0aW9uIChjaGFpbklkIHdhcyBzcGVjaWZpZWQgYW5kIG5vbi16ZXJvKVxuICAgIGlmIChjaGFpbklkICE9PSAwKSB7XG4gICAgICAgIHJhdy5wdXNoKGhleGxpZnkoY2hhaW5JZCkpOyAvLyBAVE9ETzogaGV4VmFsdWU/XG4gICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgfVxuICAgIC8vIFJlcXVlc3RpbmcgYW4gdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAoIXNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gUkxQLmVuY29kZShyYXcpO1xuICAgIH1cbiAgICAvLyBUaGUgc3BsaXRTaWduYXR1cmUgd2lsbCBlbnN1cmUgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIHJlY292ZXJ5UGFyYW0gaW4gdGhlXG4gICAgLy8gY2FzZSB0aGF0IHRoZSBzaWduVHJhbnNhY3Rpb24gZnVuY3Rpb24gb25seSBhZGRzIGEgdi5cbiAgICBjb25zdCBzaWcgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIC8vIFdlIHB1c2hlZCBhIGNoYWluSWQgYW5kIG51bGwgciwgcyBvbiBmb3IgaGFzaGluZyBvbmx5OyByZW1vdmUgdGhvc2VcbiAgICBsZXQgdiA9IDI3ICsgc2lnLnJlY292ZXJ5UGFyYW07XG4gICAgaWYgKGNoYWluSWQgIT09IDApIHtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgdiArPSBjaGFpbklkICogMiArIDg7XG4gICAgICAgIC8vIElmIGFuIEVJUC0xNTUgdiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseTsgbWF5YmUgX3ZzKSB3YXMgcHJvdmlkZWQsIGNoZWNrIGl0IVxuICAgICAgICBpZiAoc2lnLnYgPiAyOCAmJiBzaWcudiAhPT0gdikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRyYW5zYWN0aW9uLmNoYWluSWQvc2lnbmF0dXJlLnYgbWlzbWF0Y2hcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzaWcudiAhPT0gdikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgIH1cbiAgICByYXcucHVzaChoZXhsaWZ5KHYpKTtcbiAgICByYXcucHVzaChzdHJpcFplcm9zKGFycmF5aWZ5KHNpZy5yKSkpO1xuICAgIHJhdy5wdXNoKHN0cmlwWmVyb3MoYXJyYXlpZnkoc2lnLnMpKSk7XG4gICAgcmV0dXJuIFJMUC5lbmNvZGUocmF3KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIC8vIExlZ2FjeSBhbmQgRUlQLTE1NSBUcmFuc2FjdGlvbnNcbiAgICBpZiAodHJhbnNhY3Rpb24udHlwZSA9PSBudWxsIHx8IHRyYW5zYWN0aW9uLnR5cGUgPT09IDApIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVudHlwZWQgdHJhbnNhY3Rpb25zIGRvIG5vdCBzdXBwb3J0IGFjY2Vzc0xpc3Q7IGluY2x1ZGUgdHlwZTogMVwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgLy8gVHlwZWQgVHJhbnNhY3Rpb25zIChFSVAtMjcxOClcbiAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF9zZXJpYWxpemVFaXAyOTMwKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDE1NTkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3RyYW5zYWN0aW9uLnR5cGV9YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInNlcmlhbGl6ZVRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZTogdHJhbnNhY3Rpb24udHlwZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCBmaWVsZHMsIHNlcmlhbGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlY2lkID0gaGFuZGxlTnVtYmVyKGZpZWxkc1swXSkudG9OdW1iZXIoKTtcbiAgICAgICAgaWYgKHJlY2lkICE9PSAwICYmIHJlY2lkICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcmVjaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHgudiA9IHJlY2lkO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdiBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMVwiLCBcInZcIiwgZmllbGRzWzBdKTtcbiAgICB9XG4gICAgdHguciA9IGhleFplcm9QYWQoZmllbGRzWzFdLCAzMik7XG4gICAgdHgucyA9IGhleFplcm9QYWQoZmllbGRzWzJdLCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0ga2VjY2FrMjU2KHNlcmlhbGl6ZSh0eCkpO1xuICAgICAgICB0eC5mcm9tID0gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCB7IHI6IHR4LnIsIHM6IHR4LnMsIHJlY292ZXJ5UGFyYW06IHR4LnYgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gX3BhcnNlRWlwMTU1OShwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDJcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSk7XG4gICAgY29uc3QgbWF4RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzNdKTtcbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMixcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgIG1heEZlZVBlckdhczogbWF4RmVlUGVyR2FzLFxuICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzVdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls2XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzddLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzhdKSxcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0xNTU5IFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg5KSwgX3NlcmlhbGl6ZUVpcDE1NTkpO1xuICAgIHJldHVybiB0eDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUVpcDI5MzAocGF5bG9hZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShwYXlsb2FkLnNsaWNlKDEpKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA4ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gMTEpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29tcG9uZW50IGNvdW50IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwicGF5bG9hZFwiLCBoZXhsaWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgY29uc3QgdHggPSB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIGNoYWluSWQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls2XSxcbiAgICAgICAgYWNjZXNzTGlzdDogYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbls3XSlcbiAgICB9O1xuICAgIC8vIFVuc2lnbmVkIEVJUC0yOTMwIFRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gOCkge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocGF5bG9hZCk7XG4gICAgX3BhcnNlRWlwU2lnbmF0dXJlKHR4LCB0cmFuc2FjdGlvbi5zbGljZSg4KSwgX3NlcmlhbGl6ZUVpcDI5MzApO1xuICAgIHJldHVybiB0eDtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbnMgYW5kIEVJUC0xNTVcbmZ1bmN0aW9uIF9wYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gUkxQLmRlY29kZShyYXdUcmFuc2FjdGlvbik7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDYpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgbm9uY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblswXSkudG9OdW1iZXIoKSxcbiAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG4gICAgICAgIGdhc0xpbWl0OiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMl0pLFxuICAgICAgICB0bzogaGFuZGxlQWRkcmVzcyh0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuICAgICAgICBkYXRhOiB0cmFuc2FjdGlvbls1XSxcbiAgICAgICAgY2hhaW5JZDogMFxuICAgIH07XG4gICAgLy8gTGVnYWN5IHVuc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCA9PT0gNikge1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHR4LnYgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH1cbiAgICB0eC5yID0gaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls3XSwgMzIpO1xuICAgIHR4LnMgPSBoZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzhdLCAzMik7XG4gICAgaWYgKEJpZ051bWJlci5mcm9tKHR4LnIpLmlzWmVybygpICYmIEJpZ051bWJlci5mcm9tKHR4LnMpLmlzWmVybygpKSB7XG4gICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IHR4LnY7XG4gICAgICAgIHR4LnYgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gU2lnbmVkIFRyYW5zYWN0aW9uXG4gICAgICAgIHR4LmNoYWluSWQgPSBNYXRoLmZsb29yKCh0eC52IC0gMzUpIC8gMik7XG4gICAgICAgIGlmICh0eC5jaGFpbklkIDwgMCkge1xuICAgICAgICAgICAgdHguY2hhaW5JZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlY292ZXJ5UGFyYW0gPSB0eC52IC0gMjc7XG4gICAgICAgIGNvbnN0IHJhdyA9IHRyYW5zYWN0aW9uLnNsaWNlKDAsIDYpO1xuICAgICAgICBpZiAodHguY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICAgICAgcmF3LnB1c2goaGV4bGlmeSh0eC5jaGFpbklkKSk7XG4gICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgICAgIHJlY292ZXJ5UGFyYW0gLT0gdHguY2hhaW5JZCAqIDIgKyA4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IGtlY2NhazI1NihSTFAuZW5jb2RlKHJhdykpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdHguZnJvbSA9IHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgeyByOiBoZXhsaWZ5KHR4LnIpLCBzOiBoZXhsaWZ5KHR4LnMpLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHR4Lmhhc2ggPSBrZWNjYWsyNTYocmF3VHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICB0eC50eXBlID0gbnVsbDtcbiAgICByZXR1cm4gdHg7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2UocmF3VHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBwYXlsb2FkID0gYXJyYXlpZnkocmF3VHJhbnNhY3Rpb24pO1xuICAgIC8vIExlZ2FjeSBhbmQgRUlQLTE1NSBUcmFuc2FjdGlvbnNcbiAgICBpZiAocGF5bG9hZFswXSA+IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZShwYXlsb2FkKTtcbiAgICB9XG4gICAgLy8gVHlwZWQgVHJhbnNhY3Rpb24gKEVJUC0yNzE4KVxuICAgIHN3aXRjaCAocGF5bG9hZFswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3BhcnNlRWlwMjkzMChwYXlsb2FkKTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF9wYXJzZUVpcDE1NTkocGF5bG9hZCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKGB1bnN1cHBvcnRlZCB0cmFuc2FjdGlvbiB0eXBlOiAke3BheWxvYWRbMF19YCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgb3BlcmF0aW9uOiBcInBhcnNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiBwYXlsb2FkWzBdXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHRleHREYXRhKSB7XG4gICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhLnB1c2godGV4dERhdGEuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheWlmeShkYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGRhdGEgPSBhcnJheWlmeShkYXRhKTtcbiAgICBsZXQgdGV4dERhdGEgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ZXh0RGF0YSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIndlYi81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKGhyZWYsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogKG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIpLFxuICAgICAgICAgICAgaGVhZGVyczogKG9wdGlvbnMuaGVhZGVycyB8fCB7fSksXG4gICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnNraXBGZXRjaFNldHVwICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXF1ZXN0Lm1vZGUgPSBcImNvcnNcIjsgLy8gbm8tY29ycywgY29ycywgKnNhbWUtb3JpZ2luXG4gICAgICAgICAgICByZXF1ZXN0LmNhY2hlID0gXCJuby1jYWNoZVwiOyAvLyAqZGVmYXVsdCwgbm8tY2FjaGUsIHJlbG9hZCwgZm9yY2UtY2FjaGUsIG9ubHktaWYtY2FjaGVkXG4gICAgICAgICAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID0gXCJzYW1lLW9yaWdpblwiOyAvLyBpbmNsdWRlLCAqc2FtZS1vcmlnaW4sIG9taXRcbiAgICAgICAgICAgIHJlcXVlc3QucmVkaXJlY3QgPSBcImZvbGxvd1wiOyAvLyBtYW51YWwsICpmb2xsb3csIGVycm9yXG4gICAgICAgICAgICByZXF1ZXN0LnJlZmVycmVyID0gXCJjbGllbnRcIjsgLy8gbm8tcmVmZXJyZXIsICpjbGllbnRcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2goaHJlZiwgcmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB5aWVsZCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzLmZvckVhY2gpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICgocmVzcG9uc2UuaGVhZGVycykua2V5cykoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBib2R5OiBhcnJheWlmeShuZXcgVWludDhBcnJheShib2R5KSksXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXR1cmwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlY29kZSBhcyBiYXNlNjREZWNvZGUsIGVuY29kZSBhcyBiYXNlNjRFbmNvZGUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZTY0XCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBnZXRVcmwgfSBmcm9tIFwiLi9nZXR1cmxcIjtcbmZ1bmN0aW9uIHN0YWxsZXIoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBib2R5aWZ5KHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHR5cGUgJiYgKHR5cGUuc3BsaXQoXCIvXCIpWzBdID09PSBcInRleHRcIiB8fCB0eXBlLnNwbGl0KFwiO1wiKVswXS50cmltKCkgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vLyBUaGlzIEFQSSBpcyBzdGlsbCBhIHdvcmsgaW4gcHJvZ3Jlc3M7IHRoZSBmdXR1cmUgY2hhbmdlcyB3aWxsIGxpa2VseSBiZTpcbi8vIC0gQ29ubmVjdGlvbkluZm8gPT4gRmV0Y2hEYXRhUmVxdWVzdDxUID0gYW55PlxuLy8gLSBGZXRjaERhdGFSZXF1ZXN0LmJvZHk/ID0gc3RyaW5nIHwgVWludDhBcnJheSB8IHsgY29udGVudFR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSB9XG4vLyAgIC0gSWYgc3RyaW5nID0+IHRleHQvcGxhaW4sIFVpbnQ4QXJyYXkgPT4gYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtIChpZiBjb250ZW50LXR5cGUgdW5zcGVjaWZpZWQpXG4vLyAtIEZldGNoRGF0YVJlcXVlc3QucHJvY2Vzc0Z1bmMgPSAoYm9keTogVWludDhBcnJheSwgcmVzcG9uc2U6IEZldGNoRGF0YVJlc3BvbnNlKSA9PiBUXG4vLyBGb3IgdGhpcyByZWFzb24sIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGludGVybmFsIHVudGlsIHRoZSBBUEkgaXMgZmluYWxpemVkXG5leHBvcnQgZnVuY3Rpb24gX2ZldGNoRGF0YShjb25uZWN0aW9uLCBib2R5LCBwcm9jZXNzRnVuYykge1xuICAgIC8vIEhvdyBtYW55IHRpbWVzIHRvIHJldHJ5IGluIHRoZSBldmVudCBvZiBhIHRocm90dGxlXG4gICAgY29uc3QgYXR0ZW1wdExpbWl0ID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0ICE9IG51bGwpID8gY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0IDogMTI7XG4gICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KChhdHRlbXB0TGltaXQgPiAwICYmIChhdHRlbXB0TGltaXQgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIGxpbWl0XCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0XCIsIGF0dGVtcHRMaW1pdCk7XG4gICAgY29uc3QgdGhyb3R0bGVDYWxsYmFjayA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikgPyBjb25uZWN0aW9uLnRocm90dGxlQ2FsbGJhY2sgOiBudWxsKTtcbiAgICBjb25zdCB0aHJvdHRsZVNsb3RJbnRlcnZhbCA9ICgodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgKGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwpID09PSBcIm51bWJlclwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWwgOiAxMDApO1xuICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodGhyb3R0bGVTbG90SW50ZXJ2YWwgPiAwICYmICh0aHJvdHRsZVNsb3RJbnRlcnZhbCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgc2xvdCBpbnRlcnZhbFwiLCBcImNvbm5lY3Rpb24udGhyb3R0bGVTbG90SW50ZXJ2YWxcIiwgdGhyb3R0bGVTbG90SW50ZXJ2YWwpO1xuICAgIGNvbnN0IGVycm9yUGFzc1Rocm91Z2ggPSAoKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpID8gISEoY29ubmVjdGlvbi5lcnJvclBhc3NUaHJvdWdoKSA6IGZhbHNlKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgbGV0IHVybCA9IG51bGw7XG4gICAgLy8gQFRPRE86IEFsbG93IENvbm5lY3Rpb25JbmZvIHRvIG92ZXJyaWRlIHNvbWUgb2YgdGhlc2UgdmFsdWVzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIH07XG4gICAgbGV0IGFsbG93MzA0ID0gZmFsc2U7XG4gICAgbGV0IHRpbWVvdXQgPSAyICogNjAgKiAxMDAwO1xuICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVybCA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb24gPT0gbnVsbCB8fCBjb25uZWN0aW9uLnVybCA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBVUkxcIiwgXCJjb25uZWN0aW9uLnVybFwiLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgPSBjb25uZWN0aW9uLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbi50aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiBjb25uZWN0aW9uLnRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gY29ubmVjdGlvbi50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNvbm5lY3Rpb24uaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0geyBrZXk6IGtleSwgdmFsdWU6IFN0cmluZyhjb25uZWN0aW9uLmhlYWRlcnNba2V5XSkgfTtcbiAgICAgICAgICAgICAgICBpZiAoW1wiaWYtbm9uZS1tYXRjaFwiLCBcImlmLW1vZGlmaWVkLXNpbmNlXCJdLmluZGV4T2Yoa2V5LnRvTG93ZXJDYXNlKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3czMDQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLmFsbG93R3ppcCA9ICEhY29ubmVjdGlvbi5hbGxvd0d6aXA7XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnVzZXIgIT0gbnVsbCAmJiBjb25uZWN0aW9uLnBhc3N3b3JkICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh1cmwuc3Vic3RyaW5nKDAsIDYpICE9PSBcImh0dHBzOlwiICYmIGNvbm5lY3Rpb24uYWxsb3dJbnNlY3VyZUF1dGhlbnRpY2F0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYXNpYyBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyBhIHNlY3VyZSBodHRwcyB1cmxcIiwgTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcInVybFwiLCB1cmw6IHVybCwgdXNlcjogY29ubmVjdGlvbi51c2VyLCBwYXNzd29yZDogXCJbUkVEQUNURURdXCIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gY29ubmVjdGlvbi51c2VyICsgXCI6XCIgKyBjb25uZWN0aW9uLnBhc3N3b3JkO1xuICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSB7XG4gICAgICAgICAgICAgICAga2V5OiBcIkF1dGhvcml6YXRpb25cIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJCYXNpYyBcIiArIGJhc2U2NEVuY29kZSh0b1V0ZjhCeXRlcyhhdXRob3JpemF0aW9uKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24uc2tpcEZldGNoU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5za2lwRmV0Y2hTZXR1cCA9ICEhY29ubmVjdGlvbi5za2lwRmV0Y2hTZXR1cDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZURhdGEgPSBuZXcgUmVnRXhwKFwiXmRhdGE6KFthLXowLTktXSsvW2EtejAtOS1dKyk7YmFzZTY0LCguKikkXCIsIFwiaVwiKTtcbiAgICBjb25zdCBkYXRhTWF0Y2ggPSAoKHVybCkgPyB1cmwubWF0Y2gocmVEYXRhKSA6IG51bGwpO1xuICAgIGlmIChkYXRhTWF0Y2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiBcIk9LXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyBcImNvbnRlbnQtdHlwZVwiOiBkYXRhTWF0Y2hbMV0gfSxcbiAgICAgICAgICAgICAgICBib2R5OiBiYXNlNjREZWNvZGUoZGF0YU1hdGNoWzJdKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzcG9uc2UuYm9keSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShkYXRhTWF0Y2hbMV0sIGRhdGFNYXRjaFsyXSksXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib2R5KSB7XG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gXCJQT1NUXCI7XG4gICAgICAgIG9wdGlvbnMuYm9keSA9IGJvZHk7XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSB7IGtleTogXCJDb250ZW50LVR5cGVcIiwgdmFsdWU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID09IG51bGwpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSA9IHsga2V5OiBcIkNvbnRlbnQtTGVuZ3RoXCIsIHZhbHVlOiBTdHJpbmcoYm9keS5sZW5ndGgpIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmxhdEhlYWRlcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gaGVhZGVyc1trZXldO1xuICAgICAgICBmbGF0SGVhZGVyc1toZWFkZXIua2V5XSA9IGhlYWRlci52YWx1ZTtcbiAgICB9KTtcbiAgICBvcHRpb25zLmhlYWRlcnMgPSBmbGF0SGVhZGVycztcbiAgICBjb25zdCBydW5uaW5nVGltZW91dCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aW1lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgcHJvbWlzZSwgY2FuY2VsIH07XG4gICAgfSkoKTtcbiAgICBjb25zdCBydW5uaW5nRmV0Y2ggPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBhdHRlbXB0TGltaXQ7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB5aWVsZCBnZXRVcmwodXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDEgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMzAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVkaXJlY3Rpb247IGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGFic29sdXRlIGxvY2F0YWlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24gfHwgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIgJiYgbG9jYXRpb24ubWF0Y2goL15odHRwczovKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBvbmVudGlhbCBiYWNrLW9mZiB0aHJvdHRsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyeUFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyb3R0bGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IHlpZWxkIHRocm90dGxlQ2FsbGJhY2soYXR0ZW1wdCwgdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyeUFnYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGFsbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJldHJ5QWZ0ZXIpID09PSBcInN0cmluZ1wiICYmIHJldHJ5QWZ0ZXIubWF0Y2goL15bMS05XVswLTldKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSBwYXJzZUludChyZXRyeUFmdGVyKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFsbGluZyA0MjlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIoc3RhbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXJyb3IucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyByZXNwb25zZVwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxvdzMwNCAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFlcnJvclBhc3NUaHJvdWdoICYmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHksICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2Nlc3NGdW5jKGJvZHksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBwcm9jZXNzRnVuYyB0byB0cmlnZ2VyIGEgdGhyb3R0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZVJldHJ5ICYmIGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShib2R5LCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb2Nlc3NGdW5jLCBpdCBlaXRoZXIgcmV0dXJuZWQgYSBUIG9yIHRocmV3IGFib3ZlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImJvZHlcIiBpcyBub3cgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bm5pbmdUaW1lb3V0LnByb21pc2UsIHJ1bm5pbmdGZXRjaF0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLCBqc29uLCBwcm9jZXNzRnVuYykge1xuICAgIGxldCBwcm9jZXNzSnNvbkZ1bmMgPSAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHRvVXRmOFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIEpTT05cIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0LCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIElmIHdlIGhhdmUganNvbiB0byBzZW5kLCB3ZSBtdXN0XG4gICAgLy8gLSBhZGQgY29udGVudC10eXBlIG9mIGFwcGxpY2F0aW9uL2pzb24gKHVubGVzcyBhbHJlYWR5IG92ZXJyaWRkZW4pXG4gICAgLy8gLSBjb252ZXJ0IHRoZSBqc29uIHRvIGJ5dGVzXG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIGlmIChqc29uICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IHRvVXRmOEJ5dGVzKGpzb24pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb25uZWN0aW9uIHdpdGggdGhlIGNvbnRlbnQtdHlwZSBzZXQgZm9yIEpTT05cbiAgICAgICAgY29uc3QgdXBkYXRlZCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSA/ICh7IHVybDogY29ubmVjdGlvbiB9KSA6IHNoYWxsb3dDb3B5KGNvbm5lY3Rpb24pO1xuICAgICAgICBpZiAodXBkYXRlZC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcigoaykgPT4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikpLmxlbmd0aCkgIT09IDA7XG4gICAgICAgICAgICBpZiAoIWhhc0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0gc2hhbGxvd0NvcHkodXBkYXRlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uID0gdXBkYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2xsKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gc2hhbGxvd0NvcHkob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZmxvb3IgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmZsb29yID0gMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VpbGluZyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuY2VpbGluZyA9IDEwMDAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSAyNTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBjYW5jZWwgd2FzIHN1Y2Nlc3NmdWwuIFVuc3VjY2Vzc2Z1bCBjYW5jZWwgbWVhbnMgd2UncmUgYWxyZWFkeSBkb25lLlxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRyeUxpbWl0ID0gb3B0aW9ucy5yZXRyeUxpbWl0O1xuICAgICAgICBsZXQgYXR0ZW1wdCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzdWx0LCBvciBhcmUgYWxsb3dlZCBudWxsIHRoZW4gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VQb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGV4cG9uZW50aWFsIGJhY2stb2ZmICh1cCB0byAxMHMpIG91ciBuZXh0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IHJldHJ5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXRyeSBsaW1pdCByZWFjaGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dCA9IG9wdGlvbnMuaW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuZmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmNlaWxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhYnN0cmFjdC1wcm92aWRlci81LjYuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBEZXNjcmlwdGlvbiwgZGVmaW5lUmVhZE9ubHksIHJlc29sdmVQcm9wZXJ0aWVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbjtcbi8vZXhwb3J0IHR5cGUgQ2FsbFRyYW5zYWN0aW9uYWJsZSA9IHtcbi8vICAgIGNhbGwodHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uUmVxdWVzdCk6IFByb21pc2U8VHJhbnNhY3Rpb25SZXNwb25zZT47XG4vL307XG5leHBvcnQgY2xhc3MgRm9ya0V2ZW50IGV4dGVuZHMgRGVzY3JpcHRpb24ge1xuICAgIHN0YXRpYyBpc0ZvcmtFdmVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRm9ya0V2ZW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmxvY2tGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrSGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmxvY2tIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrSGFzaFwiLCBcImJsb2NrSGFzaFwiLCBibG9ja0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc0Jsb2NrRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBibG9ja0hhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBleHBpcnkpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyhoYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJoYXNoXCIsIGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIF9pc1RyYW5zYWN0aW9uRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgaGFzaDogaGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoYmVmb3JlSGFzaCwgYWZ0ZXJIYXNoLCBleHBpcnkpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyhiZWZvcmVIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJiZWZvcmVIYXNoXCIsIGJlZm9yZUhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYWZ0ZXJIYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJhZnRlckhhc2hcIiwgYWZ0ZXJIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbk9yZGVyRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuICAgICAgICAgICAgYmVmb3JlSGFzaDogYmVmb3JlSGFzaCxcbiAgICAgICAgICAgIGFmdGVySGFzaDogYWZ0ZXJIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydGVkIEFic3RyYWN0c1xuZXhwb3J0IGNsYXNzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCwgUHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1Byb3ZpZGVyXCIsIHRydWUpO1xuICAgIH1cbiAgICBnZXRGZWVEYXRhKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBibG9jaywgZ2FzUHJpY2UgfSA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9jazogdGhpcy5nZXRCbG9jayhcImxhdGVzdFwiKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogdGhpcy5nZXRHYXNQcmljZSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2h5IGlzIHRoaXMgbm93IGZhaWxpbmcgb24gQ2FsYXZlcmFzP1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IG1heEZlZVBlckdhcyA9IG51bGwsIG1heFByaW9yaXR5RmVlUGVyR2FzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChibG9jayAmJiBibG9jay5iYXNlRmVlUGVyR2FzKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gY29tcHV0ZSB0aGlzIG1vcmUgYWNjdXJhdGVseSBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIHRoZSBmb3JtdWxhIFwiY2hlY2sgaWYgdGhlIGJhc2UgZmVlIGlzIGNvcnJlY3RcIi5cbiAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTU1OVxuICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20oXCIxNTAwMDAwMDAwXCIpO1xuICAgICAgICAgICAgICAgIG1heEZlZVBlckdhcyA9IGJsb2NrLmJhc2VGZWVQZXJHYXMubXVsKDIpLmFkZChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBnYXNQcmljZSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWxpYXMgZm9yIFwib25cIlxuICAgIGFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9mZlwiXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHN0YXRpYyBpc1Byb3ZpZGVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNQcm92aWRlcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqXG4gKiB2YXIgYmFzZXggPSByZXF1aXJlKFwiYmFzZS14XCIpO1xuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgaGVhdmlseSBiYXNlZCBvbiBiYXNlLXguIFRoZSBtYWluIHJlYXNvbiB0b1xuICogZGV2aWF0ZSB3YXMgdG8gcHJldmVudCB0aGUgZGVwZW5kZW5jeSBvZiBCdWZmZXIuXG4gKlxuICogQ29udHJpYnV0b3JzOlxuICpcbiAqIGJhc2UteCBlbmNvZGluZ1xuICogRm9ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9iczU4XG4gKiBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgTWlrZSBIZWFybiBmb3IgQml0Y29pbkpcbiAqIENvcHlyaWdodCAoYykgMjAxMSBHb29nbGUgSW5jXG4gKiBQb3J0ZWQgdG8gSmF2YVNjcmlwdCBieSBTdGVmYW4gVGhvbWFzXG4gKiBNZXJnZWQgQnVmZmVyIHJlZmFjdG9yaW5ncyBmcm9tIGJhc2U1OC1uYXRpdmUgYnkgU3RlcGhlbiBQYWlyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgQml0UGF5IEluY1xuICpcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCBiYXNlLXggY29udHJpYnV0b3JzIChjKSAyMDE2XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4gKiBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICovXG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuZXhwb3J0IGNsYXNzIEJhc2VYIHtcbiAgICBjb25zdHJ1Y3RvcihhbHBoYWJldCkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFscGhhYmV0XCIsIGFscGhhYmV0KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJiYXNlXCIsIGFscGhhYmV0Lmxlbmd0aCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FscGhhYmV0TWFwXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbGVhZGVyXCIsIGFscGhhYmV0LmNoYXJBdCgwKSk7XG4gICAgICAgIC8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYWJldE1hcFthbHBoYWJldC5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaWdpdHMgPSBbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY2FycnkgPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpZ2l0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuICAgICAgICAgICAgICAgIGRpZ2l0c1tqXSA9IGNhcnJ5ICUgdGhpcy5iYXNlO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2FycnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGlnaXRzLnB1c2goY2FycnkgJSB0aGlzLmJhc2UpO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0cmluZyA9IFwiXCI7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBzb3VyY2Vba10gPT09IDAgJiYgayA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2spIHtcbiAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLl9sZWFkZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udmVydCBkaWdpdHMgdG8gYSBzdHJpbmdcbiAgICAgICAgZm9yIChsZXQgcSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBxID49IDA7IC0tcSkge1xuICAgICAgICAgICAgc3RyaW5nICs9IHRoaXMuYWxwaGFiZXRbZGlnaXRzW3FdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICBkZWNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IFtdO1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBieXRlID0gdGhpcy5fYWxwaGFiZXRNYXBbdmFsdWVbaV1dO1xuICAgICAgICAgICAgaWYgKGJ5dGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1iYXNlXCIgKyB0aGlzLmJhc2UgKyBcIiBjaGFyYWN0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY2FycnkgPSBieXRlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNhcnJ5ICs9IGJ5dGVzW2pdICogdGhpcy5iYXNlO1xuICAgICAgICAgICAgICAgIGJ5dGVzW2pdID0gY2FycnkgJiAweGZmO1xuICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgdmFsdWVba10gPT09IHRoaXMuX2xlYWRlciAmJiBrIDwgdmFsdWUubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheWlmeShuZXcgVWludDhBcnJheShieXRlcy5yZXZlcnNlKCkpKTtcbiAgICB9XG59XG5jb25zdCBCYXNlMzIgPSBuZXcgQmFzZVgoXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2N1wiKTtcbmNvbnN0IEJhc2U1OCA9IG5ldyBCYXNlWChcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIik7XG5leHBvcnQgeyBCYXNlMzIsIEJhc2U1OCB9O1xuLy9jb25zb2xlLmxvZyhCYXNlNTguZGVjb2RlKFwiUW1kMlY3NzdvNVh2SmJZTWVNYjhrMm5VNWY4ZDNjaVVRNVlwWXVXaHp2OGlEalwiKSlcbi8vY29uc29sZS5sb2coQmFzZTU4LmVuY29kZShCYXNlNTguZGVjb2RlKFwiUW1kMlY3NzdvNVh2SmJZTWVNYjhrMm5VNWY4ZDNjaVVRNVlwWXVXaHp2OGlEalwiKSkpXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgSGFzaFplcm8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgdG9VdGY4Q29kZVBvaW50cywgX3RvVXRmOFN0cmluZywgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtIH0gZnJvbSBcIi4vdXRmOFwiO1xuZnVuY3Rpb24gYnl0ZXMyKGRhdGEpIHtcbiAgICBpZiAoKGRhdGEubGVuZ3RoICUgNCkgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGRhdGFcIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoZGF0YS5zdWJzdHJpbmcoaSwgaSArIDQpLCAxNikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlVGFibGUoZGF0YSwgZnVuYykge1xuICAgIGlmICghZnVuYykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBbcGFyc2VJbnQodmFsdWUsIDE2KV07IH07XG4gICAgfVxuICAgIGxldCBsbyA9IDA7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGRhdGEuc3BsaXQoXCIsXCIpLmZvckVhY2goKHBhaXIpID0+IHtcbiAgICAgICAgbGV0IGNvbXBzID0gcGFpci5zcGxpdChcIjpcIik7XG4gICAgICAgIGxvICs9IHBhcnNlSW50KGNvbXBzWzBdLCAxNik7XG4gICAgICAgIHJlc3VsdFtsb10gPSBmdW5jKGNvbXBzWzFdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmFuZ2VUYWJsZShkYXRhKSB7XG4gICAgbGV0IGhpID0gMDtcbiAgICByZXR1cm4gZGF0YS5zcGxpdChcIixcIikubWFwKCh2KSA9PiB7XG4gICAgICAgIGxldCBjb21wcyA9IHYuc3BsaXQoXCItXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBjb21wc1sxXSA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBzWzFdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBjb21wc1sxXSA9IFwiMVwiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsbyA9IGhpICsgcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcbiAgICAgICAgaGkgPSBwYXJzZUludChjb21wc1sxXSwgMTYpO1xuICAgICAgICByZXR1cm4geyBsOiBsbywgaDogaGkgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG1hdGNoTWFwKHZhbHVlLCByYW5nZXMpIHtcbiAgICBsZXQgbG8gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbG8gKz0gcmFuZ2UubDtcbiAgICAgICAgaWYgKHZhbHVlID49IGxvICYmIHZhbHVlIDw9IGxvICsgcmFuZ2UuaCAmJiAoKHZhbHVlIC0gbG8pICUgKHJhbmdlLmQgfHwgMSkpID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2UuZSAmJiByYW5nZS5lLmluZGV4T2YodmFsdWUgLSBsbykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBUYWJsZV9BXzFfcmFuZ2VzID0gY3JlYXRlUmFuZ2VUYWJsZShcIjIyMSwxMy0xYiw1Zi0sNDAtMTAsNTEtZiwxMS0zLDMtMywyLTIsMi00LDgsMiwxNSwyZCwyOC04LDg4LDQ4LDI3LSwzLTUsMTEtMjAsMjctLDgsMjgsMy01LDEyLDE4LGItYSwxYy00LDYtMTYsMi1kLDItMiwyLDFiLTQsMTctOSw4Zi0sMTAsZiwxZi0yLDFjLTM0LDMzLTE0ZSw0LDM2LSwxMy0sNi0yLDFhLWYsNCw5LSwzLSwxNyw4LDItMiw1LSwyLDgtLDMtLDQtOCwyLTMsMyw2LSwxNi02LDItLDctMywzLSwxNyw4LDMsMywzLSwyLDYtMywzLSw0LWEsNSwyLTYsMTAtYiw0LDgsMiw0LDE3LDgsMyw2LSxiLDQsNC0sMi1lLDItNCxiLTEwLDQsOS0sMy0sMTcsOCwzLSw1LSw5LTIsMy0sNC03LDMtMywzLDQtMyxjLTEwLDMsNy0yLDQsNS0yLDMsMiwzLTIsMy0yLDQtMiw5LDQtMyw2LTIsNCw1LTgsMi1lLGQtZCw0LDksNCwxOCxiLDYtMyw4LDQsNS02LDMtOCwzLTMsYi0xMSwzLDksNCwxOCxiLDYtMyw4LDQsNS02LDMtNiwyLDMtMyxiLTExLDMsOSw0LDE4LDExLTMsNy0sNCw1LTgsMi03LDMtMyxiLTExLDMsMTMtMiwxOSxhLDItLDgtMiwyLTMsNywyLDktMTEsNC1iLDNiLTMsMWUtMjQsMywyLSwzLDItLDItNSw1LDgsNCwyLDItLDMsZSw0LSw2LDIsNy0sYi0sMy0yMSw0OSwyMy01LDFjLTMsOSwyNSwxMC0sMi0yZiwyMyw2LDMsOC0yLDUtNSwxYi00NSwyNy05LDJhLSwyLTMsNWItNCw0NS00LDUzLTUsOCw0MCwyLDUtLDgsMiw1LSwyOCwyLDUtLDIwLDIsNS0sOCwyLDUtLDgsOCwxOCwyMCwyLDUtLDgsMjgsMTQtNSwxZC0yMiw1Ni1iLDI3Ny04LDFlLTIsNTItZSxlLDgtYSwxOC04LDE1LWIsZSw0LDMtYiw1ZS0yLGItMTUsMTAsYi01LDU5LTcsMmItNTU1LDlkLTMsNWItNSwxNy0sNy0sMjctLDctLDksMiwyLDIsMjAtLDM2LDEwLGYtLDcsMTQtLDQsYSw1NC0zLDItNiw2LTUsOS0sMWMtMTAsMTMtMWQsMWMtMTQsM2MtLDEwLTYsMzItYiwyNDAtMzAsMjgtMTgsYy0xNCxhMCwxMTUtLDMsNjYtLGItNzYsNSw1LSwxZCwyNCwyLDUtMiwyLDgtLDM1LTIsMTksZi0xMCwxZC0zLDMxMS0zN2YsMWIsNWEtYixkNy0xOSxkLTMsNDEsNTctLDY4LTQsMjktMyw1ZiwyOS0zNywyZS0yLDI1LWMsMmMtMiw0ZS0zLDMwLDc4LTMsNjQtLDIwLDE5YjctNDksNTFhNy01OSw0OGUtMiwzOC03MzgsMmJhNS01YiwyMjJmLSwzYy05NCw4LWIsNi00LDFiLDYsMiwzLDMsNmQtMjAsMTZlLWYsNDEtLDM3LTcsMmUtMiwxMS1mLDUtYiwxOC0sYiwxNCw1LTMsNiw4OC0sMixiZi0yLDctLDctLDctLDQtMiw4LDgtOSw4LTJmZiwyMCw1LWIsMWMtYjQsMjctLDI3LWNiYjEsZjctOSwyOC0yLGI1LTIyMSw1Niw0OCwzLSwyLSwzLSw1LGQsMiw1LDMsNDIsNS0sOSw4LDFkLDUsNiwyLTIsOCwxNTMtMywxMjMtMywzMy0yN2ZkLGE2ZGEtNTEyOCwyMWYtNWRmLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMywyLTFkLDYxLWZmN2RcIik7XG4vLyBAVE9ETzogTWFrZSB0aGlzIHJlbGF0aXZlLi4uXG5jb25zdCBUYWJsZV9CXzFfZmxhZ3MgPSBcImFkLDM0ZiwxODA2LDE4MGIsMTgwYywxODBkLDIwMGIsMjAwYywyMDBkLDIwNjAsZmVmZlwiLnNwbGl0KFwiLFwiKS5tYXAoKHYpID0+IHBhcnNlSW50KHYsIDE2KSk7XG5jb25zdCBUYWJsZV9CXzJfcmFuZ2VzID0gW1xuICAgIHsgaDogMjUsIHM6IDMyLCBsOiA2NSB9LFxuICAgIHsgaDogMzAsIHM6IDMyLCBlOiBbMjNdLCBsOiAxMjcgfSxcbiAgICB7IGg6IDU0LCBzOiAxLCBlOiBbNDhdLCBsOiA2NCwgZDogMiB9LFxuICAgIHsgaDogMTQsIHM6IDEsIGw6IDU3LCBkOiAyIH0sXG4gICAgeyBoOiA0NCwgczogMSwgbDogMTcsIGQ6IDIgfSxcbiAgICB7IGg6IDEwLCBzOiAxLCBlOiBbMiwgNiwgOF0sIGw6IDYxLCBkOiAyIH0sXG4gICAgeyBoOiAxNiwgczogMSwgbDogNjgsIGQ6IDIgfSxcbiAgICB7IGg6IDg0LCBzOiAxLCBlOiBbMTgsIDI0LCA2Nl0sIGw6IDE5LCBkOiAyIH0sXG4gICAgeyBoOiAyNiwgczogMzIsIGU6IFsxN10sIGw6IDQzNSB9LFxuICAgIHsgaDogMjIsIHM6IDEsIGw6IDcxLCBkOiAyIH0sXG4gICAgeyBoOiAxNSwgczogODAsIGw6IDQwIH0sXG4gICAgeyBoOiAzMSwgczogMzIsIGw6IDE2IH0sXG4gICAgeyBoOiAzMiwgczogMSwgbDogODAsIGQ6IDIgfSxcbiAgICB7IGg6IDUyLCBzOiAxLCBsOiA0MiwgZDogMiB9LFxuICAgIHsgaDogMTIsIHM6IDEsIGw6IDU1LCBkOiAyIH0sXG4gICAgeyBoOiA0MCwgczogMSwgZTogWzM4XSwgbDogMTUsIGQ6IDIgfSxcbiAgICB7IGg6IDE0LCBzOiAxLCBsOiA0OCwgZDogMiB9LFxuICAgIHsgaDogMzcsIHM6IDQ4LCBsOiA0OSB9LFxuICAgIHsgaDogMTQ4LCBzOiAxLCBsOiA2MzUxLCBkOiAyIH0sXG4gICAgeyBoOiA4OCwgczogMSwgbDogMTYwLCBkOiAyIH0sXG4gICAgeyBoOiAxNSwgczogMTYsIGw6IDcwNCB9LFxuICAgIHsgaDogMjUsIHM6IDI2LCBsOiA4NTQgfSxcbiAgICB7IGg6IDI1LCBzOiAzMiwgbDogNTU5MTUgfSxcbiAgICB7IGg6IDM3LCBzOiA0MCwgbDogMTI0NyB9LFxuICAgIHsgaDogMjUsIHM6IC0xMTk3MTEsIGw6IDUzMjQ4IH0sXG4gICAgeyBoOiAyNSwgczogLTExOTc2MywgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTE5ODE1LCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMTk4NjcsIGU6IFsxLCA0LCA1LCA3LCA4LCAxMSwgMTIsIDE3XSwgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTE5OTE5LCBsOiA1MiB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk5NzEsIGU6IFsyLCA3LCA4LCAxN10sIGw6IDUyIH0sXG4gICAgeyBoOiAyNCwgczogLTEyMDAyMywgZTogWzIsIDcsIDEzLCAxNSwgMTYsIDE3XSwgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTIwMDc1LCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMjAxMjcsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTEyMDE3OSwgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTIwMjMxLCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMjAyODMsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTEyMDMzNSwgbDogNTIgfSxcbiAgICB7IGg6IDI0LCBzOiAtMTE5NTQzLCBlOiBbMTddLCBsOiA1NiB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk2MDEsIGU6IFsxN10sIGw6IDU4IH0sXG4gICAgeyBoOiAyNCwgczogLTExOTY1OSwgZTogWzE3XSwgbDogNTggfSxcbiAgICB7IGg6IDI0LCBzOiAtMTE5NzE3LCBlOiBbMTddLCBsOiA1OCB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk3NzUsIGU6IFsxN10sIGw6IDU4IH1cbl07XG5jb25zdCBUYWJsZV9CXzJfbHV0X2FicyA9IGNyZWF0ZVRhYmxlKFwiYjU6M2JjLGMzOmZmLDc6NzMsMjoyNTMsNToyNTQsMzoyNTYsMToyNTcsNToyNTksMToyNWIsMzoyNjAsMToyNjMsMjoyNjksMToyNjgsNToyNmYsMToyNzIsMjoyNzUsNzoyODAsMzoyODMsNToyODgsMzoyOGEsMToyOGIsNToyOTIsM2Y6MTk1LDE6MWJmLDI5OjE5ZSwxMjU6M2I5LDhiOjNiMiwxOjNiOCwxOjNjNSwzOjNjNiwxOjNjMCwxYTozYmEsMTozYzEsMTozYzMsMjozYjgsMTozYjUsMWJjOTozYjksMWM6MWY3NiwxOjFmNzcsZjoxZjdhLDE6MWY3YixkOjFmNzgsMToxZjc5LDE6MWY3YywxOjFmN2QsMTA3OjYzLDU6MjViLDQ6NjgsMTo2OCwxOjY4LDM6NjksMTo2OSwxOjZjLDM6NmUsNDo3MCwxOjcxLDE6NzIsMTo3MiwxOjcyLDc6N2EsMjozYzksMjo3YSwyOjZiLDE6ZTUsMTo2MiwxOjYzLDM6NjUsMTo2NiwyOjZkLGI6M2IzLDE6M2MwLDY6NjQsMWI1NzQ6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzXCIpO1xuY29uc3QgVGFibGVfQl8yX2x1dF9yZWwgPSBjcmVhdGVUYWJsZShcIjE3OToxLDI6MSwyOjEsNToxLDI6MSxhOjRmLGE6MSw4OjEsMjoxLDI6MSwzOjEsNToxLDM6MSw0OjEsMjoxLDM6MSw0OjEsODoyLDE6MSwyOjIsMToxLDI6MiwyNzoyLDE5NToyNiwyOjI1LDE6MjUsMToyNSwyOjQwLDI6M2YsMTozZiwzMzoxLDExOi02LDE6LTksMWFjNzotM2EsNmQ6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxiOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGM6LTgsMjotOCwyOi04LDI6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDQ5Oi04LDE6LTgsMTotNGEsMTotNGEsZDotNTYsMTotNTYsMTotNTYsMTotNTYsZDotOCwxOi04LGY6LTgsMTotOCwzOi03XCIpO1xuY29uc3QgVGFibGVfQl8yX2NvbXBsZXggPSBjcmVhdGVUYWJsZShcImRmOjAwNzMwMDczLDUxOjAwNjkwMzA3LDE5OjAyQkMwMDZFLGE3OjAwNkEwMzBDLDE4YTowMDIwMDNCOSwxNjowM0I5MDMwODAzMDEsMjA6MDNDNTAzMDgwMzAxLDFkNzowNTY1MDU4MiwxOTBmOjAwNjgwMzMxLDE6MDA3NDAzMDgsMTowMDc3MDMwQSwxOjAwNzkwMzBBLDE6MDA2MTAyQkUsYjY6MDNDNTAzMTMsMjowM0M1MDMxMzAzMDAsMjowM0M1MDMxMzAzMDEsMjowM0M1MDMxMzAzNDIsMmE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDM6MUY3MDAzQjksMTowM0IxMDNCOSwxOjAzQUMwM0I5LDI6MDNCMTAzNDIsMTowM0IxMDM0MjAzQjksNTowM0IxMDNCOSw2OjFGNzQwM0I5LDE6MDNCNzAzQjksMTowM0FFMDNCOSwyOjAzQjcwMzQyLDE6MDNCNzAzNDIwM0I5LDU6MDNCNzAzQjksNjowM0I5MDMwODAzMDAsMTowM0I5MDMwODAzMDEsMzowM0I5MDM0MiwxOjAzQjkwMzA4MDM0MixiOjAzQzUwMzA4MDMwMCwxOjAzQzUwMzA4MDMwMSwxOjAzQzEwMzEzLDI6MDNDNTAzNDIsMTowM0M1MDMwODAzNDIsYjoxRjdDMDNCOSwxOjAzQzkwM0I5LDE6MDNDRTAzQjksMjowM0M5MDM0MiwxOjAzQzkwMzQyMDNCOSw1OjAzQzkwM0I5LGFjOjAwNzIwMDczLDViOjAwQjAwMDYzLDY6MDBCMDAwNjYsZDowMDZFMDA2RixhOjAwNzMwMDZELDE6MDA3NDAwNjUwMDZDLDE6MDA3NDAwNkQsMTI0ZjowMDY4MDA3MDAwNjEsMjowMDYxMDA3NSwyOjAwNkYwMDc2LGI6MDA3MDAwNjEsMTowMDZFMDA2MSwxOjAzQkMwMDYxLDE6MDA2RDAwNjEsMTowMDZCMDA2MSwxOjAwNkIwMDYyLDE6MDA2RDAwNjIsMTowMDY3MDA2MiwzOjAwNzAwMDY2LDE6MDA2RTAwNjYsMTowM0JDMDA2Niw0OjAwNjgwMDdBLDE6MDA2QjAwNjgwMDdBLDE6MDA2RDAwNjgwMDdBLDE6MDA2NzAwNjgwMDdBLDE6MDA3NDAwNjgwMDdBLDE1OjAwNzAwMDYxLDE6MDA2QjAwNzAwMDYxLDE6MDA2RDAwNzAwMDYxLDE6MDA2NzAwNzAwMDYxLDg6MDA3MDAwNzYsMTowMDZFMDA3NiwxOjAzQkMwMDc2LDE6MDA2RDAwNzYsMTowMDZCMDA3NiwxOjAwNkQwMDc2LDE6MDA3MDAwNzcsMTowMDZFMDA3NywxOjAzQkMwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAzQzksMTowMDZEMDNDOSwyOjAwNjIwMDcxLDM6MDA2MzIyMTUwMDZCMDA2NywxOjAwNjMwMDZGMDAyRSwxOjAwNjQwMDYyLDE6MDA2NzAwNzksMjowMDY4MDA3MCwyOjAwNkIwMDZCLDE6MDA2QjAwNkQsOTowMDcwMDA2OCwyOjAwNzAwMDcwMDA2RCwxOjAwNzAwMDcyLDI6MDA3MzAwNzYsMTowMDc3MDA2MixjNzIzOjAwNjYwMDY2LDE6MDA2NjAwNjksMTowMDY2MDA2QywxOjAwNjYwMDY2MDA2OSwxOjAwNjYwMDY2MDA2QywxOjAwNzMwMDc0LDE6MDA3MzAwNzQsZDowNTc0MDU3NiwxOjA1NzQwNTY1LDE6MDU3NDA1NkIsMTowNTdFMDU3NiwxOjA1NzQwNTZEXCIsIGJ5dGVzMik7XG5jb25zdCBUYWJsZV9DX3JhbmdlcyA9IGNyZWF0ZVJhbmdlVGFibGUoXCI4MC0yMCwyYTAtLDM5YywzMixmNzEsMThlLDdmMi1mLDE5LTcsMzAtNCw3LTUsZjgxLWIsNSxhODAwLTIwZmYsNGQxLTFmLDExMCxmYS02LGQxNzQtNywyZTg0LSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSwyLDFmLTVmLGZmN2YtMjAwMDFcIik7XG5mdW5jdGlvbiBmbGF0dGVuKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKChhY2N1bSwgdmFsdWUpID0+IHtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsdWUpID0+IHsgYWNjdW0ucHVzaCh2YWx1ZSk7IH0pO1xuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwgW10pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQTEoY29kZXBvaW50KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9BXzFfcmFuZ2VzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUIyKGNvZGVwb2ludCkge1xuICAgIGxldCByYW5nZSA9IG1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQl8yX3Jhbmdlcyk7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBbY29kZXBvaW50ICsgcmFuZ2Uuc107XG4gICAgfVxuICAgIGxldCBjb2RlcyA9IFRhYmxlX0JfMl9sdXRfYWJzW2NvZGVwb2ludF07XG4gICAgaWYgKGNvZGVzKSB7XG4gICAgICAgIHJldHVybiBjb2RlcztcbiAgICB9XG4gICAgbGV0IHNoaWZ0ID0gVGFibGVfQl8yX2x1dF9yZWxbY29kZXBvaW50XTtcbiAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgcmV0dXJuIFtjb2RlcG9pbnQgKyBzaGlmdFswXV07XG4gICAgfVxuICAgIGxldCBjb21wbGV4ID0gVGFibGVfQl8yX2NvbXBsZXhbY29kZXBvaW50XTtcbiAgICBpZiAoY29tcGxleCkge1xuICAgICAgICByZXR1cm4gY29tcGxleDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gX25hbWVwcmVwVGFibGVDKGNvZGVwb2ludCkge1xuICAgIHJldHVybiAhIW1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQ19yYW5nZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVwcmVwKHZhbHVlKSB7XG4gICAgLy8gVGhpcyBhbGxvd3MgcGxhdGZvcm1zIHdpdGggaW5jb21wbGV0ZSBub3JtYWxpemUgdG8gYnlwYXNzXG4gICAgLy8gaXQgZm9yIHZlcnkgYmFzaWMgbmFtZXMgd2hpY2ggdGhlIGJ1aWx0LWluIHRvTG93ZXJDYXNlXG4gICAgLy8gd2lsbCBjZXJ0YWlubHkgaGFuZGxlIGNvcnJlY3RseVxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlthLXowLTktXSokL2kpICYmIHZhbHVlLmxlbmd0aCA8PSA1OSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgLy8gR2V0IHRoZSBjb2RlIHBvaW50cyAoa2VlcGluZyB0aGUgY3VycmVudCBub3JtYWxpemF0aW9uKVxuICAgIGxldCBjb2RlcyA9IHRvVXRmOENvZGVQb2ludHModmFsdWUpO1xuICAgIGNvZGVzID0gZmxhdHRlbihjb2Rlcy5tYXAoKGNvZGUpID0+IHtcbiAgICAgICAgLy8gU3Vic3RpdHV0ZSBUYWJsZSBCLjEgKE1hcHMgdG8gTm90aGluZylcbiAgICAgICAgaWYgKFRhYmxlX0JfMV9mbGFncy5pbmRleE9mKGNvZGUpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZSA+PSAweGZlMDAgJiYgY29kZSA8PSAweGZlMGYpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdWJzdGl0dXRlIFRhYmxlIEIuMiAoQ2FzZSBGb2xkaW5nKVxuICAgICAgICBsZXQgY29kZXNUYWJsZUIyID0gX25hbWVwcmVwVGFibGVCMihjb2RlKTtcbiAgICAgICAgaWYgKGNvZGVzVGFibGVCMikge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVzVGFibGVCMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBTdWJzdGl0dXRpb25cbiAgICAgICAgcmV0dXJuIFtjb2RlXTtcbiAgICB9KSk7XG4gICAgLy8gTm9ybWFsaXplIHVzaW5nIGZvcm0gS0NcbiAgICBjb2RlcyA9IHRvVXRmOENvZGVQb2ludHMoX3RvVXRmOFN0cmluZyhjb2RlcyksIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKTtcbiAgICAvLyBQcm9oaWJpdCBUYWJsZXMgQy4xLjIsIEMuMi4yLCBDLjMsIEMuNCwgQy41LCBDLjYsIEMuNywgQy44LCBDLjlcbiAgICBjb2Rlcy5mb3JFYWNoKChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChfbmFtZXByZXBUYWJsZUMoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfUFJPSElCSVRFRFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFByb2hpYml0IFVuYXNzaWduZWQgQ29kZSBQb2ludHMgKFRhYmxlIEEuMSlcbiAgICBjb2Rlcy5mb3JFYWNoKChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChfbmFtZXByZXBUYWJsZUExKGNvZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVFJJTkdQUkVQX0NPTlRBSU5TX1VOQVNTSUdORURcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBJRE5BIGV4dHJhc1xuICAgIGxldCBuYW1lID0gX3RvVXRmOFN0cmluZyhjb2Rlcyk7XG4gICAgLy8gSUROQTogNC4yLjMuMVxuICAgIGlmIChuYW1lLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIgfHwgbmFtZS5zdWJzdHJpbmcoMiwgNCkgPT09IFwiLS1cIiB8fCBuYW1lLnN1YnN0cmluZyhuYW1lLmxlbmd0aCAtIDEpID09PSBcIi1cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGh5cGhlblwiKTtcbiAgICB9XG4gICAgLy8gSUROQTogNC4yLjRcbiAgICBpZiAobmFtZS5sZW5ndGggPiA2Mykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbG9uZ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZG5hLmpzLm1hcCIsImltcG9ydCB7IGNvbmNhdCwgaGV4bGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgbmFtZXByZXAsIHRvVXRmOEJ5dGVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IFplcm9zID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuWmVyb3MuZmlsbCgwKTtcbmNvbnN0IFBhcnRpdGlvbiA9IG5ldyBSZWdFeHAoXCJeKCguKilcXFxcLik/KFteLl0rKSRcIik7XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE5hbWUobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gbmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChuYW1lcHJlcChjb21wc1tpXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBFTlMgbmFtZTsgbm90IGEgc3RyaW5nXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnQgPSBuYW1lO1xuICAgIGxldCByZXN1bHQgPSBaZXJvcztcbiAgICB3aGlsZSAoY3VycmVudC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcGFydGl0aW9uID0gY3VycmVudC5tYXRjaChQYXJ0aXRpb24pO1xuICAgICAgICBpZiAocGFydGl0aW9uID09IG51bGwgfHwgcGFydGl0aW9uWzJdID09PSBcIlwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBFTlMgYWRkcmVzczsgbWlzc2luZyBjb21wb25lbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdG9VdGY4Qnl0ZXMobmFtZXByZXAocGFydGl0aW9uWzNdKSk7XG4gICAgICAgIHJlc3VsdCA9IGtlY2NhazI1Nihjb25jYXQoW3Jlc3VsdCwga2VjY2FrMjU2KGxhYmVsKV0pKTtcbiAgICAgICAgY3VycmVudCA9IHBhcnRpdGlvblsyXSB8fCBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRuc0VuY29kZShuYW1lKSB7XG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KG5hbWUuc3BsaXQoXCIuXCIpLm1hcCgoY29tcCkgPT4ge1xuICAgICAgICAvLyBXZSBqYW0gaW4gYW4gXyBwcmVmaXggdG8gZmlsbCBpbiB3aXRoIHRoZSBsZW5ndGggbGF0ZXJcbiAgICAgICAgLy8gTm90ZTogTmFtZXByZXAgdGhyb3dzIGlmIHRoZSBjb21wb25lbnQgaXMgb3ZlciA2MyBieXRlc1xuICAgICAgICBjb25zdCBieXRlcyA9IHRvVXRmOEJ5dGVzKFwiX1wiICsgbmFtZXByZXAoY29tcCkpO1xuICAgICAgICBieXRlc1swXSA9IGJ5dGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICB9KSkpICsgXCIwMFwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZWhhc2guanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIm5ldHdvcmtzLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbmZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZW5ldHdvcmspID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJMaXN0ID0gW107XG4gICAgICAgIGlmIChwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIgJiYgb3B0aW9ucy5pbmZ1cmEgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5pbmZ1cmEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlciAmJiBvcHRpb25zLmV0aGVyc2NhbiAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5FdGhlcnNjYW5Qcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmV0aGVyc2NhbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlciAmJiBvcHRpb25zLmFsY2hlbXkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMuYWxjaGVteSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyICYmIG9wdGlvbnMucG9ja2V0ICE9PSBcIi1cIikge1xuICAgICAgICAgICAgLy8gVGhlc2UgbmV0d29ya3MgYXJlIGN1cnJlbnRseSBmYXVsdHkgb24gUG9ja2V0IGFzIHRoZWlyXG4gICAgICAgICAgICAvLyBuZXR3b3JrIGRvZXMgbm90IGhhbmRsZSB0aGUgQmVybGluIGhhcmRmb3JrLCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gbGl2ZSBvbiB0aGVzZSBvbmVzLlxuICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgZ29lcyBhd2F5IG9uY2UgUG9ja2V0IGhhcyB1cGdyYWRlZCB0aGVpciBub2Rlc1xuICAgICAgICAgICAgY29uc3Qgc2tpcCA9IFtcImdvZXJsaVwiLCBcInJvcHN0ZW5cIiwgXCJyaW5rZWJ5XCJdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBwcm92aWRlcnMuUG9ja2V0UHJvdmlkZXIobmV0d29yayk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLm5ldHdvcmsgJiYgc2tpcC5pbmRleE9mKHByb3ZpZGVyLm5ldHdvcmsubmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyICYmIG9wdGlvbnMuY2xvdWRmbGFyZSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIobmV0d29yaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICBsZXQgcXVvcnVtID0gMTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1b3J1bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXR3b3JrID09PSBcImhvbWVzdGVhZFwiKSB7XG4gICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIocHJvdmlkZXJMaXN0LCBxdW9ydW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm92aWRlckxpc3RbMF07XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGhEZWZhdWx0UHJvdmlkZXIobmV0d29yayk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn1cbmZ1bmN0aW9uIGV0Y0RlZmF1bHRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuY29uc3QgaG9tZXN0ZWFkID0ge1xuICAgIGNoYWluSWQ6IDEsXG4gICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcbiAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImhvbWVzdGVhZFwiKVxufTtcbmNvbnN0IHJvcHN0ZW4gPSB7XG4gICAgY2hhaW5JZDogMyxcbiAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgIG5hbWU6IFwicm9wc3RlblwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcbn07XG5jb25zdCBjbGFzc2ljTW9yZG9yID0ge1xuICAgIGNoYWluSWQ6IDYzLFxuICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20vbW9yZG9yXCIsIFwiY2xhc3NpY01vcmRvclwiKVxufTtcbi8vIFNlZTogaHR0cHM6Ly9jaGFpbmxpc3Qub3JnXG5jb25zdCBuZXR3b3JrcyA9IHtcbiAgICB1bnNwZWNpZmllZDogeyBjaGFpbklkOiAwLCBuYW1lOiBcInVuc3BlY2lmaWVkXCIgfSxcbiAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcbiAgICBtYWlubmV0OiBob21lc3RlYWQsXG4gICAgbW9yZGVuOiB7IGNoYWluSWQ6IDIsIG5hbWU6IFwibW9yZGVuXCIgfSxcbiAgICByb3BzdGVuOiByb3BzdGVuLFxuICAgIHRlc3RuZXQ6IHJvcHN0ZW4sXG4gICAgcmlua2VieToge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicmlua2VieVwiKVxuICAgIH0sXG4gICAga292YW46IHtcbiAgICAgICAgY2hhaW5JZDogNDIsXG4gICAgICAgIG5hbWU6IFwia292YW5cIixcbiAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcbiAgICB9LFxuICAgIGdvZXJsaToge1xuICAgICAgICBjaGFpbklkOiA1LFxuICAgICAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgICAgICBuYW1lOiBcImdvZXJsaVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcbiAgICB9LFxuICAgIGtpbnRzdWdpOiB7IGNoYWluSWQ6IDEzMzc3MDIsIG5hbWU6IFwia2ludHN1Z2lcIiB9LFxuICAgIC8vIEVUQyAoU2VlOiAjMzUxKVxuICAgIGNsYXNzaWM6IHtcbiAgICAgICAgY2hhaW5JZDogNjEsXG4gICAgICAgIG5hbWU6IFwiY2xhc3NpY1wiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovXFwvd3d3LmV0aGVyY2x1c3Rlci5jb20vZXRjXCIsIFwiY2xhc3NpY1wiKVxuICAgIH0sXG4gICAgY2xhc3NpY01vcmRlbjogeyBjaGFpbklkOiA2MiwgbmFtZTogXCJjbGFzc2ljTW9yZGVuXCIgfSxcbiAgICBjbGFzc2ljTW9yZG9yOiBjbGFzc2ljTW9yZG9yLFxuICAgIGNsYXNzaWNUZXN0bmV0OiBjbGFzc2ljTW9yZG9yLFxuICAgIGNsYXNzaWNLb3R0aToge1xuICAgICAgICBjaGFpbklkOiA2LFxuICAgICAgICBuYW1lOiBcImNsYXNzaWNLb3R0aVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovXFwvd3d3LmV0aGVyY2x1c3Rlci5jb20va290dGlcIiwgXCJjbGFzc2ljS290dGlcIilcbiAgICB9LFxuICAgIHhkYWk6IHsgY2hhaW5JZDogMTAwLCBuYW1lOiBcInhkYWlcIiB9LFxuICAgIG1hdGljOiB7IGNoYWluSWQ6IDEzNywgbmFtZTogXCJtYXRpY1wiIH0sXG4gICAgbWF0aWNtdW06IHsgY2hhaW5JZDogODAwMDEsIG5hbWU6IFwibWF0aWNtdW1cIiB9LFxuICAgIG9wdGltaXNtOiB7IGNoYWluSWQ6IDEwLCBuYW1lOiBcIm9wdGltaXNtXCIgfSxcbiAgICBcIm9wdGltaXNtLWtvdmFuXCI6IHsgY2hhaW5JZDogNjksIG5hbWU6IFwib3B0aW1pc20ta292YW5cIiB9LFxuICAgIFwib3B0aW1pc20tZ29lcmxpXCI6IHsgY2hhaW5JZDogNDIwLCBuYW1lOiBcIm9wdGltaXNtLWdvZXJsaVwiIH0sXG4gICAgYXJiaXRydW06IHsgY2hhaW5JZDogNDIxNjEsIG5hbWU6IFwiYXJiaXRydW1cIiB9LFxuICAgIFwiYXJiaXRydW0tcmlua2VieVwiOiB7IGNoYWluSWQ6IDQyMTYxMSwgbmFtZTogXCJhcmJpdHJ1bS1yaW5rZWJ5XCIgfSxcbiAgICBibmI6IHsgY2hhaW5JZDogNTYsIG5hbWU6IFwiYm5iXCIgfSxcbiAgICBibmJ0OiB7IGNoYWluSWQ6IDk3LCBuYW1lOiBcImJuYnRcIiB9LFxufTtcbi8qKlxuICogIGdldE5ldHdvcmtcbiAqXG4gKiAgQ29udmVydHMgYSBuYW1lZCBjb21tb24gbmV0d29ya3Mgb3IgY2hhaW4gSUQgKG5ldHdvcmsgSUQpIHRvIGEgTmV0d29ya1xuICogIGFuZCB2ZXJpZmllcyBhIG5ldHdvcmsgaXMgYSB2YWxpZCBOZXR3b3JrLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgIC8vIE5vIG5ldHdvcmsgKG51bGwpXG4gICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5ldHdvcmtzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkLmNoYWluSWQgPT09IG5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICAgICAgICAgICAgICBlbnNBZGRyZXNzOiAoc3RhbmRhcmQuZW5zQWRkcmVzcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrLFxuICAgICAgICAgICAgbmFtZTogXCJ1bmtub3duXCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmQgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcbiAgICAgICAgaWYgKHN0YW5kYXJkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBzdGFuZGFyZC5uYW1lLFxuICAgICAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgICAgIGVuc0FkZHJlc3M6IHN0YW5kYXJkLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmsubmFtZV07XG4gICAgLy8gTm90IGEgc3RhbmRhcmQgbmV0d29yazsgY2hlY2sgdGhhdCBpdCBpcyBhIHZhbGlkIG5ldHdvcmsgaW4gZ2VuZXJhbFxuICAgIGlmICghc3RhbmRhcmQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29yayBjaGFpbklkXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHRoZSBjaGFpbklkIG1hdGNoZXMgdGhlIGV4cGVjdGVkIG5ldHdvcmsgY2hhaW5JZCAob3IgaXMgMDsgZGlzYWJsZSBFSVAtMTU1KVxuICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IDAgJiYgbmV0d29yay5jaGFpbklkICE9PSBzdGFuZGFyZC5jaGFpbklkKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJuZXR3b3JrIGNoYWluSWQgbWlzbWF0Y2hcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgIH1cbiAgICAvLyBAVE9ETzogSW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBhZGQgYW4gYXR0YWNoIGZ1bmN0aW9uIHRvIGEgZGVmYXVsdFByb3ZpZGVyXG4gICAgLy8gY2xhc3MgYW5kIG1vdmUgdGhlIF9kZWZhdWx0UHJvdmlkZXIgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIChleHRlbmQgTmV0d29yaylcbiAgICBsZXQgZGVmYXVsdFByb3ZpZGVyID0gbmV0d29yay5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGw7XG4gICAgaWYgKGRlZmF1bHRQcm92aWRlciA9PSBudWxsICYmIHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKGlzUmVuZXR3b3JrYWJsZShzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyKSkge1xuICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlci5yZW5ldHdvcmsobmV0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFN0YW5kYXJkIE5ldHdvcmsgKGFsbG93IG92ZXJyaWRpbmcgdGhlIEVOUyBhZGRyZXNzKVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5ldHdvcmsubmFtZSxcbiAgICAgICAgY2hhaW5JZDogc3RhbmRhcmQuY2hhaW5JZCxcbiAgICAgICAgZW5zQWRkcmVzczogKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBkZWZhdWx0UHJvdmlkZXJcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSB8fCAoU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzaGEyLzUuNi4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBoYXNoIGZyb20gXCJoYXNoLmpzXCI7XG4vL2NvbnN0IF9yaXBlbWQxNjAgPSBfaGFzaC5yaXBlbWQxNjA7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgU3VwcG9ydGVkQWxnb3JpdGhtIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5yaXBlbWQxNjAoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2guc2hhMjU2KCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTUxMihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTUxMigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSG1hYyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgIGlmICghU3VwcG9ydGVkQWxnb3JpdGhtW2FsZ29yaXRobV0pIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG0gXCIgKyBhbGdvcml0aG0sIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiaG1hY1wiLFxuICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBoYXNoLmhtYWMoaGFzaFthbGdvcml0aG1dLCBhcnJheWlmeShrZXkpKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIiwiZXhwb3J0IGNvbnN0IEFkZHJlc3NaZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkZHJlc3Nlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MsIGdldENvbnRyYWN0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBoZXhEYXRhTGVuZ3RoLCBoZXhEYXRhU2xpY2UsIGhleFZhbHVlLCBoZXhaZXJvUGFkLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQWRkcmVzc1plcm8gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5LCBwYXJzZSBhcyBwYXJzZVRyYW5zYWN0aW9uIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IGNsYXNzIEZvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBGb3JtYXR0ZXIpO1xuICAgICAgICB0aGlzLmZvcm1hdHMgPSB0aGlzLmdldERlZmF1bHRGb3JtYXRzKCk7XG4gICAgfVxuICAgIGdldERlZmF1bHRGb3JtYXRzKCkge1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gKHt9KTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcy5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBiaWdOdW1iZXIgPSB0aGlzLmJpZ051bWJlci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IHRoaXMuYmxvY2tUYWcuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5oYXNoLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGhleCA9IHRoaXMuaGV4LmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IHRoaXMubnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGUuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgc3RyaWN0RGF0YSA9ICh2KSA9PiB7IHJldHVybiB0aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hY2Nlc3NMaXN0LmJpbmQodGhpcyksIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgICAgICAvLyBlaXRoZXIgKGdhc1ByaWNlKSBvciAobWF4UHJpb3JpdHlGZWVQZXJHYXMgKyBtYXhGZWVQZXJHYXMpXG4gICAgICAgICAgICAvLyBtdXN0IGJlIHNldFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG4gICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBub25jZTogbnVtYmVyLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHM6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcbiAgICAgICAgICAgIHY6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICByYXc6IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcbiAgICAgICAgICAgIG5vbmNlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBtYXhGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd051bGwoc3RyaWN0RGF0YSksXG4gICAgICAgICAgICB0eXBlOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICBhY2Nlc3NMaXN0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWNjZXNzTGlzdC5iaW5kKHRoaXMpLCBudWxsKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5yZWNlaXB0TG9nID0ge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja0hhc2g6IGhhc2gsXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAvLyBzaG91bGQgYmUgYWxsb3dOdWxsKGhhc2gpLCBidXQgYnJva2VuLUVJUC02NTggc3VwcG9ydCBpcyBoYW5kbGVkIGluIHJlY2VpcHRcbiAgICAgICAgICAgIHJvb3Q6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGxvZ3NCbG9vbTogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGxvZ3M6IEZvcm1hdHRlci5hcnJheU9mKHRoaXMucmVjZWlwdExvZy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG4gICAgICAgICAgICBjb25maXJtYXRpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG4gICAgICAgICAgICBjdW11bGF0aXZlR2FzVXNlZDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgZWZmZWN0aXZlR2FzUHJpY2U6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIHN0YXR1czogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrID0ge1xuICAgICAgICAgICAgaGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG4gICAgICAgICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbnVtYmVyLFxuICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHRoaXMuZGlmZmljdWx0eS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIG1pbmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgZXh0cmFEYXRhOiBkYXRhLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKVxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IHNoYWxsb3dDb3B5KGZvcm1hdHMuYmxvY2spO1xuICAgICAgICBmb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucy50cmFuc2FjdGlvbnMgPSBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKHRoaXMudHJhbnNhY3Rpb25SZXNwb25zZS5iaW5kKHRoaXMpKSk7XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuICAgICAgICAgICAgZnJvbUJsb2NrOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9CbG9jazogRm9ybWF0dGVyLmFsbG93TnVsbChibG9ja1RhZywgdW5kZWZpbmVkKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgYWRkcmVzczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMudG9waWNzLmJpbmQodGhpcyksIHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMuZmlsdGVyTG9nID0ge1xuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIHJlbW92ZWQ6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5ib29sZWFuLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIGRhdGE6IEZvcm1hdHRlci5hbGxvd0ZhbHNpc2goZGF0YSwgXCIweFwiKSxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG4gICAgICAgICAgICBsb2dJbmRleDogbnVtYmVyLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm9ybWF0cztcbiAgICB9XG4gICAgYWNjZXNzTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgICAgIHJldHVybiBhY2Nlc3NMaXN0aWZ5KGFjY2Vzc0xpc3QgfHwgW10pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgbnVtYmVyKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIHR5cGUobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIiB8fCBudW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGJpZ051bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhIGJvb2xlYW4sIFwidHJ1ZVwiIG9yICBcImZhbHNlXCI7IHJldHVybnMgYSBib29sZWFuXG4gICAgYm9vbGVhbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJvb2xlYW4gLSBcIiArIHZhbHVlKTtcbiAgICB9XG4gICAgaGV4KHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRhdGEodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhleCh2YWx1ZSwgc3RyaWN0KTtcbiAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YTsgb2RkLWxlbmd0aCAtIFwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGFuIGFkZHJlc3NcbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIGNhbGxBZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcodmFsdWUsIDMyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKHZhbHVlLCAxMikpO1xuICAgICAgICByZXR1cm4gKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSA/IG51bGwgOiBhZGRyZXNzO1xuICAgIH1cbiAgICBjb250cmFjdEFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYWN0QWRkcmVzcyh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBibG9ja1RhZyhibG9ja1RhZykge1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibGF0ZXN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIjB4MFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiB8fCBibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VmFsdWUoYmxvY2tUYWcpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGEgaGFzaCwgb3B0aW9uYWxseSByZXF1aXJlcyAweCBwcmVmaXg7IHJldHVybnMgcHJlZml4ZWQgbG93ZXJjYXNlIGhhc2guXG4gICAgaGFzaCh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChyZXN1bHQpICE9PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmV0dXJucyB0aGUgZGlmZmljdWx0eSBhcyBhIG51bWJlciwgb3IgaWYgdG9vIGxhcmdlIChpLmUuIFBvQSBuZXR3b3JrKSBudWxsXG4gICAgZGlmZmljdWx0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdiA9IEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVpbnQyNTYodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludDI1NlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuICAgIH1cbiAgICBfYmxvY2sodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFsdWUubWluZXIgPSB2YWx1ZS5hdXRob3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGRpZmZpY3VsdHkgbWF5IG5lZWQgdG8gY29tZSBmcm9tIF9kaWZmaWN1bHR5IGluIHJlY3Vyc2VkIGJsb2Nrc1xuICAgICAgICBjb25zdCBkaWZmaWN1bHR5ID0gKHZhbHVlLl9kaWZmaWN1bHR5ICE9IG51bGwpID8gdmFsdWUuX2RpZmZpY3VsdHkgOiB2YWx1ZS5kaWZmaWN1bHR5O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2soZm9ybWF0LCB2YWx1ZSk7XG4gICAgICAgIHJlc3VsdC5fZGlmZmljdWx0eSA9ICgoZGlmZmljdWx0eSA9PSBudWxsKSA/IG51bGwgOiBCaWdOdW1iZXIuZnJvbShkaWZmaWN1bHR5KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGJsb2NrKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrKTtcbiAgICB9XG4gICAgYmxvY2tXaXRoVHJhbnNhY3Rpb25zKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ibG9jayh2YWx1ZSwgdGhpcy5mb3JtYXRzLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICB0cmFuc2FjdGlvblJlcXVlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0LCB2YWx1ZSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uUmVzcG9uc2UodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gUmVuYW1lIGdhcyB0byBnYXNMaW1pdFxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0cmFuc2FjdGlvbi5nYXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuICAgICAgICAvLyAwIGFkZHJlc3M7IGNvcnJlY3QgdGhpcyB0byBiZSBhIHJlYWwgYWRkcmVzc1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gJiYgQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24udG8pLmlzWmVybygpKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuYW1lIGlucHV0IHRvIGRhdGFcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5kYXRhID0gdHJhbnNhY3Rpb24uaW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gPT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5jcmVhdGVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPSB0aGlzLmNvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0cmFuc2FjdGlvbi50eXBlID09PSAxIHx8IHRyYW5zYWN0aW9uLnR5cGUgPT09IDIpICYmIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMudHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGNoYWluSWQpKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLm5ldHdvcmtJZDtcbiAgICAgICAgICAgIC8vIGdldGgtZXRjIHJldHVybnMgY2hhaW5JZFxuICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gKHJlc3VsdC52IC0gMzUpIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW5JZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBwYXJzZUludChjaGFpbklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG4gICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoICYmIHJlc3VsdC5ibG9ja0hhc2gucmVwbGFjZSgvMC9nLCBcIlwiKSA9PT0gXCJ4XCIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRyYW5zYWN0aW9uKHZhbHVlKTtcbiAgICB9XG4gICAgcmVjZWlwdExvZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJlY2VpcHQodmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0LCB2YWx1ZSk7XG4gICAgICAgIC8vIFJTSyBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCBFSVAtNjU4LCBzbyB3ZSBtdW5nZSB0aGluZ3MgYSBiaXQgaGVyZSBmb3IgaXRcbiAgICAgICAgaWYgKHJlc3VsdC5yb290ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucm9vdC5sZW5ndGggPD0gNCkge1xuICAgICAgICAgICAgICAgIC8vIENvdWxkIGJlIDB4MDAsIDB4MCwgMHgwMSBvciAweDFcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHJlc3VsdC5yb290KS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgaWYgYm90aCBhcmUgc3BlY2lmaWVkLCB0aGV5IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwgJiYgKHJlc3VsdC5zdGF0dXMgIT09IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFsdC1yb290LXN0YXR1cy9zdGF0dXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZVwiLCB7IHJvb3Q6IHJlc3VsdC5yb290LCBzdGF0dXM6IHJlc3VsdC5zdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnN0YXR1cyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhbHQtcm9vdC1zdGF0dXNcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQucm9vdC5sZW5ndGggIT09IDY2KSB7XG4gICAgICAgICAgICAgICAgLy8gTXVzdCBiZSBhIHZhbGlkIGJ5dGVzMzJcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByb290IGhhc2hcIiwgXCJ2YWx1ZS5yb290XCIsIHJlc3VsdC5yb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b3BpY3ModmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2KSA9PiB0aGlzLnRvcGljcyh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZpbHRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZmlsdGVyTG9nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlckxvZywgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgY2hlY2soZm9ybWF0LCBvYmplY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1hdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdFtrZXldKG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGVycm9yLmNoZWNrVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBpZiB2YWx1ZSBpcyBudWxsLWlzaCwgbnVsbFZhbHVlIGlzIHJldHVybmVkXG4gICAgc3RhdGljIGFsbG93TnVsbChmb3JtYXQsIG51bGxWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuICAgIHN0YXRpYyBhbGxvd0ZhbHNpc2goZm9ybWF0LCByZXBsYWNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlcyBhbiBBcnJheSBzYXRpc2Z5aW5nIGNoZWNrXG4gICAgc3RhdGljIGFycmF5T2YoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tdW5pdHlSZXNvdXJjYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKSA9PT0gXCJmdW5jdGlvblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW11bml0eVJlc291cmNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpc0NvbW11bml0eVJlc291cmNhYmxlKHZhbHVlKSAmJiB2YWx1ZS5pc0NvbW11bml0eVJlc291cmNlKCkpO1xufVxuLy8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2VcbmxldCB0aHJvdHRsZU1lc3NhZ2UgPSBmYWxzZTtcbmV4cG9ydCBmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCkge1xuICAgIGlmICh0aHJvdHRsZU1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdHRsZU1lc3NhZ2UgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09IE5PVElDRSA9PT09PT09PT1cIik7XG4gICAgY29uc29sZS5sb2coXCJSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiVGhlIGRlZmF1bHQgQVBJIGtleXMgZm9yIGVhY2ggc2VydmljZSBhcmUgcHJvdmlkZWQgYXMgYSBoaWdobHktdGhyb3R0bGVkLFwiKTtcbiAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIldoaWxlIHlvdXIgYXBwbGljYXRpb24gd2lsbCBjb250aW51ZSB0byBmdW5jdGlvbiwgd2UgaGlnaGx5IHJlY29tbWVuZGVkXCIpO1xuICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcbiAgICBjb25zb2xlLmxvZyhcInJlcXVlc3QgcmF0ZS9saW1pdCBhbmQgZW5hYmxlIG90aGVyIHBlcmtzLCBzdWNoIGFzIG1ldHJpY3MgYW5kIGFkdmFuY2VkIEFQSXMuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9ybWF0dGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGb3JrRXZlbnQsIFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBCYXNlNTggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZXhcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleENvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEhhc2haZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZG5zRW5jb2RlLCBuYW1laGFzaCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBnZXROZXR3b3JrIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L25ldHdvcmtzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2hhMlwiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMsIHRvVXRmOFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24sIHBvbGwgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgYmVjaDMyIGZyb20gXCJiZWNoMzJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEZvcm1hdHRlciB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuY29uc3QgTUFYX0NDSVBfUkVESVJFQ1RTID0gMTA7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV2ZW50IFNlcmlhbGl6ZWluZ1xuZnVuY3Rpb24gY2hlY2tUb3BpYyh0b3BpYykge1xuICAgIGlmICh0b3BpYyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgaWYgKGhleERhdGFMZW5ndGgodG9waWMpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0b3BpY1wiLCBcInRvcGljXCIsIHRvcGljKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKSB7XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIG51bGwgQU5ELXRvcGljczsgdGhleSBhcmUgcmVkdW5kYW50XG4gICAgdG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG4gICAgd2hpbGUgKHRvcGljcy5sZW5ndGggPiAwICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT0gbnVsbCkge1xuICAgICAgICB0b3BpY3MucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB0b3BpY3MubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b3BpYykpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdHJhY2sgdW5pcXVlIE9SLXRvcGljc1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlID0ge307XG4gICAgICAgICAgICB0b3BpYy5mb3JFYWNoKCh0b3BpYykgPT4ge1xuICAgICAgICAgICAgICAgIHVuaXF1ZVtjaGVja1RvcGljKHRvcGljKV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUaGUgb3JkZXIgb2YgT1ItdG9waWNzIGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkID0gT2JqZWN0LmtleXModW5pcXVlKTtcbiAgICAgICAgICAgIHNvcnRlZC5zb3J0KCk7XG4gICAgICAgICAgICByZXR1cm4gc29ydGVkLmpvaW4oXCJ8XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrVG9waWModG9waWMpO1xuICAgICAgICB9XG4gICAgfSkuam9pbihcIiZcIik7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zcGxpdCgvJi9nKS5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmICh0b3BpYyA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdG9waWMuc3BsaXQoXCJ8XCIpLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoKHRvcGljID09PSBcIm51bGxcIikgPyBudWxsIDogdG9waWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgoY29tcHMubGVuZ3RoID09PSAxKSA/IGNvbXBzWzBdIDogY29tcHMpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGhleERhdGFMZW5ndGgoZXZlbnROYW1lKSA9PT0gMzIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInR4OlwiICsgZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnROYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnROYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJmaWx0ZXI6KjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChGb3JrRXZlbnQuaXNGb3JrRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICBsb2dnZXIud2FybihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudE5hbWUgJiYgdHlwZW9mIChldmVudE5hbWUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBcImZpbHRlcjpcIiArIChldmVudE5hbWUuYWRkcmVzcyB8fCBcIipcIikgKyBcIjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUudG9waWNzIHx8IFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiICsgZXZlbnROYW1lKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIE9iamVjdFxuZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbn1cbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuICAgIH0pO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBQcm92aWRlciBPYmplY3Rcbi8qKlxuICogIEV2ZW50VHlwZVxuICogICAtIFwiYmxvY2tcIlxuICogICAtIFwicG9sbFwiXG4gKiAgIC0gXCJkaWRQb2xsXCJcbiAqICAgLSBcInBlbmRpbmdcIlxuICogICAtIFwiZXJyb3JcIlxuICogICAtIFwibmV0d29ya1wiXG4gKiAgIC0gZmlsdGVyXG4gKiAgIC0gdG9waWNzIGFycmF5XG4gKiAgIC0gdHJhbnNhY3Rpb24gaGFzaFxuICovXG5jb25zdCBQb2xsYWJsZUV2ZW50cyA9IFtcImJsb2NrXCIsIFwibmV0d29ya1wiLCBcInBlbmRpbmdcIiwgXCJwb2xsXCJdO1xuZXhwb3J0IGNsYXNzIEV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidGFnXCIsIHRhZyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibGlzdGVuZXJcIiwgbGlzdGVuZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIm9uY2VcIiwgb25jZSk7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuICAgICAgICB0aGlzLl9pbmZsaWdodCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidHhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoO1xuICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YWc7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWcuc3BsaXQoXCI6XCIpWzBdO1xuICAgIH1cbiAgICBnZXQgaGFzaCgpIHtcbiAgICAgICAgY29uc3QgY29tcHMgPSB0aGlzLnRhZy5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmIChjb21wc1swXSAhPT0gXCJ0eFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcHNbMV07XG4gICAgfVxuICAgIGdldCBmaWx0ZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwiZmlsdGVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBjb21wc1sxXTtcbiAgICAgICAgY29uc3QgdG9waWNzID0gZGVzZXJpYWxpemVUb3BpY3MoY29tcHNbMl0pO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7fTtcbiAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09IFwiKlwiKSB7XG4gICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICB9XG4gICAgcG9sbGFibGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy50YWcuaW5kZXhPZihcIjpcIikgPj0gMCB8fCBQb2xsYWJsZUV2ZW50cy5pbmRleE9mKHRoaXMudGFnKSA+PSAwKTtcbiAgICB9XG59XG47XG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kXG5jb25zdCBjb2luSW5mb3MgPSB7XG4gICAgXCIwXCI6IHsgc3ltYm9sOiBcImJ0Y1wiLCBwMnBraDogMHgwMCwgcDJzaDogMHgwNSwgcHJlZml4OiBcImJjXCIgfSxcbiAgICBcIjJcIjogeyBzeW1ib2w6IFwibHRjXCIsIHAycGtoOiAweDMwLCBwMnNoOiAweDMyLCBwcmVmaXg6IFwibHRjXCIgfSxcbiAgICBcIjNcIjogeyBzeW1ib2w6IFwiZG9nZVwiLCBwMnBraDogMHgxZSwgcDJzaDogMHgxNiB9LFxuICAgIFwiNjBcIjogeyBzeW1ib2w6IFwiZXRoXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNjFcIjogeyBzeW1ib2w6IFwiZXRjXCIsIGlsazogXCJldGhcIiB9LFxuICAgIFwiNzAwXCI6IHsgc3ltYm9sOiBcInhkYWlcIiwgaWxrOiBcImV0aFwiIH0sXG59O1xuZnVuY3Rpb24gYnl0ZXMzMmlmeSh2YWx1ZSkge1xuICAgIHJldHVybiBoZXhaZXJvUGFkKEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpLCAzMik7XG59XG4vLyBDb21wdXRlIHRoZSBCYXNlNThDaGVjayBlbmNvZGVkIGRhdGEgKGNoZWNrc3VtIGlzIGZpcnN0IDQgYnl0ZXMgb2Ygc2hhMjU2ZClcbmZ1bmN0aW9uIGJhc2U1OEVuY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIEJhc2U1OC5lbmNvZGUoY29uY2F0KFtkYXRhLCBoZXhEYXRhU2xpY2Uoc2hhMjU2KHNoYTI1NihkYXRhKSksIDAsIDQpXSkpO1xufVxuY29uc3QgbWF0Y2hlcklwZnMgPSBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpO1xuY29uc3QgbWF0Y2hlcnMgPSBbXG4gICAgbmV3IFJlZ0V4cChcIl4oaHR0cHMpOi9cXC8oLiopJFwiLCBcImlcIiksXG4gICAgbmV3IFJlZ0V4cChcIl4oZGF0YSk6KC4qKSRcIiwgXCJpXCIpLFxuICAgIG1hdGNoZXJJcGZzLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCwgc3RhcnQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdG9VdGY4U3RyaW5nKF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIF9wYXJzZUJ5dGVzKHJlc3VsdCwgc3RhcnQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsIHN0YXJ0LCBzdGFydCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBsZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICByZXR1cm4gaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbn1cbi8vIFRyaW0gb2ZmIHRoZSBpcGZzOi8vIHByZWZpeCBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0IGdhdGV3YXkgVVJMXG5mdW5jdGlvbiBnZXRJcGZzTGluayhsaW5rKSB7XG4gICAgaWYgKGxpbmsubWF0Y2goL15pcGZzOlxcL1xcL2lwZnNcXC8vaSkpIHtcbiAgICAgICAgbGluayA9IGxpbmsuc3Vic3RyaW5nKDEyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGluay5tYXRjaCgvXmlwZnM6XFwvXFwvL2kpKSB7XG4gICAgICAgIGxpbmsgPSBsaW5rLnN1YnN0cmluZyg3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBJUEZTIGZvcm1hdFwiLCBcImxpbmtcIiwgbGluayk7XG4gICAgfVxuICAgIHJldHVybiBgaHR0cHM6L1xcL2dhdGV3YXkuaXBmcy5pby9pcGZzLyR7bGlua31gO1xufVxuZnVuY3Rpb24gbnVtUGFkKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWw7IHNob3VsZCBub3QgaGFwcGVuXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgcGFkZGVkLnNldChyZXN1bHQsIDMyIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHBhZGRlZDtcbn1cbmZ1bmN0aW9uIGJ5dGVzUGFkKHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZS5sZW5ndGggJSAzMikgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShNYXRoLmNlaWwodmFsdWUubGVuZ3RoIC8gMzIpICogMzIpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBQkkgRW5jb2RlcyBhIHNlcmllcyBvZiAoYnl0ZXMsIGJ5dGVzLCAuLi4pXG5mdW5jdGlvbiBlbmNvZGVCeXRlcyhkYXRhcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBieXRlQ291bnQgPSAwO1xuICAgIC8vIEFkZCBwbGFjZS1ob2xkZXJzIGZvciBwb2ludGVycyBhcyB3ZSBhZGQgaXRlbXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG51bGwpO1xuICAgICAgICBieXRlQ291bnQgKz0gMzI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGFycmF5aWZ5KGRhdGFzW2ldKTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBieXRlcyBvZmZzZXRcbiAgICAgICAgcmVzdWx0W2ldID0gbnVtUGFkKGJ5dGVDb3VudCk7XG4gICAgICAgIC8vIFRoZSBsZW5ndGggYW5kIHBhZGRlZCB2YWx1ZSBvZiBkYXRhXG4gICAgICAgIHJlc3VsdC5wdXNoKG51bVBhZChkYXRhLmxlbmd0aCkpO1xuICAgICAgICByZXN1bHQucHVzaChieXRlc1BhZChkYXRhKSk7XG4gICAgICAgIGJ5dGVDb3VudCArPSAzMiArIE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDMyKSAqIDMyO1xuICAgIH1cbiAgICByZXR1cm4gaGV4Q29uY2F0KHJlc3VsdCk7XG59XG5leHBvcnQgY2xhc3MgUmVzb2x2ZXIge1xuICAgIC8vIFRoZSByZXNvbHZlZEFkZHJlc3MgaXMgb25seSBmb3IgY3JlYXRpbmcgYSBSZXZlcnNlTG9va3VwIHJlc29sdmVyXG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGFkZHJlc3MsIG5hbWUsIHJlc29sdmVkQWRkcmVzcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgcHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcykpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9yZXNvbHZlZEFkZHJlc3NcIiwgcmVzb2x2ZWRBZGRyZXNzKTtcbiAgICB9XG4gICAgc3VwcG9ydHNXaWxkY2FyZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0c0VpcDI1NDQpIHtcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzSW50ZXJmYWNlKGJ5dGVzNCA9IHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIikpXG4gICAgICAgICAgICB0aGlzLl9zdXBwb3J0c0VpcDI1NDQgPSB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogXCIweDAxZmZjOWE3OTA2MWI5MjMwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiXG4gICAgICAgICAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS5lcSgxKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUmV0aHJvdyB0aGUgZXJyb3I6IGxpbmsgaXMgZG93biwgZXRjLiBMZXQgZnV0dXJlIGF0dGVtcHRzIHJldHJ5LlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzRWlwMjU0NCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3VwcG9ydHNFaXAyNTQ0O1xuICAgIH1cbiAgICBfZmV0Y2goc2VsZWN0b3IsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGUuZy4ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyLHVpbnQyNTYpXCIpXG4gICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGNjaXBSZWFkRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCBuYW1laGFzaCh0aGlzLm5hbWUpLCAocGFyYW1ldGVycyB8fCBcIjB4XCIpXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaWxkY2FyZCBzdXBwb3J0OyB1c2UgRUlQLTI1NDQgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgbGV0IHBhcnNlQnl0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh5aWVsZCB0aGlzLnN1cHBvcnRzV2lsZGNhcmQoKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlQnl0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHNlbGVjdG9yKFwicmVzb2x2ZShieXRlcyxieXRlcylcIilcbiAgICAgICAgICAgICAgICB0eC5kYXRhID0gaGV4Q29uY2F0KFtcIjB4OTA2MWI5MjNcIiwgZW5jb2RlQnl0ZXMoW2Ruc0VuY29kZSh0aGlzLm5hbWUpLCB0eC5kYXRhXSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh0eCk7XG4gICAgICAgICAgICAgICAgaWYgKChhcnJheWlmeShyZXN1bHQpLmxlbmd0aCAlIDMyKSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlc29sdmVyIHRocmV3IGVycm9yXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCwgZGF0YTogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfcGFyc2VCeXRlcyhyZXN1bHQsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2ZldGNoQnl0ZXMoc2VsZWN0b3IsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuX2ZldGNoKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcGFyc2VCeXRlcyhyZXN1bHQsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY29pbkluZm8gPSBjb2luSW5mb3NbU3RyaW5nKGNvaW5UeXBlKV07XG4gICAgICAgIGlmIChjb2luSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgY29pbiB0eXBlOiAke2NvaW5UeXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pbkluZm8uaWxrID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhoZXhCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShoZXhCeXRlcyk7XG4gICAgICAgIC8vIFAyUEtIOiBPUF9EVVAgT1BfSEFTSDE2MCA8cHViS2V5SGFzaD4gT1BfRVFVQUxWRVJJRlkgT1BfQ0hFQ0tTSUdcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAycGtoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG4gICAgICAgICAgICBpZiAocDJwa2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChwMnBraFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJwa2hdLCAoXCIweFwiICsgcDJwa2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQMlNIOiBPUF9IQVNIMTYwIDxzY3JpcHRIYXNoPiBPUF9FUVVBTFxuICAgICAgICBpZiAoY29pbkluZm8ucDJzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnNoID0gaGV4Qnl0ZXMubWF0Y2goL14weGE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4NyQvKTtcbiAgICAgICAgICAgIGlmIChwMnNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJzaFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnNoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoICogMiAmJiBsZW5ndGggPj0gMSAmJiBsZW5ndGggPD0gNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZShjb25jYXQoW1tjb2luSW5mby5wMnNoXSwgKFwiMHhcIiArIHAyc2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCZWNoMzJcbiAgICAgICAgaWYgKGNvaW5JbmZvLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlc1sxXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAxNDEubWVkaWF3aWtpI3dpdG5lc3MtcHJvZ3JhbVxuICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBieXRlc1swXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMjAgJiYgbGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMCAmJiBieXRlcy5sZW5ndGggPT09IDIgKyBsZW5ndGggJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhieXRlcy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVjaDMyLmVuY29kZShjb2luSW5mby5wcmVmaXgsIHdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgRXRoZXJldW0sIHVzZSB0aGUgc3RhbmRhcmQgYGFkZHIoYnl0ZXMzMilgXG4gICAgICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9mZXRjaChcIjB4M2IzYjU3ZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiIHx8IHJlc3VsdCA9PT0gSGFzaFplcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImFkZHIoYnl0ZXMzMix1aW50MjU2XCIpXG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGYxY2I3ZTA2XCIsIGJ5dGVzMzJpZnkoY29pblR5cGUpKTtcbiAgICAgICAgICAgIC8vIE5vIGFkZHJlc3NcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIGFkZHJlc3NcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGNvaW5UeXBlLCBoZXhCeXRlcyk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29pbiBkYXRhYCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgLFxuICAgICAgICAgICAgICAgICAgICBjb2luVHlwZTogY29pblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEF2YXRhcigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmthZ2UgPSBbeyB0eXBlOiBcIm5hbWVcIiwgY29udGVudDogdGhpcy5uYW1lIH1dO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IGRhdGEgZm9yIHJpY21vby5ldGhcbiAgICAgICAgICAgICAgICAvL2NvbnN0IGF2YXRhciA9IFwiZWlwMTU1OjEvZXJjNzIxOjB4MjY1Mzg1YzdmNDEzMjIyOEEwZDU0RUIxQTllNzQ2MGI5MWMwY0M2OC8yOTIzM1wiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHRoaXMuZ2V0VGV4dChcImF2YXRhclwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYXZhdGFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBhdmF0YXIubWF0Y2gobWF0Y2hlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1lID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJodHRwc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImRhdGFcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYXZhdGFyIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaXBmc1wiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwiaXBmc1wiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBnZXRJcGZzTGluayhhdmF0YXIpIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjNzIxXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXJjMTE1NVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBFUkMgdHlwZSwgdXNlIHRva2VuVVJJKHVpbnQyNTYpIG9yIHVybCh1aW50MjU2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikgPyBcIjB4Yzg3YjU2ZGRcIiA6IFwiMHgwZTg5MzQxY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IHNjaGVtZSwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvd25lciBvZiB0aGlzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvd25lciA9ICh0aGlzLl9yZXNvbHZlZEFkZHJlc3MgfHwgKHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcHMgPSAobWF0Y2hbMl0gfHwgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGNvbXBzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbklkID0gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbShjb21wc1sxXSkudG9IZXhTdHJpbmcoKSwgMzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGhpcyBhY2NvdW50IG93bnMgdGhlIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtZSA9PT0gXCJlcmM3MjFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvd25lck9mKHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Pd25lciA9IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4NjM1MjIxMWVcIiwgdG9rZW5JZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG93bmVyICE9PSB0b2tlbk93bmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm93bmVyXCIsIGNvbnRlbnQ6IHRva2VuT3duZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtZSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIsIHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IEJpZ051bWJlci5mcm9tKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4MDBmZGQ1OGVcIiwgaGV4WmVyb1BhZChvd25lciwgMzIpLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIGNvbnRlbnQ6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmwtYmFzZVwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFUkMtMTE1NSBhbGxvd3MgYSBnZW5lcmljIHtpZH0gaW4gdGhlIFVSTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWUgPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9rZW5JZC5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhLXVybC1leHBhbmRlZFwiLCBjb250ZW50OiBtZXRhZGF0YVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbWV0YWRhdGEgbGlua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwubWF0Y2goL15pcGZzOi9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVVybCA9IGdldElwZnNMaW5rKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0b2tlbiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0geWllbGQgZmV0Y2hKc29uKG1ldGFkYXRhVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdWxsIHRoZSBpbWFnZSBVUkwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlVXJsID0gbWV0YWRhdGEuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaW1hZ2VVcmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2VVcmwubWF0Y2goL14oaHR0cHM6XFwvXFwvfGRhdGE6KS9pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIElQRlMgbGluayB0byBnYXRld2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlwZnMgPSBpbWFnZVVybC5tYXRjaChtYXRjaGVySXBmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpcGZzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IFwidXJsLWlwZnNcIiwgY29udGVudDogaW1hZ2VVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsID0gZ2V0SXBmc0xpbmsoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBpbWFnZVVybCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGltYWdlVXJsIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIik7XG4gICAgICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiBEQUctUEIpXG4gICAgICAgICAgICBjb25zdCBpcGZzID0gaGV4Qnl0ZXMubWF0Y2goL14weGUzMDEwMTcwKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChpcGZzWzRdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpcGZzOi9cXC9cIiArIEJhc2U1OC5lbmNvZGUoXCIweFwiICsgaXBmc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICAgICAgY29uc3Qgc3dhcm0gPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgICAgIGlmIChzd2FybSkge1xuICAgICAgICAgICAgICAgIGlmIChzd2FybVsxXS5sZW5ndGggPT09ICgzMiAqIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJ6ejovXFwvXCIgKyBzd2FybVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgZW5jb2RlZCBhcyBwYXJhbWV0ZXIgdG8gZmV0Y2hCeXRlc1xuICAgICAgICAgICAgbGV0IGtleUJ5dGVzID0gdG9VdGY4Qnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIC8vIFRoZSBub2RlaGFzaCBjb25zdW1lcyB0aGUgZmlyc3Qgc2xvdCwgc28gdGhlIHN0cmluZyBwb2ludGVyIHRhcmdldHNcbiAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcbiAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtieXRlczMyaWZ5KDY0KSwgYnl0ZXMzMmlmeShrZXlCeXRlcy5sZW5ndGgpLCBrZXlCeXRlc10pO1xuICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG4gICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtrZXlCeXRlcywgaGV4WmVyb1BhZChcIjB4XCIsIDMyIC0gKGtleS5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweDU5ZDFkNDNjXCIsIGhleGxpZnkoa2V5Qnl0ZXMpKTtcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoaGV4Qnl0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5sZXQgbmV4dFBvbGxJZCA9IDE7XG5leHBvcnQgY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICByZWFkeVxuICAgICAqXG4gICAgICogIEEgUHJvbWlzZTxOZXR3b3JrPiB0aGF0IHJlc29sdmVzIG9ubHkgb25jZSB0aGUgcHJvdmlkZXIgaXMgcmVhZHkuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgdGhhdCBjYWxsIHRoZSBzdXBlciB3aXRoIGEgbmV0d29yayB3aXRob3V0IGEgY2hhaW5JZFxuICAgICAqICBNVVNUIHNldCB0aGlzLiBTdGFuZGFyZCBuYW1lZCBuZXR3b3JrcyBoYXZlIGEga25vd24gY2hhaW5JZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmspIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIFByb3ZpZGVyKTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gRXZlbnRzIGJlaW5nIGxpc3RlbmVkIHRvXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0dGVkID0geyBibG9jazogLTIgfTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2NpcFJlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcudGFyZ2V0LmdldEZvcm1hdHRlcigpO1xuICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBuZXR3b3JrXG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYW55TmV0d29ya1wiLCAobmV0d29yayA9PT0gXCJhbnlcIikpO1xuICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUHJvbWlzZSA9IG5ldHdvcms7XG4gICAgICAgICAgICAvLyBTcXVhc2ggYW55IFwidW5oYW5kbGVkIHByb21pc2VcIiBlcnJvcnM7IHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgaGFuZGxlZFxuICAgICAgICAgICAgbmV0d29yay5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgbmV0d29yayBzZXR0aW5nIChhc3luYylcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5KCkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga25vd25OZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5fbWF4RmlsdGVyQmxvY2tSYW5nZSA9IDEwO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICB9XG4gICAgX3JlYWR5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBuZXR3b3JrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29ya1Byb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9uZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIFByb3ZpZGVyJ3MgbmV0d29yayBkZXRlY3Rpb24gKHRoaXMgTVVTVCB0aHJvdyBpZiBpdCBjYW5ub3QpXG4gICAgICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG4gICAgICAgICAgICAgICAgLy8gc3VnZ2VzdGVkIGEgbmV0d29yayBieSBoZXJlIChvciBoYXZlIHRocm93bikuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBMb2dnZXIuZXJyb3JzLlVOS05PV05fRVJST1IsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFueU5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIG5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cbiAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG4gICAgLy8gYW55IGNoYW5nZSBpcyByZWZsZWN0ZWQpOyBvdGhlcndpc2UgdGhpcyBjYW5ub3QgY2hhbmdlXG4gICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHkoKS50aGVuKChuZXR3b3JrKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiAmJiBlcnJvci5ldmVudCA9PT0gXCJub05ldHdvcmtcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IGNyZWF0ZSBhIHNpbmdsZXRvbiBmb3JtYXR0ZXJcbiAgICBzdGF0aWMgZ2V0Rm9ybWF0dGVyKCkge1xuICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0Rm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Rm9ybWF0dGVyO1xuICAgIH1cbiAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcbiAgICBzdGF0aWMgZ2V0TmV0d29yayhuZXR3b3JrKSB7XG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKChuZXR3b3JrID09IG51bGwpID8gXCJob21lc3RlYWRcIiA6IG5ldHdvcmspO1xuICAgIH1cbiAgICBjY2lwUmVhZEZldGNoKHR4LCBjYWxsZGF0YSwgdXJscykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNjaXBSZWFkIHx8IHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZW5kZXIgPSAodHguZnJvbSB8fCBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNhbGxkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSB1cmxzW2ldO1xuICAgICAgICAgICAgICAgIC8vIFVSTCBleHBhbnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gdXJsLnJlcGxhY2UoXCJ7c2VuZGVyfVwiLCBzZW5kZXIpLnJlcGxhY2UoXCJ7ZGF0YX1cIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8ge2RhdGF9IGlzIHByZXNlbnQsIHVzZSBQT1NUOyBvdGhlcndpc2UgR0VUXG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9ICh1cmwuaW5kZXhPZihcIntkYXRhfVwiKSA+PSAwKSA/IG51bGwgOiBKU09OLnN0cmluZ2lmeSh7IGRhdGEsIHNlbmRlciB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBmZXRjaEpzb24oeyB1cmw6IGhyZWYsIGVycm9yUGFzc1Rocm91Z2g6IHRydWUgfSwganNvbiwgKHZhbHVlLCByZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zdGF0dXMgPSByZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKHJlc3VsdC5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAvLyA0eHggaW5kaWNhdGVzIHRoZSByZXN1bHQgaXMgbm90IHByZXNlbnQ7IHN0b3BcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA+PSA0MDAgJiYgcmVzdWx0LnN0YXR1cyA8IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYHJlc3BvbnNlIG5vdCBmb3VuZCBkdXJpbmcgQ0NJUCBmZXRjaDogJHtlcnJvck1lc3NhZ2V9YCwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHsgdXJsLCBlcnJvck1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIDV4eCBpbmRpY2F0ZXMgc2VydmVyIGlzc3VlOyB0cnkgdGhlIG5leHQgdXJsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlcy5wdXNoKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGVycm9yIGVuY291bnRlcmVkIGR1cmluZyBDQ0lQIGZldGNoOiAke2Vycm9yTWVzc2FnZXMubWFwKChtKSA9PiBKU09OLnN0cmluZ2lmeShtKSkuam9pbihcIiwgXCIpfWAsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgdXJscywgZXJyb3JNZXNzYWdlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3NcbiAgICAvLyB0aGFuIG1heEFnZSBvbGQgb3IgaGFzIGJlZW4gcmVxdWVzdGVkIHNpbmNlIHRoZSBsYXN0IHJlcXVlc3RcbiAgICBfZ2V0SW50ZXJuYWxCbG9ja051bWJlcihtYXhBZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3JlYWR5KCk7XG4gICAgICAgICAgICAvLyBBbGxvd2luZyBzdGFsZSBkYXRhIHVwIHRvIG1heEFnZSBvbGRcbiAgICAgICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgdGhlcmUgYXJlIHBlbmRpbmcgaW50ZXJuYWwgYmxvY2sgcmVxdWVzdHMuLi5cbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLi5cInJlbWVtYmVyXCIgd2hpY2ggZmV0Y2ggd2Ugc3RhcnRlZCB3aXRoXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlc3VsdCBpcyBub3QgdG9vIHN0YWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBpbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChnZXRUaW1lKCkgLSByZXN1bHQucmVzcFRpbWUpIDw9IG1heEFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUb28gb2xkOyBmZXRjaCBhIG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZmV0Y2ggcmVqZWN0ZWQ7IGlmIHdlIGFyZSB0aGUgZmlyc3QgdG8gZ2V0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW9uLCBkcm9wIHRocm91Z2ggc28gd2UgcmVwbGFjZSBpdCB3aXRoIGEgbmV3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmZXRjaDsgYWxsIG90aGVycyBibG9ja2VkIHdpbGwgdGhlbiBnZXQgdGhhdCBmZXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggd29uJ3QgbWF0Y2ggdGhlIG9uZSB0aGV5IFwicmVtZW1iZXJlZFwiIGFuZCBsb29wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gaW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVxVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tOdW1iZXJcIiwge30pLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogdGhpcy5nZXROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4gKG51bGwpLCAoZXJyb3IpID0+IChlcnJvcikpXG4gICAgICAgICAgICB9KS50aGVuKCh7IGJsb2NrTnVtYmVyLCBuZXR3b3JrRXJyb3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5yZW1lbWJlciB0aGlzIGJhZCBpbnRlcm5hbCBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwVGltZSA9IGdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IEJpZ051bWJlci5mcm9tKGJsb2NrTnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cbiAgICAgICAgICAgICAgICByZXR1cm4geyBibG9ja051bWJlciwgcmVxVGltZSwgcmVzcFRpbWUgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgdW5oYW5kbGVkIGV4Y2VwdGlvbnM7IGlmIG5lZWRlZCB0aGV5IGFyZSBoYW5kbGVkIGVsc2Ugd2hlcmVcbiAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlci5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBudWxsIHRoZSBkZWFkIChyZWplY3RlZCkgZmV0Y2gsIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gdXBkYXRlZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcikuYmxvY2tOdW1iZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb2xsKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcG9sbElkID0gbmV4dFBvbGxJZCsrO1xuICAgICAgICAgICAgLy8gVHJhY2sgYWxsIHJ1bm5pbmcgcHJvbWlzZXMsIHNvIHdlIGNhbiB0cmlnZ2VyIGEgcG9zdC1wb2xsIG9uY2UgdGhleSBhcmUgY29tcGxldGVcbiAgICAgICAgICAgIGNvbnN0IHJ1bm5lcnMgPSBbXTtcbiAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBFbWl0IGEgcG9sbCBldmVudCBhZnRlciB3ZSBoYXZlIHRoZSBsYXRlc3QgKGZhc3QpIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgdGhpcy5lbWl0KFwicG9sbFwiLCBwb2xsSWQsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cbiAgICAgICAgICAgIGlmIChibG9ja051bWJlciA9PT0gdGhpcy5fbGFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGUsIHRyaWdnZXIgYSBcImJsb2NrXCIgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgbmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHMgKGVtaXR0ZWQ9JHt0aGlzLl9lbWl0dGVkLmJsb2NrfSBibG9ja051bWJlciR7YmxvY2tOdW1iZXJ9KWApO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGxvZ2dlci5tYWtlRXJyb3IoXCJuZXR3b3JrIGJsb2NrIHNrZXcgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQmxvY2tOdW1iZXI6IHRoaXMuX2VtaXR0ZWQuYmxvY2tcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZW1pdHRlZC5ibG9jayArIDE7IGkgPD0gYmxvY2tOdW1iZXI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgIT09IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgZXZlbnQgZG9lcyBub3QgZXhwaXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYmxvY2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayB3ZSB3ZXJlIGF0IHdoZW4gd2UgZW1pdHRlZCB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QmxvY2tOdW1iZXIgPSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNhbm5vdCBnYXJiYWdlIGNvbGxlY3QgcGVuZGluZyB0cmFuc2FjdGlvbnMgb3IgYmxvY2tzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBcInBlbmRpbmdcIiBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50QmxvY2tOdW1iZXIgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRXZpY3QgYW55IHRyYW5zYWN0aW9uIGhhc2hlcyBvciBibG9jayBoYXNoZXMgb3ZlciAxMiBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgLSBldmVudEJsb2NrTnVtYmVyID4gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9lbWl0dGVkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpcnN0IHBvbGxpbmcgY3ljbGVcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBldmVudC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bm5lciA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGhhc2gpLnRoZW4oKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1widDpcIiArIGhhc2hdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGEgc2luZ2xlIGdldExvZ3MgdG8gYmUgaW4tZmxpZ2h0IGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5faW5mbGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlciBmcm9tIHRoZSBsYXN0IGtub3duIGV2ZW50OyBkdWUgdG8gbG9hZC1iYWxhbmNpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc29tZSBub2RlcyByZXR1cm5pbmcgdXBkYXRlZCBibG9jayBudW1iZXJzIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4aW5nIGV2ZW50cywgYSBsb2dzIHJlc3VsdCB3aXRoIDAgZW50cmllcyBjYW5ub3QgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVzdGVkIGFuZCB3ZSBtdXN0IHJldHJ5IGEgcmFuZ2Ugd2hpY2ggaW5jbHVkZXMgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBldmVudC5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBmaXRsZXIgcmFuZ2VzIGZyb20gZ3Jvd2luZyB0b28gd2lsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIudG9CbG9jayAtIHRoaXMuX21heEZpbHRlckJsb2NrUmFuZ2UgPiBmaWx0ZXIuZnJvbUJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlci5mcm9tQmxvY2sgPSBmaWx0ZXIudG9CbG9jayAtIHRoaXMuX21heEZpbHRlckJsb2NrUmFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5lciA9IHRoaXMuZ2V0TG9ncyhmaWx0ZXIpLnRoZW4oKGxvZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIG5leHQgZ2V0TG9nc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5faW5mbGlnaHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9ncy5mb3JFYWNoKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgd2hlbiB3ZSBnZXQgYW4gZXZlbnQgZm9yIGEgZ2l2ZW4gYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW4gd2UgdHJ1c3QgdGhlIGV2ZW50cyBhcmUgaW5kZXhlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja051bWJlciA+IGV2ZW50Ll9sYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5fbGFzdEJsb2NrTnVtYmVyID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIHN0YWxsIHJlcXVlc3RzIHRvIGZldGNoIGJsb2NrcyBhbmQgdHhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkW1wiYjpcIiArIGxvZy5ibG9ja0hhc2hdID0gbG9nLmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBsb2cudHJhbnNhY3Rpb25IYXNoXSA9IGxvZy5ibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGFub3RoZXIgZ2V0TG9ncyAodGhlIHJhbmdlIHdhcyBub3QgdXBkYXRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2luZmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycy5wdXNoKHJ1bm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAvLyBPbmNlIGFsbCBldmVudHMgZm9yIHRoaXMgbG9vcCBoYXZlIGJlZW4gcHJvY2Vzc2VkLCBlbWl0IFwiZGlkUG9sbFwiXG4gICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuICAgIHJlc2V0RXZlbnRzQmxvY2soYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuICAgICAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG4gICAgLy8gY2FuIGNoYW5nZSwgc3VjaCBhcyB3aGVuIGNvbm5lY3RlZCB0byBhIEpTT04tUlBDIGJhY2tlbmRcbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJwcm92aWRlci5kZXRlY3ROZXR3b3JrXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmsgPSB5aWVsZCB0aGlzLl9yZWFkeSgpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGFyZSBzdGlsbCBjb25uZWN0ZWQgdG8gdGhlIHNhbWUgbmV0d29yazsgdGhpcyBpc1xuICAgICAgICAgICAgLy8gb25seSBhbiBleHRlcm5hbCBjYWxsIGZvciBiYWNrZW5kcyB3aGljaCBjYW4gaGF2ZSB0aGUgdW5kZXJseWluZ1xuICAgICAgICAgICAgLy8gbmV0d29yayBjaGFuZ2Ugc3BvbnRhbmVvdXNseVxuICAgICAgICAgICAgY29uc3QgY3VycmVudE5ldHdvcmsgPSB5aWVsZCB0aGlzLmRldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IGN1cnJlbnROZXR3b3JrLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgYWxsb3dpbmcgbmV0d29yayBjaGFuZ2VzLCB0aGluZ3MgY2FuIGdldCBjb21wbGV4IGZhc3Q7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZyBpZiB5b3UgdXNlIFwiYW55XCJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBjdXJyZW50TmV0d29yaztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIGludGVybmFsIGJsb2NrIG51bWJlciBndWFyZHMgYW5kIGNhY2hlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0dGVkLmJsb2NrID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21heEludGVybmFsQmxvY2tOdW1iZXIgPSAtMTAyNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcIm5ldHdvcmtcIiBldmVudCBNVVNUIGhhcHBlbiBiZWZvcmUgdGhpcyBtZXRob2QgcmVzb2x2ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gYW55IGV2ZW50cyBoYXZlIGEgY2hhbmNlIHRvIHVucmVnaXN0ZXIsIHNvIHdlIHN0YWxsIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgZXZlbnQgbG9vcCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gL3RoaXMvIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBjdXJyZW50TmV0d29yaywgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsKDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBsb2dnZXIubWFrZUVycm9yKFwidW5kZXJseWluZyBuZXR3b3JrIGNoYW5nZWRcIiwgTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImNoYW5nZWRcIixcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogbmV0d29yayxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWROZXR3b3JrOiBjdXJyZW50TmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGJsb2NrTnVtYmVyKCkge1xuICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMikudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG4gICAgICAgIH0sIChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcbiAgICB9XG4gICAgZ2V0IHBvbGxpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcG9sbGVyICE9IG51bGwpO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnBvbGwoKTsgfSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgYmxvY2sgYWRkaXRpb25hbCBwb2xscyB1bnRpbCB0aGUgcG9sbGluZyBpbnRlcnZhbFxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBkb25lLCB0byBwcmV2ZW50IG92ZXJ3aGVsbWluZyB0aGUgcG9sbCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib290c3RyYXBQb2xsID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwb2xsaW5nIHdhcyBkaXNhYmxlZCwgc29tZXRoaW5nIG1heSByZXF1aXJlIGEgcG9rZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugc3RhcnRpbmcgdGhlIGJvb3RzdHJhcCBwb2xsIGFuZCBpdCB3YXMgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBvdXQgdGhlIGJvb3RzdHJhcCBzbyB3ZSBjYW4gZG8gYW5vdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG4gICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2xsaW5nSW50ZXJ2YWw7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nSW50ZXJ2YWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB0aGlzLnBvbGwoKTsgfSwgdGhpcy5fcG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RmFzdEJsb2NrTnVtYmVyKCkge1xuICAgICAgICBjb25zdCBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIFN0YWxlIGJsb2NrIG51bWJlciwgcmVxdWVzdCBhIG5ld2VyIHZhbHVlXG4gICAgICAgIGlmICgobm93IC0gdGhpcy5fZmFzdFF1ZXJ5RGF0ZSkgPiAyICogdGhpcy5fcG9sbGluZ0ludGVydmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IHRoaXMuZ2V0QmxvY2tOdW1iZXIoKS50aGVuKChibG9ja051bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPT0gbnVsbCB8fCBibG9ja051bWJlciA+IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlO1xuICAgIH1cbiAgICBfc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIE9sZGVyIGJsb2NrLCBtYXliZSBhIHN0YWxlIHJlcXVlc3RcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciAhPSBudWxsICYmIGJsb2NrTnVtYmVyIDwgdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB0aW1lIHdlIHVwZGF0ZWQgdGhlIGJsb2NrbnVtYmVyXG4gICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBnZXRUaW1lKCk7XG4gICAgICAgIC8vIE5ld2VyIGJsb2NrIG51bWJlciwgdXNlICBpdFxuICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShibG9ja051bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIChjb25maXJtYXRpb25zID09IG51bGwpID8gMSA6IGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQgfHwgMCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfd2FpdEZvclRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCwgY29uZmlybWF0aW9ucywgdGltZW91dCwgcmVwbGFjZWFibGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgLy8gUmVjZWlwdCBpcyBhbHJlYWR5IGdvb2RcbiAgICAgICAgICAgIGlmICgocmVjZWlwdCA/IHJlY2VpcHQuY29uZmlybWF0aW9ucyA6IDApID49IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvbGwgdW50aWwgdGhlIHJlY2VpcHQgaXMgZ29vZC4uLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxGdW5jcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeURvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4geyBmdW5jKCk7IH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5lZEhhbmRsZXIgPSAocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5jb25maXJtYXRpb25zIDwgY29uZmlybWF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHJlYWR5RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMub24odHJhbnNhY3Rpb25IYXNoLCBtaW5lZEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyB0aGlzLnJlbW92ZUxpc3RlbmVyKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0QmxvY2tOdW1iZXIgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2Nhbm5lZEJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZUhhbmRsZXIgPSAoYmxvY2tOdW1iZXIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCAxIHNlY29uZDsgdGhpcyBpcyBvbmx5IHVzZWQgaW4gdGhlIGNhc2Ugb2YgYSBmYXVsdCwgc29cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgdHJhZGUgb2ZmIGEgbGl0dGxlIGJpdCBvZiBsYXRlbmN5IGZvciBtb3JlIGNvbnNpc3RlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3VsdHMgYW5kIGZld2VyIEpTT04tUlBDIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25Db3VudChyZXBsYWNlYWJsZS5mcm9tKS50aGVuKChub25jZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vbmNlIDw9IHJlcGxhY2VhYmxlLm5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBtaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtaW5lZCA9IHlpZWxkIHRoaXMuZ2V0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5lZCAmJiBtaW5lZC5ibG9ja051bWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgc2Nhbm5pbmcuIFdlIHN0YXJ0IGEgbGl0dGxlIGVhcmxpZXIgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lnZ2xlIHJvb20gaGVyZSB0byBoYW5kbGUgdGhlIGV2ZW50dWFsbHkgY29uc2lzdGVudCBuYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmxvY2tjaGFpbiAoZS5nLiB0aGUgZ2V0VHJhbnNhY3Rpb25Db3VudCB3YXMgZm9yIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW50IGJsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jayA9IGxhc3RCbG9ja051bWJlciAtIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Nhbm5lZEJsb2NrIDwgcmVwbGFjZWFibGUuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5uZWRCbG9jayA9IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHNjYW5uZWRCbG9jayA8PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKHNjYW5uZWRCbG9jayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB0aSA9IDA7IHRpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aDsgdGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW3RpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgbWluZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lmhhc2ggPT09IHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZXMgb3VyIHRyYW5zYWN0aW9uIGZyb20gYW5kIG5vbmNlOyBpdHMgYSByZXBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5mcm9tID09PSByZXBsYWNlYWJsZS5mcm9tICYmIHR4Lm5vbmNlID09PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IHJlc29sdmVkIG9yIHJlamVjdGVkIChwcm9sbHkgYSB0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2Ugd2VyZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVhc29uID0gXCJyZXBsYWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZGF0YSA9PT0gcmVwbGFjZWFibGUuZGF0YSAmJiB0eC50byA9PT0gcmVwbGFjZWFibGUudG8gJiYgdHgudmFsdWUuZXEocmVwbGFjZWFibGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcInJlcHJpY2VkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguZGF0YSA9PT0gXCIweFwiICYmIHR4LmZyb20gPT09IHR4LnRvICYmIHR4LnZhbHVlLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcImNhbmNlbGxlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxhaW4gd2h5IHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWRcIiwgTG9nZ2VyLmVycm9ycy5UUkFOU0FDVElPTl9SRVBMQUNFRCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsbGVkOiAocmVhc29uID09PSBcInJlcGxhY2VkXCIgfHwgcmVhc29uID09PSBcImNhbmNlbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50OiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2srKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZShcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImJsb2NrXCIsIHJlcGxhY2VIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRpbWVvdXQpID09PSBcIm51bWJlclwiICYmIHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dCBleGNlZWRlZFwiLCBMb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHsgdGltZW91dDogdGltZW91dCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRnVuY3MucHVzaCgoKSA9PiB7IGNsZWFyVGltZW91dCh0aW1lcik7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvY2tOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEdhc1ByaWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEdhc1ByaWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJhbGFuY2UoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldEJhbGFuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFRyYW5zYWN0aW9uQ291bnRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb2RlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0Q29kZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldENvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTdG9yYWdlQXQoYWRkcmVzc09yTmFtZSwgcG9zaXRpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbigocCkgPT4gaGV4VmFsdWUocCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFN0b3JhZ2VBdFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4bGlmeShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3VsdCBmcm9tIGJhY2tlbmRcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcImdldFN0b3JhZ2VBdFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBieSBhbnkgc3ViY2xhc3Mgd3JhcHBpbmcgYSBUcmFuc2FjdGlvblJlc3BvbnNlXG4gICAgX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgc3RhcnRCbG9jaykge1xuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIGhleERhdGFMZW5ndGgoaGFzaCkgIT09IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHR4O1xuICAgICAgICAvLyBDaGVjayB0aGUgaGFzaCB3ZSBleHBlY3QgaXMgdGhlIHNhbWUgYXMgdGhlIGhhc2ggdGhlIHNlcnZlciByZXBvcnRlZFxuICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiVHJhbnNhY3Rpb24gaGFzaCBtaXNtYXRjaCBmcm9tIFByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbi5cIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53YWl0ID0gKGNvbmZpcm1zLCB0aW1lb3V0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpcm1zID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGV0YWlscyB0byBkZXRlY3QgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGxldCByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maXJtcyAhPT0gMCAmJiBzdGFydEJsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogdHguZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHR4Lm5vbmNlLFxuICAgICAgICAgICAgICAgICAgICB0bzogdHgudG8sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRCbG9ja1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5fd2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1zLCB0aW1lb3V0LCByZXBsYWNlbWVudCk7XG4gICAgICAgICAgICBpZiAocmVjZWlwdCA9PSBudWxsICYmIGNvbmZpcm1zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBsb25nZXIgcGVuZGluZywgYWxsb3cgdGhlIHBvbGxpbmcgbG9vcCB0byBnYXJiYWdlIGNvbGxlY3QgdGhpc1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRyYW5zYWN0aW9uIGZhaWxlZFwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogdHguaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHR4LFxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBoZXhUeCA9IHlpZWxkIFByb21pc2UucmVzb2x2ZShzaWduZWRUcmFuc2FjdGlvbikudGhlbih0ID0+IGhleGxpZnkodCkpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uSGFzaCA9IHR4Lmhhc2g7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB5aWVsZCB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0ge307XG4gICAgICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IHRoaXMuX2dldEFkZHJlc3ModikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcInZhbHVlXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBCaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgW1widHlwZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICgodiAhPSBudWxsKSA/IHYgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuYWNjZXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSB0aGlzLmZvcm1hdHRlci5hY2Nlc3NMaXN0KHZhbHVlcy5hY2Nlc3NMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAodiA/IGhleGxpZnkodikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlcXVlc3QoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGaWx0ZXIoZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmaWx0ZXIgPSB5aWVsZCBmaWx0ZXI7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLl9nZXRBZGRyZXNzKGZpbHRlci5hZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFtcImJsb2NrSGFzaFwiLCBcInRvcGljc1wiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZmlsdGVyW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcImZyb21CbG9ja1wiLCBcInRvQmxvY2tcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuX2dldEJsb2NrVGFnKGZpbHRlcltrZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmZpbHRlcih5aWVsZCByZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZywgYXR0ZW1wdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGF0dGVtcHQgPj0gTUFYX0NDSVBfUkVESVJFQ1RTKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDQ0lQIHJlYWQgZXhjZWVkZWQgbWF4aW11bSByZWRpcmVjdGlvbnNcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RzOiBhdHRlbXB0LCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhTZW5kZXIgPSB0cmFuc2FjdGlvbi50bztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImNhbGxcIiwgeyB0cmFuc2FjdGlvbiwgYmxvY2tUYWcgfSk7XG4gICAgICAgICAgICAvLyBDQ0lQIFJlYWQgcmVxdWVzdCB2aWEgT2ZmY2hhaW5Mb29rdXAoYWRkcmVzcyxzdHJpbmdbXSxieXRlcyxieXRlczQsYnl0ZXMpXG4gICAgICAgICAgICBpZiAoYXR0ZW1wdCA+PSAwICYmIGJsb2NrVGFnID09PSBcImxhdGVzdFwiICYmIHR4U2VuZGVyICE9IG51bGwgJiYgcmVzdWx0LnN1YnN0cmluZygwLCAxMCkgPT09IFwiMHg1NTZmMTgzMFwiICYmIChoZXhEYXRhTGVuZ3RoKHJlc3VsdCkgJSAzMiA9PT0gNCkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gaGV4RGF0YVNsaWNlKHJlc3VsdCwgNCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBzZW5kZXIgb2YgdGhlIE9mZmNoYWluTG9va3VwIG1hdGNoZXMgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbmRlciA9IGhleERhdGFTbGljZShkYXRhLCAwLCAzMik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQmlnTnVtYmVyLmZyb20oc2VuZGVyKS5lcSh0eFNlbmRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIHNlbmRlciBkaWQgbm90IG1hdGNoXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIFVSTHMgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJscyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cmxzT2Zmc2V0ID0gQmlnTnVtYmVyLmZyb20oaGV4RGF0YVNsaWNlKGRhdGEsIDMyLCA2NCkpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybHNMZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCwgdXJsc09mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsc0RhdGEgPSBoZXhEYXRhU2xpY2UoZGF0YSwgdXJsc09mZnNldCArIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB1cmxzTGVuZ3RoOyB1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IF9wYXJzZVN0cmluZyh1cmxzRGF0YSwgdSAqIDMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQ0NJUCBSZWFkIGNvbnRhaW5lZCBjb3JydXB0IFVSTCBzdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogXCJPZmZjaGFpbkxvb2t1cChhZGRyZXNzLHN0cmluZ1tdLGJ5dGVzLGJ5dGVzNCxieXRlcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sIGRhdGE6IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXJscy5wdXNoKHVybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBDQ0lQIGNhbGxkYXRhIHRvIGZvcndhcmRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGRhdGEgPSBfcGFyc2VCeXRlcyhkYXRhLCA2NCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY2FsbGJhY2tTZWxlY3RvciAoYnl0ZXM0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShkYXRhLCAxMDAsIDEyOCkpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBjYWxsYmFjayBzZWxlY3RvciBpbmNsdWRlZCBqdW5rXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrU2VsZWN0b3IgPSBoZXhEYXRhU2xpY2UoZGF0YSwgOTYsIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZXh0cmEgZGF0YSB0byBzZW5kIGJhY2sgdG8gdGhlIGNvbnRyYWN0IGFzIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmFEYXRhID0gX3BhcnNlQnl0ZXMoZGF0YSwgMTI4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2NpcFJlc3VsdCA9IHlpZWxkIHRoaXMuY2NpcFJlYWRGZXRjaCh0cmFuc2FjdGlvbiwgY2FsbGRhdGEsIHVybHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2NpcFJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNDSVAgUmVhZCBkaXNhYmxlZCBvciBwcm92aWRlZCBubyBVUkxzXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIk9mZmNoYWluTG9va3VwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBcIk9mZmNoYWluTG9va3VwKGFkZHJlc3Msc3RyaW5nW10sYnl0ZXMsYnl0ZXM0LGJ5dGVzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLCBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHR4U2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtjYWxsYmFja1NlbGVjdG9yLCBlbmNvZGVCeXRlcyhbY2NpcFJlc3VsdCwgZXh0cmFEYXRhXSldKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbCh0eCwgYmxvY2tUYWcsIGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHsgdHJhbnNhY3Rpb24sIGJsb2NrVGFnIH0sIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG4gICAgICAgICAgICAgICAgY2NpcFJlYWRFbmFibGVkOiBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24uY2NpcFJlYWRFbmFibGVkKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbChyZXNvbHZlZC50cmFuc2FjdGlvbiwgcmVzb2x2ZWQuYmxvY2tUYWcsIHJlc29sdmVkLmNjaXBSZWFkRW5hYmxlZCA/IDAgOiAtMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZXN0aW1hdGVHYXNcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiZXN0aW1hdGVHYXNcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzT3JOYW1lID0geWllbGQgYWRkcmVzc09yTmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGFkZHJlc3NPck5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgYWRkcmVzc09yTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkVOUyBuYW1lIG5vdCBjb25maWd1cmVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYHJlc29sdmVOYW1lKCR7SlNPTi5zdHJpbmdpZnkoYWRkcmVzc09yTmFtZSl9KWBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IHlpZWxkIGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICAvLyBJZiBibG9ja1RhZyBpcyBhIG51bWJlciAobm90IFwibGF0ZXN0XCIsIGV0YyksIHRoaXMgaXMgdGhlIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0gLTEyODtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoYmxvY2tIYXNoT3JCbG9ja1RhZywgMzIpKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmJsb2NrSGFzaCA9IGJsb2NrSGFzaE9yQmxvY2tUYWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tUYWcgPSB5aWVsZCB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja0hhc2hPckJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9jayBoYXNoIG9yIGJsb2NrIHRhZ1wiLCBcImJsb2NrSGFzaE9yQmxvY2tUYWdcIiwgYmxvY2tIYXNoT3JCbG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmxvY2tcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBCbG9jayB3YXMgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgZXhpc3QuIElmIHdlIGRpZCBzZWUgaXQgdGhvdWdoLCBwZXJoYXBzIGZyb20gYSBsb2csIHdlIGtub3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZXhpc3RzLCBhbmQgdGhpcyBub2RlIGlzIGp1c3Qgbm90IGNhdWdodCB1cCB5ZXQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1wiYjpcIiArIHBhcmFtcy5ibG9ja0hhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmxvY2sgdGFncywgaWYgd2UgYXJlIGFza2luZyBmb3IgYSBmdXR1cmUgYmxvY2ssIHdlIHJldHVybiBudWxsXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gdGhpcy5fZW1pdHRlZC5ibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHggPSBibG9jay50cmFuc2FjdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZmlybWF0aW9ucyB1c2luZyB0aGUgZmFzdCBibG9jayBudW1iZXIgKHBlc3NpbWlzdGljKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja1dpdGhUeHMgPSB0aGlzLmZvcm1hdHRlci5ibG9ja1dpdGhUcmFuc2FjdGlvbnMoYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zID0gYmxvY2tXaXRoVHhzLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrV2l0aFR4cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrKGJsb2NrKTtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dldEJsb2NrKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGZhbHNlKSk7XG4gICAgfVxuICAgIGdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9ja0hhc2hPckJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgdHJ1ZSkpO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvblJlc3BvbnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmJsb2NrTnVtYmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgdHJhbnNhY3Rpb25IYXNoOiB0aGlzLmZvcm1hdHRlci5oYXNoKHRyYW5zYWN0aW9uSGFzaCwgdHJ1ZSkgfTtcbiAgICAgICAgICAgIHJldHVybiBwb2xsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBcImdldGgtZXRjXCIgcmV0dXJucyByZWNlaXB0cyBiZWZvcmUgdGhleSBhcmUgcmVhZHlcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB0aGlzLmZvcm1hdHRlci5yZWNlaXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWNlaXB0LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gcmVjZWlwdC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZWNlaXB0LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWlwdDtcbiAgICAgICAgICAgIH0pLCB7IG9uY2VQb2xsOiB0aGlzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TG9ncyhmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXMoeyBmaWx0ZXI6IHRoaXMuX2dldEZpbHRlcihmaWx0ZXIpIH0pO1xuICAgICAgICAgICAgY29uc3QgbG9ncyA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RXRoZXJQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybShcImdldEV0aGVyUHJpY2VcIiwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9IHlpZWxkIGJsb2NrVGFnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYmxvY2tUYWcpID09PSBcIm51bWJlclwiICYmIGJsb2NrVGFnIDwgMCkge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmxvY2tUYWdcIiwgXCJibG9ja1RhZ1wiLCBibG9ja1RhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciArPSBibG9ja1RhZztcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXNvbHZlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudE5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IFwiXCIgfHwgY3VycmVudE5hbWUgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gc2luY2UgdGhlIGV0aCBub2RlIGNhbm5vdCBjaGFuZ2UgYW5kIGRvZXNcbiAgICAgICAgICAgICAgICAvLyBub3QgaGF2ZSBhIHdpbGRjYXIgcmVzb2x2ZXJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJldGhcIiAmJiBjdXJyZW50TmFtZSA9PT0gXCJldGhcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSBmb3IgYSByZXNvbHZlclxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihjdXJyZW50TmFtZSwgXCJnZXRSZXNvbHZlclwiKTtcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHJlc29sdmVyIVxuICAgICAgICAgICAgICAgIGlmIChhZGRyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIodGhpcywgYWRkciwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSByZXNvbHZlciBmb3VuZCwgdXNpbmcgRUlQLTI1NDQgc28gaXQgaXNuJ3Qgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lICE9PSBuYW1lICYmICEoeWllbGQgcmVzb2x2ZXIuc3VwcG9ydHNXaWxkY2FyZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgY3VycmVudE5hbWUgPSBjdXJyZW50TmFtZS5zcGxpdChcIi5cIikuc2xpY2UoMSkuam9pbihcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UmVzb2x2ZXIobmFtZSwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSBcIkVOU1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gTm8gRU5TLi4uXG4gICAgICAgICAgICBpZiAoIW5ldHdvcmsuZW5zQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb24sIG5ldHdvcms6IG5ldHdvcmsubmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwicmVzb2x2ZXIoYnl0ZXMzMilcIilcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyRGF0YSA9IHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIHRvOiBuZXR3b3JrLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4MDE3OGI4YmZcIiArIG5hbWVoYXNoKG5hbWUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuY2FsbEFkZHJlc3MoYWRkckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gRU5TIHJlZ2lzdHJ5IGNhbm5vdCB0aHJvdyBlcnJvcnMgb24gcmVzb2x2ZXIoYnl0ZXMzMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbmFtZSA9IHlpZWxkIG5hbWU7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIG5vdGhpbmcgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MobmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBhZGRyIGZyb20gdGhlIHJlc292bGVyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0geWllbGQgYWRkcmVzcztcbiAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWRkciA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKG5vZGUsIFwibG9va3VwQWRkcmVzc1wiKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlckFkZHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VjY2FrKFwibmFtZShieXRlczMyKVwiKVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLmNhbGwoe1xuICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHIsXG4gICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgbmFtZWhhc2gobm9kZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgfSksIDApO1xuICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAoYWRkciAhPSBhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEF2YXRhcihuYW1lT3JBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZXIgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPckFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkcmVzczsgcmV2ZXJzZSBsb29rdXBcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhuYW1lT3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWRkcmVzcyA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKG5vZGUsIFwiZ2V0QXZhdGFyXCIpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzb2x2ZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgcmVzb2x2aW5nIHRoZSBhdmF0YXIgYWdhaW5zdCB0aGUgYWRkci5yZXZlcnNlIHJlc29sdmVyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIodGhpcywgcmVzb2x2ZXJBZGRyZXNzLCBub2RlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF2YXRhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUcnkgZ2V0dGluZyB0aGUgbmFtZSBhbmQgcGVyZm9ybWluZyBmb3J3YXJkIGxvb2t1cDsgYWxsb3dpbmcgd2lsZGNhcmRzXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VjY2FrKFwibmFtZShieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gX3BhcnNlU3RyaW5nKHlpZWxkIHRoaXMuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgbmFtZWhhc2gobm9kZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgICAgICAgICB9KSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFTlMgbmFtZTsgZm9yd2FyZCBsb29rdXAgd2l0aCB3aWxkY2FyZFxuICAgICAgICAgICAgICAgIHJlc29sdmVyID0geWllbGQgdGhpcy5nZXRSZXNvbHZlcihuYW1lT3JBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF2YXRhciA9IHlpZWxkIHJlc29sdmVyLmdldEF2YXRhcigpO1xuICAgICAgICAgICAgaWYgKGF2YXRhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXZhdGFyLnVybDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1ldGhvZCArIFwiIG5vdCBpbXBsZW1lbnRlZFwiLCBMb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcbiAgICB9XG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoKGUpID0+IGUucG9sbGFibGUoKSkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoKGUpID0+IGUucG9sbGFibGUoKSkubGVuZ3RoID4gMCk7XG4gICAgfVxuICAgIF9hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoZ2V0RXZlbnRUYWcoZXZlbnROYW1lKSwgbGlzdGVuZXIsIG9uY2UpO1xuICAgICAgICB0aGlzLl9ldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIHRoaXMuX3N0YXJ0RXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lm9uY2UpIHtcbiAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGlzdGVuZXJDb3VudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChldmVudC50YWcgPT09IGV2ZW50VGFnKTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5tYXAoKGV2ZW50KSA9PiBldmVudC5saXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1xuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IChldmVudC50YWcgPT09IGV2ZW50VGFnKSlcbiAgICAgICAgICAgIC5tYXAoKGV2ZW50KSA9PiBldmVudC5saXN0ZW5lcik7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdG9wcGVkID0gW107XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMuZmlsdGVyKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcgfHwgZXZlbnQubGlzdGVuZXIgIT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gW107XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRoaXMuX2V2ZW50cztcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnICE9PSBldmVudFRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBoZXhsaWZ5LCBoZXhWYWx1ZSwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IF9UeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2hhc2hcIjtcbmltcG9ydCB7IGNoZWNrUHJvcGVydGllcywgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMsIHJlc29sdmVQcm9wZXJ0aWVzLCBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyIH0gZnJvbSBcIi4vYmFzZS1wcm92aWRlclwiO1xuY29uc3QgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHBhcmFtcykge1xuICAgIC8vIFVuZG8gdGhlIFwiY29udmVuaWVuY2VcIiBzb21lIG5vZGVzIGFyZSBhdHRlbXB0aW5nIHRvIHByZXZlbnQgYmFja3dhcmRzXG4gICAgLy8gaW5jb21wYXRpYmlsaXR5OyBtYXliZSBmb3IgdjYgY29uc2lkZXIgZm9yd2FyZGluZyByZXZlcnRzIGFzIGVycm9yc1xuICAgIGlmIChtZXRob2QgPT09IFwiY2FsbFwiICYmIGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG4gICAgICAgIGNvbnN0IGUgPSBlcnJvci5lcnJvcjtcbiAgICAgICAgaWYgKGUgJiYgZS5tZXNzYWdlLm1hdGNoKFwicmV2ZXJ0ZWRcIikgJiYgaXNIZXhTdHJpbmcoZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb25cIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgZXJyb3IsIGRhdGE6IFwiMHhcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiAmJiBlcnJvci5lcnJvciAmJiB0eXBlb2YgKGVycm9yLmVycm9yLm1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5lcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLmJvZHkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5ib2R5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGVycm9yLnJlc3BvbnNlVGV4dCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IGVycm9yLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gICAgbWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBwYXJhbXMudHJhbnNhY3Rpb24gfHwgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgIC8vIFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBnYXMgKiBwcmljZSArIHZhbHVlICsgY29zdChkYXRhKVwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kc3xiYXNlIGZlZSBleGNlZWRzIGdhcyBsaW1pdC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW5zdWZmaWNpZW50IGZ1bmRzIGZvciBpbnRyaW5zaWMgdHJhbnNhY3Rpb24gY29zdFwiLCBMb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL25vbmNlIHRvbyBsb3cvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFwiLCBMb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvcmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcInJlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvb25seSByZXBsYXktcHJvdGVjdGVkLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJsZWdhY3kgcHJlLWVpcC0xNTUgdHJhbnNhY3Rpb25zIG5vdCBzdXBwb3J0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3JHYXMuaW5kZXhPZihtZXRob2QpID49IDAgJiYgbWVzc2FnZS5tYXRjaCgvZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlfGFsd2F5cyBmYWlsaW5nIHRyYW5zYWN0aW9ufGV4ZWN1dGlvbiByZXZlcnRlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBMb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiB0aW1lcih0aW1lb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHBheWxvYWQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XG4gICAgICAgIGVycm9yLmRhdGEgPSBwYXlsb2FkLmVycm9yLmRhdGE7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZC5yZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5leHBvcnQgY2xhc3MgSnNvblJwY1NpZ25lciBleHRlbmRzIFNpZ25lciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgcHJvdmlkZXIsIGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBKc29uUnBjU2lnbmVyKTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgaWYgKGFkZHJlc3NPckluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzT3JJbmRleCkpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaW5kZXhcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0VW5jaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9hZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgaWYgKGFjY291bnRzLmxlbmd0aCA8PSB0aGlzLl9pbmRleCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBhY2NvdW50ICNcIiArIHRoaXMuX2luZGV4LCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhY2NvdW50c1t0aGlzLl9pbmRleF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBmcm9tQWRkcmVzcyA9IHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhlIEpTT04tUlBDIGZvciBldGhfc2VuZFRyYW5zYWN0aW9uIHVzZXMgOTAwMDAgZ2FzOyBpZiB0aGUgdXNlclxuICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2VcbiAgICAgICAgLy8gd2UgbG9vayBpdCB1cCBmb3IgdGhlbS5cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gc2hhbGxvd0NvcHkodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPSB0aGlzLnByb3ZpZGVyLmVzdGltYXRlR2FzKGVzdGltYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24udG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBQcm9taXNlLnJlc29sdmUodHJhbnNhY3Rpb24udG8pLnRoZW4oKHRvKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcm92aWRlZCBFTlMgbmFtZSByZXNvbHZlcyB0byBudWxsXCIsIFwidHgudG9cIiwgdG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgdHg6IHJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKSxcbiAgICAgICAgICAgIHNlbmRlcjogZnJvbUFkZHJlc3NcbiAgICAgICAgfSkudGhlbigoeyB0eCwgc2VuZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eC5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHguZnJvbS50b0xvd2VyQ2FzZSgpICE9PSBzZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eC5mcm9tID0gc2VuZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB0aGlzLnByb3ZpZGVyLmNvbnN0cnVjdG9yLmhleGxpZnlUcmFuc2FjdGlvbih0eCwgeyBmcm9tOiB0cnVlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zZW5kVHJhbnNhY3Rpb25cIiwgW2hleFR4XSkudGhlbigoaGFzaCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IoXCJzZW5kVHJhbnNhY3Rpb25cIiwgZXJyb3IsIGhleFR4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInNpZ25pbmcgdHJhbnNhY3Rpb25zIGlzIHVuc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2lnblRyYW5zYWN0aW9uXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYW5ub3QgYmUgbWluZWQgYW55IGVhcmxpZXIgdGhhbiBhbnkgcmVjZW50IGJsb2NrXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IHlpZWxkIHRoaXMucHJvdmlkZXIuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucHJvdmlkZXIucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCBKU09OLVJQQyBvbmx5IHByb3ZpZGVzIGFuZCBvcGFxdWUgdHJhbnNhY3Rpb24gaGFzaFxuICAgICAgICAgICAgICAgIC8vIGZvciBhIHJlc3BvbnNlLCBhbmQgd2UgbmVlZCB0aGUgYWN0dWFsIHRyYW5zYWN0aW9uLCBzbyB3ZSBwb2xsXG4gICAgICAgICAgICAgICAgLy8gZm9yIGl0OyBpdCBzaG91bGQgc2hvdyB1cCB2ZXJ5IHF1aWNrbHlcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLl93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcy5wcm92aWRlciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLnRyYW5zYWN0aW9uSGFzaCA9IGhhc2g7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKCh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IHRvVXRmOEJ5dGVzKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5zZW5kKFwicGVyc29uYWxfc2lnblwiLCBbaGV4bGlmeShkYXRhKSwgYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbGVnYWN5U2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIGhleGxpZnkoZGF0YSldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zaWduVHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBhbnkgRU5TIG5hbWVzIChpbi1wbGFjZSlcbiAgICAgICAgICAgIGNvbnN0IHBvcHVsYXRlZCA9IHlpZWxkIF9UeXBlZERhdGFFbmNvZGVyLnJlc29sdmVOYW1lcyhkb21haW4sIHR5cGVzLCB2YWx1ZSwgKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduVHlwZWREYXRhX3Y0XCIsIFtcbiAgICAgICAgICAgICAgICBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoX1R5cGVkRGF0YUVuY29kZXIuZ2V0UGF5bG9hZChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5sb2NrKHBhc3N3b3JkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXI7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5nZXRBZGRyZXNzKCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3VubG9ja0FjY291bnRcIiwgW2FkZHJlc3MudG9Mb3dlckNhc2UoKSwgcGFzc3dvcmQsIG51bGxdKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVW5jaGVja2VkSnNvblJwY1NpZ25lciBleHRlbmRzIEpzb25ScGNTaWduZXIge1xuICAgIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oKGhhc2gpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgICAgICAgICBub25jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogbnVsbCxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogbnVsbCxcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY29uZmlybWF0aW9uczogMCxcbiAgICAgICAgICAgICAgICBmcm9tOiBudWxsLFxuICAgICAgICAgICAgICAgIHdhaXQ6IChjb25maXJtYXRpb25zKSA9PiB7IHJldHVybiB0aGlzLnByb3ZpZGVyLndhaXRGb3JUcmFuc2FjdGlvbihoYXNoLCBjb25maXJtYXRpb25zKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcbiAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdmFsdWU6IHRydWUsXG4gICAgdHlwZTogdHJ1ZSwgYWNjZXNzTGlzdDogdHJ1ZSxcbiAgICBtYXhGZWVQZXJHYXM6IHRydWUsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cnVlXG59O1xuZXhwb3J0IGNsYXNzIEpzb25ScGNQcm92aWRlciBleHRlbmRzIEJhc2VQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBuZXR3b3JrKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBKc29uUnBjUHJvdmlkZXIpO1xuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBuZXR3b3JrO1xuICAgICAgICAvLyBUaGUgbmV0d29yayBpcyB1bmtub3duLCBxdWVyeSB0aGUgSlNPTi1SUEMgZm9yIGl0XG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmtPclJlYWR5KTtcbiAgICAgICAgLy8gRGVmYXVsdCBVUkxcbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICAgIHVybCA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImRlZmF1bHRVcmxcIikoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh1cmwpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHNoYWxsb3dDb3B5KHVybCkpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9uZXh0SWQgPSA0MjtcbiAgICB9XG4gICAgZ2V0IF9jYWNoZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TG9vcENhY2hlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TG9vcENhY2hlID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TG9vcENhY2hlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwiaHR0cDovXFwvbG9jYWxob3N0Ojg1NDVcIjtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0pIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IHRoaXMuX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhpcyBjYWNoZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdO1xuICAgIH1cbiAgICBfdW5jYWNoZWREZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGltZXIoMCk7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSB5aWVsZCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwibmV0X3ZlcnNpb25cIiwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdldE5ldHdvcmsgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXROZXR3b3JrXCIpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXROZXR3b3JrKEJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImludmFsaWROZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJFcnJvcjogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBcIm5vTmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMsIGFkZHJlc3NPckluZGV4KTtcbiAgICB9XG4gICAgZ2V0VW5jaGVja2VkU2lnbmVyKGFkZHJlc3NPckluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpZ25lcihhZGRyZXNzT3JJbmRleCkuY29ubmVjdFVuY2hlY2tlZCgpO1xuICAgIH1cbiAgICBsaXN0QWNjb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoXCJldGhfYWNjb3VudHNcIiwgW10pLnRoZW4oKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhKSA9PiB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGNhbiBleHBhbmQgdGhpcyBpbiB0aGUgZnV0dXJlIHRvIGFueSBjYWxsLCBidXQgZm9yIG5vdyB0aGVzZVxuICAgICAgICAvLyBhcmUgdGhlIGJpZ2dlc3Qgd2lucyBhbmQgZG8gbm90IHJlcXVpcmUgYW55IHNlcmlhbGl6aW5nIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGNhY2hlID0gKFtcImV0aF9jaGFpbklkXCIsIFwiZXRoX2Jsb2NrTnVtYmVyXCJdLmluZGV4T2YobWV0aG9kKSA+PSAwKTtcbiAgICAgICAgaWYgKGNhY2hlICYmIHRoaXMuX2NhY2hlW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZVttZXRob2RdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZldGNoSnNvbih0aGlzLmNvbm5lY3Rpb24sIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLCBnZXRSZXN1bHQpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBmZXRjaCwgYnV0IGNsZWFyIGl0IG9uIHRoZSBuZXh0IGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVttZXRob2RdID0gcmVzdWx0O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBwcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9ibG9ja051bWJlclwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCYWxhbmNlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvbkNvdW50XCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFN0b3JhZ2VBdFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWddXTtcbiAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLCBbcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLCBbcGFyYW1zLmJsb2NrVGFnLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ibG9ja0hhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5SGFzaFwiLCBbcGFyYW1zLmJsb2NrSGFzaCwgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2hcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBbcGFyYW1zLnRyYW5zYWN0aW9uSGFzaF1dO1xuICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleGxpZnlUcmFuc2FjdGlvbiA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImhleGxpZnlUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2NhbGxcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhleGxpZnlUcmFuc2FjdGlvbiA9IGdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImhleGxpZnlUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2VzdGltYXRlR2FzXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgJiYgcGFyYW1zLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmZpbHRlci5hZGRyZXNzID0gZ2V0TG93ZXJDYXNlKHBhcmFtcy5maWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0TG9nc1wiLCBbcGFyYW1zLmZpbHRlcl1dO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gTGVnYWN5IG5ldHdvcmtzIGRvIG5vdCBsaWtlIHRoZSB0eXBlIGZpZWxkIGJlaW5nIHBhc3NlZCBhbG9uZyAod2hpY2hcbiAgICAgICAgICAgIC8vIGlzIGZhaXIpLCBzbyB3ZSBkZWxldGUgdHlwZSBpZiBpdCBpcyAwIGFuZCBhIG5vbi1FSVAtMTU1OSBuZXR3b3JrXG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiB8fCBtZXRob2QgPT09IFwiZXN0aW1hdGVHYXNcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4ID0gcGFyYW1zLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICh0eCAmJiB0eC50eXBlICE9IG51bGwgJiYgQmlnTnVtYmVyLmZyb20odHgudHlwZSkuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIEVJUC0xNTU5IHByb3BlcnRpZXMsIGl0IG1pZ2h0IGJlIG5vbi1FSVAtYTU1OVxuICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHlpZWxkIHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZlZURhdGEubWF4RmVlUGVyR2FzID09IG51bGwgJiYgZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV0d29yayBkb2Vzbid0IGtub3cgYWJvdXQgRUlQLTE1NTkgKGFuZCBoZW5jZSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHNoYWxsb3dDb3B5KHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnRyYW5zYWN0aW9uID0gc2hhbGxvd0NvcHkodHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudHJhbnNhY3Rpb24udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNlbmQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N0YXJ0RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UGVuZGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLl9zdGFydEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgX3N0YXJ0UGVuZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBjb25zdCBwZW5kaW5nRmlsdGVyID0gdGhpcy5zZW5kKFwiZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlclwiLCBbXSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdGaWx0ZXIgPSBwZW5kaW5nRmlsdGVyO1xuICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwb2xsKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF9nZXRGaWx0ZXJDaGFuZ2VzXCIsIFtmaWx0ZXJJZF0pLnRoZW4oZnVuY3Rpb24gKGhhc2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYXQgc29tZSBwb2ludC4uLiBIb3c/IFdoZW4/XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcSA9IHNlcS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5nZXRUcmFuc2FjdGlvbihoYXNoKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfdW5pbnN0YWxsRmlsdGVyXCIsIFtmaWx0ZXJJZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBwb2xsKCk7IH0sIDApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2xsKCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICB9XG4gICAgX3N0b3BFdmVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudGFnID09PSBcInBlbmRpbmdcIiAmJiB0aGlzLmxpc3RlbmVyQ291bnQoXCJwZW5kaW5nXCIpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RvcEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBhbiBldGhlcnMuanMgdHJhbnNhY3Rpb24gaW50byBhIEpTT04tUlBDIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gZ2FzTGltaXQgPT4gZ2FzXG4gICAgLy8gIC0gQWxsIHZhbHVlcyBoZXhsaWZpZWRcbiAgICAvLyAgLSBBbGwgbnVtZXJpYyB2YWx1ZXMgemVyby1zdHJpcGVkXG4gICAgLy8gIC0gQWxsIGFkZHJlc3NlcyBhcmUgbG93ZXJjYXNlZFxuICAgIC8vIE5PVEU6IFRoaXMgYWxsb3dzIGEgVHJhbnNhY3Rpb25SZXF1ZXN0LCBidXQgYWxsIHZhbHVlcyBzaG91bGQgYmUgcmVzb2x2ZWRcbiAgICAvLyAgICAgICBiZWZvcmUgdGhpcyBpcyBjYWxsZWRcbiAgICAvLyBAVE9ETzogVGhpcyB3aWxsIGxpa2VseSBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBhbmQgcHJlcGFyZVJlcXVlc3RcbiAgICAvLyAgICAgICAgd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZCBmb3IgdGhpcy5cbiAgICBzdGF0aWMgaGV4bGlmeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBhbGxvd0V4dHJhKSB7XG4gICAgICAgIC8vIENoZWNrIG9ubHkgYWxsb3dlZCBwcm9wZXJ0aWVzIGFyZSBnaXZlblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gc2hhbGxvd0NvcHkoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG4gICAgICAgIGlmIChhbGxvd0V4dHJhKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxvd0V4dHJhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93RXh0cmFba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sIGFsbG93ZWQpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgLy8gSlNPTi1SUEMgbm93IHJlcXVpcmVzIG51bWVyaWMgdmFsdWVzIHRvIGJlIFwicXVhbnRpdHlcIiB2YWx1ZXNcbiAgICAgICAgW1wiY2hhaW5JZFwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ0eXBlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJub25jZVwiLCBcInZhbHVlXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaGV4VmFsdWUodHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBcImdhc1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIFtcImZyb21cIiwgXCJ0b1wiLCBcImRhdGFcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBoZXhsaWZ5KHRyYW5zYWN0aW9uW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgIHJlc3VsdFtcImFjY2Vzc0xpc3RcIl0gPSBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1ycGMtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBkZWVwQ29weSwgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmxldCBfbmV4dElkID0gMTtcbmZ1bmN0aW9uIGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHNlbmRGdW5jKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IFwiV2ViM0xlZ2FjeUZldGNoZXJcIjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6IChfbmV4dElkKyspLFxuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW5kRnVuYyhyZXF1ZXN0LCAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzcG9uc2UuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHJlc3BvbnNlLmVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5yZXF1ZXN0KHJlcXVlc3QpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBXZWIzUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBuZXR3b3JrKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBXZWIzUHJvdmlkZXIpO1xuICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBsZXQganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG4gICAgICAgIGxldCBzdWJwcm92aWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHByb3ZpZGVyLmhvc3QgfHwgcHJvdmlkZXIucGF0aCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGF0aCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViMy1wcm92aWRlci5qcy5tYXAiLCIvLyBFdmVudHMgYmVpbmcgZW1pdHRlZCBieSBhbiBlaXAtMTE5MyBwcm92aWRlclxyXG4vLyBTZWUgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzI2V2ZW50c1xyXG5leHBvcnQgY29uc3QgRXRoZXJldW1FdmVudHMgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIENPTk5FQ1Q6ICdjb25uZWN0JyxcclxuICAgIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcclxuICAgIENIQUlOX0NIQU5HRUQ6ICdjaGFpbkNoYW5nZWQnLFxyXG4gICAgQUNDT1VOVFNfQ0hBTkdFRDogJ2FjY291bnRzQ2hhbmdlZCcsXHJcbn0pO1xyXG5cclxuLy8gRXZlbnRzIGVtaXR0ZWQgYnkgdGhlIGNvbm5lY3RvcnMsXHJcbi8vIFRoZSBJbnRlcm5hbFdlYjNQcm92aWRlciBvZiBNb3JhbGlzIHdpbGwgbGlzdGVuIHRvIHRoZXNlXHJcbmV4cG9ydCBjb25zdCBDb25uZWN0b3JFdmVudHMgPSBPYmplY3QuZnJlZXplKHtcclxuICAgIENPTk5FQ1Q6ICdjb25uZWN0JyxcclxuICAgIERJU0NPTk5FQ1Q6ICdkaXNjb25uZWN0JyxcclxuICAgIENIQUlOX0NIQU5HRUQ6ICdjaGFpbkNoYW5nZWQnLFxyXG4gICAgQUNDT1VOVF9DSEFOR0VEOiAnYWNjb3VudENoYW5nZWQnLFxyXG59KTtcclxuIiwiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnO1xyXG5pbXBvcnQge0Nvbm5lY3RvckV2ZW50cywgRXRoZXJldW1FdmVudHN9IGZyb20gJy4vZXZlbnRzJztcclxuaW1wb3J0IE1vcmFsaXMgZnJvbSBcIm1vcmFsaXNcIjtcclxuaW1wb3J0IEV0aGVyc0V4dGVybmFsUHJvdmlkZXIgPSBNb3JhbGlzLkV0aGVyc0V4dGVybmFsUHJvdmlkZXI7XHJcblxyXG4vKipcclxuICogQWJzdHJhY3QgY29ubmVjdG9yIHRvIGNvbm5lY3QgRUlQLTExOTMgcHJvdmlkZXJzIHRvIE1vcmFsaXNcclxuICpcclxuICogSXQgc2hvdWxkIGltcGxlbWVudCBhdCBsZWFzdDpcclxuICogLSBhY3RpdmF0ZSgpXHJcbiAqIC0gRW1pdCBDb25uZWN0b3JFdmVudC5DSEFJTl9DSEFOR0VEIHdoZW4gdGhlIGNoYWluIGhhcyBjaGFuZ2VkIChpZiBwb3NzaWJsZSlcclxuICogLSBFbWl0IENvbm5lY3RvckV2ZW50LkFDQ09VTlRfQ0hBTkdFRCB3aGVuIHRoZSBhY2NvdW50IGhhcyBjaGFuZ2VkIChpZiBwb3NzaWJsZSlcclxuICogLSB0eXBlOiBhIG5hbWUgdG8gaWRlbnRpZnlcclxuICogLSBuZXR3b3JrOiB0aGUgbmV0d29yayB0eXBlIHRoYXQgaXMgdXNlZCAoZWcuICdldm0nKVxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RXZWIzQ29ubmVjdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAgIHR5cGUgPSAnYWJzdHJhY3QnO1xyXG4gICAgbmV0d29yayA9ICdldm0nO1xyXG4gICAgYWNjb3VudDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICBjaGFpbklkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgIHByb3ZpZGVyOiBFdGhlcnNFeHRlcm5hbFByb3ZpZGVyIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZUFjY291bnRzQ2hhbmdlZCA9IHRoaXMuaGFuZGxlQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFpbkNoYW5nZWQgPSB0aGlzLmhhbmRsZUNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ29ubmVjdCA9IHRoaXMuaGFuZGxlQ29ubmVjdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCA9IHRoaXMuaGFuZGxlRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHN1YnNjcmliZVRvRXZlbnRzKHByb3ZpZGVyOiBhbnkpIHtcclxuICAgICAgICBpZiAocHJvdmlkZXIgJiYgcHJvdmlkZXIub24pIHtcclxuICAgICAgICAgICAgcHJvdmlkZXIub24oRXRoZXJldW1FdmVudHMuQ0hBSU5fQ0hBTkdFRCwgdGhpcy5oYW5kbGVDaGFpbkNoYW5nZWQpO1xyXG4gICAgICAgICAgICBwcm92aWRlci5vbihFdGhlcmV1bUV2ZW50cy5BQ0NPVU5UU19DSEFOR0VELCB0aGlzLmhhbmRsZUFjY291bnRzQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLm9uKEV0aGVyZXVtRXZlbnRzLkNPTk5FQ1QsIHRoaXMuaGFuZGxlQ29ubmVjdCk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLm9uKEV0aGVyZXVtRXZlbnRzLkRJU0NPTk5FQ1QsIHRoaXMuaGFuZGxlRGlzY29ubmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVuc3Vic2NyaWJlVG9FdmVudHMocHJvdmlkZXI6IGFueSkge1xyXG4gICAgICAgIGlmIChwcm92aWRlciAmJiBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBwcm92aWRlci5yZW1vdmVMaXN0ZW5lcihFdGhlcmV1bUV2ZW50cy5DSEFJTl9DSEFOR0VELCB0aGlzLmhhbmRsZUNoYWluQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgIHByb3ZpZGVyLnJlbW92ZUxpc3RlbmVyKEV0aGVyZXVtRXZlbnRzLkFDQ09VTlRTX0NIQU5HRUQsIHRoaXMuaGFuZGxlQWNjb3VudHNDaGFuZ2VkKTtcclxuICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoRXRoZXJldW1FdmVudHMuQ09OTkVDVCwgdGhpcy5oYW5kbGVDb25uZWN0KTtcclxuICAgICAgICAgICAgcHJvdmlkZXIucmVtb3ZlTGlzdGVuZXIoRXRoZXJldW1FdmVudHMuRElTQ09OTkVDVCwgdGhpcy5oYW5kbGVEaXNjb25uZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIHByb3ZpZGVyLlxyXG4gICAgICogU2hvdWxkIHJldHVybnMgYW4gb2JqZWN0IHdpdGg6XHJcbiAgICAgKiAtIHByb3ZpZGVyOiBBIHZhbGlkIEVJUC0xMTkzIHByb3ZpZGVyXHJcbiAgICAgKiAtIGNoYWluSWQob3B0aW9uYWwpOiB0aGUgY2hhaW5JZCB0aGF0IGhhcyBiZWVuIGNvbm5lY3RlZCB0byAoaW4gaGV4IGZvcm1hdClcclxuICAgICAqIC0gYWNjb3VudChvcHRpb25hbCk6IHRoZSBhZGRyZXNzIHRoYXQgaXMgY29ubmVjdGVkIHRvIHRoZSBwcm92aWRlclxyXG4gICAgICovXHJcbiAgICBhc3luYyBhY3RpdmF0ZSgpOiBQcm9taXNlPHtcclxuICAgICAgICBwcm92aWRlcjogYW55LFxyXG4gICAgICAgIGFjY291bnQ6IGFueSxcclxuICAgICAgICBjaGFpbklkOiBhbnlcclxuICAgIH0+IHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZDogYWN0aXZhdGUoKScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBhY2NvdW50IGFuZCBlbWl0IGV2ZW50LCBvbiBFSVAtMTE5MyBhY2NvdW50c0NoYW5nZWQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50czogYW55KSB7XHJcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IGFjY291bnRzICYmIGFjY291bnRzWzBdID8gYWNjb3VudHNbMF0udG9Mb3dlckNhc2UoKSA6IG51bGw7XHJcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcclxuICAgICAgICB0aGlzLmVtaXQoQ29ubmVjdG9yRXZlbnRzLkFDQ09VTlRfQ0hBTkdFRCwgYWNjb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGNoYWluSWQgYW5kIGVtaXQgZXZlbnQsIG9uIEVJUC0xMTkzIGFjY291bnRzQ2hhbmdlZCBldmVudHNcclxuICAgICAqL1xyXG4gICAgaGFuZGxlQ2hhaW5DaGFuZ2VkKGNoYWluSWQ6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IG5ld0NoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IG5ld0NoYWluSWQ7XHJcbiAgICAgICAgdGhpcy5lbWl0KENvbm5lY3RvckV2ZW50cy5DSEFJTl9DSEFOR0VELCBuZXdDaGFpbklkKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVDb25uZWN0KGNvbm5lY3RJbmZvOiBhbnkpIHtcclxuICAgICAgICB0aGlzLmVtaXQoQ29ubmVjdG9yRXZlbnRzLkNPTk5FQ1QsIGNvbm5lY3RJbmZvKTtcclxuICAgIH1cclxuXHJcbiAgICBoYW5kbGVEaXNjb25uZWN0KGVycm9yOiBhbnkpIHtcclxuICAgICAgICB0aGlzLmVtaXQoQ29ubmVjdG9yRXZlbnRzLkRJU0NPTk5FQ1QsIGVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyBhbGwgYWN0aXZlIGxpc3RuZXJzLCBjb25uZWN0aW9ucyBhbmQgc3RhbGUgcmVmZXJlbmNlc1xyXG4gICAgICovXHJcbiAgICBhc3luYyBkZWFjdGl2YXRlKCkge1xyXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0V2ZW50cyh0aGlzLnByb3ZpZGVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoYWluSWQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdFdlYjNDb25uZWN0b3I7XHJcbiIsInZhciBhPShuPT4obi5NaXNzaW5nQXBpS2V5PVwiTUlTU0lOR19BUElfS0VZXCIsbi5Nb2RhbE5vdFJlYWR5PVwiTU9EQUxfTk9UX1JFQURZXCIsbi5NYWxmb3JtZWRSZXNwb25zZT1cIk1BTEZPUk1FRF9SRVNQT05TRVwiLG4uSW52YWxpZEFyZ3VtZW50PVwiSU5WQUxJRF9BUkdVTUVOVFwiLG4uRXh0ZW5zaW9uTm90SW5pdGlhbGl6ZWQ9XCJFWFRFTlNJT05fTk9UX0lOSVRJQUxJWkVEXCIsbi5JbmNvbXBhdGlibGVFeHRlbnNpb25zPVwiSU5DT01QQVRJQkxFX0VYVEVOU0lPTlNcIixuKSkoYXx8e30pLG09KF89PihfLlN5bmNXZWIzTWV0aG9kPVwiU1lOQ19XRUIzX01FVEhPRFwiLF8uRHVwbGljYXRlSWZyYW1lPVwiRFVQTElDQVRFX0lGUkFNRVwiLF8uUmVhY3ROYXRpdmVFbmRwb2ludENvbmZpZ3VyYXRpb249XCJSRUFDVF9OQVRJVkVfRU5EUE9JTlRfQ09ORklHVVJBVElPTlwiLF8uRGVwcmVjYXRpb25Ob3RpY2U9XCJERVBSRUNBVElPTl9OT1RJQ0VcIixfKSkobXx8e30pLHA9KGU9PihlW2UuUGFyc2VFcnJvcj0tMzI3MDBdPVwiUGFyc2VFcnJvclwiLGVbZS5JbnZhbGlkUmVxdWVzdD0tMzI2MDBdPVwiSW52YWxpZFJlcXVlc3RcIixlW2UuTWV0aG9kTm90Rm91bmQ9LTMyNjAxXT1cIk1ldGhvZE5vdEZvdW5kXCIsZVtlLkludmFsaWRQYXJhbXM9LTMyNjAyXT1cIkludmFsaWRQYXJhbXNcIixlW2UuSW50ZXJuYWxFcnJvcj0tMzI2MDNdPVwiSW50ZXJuYWxFcnJvclwiLGVbZS5NYWdpY0xpbmtGYWlsZWRWZXJpZmljYXRpb249LTFlNF09XCJNYWdpY0xpbmtGYWlsZWRWZXJpZmljYXRpb25cIixlW2UuTWFnaWNMaW5rRXhwaXJlZD0tMTAwMDFdPVwiTWFnaWNMaW5rRXhwaXJlZFwiLGVbZS5NYWdpY0xpbmtSYXRlTGltaXRlZD0tMTAwMDJdPVwiTWFnaWNMaW5rUmF0ZUxpbWl0ZWRcIixlW2UuTWFnaWNMaW5rSW52YWxpZFJlZGlyZWN0VVJMPS0xMDAwNl09XCJNYWdpY0xpbmtJbnZhbGlkUmVkaXJlY3RVUkxcIixlW2UuVXNlckFscmVhZHlMb2dnZWRJbj0tMTAwMDNdPVwiVXNlckFscmVhZHlMb2dnZWRJblwiLGVbZS5VcGRhdGVFbWFpbEZhaWxlZD0tMTAwMDRdPVwiVXBkYXRlRW1haWxGYWlsZWRcIixlW2UuVXNlclJlcXVlc3RFZGl0RW1haWw9LTEwMDA1XT1cIlVzZXJSZXF1ZXN0RWRpdEVtYWlsXCIsZVtlLkluYWN0aXZlUmVjaXBpZW50PS0xMDAxMF09XCJJbmFjdGl2ZVJlY2lwaWVudFwiLGVbZS5BY2Nlc3NEZW5pZWRUb1VzZXI9LTEwMDExXT1cIkFjY2Vzc0RlbmllZFRvVXNlclwiLGUpKShwfHx7fSk7dmFyIHU9KHQ9Pih0LkxvZ2luV2l0aFNtcz1cIm1hZ2ljX2F1dGhfbG9naW5fd2l0aF9zbXNcIix0LkxvZ2luV2l0aEVtYWlsT1RQPVwibWFnaWNfYXV0aF9sb2dpbl93aXRoX2VtYWlsX290cFwiLHQuTG9naW5XaXRoTWFnaWNMaW5rPVwibWFnaWNfYXV0aF9sb2dpbl93aXRoX21hZ2ljX2xpbmtcIix0LkxvZ2luV2l0aENyZWRlbnRpYWw9XCJtYWdpY19hdXRoX2xvZ2luX3dpdGhfY3JlZGVudGlhbFwiLHQuR2V0SWRUb2tlbj1cIm1hZ2ljX2F1dGhfZ2V0X2lkX3Rva2VuXCIsdC5HZW5lcmF0ZUlkVG9rZW49XCJtYWdpY19hdXRoX2dlbmVyYXRlX2lkX3Rva2VuXCIsdC5HZXRNZXRhZGF0YT1cIm1hZ2ljX2F1dGhfZ2V0X21ldGFkYXRhXCIsdC5Jc0xvZ2dlZEluPVwibWFnaWNfYXV0aF9pc19sb2dnZWRfaW5cIix0LkxvZ291dD1cIm1hZ2ljX2F1dGhfbG9nb3V0XCIsdC5VcGRhdGVFbWFpbD1cIm1hZ2ljX2F1dGhfdXBkYXRlX2VtYWlsXCIsdC5Vc2VyU2V0dGluZ3M9XCJtYWdpY19hdXRoX3NldHRpbmdzXCIsdC5Vc2VyU2V0dGluZ3NUZXN0TW9kZT1cIm1hZ2ljX2F1dGhfc2V0dGluZ3NfdGVzdGluZ19tb2RlXCIsdC5Mb2dpbldpdGhTbXNUZXN0TW9kZT1cIm1hZ2ljX2F1dGhfbG9naW5fd2l0aF9zbXNfdGVzdGluZ19tb2RlXCIsdC5Mb2dpbldpdGhFbWFpbE9UUFRlc3RNb2RlPVwibWFnaWNfYXV0aF9sb2dpbl93aXRoX2VtYWlsX290cF90ZXN0aW5nX21vZGVcIix0LkxvZ2luV2l0aE1hZ2ljTGlua1Rlc3RNb2RlPVwibWFnaWNfbG9naW5fd2l0aF9tYWdpY19saW5rX3Rlc3RpbmdfbW9kZVwiLHQuTG9naW5XaXRoQ3JlZGVudGlhbFRlc3RNb2RlPVwibWFnaWNfYXV0aF9sb2dpbl93aXRoX2NyZWRlbnRpYWxfdGVzdGluZ19tb2RlXCIsdC5HZXRJZFRva2VuVGVzdE1vZGU9XCJtYWdpY19hdXRoX2dldF9pZF90b2tlbl90ZXN0aW5nX21vZGVcIix0LkdlbmVyYXRlSWRUb2tlblRlc3RNb2RlPVwibWFnaWNfYXV0aF9nZW5lcmF0ZV9pZF90b2tlbl90ZXN0aW5nX21vZGVcIix0LkdldE1ldGFkYXRhVGVzdE1vZGU9XCJtYWdpY19hdXRoX2dldF9tZXRhZGF0YV90ZXN0aW5nX21vZGVcIix0LklzTG9nZ2VkSW5UZXN0TW9kZT1cIm1hZ2ljX2F1dGhfaXNfbG9nZ2VkX2luX3Rlc3RpbmdfbW9kZVwiLHQuTG9nb3V0VGVzdE1vZGU9XCJtYWdpY19hdXRoX2xvZ291dF90ZXN0aW5nX21vZGVcIix0LlVwZGF0ZUVtYWlsVGVzdE1vZGU9XCJtYWdpY19hdXRoX3VwZGF0ZV9lbWFpbF90ZXN0aW5nX21vZGVcIix0KSkodXx8e30pO3ZhciBnPShpPT4oaS5NQUdJQ19IQU5ETEVfUkVTUE9OU0U9XCJNQUdJQ19IQU5ETEVfUkVTUE9OU0VcIixpLk1BR0lDX09WRVJMQVlfUkVBRFk9XCJNQUdJQ19PVkVSTEFZX1JFQURZXCIsaS5NQUdJQ19TSE9XX09WRVJMQVk9XCJNQUdJQ19TSE9XX09WRVJMQVlcIixpLk1BR0lDX0hJREVfT1ZFUkxBWT1cIk1BR0lDX0hJREVfT1ZFUkxBWVwiLGkuTUFHSUNfSEFORExFX0VWRU5UPVwiTUFHSUNfSEFORExFX0VWRU5UXCIsaSkpKGd8fHt9KSxvPShzPT4ocy5NQUdJQ19IQU5ETEVfUkVRVUVTVD1cIk1BR0lDX0hBTkRMRV9SRVFVRVNUXCIscykpKG98fHt9KTt2YXIgbD0ocz0+KHMuSGFybW9ueT1cIkhBUk1PTllcIixzKSkobHx8e30pO2V4cG9ydHtsIGFzIEV0aENoYWluVHlwZSxnIGFzIE1hZ2ljSW5jb21pbmdXaW5kb3dNZXNzYWdlLG8gYXMgTWFnaWNPdXRnb2luZ1dpbmRvd01lc3NhZ2UsdSBhcyBNYWdpY1BheWxvYWRNZXRob2QscCBhcyBSUENFcnJvckNvZGUsYSBhcyBTREtFcnJvckNvZGUsbSBhcyBTREtXYXJuaW5nQ29kZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgeXQ9T2JqZWN0LmNyZWF0ZTt2YXIgVT1PYmplY3QuZGVmaW5lUHJvcGVydHksUnQ9T2JqZWN0LmRlZmluZVByb3BlcnRpZXMsVHQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcix2dD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyx4dD1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxiZT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLEl0PU9iamVjdC5nZXRQcm90b3R5cGVPZixNZT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFB0PU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7dmFyIE5lPSh0LGUsbik9PmUgaW4gdD9VKHQsZSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6bn0pOnRbZV09bix6PSh0LGUpPT57Zm9yKHZhciBuIGluIGV8fChlPXt9KSlNZS5jYWxsKGUsbikmJk5lKHQsbixlW25dKTtpZihiZSlmb3IodmFyIG4gb2YgYmUoZSkpUHQuY2FsbChlLG4pJiZOZSh0LG4sZVtuXSk7cmV0dXJuIHR9LHdlPSh0LGUpPT5SdCh0LHZ0KGUpKSwkdD10PT5VKHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGJ0PSh0LGUpPT4oKT0+KGV8fHQoKGU9e2V4cG9ydHM6e319KS5leHBvcnRzLGUpLGUuZXhwb3J0cyksTXQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlVKHQsbix7Z2V0OmVbbl0sZW51bWVyYWJsZTohMH0pfSxOdD0odCxlLG4scik9PntpZihlJiZ0eXBlb2YgZT09XCJvYmplY3RcInx8dHlwZW9mIGU9PVwiZnVuY3Rpb25cIilmb3IobGV0IHMgb2YgeHQoZSkpIU1lLmNhbGwodCxzKSYmKG58fHMhPT1cImRlZmF1bHRcIikmJlUodCxzLHtnZXQ6KCk9PmVbc10sZW51bWVyYWJsZTohKHI9VHQoZSxzKSl8fHIuZW51bWVyYWJsZX0pO3JldHVybiB0fSx3dD0odCxlKT0+TnQoJHQoVSh0IT1udWxsP3l0KEl0KHQpKTp7fSxcImRlZmF1bHRcIiwhZSYmdCYmdC5fX2VzTW9kdWxlP3tnZXQ6KCk9PnQuZGVmYXVsdCxlbnVtZXJhYmxlOiEwfTp7dmFsdWU6dCxlbnVtZXJhYmxlOiEwfSkpLHQpO3ZhciBJPSh0LGUsbik9Pm5ldyBQcm9taXNlKChyLHMpPT57dmFyIG89Yz0+e3RyeXtpKG4ubmV4dChjKSl9Y2F0Y2gocCl7cyhwKX19LGE9Yz0+e3RyeXtpKG4udGhyb3coYykpfWNhdGNoKHApe3MocCl9fSxpPWM9PmMuZG9uZT9yKGMudmFsdWUpOlByb21pc2UucmVzb2x2ZShjLnZhbHVlKS50aGVuKG8sYSk7aSgobj1uLmFwcGx5KHQsZSkpLm5leHQoKSl9KTt2YXIgbnQ9YnQoKGZyLGZlKT0+e1widXNlIHN0cmljdFwiO3ZhciAkbj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFQ9XCJ+XCI7ZnVuY3Rpb24gQigpe31PYmplY3QuY3JlYXRlJiYoQi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShudWxsKSxuZXcgQigpLl9fcHJvdG9fX3x8KFQ9ITEpKTtmdW5jdGlvbiBibih0LGUsbil7dGhpcy5mbj10LHRoaXMuY29udGV4dD1lLHRoaXMub25jZT1ufHwhMX1mdW5jdGlvbiB0dCh0LGUsbixyLHMpe2lmKHR5cGVvZiBuIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7dmFyIG89bmV3IGJuKG4scnx8dCxzKSxhPVQ/VCtlOmU7cmV0dXJuIHQuX2V2ZW50c1thXT90Ll9ldmVudHNbYV0uZm4/dC5fZXZlbnRzW2FdPVt0Ll9ldmVudHNbYV0sb106dC5fZXZlbnRzW2FdLnB1c2gobyk6KHQuX2V2ZW50c1thXT1vLHQuX2V2ZW50c0NvdW50KyspLHR9ZnVuY3Rpb24gb2UodCxlKXstLXQuX2V2ZW50c0NvdW50PT09MD90Ll9ldmVudHM9bmV3IEI6ZGVsZXRlIHQuX2V2ZW50c1tlXX1mdW5jdGlvbiB5KCl7dGhpcy5fZXZlbnRzPW5ldyBCLHRoaXMuX2V2ZW50c0NvdW50PTB9eS5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3ZhciBlPVtdLG4scjtpZih0aGlzLl9ldmVudHNDb3VudD09PTApcmV0dXJuIGU7Zm9yKHIgaW4gbj10aGlzLl9ldmVudHMpJG4uY2FsbChuLHIpJiZlLnB1c2goVD9yLnNsaWNlKDEpOnIpO3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2UuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobikpOmV9O3kucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihlKXt2YXIgbj1UP1QrZTplLHI9dGhpcy5fZXZlbnRzW25dO2lmKCFyKXJldHVybltdO2lmKHIuZm4pcmV0dXJuW3IuZm5dO2Zvcih2YXIgcz0wLG89ci5sZW5ndGgsYT1uZXcgQXJyYXkobyk7czxvO3MrKylhW3NdPXJbc10uZm47cmV0dXJuIGF9O3kucHJvdG90eXBlLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24oZSl7dmFyIG49VD9UK2U6ZSxyPXRoaXMuX2V2ZW50c1tuXTtyZXR1cm4gcj9yLmZuPzE6ci5sZW5ndGg6MH07eS5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihlLG4scixzLG8sYSl7dmFyIGk9VD9UK2U6ZTtpZighdGhpcy5fZXZlbnRzW2ldKXJldHVybiExO3ZhciBjPXRoaXMuX2V2ZW50c1tpXSxwPWFyZ3VtZW50cy5sZW5ndGgsbCx1O2lmKGMuZm4pe3N3aXRjaChjLm9uY2UmJnRoaXMucmVtb3ZlTGlzdGVuZXIoZSxjLmZuLHZvaWQgMCwhMCkscCl7Y2FzZSAxOnJldHVybiBjLmZuLmNhbGwoYy5jb250ZXh0KSwhMDtjYXNlIDI6cmV0dXJuIGMuZm4uY2FsbChjLmNvbnRleHQsbiksITA7Y2FzZSAzOnJldHVybiBjLmZuLmNhbGwoYy5jb250ZXh0LG4sciksITA7Y2FzZSA0OnJldHVybiBjLmZuLmNhbGwoYy5jb250ZXh0LG4scixzKSwhMDtjYXNlIDU6cmV0dXJuIGMuZm4uY2FsbChjLmNvbnRleHQsbixyLHMsbyksITA7Y2FzZSA2OnJldHVybiBjLmZuLmNhbGwoYy5jb250ZXh0LG4scixzLG8sYSksITB9Zm9yKHU9MSxsPW5ldyBBcnJheShwLTEpO3U8cDt1KyspbFt1LTFdPWFyZ3VtZW50c1t1XTtjLmZuLmFwcGx5KGMuY29udGV4dCxsKX1lbHNle3ZhciB2PWMubGVuZ3RoLE07Zm9yKHU9MDt1PHY7dSsrKXN3aXRjaChjW3VdLm9uY2UmJnRoaXMucmVtb3ZlTGlzdGVuZXIoZSxjW3VdLmZuLHZvaWQgMCwhMCkscCl7Y2FzZSAxOmNbdV0uZm4uY2FsbChjW3VdLmNvbnRleHQpO2JyZWFrO2Nhc2UgMjpjW3VdLmZuLmNhbGwoY1t1XS5jb250ZXh0LG4pO2JyZWFrO2Nhc2UgMzpjW3VdLmZuLmNhbGwoY1t1XS5jb250ZXh0LG4scik7YnJlYWs7Y2FzZSA0OmNbdV0uZm4uY2FsbChjW3VdLmNvbnRleHQsbixyLHMpO2JyZWFrO2RlZmF1bHQ6aWYoIWwpZm9yKE09MSxsPW5ldyBBcnJheShwLTEpO008cDtNKyspbFtNLTFdPWFyZ3VtZW50c1tNXTtjW3VdLmZuLmFwcGx5KGNbdV0uY29udGV4dCxsKX19cmV0dXJuITB9O3kucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGUsbixyKXtyZXR1cm4gdHQodGhpcyxlLG4sciwhMSl9O3kucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24oZSxuLHIpe3JldHVybiB0dCh0aGlzLGUsbixyLCEwKX07eS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9ZnVuY3Rpb24oZSxuLHIscyl7dmFyIG89VD9UK2U6ZTtpZighdGhpcy5fZXZlbnRzW29dKXJldHVybiB0aGlzO2lmKCFuKXJldHVybiBvZSh0aGlzLG8pLHRoaXM7dmFyIGE9dGhpcy5fZXZlbnRzW29dO2lmKGEuZm4pYS5mbj09PW4mJighc3x8YS5vbmNlKSYmKCFyfHxhLmNvbnRleHQ9PT1yKSYmb2UodGhpcyxvKTtlbHNle2Zvcih2YXIgaT0wLGM9W10scD1hLmxlbmd0aDtpPHA7aSsrKShhW2ldLmZuIT09bnx8cyYmIWFbaV0ub25jZXx8ciYmYVtpXS5jb250ZXh0IT09cikmJmMucHVzaChhW2ldKTtjLmxlbmd0aD90aGlzLl9ldmVudHNbb109Yy5sZW5ndGg9PT0xP2NbMF06YzpvZSh0aGlzLG8pfXJldHVybiB0aGlzfTt5LnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIG47cmV0dXJuIGU/KG49VD9UK2U6ZSx0aGlzLl9ldmVudHNbbl0mJm9lKHRoaXMsbikpOih0aGlzLl9ldmVudHM9bmV3IEIsdGhpcy5fZXZlbnRzQ291bnQ9MCksdGhpc307eS5wcm90b3R5cGUub2ZmPXkucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO3kucHJvdG90eXBlLmFkZExpc3RlbmVyPXkucHJvdG90eXBlLm9uO3kucHJlZml4ZWQ9VDt5LkV2ZW50RW1pdHRlcj15O3R5cGVvZiBmZSE9XCJ1bmRlZmluZWRcIiYmKGZlLmV4cG9ydHM9eSl9KTtmdW5jdGlvbiBBdCh0KXtsZXQgZT17ZXhwb3J0czp7fX07cmV0dXJuIHQoZSxlLmV4cG9ydHMpLGUuZXhwb3J0c312YXIgTHQ9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDkwMDcxOTkyNTQ3NDA5OTE7dmFyIG1lPXtTRU1WRVJfU1BFQ19WRVJTSU9OOlwiMi4wLjBcIixNQVhfTEVOR1RIOjI1NixNQVhfU0FGRV9JTlRFR0VSOkx0LE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEg6MTZ9LFN0PXR5cGVvZiBwcm9jZXNzPT1cIm9iamVjdFwiJiZwcm9jZXNzLmVudiYmcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyYmL1xcYnNlbXZlclxcYi9pLnRlc3QocHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyk/KC4uLnQpPT5jb25zb2xlLmVycm9yKFwiU0VNVkVSXCIsLi4udCk6KCk9Pnt9LGQ9U3QsSz1BdChmdW5jdGlvbih0LGUpe2xldHtNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIOm59PW1lLHI9KGU9dC5leHBvcnRzPXt9KS5yZT1bXSxzPWUuc3JjPVtdLG89ZS50PXt9LGE9MCxpPShjLHAsbCk9PntsZXQgdT1hKys7ZCh1LHApLG9bY109dSxzW3VdPXAsclt1XT1uZXcgUmVnRXhwKHAsbD9cImdcIjp2b2lkIDApfTtpKFwiTlVNRVJJQ0lERU5USUZJRVJcIixcIjB8WzEtOV1cXFxcZCpcIiksaShcIk5VTUVSSUNJREVOVElGSUVSTE9PU0VcIixcIlswLTldK1wiKSxpKFwiTk9OTlVNRVJJQ0lERU5USUZJRVJcIixcIlxcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSpcIiksaShcIk1BSU5WRVJTSU9OXCIsYCgke3Nbby5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuKCR7c1tvLk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC4oJHtzW28uTlVNRVJJQ0lERU5USUZJRVJdfSlgKSxpKFwiTUFJTlZFUlNJT05MT09TRVwiLGAoJHtzW28uTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuKCR7c1tvLk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLigke3Nbby5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYCksaShcIlBSRVJFTEVBU0VJREVOVElGSUVSXCIsYCg/OiR7c1tvLk5VTUVSSUNJREVOVElGSUVSXX18JHtzW28uTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKSxpKFwiUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRVwiLGAoPzoke3Nbby5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18JHtzW28uTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKSxpKFwiUFJFUkVMRUFTRVwiLGAoPzotKCR7c1tvLlBSRVJFTEVBU0VJREVOVElGSUVSXX0oPzpcXFxcLiR7c1tvLlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYCksaShcIlBSRVJFTEVBU0VMT09TRVwiLGAoPzotPygke3Nbby5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0oPzpcXFxcLiR7c1tvLlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKSxpKFwiQlVJTERJREVOVElGSUVSXCIsXCJbMC05QS1aYS16LV0rXCIpLGkoXCJCVUlMRFwiLGAoPzpcXFxcKygke3Nbby5CVUlMRElERU5USUZJRVJdfSg/OlxcXFwuJHtzW28uQlVJTERJREVOVElGSUVSXX0pKikpYCksaShcIkZVTExQTEFJTlwiLGB2PyR7c1tvLk1BSU5WRVJTSU9OXX0ke3Nbby5QUkVSRUxFQVNFXX0/JHtzW28uQlVJTERdfT9gKSxpKFwiRlVMTFwiLGBeJHtzW28uRlVMTFBMQUlOXX0kYCksaShcIkxPT1NFUExBSU5cIixgW3Y9XFxcXHNdKiR7c1tvLk1BSU5WRVJTSU9OTE9PU0VdfSR7c1tvLlBSRVJFTEVBU0VMT09TRV19PyR7c1tvLkJVSUxEXX0/YCksaShcIkxPT1NFXCIsYF4ke3Nbby5MT09TRVBMQUlOXX0kYCksaShcIkdUTFRcIixcIigoPzo8fD4pPz0/KVwiKSxpKFwiWFJBTkdFSURFTlRJRklFUkxPT1NFXCIsYCR7c1tvLk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKSxpKFwiWFJBTkdFSURFTlRJRklFUlwiLGAke3Nbby5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApLGkoXCJYUkFOR0VQTEFJTlwiLGBbdj1cXFxcc10qKCR7c1tvLlhSQU5HRUlERU5USUZJRVJdfSkoPzpcXFxcLigke3Nbby5YUkFOR0VJREVOVElGSUVSXX0pKD86XFxcXC4oJHtzW28uWFJBTkdFSURFTlRJRklFUl19KSg/OiR7c1tvLlBSRVJFTEVBU0VdfSk/JHtzW28uQlVJTERdfT8pPyk/YCksaShcIlhSQU5HRVBMQUlOTE9PU0VcIixgW3Y9XFxcXHNdKigke3Nbby5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzpcXFxcLigke3Nbby5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzpcXFxcLigke3Nbby5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzoke3Nbby5QUkVSRUxFQVNFTE9PU0VdfSk/JHtzW28uQlVJTERdfT8pPyk/YCksaShcIlhSQU5HRVwiLGBeJHtzW28uR1RMVF19XFxcXHMqJHtzW28uWFJBTkdFUExBSU5dfSRgKSxpKFwiWFJBTkdFTE9PU0VcIixgXiR7c1tvLkdUTFRdfVxcXFxzKiR7c1tvLlhSQU5HRVBMQUlOTE9PU0VdfSRgKSxpKFwiQ09FUkNFXCIsYChefFteXFxcXGRdKShcXFxcZHsxLCR7bn19KSg/OlxcXFwuKFxcXFxkezEsJHtufX0pKT8oPzpcXFxcLihcXFxcZHsxLCR7bn19KSk/KD86JHxbXlxcXFxkXSlgKSxpKFwiQ09FUkNFUlRMXCIsc1tvLkNPRVJDRV0sITApLGkoXCJMT05FVElMREVcIixcIig/On4+PylcIiksaShcIlRJTERFVFJJTVwiLGAoXFxcXHMqKSR7c1tvLkxPTkVUSUxERV19XFxcXHMrYCwhMCksZS50aWxkZVRyaW1SZXBsYWNlPVwiJDF+XCIsaShcIlRJTERFXCIsYF4ke3Nbby5MT05FVElMREVdfSR7c1tvLlhSQU5HRVBMQUlOXX0kYCksaShcIlRJTERFTE9PU0VcIixgXiR7c1tvLkxPTkVUSUxERV19JHtzW28uWFJBTkdFUExBSU5MT09TRV19JGApLGkoXCJMT05FQ0FSRVRcIixcIig/OlxcXFxeKVwiKSxpKFwiQ0FSRVRUUklNXCIsYChcXFxccyopJHtzW28uTE9ORUNBUkVUXX1cXFxccytgLCEwKSxlLmNhcmV0VHJpbVJlcGxhY2U9XCIkMV5cIixpKFwiQ0FSRVRcIixgXiR7c1tvLkxPTkVDQVJFVF19JHtzW28uWFJBTkdFUExBSU5dfSRgKSxpKFwiQ0FSRVRMT09TRVwiLGBeJHtzW28uTE9ORUNBUkVUXX0ke3Nbby5YUkFOR0VQTEFJTkxPT1NFXX0kYCksaShcIkNPTVBBUkFUT1JMT09TRVwiLGBeJHtzW28uR1RMVF19XFxcXHMqKCR7c1tvLkxPT1NFUExBSU5dfSkkfF4kYCksaShcIkNPTVBBUkFUT1JcIixgXiR7c1tvLkdUTFRdfVxcXFxzKigke3Nbby5GVUxMUExBSU5dfSkkfF4kYCksaShcIkNPTVBBUkFUT1JUUklNXCIsYChcXFxccyopJHtzW28uR1RMVF19XFxcXHMqKCR7c1tvLkxPT1NFUExBSU5dfXwke3Nbby5YUkFOR0VQTEFJTl19KWAsITApLGUuY29tcGFyYXRvclRyaW1SZXBsYWNlPVwiJDEkMiQzXCIsaShcIkhZUEhFTlJBTkdFXCIsYF5cXFxccyooJHtzW28uWFJBTkdFUExBSU5dfSlcXFxccystXFxcXHMrKCR7c1tvLlhSQU5HRVBMQUlOXX0pXFxcXHMqJGApLGkoXCJIWVBIRU5SQU5HRUxPT1NFXCIsYF5cXFxccyooJHtzW28uWFJBTkdFUExBSU5MT09TRV19KVxcXFxzKy1cXFxccysoJHtzW28uWFJBTkdFUExBSU5MT09TRV19KVxcXFxzKiRgKSxpKFwiU1RBUlwiLFwiKDx8Pik/PT9cXFxccypcXFxcKlwiKSxpKFwiR1RFMFwiLFwiXlxcXFxzKj49XFxcXHMqMC4wLjBcXFxccyokXCIpLGkoXCJHVEUwUFJFXCIsXCJeXFxcXHMqPj1cXFxccyowLjAuMC0wXFxcXHMqJFwiKX0pLEFlPS9eWzAtOV0rJC8sTGU9KHQsZSk9PntsZXQgbj1BZS50ZXN0KHQpLHI9QWUudGVzdChlKTtyZXR1cm4gbiYmciYmKHQ9K3QsZT0rZSksdD09PWU/MDpuJiYhcj8tMTpyJiYhbj8xOnQ8ZT8tMToxfSxPdD0odCxlKT0+TGUoZSx0KSxDdD17Y29tcGFyZUlkZW50aWZpZXJzOkxlLHJjb21wYXJlSWRlbnRpZmllcnM6T3R9LHtNQVhfTEVOR1RIOlNlLE1BWF9TQUZFX0lOVEVHRVI6WX09bWUse3JlOk9lLHQ6Q2V9PUsse2NvbXBhcmVJZGVudGlmaWVyczpqfT1DdCxFPWNsYXNze2NvbnN0cnVjdG9yKGUsbil7aWYobiYmdHlwZW9mIG49PVwib2JqZWN0XCJ8fChuPXtsb29zZTohIW4saW5jbHVkZVByZXJlbGVhc2U6ITF9KSxlIGluc3RhbmNlb2YgRSl7aWYoZS5sb29zZT09PSEhbi5sb29zZSYmZS5pbmNsdWRlUHJlcmVsZWFzZT09PSEhbi5pbmNsdWRlUHJlcmVsZWFzZSlyZXR1cm4gZTtlPWUudmVyc2lvbn1lbHNlIGlmKHR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgVmVyc2lvbjogJHtlfWApO2lmKGUubGVuZ3RoPlNlKXRocm93IG5ldyBUeXBlRXJyb3IoYHZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJHtTZX0gY2hhcmFjdGVyc2ApO2QoXCJTZW1WZXJcIixlLG4pLHRoaXMub3B0aW9ucz1uLHRoaXMubG9vc2U9ISFuLmxvb3NlLHRoaXMuaW5jbHVkZVByZXJlbGVhc2U9ISFuLmluY2x1ZGVQcmVyZWxlYXNlO2xldCByPWUudHJpbSgpLm1hdGNoKG4ubG9vc2U/T2VbQ2UuTE9PU0VdOk9lW0NlLkZVTExdKTtpZighcil0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7ZX1gKTtpZih0aGlzLnJhdz1lLHRoaXMubWFqb3I9K3JbMV0sdGhpcy5taW5vcj0rclsyXSx0aGlzLnBhdGNoPStyWzNdLHRoaXMubWFqb3I+WXx8dGhpcy5tYWpvcjwwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIG1ham9yIHZlcnNpb25cIik7aWYodGhpcy5taW5vcj5ZfHx0aGlzLm1pbm9yPDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgbWlub3IgdmVyc2lvblwiKTtpZih0aGlzLnBhdGNoPll8fHRoaXMucGF0Y2g8MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBwYXRjaCB2ZXJzaW9uXCIpO3JbNF0/dGhpcy5wcmVyZWxlYXNlPXJbNF0uc3BsaXQoXCIuXCIpLm1hcChzPT57aWYoL15bMC05XSskLy50ZXN0KHMpKXtsZXQgbz0rcztpZihvPj0wJiZvPFkpcmV0dXJuIG99cmV0dXJuIHN9KTp0aGlzLnByZXJlbGVhc2U9W10sdGhpcy5idWlsZD1yWzVdP3JbNV0uc3BsaXQoXCIuXCIpOltdLHRoaXMuZm9ybWF0KCl9Zm9ybWF0KCl7cmV0dXJuIHRoaXMudmVyc2lvbj1gJHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gLHRoaXMucHJlcmVsZWFzZS5sZW5ndGgmJih0aGlzLnZlcnNpb24rPWAtJHt0aGlzLnByZXJlbGVhc2Uuam9pbihcIi5cIil9YCksdGhpcy52ZXJzaW9ufXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMudmVyc2lvbn1jb21wYXJlKGUpe2lmKGQoXCJTZW1WZXIuY29tcGFyZVwiLHRoaXMudmVyc2lvbix0aGlzLm9wdGlvbnMsZSksIShlIGluc3RhbmNlb2YgRSkpe2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiJiZlPT09dGhpcy52ZXJzaW9uKXJldHVybiAwO2U9bmV3IEUoZSx0aGlzLm9wdGlvbnMpfXJldHVybiBlLnZlcnNpb249PT10aGlzLnZlcnNpb24/MDp0aGlzLmNvbXBhcmVNYWluKGUpfHx0aGlzLmNvbXBhcmVQcmUoZSl9Y29tcGFyZU1haW4oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBFfHwoZT1uZXcgRShlLHRoaXMub3B0aW9ucykpLGoodGhpcy5tYWpvcixlLm1ham9yKXx8aih0aGlzLm1pbm9yLGUubWlub3IpfHxqKHRoaXMucGF0Y2gsZS5wYXRjaCl9Y29tcGFyZVByZShlKXtpZihlIGluc3RhbmNlb2YgRXx8KGU9bmV3IEUoZSx0aGlzLm9wdGlvbnMpKSx0aGlzLnByZXJlbGVhc2UubGVuZ3RoJiYhZS5wcmVyZWxlYXNlLmxlbmd0aClyZXR1cm4tMTtpZighdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCYmZS5wcmVyZWxlYXNlLmxlbmd0aClyZXR1cm4gMTtpZighdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCYmIWUucHJlcmVsZWFzZS5sZW5ndGgpcmV0dXJuIDA7bGV0IG49MDtkb3tsZXQgcj10aGlzLnByZXJlbGVhc2Vbbl0scz1lLnByZXJlbGVhc2Vbbl07aWYoZChcInByZXJlbGVhc2UgY29tcGFyZVwiLG4scixzKSxyPT09dm9pZCAwJiZzPT09dm9pZCAwKXJldHVybiAwO2lmKHM9PT12b2lkIDApcmV0dXJuIDE7aWYocj09PXZvaWQgMClyZXR1cm4tMTtpZihyIT09cylyZXR1cm4gaihyLHMpfXdoaWxlKCsrbil9Y29tcGFyZUJ1aWxkKGUpe2UgaW5zdGFuY2VvZiBFfHwoZT1uZXcgRShlLHRoaXMub3B0aW9ucykpO2xldCBuPTA7ZG97bGV0IHI9dGhpcy5idWlsZFtuXSxzPWUuYnVpbGRbbl07aWYoZChcInByZXJlbGVhc2UgY29tcGFyZVwiLG4scixzKSxyPT09dm9pZCAwJiZzPT09dm9pZCAwKXJldHVybiAwO2lmKHM9PT12b2lkIDApcmV0dXJuIDE7aWYocj09PXZvaWQgMClyZXR1cm4tMTtpZihyIT09cylyZXR1cm4gaihyLHMpfXdoaWxlKCsrbil9aW5jKGUsbil7c3dpdGNoKGUpe2Nhc2VcInByZW1ham9yXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD0wLHRoaXMucGF0Y2g9MCx0aGlzLm1pbm9yPTAsdGhpcy5tYWpvcisrLHRoaXMuaW5jKFwicHJlXCIsbik7YnJlYWs7Y2FzZVwicHJlbWlub3JcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPTAsdGhpcy5wYXRjaD0wLHRoaXMubWlub3IrKyx0aGlzLmluYyhcInByZVwiLG4pO2JyZWFrO2Nhc2VcInByZXBhdGNoXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD0wLHRoaXMuaW5jKFwicGF0Y2hcIixuKSx0aGlzLmluYyhcInByZVwiLG4pO2JyZWFrO2Nhc2VcInByZXJlbGVhc2VcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCYmdGhpcy5pbmMoXCJwYXRjaFwiLG4pLHRoaXMuaW5jKFwicHJlXCIsbik7YnJlYWs7Y2FzZVwibWFqb3JcIjp0aGlzLm1pbm9yPT09MCYmdGhpcy5wYXRjaD09PTAmJnRoaXMucHJlcmVsZWFzZS5sZW5ndGghPT0wfHx0aGlzLm1ham9yKyssdGhpcy5taW5vcj0wLHRoaXMucGF0Y2g9MCx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwibWlub3JcIjp0aGlzLnBhdGNoPT09MCYmdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCE9PTB8fHRoaXMubWlub3IrKyx0aGlzLnBhdGNoPTAsdGhpcy5wcmVyZWxlYXNlPVtdO2JyZWFrO2Nhc2VcInBhdGNoXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD09PTAmJnRoaXMucGF0Y2grKyx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwicHJlXCI6aWYodGhpcy5wcmVyZWxlYXNlLmxlbmd0aD09PTApdGhpcy5wcmVyZWxlYXNlPVswXTtlbHNle2xldCByPXRoaXMucHJlcmVsZWFzZS5sZW5ndGg7Zm9yKDstLXI+PTA7KXR5cGVvZiB0aGlzLnByZXJlbGVhc2Vbcl09PVwibnVtYmVyXCImJih0aGlzLnByZXJlbGVhc2Vbcl0rKyxyPS0yKTtyPT09LTEmJnRoaXMucHJlcmVsZWFzZS5wdXNoKDApfW4mJih0aGlzLnByZXJlbGVhc2VbMF09PT1uP2lzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkmJih0aGlzLnByZXJlbGVhc2U9W24sMF0pOnRoaXMucHJlcmVsZWFzZT1bbiwwXSk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5jcmVtZW50IGFyZ3VtZW50OiAke2V9YCl9cmV0dXJuIHRoaXMuZm9ybWF0KCksdGhpcy5yYXc9dGhpcy52ZXJzaW9uLHRoaXN9fSxfdD0odCxlLG4pPT5uZXcgRSh0LG4pLmNvbXBhcmUobmV3IEUoZSxuKSksaz1fdCxEdD0odCxlLG4pPT5rKHQsZSxuKT09PTAsa3Q9RHQsSnQ9KHQsZSxuKT0+ayh0LGUsbikhPT0wLHF0PUp0LEd0PSh0LGUsbik9PmsodCxlLG4pPjAsVXQ9R3QsS3Q9KHQsZSxuKT0+ayh0LGUsbik+PTAsanQ9S3QsRnQ9KHQsZSxuKT0+ayh0LGUsbik8MCxXdD1GdCxYdD0odCxlLG4pPT5rKHQsZSxuKTw9MCxCdD1YdCxIdD0odCxlLG4scik9Pntzd2l0Y2goZSl7Y2FzZVwiPT09XCI6cmV0dXJuIHR5cGVvZiB0PT1cIm9iamVjdFwiJiYodD10LnZlcnNpb24pLHR5cGVvZiBuPT1cIm9iamVjdFwiJiYobj1uLnZlcnNpb24pLHQ9PT1uO2Nhc2VcIiE9PVwiOnJldHVybiB0eXBlb2YgdD09XCJvYmplY3RcIiYmKHQ9dC52ZXJzaW9uKSx0eXBlb2Ygbj09XCJvYmplY3RcIiYmKG49bi52ZXJzaW9uKSx0IT09bjtjYXNlXCJcIjpjYXNlXCI9XCI6Y2FzZVwiPT1cIjpyZXR1cm4ga3QodCxuLHIpO2Nhc2VcIiE9XCI6cmV0dXJuIHF0KHQsbixyKTtjYXNlXCI+XCI6cmV0dXJuIFV0KHQsbixyKTtjYXNlXCI+PVwiOnJldHVybiBqdCh0LG4scik7Y2FzZVwiPFwiOnJldHVybiBXdCh0LG4scik7Y2FzZVwiPD1cIjpyZXR1cm4gQnQodCxuLHIpO2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBvcGVyYXRvcjogJHtlfWApfX0sRWU9SHQsRj1TeW1ib2woXCJTZW1WZXIgQU5ZXCIpLE89Y2xhc3N7c3RhdGljIGdldCBBTlkoKXtyZXR1cm4gRn1jb25zdHJ1Y3RvcihlLG4pe2lmKG4mJnR5cGVvZiBuPT1cIm9iamVjdFwifHwobj17bG9vc2U6ISFuLGluY2x1ZGVQcmVyZWxlYXNlOiExfSksZSBpbnN0YW5jZW9mIE8pe2lmKGUubG9vc2U9PT0hIW4ubG9vc2UpcmV0dXJuIGU7ZT1lLnZhbHVlfWQoXCJjb21wYXJhdG9yXCIsZSxuKSx0aGlzLm9wdGlvbnM9bix0aGlzLmxvb3NlPSEhbi5sb29zZSx0aGlzLnBhcnNlKGUpLHRoaXMuc2VtdmVyPT09Rj90aGlzLnZhbHVlPVwiXCI6dGhpcy52YWx1ZT10aGlzLm9wZXJhdG9yK3RoaXMuc2VtdmVyLnZlcnNpb24sZChcImNvbXBcIix0aGlzKX1wYXJzZShlKXtsZXQgbj10aGlzLm9wdGlvbnMubG9vc2U/X2VbRGUuQ09NUEFSQVRPUkxPT1NFXTpfZVtEZS5DT01QQVJBVE9SXSxyPWUubWF0Y2gobik7aWYoIXIpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBjb21wYXJhdG9yOiAke2V9YCk7dGhpcy5vcGVyYXRvcj1yWzFdIT09dm9pZCAwP3JbMV06XCJcIix0aGlzLm9wZXJhdG9yPT09XCI9XCImJih0aGlzLm9wZXJhdG9yPVwiXCIpLHJbMl0/dGhpcy5zZW12ZXI9bmV3IEUoclsyXSx0aGlzLm9wdGlvbnMubG9vc2UpOnRoaXMuc2VtdmVyPUZ9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy52YWx1ZX10ZXN0KGUpe2lmKGQoXCJDb21wYXJhdG9yLnRlc3RcIixlLHRoaXMub3B0aW9ucy5sb29zZSksdGhpcy5zZW12ZXI9PT1GfHxlPT09RilyZXR1cm4hMDtpZih0eXBlb2YgZT09XCJzdHJpbmdcIil0cnl7ZT1uZXcgRShlLHRoaXMub3B0aW9ucyl9Y2F0Y2gobil7cmV0dXJuITF9cmV0dXJuIEVlKGUsdGhpcy5vcGVyYXRvcix0aGlzLnNlbXZlcix0aGlzLm9wdGlvbnMpfWludGVyc2VjdHMoZSxuKXtpZighKGUgaW5zdGFuY2VvZiBPKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYSBDb21wYXJhdG9yIGlzIHJlcXVpcmVkXCIpO2lmKG4mJnR5cGVvZiBuPT1cIm9iamVjdFwifHwobj17bG9vc2U6ISFuLGluY2x1ZGVQcmVyZWxlYXNlOiExfSksdGhpcy5vcGVyYXRvcj09PVwiXCIpcmV0dXJuIHRoaXMudmFsdWU9PT1cIlwifHxuZXcgTihlLnZhbHVlLG4pLnRlc3QodGhpcy52YWx1ZSk7aWYoZS5vcGVyYXRvcj09PVwiXCIpcmV0dXJuIGUudmFsdWU9PT1cIlwifHxuZXcgTih0aGlzLnZhbHVlLG4pLnRlc3QoZS5zZW12ZXIpO2xldCByPSEodGhpcy5vcGVyYXRvciE9PVwiPj1cIiYmdGhpcy5vcGVyYXRvciE9PVwiPlwifHxlLm9wZXJhdG9yIT09XCI+PVwiJiZlLm9wZXJhdG9yIT09XCI+XCIpLHM9ISh0aGlzLm9wZXJhdG9yIT09XCI8PVwiJiZ0aGlzLm9wZXJhdG9yIT09XCI8XCJ8fGUub3BlcmF0b3IhPT1cIjw9XCImJmUub3BlcmF0b3IhPT1cIjxcIiksbz10aGlzLnNlbXZlci52ZXJzaW9uPT09ZS5zZW12ZXIudmVyc2lvbixhPSEodGhpcy5vcGVyYXRvciE9PVwiPj1cIiYmdGhpcy5vcGVyYXRvciE9PVwiPD1cInx8ZS5vcGVyYXRvciE9PVwiPj1cIiYmZS5vcGVyYXRvciE9PVwiPD1cIiksaT1FZSh0aGlzLnNlbXZlcixcIjxcIixlLnNlbXZlcixuKSYmKHRoaXMub3BlcmF0b3I9PT1cIj49XCJ8fHRoaXMub3BlcmF0b3I9PT1cIj5cIikmJihlLm9wZXJhdG9yPT09XCI8PVwifHxlLm9wZXJhdG9yPT09XCI8XCIpLGM9RWUodGhpcy5zZW12ZXIsXCI+XCIsZS5zZW12ZXIsbikmJih0aGlzLm9wZXJhdG9yPT09XCI8PVwifHx0aGlzLm9wZXJhdG9yPT09XCI8XCIpJiYoZS5vcGVyYXRvcj09PVwiPj1cInx8ZS5vcGVyYXRvcj09PVwiPlwiKTtyZXR1cm4gcnx8c3x8byYmYXx8aXx8Y319LHtyZTpfZSx0OkRlfT1LLE49Y2xhc3N7Y29uc3RydWN0b3IoZSxuKXtpZihuJiZ0eXBlb2Ygbj09XCJvYmplY3RcInx8KG49e2xvb3NlOiEhbixpbmNsdWRlUHJlcmVsZWFzZTohMX0pLGUgaW5zdGFuY2VvZiBOKXJldHVybiBlLmxvb3NlPT09ISFuLmxvb3NlJiZlLmluY2x1ZGVQcmVyZWxlYXNlPT09ISFuLmluY2x1ZGVQcmVyZWxlYXNlP2U6bmV3IE4oZS5yYXcsbik7aWYoZSBpbnN0YW5jZW9mIE8pcmV0dXJuIHRoaXMucmF3PWUudmFsdWUsdGhpcy5zZXQ9W1tlXV0sdGhpcy5mb3JtYXQoKSx0aGlzO2lmKHRoaXMub3B0aW9ucz1uLHRoaXMubG9vc2U9ISFuLmxvb3NlLHRoaXMuaW5jbHVkZVByZXJlbGVhc2U9ISFuLmluY2x1ZGVQcmVyZWxlYXNlLHRoaXMucmF3PWUsdGhpcy5zZXQ9ZS5zcGxpdCgvXFxzKlxcfFxcfFxccyovKS5tYXAocj0+dGhpcy5wYXJzZVJhbmdlKHIudHJpbSgpKSkuZmlsdGVyKHI9PnIubGVuZ3RoKSwhdGhpcy5zZXQubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgU2VtVmVyIFJhbmdlOiAke2V9YCk7dGhpcy5mb3JtYXQoKX1mb3JtYXQoKXtyZXR1cm4gdGhpcy5yYW5nZT10aGlzLnNldC5tYXAoZT0+ZS5qb2luKFwiIFwiKS50cmltKCkpLmpvaW4oXCJ8fFwiKS50cmltKCksdGhpcy5yYW5nZX10b1N0cmluZygpe3JldHVybiB0aGlzLnJhbmdlfXBhcnNlUmFuZ2UoZSl7bGV0e2xvb3NlOm59PXRoaXMub3B0aW9ucztlPWUudHJpbSgpO2xldCByPW4/Z1tmLkhZUEhFTlJBTkdFTE9PU0VdOmdbZi5IWVBIRU5SQU5HRV07ZT1lLnJlcGxhY2Uocixjbih0aGlzLm9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpKSxkKFwiaHlwaGVuIHJlcGxhY2VcIixlKSxlPWUucmVwbGFjZShnW2YuQ09NUEFSQVRPUlRSSU1dLFZ0KSxkKFwiY29tcGFyYXRvciB0cmltXCIsZSxnW2YuQ09NUEFSQVRPUlRSSU1dKSxlPShlPShlPWUucmVwbGFjZShnW2YuVElMREVUUklNXSx6dCkpLnJlcGxhY2UoZ1tmLkNBUkVUVFJJTV0sWXQpKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpO2xldCBzPW4/Z1tmLkNPTVBBUkFUT1JMT09TRV06Z1tmLkNPTVBBUkFUT1JdO3JldHVybiBlLnNwbGl0KFwiIFwiKS5tYXAobz0+WnQobyx0aGlzLm9wdGlvbnMpKS5qb2luKFwiIFwiKS5zcGxpdCgvXFxzKy8pLm1hcChvPT5hbihvLHRoaXMub3B0aW9ucykpLmZpbHRlcih0aGlzLm9wdGlvbnMubG9vc2U/bz0+ISFvLm1hdGNoKHMpOigpPT4hMCkubWFwKG89Pm5ldyBPKG8sdGhpcy5vcHRpb25zKSl9aW50ZXJzZWN0cyhlLG4pe2lmKCEoZSBpbnN0YW5jZW9mIE4pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhIFJhbmdlIGlzIHJlcXVpcmVkXCIpO3JldHVybiB0aGlzLnNldC5zb21lKHI9PmtlKHIsbikmJmUuc2V0LnNvbWUocz0+a2UocyxuKSYmci5ldmVyeShvPT5zLmV2ZXJ5KGE9Pm8uaW50ZXJzZWN0cyhhLG4pKSkpKX10ZXN0KGUpe2lmKCFlKXJldHVybiExO2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKXRyeXtlPW5ldyBFKGUsdGhpcy5vcHRpb25zKX1jYXRjaChuKXtyZXR1cm4hMX1mb3IobGV0IG49MDtuPHRoaXMuc2V0Lmxlbmd0aDtuKyspaWYobG4odGhpcy5zZXRbbl0sZSx0aGlzLm9wdGlvbnMpKXJldHVybiEwO3JldHVybiExfX0se3JlOmcsdDpmLGNvbXBhcmF0b3JUcmltUmVwbGFjZTpWdCx0aWxkZVRyaW1SZXBsYWNlOnp0LGNhcmV0VHJpbVJlcGxhY2U6WXR9PUssa2U9KHQsZSk9PntsZXQgbj0hMCxyPXQuc2xpY2UoKSxzPXIucG9wKCk7Zm9yKDtuJiZyLmxlbmd0aDspbj1yLmV2ZXJ5KG89PnMuaW50ZXJzZWN0cyhvLGUpKSxzPXIucG9wKCk7cmV0dXJuIG59LFp0PSh0LGUpPT4oZChcImNvbXBcIix0LGUpLHQ9dG4odCxlKSxkKFwiY2FyZXRcIix0KSx0PVF0KHQsZSksZChcInRpbGRlc1wiLHQpLHQ9cm4odCxlKSxkKFwieHJhbmdlXCIsdCksdD1vbih0LGUpLGQoXCJzdGFyc1wiLHQpLHQpLFI9dD0+IXR8fHQudG9Mb3dlckNhc2UoKT09PVwieFwifHx0PT09XCIqXCIsUXQ9KHQsZSk9PnQudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKG49PmVuKG4sZSkpLmpvaW4oXCIgXCIpLGVuPSh0LGUpPT57bGV0IG49ZS5sb29zZT9nW2YuVElMREVMT09TRV06Z1tmLlRJTERFXTtyZXR1cm4gdC5yZXBsYWNlKG4sKHIscyxvLGEsaSk9PntsZXQgYztyZXR1cm4gZChcInRpbGRlXCIsdCxyLHMsbyxhLGkpLFIocyk/Yz1cIlwiOlIobyk/Yz1gPj0ke3N9LjAuMCA8JHsrcysxfS4wLjAtMGA6UihhKT9jPWA+PSR7c30uJHtvfS4wIDwke3N9LiR7K28rMX0uMC0wYDppPyhkKFwicmVwbGFjZVRpbGRlIHByXCIsaSksYz1gPj0ke3N9LiR7b30uJHthfS0ke2l9IDwke3N9LiR7K28rMX0uMC0wYCk6Yz1gPj0ke3N9LiR7b30uJHthfSA8JHtzfS4keytvKzF9LjAtMGAsZChcInRpbGRlIHJldHVyblwiLGMpLGN9KX0sdG49KHQsZSk9PnQudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKG49Pm5uKG4sZSkpLmpvaW4oXCIgXCIpLG5uPSh0LGUpPT57ZChcImNhcmV0XCIsdCxlKTtsZXQgbj1lLmxvb3NlP2dbZi5DQVJFVExPT1NFXTpnW2YuQ0FSRVRdLHI9ZS5pbmNsdWRlUHJlcmVsZWFzZT9cIi0wXCI6XCJcIjtyZXR1cm4gdC5yZXBsYWNlKG4sKHMsbyxhLGksYyk9PntsZXQgcDtyZXR1cm4gZChcImNhcmV0XCIsdCxzLG8sYSxpLGMpLFIobyk/cD1cIlwiOlIoYSk/cD1gPj0ke299LjAuMCR7cn0gPCR7K28rMX0uMC4wLTBgOlIoaSk/cD1vPT09XCIwXCI/YD49JHtvfS4ke2F9LjAke3J9IDwke299LiR7K2ErMX0uMC0wYDpgPj0ke299LiR7YX0uMCR7cn0gPCR7K28rMX0uMC4wLTBgOmM/KGQoXCJyZXBsYWNlQ2FyZXQgcHJcIixjKSxwPW89PT1cIjBcIj9hPT09XCIwXCI/YD49JHtvfS4ke2F9LiR7aX0tJHtjfSA8JHtvfS4ke2F9LiR7K2krMX0tMGA6YD49JHtvfS4ke2F9LiR7aX0tJHtjfSA8JHtvfS4keythKzF9LjAtMGA6YD49JHtvfS4ke2F9LiR7aX0tJHtjfSA8JHsrbysxfS4wLjAtMGApOihkKFwibm8gcHJcIikscD1vPT09XCIwXCI/YT09PVwiMFwiP2A+PSR7b30uJHthfS4ke2l9JHtyfSA8JHtvfS4ke2F9LiR7K2krMX0tMGA6YD49JHtvfS4ke2F9LiR7aX0ke3J9IDwke299LiR7K2ErMX0uMC0wYDpgPj0ke299LiR7YX0uJHtpfSA8JHsrbysxfS4wLjAtMGApLGQoXCJjYXJldCByZXR1cm5cIixwKSxwfSl9LHJuPSh0LGUpPT4oZChcInJlcGxhY2VYUmFuZ2VzXCIsdCxlKSx0LnNwbGl0KC9cXHMrLykubWFwKG49PnNuKG4sZSkpLmpvaW4oXCIgXCIpKSxzbj0odCxlKT0+e3Q9dC50cmltKCk7bGV0IG49ZS5sb29zZT9nW2YuWFJBTkdFTE9PU0VdOmdbZi5YUkFOR0VdO3JldHVybiB0LnJlcGxhY2UobiwocixzLG8sYSxpLGMpPT57ZChcInhSYW5nZVwiLHQscixzLG8sYSxpLGMpO2xldCBwPVIobyksbD1wfHxSKGEpLHU9bHx8UihpKSx2PXU7cmV0dXJuIHM9PT1cIj1cIiYmdiYmKHM9XCJcIiksYz1lLmluY2x1ZGVQcmVyZWxlYXNlP1wiLTBcIjpcIlwiLHA/cj1zPT09XCI+XCJ8fHM9PT1cIjxcIj9cIjwwLjAuMC0wXCI6XCIqXCI6cyYmdj8obCYmKGE9MCksaT0wLHM9PT1cIj5cIj8ocz1cIj49XCIsbD8obz0rbysxLGE9MCxpPTApOihhPSthKzEsaT0wKSk6cz09PVwiPD1cIiYmKHM9XCI8XCIsbD9vPStvKzE6YT0rYSsxKSxzPT09XCI8XCImJihjPVwiLTBcIikscj1gJHtzK299LiR7YX0uJHtpfSR7Y31gKTpsP3I9YD49JHtvfS4wLjAke2N9IDwkeytvKzF9LjAuMC0wYDp1JiYocj1gPj0ke299LiR7YX0uMCR7Y30gPCR7b30uJHsrYSsxfS4wLTBgKSxkKFwieFJhbmdlIHJldHVyblwiLHIpLHJ9KX0sb249KHQsZSk9PihkKFwicmVwbGFjZVN0YXJzXCIsdCxlKSx0LnRyaW0oKS5yZXBsYWNlKGdbZi5TVEFSXSxcIlwiKSksYW49KHQsZSk9PihkKFwicmVwbGFjZUdURTBcIix0LGUpLHQudHJpbSgpLnJlcGxhY2UoZ1tlLmluY2x1ZGVQcmVyZWxlYXNlP2YuR1RFMFBSRTpmLkdURTBdLFwiXCIpKSxjbj10PT4oZSxuLHIscyxvLGEsaSxjLHAsbCx1LHYsTSk9PmAke249UihyKT9cIlwiOlIocyk/YD49JHtyfS4wLjAke3Q/XCItMFwiOlwiXCJ9YDpSKG8pP2A+PSR7cn0uJHtzfS4wJHt0P1wiLTBcIjpcIlwifWA6YT9gPj0ke259YDpgPj0ke259JHt0P1wiLTBcIjpcIlwifWB9ICR7Yz1SKHApP1wiXCI6UihsKT9gPCR7K3ArMX0uMC4wLTBgOlIodSk/YDwke3B9LiR7K2wrMX0uMC0wYDp2P2A8PSR7cH0uJHtsfS4ke3V9LSR7dn1gOnQ/YDwke3B9LiR7bH0uJHsrdSsxfS0wYDpgPD0ke2N9YH1gLnRyaW0oKSxsbj0odCxlLG4pPT57Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspaWYoIXRbcl0udGVzdChlKSlyZXR1cm4hMTtpZihlLnByZXJlbGVhc2UubGVuZ3RoJiYhbi5pbmNsdWRlUHJlcmVsZWFzZSl7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspaWYoZCh0W3JdLnNlbXZlciksdFtyXS5zZW12ZXIhPT1PLkFOWSYmdFtyXS5zZW12ZXIucHJlcmVsZWFzZS5sZW5ndGg+MCl7bGV0IHM9dFtyXS5zZW12ZXI7aWYocy5tYWpvcj09PWUubWFqb3ImJnMubWlub3I9PT1lLm1pbm9yJiZzLnBhdGNoPT09ZS5wYXRjaClyZXR1cm4hMH1yZXR1cm4hMX1yZXR1cm4hMH0sSmU9KHQsZSxuKT0+e3RyeXtlPW5ldyBOKGUsbil9Y2F0Y2gocil7cmV0dXJuITF9cmV0dXJuIGUudGVzdCh0KX07dmFye01BWF9MRU5HVEg6cG59PW1lLHtyZTpxZSx0OkdlfT1LLHVuPSh0LGUpPT57aWYoZSYmdHlwZW9mIGU9PVwib2JqZWN0XCJ8fChlPXtsb29zZTohIWUsaW5jbHVkZVByZXJlbGVhc2U6ITF9KSx0IGluc3RhbmNlb2YgRSlyZXR1cm4gdDtpZih0eXBlb2YgdCE9XCJzdHJpbmdcInx8dC5sZW5ndGg+cG58fCEoZS5sb29zZT9xZVtHZS5MT09TRV06cWVbR2UuRlVMTF0pLnRlc3QodCkpcmV0dXJuIG51bGw7dHJ5e3JldHVybiBuZXcgRSh0LGUpfWNhdGNoKG4pe3JldHVybiBudWxsfX0sZG49dW4se3JlOlosdDpRfT1LLFVlPSh0LGUpPT57aWYodCBpbnN0YW5jZW9mIEUpcmV0dXJuIHQ7aWYodHlwZW9mIHQ9PVwibnVtYmVyXCImJih0PVN0cmluZyh0KSksdHlwZW9mIHQhPVwic3RyaW5nXCIpcmV0dXJuIG51bGw7bGV0IG49bnVsbDtpZigoZT1lfHx7fSkucnRsKXtsZXQgcjtmb3IoOyhyPVpbUS5DT0VSQ0VSVExdLmV4ZWModCkpJiYoIW58fG4uaW5kZXgrblswXS5sZW5ndGghPT10Lmxlbmd0aCk7KW4mJnIuaW5kZXgrclswXS5sZW5ndGg9PT1uLmluZGV4K25bMF0ubGVuZ3RofHwobj1yKSxaW1EuQ09FUkNFUlRMXS5sYXN0SW5kZXg9ci5pbmRleCtyWzFdLmxlbmd0aCtyWzJdLmxlbmd0aDtaW1EuQ09FUkNFUlRMXS5sYXN0SW5kZXg9LTF9ZWxzZSBuPXQubWF0Y2goWltRLkNPRVJDRV0pO3JldHVybiBuPT09bnVsbD9udWxsOmRuKGAke25bMl19LiR7blszXXx8XCIwXCJ9LiR7bls0XXx8XCIwXCJ9YCxlKX07ZnVuY3Rpb24gbW4odCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodC5zbGljZSgxKSwxNikpfWZ1bmN0aW9uIEVuKHQpe3JldHVybmAlJHtgMDAke3QuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNil9YC5zbGljZSgtMil9YH1mdW5jdGlvbiBobih0KXtyZXR1cm4gYnRvYShlbmNvZGVVUklDb21wb25lbnQodCkucmVwbGFjZSgvJVswLTlBLUZdezJ9L2csbW4pKX1mdW5jdGlvbiBmbih0KXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KEFycmF5LmZyb20oYXRvYih0KSxFbikuam9pbihcIlwiKSl9ZnVuY3Rpb24gZWUodCl7cmV0dXJuIGhuKEpTT04uc3RyaW5naWZ5KHQpKX1mdW5jdGlvbiBLZSh0KXtyZXR1cm4gSlNPTi5wYXJzZShmbih0KSl9aW1wb3J0e1JQQ0Vycm9yQ29kZSBhcyB2bixTREtFcnJvckNvZGUgYXMgSixTREtXYXJuaW5nQ29kZSBhcyByZX1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7aW1wb3J0e01hZ2ljUGF5bG9hZE1ldGhvZCBhcyBnbixSUENFcnJvckNvZGUgYXMgeW59ZnJvbVwiQG1hZ2ljLXNkay90eXBlc1wiO2Z1bmN0aW9uICQodCl7cmV0dXJuIHR5cGVvZiB0PT1cInVuZGVmaW5lZFwifWZ1bmN0aW9uIFJuKHQpe3JldHVybiB0PT09bnVsbH1mdW5jdGlvbiB0ZSh0KXtyZXR1cm4gUm4odCl8fCQodCl9ZnVuY3Rpb24gZXIodCl7cmV0dXJuIHRlKHQpPyExOiEkKHQuanNvbnJwYykmJiEkKHQuaWQpJiYhJCh0Lm1ldGhvZCkmJiEkKHQucGFyYW1zKX1mdW5jdGlvbiBqZSh0KXtyZXR1cm4gdGUodCk/ITE6ISQodC5qc29ucnBjKSYmISQodC5pZCkmJighJCh0LnJlc3VsdCl8fCEkKHQuZXJyb3IpKX1mdW5jdGlvbiB0cih0KXtyZXR1cm4gdGUodCk/ITE6dHlwZW9mIHQ9PVwic3RyaW5nXCImJk9iamVjdC52YWx1ZXMoZ24pLmluY2x1ZGVzKHQpfWZ1bmN0aW9uIEZlKHQpe3JldHVybiB0ZSh0KT8hMTp0eXBlb2YgdD09XCJudW1iZXJcIiYmT2JqZWN0LnZhbHVlcyh5bikuaW5jbHVkZXModCl9ZnVuY3Rpb24gbmUodCl7aWYoIXQpcmV0dXJuITA7Zm9yKGxldCBlIGluIHQpaWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxlKSlyZXR1cm4hMTtyZXR1cm4hMH12YXIgbT17fTtmdW5jdGlvbiBUbih0LGUpe3JldHVybiBPYmplY3QuYXNzaWduKG0sZSksdH12YXIgV2U9e1wibWFnaWMtc2RrXCI6XCJtYWdpYy1zZGtcIixcIkBtYWdpYy1zZGsvcmVhY3QtbmF0aXZlXCI6XCJtYWdpYy1zZGstcm5cIn07dmFyIGI9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihlLG4pe3N1cGVyKGBNYWdpYyBTREsgRXJyb3I6IFske2V9XSAke259YCk7dGhpcy5jb2RlPWU7dGhpcy5yYXdNZXNzYWdlPW47dGhpcy5fX3Byb3RvX189RXJyb3I7T2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsYi5wcm90b3R5cGUpfX0sdz1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGUpe3N1cGVyKCk7dGhpcy5fX3Byb3RvX189RXJyb3I7bGV0IG49TnVtYmVyKGU9PW51bGw/dm9pZCAwOmUuY29kZSk7dGhpcy5yYXdNZXNzYWdlPShlPT1udWxsP3ZvaWQgMDplLm1lc3NhZ2UpfHxcIkludGVybmFsIGVycm9yXCIsdGhpcy5jb2RlPUZlKG4pP246dm4uSW50ZXJuYWxFcnJvcix0aGlzLm1lc3NhZ2U9YE1hZ2ljIFJQQyBFcnJvcjogWyR7dGhpcy5jb2RlfV0gJHt0aGlzLnJhd01lc3NhZ2V9YCxPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyx3LnByb3RvdHlwZSl9fSxXPWNsYXNze2NvbnN0cnVjdG9yKGUsbil7dGhpcy5jb2RlPWU7dGhpcy5yYXdNZXNzYWdlPW47dGhpcy5tZXNzYWdlPWBNYWdpYyBTREsgV2FybmluZzogWyR7ZX1dICR7bn1gfWxvZygpe2NvbnNvbGUud2Fybih0aGlzLm1lc3NhZ2UpfX0sWD1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGUsbixyLHMpe3N1cGVyKGBNYWdpYyBFeHRlbnNpb24gRXJyb3IgKCR7ZS5uYW1lfSk6IFske259XSAke3J9YCk7dGhpcy5jb2RlPW47dGhpcy5yYXdNZXNzYWdlPXI7dGhpcy5kYXRhPXM7dGhpcy5fX3Byb3RvX189RXJyb3I7T2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsWC5wcm90b3R5cGUpfX0sc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSxuLHIpe3RoaXMuY29kZT1uO3RoaXMucmF3TWVzc2FnZT1yO3RoaXMubWVzc2FnZT1gTWFnaWMgRXh0ZW5zaW9uIFdhcm5pbmcgKCR7ZS5uYW1lfSk6IFske259XSAke3J9YH1sb2coKXtjb25zb2xlLndhcm4odGhpcy5tZXNzYWdlKX19O2Z1bmN0aW9uIFhlKCl7cmV0dXJuIG5ldyBiKEouTWlzc2luZ0FwaUtleSxcIlBsZWFzZSBwcm92aWRlIGFuIEFQSSBrZXkgdGhhdCB5b3UgYWNxdWlyZWQgZnJvbSB0aGUgTWFnaWMgZGV2ZWxvcGVyIGRhc2hib2FyZC5cIil9ZnVuY3Rpb24gY3IoKXtyZXR1cm4gbmV3IGIoSi5Nb2RhbE5vdFJlYWR5LFwiTW9kYWwgaXMgbm90IHJlYWR5LlwiKX1mdW5jdGlvbiBCZSgpe3JldHVybiBuZXcgYihKLk1hbGZvcm1lZFJlc3BvbnNlLFwiUmVzcG9uc2UgZnJvbSB0aGUgTWFnaWMgaWZyYW1lIGlzIG1hbGZvcm1lZC5cIil9ZnVuY3Rpb24gSGUodCl7cmV0dXJuIG5ldyBiKEouRXh0ZW5zaW9uTm90SW5pdGlhbGl6ZWQsYEV4dGVuc2lvbnMgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgTWFnaWMgU0RLIGluc3RhbmNlIGJlZm9yZSBcXGBFeHRlbnNpb24uJHt0fVxcYCBjYW4gYmUgYWNjZXNzZWQuIERvIG5vdCBpbnZva2UgXFxgRXh0ZW5zaW9uLiR7dH1cXGAgaW5zaWRlIGFuIGV4dGVuc2lvbiBjb25zdHJ1Y3Rvci5gKX1mdW5jdGlvbiBWZSh0KXtsZXQgZT1gU29tZSBleHRlbnNpb25zIGFyZSBpbmNvbXBhdGlibGUgd2l0aCBcXGAke20uc2RrTmFtZX1AJHttLnZlcnNpb259XFxgOmA7cmV0dXJuIHQuZmlsdGVyKG49PnR5cGVvZiBuLmNvbXBhdCE9XCJ1bmRlZmluZWRcIiYmbi5jb21wYXQhPT1udWxsKS5mb3JFYWNoKG49PntsZXQgcj1uLmNvbXBhdFttLnNka05hbWVdO3R5cGVvZiByPT1cInN0cmluZ1wiP2UrPWBcbiAgLSBFeHRlbnNpb24gXFxgJHtuLm5hbWV9XFxgIHN1cHBvcnRzIHZlcnNpb24ocykgXFxgJHtyfVxcYGA6cnx8KGUrPWBcbiAgLSBFeHRlbnNpb24gXFxgJHtuLm5hbWV9XFxgIGRvZXMgbm90IHN1cHBvcnQgJHttLnBsYXRmb3JtfSBlbnZpcm9ubWVudHMuYCl9KSxuZXcgYihKLkluY29tcGF0aWJsZUV4dGVuc2lvbnMsZSl9ZnVuY3Rpb24gemUodCl7bGV0IGU9bj0+e2xldCByPW4rMSxzPXIlMTAsbz1yJTEwMDtyZXR1cm4gcz09PTEmJm8hPT0xMT9gJHtyfXN0YDpzPT09MiYmbyE9PTEyP2Ake3J9bmRgOnM9PT0zJiZvIT09MTM/YCR7cn1yZGA6YCR7cn10aGB9O3JldHVybiBuZXcgYihKLkludmFsaWRBcmd1bWVudCxgSW52YWxpZCAke2UodC5hcmd1bWVudCl9IGFyZ3VtZW50IGdpdmVuIHRvIFxcYCR7dC5wcm9jZWR1cmV9XFxgLlxuICBFeHBlY3RlZDogXFxgJHt0LmV4cGVjdGVkfVxcYFxuICBSZWNlaXZlZDogXFxgJHt0LnJlY2VpdmVkfVxcYGApfWZ1bmN0aW9uIGxyKCl7cmV0dXJuIG5ldyBXKHJlLkR1cGxpY2F0ZUlmcmFtZSxcIkR1cGxpY2F0ZSBpZnJhbWVzIGZvdW5kLlwiKX1mdW5jdGlvbiBZZSgpe3JldHVybiBuZXcgVyhyZS5TeW5jV2ViM01ldGhvZCxcIk5vbi1hc3luYyB3ZWIzIG1ldGhvZHMgYXJlIGRlcHJlY2F0ZWQgaW4gd2ViMyA+IDEuMCBhbmQgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIE1hZ2ljIHdlYjMgcHJvdmlkZXIuIFBsZWFzZSB1c2UgYW4gYXN5bmMgbWV0aG9kIGluc3RlYWQuXCIpfWZ1bmN0aW9uIFplKCl7cmV0dXJuIG5ldyBXKHJlLlJlYWN0TmF0aXZlRW5kcG9pbnRDb25maWd1cmF0aW9uLGBDVVNUT00gRE9NQUlOUyBBUkUgTk9UIFNVUFBPUlRFRCBXSEVOIFVTSU5HIE1BR0lDIFNESyBXSVRIIFJFQUNUIE5BVElWRSEgVGhlIFxcYGVuZHBvaW50XFxgIHBhcmFtZXRlciBTSE9VTEQgTk9UIGJlIHByb3ZpZGVkLiBUaGUgTWFnaWMgXFxgPGlmcmFtZT5cXGAgaXMgYXV0b21hdGljYWxseSB3cmFwcGVkIGJ5IGEgV2ViVmlldyBwb2ludGVkIGF0IFxcYCR7bS5kZWZhdWx0RW5kcG9pbnR9XFxgLiBDaGFuZ2luZyB0aGlzIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBsZWFkIHRvIHVuZXhwZWN0ZWQgcmVzdWx0cyBhbmQgcG90ZW50aWFsbHkgc2VjdXJpdHktdGhyZWF0ZW5pbmcgYnVncy5gKX1mdW5jdGlvbiBwcih0KXtsZXR7bWV0aG9kOmUscmVtb3ZhbFZlcnNpb25zOm4sdXNlSW5zdGVhZDpyfT10LHM9blttLnNka05hbWVdLG89cj9gIFVzZSBcXGAke3J9XFxgIGluc3RlYWQuYDpcIlwiLGE9YFxcYCR7ZX1cXGAgd2lsbCBiZSByZW1vdmVkIGZyb20gXFxgJHttLnNka05hbWV9XFxgIGluIHZlcnNpb24gXFxgJHtzfVxcYC4ke299YDtyZXR1cm4gbmV3IFcocmUuRGVwcmVjYXRpb25Ob3RpY2UsYSl9aW1wb3J0e01hZ2ljUGF5bG9hZE1ldGhvZCBhcyBBfWZyb21cIkBtYWdpYy1zZGsvdHlwZXNcIjtpbXBvcnR7TWFnaWNPdXRnb2luZ1dpbmRvd01lc3NhZ2UgYXMgTW4sTWFnaWNJbmNvbWluZ1dpbmRvd01lc3NhZ2UgYXMgTm59ZnJvbVwiQG1hZ2ljLXNkay90eXBlc1wiO2Z1bmN0aW9uKnhuKCl7bGV0IHQ9MDtmb3IoOzspdDxOdW1iZXIuTUFYX1NBRkVfSU5URUdFUj95aWVsZCsrdDp0PTB9dmFyIEluPXhuKCk7ZnVuY3Rpb24gaGUoKXtyZXR1cm4gSW4ubmV4dCgpLnZhbHVlfXZhciBRZT1TeW1ib2woXCJQYXlsb2FkIHByZS1wcm9jZXNzZWQgYnkgTWFnaWMgU0RLXCIpO2Z1bmN0aW9uIGV0KHQpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodCxRZSx7dmFsdWU6ITAsZW51bWVyYWJsZTohMX0pLHR9ZnVuY3Rpb24gUG4odCl7cmV0dXJuISF0W1FlXX1mdW5jdGlvbiBDKHQpe3ZhciBlLG4scjtyZXR1cm4gUG4odCl8fCh0Lmpzb25ycGM9KGU9dC5qc29ucnBjKSE9bnVsbD9lOlwiMi4wXCIsdC5pZD1oZSgpLHQubWV0aG9kPShuPXQubWV0aG9kKSE9bnVsbD9uOlwibm9vcFwiLHQucGFyYW1zPShyPXQucGFyYW1zKSE9bnVsbD9yOltdLGV0KHQpKSx0fWZ1bmN0aW9uIGgodCxlPVtdKXtyZXR1cm4gZXQoe3BhcmFtczplLG1ldGhvZDp0LGpzb25ycGM6XCIyLjBcIixpZDpoZSgpfSl9dmFyIF89Y2xhc3N7Y29uc3RydWN0b3IoZSl7ZSBpbnN0YW5jZW9mIF8/KHRoaXMuX2pzb25ycGM9ZS5wYXlsb2FkLmpzb25ycGMsdGhpcy5faWQ9ZS5wYXlsb2FkLmlkLHRoaXMuX3Jlc3VsdD1lLnBheWxvYWQucmVzdWx0LHRoaXMuX2Vycm9yPWUucGF5bG9hZC5lcnJvcik6amUoZSk/KHRoaXMuX2pzb25ycGM9ZS5qc29ucnBjLHRoaXMuX2lkPWUuaWQsdGhpcy5fcmVzdWx0PWUucmVzdWx0LHRoaXMuX2Vycm9yPWUuZXJyb3IpOih0aGlzLl9qc29ucnBjPWUuanNvbnJwYyx0aGlzLl9pZD1lLmlkLHRoaXMuX3Jlc3VsdD12b2lkIDAsdGhpcy5fZXJyb3I9dm9pZCAwKX1hcHBseUVycm9yKGUpe3JldHVybiB0aGlzLl9lcnJvcj1lLHRoaXN9YXBwbHlSZXN1bHQoZSl7cmV0dXJuIHRoaXMuX3Jlc3VsdD1lLHRoaXN9Z2V0IGhhc0Vycm9yKCl7cmV0dXJuIHR5cGVvZiB0aGlzLl9lcnJvciE9XCJ1bmRlZmluZWRcIiYmdGhpcy5fZXJyb3IhPT1udWxsfWdldCBoYXNSZXN1bHQoKXtyZXR1cm4gdHlwZW9mIHRoaXMuX3Jlc3VsdCE9XCJ1bmRlZmluZWRcIn1nZXQgcGF5bG9hZCgpe3JldHVybntqc29ucnBjOnRoaXMuX2pzb25ycGMsaWQ6dGhpcy5faWQscmVzdWx0OnRoaXMuX3Jlc3VsdCxlcnJvcjp0aGlzLl9lcnJvcn19fTt2YXIgcnQ9d3QobnQoKSksc3Q9Y2xhc3MgZXh0ZW5kcyBydC5kZWZhdWx0e307ZnVuY3Rpb24gaWUoKXtsZXQgdD1uZXcgc3Q7cmV0dXJue2VtaXR0ZXI6dCxjcmVhdGVDaGFpbmluZ0VtaXR0ZXJNZXRob2Q6KHIscyk9PiguLi5vKT0+KHRbcl0uYXBwbHkodCxvKSxzKSxjcmVhdGVCb3VuZEVtaXR0ZXJNZXRob2Q6cj0+KC4uLnMpPT50W3JdLmFwcGx5KHQscyl9fXZhciBvdD1TeW1ib2woXCJpc1Byb21pRXZlbnRcIik7ZnVuY3Rpb24gaXQodCl7cmV0dXJuISF0W290XX1mdW5jdGlvbiBhZSh0KXtsZXQgZT1nZSh0KSx7Y3JlYXRlQm91bmRFbWl0dGVyTWV0aG9kOm4sY3JlYXRlQ2hhaW5pbmdFbWl0dGVyTWV0aG9kOnJ9PWllKCkscz1TeW1ib2woXCJQcm9taXNlLnRoZW5cIiksbz1TeW1ib2woXCJQcm9taXNlLmNhdGNoXCIpLGE9U3ltYm9sKFwiUHJvbWlzZS5maW5hbGx5XCIpLGk9KGwsdSk9PiguLi52KT0+e2xldCBNPXVbbF0uYXBwbHkodSx2KTtyZXR1cm4gYyhNKX0sYz1sPT5PYmplY3QuYXNzaWduKGwse1tvdF06ITAsW3NdOmxbc118fGwudGhlbixbb106bFtvXXx8bC5jYXRjaCxbYV06bFthXXx8bC5maW5hbGx5LHRoZW46aShzLGwpLGNhdGNoOmkobyxsKSxmaW5hbGx5OmkoYSxsKSxvbjpyKFwib25cIixsKSxvbmNlOnIoXCJvbmNlXCIsbCksYWRkTGlzdGVuZXI6cihcImFkZExpc3RlbmVyXCIsbCksb2ZmOnIoXCJvZmZcIixsKSxyZW1vdmVMaXN0ZW5lcjpyKFwicmVtb3ZlTGlzdGVuZXJcIixsKSxyZW1vdmVBbGxMaXN0ZW5lcnM6cihcInJlbW92ZUFsbExpc3RlbmVyc1wiLGwpLGVtaXQ6bihcImVtaXRcIiksZXZlbnROYW1lczpuKFwiZXZlbnROYW1lc1wiKSxsaXN0ZW5lcnM6bihcImxpc3RlbmVyc1wiKSxsaXN0ZW5lckNvdW50Om4oXCJsaXN0ZW5lckNvdW50XCIpfSkscD1jKGUudGhlbihsPT4ocC5lbWl0KFwiZG9uZVwiLGwpLHAuZW1pdChcInNldHRsZWRcIiksbCksbD0+e3Rocm93IHAuZW1pdChcImVycm9yXCIsbCkscC5lbWl0KFwic2V0dGxlZFwiKSxsfSkpO3JldHVybiBwfWZ1bmN0aW9uIGdlKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoZSxuKT0+e2xldCByPXQoZSxuKTtQcm9taXNlLnJlc29sdmUocikuY2F0Y2gobil9KX12YXIgUD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnNkaz1lfWdldCBvdmVybGF5KCl7cmV0dXJuIHRoaXMuc2RrLm92ZXJsYXl9cmVxdWVzdChlKXtsZXQgbj10aGlzLm92ZXJsYXkucG9zdChNbi5NQUdJQ19IQU5ETEVfUkVRVUVTVCxDKGUpKSxyPWFlKChvLGEpPT57bi50aGVuKGk9PntpZihzKCksaS5oYXNFcnJvcilhKG5ldyB3KGkucGF5bG9hZC5lcnJvcikpO2Vsc2UgaWYoaS5oYXNSZXN1bHQpbyhpLnBheWxvYWQucmVzdWx0KTtlbHNlIHRocm93IEJlKCl9KS5jYXRjaChpPT57cygpLGEoaSl9KX0pLHM9dGhpcy5vdmVybGF5Lm9uKE5uLk1BR0lDX0hBTkRMRV9FVkVOVCxvPT57dmFyIGk7bGV0e3Jlc3BvbnNlOmF9PW8uZGF0YTtpZihhLmlkPT09ZS5pZCYmKChpPWEucmVzdWx0KT09bnVsbD92b2lkIDA6aS5ldmVudCkpe2xldHtldmVudDpjLHBhcmFtczpwPVtdfT1hLnJlc3VsdDtyLmVtaXQoYywuLi5wKX19KTtyZXR1cm4gcn19O3ZhciB5ZT1jbGFzcyBleHRlbmRzIFB7bG9naW5XaXRoTWFnaWNMaW5rKGUpe2xldHtlbWFpbDpuLHNob3dVSTpyPSEwLHJlZGlyZWN0VVJJOnN9PWUsbz1oKHRoaXMuc2RrLnRlc3RNb2RlP0EuTG9naW5XaXRoTWFnaWNMaW5rVGVzdE1vZGU6QS5Mb2dpbldpdGhNYWdpY0xpbmssW3tlbWFpbDpuLHNob3dVSTpyLHJlZGlyZWN0VVJJOnN9XSk7cmV0dXJuIHRoaXMucmVxdWVzdChvKX1sb2dpbldpdGhTTVMoZSl7bGV0e3Bob25lTnVtYmVyOm59PWUscj1oKHRoaXMuc2RrLnRlc3RNb2RlP0EuTG9naW5XaXRoU21zVGVzdE1vZGU6QS5Mb2dpbldpdGhTbXMsW3twaG9uZU51bWJlcjpuLHNob3dVSTohMH1dKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KHIpfWxvZ2luV2l0aEVtYWlsT1RQKGUpe2xldHtlbWFpbDpufT1lLHI9aCh0aGlzLnNkay50ZXN0TW9kZT9BLkxvZ2luV2l0aEVtYWlsT1RQVGVzdE1vZGU6QS5Mb2dpbldpdGhFbWFpbE9UUCxbe2VtYWlsOm4sc2hvd1VJOiEwfV0pO3JldHVybiB0aGlzLnJlcXVlc3Qocil9bG9naW5XaXRoQ3JlZGVudGlhbChlKXtsZXQgbj1lIT1udWxsP2U6XCJcIjtpZighZSYmbS5wbGF0Zm9ybT09PVwid2ViXCIpe249d2luZG93LmxvY2F0aW9uLnNlYXJjaDtsZXQgcz13aW5kb3cubG9jYXRpb24ub3JpZ2luK3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTt3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUobnVsbCxcIlwiLHMpfWxldCByPWgodGhpcy5zZGsudGVzdE1vZGU/QS5Mb2dpbldpdGhDcmVkZW50aWFsVGVzdE1vZGU6QS5Mb2dpbldpdGhDcmVkZW50aWFsLFtuXSk7cmV0dXJuIHRoaXMucmVxdWVzdChyKX19O2ltcG9ydHtNYWdpY1BheWxvYWRNZXRob2QgYXMgeH1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7dmFyIEg9e307TXQoSCx7Y2xlYXI6KCk9PnduLGdldEl0ZW06KCk9PkQsaXRlcmF0ZTooKT0+T24sa2V5OigpPT5MbixrZXlzOigpPT5TbixsZW5ndGg6KCk9PkFuLHJlbW92ZUl0ZW06KCk9PmxlLHNldEl0ZW06KCk9PnF9KTt2YXIgY2U7ZnVuY3Rpb24gTCh0KXtyZXR1cm4oLi4uZSk9PkkodGhpcyxudWxsLGZ1bmN0aW9uKigpe3JldHVybiBjZXx8KGNlPXlpZWxkIG0uY29uZmlndXJlU3RvcmFnZSgpKSx5aWVsZCBjZS5yZWFkeSgpLGNlW3RdKC4uLmUpfSl9dmFyIEQ9TChcImdldEl0ZW1cIikscT1MKFwic2V0SXRlbVwiKSxsZT1MKFwicmVtb3ZlSXRlbVwiKSx3bj1MKFwiY2xlYXJcIiksQW49TChcImxlbmd0aFwiKSxMbj1MKFwia2V5XCIpLFNuPUwoXCJrZXlzXCIpLE9uPUwoXCJpdGVyYXRlXCIpO2Z1bmN0aW9uIGF0KCl7bGV0IHQ9d2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoMTYpKTt0WzZdPXRbNl0mMTV8NjQsdFs4XT10WzhdJjE5MXwxMjg7bGV0IGU9XCJcIjtyZXR1cm4gZSs9dFswXS50b1N0cmluZygxNiksZSs9dFsxXS50b1N0cmluZygxNiksZSs9dFsyXS50b1N0cmluZygxNiksZSs9dFszXS50b1N0cmluZygxNiksZSs9XCItXCIsZSs9dFs0XS50b1N0cmluZygxNiksZSs9dFs1XS50b1N0cmluZygxNiksZSs9XCItXCIsZSs9dFs2XS50b1N0cmluZygxNiksZSs9dFs3XS50b1N0cmluZygxNiksZSs9XCItXCIsZSs9dFs4XS50b1N0cmluZygxNiksZSs9dFs5XS50b1N0cmluZygxNiksZSs9XCItXCIsZSs9dFsxMF0udG9TdHJpbmcoMTYpLGUrPXRbMTFdLnRvU3RyaW5nKDE2KSxlKz10WzEyXS50b1N0cmluZygxNiksZSs9dFsxM10udG9TdHJpbmcoMTYpLGUrPXRbMTRdLnRvU3RyaW5nKDE2KSxlKz10WzE1XS50b1N0cmluZygxNiksZX12YXIgUmU9XCJTVE9SRV9LRVlfUFJJVkFURV9LRVlcIixwZT1cIlNUT1JFX0tFWV9QVUJMSUNfSldLXCIsVGU9XCJFQ0RTQVwiLGN0PVwiUC0yNTZcIixDbj17bmFtZTpUZSxuYW1lZEN1cnZlOmN0fSxfbj17bmFtZTpUZSxuYW1lZEN1cnZlOmN0fTtmdW5jdGlvbiBsdCgpe2xlKHBlKSxsZShSZSl9ZnVuY3Rpb24gcHQoKXtyZXR1cm4gSSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7bGV0IHQ9eWllbGQgRG4oKTtpZighdCl7Y29uc29sZS5pbmZvKFwidW5hYmxlIHRvIGNyZWF0ZSBwdWJsaWMga2V5IG9yIHdlYmNyeXB0byBpcyB1bnN1cHBvcnRlZFwiKTtyZXR1cm59bGV0e3N1YnRsZTplfT13aW5kb3cuY3J5cHRvLG49eWllbGQgRChSZSk7aWYoIW58fCFlKXtjb25zb2xlLmluZm8oXCJ1bmFibGUgdG8gZmluZCBwcml2YXRlIGtleSBvciB3ZWJjcnlwdG8gdW5zdXBwb3J0ZWRcIik7cmV0dXJufWxldCByPXtpYXQ6TWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKS8xZTMpLGp0aTphdCgpfSxzPXt0eXA6XCJkcG9wK2p3dFwiLGFsZzpcIkVTMjU2XCIsandrOnR9LG89e3Byb3RlY3RlZDp1dChKU09OLnN0cmluZ2lmeShzKSksY2xhaW1zOnV0KEpTT04uc3RyaW5naWZ5KHIpKX0sYT1xbihgJHtvLnByb3RlY3RlZH0uJHtvLmNsYWltc31gKSxpPXtuYW1lOlRlLGhhc2g6e25hbWU6XCJTSEEtMjU2XCJ9fSxjPVVuKG5ldyBVaW50OEFycmF5KHlpZWxkIGUuc2lnbihpLG4sYSkpKTtyZXR1cm5gJHtvLnByb3RlY3RlZH0uJHtvLmNsYWltc30uJHtjfWB9KX1mdW5jdGlvbiBEbigpe3JldHVybiBJKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtpZighSm4oKSl7Y29uc29sZS5pbmZvKFwid2ViY3J5cHRvIGlzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJufXJldHVybih5aWVsZCBEKHBlKSl8fCh5aWVsZCBrbigpKSxEKHBlKX0pfWZ1bmN0aW9uIGtuKCl7cmV0dXJuIEkodGhpcyxudWxsLGZ1bmN0aW9uKigpe2xldCB0PW51bGwse3N1YnRsZTplfT13aW5kb3cuY3J5cHRvLG49eWllbGQgZS5nZW5lcmF0ZUtleShDbiwhMCxbXCJzaWduXCJdKSxyPXlpZWxkIGUuZXhwb3J0S2V5KFwiandrXCIsbi5wcml2YXRlS2V5KTt0PXlpZWxkIGUuZXhwb3J0S2V5KFwiandrXCIsbi5wdWJsaWNLZXkpO2xldCBzPXlpZWxkIGUuaW1wb3J0S2V5KFwiandrXCIscixfbiwhMSxbXCJzaWduXCJdKTt5aWVsZCBxKFJlLHMpLHlpZWxkIHEocGUsdCl9KX1mdW5jdGlvbiBKbigpe2xldCB0PXR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCImJiEhd2luZG93LmNyeXB0byxlPXQmJiEhd2luZG93LmNyeXB0by5zdWJ0bGU7cmV0dXJuIHQmJmV9ZnVuY3Rpb24gdXQodCl7cmV0dXJuIGR0KEduKHQpKX1mdW5jdGlvbiBxbih0KXtyZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpfWZ1bmN0aW9uIGR0KHQpe3JldHVybiBidG9hKHQpLnJlcGxhY2UoL1xcKy9nLFwiLVwiKS5yZXBsYWNlKC9cXC8vZyxcIl9cIikucmVwbGFjZSgvPSsvZyxcIlwiKX1mdW5jdGlvbiBHbih0KXtyZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHQpLnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2csKG4scik9PlN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQociwxNikpKX1mdW5jdGlvbiBVbih0KXtsZXQgZT1cIlwiO3JldHVybiB0LmZvckVhY2gobj0+e2UrPVN0cmluZy5mcm9tQ2hhckNvZGUobil9KSxkdChlKX12YXIgdmU9Y2xhc3MgZXh0ZW5kcyBQe2dldElkVG9rZW4oZSl7bGV0IG49aCh0aGlzLnNkay50ZXN0TW9kZT94LkdldElkVG9rZW5UZXN0TW9kZTp4LkdldElkVG9rZW4sW2VdKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KG4pfWdlbmVyYXRlSWRUb2tlbihlKXtsZXQgbj1oKHRoaXMuc2RrLnRlc3RNb2RlP3guR2VuZXJhdGVJZFRva2VuVGVzdE1vZGU6eC5HZW5lcmF0ZUlkVG9rZW4sW2VdKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KG4pfWdldE1ldGFkYXRhKCl7bGV0IGU9aCh0aGlzLnNkay50ZXN0TW9kZT94LkdldE1ldGFkYXRhVGVzdE1vZGU6eC5HZXRNZXRhZGF0YSk7cmV0dXJuIHRoaXMucmVxdWVzdChlKX11cGRhdGVFbWFpbChlKXtsZXR7ZW1haWw6bixzaG93VUk6cj0hMH09ZSxzPWgodGhpcy5zZGsudGVzdE1vZGU/eC5VcGRhdGVFbWFpbFRlc3RNb2RlOnguVXBkYXRlRW1haWwsW3tlbWFpbDpuLHNob3dVSTpyfV0pO3JldHVybiB0aGlzLnJlcXVlc3Qocyl9aXNMb2dnZWRJbigpe2xldCBlPWgodGhpcy5zZGsudGVzdE1vZGU/eC5Jc0xvZ2dlZEluVGVzdE1vZGU6eC5Jc0xvZ2dlZEluKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KGUpfWxvZ291dCgpe2x0KCk7bGV0IGU9aCh0aGlzLnNkay50ZXN0TW9kZT94LkxvZ291dFRlc3RNb2RlOnguTG9nb3V0KTtyZXR1cm4gdGhpcy5yZXF1ZXN0KGUpfXNob3dTZXR0aW5ncygpe2xldCBlPWgodGhpcy5zZGsudGVzdE1vZGU/eC5Vc2VyU2V0dGluZ3NUZXN0TW9kZTp4LlVzZXJTZXR0aW5ncyk7cmV0dXJuIHRoaXMucmVxdWVzdChlKX19O2ltcG9ydHtNYWdpY091dGdvaW5nV2luZG93TWVzc2FnZSBhcyBtdH1mcm9tXCJAbWFnaWMtc2RrL3R5cGVzXCI7dmFye2NyZWF0ZUJvdW5kRW1pdHRlck1ldGhvZDp1ZSxjcmVhdGVDaGFpbmluZ0VtaXR0ZXJNZXRob2Q6R309aWUoKSx4ZT1jbGFzcyBleHRlbmRzIFB7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpO3RoaXMuaXNNYWdpYz0hMDt0aGlzLm9uPUcoXCJvblwiLHRoaXMpO3RoaXMub25jZT1HKFwib25jZVwiLHRoaXMpO3RoaXMuYWRkTGlzdGVuZXI9RyhcImFkZExpc3RlbmVyXCIsdGhpcyk7dGhpcy5vZmY9RyhcIm9mZlwiLHRoaXMpO3RoaXMucmVtb3ZlTGlzdGVuZXI9RyhcInJlbW92ZUxpc3RlbmVyXCIsdGhpcyk7dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnM9RyhcInJlbW92ZUFsbExpc3RlbmVyc1wiLHRoaXMpO3RoaXMuZW1pdD11ZShcImVtaXRcIik7dGhpcy5ldmVudE5hbWVzPXVlKFwiZXZlbnROYW1lc1wiKTt0aGlzLmxpc3RlbmVycz11ZShcImxpc3RlbmVyc1wiKTt0aGlzLmxpc3RlbmVyQ291bnQ9dWUoXCJsaXN0ZW5lckNvdW50XCIpfXNlbmRBc3luYyhlLG4pe2lmKCFuKXRocm93IHplKHtwcm9jZWR1cmU6XCJNYWdpYy5ycGNQcm92aWRlci5zZW5kQXN5bmNcIixhcmd1bWVudDoxLGV4cGVjdGVkOlwiZnVuY3Rpb25cIixyZWNlaXZlZDpuPT09bnVsbD9cIm51bGxcIjp0eXBlb2Ygbn0pO2lmKEFycmF5LmlzQXJyYXkoZSkpdGhpcy5vdmVybGF5LnBvc3QobXQuTUFHSUNfSEFORExFX1JFUVVFU1QsZS5tYXAocj0+e2xldCBzPUMocik7cmV0dXJuIHRoaXMucHJlZml4UGF5bG9hZE1ldGhvZEZvclRlc3RNb2RlKHMpLHN9KSkudGhlbihyPT57bihudWxsLHIubWFwKHM9PndlKHooe30scy5wYXlsb2FkKSx7ZXJyb3I6cy5oYXNFcnJvcj9uZXcgdyhzLnBheWxvYWQuZXJyb3IpOm51bGx9KSkpfSk7ZWxzZXtsZXQgcj1DKGUpO3RoaXMucHJlZml4UGF5bG9hZE1ldGhvZEZvclRlc3RNb2RlKHIpLHRoaXMub3ZlcmxheS5wb3N0KG10Lk1BR0lDX0hBTkRMRV9SRVFVRVNULHIpLnRoZW4ocz0+e24ocy5oYXNFcnJvcj9uZXcgdyhzLnBheWxvYWQuZXJyb3IpOm51bGwscy5wYXlsb2FkKX0pfX1zZW5kKGUsbil7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpe2xldCBzPWgoZSxBcnJheS5pc0FycmF5KG4pP246W10pO3JldHVybiB0aGlzLnJlcXVlc3Qocyl9aWYoQXJyYXkuaXNBcnJheShlKXx8ISFuKXt0aGlzLnNlbmRBc3luYyhlLG4pO3JldHVybn1sZXQgcj1ZZSgpO3JldHVybiByLmxvZygpLG5ldyBfKGUpLmFwcGx5RXJyb3Ioe2NvZGU6LTMyNjAzLG1lc3NhZ2U6ci5yYXdNZXNzYWdlfSkucGF5bG9hZH1lbmFibGUoKXtsZXQgZT1oKFwiZXRoX2FjY291bnRzXCIpO3JldHVybiB0aGlzLnJlcXVlc3QoZSl9cmVxdWVzdChlKXtyZXR1cm4gdGhpcy5wcmVmaXhQYXlsb2FkTWV0aG9kRm9yVGVzdE1vZGUoZSksc3VwZXIucmVxdWVzdChlKX1wcmVmaXhQYXlsb2FkTWV0aG9kRm9yVGVzdE1vZGUoZSl7bGV0IG49XCJ0ZXN0TW9kZS9ldGgvXCI7dGhpcy5zZGsudGVzdE1vZGUmJihlLm1ldGhvZD1gJHtufSR7ZS5tZXRob2R9YCl9fTtmdW5jdGlvbiBJZSh0LGUpe3JldHVybiBlP25ldyBVUkwodCxlKTpuZXcgVVJMKHQpfXZhciBFdD1bXCJyZXF1ZXN0XCIsXCJvdmVybGF5XCIsXCJzZGtcIl07ZnVuY3Rpb24gS24odCl7bGV0IGU9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpLG49W2VdO2Zvcig7ZSE9PVAucHJvdG90eXBlOyllPU9iamVjdC5nZXRQcm90b3R5cGVPZihlKSxuLnB1c2goZSk7cmV0dXJuIG59dmFyIFBlPWNsYXNzIGV4dGVuZHMgUHtjb25zdHJ1Y3Rvcigpe3N1cGVyKHZvaWQgMCk7dGhpcy5fX3Nka19hY2Nlc3NfZmllbGRfZGVzY3JpcHRvcnNfXz1uZXcgTWFwO3RoaXMuX19pc19pbml0aWFsaXplZF9fPSExO3RoaXMudXRpbHM9e2NyZWF0ZVByb21pRXZlbnQ6YWUsaXNQcm9taUV2ZW50Oml0LGVuY29kZUpTT046ZWUsZGVjb2RlSlNPTjpLZSxjcmVhdGVKc29uUnBjUmVxdWVzdFBheWxvYWQ6aCxzdGFuZGFyZGl6ZUpzb25ScGNSZXF1ZXN0UGF5bG9hZDpDLHN0b3JhZ2U6SH07bGV0IGU9W3RoaXMsLi4uS24odGhpcyldO0V0LmZvckVhY2gobj0+e2xldCByPWUubWFwKGk9Pk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSxuKSkscz1yLmZpbmRJbmRleChpPT4hIWkpLG89cz4wLGE9cltzXTthJiYodGhpcy5fX3Nka19hY2Nlc3NfZmllbGRfZGVzY3JpcHRvcnNfXy5zZXQobix7ZGVzY3JpcHRvcjphLGlzUHJvdG90eXBlRmllbGQ6b30pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLG4se2NvbmZpZ3VyYWJsZTohMCxnZXQ6KCk9Pnt0aHJvdyBIZShuKX19KSl9KX1pbml0KGUpe3RoaXMuX19pc19pbml0aWFsaXplZF9ffHwoRXQuZm9yRWFjaChuPT57aWYodGhpcy5fX3Nka19hY2Nlc3NfZmllbGRfZGVzY3JpcHRvcnNfXy5oYXMobikpe2xldHtkZXNjcmlwdG9yOnIsaXNQcm90b3R5cGVGaWVsZDpzfT10aGlzLl9fc2RrX2FjY2Vzc19maWVsZF9kZXNjcmlwdG9yc19fLmdldChuKTtzP2RlbGV0ZSB0aGlzW25dOk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLG4scil9fSksdGhpcy5zZGs9ZSx0aGlzLl9faXNfaW5pdGlhbGl6ZWRfXz0hMCl9Y3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKGUpe2xldHttZXRob2Q6bixyZW1vdmFsVmVyc2lvbjpyLHVzZUluc3RlYWQ6c309ZSxvPXM/YCBVc2UgXFxgJHtzfVxcYCBpbnN0ZWFkLmA6XCJcIixhPWBcXGAke259XFxgIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoaXMgRXh0ZW5zaW9uIGluIHZlcnNpb24gXFxgJHtyfVxcYC4ke299YDtyZXR1cm4gbmV3IHNlKHRoaXMsXCJERVBSRUNBVElPTl9OT1RJQ0VcIixhKX1jcmVhdGVXYXJuaW5nKGUsbil7cmV0dXJuIG5ldyBzZSh0aGlzLGUsbil9Y3JlYXRlRXJyb3IoZSxuLHIpe3JldHVybiBuZXcgWCh0aGlzLGUsbixyKX19LGh0PWNsYXNzIGV4dGVuZHMgUGV7fSxTPWNsYXNzIGV4dGVuZHMgUGV7fTtTLkludGVybmFsPWh0LFMuQW5vbnltb3VzPVwiYW5vbnltb3VzIGV4dGVuc2lvblwiO2Z1bmN0aW9uIGZ0KHQpe3JldHVybiB0LmNvbXBhdCYmdC5jb21wYXRbbS5zZGtOYW1lXSE9bnVsbD90eXBlb2YgdC5jb21wYXRbbS5zZGtOYW1lXT09XCJzdHJpbmdcIj9KZShVZShtLnZlcnNpb24pLHQuY29tcGF0W20uc2RrTmFtZV0pOiEhdC5jb21wYXRbbS5zZGtOYW1lXTohMH1mdW5jdGlvbiBqbih0KXt2YXIgcztsZXQgZT0ocz10PT1udWxsP3ZvaWQgMDp0LmV4dGVuc2lvbnMpIT1udWxsP3M6W10sbj17fSxyPVtdO2lmKEFycmF5LmlzQXJyYXkoZSk/ZS5mb3JFYWNoKG89PntmdChvKT8oby5pbml0KHRoaXMpLChvLm5hbWV8fG8ubmFtZSE9PVMuQW5vbnltb3VzKSYmKHRoaXNbby5uYW1lXT1vKSxvIGluc3RhbmNlb2YgUy5JbnRlcm5hbCYmKG5lKG8uY29uZmlnKXx8KG5bby5uYW1lXT1vLmNvbmZpZykpKTpyLnB1c2gobyl9KTpPYmplY3Qua2V5cyhlKS5mb3JFYWNoKG89PntpZihmdChlW29dKSl7ZVtvXS5pbml0KHRoaXMpO2xldCBhPWVbb107dGhpc1tvXT1hLGEgaW5zdGFuY2VvZiBTLkludGVybmFsJiYobmUoYS5jb25maWcpfHwobltlW29dLm5hbWVdPWEuY29uZmlnKSl9ZWxzZSByLnB1c2goZVtvXSl9KSxyLmxlbmd0aCl0aHJvdyBWZShyKTtyZXR1cm4gbn12YXIgVj1jbGFzc3tjb25zdHJ1Y3RvcihlLG4pe3RoaXMuYXBpS2V5PWU7dmFyIGE7aWYoIWUpdGhyb3cgWGUoKTttLnBsYXRmb3JtPT09XCJyZWFjdC1uYXRpdmVcIiYmKG49PW51bGw/dm9pZCAwOm4uZW5kcG9pbnQpJiZaZSgpLmxvZygpO2xldHtkZWZhdWx0RW5kcG9pbnQ6cix2ZXJzaW9uOnN9PW07dGhpcy50ZXN0TW9kZT0hIShuPT1udWxsP3ZvaWQgMDpuLnRlc3RNb2RlKSx0aGlzLmVuZHBvaW50PUllKChhPW49PW51bGw/dm9pZCAwOm4uZW5kcG9pbnQpIT1udWxsP2E6cikub3JpZ2luLHRoaXMuYXV0aD1uZXcgeWUodGhpcyksdGhpcy51c2VyPW5ldyB2ZSh0aGlzKSx0aGlzLnJwY1Byb3ZpZGVyPW5ldyB4ZSh0aGlzKTtsZXQgbz1qbi5jYWxsKHRoaXMsbik7dGhpcy5wYXJhbWV0ZXJzPWVlKHooe0FQSV9LRVk6dGhpcy5hcGlLZXksRE9NQUlOX09SSUdJTjp3aW5kb3cubG9jYXRpb24/d2luZG93LmxvY2F0aW9uLm9yaWdpbjpcIlwiLEVUSF9ORVRXT1JLOm49PW51bGw/dm9pZCAwOm4ubmV0d29yayxob3N0OkllKHRoaXMuZW5kcG9pbnQpLmhvc3Qsc2RrOldlW20uc2RrTmFtZV0sdmVyc2lvbjpzLGV4dDpuZShvKT92b2lkIDA6byxsb2NhbGU6KG49PW51bGw/dm9pZCAwOm4ubG9jYWxlKXx8XCJlbl9VU1wifSxtLmJ1bmRsZUlkP3tidW5kbGVJZDptLmJ1bmRsZUlkfTp7fSkpfWdldCBvdmVybGF5KCl7aWYoIVYuX19vdmVybGF5c19fLmhhcyh0aGlzLnBhcmFtZXRlcnMpKXtsZXQgZT1uZXcgbS5WaWV3Q29udHJvbGxlcih0aGlzLmVuZHBvaW50LHRoaXMucGFyYW1ldGVycyk7ZS5pbml0KCksVi5fX292ZXJsYXlzX18uc2V0KHRoaXMucGFyYW1ldGVycyxlKX1yZXR1cm4gVi5fX292ZXJsYXlzX18uZ2V0KHRoaXMucGFyYW1ldGVycyl9cHJlbG9hZCgpe3JldHVybiBJKHRoaXMsbnVsbCxmdW5jdGlvbiooKXt5aWVsZCB0aGlzLm92ZXJsYXkucmVhZHl9KX19LCRlPVY7JGUuX19vdmVybGF5c19fPW5ldyBNYXA7aW1wb3J0e01hZ2ljSW5jb21pbmdXaW5kb3dNZXNzYWdlIGFzIGRlfWZyb21cIkBtYWdpYy1zZGsvdHlwZXNcIjtmdW5jdGlvbiBGbih0LGUpe3JldHVybiBlJiZBcnJheS5pc0FycmF5KHQpP3QuZmluZChuPT5uLmlkPT09ZSk6dH1mdW5jdGlvbiBXbih0LGUpe3ZhciBzO2xldCBuPShzPWUuZGF0YS5yZXNwb25zZSk9PW51bGw/dm9pZCAwOnMuaWQscj1Gbih0LG4pO2lmKG4mJnIpe2xldCBvPW5ldyBfKHIpLmFwcGx5UmVzdWx0KGUuZGF0YS5yZXNwb25zZS5yZXN1bHQpLmFwcGx5RXJyb3IoZS5kYXRhLnJlc3BvbnNlLmVycm9yKTtyZXR1cm57aWQ6bixyZXNwb25zZTpvfX1yZXR1cm57fX1mdW5jdGlvbiBYbih0LGUpe3JldHVybiBJKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtsZXQgbj15aWVsZCBEKFwicnRcIikscjtpZihtLnBsYXRmb3JtPT09XCJ3ZWJcIil0cnl7cj15aWVsZCBwdCgpfWNhdGNoKHMpe2NvbnNvbGUuZXJyb3IoXCJ3ZWJjcnlwdG8gZXJyb3JcIixzKX1yZXR1cm4gcj9uP3ttc2dUeXBlOnQscGF5bG9hZDplLGp3dDpyLHJ0Om59Onttc2dUeXBlOnQscGF5bG9hZDplLGp3dDpyfTp7bXNnVHlwZTp0LHBheWxvYWQ6ZX19KX1mdW5jdGlvbiBCbih0KXtyZXR1cm4gSSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7IXQuZGF0YS5ydHx8KHlpZWxkIHEoXCJydFwiLHQuZGF0YS5ydCkpfSl9dmFyIGd0PWNsYXNze2NvbnN0cnVjdG9yKGUsbil7dGhpcy5lbmRwb2ludD1lO3RoaXMucGFyYW1ldGVycz1uO3RoaXMubWVzc2FnZUhhbmRsZXJzPW5ldyBTZXQ7dGhpcy5yZWFkeT10aGlzLndhaXRGb3JSZWFkeSgpLHRoaXMubGlzdGVuKCl9cG9zdChlLG4pe3JldHVybiBJKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtyZXR1cm4gZ2Uocj0+SSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7eWllbGQgdGhpcy5yZWFkeTtsZXQgcz1bXSxvPUFycmF5LmlzQXJyYXkobik/bi5tYXAocD0+cC5pZCk6W10sYT15aWVsZCBYbihgJHtlfS0ke3RoaXMucGFyYW1ldGVyc31gLG4pO3lpZWxkIHRoaXMuX3Bvc3QoYSk7bGV0IGk9cD0+bD0+e2xldHtpZDp1LHJlc3BvbnNlOnZ9PVduKG4sbCk7Qm4obCksdSYmdiYmQXJyYXkuaXNBcnJheShuKSYmby5pbmNsdWRlcyh1KT8ocy5wdXNoKHYpLHMubGVuZ3RoPT09bi5sZW5ndGgmJihwKCkscihzKSkpOnUmJnYmJiFBcnJheS5pc0FycmF5KG4pJiZ1PT09bi5pZCYmKHAoKSxyKHYpKX0sYz10aGlzLm9uKGRlLk1BR0lDX0hBTkRMRV9SRVNQT05TRSxpKCgpPT5jKCkpKX0pKX0pfW9uKGUsbil7bGV0IHI9bi5iaW5kKHdpbmRvdykscz1vPT57by5kYXRhLm1zZ1R5cGU9PT1gJHtlfS0ke3RoaXMucGFyYW1ldGVyc31gJiZyKG8pfTtyZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlcnMuYWRkKHMpLCgpPT50aGlzLm1lc3NhZ2VIYW5kbGVycy5kZWxldGUocyl9d2FpdEZvclJlYWR5KCl7cmV0dXJuIG5ldyBQcm9taXNlKGU9Pnt0aGlzLm9uKGRlLk1BR0lDX09WRVJMQVlfUkVBRFksKCk9PmUoKSl9KX1saXN0ZW4oKXt0aGlzLm9uKGRlLk1BR0lDX0hJREVfT1ZFUkxBWSwoKT0+e3RoaXMuaGlkZU92ZXJsYXkoKX0pLHRoaXMub24oZGUuTUFHSUNfU0hPV19PVkVSTEFZLCgpPT57dGhpcy5zaG93T3ZlcmxheSgpfSl9fTtleHBvcnR7UyBhcyBFeHRlbnNpb24sWCBhcyBNYWdpY0V4dGVuc2lvbkVycm9yLHNlIGFzIE1hZ2ljRXh0ZW5zaW9uV2FybmluZyx3IGFzIE1hZ2ljUlBDRXJyb3IsYiBhcyBNYWdpY1NES0Vycm9yLFcgYXMgTWFnaWNTREtXYXJuaW5nLCRlIGFzIFNES0Jhc2UsUmUgYXMgU1RPUkVfS0VZX1BSSVZBVEVfS0VZLHBlIGFzIFNUT1JFX0tFWV9QVUJMSUNfSldLLHN0IGFzIFR5cGVkRW1pdHRlcixndCBhcyBWaWV3Q29udHJvbGxlcixsdCBhcyBjbGVhcktleXMscHIgYXMgY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nLGxyIGFzIGNyZWF0ZUR1cGxpY2F0ZUlmcmFtZVdhcm5pbmcsSGUgYXMgY3JlYXRlRXh0ZW5zaW9uTm90SW5pdGlhbGl6ZWRFcnJvcixWZSBhcyBjcmVhdGVJbmNvbXBhdGlibGVFeHRlbnNpb25zRXJyb3IsemUgYXMgY3JlYXRlSW52YWxpZEFyZ3VtZW50RXJyb3IscHQgYXMgY3JlYXRlSnd0LEJlIGFzIGNyZWF0ZU1hbGZvcm1lZFJlc3BvbnNlRXJyb3IsWGUgYXMgY3JlYXRlTWlzc2luZ0FwaUtleUVycm9yLGNyIGFzIGNyZWF0ZU1vZGFsTm90UmVhZHlFcnJvcixhZSBhcyBjcmVhdGVQcm9taUV2ZW50LGdlIGFzIGNyZWF0ZVByb21pc2UsWmUgYXMgY3JlYXRlUmVhY3ROYXRpdmVFbmRwb2ludENvbmZpZ3VyYXRpb25XYXJuaW5nLFRuIGFzIGNyZWF0ZVNESyxZZSBhcyBjcmVhdGVTeW5jaHJvbm91c1dlYjNNZXRob2RXYXJuaW5nLGllIGFzIGNyZWF0ZVR5cGVkRW1pdHRlcixJZSBhcyBjcmVhdGVVUkwsS2UgYXMgZGVjb2RlSlNPTixlZSBhcyBlbmNvZGVKU09OLGhlIGFzIGdldFBheWxvYWRJZCxuZSBhcyBpc0VtcHR5LEZlIGFzIGlzSnNvblJwY0Vycm9yQ29kZSxlciBhcyBpc0pzb25ScGNSZXF1ZXN0UGF5bG9hZCxqZSBhcyBpc0pzb25ScGNSZXNwb25zZVBheWxvYWQsdHIgYXMgaXNNYWdpY1BheWxvYWRNZXRob2QsaXQgYXMgaXNQcm9taUV2ZW50LEggYXMgc3RvcmFnZSxhdCBhcyB1dWlkfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsImltcG9ydHtFeHRlbnNpb24gYXMgbixNYWdpY1NES0Vycm9yIGFzIG8sTWFnaWNFeHRlbnNpb25FcnJvciBhcyBhLE1hZ2ljRXh0ZW5zaW9uV2FybmluZyBhcyB0LE1hZ2ljUlBDRXJyb3IgYXMgcyxNYWdpY1NES1dhcm5pbmcgYXMgRSxpc1Byb21pRXZlbnQgYXMgZX1mcm9tXCJAbWFnaWMtc2RrL3Byb3ZpZGVyXCI7ZXhwb3J0KmZyb21cIkBtYWdpYy1zZGsvdHlwZXNcIjtleHBvcnR7biBhcyBFeHRlbnNpb24sYSBhcyBFeHRlbnNpb25FcnJvcix0IGFzIEV4dGVuc2lvbldhcm5pbmcscyBhcyBSUENFcnJvcixvIGFzIFNES0Vycm9yLEUgYXMgU0RLV2FybmluZyxlIGFzIGlzUHJvbWlFdmVudH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJ2YXIgWnI9T2JqZWN0LmNyZWF0ZTt2YXIgRGU9T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBxcj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBrcj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgZXQ9T2JqZWN0LmdldFByb3RvdHlwZU9mLHJ0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHR0PXA9PkRlKHAsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHZlPShwPT50eXBlb2YgcmVxdWlyZSE9XCJ1bmRlZmluZWRcIj9yZXF1aXJlOnR5cGVvZiBQcm94eSE9XCJ1bmRlZmluZWRcIj9uZXcgUHJveHkocCx7Z2V0OihnLE8pPT4odHlwZW9mIHJlcXVpcmUhPVwidW5kZWZpbmVkXCI/cmVxdWlyZTpnKVtPXX0pOnApKGZ1bmN0aW9uKHApe2lmKHR5cGVvZiByZXF1aXJlIT1cInVuZGVmaW5lZFwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicrcCsnXCIgaXMgbm90IHN1cHBvcnRlZCcpfSk7dmFyICRlPShwLGcpPT4oKT0+KGd8fHAoKGc9e2V4cG9ydHM6e319KS5leHBvcnRzLGcpLGcuZXhwb3J0cyk7dmFyIG50PShwLGcsTyxMKT0+e2lmKGcmJnR5cGVvZiBnPT1cIm9iamVjdFwifHx0eXBlb2YgZz09XCJmdW5jdGlvblwiKWZvcihsZXQgTSBvZiBrcihnKSkhcnQuY2FsbChwLE0pJiYoT3x8TSE9PVwiZGVmYXVsdFwiKSYmRGUocCxNLHtnZXQ6KCk9PmdbTV0sZW51bWVyYWJsZTohKEw9cXIoZyxNKSl8fEwuZW51bWVyYWJsZX0pO3JldHVybiBwfSxaZT0ocCxnKT0+bnQodHQoRGUocCE9bnVsbD9acihldChwKSk6e30sXCJkZWZhdWx0XCIsIWcmJnAmJnAuX19lc01vZHVsZT97Z2V0OigpPT5wLmRlZmF1bHQsZW51bWVyYWJsZTohMH06e3ZhbHVlOnAsZW51bWVyYWJsZTohMH0pKSxwKTt2YXIgc2U9KHAsZyxPKT0+bmV3IFByb21pc2UoKEwsTSk9Pnt2YXIgUT1TPT57dHJ5e1koTy5uZXh0KFMpKX1jYXRjaChQKXtNKFApfX0sQz1TPT57dHJ5e1koTy50aHJvdyhTKSl9Y2F0Y2goUCl7TShQKX19LFk9Uz0+Uy5kb25lP0woUy52YWx1ZSk6UHJvbWlzZS5yZXNvbHZlKFMudmFsdWUpLnRoZW4oUSxDKTtZKChPPU8uYXBwbHkocCxnKSkubmV4dCgpKX0pO3ZhciBrZT0kZSgocWUsTmUpPT57KGZ1bmN0aW9uKHApe2lmKHR5cGVvZiBxZT09XCJvYmplY3RcIiYmdHlwZW9mIE5lIT1cInVuZGVmaW5lZFwiKU5lLmV4cG9ydHM9cCgpO2Vsc2UgaWYodHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKWRlZmluZShbXSxwKTtlbHNle3ZhciBnO3R5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCI/Zz13aW5kb3c6dHlwZW9mIGdsb2JhbCE9XCJ1bmRlZmluZWRcIj9nPWdsb2JhbDp0eXBlb2Ygc2VsZiE9XCJ1bmRlZmluZWRcIj9nPXNlbGY6Zz10aGlzLGcubG9jYWxmb3JhZ2U9cCgpfX0pKGZ1bmN0aW9uKCl7dmFyIHAsZyxPO3JldHVybiBmdW5jdGlvbiBMKE0sUSxDKXtmdW5jdGlvbiBZKEssWil7aWYoIVFbS10pe2lmKCFNW0tdKXt2YXIgbT10eXBlb2YgdmU9PVwiZnVuY3Rpb25cIiYmdmU7aWYoIVomJm0pcmV0dXJuIG0oSywhMCk7aWYoUylyZXR1cm4gUyhLLCEwKTt2YXIgdz1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK0srXCInXCIpO3Rocm93IHcuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIix3fXZhciBOPVFbS109e2V4cG9ydHM6e319O01bS11bMF0uY2FsbChOLmV4cG9ydHMsZnVuY3Rpb24oeil7dmFyIHE9TVtLXVsxXVt6XTtyZXR1cm4gWShxfHx6KX0sTixOLmV4cG9ydHMsTCxNLFEsQyl9cmV0dXJuIFFbS10uZXhwb3J0c31mb3IodmFyIFM9dHlwZW9mIHZlPT1cImZ1bmN0aW9uXCImJnZlLFA9MDtQPEMubGVuZ3RoO1ArKylZKENbUF0pO3JldHVybiBZfSh7MTpbZnVuY3Rpb24oTCxNLFEpeyhmdW5jdGlvbihDKXtcInVzZSBzdHJpY3RcIjt2YXIgWT1DLk11dGF0aW9uT2JzZXJ2ZXJ8fEMuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixTO2lmKFkpe3ZhciBQPTAsSz1uZXcgWSh6KSxaPUMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7Sy5vYnNlcnZlKFose2NoYXJhY3RlckRhdGE6ITB9KSxTPWZ1bmN0aW9uKCl7Wi5kYXRhPVA9KytQJTJ9fWVsc2UgaWYoIUMuc2V0SW1tZWRpYXRlJiZ0eXBlb2YgQy5NZXNzYWdlQ2hhbm5lbCE9XCJ1bmRlZmluZWRcIil7dmFyIG09bmV3IEMuTWVzc2FnZUNoYW5uZWw7bS5wb3J0MS5vbm1lc3NhZ2U9eixTPWZ1bmN0aW9uKCl7bS5wb3J0Mi5wb3N0TWVzc2FnZSgwKX19ZWxzZVwiZG9jdW1lbnRcImluIEMmJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiBDLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/Uz1mdW5jdGlvbigpe3ZhciBGPUMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtGLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe3ooKSxGLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLEYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChGKSxGPW51bGx9LEMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKEYpfTpTPWZ1bmN0aW9uKCl7c2V0VGltZW91dCh6LDApfTt2YXIgdyxOPVtdO2Z1bmN0aW9uIHooKXt3PSEwO2Zvcih2YXIgRixrLFU9Ti5sZW5ndGg7VTspe2ZvcihrPU4sTj1bXSxGPS0xOysrRjxVOylrW0ZdKCk7VT1OLmxlbmd0aH13PSExfU0uZXhwb3J0cz1xO2Z1bmN0aW9uIHEoRil7Ti5wdXNoKEYpPT09MSYmIXcmJlMoKX19KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCE9XCJ1bmRlZmluZWRcIj9nbG9iYWw6dHlwZW9mIHNlbGYhPVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHt9XSwyOltmdW5jdGlvbihMLE0sUSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIEM9TCgxKTtmdW5jdGlvbiBZKCl7fXZhciBTPXt9LFA9W1wiUkVKRUNURURcIl0sSz1bXCJGVUxGSUxMRURcIl0sWj1bXCJQRU5ESU5HXCJdO00uZXhwb3J0cz1tO2Z1bmN0aW9uIG0oaCl7aWYodHlwZW9mIGghPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVzb2x2ZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO3RoaXMuc3RhdGU9Wix0aGlzLnF1ZXVlPVtdLHRoaXMub3V0Y29tZT12b2lkIDAsaCE9PVkmJnEodGhpcyxoKX1tLnByb3RvdHlwZS5jYXRjaD1mdW5jdGlvbihoKXtyZXR1cm4gdGhpcy50aGVuKG51bGwsaCl9LG0ucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oaCxSKXtpZih0eXBlb2YgaCE9XCJmdW5jdGlvblwiJiZ0aGlzLnN0YXRlPT09S3x8dHlwZW9mIFIhPVwiZnVuY3Rpb25cIiYmdGhpcy5zdGF0ZT09PVApcmV0dXJuIHRoaXM7dmFyIEk9bmV3IHRoaXMuY29uc3RydWN0b3IoWSk7aWYodGhpcy5zdGF0ZSE9PVope3ZhciBCPXRoaXMuc3RhdGU9PT1LP2g6UjtOKEksQix0aGlzLm91dGNvbWUpfWVsc2UgdGhpcy5xdWV1ZS5wdXNoKG5ldyB3KEksaCxSKSk7cmV0dXJuIEl9O2Z1bmN0aW9uIHcoaCxSLEkpe3RoaXMucHJvbWlzZT1oLHR5cGVvZiBSPT1cImZ1bmN0aW9uXCImJih0aGlzLm9uRnVsZmlsbGVkPVIsdGhpcy5jYWxsRnVsZmlsbGVkPXRoaXMub3RoZXJDYWxsRnVsZmlsbGVkKSx0eXBlb2YgST09XCJmdW5jdGlvblwiJiYodGhpcy5vblJlamVjdGVkPUksdGhpcy5jYWxsUmVqZWN0ZWQ9dGhpcy5vdGhlckNhbGxSZWplY3RlZCl9dy5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZD1mdW5jdGlvbihoKXtTLnJlc29sdmUodGhpcy5wcm9taXNlLGgpfSx3LnByb3RvdHlwZS5vdGhlckNhbGxGdWxmaWxsZWQ9ZnVuY3Rpb24oaCl7Tih0aGlzLnByb21pc2UsdGhpcy5vbkZ1bGZpbGxlZCxoKX0sdy5wcm90b3R5cGUuY2FsbFJlamVjdGVkPWZ1bmN0aW9uKGgpe1MucmVqZWN0KHRoaXMucHJvbWlzZSxoKX0sdy5wcm90b3R5cGUub3RoZXJDYWxsUmVqZWN0ZWQ9ZnVuY3Rpb24oaCl7Tih0aGlzLnByb21pc2UsdGhpcy5vblJlamVjdGVkLGgpfTtmdW5jdGlvbiBOKGgsUixJKXtDKGZ1bmN0aW9uKCl7dmFyIEI7dHJ5e0I9UihJKX1jYXRjaChIKXtyZXR1cm4gUy5yZWplY3QoaCxIKX1CPT09aD9TLnJlamVjdChoLG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKTpTLnJlc29sdmUoaCxCKX0pfVMucmVzb2x2ZT1mdW5jdGlvbihoLFIpe3ZhciBJPUYoeixSKTtpZihJLnN0YXR1cz09PVwiZXJyb3JcIilyZXR1cm4gUy5yZWplY3QoaCxJLnZhbHVlKTt2YXIgQj1JLnZhbHVlO2lmKEIpcShoLEIpO2Vsc2V7aC5zdGF0ZT1LLGgub3V0Y29tZT1SO2Zvcih2YXIgSD0tMSxqPWgucXVldWUubGVuZ3RoOysrSDxqOyloLnF1ZXVlW0hdLmNhbGxGdWxmaWxsZWQoUil9cmV0dXJuIGh9LFMucmVqZWN0PWZ1bmN0aW9uKGgsUil7aC5zdGF0ZT1QLGgub3V0Y29tZT1SO2Zvcih2YXIgST0tMSxCPWgucXVldWUubGVuZ3RoOysrSTxCOyloLnF1ZXVlW0ldLmNhbGxSZWplY3RlZChSKTtyZXR1cm4gaH07ZnVuY3Rpb24geihoKXt2YXIgUj1oJiZoLnRoZW47aWYoaCYmKHR5cGVvZiBoPT1cIm9iamVjdFwifHx0eXBlb2YgaD09XCJmdW5jdGlvblwiKSYmdHlwZW9mIFI9PVwiZnVuY3Rpb25cIilyZXR1cm4gZnVuY3Rpb24oKXtSLmFwcGx5KGgsYXJndW1lbnRzKX19ZnVuY3Rpb24gcShoLFIpe3ZhciBJPSExO2Z1bmN0aW9uIEIoJCl7SXx8KEk9ITAsUy5yZWplY3QoaCwkKSl9ZnVuY3Rpb24gSCgkKXtJfHwoST0hMCxTLnJlc29sdmUoaCwkKSl9ZnVuY3Rpb24gaigpe1IoSCxCKX12YXIgSj1GKGopO0ouc3RhdHVzPT09XCJlcnJvclwiJiZCKEoudmFsdWUpfWZ1bmN0aW9uIEYoaCxSKXt2YXIgST17fTt0cnl7SS52YWx1ZT1oKFIpLEkuc3RhdHVzPVwic3VjY2Vzc1wifWNhdGNoKEIpe0kuc3RhdHVzPVwiZXJyb3JcIixJLnZhbHVlPUJ9cmV0dXJuIEl9bS5yZXNvbHZlPWs7ZnVuY3Rpb24gayhoKXtyZXR1cm4gaCBpbnN0YW5jZW9mIHRoaXM/aDpTLnJlc29sdmUobmV3IHRoaXMoWSksaCl9bS5yZWplY3Q9VTtmdW5jdGlvbiBVKGgpe3ZhciBSPW5ldyB0aGlzKFkpO3JldHVybiBTLnJlamVjdChSLGgpfW0uYWxsPWFlO2Z1bmN0aW9uIGFlKGgpe3ZhciBSPXRoaXM7aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGgpIT09XCJbb2JqZWN0IEFycmF5XVwiKXJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKFwibXVzdCBiZSBhbiBhcnJheVwiKSk7dmFyIEk9aC5sZW5ndGgsQj0hMTtpZighSSlyZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtmb3IodmFyIEg9bmV3IEFycmF5KEkpLGo9MCxKPS0xLCQ9bmV3IHRoaXMoWSk7KytKPEk7KWVlKGhbSl0sSik7cmV0dXJuICQ7ZnVuY3Rpb24gZWUob2UsYSl7Ui5yZXNvbHZlKG9lKS50aGVuKHMsZnVuY3Rpb24odil7Qnx8KEI9ITAsUy5yZWplY3QoJCx2KSl9KTtmdW5jdGlvbiBzKHYpe0hbYV09diwrK2o9PT1JJiYhQiYmKEI9ITAsUy5yZXNvbHZlKCQsSCkpfX19bS5yYWNlPXJlO2Z1bmN0aW9uIHJlKGgpe3ZhciBSPXRoaXM7aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGgpIT09XCJbb2JqZWN0IEFycmF5XVwiKXJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKFwibXVzdCBiZSBhbiBhcnJheVwiKSk7dmFyIEk9aC5sZW5ndGgsQj0hMTtpZighSSlyZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtmb3IodmFyIEg9LTEsaj1uZXcgdGhpcyhZKTsrK0g8STspSihoW0hdKTtyZXR1cm4gajtmdW5jdGlvbiBKKCQpe1IucmVzb2x2ZSgkKS50aGVuKGZ1bmN0aW9uKGVlKXtCfHwoQj0hMCxTLnJlc29sdmUoaixlZSkpfSxmdW5jdGlvbihlZSl7Qnx8KEI9ITAsUy5yZWplY3QoaixlZSkpfSl9fX0se1wiMVwiOjF9XSwzOltmdW5jdGlvbihMLE0sUSl7KGZ1bmN0aW9uKEMpe1widXNlIHN0cmljdFwiO3R5cGVvZiBDLlByb21pc2UhPVwiZnVuY3Rpb25cIiYmKEMuUHJvbWlzZT1MKDIpKX0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsIT1cInVuZGVmaW5lZFwiP2dsb2JhbDp0eXBlb2Ygc2VsZiE9XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiMlwiOjJ9XSw0OltmdW5jdGlvbihMLE0sUSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIEM9dHlwZW9mIFN5bWJvbD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT1cInN5bWJvbFwiP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJnR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX07ZnVuY3Rpb24gWShlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gUygpe3RyeXtpZih0eXBlb2YgaW5kZXhlZERCIT1cInVuZGVmaW5lZFwiKXJldHVybiBpbmRleGVkREI7aWYodHlwZW9mIHdlYmtpdEluZGV4ZWREQiE9XCJ1bmRlZmluZWRcIilyZXR1cm4gd2Via2l0SW5kZXhlZERCO2lmKHR5cGVvZiBtb3pJbmRleGVkREIhPVwidW5kZWZpbmVkXCIpcmV0dXJuIG1vekluZGV4ZWREQjtpZih0eXBlb2YgT0luZGV4ZWREQiE9XCJ1bmRlZmluZWRcIilyZXR1cm4gT0luZGV4ZWREQjtpZih0eXBlb2YgbXNJbmRleGVkREIhPVwidW5kZWZpbmVkXCIpcmV0dXJuIG1zSW5kZXhlZERCfWNhdGNoe3JldHVybn19dmFyIFA9UygpO2Z1bmN0aW9uIEsoKXt0cnl7aWYoIVB8fCFQLm9wZW4pcmV0dXJuITE7dmFyIGU9dHlwZW9mIG9wZW5EYXRhYmFzZSE9XCJ1bmRlZmluZWRcIiYmLyhTYWZhcml8aVBob25lfGlQYWR8aVBvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJiEvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiYhL0JsYWNrQmVycnkvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSx0PXR5cGVvZiBmZXRjaD09XCJmdW5jdGlvblwiJiZmZXRjaC50b1N0cmluZygpLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVcIikhPT0tMTtyZXR1cm4oIWV8fHQpJiZ0eXBlb2YgaW5kZXhlZERCIT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgSURCS2V5UmFuZ2UhPVwidW5kZWZpbmVkXCJ9Y2F0Y2h7cmV0dXJuITF9fWZ1bmN0aW9uIFooZSx0KXtlPWV8fFtdLHQ9dHx8e307dHJ5e3JldHVybiBuZXcgQmxvYihlLHQpfWNhdGNoKG4pe2lmKG4ubmFtZSE9PVwiVHlwZUVycm9yXCIpdGhyb3cgbjtmb3IodmFyIHI9dHlwZW9mIEJsb2JCdWlsZGVyIT1cInVuZGVmaW5lZFwiP0Jsb2JCdWlsZGVyOnR5cGVvZiBNU0Jsb2JCdWlsZGVyIT1cInVuZGVmaW5lZFwiP01TQmxvYkJ1aWxkZXI6dHlwZW9mIE1vekJsb2JCdWlsZGVyIT1cInVuZGVmaW5lZFwiP01vekJsb2JCdWlsZGVyOldlYktpdEJsb2JCdWlsZGVyLG89bmV3IHIsaT0wO2k8ZS5sZW5ndGg7aSs9MSlvLmFwcGVuZChlW2ldKTtyZXR1cm4gby5nZXRCbG9iKHQudHlwZSl9fXR5cGVvZiBQcm9taXNlPT1cInVuZGVmaW5lZFwiJiZMKDMpO3ZhciBtPVByb21pc2U7ZnVuY3Rpb24gdyhlLHQpe3QmJmUudGhlbihmdW5jdGlvbihyKXt0KG51bGwscil9LGZ1bmN0aW9uKHIpe3Qocil9KX1mdW5jdGlvbiBOKGUsdCxyKXt0eXBlb2YgdD09XCJmdW5jdGlvblwiJiZlLnRoZW4odCksdHlwZW9mIHI9PVwiZnVuY3Rpb25cIiYmZS5jYXRjaChyKX1mdW5jdGlvbiB6KGUpe3JldHVybiB0eXBlb2YgZSE9XCJzdHJpbmdcIiYmKGNvbnNvbGUud2FybihlK1wiIHVzZWQgYXMgYSBrZXksIGJ1dCBpdCBpcyBub3QgYSBzdHJpbmcuXCIpLGU9U3RyaW5nKGUpKSxlfWZ1bmN0aW9uIHEoKXtpZihhcmd1bWVudHMubGVuZ3RoJiZ0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV09PVwiZnVuY3Rpb25cIilyZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV19dmFyIEY9XCJsb2NhbC1mb3JhZ2UtZGV0ZWN0LWJsb2Itc3VwcG9ydFwiLGs9dm9pZCAwLFU9e30sYWU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxyZT1cInJlYWRvbmx5XCIsaD1cInJlYWR3cml0ZVwiO2Z1bmN0aW9uIFIoZSl7Zm9yKHZhciB0PWUubGVuZ3RoLHI9bmV3IEFycmF5QnVmZmVyKHQpLG89bmV3IFVpbnQ4QXJyYXkociksaT0wO2k8dDtpKyspb1tpXT1lLmNoYXJDb2RlQXQoaSk7cmV0dXJuIHJ9ZnVuY3Rpb24gSShlKXtyZXR1cm4gbmV3IG0oZnVuY3Rpb24odCl7dmFyIHI9ZS50cmFuc2FjdGlvbihGLGgpLG89WihbXCJcIl0pO3Iub2JqZWN0U3RvcmUoRikucHV0KG8sXCJrZXlcIiksci5vbmFib3J0PWZ1bmN0aW9uKGkpe2kucHJldmVudERlZmF1bHQoKSxpLnN0b3BQcm9wYWdhdGlvbigpLHQoITEpfSxyLm9uY29tcGxldGU9ZnVuY3Rpb24oKXt2YXIgaT1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKSxuPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8vKTt0KG58fCFpfHxwYXJzZUludChpWzFdLDEwKT49NDMpfX0pLmNhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuITF9KX1mdW5jdGlvbiBCKGUpe3JldHVybiB0eXBlb2Ygaz09XCJib29sZWFuXCI/bS5yZXNvbHZlKGspOkkoZSkudGhlbihmdW5jdGlvbih0KXtyZXR1cm4gaz10LGt9KX1mdW5jdGlvbiBIKGUpe3ZhciB0PVVbZS5uYW1lXSxyPXt9O3IucHJvbWlzZT1uZXcgbShmdW5jdGlvbihvLGkpe3IucmVzb2x2ZT1vLHIucmVqZWN0PWl9KSx0LmRlZmVycmVkT3BlcmF0aW9ucy5wdXNoKHIpLHQuZGJSZWFkeT90LmRiUmVhZHk9dC5kYlJlYWR5LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gci5wcm9taXNlfSk6dC5kYlJlYWR5PXIucHJvbWlzZX1mdW5jdGlvbiBqKGUpe3ZhciB0PVVbZS5uYW1lXSxyPXQuZGVmZXJyZWRPcGVyYXRpb25zLnBvcCgpO2lmKHIpcmV0dXJuIHIucmVzb2x2ZSgpLHIucHJvbWlzZX1mdW5jdGlvbiBKKGUsdCl7dmFyIHI9VVtlLm5hbWVdLG89ci5kZWZlcnJlZE9wZXJhdGlvbnMucG9wKCk7aWYobylyZXR1cm4gby5yZWplY3QodCksby5wcm9taXNlfWZ1bmN0aW9uICQoZSx0KXtyZXR1cm4gbmV3IG0oZnVuY3Rpb24ocixvKXtpZihVW2UubmFtZV09VVtlLm5hbWVdfHxHKCksZS5kYilpZih0KUgoZSksZS5kYi5jbG9zZSgpO2Vsc2UgcmV0dXJuIHIoZS5kYik7dmFyIGk9W2UubmFtZV07dCYmaS5wdXNoKGUudmVyc2lvbik7dmFyIG49UC5vcGVuLmFwcGx5KFAsaSk7dCYmKG4ub251cGdyYWRlbmVlZGVkPWZ1bmN0aW9uKGYpe3ZhciB1PW4ucmVzdWx0O3RyeXt1LmNyZWF0ZU9iamVjdFN0b3JlKGUuc3RvcmVOYW1lKSxmLm9sZFZlcnNpb248PTEmJnUuY3JlYXRlT2JqZWN0U3RvcmUoRil9Y2F0Y2goYyl7aWYoYy5uYW1lPT09XCJDb25zdHJhaW50RXJyb3JcIiljb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicrZS5uYW1lKydcIiBoYXMgYmVlbiB1cGdyYWRlZCBmcm9tIHZlcnNpb24gJytmLm9sZFZlcnNpb24rXCIgdG8gdmVyc2lvbiBcIitmLm5ld1ZlcnNpb24rJywgYnV0IHRoZSBzdG9yYWdlIFwiJytlLnN0b3JlTmFtZSsnXCIgYWxyZWFkeSBleGlzdHMuJyk7ZWxzZSB0aHJvdyBjfX0pLG4ub25lcnJvcj1mdW5jdGlvbihmKXtmLnByZXZlbnREZWZhdWx0KCksbyhuLmVycm9yKX0sbi5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtyKG4ucmVzdWx0KSxqKGUpfX0pfWZ1bmN0aW9uIGVlKGUpe3JldHVybiAkKGUsITEpfWZ1bmN0aW9uIG9lKGUpe3JldHVybiAkKGUsITApfWZ1bmN0aW9uIGEoZSx0KXtpZighZS5kYilyZXR1cm4hMDt2YXIgcj0hZS5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGUuc3RvcmVOYW1lKSxvPWUudmVyc2lvbjxlLmRiLnZlcnNpb24saT1lLnZlcnNpb24+ZS5kYi52ZXJzaW9uO2lmKG8mJihlLnZlcnNpb24hPT10JiZjb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicrZS5uYW1lK2BcIiBjYW4ndCBiZSBkb3duZ3JhZGVkIGZyb20gdmVyc2lvbiBgK2UuZGIudmVyc2lvbitcIiB0byB2ZXJzaW9uIFwiK2UudmVyc2lvbitcIi5cIiksZS52ZXJzaW9uPWUuZGIudmVyc2lvbiksaXx8cil7aWYocil7dmFyIG49ZS5kYi52ZXJzaW9uKzE7bj5lLnZlcnNpb24mJihlLnZlcnNpb249bil9cmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gbmV3IG0oZnVuY3Rpb24odCxyKXt2YXIgbz1uZXcgRmlsZVJlYWRlcjtvLm9uZXJyb3I9cixvLm9ubG9hZGVuZD1mdW5jdGlvbihpKXt2YXIgbj1idG9hKGkudGFyZ2V0LnJlc3VsdHx8XCJcIik7dCh7X19sb2NhbF9mb3JhZ2VfZW5jb2RlZF9ibG9iOiEwLGRhdGE6bix0eXBlOmUudHlwZX0pfSxvLnJlYWRBc0JpbmFyeVN0cmluZyhlKX0pfWZ1bmN0aW9uIHYoZSl7dmFyIHQ9UihhdG9iKGUuZGF0YSkpO3JldHVybiBaKFt0XSx7dHlwZTplLnR5cGV9KX1mdW5jdGlvbiBiKGUpe3JldHVybiBlJiZlLl9fbG9jYWxfZm9yYWdlX2VuY29kZWRfYmxvYn1mdW5jdGlvbiBfKGUpe3ZhciB0PXRoaXMscj10Ll9pbml0UmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIG89VVt0Ll9kYkluZm8ubmFtZV07aWYobyYmby5kYlJlYWR5KXJldHVybiBvLmRiUmVhZHl9KTtyZXR1cm4gTihyLGUsZSkscn1mdW5jdGlvbiBFKGUpe0goZSk7Zm9yKHZhciB0PVVbZS5uYW1lXSxyPXQuZm9yYWdlcyxvPTA7bzxyLmxlbmd0aDtvKyspe3ZhciBpPXJbb107aS5fZGJJbmZvLmRiJiYoaS5fZGJJbmZvLmRiLmNsb3NlKCksaS5fZGJJbmZvLmRiPW51bGwpfXJldHVybiBlLmRiPW51bGwsZWUoZSkudGhlbihmdW5jdGlvbihuKXtyZXR1cm4gZS5kYj1uLGEoZSk/b2UoZSk6bn0pLnRoZW4oZnVuY3Rpb24obil7ZS5kYj10LmRiPW47Zm9yKHZhciBmPTA7ZjxyLmxlbmd0aDtmKyspcltmXS5fZGJJbmZvLmRiPW59KS5jYXRjaChmdW5jdGlvbihuKXt0aHJvdyBKKGUsbiksbn0pfWZ1bmN0aW9uIEQoZSx0LHIsbyl7bz09PXZvaWQgMCYmKG89MSk7dHJ5e3ZhciBpPWUuZGIudHJhbnNhY3Rpb24oZS5zdG9yZU5hbWUsdCk7cihudWxsLGkpfWNhdGNoKG4pe2lmKG8+MCYmKCFlLmRifHxuLm5hbWU9PT1cIkludmFsaWRTdGF0ZUVycm9yXCJ8fG4ubmFtZT09PVwiTm90Rm91bmRFcnJvclwiKSlyZXR1cm4gbS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe2lmKCFlLmRifHxuLm5hbWU9PT1cIk5vdEZvdW5kRXJyb3JcIiYmIWUuZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhlLnN0b3JlTmFtZSkmJmUudmVyc2lvbjw9ZS5kYi52ZXJzaW9uKXJldHVybiBlLmRiJiYoZS52ZXJzaW9uPWUuZGIudmVyc2lvbisxKSxvZShlKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gRShlKS50aGVuKGZ1bmN0aW9uKCl7RChlLHQscixvLTEpfSl9KS5jYXRjaChyKTtyKG4pfX1mdW5jdGlvbiBHKCl7cmV0dXJue2ZvcmFnZXM6W10sZGI6bnVsbCxkYlJlYWR5Om51bGwsZGVmZXJyZWRPcGVyYXRpb25zOltdfX1mdW5jdGlvbiBmZShlKXt2YXIgdD10aGlzLHI9e2RiOm51bGx9O2lmKGUpZm9yKHZhciBvIGluIGUpcltvXT1lW29dO3ZhciBpPVVbci5uYW1lXTtpfHwoaT1HKCksVVtyLm5hbWVdPWkpLGkuZm9yYWdlcy5wdXNoKHQpLHQuX2luaXRSZWFkeXx8KHQuX2luaXRSZWFkeT10LnJlYWR5LHQucmVhZHk9Xyk7dmFyIG49W107ZnVuY3Rpb24gZigpe3JldHVybiBtLnJlc29sdmUoKX1mb3IodmFyIHU9MDt1PGkuZm9yYWdlcy5sZW5ndGg7dSsrKXt2YXIgYz1pLmZvcmFnZXNbdV07YyE9PXQmJm4ucHVzaChjLl9pbml0UmVhZHkoKS5jYXRjaChmKSl9dmFyIGw9aS5mb3JhZ2VzLnNsaWNlKDApO3JldHVybiBtLmFsbChuKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHIuZGI9aS5kYixlZShyKX0pLnRoZW4oZnVuY3Rpb24oZCl7cmV0dXJuIHIuZGI9ZCxhKHIsdC5fZGVmYXVsdENvbmZpZy52ZXJzaW9uKT9vZShyKTpkfSkudGhlbihmdW5jdGlvbihkKXtyLmRiPWkuZGI9ZCx0Ll9kYkluZm89cjtmb3IodmFyIHk9MDt5PGwubGVuZ3RoO3krKyl7dmFyIEE9bFt5XTtBIT09dCYmKEEuX2RiSW5mby5kYj1yLmRiLEEuX2RiSW5mby52ZXJzaW9uPXIudmVyc2lvbil9fSl9ZnVuY3Rpb24gaWUoZSx0KXt2YXIgcj10aGlzO2U9eihlKTt2YXIgbz1uZXcgbShmdW5jdGlvbihpLG4pe3IucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7RChyLl9kYkluZm8scmUsZnVuY3Rpb24oZix1KXtpZihmKXJldHVybiBuKGYpO3RyeXt2YXIgYz11Lm9iamVjdFN0b3JlKHIuX2RiSW5mby5zdG9yZU5hbWUpLGw9Yy5nZXQoZSk7bC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgZD1sLnJlc3VsdDtkPT09dm9pZCAwJiYoZD1udWxsKSxiKGQpJiYoZD12KGQpKSxpKGQpfSxsLm9uZXJyb3I9ZnVuY3Rpb24oKXtuKGwuZXJyb3IpfX1jYXRjaChkKXtuKGQpfX0pfSkuY2F0Y2gobil9KTtyZXR1cm4gdyhvLHQpLG99ZnVuY3Rpb24gY2UoZSx0KXt2YXIgcj10aGlzLG89bmV3IG0oZnVuY3Rpb24oaSxuKXtyLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe0Qoci5fZGJJbmZvLHJlLGZ1bmN0aW9uKGYsdSl7aWYoZilyZXR1cm4gbihmKTt0cnl7dmFyIGM9dS5vYmplY3RTdG9yZShyLl9kYkluZm8uc3RvcmVOYW1lKSxsPWMub3BlbkN1cnNvcigpLGQ9MTtsLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciB5PWwucmVzdWx0O2lmKHkpe3ZhciBBPXkudmFsdWU7YihBKSYmKEE9dihBKSk7dmFyIFQ9ZShBLHkua2V5LGQrKyk7VCE9PXZvaWQgMD9pKFQpOnkuY29udGludWUoKX1lbHNlIGkoKX0sbC5vbmVycm9yPWZ1bmN0aW9uKCl7bihsLmVycm9yKX19Y2F0Y2goeSl7bih5KX19KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIG5yKGUsdCxyKXt2YXIgbz10aGlzO2U9eihlKTt2YXIgaT1uZXcgbShmdW5jdGlvbihuLGYpe3ZhciB1O28ucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHU9by5fZGJJbmZvLGFlLmNhbGwodCk9PT1cIltvYmplY3QgQmxvYl1cIj9CKHUuZGIpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGM/dDpzKHQpfSk6dH0pLnRoZW4oZnVuY3Rpb24oYyl7RChvLl9kYkluZm8saCxmdW5jdGlvbihsLGQpe2lmKGwpcmV0dXJuIGYobCk7dHJ5e3ZhciB5PWQub2JqZWN0U3RvcmUoby5fZGJJbmZvLnN0b3JlTmFtZSk7Yz09PW51bGwmJihjPXZvaWQgMCk7dmFyIEE9eS5wdXQoYyxlKTtkLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtjPT09dm9pZCAwJiYoYz1udWxsKSxuKGMpfSxkLm9uYWJvcnQ9ZC5vbmVycm9yPWZ1bmN0aW9uKCl7dmFyIFQ9QS5lcnJvcj9BLmVycm9yOkEudHJhbnNhY3Rpb24uZXJyb3I7ZihUKX19Y2F0Y2goVCl7ZihUKX19KX0pLmNhdGNoKGYpfSk7cmV0dXJuIHcoaSxyKSxpfWZ1bmN0aW9uIG9yKGUsdCl7dmFyIHI9dGhpcztlPXooZSk7dmFyIG89bmV3IG0oZnVuY3Rpb24oaSxuKXtyLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe0Qoci5fZGJJbmZvLGgsZnVuY3Rpb24oZix1KXtpZihmKXJldHVybiBuKGYpO3RyeXt2YXIgYz11Lm9iamVjdFN0b3JlKHIuX2RiSW5mby5zdG9yZU5hbWUpLGw9Yy5kZWxldGUoZSk7dS5vbmNvbXBsZXRlPWZ1bmN0aW9uKCl7aSgpfSx1Lm9uZXJyb3I9ZnVuY3Rpb24oKXtuKGwuZXJyb3IpfSx1Lm9uYWJvcnQ9ZnVuY3Rpb24oKXt2YXIgZD1sLmVycm9yP2wuZXJyb3I6bC50cmFuc2FjdGlvbi5lcnJvcjtuKGQpfX1jYXRjaChkKXtuKGQpfX0pfSkuY2F0Y2gobil9KTtyZXR1cm4gdyhvLHQpLG99ZnVuY3Rpb24gaXIoZSl7dmFyIHQ9dGhpcyxyPW5ldyBtKGZ1bmN0aW9uKG8saSl7dC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtEKHQuX2RiSW5mbyxoLGZ1bmN0aW9uKG4sZil7aWYobilyZXR1cm4gaShuKTt0cnl7dmFyIHU9Zi5vYmplY3RTdG9yZSh0Ll9kYkluZm8uc3RvcmVOYW1lKSxjPXUuY2xlYXIoKTtmLm9uY29tcGxldGU9ZnVuY3Rpb24oKXtvKCl9LGYub25hYm9ydD1mLm9uZXJyb3I9ZnVuY3Rpb24oKXt2YXIgbD1jLmVycm9yP2MuZXJyb3I6Yy50cmFuc2FjdGlvbi5lcnJvcjtpKGwpfX1jYXRjaChsKXtpKGwpfX0pfSkuY2F0Y2goaSl9KTtyZXR1cm4gdyhyLGUpLHJ9ZnVuY3Rpb24gYXIoZSl7dmFyIHQ9dGhpcyxyPW5ldyBtKGZ1bmN0aW9uKG8saSl7dC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXtEKHQuX2RiSW5mbyxyZSxmdW5jdGlvbihuLGYpe2lmKG4pcmV0dXJuIGkobik7dHJ5e3ZhciB1PWYub2JqZWN0U3RvcmUodC5fZGJJbmZvLnN0b3JlTmFtZSksYz11LmNvdW50KCk7Yy5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXtvKGMucmVzdWx0KX0sYy5vbmVycm9yPWZ1bmN0aW9uKCl7aShjLmVycm9yKX19Y2F0Y2gobCl7aShsKX19KX0pLmNhdGNoKGkpfSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIGZyKGUsdCl7dmFyIHI9dGhpcyxvPW5ldyBtKGZ1bmN0aW9uKGksbil7aWYoZTwwKXtpKG51bGwpO3JldHVybn1yLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe0Qoci5fZGJJbmZvLHJlLGZ1bmN0aW9uKGYsdSl7aWYoZilyZXR1cm4gbihmKTt0cnl7dmFyIGM9dS5vYmplY3RTdG9yZShyLl9kYkluZm8uc3RvcmVOYW1lKSxsPSExLGQ9Yy5vcGVuS2V5Q3Vyc29yKCk7ZC5vbnN1Y2Nlc3M9ZnVuY3Rpb24oKXt2YXIgeT1kLnJlc3VsdDtpZigheSl7aShudWxsKTtyZXR1cm59ZT09PTB8fGw/aSh5LmtleSk6KGw9ITAseS5hZHZhbmNlKGUpKX0sZC5vbmVycm9yPWZ1bmN0aW9uKCl7bihkLmVycm9yKX19Y2F0Y2goeSl7bih5KX19KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIHVyKGUpe3ZhciB0PXRoaXMscj1uZXcgbShmdW5jdGlvbihvLGkpe3QucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7RCh0Ll9kYkluZm8scmUsZnVuY3Rpb24obixmKXtpZihuKXJldHVybiBpKG4pO3RyeXt2YXIgdT1mLm9iamVjdFN0b3JlKHQuX2RiSW5mby5zdG9yZU5hbWUpLGM9dS5vcGVuS2V5Q3Vyc29yKCksbD1bXTtjLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBkPWMucmVzdWx0O2lmKCFkKXtvKGwpO3JldHVybn1sLnB1c2goZC5rZXkpLGQuY29udGludWUoKX0sYy5vbmVycm9yPWZ1bmN0aW9uKCl7aShjLmVycm9yKX19Y2F0Y2goZCl7aShkKX19KX0pLmNhdGNoKGkpfSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIHNyKGUsdCl7dD1xLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgcj10aGlzLmNvbmZpZygpO2U9dHlwZW9mIGUhPVwiZnVuY3Rpb25cIiYmZXx8e30sZS5uYW1lfHwoZS5uYW1lPWUubmFtZXx8ci5uYW1lLGUuc3RvcmVOYW1lPWUuc3RvcmVOYW1lfHxyLnN0b3JlTmFtZSk7dmFyIG89dGhpcyxpO2lmKCFlLm5hbWUpaT1tLnJlamVjdChcIkludmFsaWQgYXJndW1lbnRzXCIpO2Vsc2V7dmFyIG49ZS5uYW1lPT09ci5uYW1lJiZvLl9kYkluZm8uZGIsZj1uP20ucmVzb2x2ZShvLl9kYkluZm8uZGIpOmVlKGUpLnRoZW4oZnVuY3Rpb24odSl7dmFyIGM9VVtlLm5hbWVdLGw9Yy5mb3JhZ2VzO2MuZGI9dTtmb3IodmFyIGQ9MDtkPGwubGVuZ3RoO2QrKylsW2RdLl9kYkluZm8uZGI9dTtyZXR1cm4gdX0pO2Uuc3RvcmVOYW1lP2k9Zi50aGVuKGZ1bmN0aW9uKHUpe2lmKCEhdS5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGUuc3RvcmVOYW1lKSl7dmFyIGM9dS52ZXJzaW9uKzE7SChlKTt2YXIgbD1VW2UubmFtZV0sZD1sLmZvcmFnZXM7dS5jbG9zZSgpO2Zvcih2YXIgeT0wO3k8ZC5sZW5ndGg7eSsrKXt2YXIgQT1kW3ldO0EuX2RiSW5mby5kYj1udWxsLEEuX2RiSW5mby52ZXJzaW9uPWN9dmFyIFQ9bmV3IG0oZnVuY3Rpb24oeCxWKXt2YXIgVz1QLm9wZW4oZS5uYW1lLGMpO1cub25lcnJvcj1mdW5jdGlvbihYKXt2YXIgZGU9Vy5yZXN1bHQ7ZGUuY2xvc2UoKSxWKFgpfSxXLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbigpe3ZhciBYPVcucmVzdWx0O1guZGVsZXRlT2JqZWN0U3RvcmUoZS5zdG9yZU5hbWUpfSxXLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBYPVcucmVzdWx0O1guY2xvc2UoKSx4KFgpfX0pO3JldHVybiBULnRoZW4oZnVuY3Rpb24oeCl7bC5kYj14O2Zvcih2YXIgVj0wO1Y8ZC5sZW5ndGg7VisrKXt2YXIgVz1kW1ZdO1cuX2RiSW5mby5kYj14LGooVy5fZGJJbmZvKX19KS5jYXRjaChmdW5jdGlvbih4KXt0aHJvdyhKKGUseCl8fG0ucmVzb2x2ZSgpKS5jYXRjaChmdW5jdGlvbigpe30pLHh9KX19KTppPWYudGhlbihmdW5jdGlvbih1KXtIKGUpO3ZhciBjPVVbZS5uYW1lXSxsPWMuZm9yYWdlczt1LmNsb3NlKCk7Zm9yKHZhciBkPTA7ZDxsLmxlbmd0aDtkKyspe3ZhciB5PWxbZF07eS5fZGJJbmZvLmRiPW51bGx9dmFyIEE9bmV3IG0oZnVuY3Rpb24oVCx4KXt2YXIgVj1QLmRlbGV0ZURhdGFiYXNlKGUubmFtZSk7Vi5vbmVycm9yPVYub25ibG9ja2VkPWZ1bmN0aW9uKFcpe3ZhciBYPVYucmVzdWx0O1gmJlguY2xvc2UoKSx4KFcpfSxWLm9uc3VjY2Vzcz1mdW5jdGlvbigpe3ZhciBXPVYucmVzdWx0O1cmJlcuY2xvc2UoKSxUKFcpfX0pO3JldHVybiBBLnRoZW4oZnVuY3Rpb24oVCl7Yy5kYj1UO2Zvcih2YXIgeD0wO3g8bC5sZW5ndGg7eCsrKXt2YXIgVj1sW3hdO2ooVi5fZGJJbmZvKX19KS5jYXRjaChmdW5jdGlvbihUKXt0aHJvdyhKKGUsVCl8fG0ucmVzb2x2ZSgpKS5jYXRjaChmdW5jdGlvbigpe30pLFR9KX0pfXJldHVybiB3KGksdCksaX12YXIgY3I9e19kcml2ZXI6XCJhc3luY1N0b3JhZ2VcIixfaW5pdFN0b3JhZ2U6ZmUsX3N1cHBvcnQ6SygpLGl0ZXJhdGU6Y2UsZ2V0SXRlbTppZSxzZXRJdGVtOm5yLHJlbW92ZUl0ZW06b3IsY2xlYXI6aXIsbGVuZ3RoOmFyLGtleTpmcixrZXlzOnVyLGRyb3BJbnN0YW5jZTpzcn07ZnVuY3Rpb24gbHIoKXtyZXR1cm4gdHlwZW9mIG9wZW5EYXRhYmFzZT09XCJmdW5jdGlvblwifXZhciB0ZT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixkcj1cIn5+bG9jYWxfZm9yYWdlX3R5cGV+XCIseGU9L15+fmxvY2FsX2ZvcmFnZV90eXBlfihbXn5dKyl+LyxoZT1cIl9fbGZzY19fOlwiLGdlPWhlLmxlbmd0aCxiZT1cImFyYmZcIixfZT1cImJsb2JcIixPZT1cInNpMDhcIixDZT1cInVpMDhcIixMZT1cInVpYzhcIixQZT1cInNpMTZcIixNZT1cInNpMzJcIixGZT1cInVyMTZcIixVZT1cInVpMzJcIixZZT1cImZsMzJcIix6ZT1cImZsNjRcIixXZT1nZStiZS5sZW5ndGgsS2U9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBIZShlKXt2YXIgdD1lLmxlbmd0aCouNzUscj1lLmxlbmd0aCxvLGk9MCxuLGYsdSxjO2VbZS5sZW5ndGgtMV09PT1cIj1cIiYmKHQtLSxlW2UubGVuZ3RoLTJdPT09XCI9XCImJnQtLSk7dmFyIGw9bmV3IEFycmF5QnVmZmVyKHQpLGQ9bmV3IFVpbnQ4QXJyYXkobCk7Zm9yKG89MDtvPHI7bys9NCluPXRlLmluZGV4T2YoZVtvXSksZj10ZS5pbmRleE9mKGVbbysxXSksdT10ZS5pbmRleE9mKGVbbysyXSksYz10ZS5pbmRleE9mKGVbbyszXSksZFtpKytdPW48PDJ8Zj4+NCxkW2krK109KGYmMTUpPDw0fHU+PjIsZFtpKytdPSh1JjMpPDw2fGMmNjM7cmV0dXJuIGx9ZnVuY3Rpb24gd2UoZSl7dmFyIHQ9bmV3IFVpbnQ4QXJyYXkoZSkscj1cIlwiLG87Zm9yKG89MDtvPHQubGVuZ3RoO28rPTMpcis9dGVbdFtvXT4+Ml0scis9dGVbKHRbb10mMyk8PDR8dFtvKzFdPj40XSxyKz10ZVsodFtvKzFdJjE1KTw8Mnx0W28rMl0+PjZdLHIrPXRlW3RbbysyXSY2M107cmV0dXJuIHQubGVuZ3RoJTM9PT0yP3I9ci5zdWJzdHJpbmcoMCxyLmxlbmd0aC0xKStcIj1cIjp0Lmxlbmd0aCUzPT09MSYmKHI9ci5zdWJzdHJpbmcoMCxyLmxlbmd0aC0yKStcIj09XCIpLHJ9ZnVuY3Rpb24gdnIoZSx0KXt2YXIgcj1cIlwiO2lmKGUmJihyPUtlLmNhbGwoZSkpLGUmJihyPT09XCJbb2JqZWN0IEFycmF5QnVmZmVyXVwifHxlLmJ1ZmZlciYmS2UuY2FsbChlLmJ1ZmZlcik9PT1cIltvYmplY3QgQXJyYXlCdWZmZXJdXCIpKXt2YXIgbyxpPWhlO2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj8obz1lLGkrPWJlKToobz1lLmJ1ZmZlcixyPT09XCJbb2JqZWN0IEludDhBcnJheV1cIj9pKz1PZTpyPT09XCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI/aSs9Q2U6cj09PVwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIj9pKz1MZTpyPT09XCJbb2JqZWN0IEludDE2QXJyYXldXCI/aSs9UGU6cj09PVwiW29iamVjdCBVaW50MTZBcnJheV1cIj9pKz1GZTpyPT09XCJbb2JqZWN0IEludDMyQXJyYXldXCI/aSs9TWU6cj09PVwiW29iamVjdCBVaW50MzJBcnJheV1cIj9pKz1VZTpyPT09XCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIj9pKz1ZZTpyPT09XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIj9pKz16ZTp0KG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgdHlwZSBmb3IgQmluYXJ5QXJyYXlcIikpKSx0KGkrd2UobykpfWVsc2UgaWYocj09PVwiW29iamVjdCBCbG9iXVwiKXt2YXIgbj1uZXcgRmlsZVJlYWRlcjtuLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBmPWRyK2UudHlwZStcIn5cIit3ZSh0aGlzLnJlc3VsdCk7dChoZStfZStmKX0sbi5yZWFkQXNBcnJheUJ1ZmZlcihlKX1lbHNlIHRyeXt0KEpTT04uc3RyaW5naWZ5KGUpKX1jYXRjaChmKXtjb25zb2xlLmVycm9yKFwiQ291bGRuJ3QgY29udmVydCB2YWx1ZSBpbnRvIGEgSlNPTiBzdHJpbmc6IFwiLGUpLHQobnVsbCxmKX19ZnVuY3Rpb24gaHIoZSl7aWYoZS5zdWJzdHJpbmcoMCxnZSkhPT1oZSlyZXR1cm4gSlNPTi5wYXJzZShlKTt2YXIgdD1lLnN1YnN0cmluZyhXZSkscj1lLnN1YnN0cmluZyhnZSxXZSksbztpZihyPT09X2UmJnhlLnRlc3QodCkpe3ZhciBpPXQubWF0Y2goeGUpO289aVsxXSx0PXQuc3Vic3RyaW5nKGlbMF0ubGVuZ3RoKX12YXIgbj1IZSh0KTtzd2l0Y2gocil7Y2FzZSBiZTpyZXR1cm4gbjtjYXNlIF9lOnJldHVybiBaKFtuXSx7dHlwZTpvfSk7Y2FzZSBPZTpyZXR1cm4gbmV3IEludDhBcnJheShuKTtjYXNlIENlOnJldHVybiBuZXcgVWludDhBcnJheShuKTtjYXNlIExlOnJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkobik7Y2FzZSBQZTpyZXR1cm4gbmV3IEludDE2QXJyYXkobik7Y2FzZSBGZTpyZXR1cm4gbmV3IFVpbnQxNkFycmF5KG4pO2Nhc2UgTWU6cmV0dXJuIG5ldyBJbnQzMkFycmF5KG4pO2Nhc2UgVWU6cmV0dXJuIG5ldyBVaW50MzJBcnJheShuKTtjYXNlIFllOnJldHVybiBuZXcgRmxvYXQzMkFycmF5KG4pO2Nhc2UgemU6cmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtvd24gdHlwZTogXCIrcil9fXZhciBFZT17c2VyaWFsaXplOnZyLGRlc2VyaWFsaXplOmhyLHN0cmluZ1RvQnVmZmVyOkhlLGJ1ZmZlclRvU3RyaW5nOndlfTtmdW5jdGlvbiBWZShlLHQscixvKXtlLmV4ZWN1dGVTcWwoXCJDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyBcIit0LnN0b3JlTmFtZStcIiAoaWQgSU5URUdFUiBQUklNQVJZIEtFWSwga2V5IHVuaXF1ZSwgdmFsdWUpXCIsW10scixvKX1mdW5jdGlvbiBtcihlKXt2YXIgdD10aGlzLHI9e2RiOm51bGx9O2lmKGUpZm9yKHZhciBvIGluIGUpcltvXT10eXBlb2YgZVtvXSE9XCJzdHJpbmdcIj9lW29dLnRvU3RyaW5nKCk6ZVtvXTt2YXIgaT1uZXcgbShmdW5jdGlvbihuLGYpe3RyeXtyLmRiPW9wZW5EYXRhYmFzZShyLm5hbWUsU3RyaW5nKHIudmVyc2lvbiksci5kZXNjcmlwdGlvbixyLnNpemUpfWNhdGNoKHUpe3JldHVybiBmKHUpfXIuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24odSl7VmUodSxyLGZ1bmN0aW9uKCl7dC5fZGJJbmZvPXIsbigpfSxmdW5jdGlvbihjLGwpe2YobCl9KX0sZil9KTtyZXR1cm4gci5zZXJpYWxpemVyPUVlLGl9ZnVuY3Rpb24gbmUoZSx0LHIsbyxpLG4pe2UuZXhlY3V0ZVNxbChyLG8saSxmdW5jdGlvbihmLHUpe3UuY29kZT09PXUuU1lOVEFYX0VSUj9mLmV4ZWN1dGVTcWwoXCJTRUxFQ1QgbmFtZSBGUk9NIHNxbGl0ZV9tYXN0ZXIgV0hFUkUgdHlwZT0ndGFibGUnIEFORCBuYW1lID0gP1wiLFt0LnN0b3JlTmFtZV0sZnVuY3Rpb24oYyxsKXtsLnJvd3MubGVuZ3RoP24oYyx1KTpWZShjLHQsZnVuY3Rpb24oKXtjLmV4ZWN1dGVTcWwocixvLGksbil9LG4pfSxuKTpuKGYsdSl9LG4pfWZ1bmN0aW9uIHlyKGUsdCl7dmFyIHI9dGhpcztlPXooZSk7dmFyIG89bmV3IG0oZnVuY3Rpb24oaSxuKXtyLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBmPXIuX2RiSW5mbztmLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKHUpe25lKHUsZixcIlNFTEVDVCAqIEZST00gXCIrZi5zdG9yZU5hbWUrXCIgV0hFUkUga2V5ID0gPyBMSU1JVCAxXCIsW2VdLGZ1bmN0aW9uKGMsbCl7dmFyIGQ9bC5yb3dzLmxlbmd0aD9sLnJvd3MuaXRlbSgwKS52YWx1ZTpudWxsO2QmJihkPWYuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShkKSksaShkKX0sZnVuY3Rpb24oYyxsKXtuKGwpfSl9KX0pLmNhdGNoKG4pfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIHByKGUsdCl7dmFyIHI9dGhpcyxvPW5ldyBtKGZ1bmN0aW9uKGksbil7ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZj1yLl9kYkluZm87Zi5kYi50cmFuc2FjdGlvbihmdW5jdGlvbih1KXtuZSh1LGYsXCJTRUxFQ1QgKiBGUk9NIFwiK2Yuc3RvcmVOYW1lLFtdLGZ1bmN0aW9uKGMsbCl7Zm9yKHZhciBkPWwucm93cyx5PWQubGVuZ3RoLEE9MDtBPHk7QSsrKXt2YXIgVD1kLml0ZW0oQSkseD1ULnZhbHVlO2lmKHgmJih4PWYuc2VyaWFsaXplci5kZXNlcmlhbGl6ZSh4KSkseD1lKHgsVC5rZXksQSsxKSx4IT09dm9pZCAwKXtpKHgpO3JldHVybn19aSgpfSxmdW5jdGlvbihjLGwpe24obCl9KX0pfSkuY2F0Y2gobil9KTtyZXR1cm4gdyhvLHQpLG99ZnVuY3Rpb24gR2UoZSx0LHIsbyl7dmFyIGk9dGhpcztlPXooZSk7dmFyIG49bmV3IG0oZnVuY3Rpb24oZix1KXtpLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3Q9PT12b2lkIDAmJih0PW51bGwpO3ZhciBjPXQsbD1pLl9kYkluZm87bC5zZXJpYWxpemVyLnNlcmlhbGl6ZSh0LGZ1bmN0aW9uKGQseSl7eT91KHkpOmwuZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24oQSl7bmUoQSxsLFwiSU5TRVJUIE9SIFJFUExBQ0UgSU5UTyBcIitsLnN0b3JlTmFtZStcIiAoa2V5LCB2YWx1ZSkgVkFMVUVTICg/LCA/KVwiLFtlLGRdLGZ1bmN0aW9uKCl7ZihjKX0sZnVuY3Rpb24oVCx4KXt1KHgpfSl9LGZ1bmN0aW9uKEEpe2lmKEEuY29kZT09PUEuUVVPVEFfRVJSKXtpZihvPjApe2YoR2UuYXBwbHkoaSxbZSxjLHIsby0xXSkpO3JldHVybn11KEEpfX0pfSl9KS5jYXRjaCh1KX0pO3JldHVybiB3KG4sciksbn1mdW5jdGlvbiBncihlLHQscil7cmV0dXJuIEdlLmFwcGx5KHRoaXMsW2UsdCxyLDFdKX1mdW5jdGlvbiBicihlLHQpe3ZhciByPXRoaXM7ZT16KGUpO3ZhciBvPW5ldyBtKGZ1bmN0aW9uKGksbil7ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZj1yLl9kYkluZm87Zi5kYi50cmFuc2FjdGlvbihmdW5jdGlvbih1KXtuZSh1LGYsXCJERUxFVEUgRlJPTSBcIitmLnN0b3JlTmFtZStcIiBXSEVSRSBrZXkgPSA/XCIsW2VdLGZ1bmN0aW9uKCl7aSgpfSxmdW5jdGlvbihjLGwpe24obCl9KX0pfSkuY2F0Y2gobil9KTtyZXR1cm4gdyhvLHQpLG99ZnVuY3Rpb24gX3IoZSl7dmFyIHQ9dGhpcyxyPW5ldyBtKGZ1bmN0aW9uKG8saSl7dC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgbj10Ll9kYkluZm87bi5kYi50cmFuc2FjdGlvbihmdW5jdGlvbihmKXtuZShmLG4sXCJERUxFVEUgRlJPTSBcIituLnN0b3JlTmFtZSxbXSxmdW5jdGlvbigpe28oKX0sZnVuY3Rpb24odSxjKXtpKGMpfSl9KX0pLmNhdGNoKGkpfSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIHdyKGUpe3ZhciB0PXRoaXMscj1uZXcgbShmdW5jdGlvbihvLGkpe3QucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIG49dC5fZGJJbmZvO24uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24oZil7bmUoZixuLFwiU0VMRUNUIENPVU5UKGtleSkgYXMgYyBGUk9NIFwiK24uc3RvcmVOYW1lLFtdLGZ1bmN0aW9uKHUsYyl7dmFyIGw9Yy5yb3dzLml0ZW0oMCkuYztvKGwpfSxmdW5jdGlvbih1LGMpe2koYyl9KX0pfSkuY2F0Y2goaSl9KTtyZXR1cm4gdyhyLGUpLHJ9ZnVuY3Rpb24gRXIoZSx0KXt2YXIgcj10aGlzLG89bmV3IG0oZnVuY3Rpb24oaSxuKXtyLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBmPXIuX2RiSW5mbztmLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKHUpe25lKHUsZixcIlNFTEVDVCBrZXkgRlJPTSBcIitmLnN0b3JlTmFtZStcIiBXSEVSRSBpZCA9ID8gTElNSVQgMVwiLFtlKzFdLGZ1bmN0aW9uKGMsbCl7dmFyIGQ9bC5yb3dzLmxlbmd0aD9sLnJvd3MuaXRlbSgwKS5rZXk6bnVsbDtpKGQpfSxmdW5jdGlvbihjLGwpe24obCl9KX0pfSkuY2F0Y2gobil9KTtyZXR1cm4gdyhvLHQpLG99ZnVuY3Rpb24gSXIoZSl7dmFyIHQ9dGhpcyxyPW5ldyBtKGZ1bmN0aW9uKG8saSl7dC5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgbj10Ll9kYkluZm87bi5kYi50cmFuc2FjdGlvbihmdW5jdGlvbihmKXtuZShmLG4sXCJTRUxFQ1Qga2V5IEZST00gXCIrbi5zdG9yZU5hbWUsW10sZnVuY3Rpb24odSxjKXtmb3IodmFyIGw9W10sZD0wO2Q8Yy5yb3dzLmxlbmd0aDtkKyspbC5wdXNoKGMucm93cy5pdGVtKGQpLmtleSk7byhsKX0sZnVuY3Rpb24odSxjKXtpKGMpfSl9KX0pLmNhdGNoKGkpfSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIFNyKGUpe3JldHVybiBuZXcgbShmdW5jdGlvbih0LHIpe2UudHJhbnNhY3Rpb24oZnVuY3Rpb24obyl7by5leGVjdXRlU3FsKFwiU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyIFdIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZSA8PiAnX19XZWJLaXREYXRhYmFzZUluZm9UYWJsZV9fJ1wiLFtdLGZ1bmN0aW9uKGksbil7Zm9yKHZhciBmPVtdLHU9MDt1PG4ucm93cy5sZW5ndGg7dSsrKWYucHVzaChuLnJvd3MuaXRlbSh1KS5uYW1lKTt0KHtkYjplLHN0b3JlTmFtZXM6Zn0pfSxmdW5jdGlvbihpLG4pe3Iobil9KX0sZnVuY3Rpb24obyl7cihvKX0pfSl9ZnVuY3Rpb24gQXIoZSx0KXt0PXEuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciByPXRoaXMuY29uZmlnKCk7ZT10eXBlb2YgZSE9XCJmdW5jdGlvblwiJiZlfHx7fSxlLm5hbWV8fChlLm5hbWU9ZS5uYW1lfHxyLm5hbWUsZS5zdG9yZU5hbWU9ZS5zdG9yZU5hbWV8fHIuc3RvcmVOYW1lKTt2YXIgbz10aGlzLGk7cmV0dXJuIGUubmFtZT9pPW5ldyBtKGZ1bmN0aW9uKG4pe3ZhciBmO2UubmFtZT09PXIubmFtZT9mPW8uX2RiSW5mby5kYjpmPW9wZW5EYXRhYmFzZShlLm5hbWUsXCJcIixcIlwiLDApLGUuc3RvcmVOYW1lP24oe2RiOmYsc3RvcmVOYW1lczpbZS5zdG9yZU5hbWVdfSk6bihTcihmKSl9KS50aGVuKGZ1bmN0aW9uKG4pe3JldHVybiBuZXcgbShmdW5jdGlvbihmLHUpe24uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24oYyl7ZnVuY3Rpb24gbChUKXtyZXR1cm4gbmV3IG0oZnVuY3Rpb24oeCxWKXtjLmV4ZWN1dGVTcWwoXCJEUk9QIFRBQkxFIElGIEVYSVNUUyBcIitULFtdLGZ1bmN0aW9uKCl7eCgpfSxmdW5jdGlvbihXLFgpe1YoWCl9KX0pfWZvcih2YXIgZD1bXSx5PTAsQT1uLnN0b3JlTmFtZXMubGVuZ3RoO3k8QTt5KyspZC5wdXNoKGwobi5zdG9yZU5hbWVzW3ldKSk7bS5hbGwoZCkudGhlbihmdW5jdGlvbigpe2YoKX0pLmNhdGNoKGZ1bmN0aW9uKFQpe3UoVCl9KX0sZnVuY3Rpb24oYyl7dShjKX0pfSl9KTppPW0ucmVqZWN0KFwiSW52YWxpZCBhcmd1bWVudHNcIiksdyhpLHQpLGl9dmFyIFJyPXtfZHJpdmVyOlwid2ViU1FMU3RvcmFnZVwiLF9pbml0U3RvcmFnZTptcixfc3VwcG9ydDpscigpLGl0ZXJhdGU6cHIsZ2V0SXRlbTp5cixzZXRJdGVtOmdyLHJlbW92ZUl0ZW06YnIsY2xlYXI6X3IsbGVuZ3RoOndyLGtleTpFcixrZXlzOklyLGRyb3BJbnN0YW5jZTpBcn07ZnVuY3Rpb24gRHIoKXt0cnl7cmV0dXJuIHR5cGVvZiBsb2NhbFN0b3JhZ2UhPVwidW5kZWZpbmVkXCImJlwic2V0SXRlbVwiaW4gbG9jYWxTdG9yYWdlJiYhIWxvY2FsU3RvcmFnZS5zZXRJdGVtfWNhdGNoe3JldHVybiExfX1mdW5jdGlvbiBqZShlLHQpe3ZhciByPWUubmFtZStcIi9cIjtyZXR1cm4gZS5zdG9yZU5hbWUhPT10LnN0b3JlTmFtZSYmKHIrPWUuc3RvcmVOYW1lK1wiL1wiKSxyfWZ1bmN0aW9uIE5yKCl7dmFyIGU9XCJfbG9jYWxmb3JhZ2Vfc3VwcG9ydF90ZXN0XCI7dHJ5e3JldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLCEwKSxsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShlKSwhMX1jYXRjaHtyZXR1cm4hMH19ZnVuY3Rpb24gVHIoKXtyZXR1cm4hTnIoKXx8bG9jYWxTdG9yYWdlLmxlbmd0aD4wfWZ1bmN0aW9uIEJyKGUpe3ZhciB0PXRoaXMscj17fTtpZihlKWZvcih2YXIgbyBpbiBlKXJbb109ZVtvXTtyZXR1cm4gci5rZXlQcmVmaXg9amUoZSx0Ll9kZWZhdWx0Q29uZmlnKSxUcigpPyh0Ll9kYkluZm89cixyLnNlcmlhbGl6ZXI9RWUsbS5yZXNvbHZlKCkpOm0ucmVqZWN0KCl9ZnVuY3Rpb24geHIoZSl7dmFyIHQ9dGhpcyxyPXQucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBvPXQuX2RiSW5mby5rZXlQcmVmaXgsaT1sb2NhbFN0b3JhZ2UubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBuPWxvY2FsU3RvcmFnZS5rZXkoaSk7bi5pbmRleE9mKG8pPT09MCYmbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obil9fSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIE9yKGUsdCl7dmFyIHI9dGhpcztlPXooZSk7dmFyIG89ci5yZWFkeSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgaT1yLl9kYkluZm8sbj1sb2NhbFN0b3JhZ2UuZ2V0SXRlbShpLmtleVByZWZpeCtlKTtyZXR1cm4gbiYmKG49aS5zZXJpYWxpemVyLmRlc2VyaWFsaXplKG4pKSxufSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIENyKGUsdCl7dmFyIHI9dGhpcyxvPXIucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBpPXIuX2RiSW5mbyxuPWkua2V5UHJlZml4LGY9bi5sZW5ndGgsdT1sb2NhbFN0b3JhZ2UubGVuZ3RoLGM9MSxsPTA7bDx1O2wrKyl7dmFyIGQ9bG9jYWxTdG9yYWdlLmtleShsKTtpZihkLmluZGV4T2Yobik9PT0wKXt2YXIgeT1sb2NhbFN0b3JhZ2UuZ2V0SXRlbShkKTtpZih5JiYoeT1pLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoeSkpLHk9ZSh5LGQuc3Vic3RyaW5nKGYpLGMrKykseSE9PXZvaWQgMClyZXR1cm4geX19fSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIExyKGUsdCl7dmFyIHI9dGhpcyxvPXIucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGk9ci5fZGJJbmZvLG47dHJ5e249bG9jYWxTdG9yYWdlLmtleShlKX1jYXRjaHtuPW51bGx9cmV0dXJuIG4mJihuPW4uc3Vic3RyaW5nKGkua2V5UHJlZml4Lmxlbmd0aCkpLG59KTtyZXR1cm4gdyhvLHQpLG99ZnVuY3Rpb24gUHIoZSl7dmFyIHQ9dGhpcyxyPXQucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBvPXQuX2RiSW5mbyxpPWxvY2FsU3RvcmFnZS5sZW5ndGgsbj1bXSxmPTA7ZjxpO2YrKyl7dmFyIHU9bG9jYWxTdG9yYWdlLmtleShmKTt1LmluZGV4T2Yoby5rZXlQcmVmaXgpPT09MCYmbi5wdXNoKHUuc3Vic3RyaW5nKG8ua2V5UHJlZml4Lmxlbmd0aCkpfXJldHVybiBufSk7cmV0dXJuIHcocixlKSxyfWZ1bmN0aW9uIE1yKGUpe3ZhciB0PXRoaXMscj10LmtleXMoKS50aGVuKGZ1bmN0aW9uKG8pe3JldHVybiBvLmxlbmd0aH0pO3JldHVybiB3KHIsZSkscn1mdW5jdGlvbiBGcihlLHQpe3ZhciByPXRoaXM7ZT16KGUpO3ZhciBvPXIucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGk9ci5fZGJJbmZvO2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGkua2V5UHJlZml4K2UpfSk7cmV0dXJuIHcobyx0KSxvfWZ1bmN0aW9uIFVyKGUsdCxyKXt2YXIgbz10aGlzO2U9eihlKTt2YXIgaT1vLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3Q9PT12b2lkIDAmJih0PW51bGwpO3ZhciBuPXQ7cmV0dXJuIG5ldyBtKGZ1bmN0aW9uKGYsdSl7dmFyIGM9by5fZGJJbmZvO2Muc2VyaWFsaXplci5zZXJpYWxpemUodCxmdW5jdGlvbihsLGQpe2lmKGQpdShkKTtlbHNlIHRyeXtsb2NhbFN0b3JhZ2Uuc2V0SXRlbShjLmtleVByZWZpeCtlLGwpLGYobil9Y2F0Y2goeSl7KHkubmFtZT09PVwiUXVvdGFFeGNlZWRlZEVycm9yXCJ8fHkubmFtZT09PVwiTlNfRVJST1JfRE9NX1FVT1RBX1JFQUNIRURcIikmJnUoeSksdSh5KX19KX0pfSk7cmV0dXJuIHcoaSxyKSxpfWZ1bmN0aW9uIFlyKGUsdCl7aWYodD1xLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxlPXR5cGVvZiBlIT1cImZ1bmN0aW9uXCImJmV8fHt9LCFlLm5hbWUpe3ZhciByPXRoaXMuY29uZmlnKCk7ZS5uYW1lPWUubmFtZXx8ci5uYW1lLGUuc3RvcmVOYW1lPWUuc3RvcmVOYW1lfHxyLnN0b3JlTmFtZX12YXIgbz10aGlzLGk7cmV0dXJuIGUubmFtZT9pPW5ldyBtKGZ1bmN0aW9uKG4pe2Uuc3RvcmVOYW1lP24oamUoZSxvLl9kZWZhdWx0Q29uZmlnKSk6bihlLm5hbWUrXCIvXCIpfSkudGhlbihmdW5jdGlvbihuKXtmb3IodmFyIGY9bG9jYWxTdG9yYWdlLmxlbmd0aC0xO2Y+PTA7Zi0tKXt2YXIgdT1sb2NhbFN0b3JhZ2Uua2V5KGYpO3UuaW5kZXhPZihuKT09PTAmJmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHUpfX0pOmk9bS5yZWplY3QoXCJJbnZhbGlkIGFyZ3VtZW50c1wiKSx3KGksdCksaX12YXIgenI9e19kcml2ZXI6XCJsb2NhbFN0b3JhZ2VXcmFwcGVyXCIsX2luaXRTdG9yYWdlOkJyLF9zdXBwb3J0OkRyKCksaXRlcmF0ZTpDcixnZXRJdGVtOk9yLHNldEl0ZW06VXIscmVtb3ZlSXRlbTpGcixjbGVhcjp4cixsZW5ndGg6TXIsa2V5OkxyLGtleXM6UHIsZHJvcEluc3RhbmNlOllyfSxXcj1mdW5jdGlvbih0LHIpe3JldHVybiB0PT09cnx8dHlwZW9mIHQ9PVwibnVtYmVyXCImJnR5cGVvZiByPT1cIm51bWJlclwiJiZpc05hTih0KSYmaXNOYU4ocil9LEtyPWZ1bmN0aW9uKHQscil7Zm9yKHZhciBvPXQubGVuZ3RoLGk9MDtpPG87KXtpZihXcih0W2ldLHIpKXJldHVybiEwO2krK31yZXR1cm4hMX0sWGU9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKT09PVwiW29iamVjdCBBcnJheV1cIn0sbGU9e30sUWU9e30sdWU9e0lOREVYRUREQjpjcixXRUJTUUw6UnIsTE9DQUxTVE9SQUdFOnpyfSxIcj1bdWUuSU5ERVhFRERCLl9kcml2ZXIsdWUuV0VCU1FMLl9kcml2ZXIsdWUuTE9DQUxTVE9SQUdFLl9kcml2ZXJdLG1lPVtcImRyb3BJbnN0YW5jZVwiXSxJZT1bXCJjbGVhclwiLFwiZ2V0SXRlbVwiLFwiaXRlcmF0ZVwiLFwia2V5XCIsXCJrZXlzXCIsXCJsZW5ndGhcIixcInJlbW92ZUl0ZW1cIixcInNldEl0ZW1cIl0uY29uY2F0KG1lKSxWcj17ZGVzY3JpcHRpb246XCJcIixkcml2ZXI6SHIuc2xpY2UoKSxuYW1lOlwibG9jYWxmb3JhZ2VcIixzaXplOjQ5ODA3MzYsc3RvcmVOYW1lOlwia2V5dmFsdWVwYWlyc1wiLHZlcnNpb246MX07ZnVuY3Rpb24gR3IoZSx0KXtlW3RdPWZ1bmN0aW9uKCl7dmFyIHI9YXJndW1lbnRzO3JldHVybiBlLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3JldHVybiBlW3RdLmFwcGx5KGUscil9KX19ZnVuY3Rpb24gU2UoKXtmb3IodmFyIGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXt2YXIgdD1hcmd1bWVudHNbZV07aWYodClmb3IodmFyIHIgaW4gdCl0Lmhhc093blByb3BlcnR5KHIpJiYoWGUodFtyXSk/YXJndW1lbnRzWzBdW3JdPXRbcl0uc2xpY2UoKTphcmd1bWVudHNbMF1bcl09dFtyXSl9cmV0dXJuIGFyZ3VtZW50c1swXX12YXIganI9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe1kodGhpcyxlKTtmb3IodmFyIHIgaW4gdWUpaWYodWUuaGFzT3duUHJvcGVydHkocikpe3ZhciBvPXVlW3JdLGk9by5fZHJpdmVyO3RoaXNbcl09aSxsZVtpXXx8dGhpcy5kZWZpbmVEcml2ZXIobyl9dGhpcy5fZGVmYXVsdENvbmZpZz1TZSh7fSxWciksdGhpcy5fY29uZmlnPVNlKHt9LHRoaXMuX2RlZmF1bHRDb25maWcsdCksdGhpcy5fZHJpdmVyU2V0PW51bGwsdGhpcy5faW5pdERyaXZlcj1udWxsLHRoaXMuX3JlYWR5PSExLHRoaXMuX2RiSW5mbz1udWxsLHRoaXMuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpLHRoaXMuc2V0RHJpdmVyKHRoaXMuX2NvbmZpZy5kcml2ZXIpLmNhdGNoKGZ1bmN0aW9uKCl7fSl9cmV0dXJuIGUucHJvdG90eXBlLmNvbmZpZz1mdW5jdGlvbihyKXtpZigodHlwZW9mIHI9PVwidW5kZWZpbmVkXCI/XCJ1bmRlZmluZWRcIjpDKHIpKT09PVwib2JqZWN0XCIpe2lmKHRoaXMuX3JlYWR5KXJldHVybiBuZXcgRXJyb3IoXCJDYW4ndCBjYWxsIGNvbmZpZygpIGFmdGVyIGxvY2FsZm9yYWdlIGhhcyBiZWVuIHVzZWQuXCIpO2Zvcih2YXIgbyBpbiByKXtpZihvPT09XCJzdG9yZU5hbWVcIiYmKHJbb109cltvXS5yZXBsYWNlKC9cXFcvZyxcIl9cIikpLG89PT1cInZlcnNpb25cIiYmdHlwZW9mIHJbb10hPVwibnVtYmVyXCIpcmV0dXJuIG5ldyBFcnJvcihcIkRhdGFiYXNlIHZlcnNpb24gbXVzdCBiZSBhIG51bWJlci5cIik7dGhpcy5fY29uZmlnW29dPXJbb119cmV0dXJuXCJkcml2ZXJcImluIHImJnIuZHJpdmVyP3RoaXMuc2V0RHJpdmVyKHRoaXMuX2NvbmZpZy5kcml2ZXIpOiEwfWVsc2UgcmV0dXJuIHR5cGVvZiByPT1cInN0cmluZ1wiP3RoaXMuX2NvbmZpZ1tyXTp0aGlzLl9jb25maWd9LGUucHJvdG90eXBlLmRlZmluZURyaXZlcj1mdW5jdGlvbihyLG8saSl7dmFyIG49bmV3IG0oZnVuY3Rpb24oZix1KXt0cnl7dmFyIGM9ci5fZHJpdmVyLGw9bmV3IEVycm9yKFwiQ3VzdG9tIGRyaXZlciBub3QgY29tcGxpYW50OyBzZWUgaHR0cHM6Ly9tb3ppbGxhLmdpdGh1Yi5pby9sb2NhbEZvcmFnZS8jZGVmaW5lZHJpdmVyXCIpO2lmKCFyLl9kcml2ZXIpe3UobCk7cmV0dXJufWZvcih2YXIgZD1JZS5jb25jYXQoXCJfaW5pdFN0b3JhZ2VcIikseT0wLEE9ZC5sZW5ndGg7eTxBO3krKyl7dmFyIFQ9ZFt5XSx4PSFLcihtZSxUKTtpZigoeHx8cltUXSkmJnR5cGVvZiByW1RdIT1cImZ1bmN0aW9uXCIpe3UobCk7cmV0dXJufX12YXIgVj1mdW5jdGlvbigpe2Zvcih2YXIgZGU9ZnVuY3Rpb24oSnIpe3JldHVybiBmdW5jdGlvbigpe3ZhciAkcj1uZXcgRXJyb3IoXCJNZXRob2QgXCIrSnIrXCIgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoZSBjdXJyZW50IGRyaXZlclwiKSxKZT1tLnJlamVjdCgkcik7cmV0dXJuIHcoSmUsYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0pLEplfX0sQWU9MCxRcj1tZS5sZW5ndGg7QWU8UXI7QWUrKyl7dmFyIFJlPW1lW0FlXTtyW1JlXXx8KHJbUmVdPWRlKFJlKSl9fTtWKCk7dmFyIFc9ZnVuY3Rpb24oZGUpe2xlW2NdJiZjb25zb2xlLmluZm8oXCJSZWRlZmluaW5nIExvY2FsRm9yYWdlIGRyaXZlcjogXCIrYyksbGVbY109cixRZVtjXT1kZSxmKCl9O1wiX3N1cHBvcnRcImluIHI/ci5fc3VwcG9ydCYmdHlwZW9mIHIuX3N1cHBvcnQ9PVwiZnVuY3Rpb25cIj9yLl9zdXBwb3J0KCkudGhlbihXLHUpOlcoISFyLl9zdXBwb3J0KTpXKCEwKX1jYXRjaChYKXt1KFgpfX0pO3JldHVybiBOKG4sbyxpKSxufSxlLnByb3RvdHlwZS5kcml2ZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZHJpdmVyfHxudWxsfSxlLnByb3RvdHlwZS5nZXREcml2ZXI9ZnVuY3Rpb24ocixvLGkpe3ZhciBuPWxlW3JdP20ucmVzb2x2ZShsZVtyXSk6bS5yZWplY3QobmV3IEVycm9yKFwiRHJpdmVyIG5vdCBmb3VuZC5cIikpO3JldHVybiBOKG4sbyxpKSxufSxlLnByb3RvdHlwZS5nZXRTZXJpYWxpemVyPWZ1bmN0aW9uKHIpe3ZhciBvPW0ucmVzb2x2ZShFZSk7cmV0dXJuIE4obyxyKSxvfSxlLnByb3RvdHlwZS5yZWFkeT1mdW5jdGlvbihyKXt2YXIgbz10aGlzLGk9by5fZHJpdmVyU2V0LnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gby5fcmVhZHk9PT1udWxsJiYoby5fcmVhZHk9by5faW5pdERyaXZlcigpKSxvLl9yZWFkeX0pO3JldHVybiBOKGkscixyKSxpfSxlLnByb3RvdHlwZS5zZXREcml2ZXI9ZnVuY3Rpb24ocixvLGkpe3ZhciBuPXRoaXM7WGUocil8fChyPVtyXSk7dmFyIGY9dGhpcy5fZ2V0U3VwcG9ydGVkRHJpdmVycyhyKTtmdW5jdGlvbiB1KCl7bi5fY29uZmlnLmRyaXZlcj1uLmRyaXZlcigpfWZ1bmN0aW9uIGMoeSl7cmV0dXJuIG4uX2V4dGVuZCh5KSx1KCksbi5fcmVhZHk9bi5faW5pdFN0b3JhZ2Uobi5fY29uZmlnKSxuLl9yZWFkeX1mdW5jdGlvbiBsKHkpe3JldHVybiBmdW5jdGlvbigpe3ZhciBBPTA7ZnVuY3Rpb24gVCgpe2Zvcig7QTx5Lmxlbmd0aDspe3ZhciB4PXlbQV07cmV0dXJuIEErKyxuLl9kYkluZm89bnVsbCxuLl9yZWFkeT1udWxsLG4uZ2V0RHJpdmVyKHgpLnRoZW4oYykuY2F0Y2goVCl9dSgpO3ZhciBWPW5ldyBFcnJvcihcIk5vIGF2YWlsYWJsZSBzdG9yYWdlIG1ldGhvZCBmb3VuZC5cIik7cmV0dXJuIG4uX2RyaXZlclNldD1tLnJlamVjdChWKSxuLl9kcml2ZXJTZXR9cmV0dXJuIFQoKX19dmFyIGQ9dGhpcy5fZHJpdmVyU2V0IT09bnVsbD90aGlzLl9kcml2ZXJTZXQuY2F0Y2goZnVuY3Rpb24oKXtyZXR1cm4gbS5yZXNvbHZlKCl9KTptLnJlc29sdmUoKTtyZXR1cm4gdGhpcy5fZHJpdmVyU2V0PWQudGhlbihmdW5jdGlvbigpe3ZhciB5PWZbMF07cmV0dXJuIG4uX2RiSW5mbz1udWxsLG4uX3JlYWR5PW51bGwsbi5nZXREcml2ZXIoeSkudGhlbihmdW5jdGlvbihBKXtuLl9kcml2ZXI9QS5fZHJpdmVyLHUoKSxuLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKSxuLl9pbml0RHJpdmVyPWwoZil9KX0pLmNhdGNoKGZ1bmN0aW9uKCl7dSgpO3ZhciB5PW5ldyBFcnJvcihcIk5vIGF2YWlsYWJsZSBzdG9yYWdlIG1ldGhvZCBmb3VuZC5cIik7cmV0dXJuIG4uX2RyaXZlclNldD1tLnJlamVjdCh5KSxuLl9kcml2ZXJTZXR9KSxOKHRoaXMuX2RyaXZlclNldCxvLGkpLHRoaXMuX2RyaXZlclNldH0sZS5wcm90b3R5cGUuc3VwcG9ydHM9ZnVuY3Rpb24ocil7cmV0dXJuISFRZVtyXX0sZS5wcm90b3R5cGUuX2V4dGVuZD1mdW5jdGlvbihyKXtTZSh0aGlzLHIpfSxlLnByb3RvdHlwZS5fZ2V0U3VwcG9ydGVkRHJpdmVycz1mdW5jdGlvbihyKXtmb3IodmFyIG89W10saT0wLG49ci5sZW5ndGg7aTxuO2krKyl7dmFyIGY9cltpXTt0aGlzLnN1cHBvcnRzKGYpJiZvLnB1c2goZil9cmV0dXJuIG99LGUucHJvdG90eXBlLl93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHk9ZnVuY3Rpb24oKXtmb3IodmFyIHI9MCxvPUllLmxlbmd0aDtyPG87cisrKUdyKHRoaXMsSWVbcl0pfSxlLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZT1mdW5jdGlvbihyKXtyZXR1cm4gbmV3IGUocil9LGV9KCksWHI9bmV3IGpyO00uZXhwb3J0cz1Ycn0se1wiM1wiOjN9XX0se30sWzRdKSg0KX0pfSk7dmFyIHJyPSRlKCh5ZSxlcik9PnsoZnVuY3Rpb24ocCxnKXt0eXBlb2YgeWU9PVwib2JqZWN0XCImJnR5cGVvZiBlciE9XCJ1bmRlZmluZWRcIj9nKHllKTp0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQ/ZGVmaW5lKFwibG9jYWxmb3JhZ2UtZHJpdmVyLW1lbW9yeVwiLFtcImV4cG9ydHNcIl0sZyk6ZyhwLkxvY2FsZm9yYWdlRHJpdmVyTWVtb3J5PXt9KX0pKHR5cGVvZiBzZWxmIT1cInVuZGVmaW5lZFwiP3NlbGY6eWUsZnVuY3Rpb24ocCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGc9XCJsb2NhbGZvcmFnZS1kcml2ZXItbWVtb3J5XCI7ZnVuY3Rpb24gTyhhKXt2YXIgcz10eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJmFbU3ltYm9sLml0ZXJhdG9yXSx2PTA7cmV0dXJuIHM/cy5jYWxsKGEpOntuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIGEmJnY+PWEubGVuZ3RoJiYoYT12b2lkIDApLHt2YWx1ZTphJiZhW3YrK10sZG9uZTohYX19fX1mdW5jdGlvbiBMKGEscyl7YT1hfHxbXSxzPXN8fHt9O3RyeXtyZXR1cm4gbmV3IEJsb2IoYSxzKX1jYXRjaChFKXtpZihFLm5hbWUhPT1cIlR5cGVFcnJvclwiKXRocm93IEU7Zm9yKHZhciB2PXR5cGVvZiBCbG9iQnVpbGRlciE9XCJ1bmRlZmluZWRcIj9CbG9iQnVpbGRlcjp0eXBlb2YgTVNCbG9iQnVpbGRlciE9XCJ1bmRlZmluZWRcIj9NU0Jsb2JCdWlsZGVyOnR5cGVvZiBNb3pCbG9iQnVpbGRlciE9XCJ1bmRlZmluZWRcIj9Nb3pCbG9iQnVpbGRlcjpXZWJLaXRCbG9iQnVpbGRlcixiPW5ldyB2LF89MDtfPGEubGVuZ3RoO18rPTEpYi5hcHBlbmQoYVtfXSk7cmV0dXJuIGIuZ2V0QmxvYihzLnR5cGUpfX12YXIgTT0vXn5+bG9jYWxfZm9yYWdlX3R5cGV+KFtefl0rKX4vLFE9XCJfX2xmc2NfXzpcIi5sZW5ndGgsQz1RK1wiYXJiZlwiLmxlbmd0aCxZPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gUyhhKXt2YXIgcz1hLmxlbmd0aCouNzUsdj1hLmxlbmd0aDthW2EubGVuZ3RoLTFdPT09XCI9XCImJihzLS0sYVthLmxlbmd0aC0yXT09PVwiPVwiJiZzLS0pO2Zvcih2YXIgYj1uZXcgQXJyYXlCdWZmZXIocyksXz1uZXcgVWludDhBcnJheShiKSxFPTAsRD0wO0U8djtFKz00KXt2YXIgRz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5pbmRleE9mKGFbRV0pLGZlPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLmluZGV4T2YoYVtFKzFdKSxpZT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIi5pbmRleE9mKGFbRSsyXSksY2U9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIuaW5kZXhPZihhW0UrM10pO19bRCsrXT1HPDwyfGZlPj40LF9bRCsrXT0oZmUmMTUpPDw0fGllPj4yLF9bRCsrXT0oaWUmMyk8PDZ8Y2UmNjN9cmV0dXJuIGJ9ZnVuY3Rpb24gUChhKXtmb3IodmFyIHM9bmV3IFVpbnQ4QXJyYXkoYSksdj1cIlwiLGI9MDtiPHMubGVuZ3RoO2IrPTMpdis9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCJbc1tiXT4+Ml0sdis9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCJbKHNbYl0mMyk8PDR8c1tiKzFdPj40XSx2Kz1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIlsoc1tiKzFdJjE1KTw8MnxzW2IrMl0+PjZdLHYrPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiW3NbYisyXSY2M107cmV0dXJuIHMubGVuZ3RoJTM9PT0yP3Y9di5zdWJzdHJpbmcoMCx2Lmxlbmd0aC0xKStcIj1cIjpzLmxlbmd0aCUzPT09MSYmKHY9di5zdWJzdHJpbmcoMCx2Lmxlbmd0aC0yKStcIj09XCIpLHZ9ZnVuY3Rpb24gSyhhLHMpe3ZhciB2PVwiXCI7aWYoYSYmKHY9WS5jYWxsKGEpKSxhJiYodj09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cInx8YS5idWZmZXImJlkuY2FsbChhLmJ1ZmZlcik9PT1cIltvYmplY3QgQXJyYXlCdWZmZXJdXCIpKXt2YXIgYj12b2lkIDAsXz1cIl9fbGZzY19fOlwiO2EgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj8oYj1hLF8rPVwiYXJiZlwiKTooYj1hLmJ1ZmZlcix2PT09XCJbb2JqZWN0IEludDhBcnJheV1cIj9fKz1cInNpMDhcIjp2PT09XCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI/Xys9XCJ1aTA4XCI6dj09PVwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIj9fKz1cInVpYzhcIjp2PT09XCJbb2JqZWN0IEludDE2QXJyYXldXCI/Xys9XCJzaTE2XCI6dj09PVwiW29iamVjdCBVaW50MTZBcnJheV1cIj9fKz1cInVyMTZcIjp2PT09XCJbb2JqZWN0IEludDMyQXJyYXldXCI/Xys9XCJzaTMyXCI6dj09PVwiW29iamVjdCBVaW50MzJBcnJheV1cIj9fKz1cInVpMzJcIjp2PT09XCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIj9fKz1cImZsMzJcIjp2PT09XCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIj9fKz1cImZsNjRcIjpzKG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgdHlwZSBmb3IgQmluYXJ5QXJyYXlcIikpKSxzKF8rUChiKSl9ZWxzZSBpZih2PT09XCJbb2JqZWN0IEJsb2JdXCIpe3ZhciBFPW5ldyBGaWxlUmVhZGVyO0Uub25sb2FkPWZ1bmN0aW9uKCl7dmFyIEQ9XCJ+fmxvY2FsX2ZvcmFnZV90eXBlflwiK2EudHlwZStcIn5cIitQKHRoaXMucmVzdWx0KTtzKFwiX19sZnNjX186YmxvYlwiK0QpfSxFLnJlYWRBc0FycmF5QnVmZmVyKGEpfWVsc2UgdHJ5e3MoSlNPTi5zdHJpbmdpZnkoYSkpfWNhdGNoKEQpe2NvbnNvbGUuZXJyb3IoXCJDb3VsZG4ndCBjb252ZXJ0IHZhbHVlIGludG8gYSBKU09OIHN0cmluZzogXCIsYSkscyhudWxsLEQpfX1mdW5jdGlvbiBaKGEpe2lmKGEuc3Vic3RyaW5nKDAsUSkhPT1cIl9fbGZzY19fOlwiKXJldHVybiBKU09OLnBhcnNlKGEpO3ZhciBzPWEuc3Vic3RyaW5nKEMpLHY9YS5zdWJzdHJpbmcoUSxDKSxiO2lmKHY9PT1cImJsb2JcIiYmTS50ZXN0KHMpKXt2YXIgXz1zLm1hdGNoKE0pO2I9X1sxXSxzPXMuc3Vic3RyaW5nKF9bMF0ubGVuZ3RoKX12YXIgRT1TKHMpO3N3aXRjaCh2KXtjYXNlXCJhcmJmXCI6cmV0dXJuIEU7Y2FzZVwiYmxvYlwiOnJldHVybiBMKFtFXSx7dHlwZTpifSk7Y2FzZVwic2kwOFwiOnJldHVybiBuZXcgSW50OEFycmF5KEUpO2Nhc2VcInVpMDhcIjpyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoRSk7Y2FzZVwidWljOFwiOnJldHVybiBuZXcgVWludDhDbGFtcGVkQXJyYXkoRSk7Y2FzZVwic2kxNlwiOnJldHVybiBuZXcgSW50MTZBcnJheShFKTtjYXNlXCJ1cjE2XCI6cmV0dXJuIG5ldyBVaW50MTZBcnJheShFKTtjYXNlXCJzaTMyXCI6cmV0dXJuIG5ldyBJbnQzMkFycmF5KEUpO2Nhc2VcInVpMzJcIjpyZXR1cm4gbmV3IFVpbnQzMkFycmF5KEUpO2Nhc2VcImZsMzJcIjpyZXR1cm4gbmV3IEZsb2F0MzJBcnJheShFKTtjYXNlXCJmbDY0XCI6cmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkoRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtvd24gdHlwZTogXCIrdil9fWZ1bmN0aW9uIG0oYSl7dmFyIHMsdjtpZihhPT09bnVsbHx8dHlwZW9mIGEhPVwib2JqZWN0XCJ8fFwiaXNBY3RpdmVDbG9uZVwiaW4gYSlyZXR1cm4gYTt2YXIgYj1hIGluc3RhbmNlb2YgRGF0ZT9uZXcgRGF0ZShhKTphLmNvbnN0cnVjdG9yKCk7dHJ5e2Zvcih2YXIgXz1PKE9iamVjdC5rZXlzKGEpKSxFPV8ubmV4dCgpOyFFLmRvbmU7RT1fLm5leHQoKSl7dmFyIEQ9RS52YWx1ZTtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxEKSYmKGEuaXNBY3RpdmVDbG9uZT1udWxsLGJbRF09bShhW0RdKSxkZWxldGUgYS5pc0FjdGl2ZUNsb25lKX19Y2F0Y2goRyl7cz17ZXJyb3I6R319ZmluYWxseXt0cnl7RSYmIUUuZG9uZSYmKHY9Xy5yZXR1cm4pJiZ2LmNhbGwoXyl9ZmluYWxseXtpZihzKXRocm93IHMuZXJyb3J9fXJldHVybiBifWZ1bmN0aW9uIHcoYSxzKXtyZXR1cm4oYS5uYW1lfHxzLm5hbWUpK1wiL1wiKyhhLnN0b3JlTmFtZXx8cy5zdG9yZU5hbWUpK1wiL1wifWZ1bmN0aW9uIE4oYSxzKXtzJiZhLnRoZW4oZnVuY3Rpb24odil7cyhudWxsLHYpfSxmdW5jdGlvbih2KXtzKHYpfSl9ZnVuY3Rpb24geigpe2Zvcih2YXIgYT1bXSxzPTA7czxhcmd1bWVudHMubGVuZ3RoO3MrKylhW3NdPWFyZ3VtZW50c1tzXTtpZihhcmd1bWVudHMubGVuZ3RoJiZ0eXBlb2YgYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV09PVwiZnVuY3Rpb25cIilyZXR1cm4gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV19ZnVuY3Rpb24gcShhLHMpe3ZhciB2PXRoaXM7aWYocz16LmFwcGx5KHRoaXMsYXJndW1lbnRzKSxhPXR5cGVvZiBhIT1cImZ1bmN0aW9uXCImJmF8fHt9LCFhLm5hbWUpe3ZhciBiPXRoaXMuY29uZmlnKCk7YS5uYW1lPWEubmFtZXx8Yi5uYW1lLGEuc3RvcmVOYW1lPWEuc3RvcmVOYW1lfHxiLnN0b3JlTmFtZX12YXIgXztyZXR1cm4gYS5uYW1lP189bmV3IFByb21pc2UoZnVuY3Rpb24oRSl7YS5zdG9yZU5hbWU/RSh3KGEsdi5fZGVmYXVsdENvbmZpZykpOkUoYS5uYW1lK1wiL1wiKX0pOl89UHJvbWlzZS5yZWplY3QoXCJJbnZhbGlkIGFyZ3VtZW50c1wiKSx7cHJvbWlzZTpfLGNhbGxiYWNrOnN9fWZ1bmN0aW9uIEYoYSl7cmV0dXJuIHR5cGVvZiBhIT1cInN0cmluZ1wiJiYoY29uc29sZS53YXJuKGErXCIgdXNlZCBhcyBhIGtleSwgYnV0IGl0IGlzIG5vdCBhIHN0cmluZy5cIiksYT1TdHJpbmcoYSkpLGF9dmFyIGs9e2J1ZmZlclRvU3RyaW5nOlAsZGVzZXJpYWxpemU6WixzZXJpYWxpemU6SyxzdHJpbmdUb0J1ZmZlcjpTfSxVPXt9LGFlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShzKXt0aGlzLmtwPXMsdGhpcy5kYXRhPXt9fXJldHVybiBhLnJlc29sdmU9ZnVuY3Rpb24ocyl7cmV0dXJuIFVbc118fChVW3NdPW5ldyBhKHMpKSxVW3NdfSxhLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuZGF0YT17fX0sYS5wcm90b3R5cGUuZHJvcD1mdW5jdGlvbigpe3RoaXMuY2xlYXIoKSxkZWxldGUgVVt0aGlzLmtwXX0sYS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHMpe3JldHVybiB0aGlzLmRhdGFbc119LGEucHJvdG90eXBlLmtleT1mdW5jdGlvbihzKXtyZXR1cm4gdGhpcy5rZXlzKClbc119LGEucHJvdG90eXBlLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhKX0sYS5wcm90b3R5cGUucm09ZnVuY3Rpb24ocyl7ZGVsZXRlIHRoaXMuZGF0YVtzXX0sYS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHMsdil7dGhpcy5kYXRhW3NdPXZ9LGF9KCk7ZnVuY3Rpb24gcmUoYSl7dmFyIHM9YT9tKGEpOnt9LHY9dyhzLHRoaXMuX2RlZmF1bHRDb25maWcpLGI9YWUucmVzb2x2ZSh2KTtyZXR1cm4gdGhpcy5fZGJJbmZvPXMsdGhpcy5fZGJJbmZvLnNlcmlhbGl6ZXI9ayx0aGlzLl9kYkluZm8ua2V5UHJlZml4PXYsdGhpcy5fZGJJbmZvLm1TdG9yZT1iLFByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIGgoYSl7dmFyIHM9dGhpcyx2PXRoaXMucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7cy5fZGJJbmZvLm1TdG9yZS5jbGVhcigpfSk7cmV0dXJuIE4odixhKSx2fWZ1bmN0aW9uIFIoYSxzKXt2YXIgdj1xLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxiPXYucHJvbWlzZSxfPXYuY2FsbGJhY2ssRT1iLnRoZW4oZnVuY3Rpb24oRCl7YWUucmVzb2x2ZShEKS5kcm9wKCl9KTtyZXR1cm4gTihFLF8pLGJ9ZnVuY3Rpb24gSShhLHMpe3ZhciB2PXRoaXM7YT1GKGEpO3ZhciBiPXRoaXMucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIF89di5fZGJJbmZvLm1TdG9yZS5nZXQoYSk7cmV0dXJuIF89PW51bGw/bnVsbDp2Ll9kYkluZm8uc2VyaWFsaXplci5kZXNlcmlhbGl6ZShfKX0pO3JldHVybiBOKGIscyksYn1mdW5jdGlvbiBCKGEscyl7dmFyIHY9dGhpcyxiPXRoaXMucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBfPXYuX2RiSW5mby5tU3RvcmUsRT1fLmtleXMoKSxEPTA7RDxFLmxlbmd0aDtEKyspe3ZhciBHPV8uZ2V0KEVbRF0pO2lmKEcmJihHPXYuX2RiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKEcpKSxHPWEoRyxFW0RdLEQrMSksRyE9PXZvaWQgMClyZXR1cm4gR319KTtyZXR1cm4gTihiLHMpLGJ9ZnVuY3Rpb24gSChhLHMpe3ZhciB2PXRoaXMsYj10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3ZhciBfO3RyeXtfPXYuX2RiSW5mby5tU3RvcmUua2V5KGEpLF89PT12b2lkIDAmJihfPW51bGwpfWNhdGNoe189bnVsbH1yZXR1cm4gX30pO3JldHVybiBOKGIscyksYn1mdW5jdGlvbiBqKGEpe3ZhciBzPXRoaXMsdj10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3JldHVybiBzLl9kYkluZm8ubVN0b3JlLmtleXMoKX0pO3JldHVybiBOKHYsYSksdn1mdW5jdGlvbiBKKGEpe3ZhciBzPXRoaXMua2V5cygpLnRoZW4oZnVuY3Rpb24odil7cmV0dXJuIHYubGVuZ3RofSk7cmV0dXJuIE4ocyxhKSxzfWZ1bmN0aW9uICQoYSxzKXt2YXIgdj10aGlzO2E9RihhKTt2YXIgYj10aGlzLnJlYWR5KCkudGhlbihmdW5jdGlvbigpe3YuX2RiSW5mby5tU3RvcmUucm0oYSl9KTtyZXR1cm4gTihiLHMpLGJ9ZnVuY3Rpb24gZWUoYSxzLHYpe3ZhciBiPXRoaXM7YT1GKGEpO3ZhciBfPXRoaXMucmVhZHkoKS50aGVuKGZ1bmN0aW9uKCl7cz09PXZvaWQgMCYmKHM9bnVsbCk7dmFyIEU9cztyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oRCxHKXtiLl9kYkluZm8uc2VyaWFsaXplci5zZXJpYWxpemUocyxmdW5jdGlvbihmZSxpZSl7aWYoaWUpRyhpZSk7ZWxzZSB0cnl7Yi5fZGJJbmZvLm1TdG9yZS5zZXQoYSxmZSksRChFKX1jYXRjaChjZSl7RyhjZSl9fSl9KX0pO3JldHVybiBOKF8sdiksX312YXIgb2U9ITA7cC5fc3VwcG9ydD1vZSxwLl9kcml2ZXI9ZyxwLl9pbml0U3RvcmFnZT1yZSxwLmNsZWFyPWgscC5kcm9wSW5zdGFuY2U9UixwLmdldEl0ZW09SSxwLml0ZXJhdGU9QixwLmtleT1ILHAua2V5cz1qLHAubGVuZ3RoPUoscC5yZW1vdmVJdGVtPSQscC5zZXRJdGVtPWVlLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSl9KTt2YXIgcGU9WmUoa2UoKSksQmU9WmUocnIoKSk7aW1wb3J0e1NES0Jhc2UgYXMgY3QsY3JlYXRlU0RLIGFzIGx0fWZyb21cIkBtYWdpYy1zZGsvcHJvdmlkZXJcIjtpbXBvcnR7Vmlld0NvbnRyb2xsZXIgYXMgb3QsY3JlYXRlRHVwbGljYXRlSWZyYW1lV2FybmluZyBhcyBpdCxjcmVhdGVVUkwgYXMgdHIsY3JlYXRlTW9kYWxOb3RSZWFkeUVycm9yIGFzIGF0fWZyb21cIkBtYWdpYy1zZGsvcHJvdmlkZXJcIjt2YXIgZnQ9e2Rpc3BsYXk6XCJub25lXCIscG9zaXRpb246XCJmaXhlZFwiLHRvcDpcIjBcIixyaWdodDpcIjBcIix3aWR0aDpcIjEwMCVcIixoZWlnaHQ6XCIxMDAlXCIsYm9yZGVyUmFkaXVzOlwiMFwiLGJvcmRlcjpcIm5vbmVcIix6SW5kZXg6XCIyMTQ3NDgzNjQ3XCJ9O2Z1bmN0aW9uIHV0KHApe2ZvcihsZXRbZyxPXW9mIE9iamVjdC5lbnRyaWVzKGZ0KSlwLnN0eWxlW2ddPU99ZnVuY3Rpb24gc3QocCl7bGV0IGc9W10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm1hZ2ljLWlmcmFtZVwiKSk7cmV0dXJuIEJvb2xlYW4oZy5maW5kKE89Pk8uc3JjLmluY2x1ZGVzKHApKSl9dmFyIFRlPWNsYXNzIGV4dGVuZHMgb3R7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpO3RoaXMuYWN0aXZlRWxlbWVudD1udWxsfWluaXQoKXt0aGlzLnRlc3Q9XCJoZWxsb1wiLHRoaXMuaWZyYW1lPW5ldyBQcm9taXNlKGc9PntsZXQgTz0oKT0+e2lmKHN0KGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnBhcmFtZXRlcnMpKSlpdCgpLmxvZygpO2Vsc2V7bGV0IEw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtMLmNsYXNzTGlzdC5hZGQoXCJtYWdpYy1pZnJhbWVcIiksTC5kYXRhc2V0Lm1hZ2ljSWZyYW1lTGFiZWw9dHIodGhpcy5lbmRwb2ludCkuaG9zdCxMLnRpdGxlPVwiU2VjdXJlIE1vZGFsXCIsTC5zcmM9dHIoYC9zZW5kP3BhcmFtcz0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnBhcmFtZXRlcnMpfWAsdGhpcy5lbmRwb2ludCkuaHJlZix1dChMKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKEwpLGcoTCl9fTtbXCJsb2FkZWRcIixcImludGVyYWN0aXZlXCIsXCJjb21wbGV0ZVwiXS5pbmNsdWRlcyhkb2N1bWVudC5yZWFkeVN0YXRlKT9PKCk6d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsTywhMSl9KSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixnPT57dmFyIE87aWYoZy5vcmlnaW49PT10aGlzLmVuZHBvaW50JiZnLmRhdGEmJmcuZGF0YS5tc2dUeXBlJiZ0aGlzLm1lc3NhZ2VIYW5kbGVycy5zaXplKXtnLmRhdGEucmVzcG9uc2U9KE89Zy5kYXRhLnJlc3BvbnNlKSE9bnVsbD9POnt9O2ZvcihsZXQgTCBvZiB0aGlzLm1lc3NhZ2VIYW5kbGVycy52YWx1ZXMoKSlMKGcpfX0pfXNob3dPdmVybGF5KCl7cmV0dXJuIHNlKHRoaXMsbnVsbCxmdW5jdGlvbiooKXtsZXQgZz15aWVsZCB0aGlzLmlmcmFtZTtnLnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiLHRoaXMuYWN0aXZlRWxlbWVudD1kb2N1bWVudC5hY3RpdmVFbGVtZW50LGcuZm9jdXMoKX0pfWhpZGVPdmVybGF5KCl7cmV0dXJuIHNlKHRoaXMsbnVsbCxmdW5jdGlvbiooKXt2YXIgTztsZXQgZz15aWVsZCB0aGlzLmlmcmFtZTtnLnN0eWxlLmRpc3BsYXk9XCJub25lXCIsKChPPXRoaXMuYWN0aXZlRWxlbWVudCk9PW51bGw/dm9pZCAwOk8uZm9jdXMpJiZ0aGlzLmFjdGl2ZUVsZW1lbnQuZm9jdXMoKSx0aGlzLmFjdGl2ZUVsZW1lbnQ9bnVsbH0pfV9wb3N0KGcpe3JldHVybiBzZSh0aGlzLG51bGwsZnVuY3Rpb24qKCl7bGV0IE89eWllbGQgdGhpcy5pZnJhbWU7aWYoTyYmTy5jb250ZW50V2luZG93KU8uY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShnLHRoaXMuZW5kcG9pbnQpO2Vsc2UgdGhyb3cgYXQoKX0pfX07ZXhwb3J0KmZyb21cIkBtYWdpYy1zZGsvY29tbW9uc1wiO3ZhciBfdD1sdChjdCx7cGxhdGZvcm06XCJ3ZWJcIixzZGtOYW1lOlwibWFnaWMtc2RrXCIsdmVyc2lvbjpcIjEwLjAuMFwiLGRlZmF1bHRFbmRwb2ludDpcImh0dHBzOi8vYXV0aC5tYWdpYy5saW5rL1wiLFZpZXdDb250cm9sbGVyOlRlLGNvbmZpZ3VyZVN0b3JhZ2U6KCk9PnNlKHZvaWQgMCxudWxsLGZ1bmN0aW9uKigpe2xldCBwPXBlLmRlZmF1bHQuY3JlYXRlSW5zdGFuY2Uoe25hbWU6XCJNYWdpY0F1dGhMb2NhbFN0b3JhZ2VEQlwiLHN0b3JlTmFtZTpcIk1hZ2ljQXV0aExvY2FsU3RvcmFnZVwifSk7cmV0dXJuIHlpZWxkIHAuZGVmaW5lRHJpdmVyKEJlKSx5aWVsZCBwLnNldERyaXZlcihbcGUuZGVmYXVsdC5JTkRFWEVEREIscGUuZGVmYXVsdC5MT0NBTFNUT1JBR0UsQmUuX2RyaXZlcl0pLHB9KX0pO2V4cG9ydHtfdCBhcyBNYWdpY307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnR7RXh0ZW5zaW9uIGFzIG99ZnJvbVwibWFnaWMtc2RrXCI7dmFyIHM9KHQ9Pih0LkdldFdhbGxldEluZm89XCJtY19nZXRfd2FsbGV0X2luZm9cIix0LlNob3dXYWxsZXQ9XCJtY193YWxsZXRcIix0LlJlcXVlc3RVc2VySW5mbz1cIm1jX3JlcXVlc3RfdXNlcl9pbmZvXCIsdC5EaXNjb25uZWN0PVwibWNfZGlzY29ubmVjdFwiLHQpKShzfHx7fSk7dmFyIGw9Y2xhc3MgZXh0ZW5kcyBvLkludGVybmFse2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKTt0aGlzLm5hbWU9XCJjb25uZWN0XCI7dGhpcy5jb25maWc9e21jOiEwfX1nZXRXYWxsZXRJbmZvKCl7bGV0IGU9dGhpcy51dGlscy5jcmVhdGVKc29uUnBjUmVxdWVzdFBheWxvYWQoXCJtY19nZXRfd2FsbGV0X2luZm9cIik7cmV0dXJuIHRoaXMucmVxdWVzdChlKX1zaG93V2FsbGV0KCl7bGV0IGU9dGhpcy51dGlscy5jcmVhdGVKc29uUnBjUmVxdWVzdFBheWxvYWQoXCJtY193YWxsZXRcIik7cmV0dXJuIHRoaXMucmVxdWVzdChlKX1yZXF1ZXN0VXNlckluZm8oZSl7bGV0IG49dGhpcy51dGlscy5jcmVhdGVKc29uUnBjUmVxdWVzdFBheWxvYWQoXCJtY19yZXF1ZXN0X3VzZXJfaW5mb1wiLGU/W2VdOltdKTtyZXR1cm4gdGhpcy5yZXF1ZXN0KG4pfWRpc2Nvbm5lY3QoKXtsZXQgZT10aGlzLnV0aWxzLmNyZWF0ZUpzb25ScGNSZXF1ZXN0UGF5bG9hZChcIm1jX2Rpc2Nvbm5lY3RcIik7cmV0dXJuIHRoaXMucmVxdWVzdChlKX19O2V4cG9ydHtsIGFzIENvbm5lY3RFeHRlbnNpb24scyBhcyBNYWdpY0Nvbm5lY3RQYXlsb2FkTWV0aG9kfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cclxuaW1wb3J0IHtldGhlcnN9IGZyb20gJ2V0aGVycyc7XHJcbmltcG9ydCBBYnN0cmFjdFdlYjNDb25uZWN0b3IgZnJvbSAnLi9BYnN0cmFjdFdlYjNDb25uZWN0b3InO1xyXG5pbXBvcnQge01hZ2ljfSBmcm9tIFwibWFnaWMtc2RrXCI7XHJcbmltcG9ydCB7Q29ubmVjdEV4dGVuc2lvbn0gZnJvbSBcIkBtYWdpYy1leHQvY29ubmVjdFwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCB7Q3VzdG9tTm9kZUNvbmZpZ3VyYXRpb259IGZyb20gXCJAbWFnaWMtc2RrL3R5cGVzL2Rpc3QvdHlwZXMvbW9kdWxlcy9ycGMtcHJvdmlkZXItdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hZ2ljV2ViM0Nvbm5lY3RvciBleHRlbmRzIEFic3RyYWN0V2ViM0Nvbm5lY3RvciB7XHJcbiAgICB0eXBlID0gJ01hZ2ljTGluayc7XHJcbiAgICBtYWdpYzogYW55O1xyXG5cclxuICAgIGFzeW5jIGFjdGl2YXRlKCkge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IE5ldHdvcmtJbmZvLmdldEluc3RhbmNlKCk7XHJcbmNvbnNvbGUubG9nKCduZXR3b3JrSW5mbycsIG5ldHdvcmtJbmZvKTtcclxuICAgICAgICBsZXQgY3VzdG9tTmV0d29yayA9IHtycGNVcmw6IG5ldHdvcmtJbmZvLlJwY1VybCwgY2hhaW5JZDogbmV0d29ya0luZm8uQ2hhaW5JZH0gYXMgQ3VzdG9tTm9kZUNvbmZpZ3VyYXRpb247XHJcbiAgICAgICAgdGhpcy5tYWdpYyA9IG5ldyBNYWdpYygncGtfbGl2ZV9FQTlEREM0NThGRTIxQjI0Jywge1xyXG4gICAgICAgICAgICBleHRlbnNpb25zOiBbbmV3IENvbm5lY3RFeHRlbnNpb24oKV0sXHJcbiAgICAgICAgICAgIG5ldHdvcms6IGN1c3RvbU5ldHdvcmtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGxldCBldGhlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcih0aGlzLm1hZ2ljLnJwY1Byb3ZpZGVyKTtcclxuICAgICAgICBsZXQgYWNjb3VudHMgPSBhd2FpdCBldGhlci5saXN0QWNjb3VudHMoKTtcclxuXHJcbiAgICAgICAgLy8gQXNzaWduIENvbnN0YW50c1xyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnRzWzBdO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBldGhlci5wcm92aWRlcjtcclxuICAgICAgICB0aGlzLmNoYWluSWQgPSBgMHgke25ldHdvcmtJbmZvLkNoYWluSWQudG9TdHJpbmcoMTYpfWA7XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHModGhpcy5wcm92aWRlcik7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXHJcbiAgICAgICAgICAgIGFjY291bnQ6IHRoaXMuYWNjb3VudCxcclxuICAgICAgICAgICAgY2hhaW5JZDogdGhpcy5jaGFpbklkLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRlYWN0aXZhdGUgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZVRvRXZlbnRzKHRoaXMucHJvdmlkZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLm1hZ2ljKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubWFnaWMuY29ubmVjdC5kaXNjb25uZWN0KCkuY2F0Y2goKGU6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3IgdG8gZGlzY29ubmVjdDonLCBlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWNjb3VudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGFpbklkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcclxuICAgIH07XHJcbn1cclxuIiwiaW1wb3J0IE1vcmFsaXMgZnJvbSBcIm1vcmFsaXNcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuLi8uLi9lcnJvcnMvR2VuZXJhbEVycm9yXCI7XHJcbmltcG9ydCBTd2l0Y2hOZXR3b3JrTW9kYWwgZnJvbSBcIi4uLy4uL3VpL21vZGFscy9Td2l0Y2hOZXR3b3JrTW9kYWxcIjtcclxuaW1wb3J0IE1hZ2ljV2ViM0Nvbm5lY3RvciBmcm9tIFwiLi4vLi4vd2FsbGV0L01hZ2ljV2ViM0Nvbm5lY3RvclwiO1xyXG5pbXBvcnQgUHJvdmlkZXJJbmZvIGZyb20gXCIuLi8uLi93YWxsZXQvUHJvdmlkZXJJbmZvXCI7XHJcbmltcG9ydCBNb3JhbGlzV2ViM1Byb3ZpZGVyID0gTW9yYWxpcy5Nb3JhbGlzV2ViM1Byb3ZpZGVyO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dGhlbnRpY2F0ZVNlcnZpY2Uge1xyXG4gICAgbW9yYWxpczogdHlwZW9mIE1vcmFsaXNcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZW5hYmxlV2ViMyhtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIGlmIChtb3JhbGlzLmlzV2ViM0VuYWJsZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9yYWxpcy5wcm92aWRlciBhcyBNb3JhbGlzV2ViM1Byb3ZpZGVyO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9wdGlvbnMgPSB7Y29ubmVjdG9yOiBNYWdpY1dlYjNDb25uZWN0b3J9IGFzIGFueTtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbW9yYWxpcy5lbmFibGVXZWIzKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBhdXRoZW50aWNhdGVVc2VyKGVuYWJsZVdlYjNDYWxsYmFjaz86ICh3YWxsZXRDb25uZWN0aW9uSW5mbzogYW55KSA9PiB2b2lkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRlZENhbGxiYWNrPzogKHVzZXI6IE1vcmFsaXMuVXNlcikgPT4gdm9pZFxyXG4gICAgKSB7XHJcbiAgICAgICAgbGV0IGNoYWluSWQgPSBOZXR3b3JrSW5mby5nZXRJbnN0YW5jZSgpLkNoYWluSWQ7XHJcbiAgICAgICAgbGV0IHdlYjNQcm92aWRlciA9IGF3YWl0IEF1dGhlbnRpY2F0ZVNlcnZpY2UuZW5hYmxlV2ViMyh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGlmIChlbmFibGVXZWIzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgZW5hYmxlV2ViM0NhbGxiYWNrKHdlYjNQcm92aWRlcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdXNlciA9IHRoaXMubW9yYWxpcy5Vc2VyLmN1cnJlbnQoKTtcclxuICAgICAgICBpZiAodXNlcikge1xyXG4gICAgICAgICAgICBpZiAoYXV0aGVudGljYXRlZENhbGxiYWNrKSBhdXRoZW50aWNhdGVkQ2FsbGJhY2sodXNlcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh3ZWIzUHJvdmlkZXIubmV0d29yay5jaGFpbklkICE9IGNoYWluSWQpIHtcclxuICAgICAgICAgICAgbGV0IHVzZXJOZXR3b3JrID0gTmV0d29ya0luZm8uZ2V0TmV0d29ya0luZm9CeUNoYWluSWQod2ViM1Byb3ZpZGVyLm5ldHdvcmsuY2hhaW5JZCk7XHJcbiAgICAgICAgICAgIGlmICh1c2VyTmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgTmV0d29ya0luZm8uc2V0TmV0d29ya0J5Q2hhaW5JZCh3ZWIzUHJvdmlkZXIubmV0d29yay5jaGFpbklkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBTd2l0Y2hOZXR3b3JrTW9kYWwodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIG1vZGFsLnNob3coKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9iajogYW55ID0ge3NpZ25pbmdNZXNzYWdlOiBcIllvdSBhcmUgbG9nZ2luZyBpbnRvIExpbWluYWwubWFya2V0LlxcblxcblwiLCBjb25uZWN0b3I6IE1hZ2ljV2ViM0Nvbm5lY3Rvcn07XHJcbiAgICAgICAgdXNlciA9IGF3YWl0IHRoaXMubW9yYWxpcy5hdXRoZW50aWNhdGUob2JqKVxyXG4gICAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKHJlYXNvbjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihyZWFzb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGF1dGhlbnRpY2F0ZWRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICBhdXRoZW50aWNhdGVkQ2FsbGJhY2sodXNlcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRVc2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vcmFsaXMuVXNlci5jdXJyZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldEV0aEFkZHJlc3MoKTogc3RyaW5nIHtcclxuICAgICAgICBsZXQgdXNlciA9IHRoaXMuZ2V0VXNlcigpO1xyXG4gICAgICAgIGlmICghdXNlcikgcmV0dXJuICcnO1xyXG5cclxuICAgICAgICBsZXQgZXRoQWRkcmVzcyA9IHVzZXIuZ2V0KCdldGhBZGRyZXNzJyk7XHJcbiAgICAgICAgcmV0dXJuIGV0aEFkZHJlc3M7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzV2FsbGV0Q29ubmVjdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vcmFsaXMuaXNXZWIzRW5hYmxlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc1VzZXJMb2dnZWRJbigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubW9yYWxpcy5Vc2VyLmN1cnJlbnQoKSAhPT0gbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENoYWluSWQoKTogbnVtYmVyIHtcclxuICAgICAgICBpZiAoIXRoaXMubW9yYWxpcy5jaGFpbklkKSByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMubW9yYWxpcy5jaGFpbklkLCAxNik7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IEF1dGhlbnRpY2F0ZVNlcnZpY2UgZnJvbSBcIi4uL3NlcnZpY2VzL2JhY2tlbmQvQXV0aGVudGljYXRlU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmV0d29yayB7XHJcbiAgICBTZXJ2ZXJVcmwgPSBcIlwiO1xyXG4gICAgQXBwSWQgPSBcIlwiO1xyXG4gICAgQ2hhaW5JZCA9IDA7XHJcbiAgICBOYW1lID0gXCJcIjtcclxuICAgIENoYWluTmFtZSA9ICcnO1xyXG4gICAgTmF0aXZlQ3VycmVuY3lOYW1lID0gXCJcIjtcclxuICAgIE5hdGl2ZVN5bWJvbCA9IFwiXCI7XHJcbiAgICBOYXRpdmVEZWNpbWFsID0gMTg7XHJcbiAgICBScGNVcmwgPSAnJztcclxuICAgIEJsb2NrRXhwbG9yZXIgPSAnJztcclxuICAgIFRlc3ROZXR3b3JrID0gdHJ1ZTtcclxuICAgIEZhdWNldFVybCA9ICcnO1xyXG4gICAgQnV5VXJsID0nJztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgYWRkTmV0d29ya1RvV2FsbGV0KG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIGNvbnN0IHdlYjMgPSBhd2FpdCBBdXRoZW50aWNhdGVTZXJ2aWNlLmVuYWJsZVdlYjMobW9yYWxpcyk7XHJcbiAgICAgICAgaWYgKCF3ZWIzIHx8ICF3ZWIzLnByb3ZpZGVyLnJlcXVlc3QpIHJldHVybjtcclxuXHJcbiAgICAgICAgd2ViMy5wcm92aWRlci5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgbWV0aG9kOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxyXG4gICAgICAgICAgICBwYXJhbXM6IFt7XHJcbiAgICAgICAgICAgICAgICBjaGFpbklkOiAnMHgnICsgdGhpcy5DaGFpbklkLnRvU3RyaW5nKDE2KSxcclxuICAgICAgICAgICAgICAgIGNoYWluTmFtZTogdGhpcy5DaGFpbk5hbWUsXHJcbiAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeToge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuTmF0aXZlQ3VycmVuY3lOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdGhpcy5OYXRpdmVTeW1ib2wsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHM6IHRoaXMuTmF0aXZlRGVjaW1hbFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJwY1VybHM6IFt0aGlzLlJwY1VybF0sXHJcbiAgICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsczogW3RoaXMuQmxvY2tFeHBsb3Jlcl1cclxuICAgICAgICAgICAgfV1cclxuICAgICAgICB9KS5jYXRjaCgoZXJyb3I6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBoYXNFbm91Z2hOYXRpdmVUb2tlbnMobW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzKSA6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIC8vVE9ETzogcmVtb3ZlIGxhdGVyLCBNb3JhbGlzIGRvZXNudCBzdXBwb3J0IGdldE5hdGl2ZUJhbGFuY2Ugb24gbG9jYWxob3N0IHNvIGl0J3MgYWx3YXlzIHRydWVcclxuICAgICAgICBpZiAodGhpcy5OYW1lID09ICdsb2NhbGhvc3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnM6IGFueSA9IHtjaGFpbjogJzB4JyArIHRoaXMuQ2hhaW5JZC50b1N0cmluZygxNil9O1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtb3JhbGlzLldlYjNBUEkuYWNjb3VudC5nZXROYXRpdmVCYWxhbmNlKG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHBhcnNlRmxvYXQoTW9yYWxpcy5Vbml0cy5Gcm9tV2VpKHJlc3VsdC5iYWxhbmNlLCAxOCkpO1xyXG4gICAgICAgICAgICBpZiAoYmFsYW5jZSA8IDAuMDA1KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxufVxyXG5cclxuIiwiaW1wb3J0IE5ldHdvcmsgZnJvbSBcIi4vTmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGVzdE5ldHdvcmsgZXh0ZW5kcyBOZXR3b3JrIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhvc3QuaW5kZXhPZignbG9jYWxob3N0JykgPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5TZXJ2ZXJVcmwgPSBcImh0dHBzOi8vZjh0MXZycnd0Ym9hLnVzZW1vcmFsaXMuY29tOjIwNTMvc2VydmVyXCI7XHJcbiAgICAgICAgICAgIHRoaXMuQXBwSWQgPSBcIlhaaHAzd1FvYnJLaUNpYjBCZjRGUFZLQVVoYkhNOVN2VExLT0t2QmJcIjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLlNlcnZlclVybCA9IFwiaHR0cHM6Ly9wa2tlbmhsN3N5bnMuZ3JhbmRtb3JhbGlzLmNvbToyMDUzL3NlcnZlclwiO1xyXG4gICAgICAgICAgICB0aGlzLkFwcElkID0gXCJRcFNoRDRWWVFUNk43ZXZjMnZNdTNWdEVLU0VHalFQU2J1Sk5obElxXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuVGVzdE5ldHdvcmsgPSB0cnVlO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE5ldHdvcmsgZnJvbSAnLi9OZXR3b3JrJztcclxuaW1wb3J0IFRlc3ROZXR3b3JrIGZyb20gXCIuL1Rlc3ROZXR3b3JrXCI7XHJcbi8vbG9jYWxob3N0XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGxvY2FsaG9zdE5ldHdvcmsgZXh0ZW5kcyBUZXN0TmV0d29yayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLkNoYWluSWQgPSAzMTMzNztcclxuICAgICAgICB0aGlzLk5hbWUgPSBcImxvY2FsaG9zdFwiO1xyXG4gICAgICAgIHRoaXMuQ2hhaW5OYW1lID0gJ2xvY2FsaG9zdCB0ZXN0JztcclxuICAgICAgICB0aGlzLk5hdGl2ZUN1cnJlbmN5TmFtZSA9IFwiRXRoZXJldW1cIjtcclxuICAgICAgICB0aGlzLk5hdGl2ZVN5bWJvbCA9IFwiRVRIXCI7XHJcbiAgICAgICAgdGhpcy5OYXRpdmVEZWNpbWFsID0gMTg7XHJcbiAgICAgICAgdGhpcy5ScGNVcmwgPSAnaHR0cHM6Ly9yaW5rZWJ5LmluZnVyYS5pby8nO1xyXG4gICAgICAgIHRoaXMuQmxvY2tFeHBsb3JlciA9ICdodHRwczovL3JpbmtlYnkuZXRoZXJzY2FuLmlvJztcclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG59XHJcblxyXG4iLCJcclxuXHJcbmltcG9ydCBOZXR3b3JrIGZyb20gJy4vTmV0d29yayc7XHJcbmltcG9ydCBUZXN0TmV0d29yayBmcm9tIFwiLi9UZXN0TmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgbXVtYmFpTmV0d29yayBleHRlbmRzIFRlc3ROZXR3b3JrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuQ2hhaW5JZCA9IDgwMDAxO1xyXG4gICAgICAgIHRoaXMuTmFtZSA9IFwibXVtYmFpXCI7XHJcbiAgICAgICAgdGhpcy5DaGFpbk5hbWUgPSAnUG9seWdvbiBNdW1iYWknO1xyXG4gICAgICAgIHRoaXMuTmF0aXZlQ3VycmVuY3lOYW1lID0gXCJNYXRpY1wiO1xyXG4gICAgICAgIHRoaXMuTmF0aXZlU3ltYm9sID0gXCJNQVRJQ1wiO1xyXG4gICAgICAgIHRoaXMuTmF0aXZlRGVjaW1hbCA9IDE4O1xyXG4gICAgICAgIHRoaXMuUnBjVXJsID0gJ2h0dHBzOi8vbWF0aWMtbXVtYmFpLmNoYWluc3RhY2tsYWJzLmNvbS8nO1xyXG4gICAgICAgICAgICB0aGlzLkJsb2NrRXhwbG9yZXIgPSAnaHR0cHM6Ly9tdW1iYWkucG9seWdvbnNjYW4uY29tLyc7XHJcbiAgICAgICAgICAgIHRoaXMuRmF1Y2V0VXJsID0gJ2h0dHBzOi8vZmF1Y2V0LnBvbHlnb24udGVjaG5vbG9neS8nO1xyXG4gICAgICAgICAgICB0aGlzLkJ1eVVybCA9ICdodHRwczovL3d3dy5tb29ucGF5LmNvbS9idXkvbWF0aWMnO1xyXG5cdH1cclxuXHJcblxyXG5cclxufVxyXG5cclxuIiwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb29raWVIZWxwZXIge1xyXG4gICAgZG9jdW1lbnQ6IERvY3VtZW50XHJcblxyXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQ6IERvY3VtZW50KSB7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRDb29raWUobmFtZSA6IHN0cmluZywgdmFsdWUgOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5kZWxldGVDb29raWUobmFtZSk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudC5jb29raWUgPSBuYW1lICsgXCI9XCIgKyB2YWx1ZSArIFwiOyBleHBpcmVzPU1vbiwgMiBEZWMgXCIgKyAoZGF0ZS5nZXRGdWxsWWVhcigpICsgMSkgKyBcIiAxMjowMDowMCBVVEM7cGF0aD0vO1NhbWVTaXRlPVN0cmljdFwiO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDb29raWVWYWx1ZShuYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jb29raWUubWF0Y2goJyhefDspXFxcXHMqJyArIG5hbWUgKyAnXFxcXHMqPVxcXFxzKihbXjtdKyknKT8ucG9wKCkgfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldENvb2tpZVByb3ZpZGVyKHByb3ZpZGVyTmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICB0aGlzLnNldENvb2tpZShcInByb3ZpZGVyXCIsIHByb3ZpZGVyTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZUNvb2tpZShuYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyBcIj0wOyBleHBpcmVzPU1vbiwgMiBEZWMgMjAyMCAxMjowMDowMCBVVEM7cGF0aD0vXCI7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgTmV0d29yayBmcm9tIFwiLi9OZXR3b3JrXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluTmV0d29yayBleHRlbmRzIE5ldHdvcmsge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMuU2VydmVyVXJsID0gXCJodHRwczovL3Jva2lud2djdGhxeS5ncmFuZG1vcmFsaXMuY29tOjIwNTMvc2VydmVyXCI7XHJcbiAgICAgICAgdGhpcy5BcHBJZCA9IFwiRnFKeGZwOXhuZzFTYm92T1RvUjJmbkZqbkJKanUyS282N25tVGZGRlwiO1xyXG4gICAgICAgIHRoaXMuVGVzdE5ldHdvcmsgPSBmYWxzZTtcclxuICAgIH1cclxufSIsImltcG9ydCBOZXR3b3JrIGZyb20gJy4vTmV0d29yayc7XHJcbmltcG9ydCBNYWluTmV0d29yayBmcm9tIFwiLi9NYWluTmV0d29ya1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgcG9seWdvbk5ldHdvcmsgZXh0ZW5kcyBNYWluTmV0d29yayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLkNoYWluSWQgPSAxMzc7XHJcbiAgICAgICAgdGhpcy5OYW1lID0gXCJwb2x5Z29uXCI7XHJcbiAgICAgICAgdGhpcy5DaGFpbk5hbWUgPSAnUG9seWdvbiBNYWlubmV0JztcclxuICAgICAgICB0aGlzLk5hdGl2ZUN1cnJlbmN5TmFtZSA9IFwiTWF0aWNcIjtcclxuICAgICAgICB0aGlzLk5hdGl2ZVN5bWJvbCA9IFwiTUFUSUNcIjtcclxuICAgICAgICB0aGlzLk5hdGl2ZURlY2ltYWwgPSAxODtcclxuICAgICAgICB0aGlzLlJwY1VybCA9ICdodHRwczovL3BvbHlnb24tcnBjLmNvbS8nO1xyXG4gICAgICAgIHRoaXMuQmxvY2tFeHBsb3JlciA9ICdodHRwczovL3BvbHlnb25zY2FuLmNvbS8nO1xyXG4gICAgICAgIHRoaXMuRmF1Y2V0VXJsID0gJ2h0dHBzOi8vZmF1Y2V0LnBvbHlnb24udGVjaG5vbG9neS8nO1xyXG4gICAgICAgIHRoaXMuQnV5VXJsID0gJ2h0dHBzOi8vd3d3Lm1vb25wYXkuY29tL2J1eS9tYXRpYyc7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuIiwiaW1wb3J0IGxvY2FsaG9zdE5ldHdvcmsgZnJvbSAnLi9sb2NhbGhvc3QtbmV0d29yayc7XHJcbmltcG9ydCBtdW1iYWlOZXR3b3JrIGZyb20gJy4vbXVtYmFpLW5ldHdvcmsnO1xyXG5pbXBvcnQgTmV0d29yayBmcm9tIFwiLi9OZXR3b3JrXCI7XHJcbmltcG9ydCBDb29raWVIZWxwZXIgZnJvbSBcIi4uL3V0aWwvQ29va2llSGVscGVyXCI7XHJcbmltcG9ydCBNb3JhbGlzIGZyb20gXCJtb3JhbGlzXCI7XHJcbmltcG9ydCBwb2x5Z29uTmV0d29yayBmcm9tIFwiLi9wb2x5Z29uLW5ldHdvcmtcIjtcclxuaW1wb3J0IHtOZXR3b3JrVHlwZX0gZnJvbSBcIi4vTmV0d29ya1R5cGVcIjtcclxuXHJcblxyXG5jb25zdCBuZXR3b3JrSW5mb3MgPSBbbG9jYWxob3N0TmV0d29yaywgbXVtYmFpTmV0d29yaywgcG9seWdvbk5ldHdvcmtdO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5ldHdvcmtJbmZvIHtcclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBOZXR3b3JrO1xyXG4gICAgbW9yYWxpczogdHlwZW9mIE1vcmFsaXM7XHJcblxyXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBOZXR3b3JrIHtcclxuICAgICAgICBpZiAoTmV0d29ya0luZm8uaW5zdGFuY2UpIHJldHVybiBOZXR3b3JrSW5mby5pbnN0YW5jZTtcclxuXHJcbiAgICAgICAgTmV0d29ya0luZm8uaW5zdGFuY2UgPSB0aGlzLmdldE5ldHdvcmtJbmZvKCk7XHJcbiAgICAgICAgcmV0dXJuIE5ldHdvcmtJbmZvLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgbG9hZE5ldHdvcmsobmV0d29ya05hbWU6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIE5ldHdvcmtJbmZvLmluc3RhbmNlID0gdGhpcy5nZXROZXR3b3JrSW5mbyhuZXR3b3JrTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzZXROZXR3b3JrQnlDaGFpbklkKGNoYWluSWQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5nZXROZXR3b3JrSW5mb0J5Q2hhaW5JZChjaGFpbklkKTtcclxuICAgICAgICBpZiAobmV0d29yaykge1xyXG4gICAgICAgICAgICBOZXR3b3JrSW5mby5pbnN0YW5jZSA9IG5ldHdvcms7XHJcblxyXG4gICAgICAgICAgICBsZXQgY29va2llSGVscGVyID0gbmV3IENvb2tpZUhlbHBlcihkb2N1bWVudCk7XHJcbiAgICAgICAgICAgIGNvb2tpZUhlbHBlci5zZXRDb29raWUoJ25ldHdvcmsnLCBuZXR3b3JrLk5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldE5ldHdvcmtzKG5ldHdvcmtUeXBlPyA6IG51bWJlcik6IEFycmF5PE5ldHdvcms+IHtcclxuICAgICAgICBsZXQgbmV0d29ya3MgPSBuZXcgQXJyYXk8TmV0d29yaz4oKTtcclxuICAgICAgICBsZXQgaXNMb2NhbGhvc3QgPSB3aW5kb3cubG9jYXRpb24uaG9zdC5pbmRleE9mKCdsb2NhbGhvc3QnKSAhPSAtMTtcclxuICAgICAgICBuZXR3b3JrSW5mb3MuZm9yRWFjaChuZXR3b3JrSW5mb1R5cGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdG1wID0gbmV3IG5ldHdvcmtJbmZvVHlwZSgpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTG9jYWxob3N0ICYmIHRtcC5OYW1lID09IFwibG9jYWxob3N0XCIpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrVHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3Jrcy5wdXNoKHRtcCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggbmV0d29ya1R5cGUpXHJcbiAgICAgICAgICAgICAgICBpZiAobmV0d29ya1R5cGUgPT0gTmV0d29ya1R5cGUuTWFpbm5ldCAmJiAhdG1wLlRlc3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya3MucHVzaCh0bXApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuZXR3b3JrVHlwZSA9PSBOZXR3b3JrVHlwZS5UZXN0bmV0ICYmIHRtcC5UZXN0TmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcmtzLnB1c2godG1wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXR3b3JrcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldE5ldHdvcmtJbmZvQnlDaGFpbklkKGNoYWluSWQ6IG51bWJlcik6IE5ldHdvcmsgfCB1bmRlZmluZWQge1xyXG5cclxuICAgICAgICBsZXQgbmV0d29ya0luZm86IE5ldHdvcmsgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIG5ldHdvcmtJbmZvcy5mb3JFYWNoKG5ldHdvcmtJbmZvVHlwZSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0bXAgPSBuZXcgbmV0d29ya0luZm9UeXBlKCk7XHJcbiAgICAgICAgICAgIGlmICh0bXAuQ2hhaW5JZCA9PSBjaGFpbklkKSB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrSW5mbyA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXR3b3JrSW5mbztcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0TmV0d29ya0luZm8obmV0d29ya05hbWU/OiBzdHJpbmcpOiBOZXR3b3JrIHtcclxuICAgICAgICBsZXQgY29va2llSGVscGVyID0gbmV3IENvb2tpZUhlbHBlcihkb2N1bWVudCk7XHJcblxyXG4gICAgICAgIGlmICghbmV0d29ya05hbWUpIG5ldHdvcmtOYW1lID0gY29va2llSGVscGVyLmdldENvb2tpZVZhbHVlKCduZXR3b3JrJyk7XHJcbiAgICAgICAgaWYgKCFuZXR3b3JrTmFtZSkgbmV0d29ya05hbWUgPSAncG9seWdvbic7XHJcblxyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IG51bGw7XHJcbiAgICAgICAgbmV0d29ya0luZm9zLmZvckVhY2gobmV0d29ya0luZm9UeXBlID0+IHtcclxuICAgICAgICAgICAgbGV0IHRtcCA9IG5ldyBuZXR3b3JrSW5mb1R5cGUoKTtcclxuICAgICAgICAgICAgaWYgKHRtcC5OYW1lID09IG5ldHdvcmtOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBuZXR3b3JrSW5mbyA9IHRtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChuZXR3b3JrSW5mbykgcmV0dXJuIG5ldHdvcmtJbmZvO1xyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKFwiTmV0d29yayAnXCIgKyBuZXR3b3JrTmFtZSArIFwiJyBjb3VsZCBub3QgYmUgZm91bmQuIERlZmF1bHRpbmcgdG8gUG9seWdvbiBuZXR3b3JrLlwiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBwb2x5Z29uTmV0d29yaygpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbm5lY3Rpb25TZXJ2aWNlIHtcclxuICAgIG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcztcclxuICAgIG9wdGlvbnMgOiB7c2VydmVyVXJsOnN0cmluZywgYXBwSWQ6c3RyaW5nfTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge3NlcnZlclVybDogJycsIGFwcElkOiAnJ307XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBnZXRPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IE5ldHdvcmtJbmZvLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge3NlcnZlclVybDogbmV0d29ya0luZm8uU2VydmVyVXJsLCBhcHBJZDogbmV0d29ya0luZm8uQXBwSWR9O1xyXG5cclxuICAgICAgICBhd2FpdCB0aGlzLm1vcmFsaXMuc3RhcnQodGhpcy5vcHRpb25zKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKCdJbnZhbGlkIHNlc3Npb24gdG9rZW4nKSAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgTW9yYWxpcy5Vc2VyLmxvZ091dCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgc2Vzc2lvbiB0b2tlbicpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufSIsImltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi9Db250cmFjdEFkZHJlc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgbG9jYWxob3N0Q29udHJhY3RBZGRyZXNzZXMgaW1wbGVtZW50cyBDb250cmFjdEFkZHJlc3NlcyB7XHJcblxyXG4gICAgS1lDX0FERFJFU1MgPSBcIjB4MTcyQTlEQTMyOEJDNzFmNDM1NGY0ZjE3RGI1NjMwNTUyY0M5NDIwZFwiO1xyXG4gICAgQVVTRF9BRERSRVNTID0gXCIweENkNDBhZTc2NDhFNTNCOTJlMzM4Q0NhQUY3ODczNDM5N0QyRmUyQTRcIjtcclxuICAgIExJTUlOQUxfTUFSS0VUX0FERFJFU1MgPSBcIjB4NTRlYjRmQTQ4MmQ1MGUwMzY5RDMzMzE5M0RlODA0ODk4MzE3QTJBNVwiO1xyXG4gICAgTUFSS0VUX0NBTEVOREFSX0FERFJFU1MgPSBcIjB4RjVBMzk2NjBBODk0Njk4MDc0NTkzQTVCMWZCZDMzNjk3ZENhNDA5MVwiO1xyXG5cclxufSIsImltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi9Db250cmFjdEFkZHJlc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgbXVtYmFpQ29udHJhY3RBZGRyZXNzZXMgaW1wbGVtZW50cyBDb250cmFjdEFkZHJlc3NlcyB7XHJcblxyXG4gICAgS1lDX0FERFJFU1MgPSBcIjB4OWUyQjI4RDlGODQxMzAwYkUzQjY0ZTUwNWRFY0EzNmMzNTI1MDYwOVwiO1xyXG4gICAgQVVTRF9BRERSRVNTID0gXCIweDM4RjJCMUU5RjExOTM3ZEQyNzZENjQ1MjE1MzViMTUyODBBN0YxMzdcIjtcclxuICAgIExJTUlOQUxfTUFSS0VUX0FERFJFU1MgPSBcIjB4NmU5QzI5ZTQxNmRjOUY3QTZBMDNmZmViYUIzZjAyRWY2MmExYmFFNFwiO1xyXG4gICAgTUFSS0VUX0NBTEVOREFSX0FERFJFU1MgPSBcIjB4YzZCMjlkZmQ0RkQ3NTZFRjk0YjNBM0ZGN2E1MzFGNDQ2N0JEREE3NVwiO1xyXG5cclxufSIsImltcG9ydCBDb250cmFjdEFkZHJlc3NlcyBmcm9tIFwiLi9Db250cmFjdEFkZHJlc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZnVqaUNvbnRyYWN0QWRkcmVzc2VzIGltcGxlbWVudHMgQ29udHJhY3RBZGRyZXNzZXMge1xyXG5cclxuICAgIEtZQ19BRERSRVNTID0gXCIweDA1OTREMDRGREI1Qzk4RmI3Rjc3N2E3OTkxMzk0MjRBZTI0MTRBYURcIjtcclxuICAgIEFVU0RfQUREUkVTUyA9IFwiMHhiQWM0ODJhRTBiMGQ2NTI4NTRkZjM3N2JlNTY2NDQ1OTg0QTAyMUVEXCI7XHJcbiAgICBMSU1JTkFMX01BUktFVF9BRERSRVNTID0gXCIweDA5OEE1MTJCMDE3NDA4MDA4YTIzRUNlMjI4NDM3ODg3OTlDRGViRmRcIjtcclxuICAgIE1BUktFVF9DQUxFTkRBUl9BRERSRVNTID0gXCIweDc3RTZBNjJCZTgzOThCMThkMmRBODFDREI2RWIwOTdiRDgxMzJjY0JcIjtcclxuXHJcbn0iLCJpbXBvcnQgQ29udHJhY3RBZGRyZXNzZXMgZnJvbSBcIi4vQ29udHJhY3RBZGRyZXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHBvbHlnb25Db250cmFjdEFkZHJlc3NlcyBpbXBsZW1lbnRzIENvbnRyYWN0QWRkcmVzc2VzIHtcclxuXHJcbiAgICBLWUNfQUREUkVTUyA9IFwiMHhjN2RBOThFMjgyY2MzMEJENGZlMGE3ZEUzODM3MkY4NzZEQjU3N0U0XCI7XHJcbiAgICBBVVNEX0FERFJFU1MgPSBcIjB4OUI3ODBlNzFDMmE4NDkyRTgwNWUxNzYxNkVCODc4ZjJlMzg3NEUyMVwiO1xyXG4gICAgTElNSU5BTF9NQVJLRVRfQUREUkVTUyA9IFwiMHg4QjRmYzBiY2FFRDc2YTY1Njk1MjVkOEZlNTFFNTdjQWQzMkZEZDk0XCI7XHJcbiAgICBNQVJLRVRfQ0FMRU5EQVJfQUREUkVTUyA9IFwiMHg3N2I1NENiRjNlMTM3MGFmMTNkYTQxMTk2QjRkOTljZDAyZUJjQzQ0XCI7XHJcblxyXG59IiwiaW1wb3J0IGxvY2FsaG9zdENvbnRyYWN0QWRkcmVzc2VzIGZyb20gJy4vbG9jYWxob3N0LWNvbnRyYWN0LWFkZHJlc3Nlcyc7XHJcbmltcG9ydCBtdW1iYWlDb250cmFjdEFkZHJlc3NlcyBmcm9tICcuL211bWJhaS1jb250cmFjdC1hZGRyZXNzZXMnO1xyXG5pbXBvcnQgZnVqaUNvbnRyYWN0QWRkcmVzc2VzIGZyb20gJy4vZnVqaS1jb250cmFjdC1hZGRyZXNzZXMnO1xyXG5pbXBvcnQgQ29udHJhY3RBZGRyZXNzZXMgZnJvbSBcIi4vQ29udHJhY3RBZGRyZXNzZXNcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgcG9seWdvbkNvbnRyYWN0QWRkcmVzc2VzIGZyb20gXCIuL3BvbHlnb24tY29udHJhY3QtYWRkcmVzc2VzXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udHJhY3RJbmZvIHtcclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRDb250cmFjdEluZm8obmV0d29ya05hbWU/OiBzdHJpbmcpOiBDb250cmFjdEFkZHJlc3NlcyB7XHJcbiAgICAgICAgbGV0IGNvbnRyYWN0SW5mb3M6IGFueSA9IHtcclxuICAgICAgICAgICAgbG9jYWxob3N0Q29udHJhY3RBZGRyZXNzZXMsIG11bWJhaUNvbnRyYWN0QWRkcmVzc2VzLCBmdWppQ29udHJhY3RBZGRyZXNzZXMsXHJcbiAgICAgICAgICAgIHBvbHlnb25Db250cmFjdEFkZHJlc3Nlc1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmICghbmV0d29ya05hbWUpIHtcclxuICAgICAgICAgICAgbmV0d29ya05hbWUgPSBOZXR3b3JrSW5mby5nZXRJbnN0YW5jZSgpLk5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRyYWN0SW5mb1R5cGUgPSBjb250cmFjdEluZm9zW25ldHdvcmtOYW1lICsgJ0NvbnRyYWN0QWRkcmVzc2VzJ107XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb250cmFjdEluZm9UeXBlKCk7XHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJleHBvcnQgZW51bSBJbmZvQmFyVHlwZSB7XHJcbiAgICBJbmZvID0gJ2luZm9CYXInLFxyXG4gICAgV2FybmluZyA9ICd3YXJuaW5nQmFyJyxcclxuICAgIEVycm9yID0gJ2Vycm9yQmFyJ1xyXG59IiwiaW1wb3J0IHtJbmZvQmFyVHlwZX0gZnJvbSBcIi4vSW5mb0JhclR5cGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZm9CYXIge1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgc2hvdyhtZXNzYWdlIDogc3RyaW5nLCB0eXBlIDogSW5mb0JhclR5cGUsIHRpbWVvdXRJblNlY29uZHMgOiBudW1iZXIgPSA0KSB7XHJcbiAgICAgICAgbGV0IGluZm9CYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5mb0JhcicpO1xyXG4gICAgICAgIGlmICghaW5mb0Jhcikge1xyXG4gICAgICAgICAgICBpbmZvQmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGluZm9CYXIuY2xhc3NMaXN0LmFkZCgnbm90aWZpY2F0aW9uQmFyJyk7XHJcbiAgICAgICAgICAgIGluZm9CYXIuaWQgPSAnaW5mb0Jhcic7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmJlZ2luJywgaW5mb0Jhcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbmZvQmFyLmlubmVySFRNTCA9IG1lc3NhZ2U7XHJcbiAgICAgICAgaW5mb0Jhci5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICBpbmZvQmFyLmNsYXNzTGlzdC5yZW1vdmUoSW5mb0JhclR5cGUuSW5mbyk7XHJcbiAgICAgICAgaW5mb0Jhci5jbGFzc0xpc3QucmVtb3ZlKEluZm9CYXJUeXBlLldhcm5pbmcpO1xyXG4gICAgICAgIGluZm9CYXIuY2xhc3NMaXN0LnJlbW92ZShJbmZvQmFyVHlwZS5FcnJvcik7XHJcbiAgICAgICAgaW5mb0Jhci5jbGFzc0xpc3QuYWRkKHR5cGUpXHJcbiAgICAgICAgaWYgKHRpbWVvdXRJblNlY29uZHMgPiAwKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW5mb0Jhcj8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIH0sIHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJcXHJcXG5Zb3UgbmVlZCB0byBzZXQgdXAgYSB3YWxsZXQgaW4geW91ciBicm93c2VyIGJlZm9yZSB5b3UgY2FuIHVzZSBsaW1pbmFsLm1hcmtldC5cXHJcXG48YnIvPjxici8+XFxyXFxuVG8gbWFrZSBpdCBzaW1wbGUsIHdlIHdvdWxkIGxpa2UgdG8gc3VnZ2VzdCB0d28gb3B0aW9ucy4gSW4geW91ciBicm93c2VyIG9yIHlvdXIgcGhvbmUuXFxyXFxuPHVsPlxcclxcbiAgICA8bGk+Rm9yIHRoZSBicm93c2VyIHdlIHJlY29tbWVuZCA8YSBocmVmPVxcXCJodHRwczovL21ldGFtYXNrLmlvL2Rvd25sb2FkL1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPk1ldGFtYXNrPC9hPi5cXHJcXG4gICAgPC9saT5cXHJcXG4gICAgPGxpPlxcclxcbiAgICAgICAgRm9yIHlvdXIgcGhvbmUsIHdlIGxpa2UgPGEgaHJlZj1cXFwiaHR0cHM6Ly93d3cudG9rZW5wb2NrZXQucHJvL2VuL2Rvd25sb2FkL2FwcFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPlRva2VuIFBva2V0PC9hPlxcclxcbiAgICA8L2xpPlxcclxcbjwvdWw+XFxyXFxuPGJyLz5cXHJcXG5CdXQsIHlvdSBoYXZlIDxhIGhyZWY9XFxcImh0dHBzOi8vZXRoZXJldW0ub3JnL2VuL3dhbGxldHMvXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCI+bWFueSBvcHRpb25zPC9hPiBpZiB5b3Ugd2FudCB0byBsZWFybiBtb3JlLlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgSW5mb0JhciBmcm9tIFwiLi4vdWkvZWxlbWVudHMvSW5mb0JhclwiO1xyXG5pbXBvcnQge0luZm9CYXJUeXBlfSBmcm9tIFwiLi4vdWkvZWxlbWVudHMvSW5mb0JhclR5cGVcIjtcclxuaW1wb3J0IFdhbGxldE1pc3NpbmdIdG1sIGZyb20gJy4uL2h0bWwvbW9kYWwvV2FsbGV0TWlzc2luZy5odG1sJztcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi91aS9tb2RhbHMvTW9kYWxcIjtcclxuaW1wb3J0IFN3aXRjaE5ldHdvcmtNb2RhbCBmcm9tIFwiLi4vdWkvbW9kYWxzL1N3aXRjaE5ldHdvcmtNb2RhbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlZGVmaW5lZEVycm9ySGFuZGxlcnMge1xyXG5cclxuICAgIGVycm9yTWVzc2FnZU1hcHBpbmcgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xyXG4gICAgU2VudExvZ2luUmVxdWVzdCA9IFwiV2UgaGF2ZSBzZW50IHJlcXVlc3QgdG8geW91IHdhbGxldCB0byBsb2dpbi4gT3BlbiB5b3VyIHdhbGxldCB0byBsb2dpblwiO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZU1hcHBpbmcuc2V0KCdjaGFpbiBub3Qgc3VwcG9ydGVkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGl2ID0gJ05ldHdvcmsgaXMgbm90IHN1cHBvcnRlZC4gPGEgaHJlZj1cIlwiIGlkPVwic3dpdGNoTmV0d29ya0xpbmtcIj5DbGljayBtZSB0byBzd2l0Y2ggdG8gc3VwcG9ydGVkIG5ldHdvcms8L2E+JztcclxuXHJcbiAgICAgICAgICAgIEluZm9CYXIuc2hvdyhkaXYsIEluZm9CYXJUeXBlLldhcm5pbmcsIDEyMClcclxuXHJcbiAgICAgICAgICAgIGxldCBzd2l0Y2hOZXR3b3JrTGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hOZXR3b3JrTGluaycpO1xyXG4gICAgICAgICAgICBzd2l0Y2hOZXR3b3JrTGluaz8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBTd2l0Y2hOZXR3b3JrTW9kYWwoTW9yYWxpcyk7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5zaG93KCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VNYXBwaW5nLnNldCgnYWxyZWFkeSBwcm9jZXNzaW5nIGV0aF9yZXF1ZXN0YWNjb3VudHMnLCB0aGlzLlNlbnRMb2dpblJlcXVlc3QpO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ3JlcXVlc3Qgb2YgdHlwZSBcXCd3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zXFwnIGFscmVhZHkgcGVuZGluZycsIHRoaXMuU2VudExvZ2luUmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VNYXBwaW5nLnNldCgnYWxyZWFkeSBoYXMgYmVlbiBjYWxsZWQsIGJ1dCBpcyBub3QgZmluaXNoZWQgeWV0JywgdGhpcy5TZW50TG9naW5SZXF1ZXN0KTtcclxuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZU1hcHBpbmcuc2V0KCdyZXF1ZXN0IGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MnLCB0aGlzLlNlbnRMb2dpblJlcXVlc3QpO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5zZXQoJ3dlYjMgaW5zdGFuY2UnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGltaW5hbF9tYXJrZXRfY29ubmVjdF93YWxsZXRcIik7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50c1swXS5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VNYXBwaW5nLnNldCgndXNlciByZWplY3RlZCB0aGUgcmVxdWVzdCcsICgpID0+IHtcclxuICAgICAgICAgICAgTW9yYWxpcy5Vc2VyLmxvZ091dCgpO1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2VNYXBwaW5nLnNldCgnTm9uIGV0aGVyZXVtIGVuYWJsZWQgYnJvd3NlcicsICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShXYWxsZXRNaXNzaW5nSHRtbCk7XHJcbiAgICAgICAgICAgIG1vZGFsLnNob3dNb2RhbCgnTmV3IHRvIGJsb2NrY2hhaW4/JywgdGVtcGxhdGUobnVsbCksIGZhbHNlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvL3dpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGFuZGxlKG1lc3NhZ2UgOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlTWFwcGluZy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghaGFuZGxlZCAmJiBtZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihrZXkudG9Mb3dlckNhc2UoKSkgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICBJbmZvQmFyLnNob3codmFsdWUudG9TdHJpbmcoKSwgSW5mb0JhclR5cGUuV2FybmluZywgMTApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZWQ7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgUHJlZGVmaW5lZEVycm9ySGFuZGxlcnMgZnJvbSBcIi4vUHJlZGVmaW5lZEVycm9ySGFuZGxlcnNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVycm9ySW5mbyB7XHJcblxyXG4gICAgZXJyb3JJbmZvOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZXJyb3JJbmZvOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmVycm9ySW5mbyA9IGVycm9ySW5mbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0RXJyb3JJbmZvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9ySW5mbztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlcG9ydChlcnJvcjogR2VuZXJhbEVycm9yKSB7XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgaWYgKCFlcnJvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgZXJyb3JIYW5kbGVyID0gbmV3IFByZWRlZmluZWRFcnJvckhhbmRsZXJzKCk7XHJcbiAgICAgICAgaWYgKGVycm9ySGFuZGxlci5oYW5kbGUoZXJyb3IubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGVycm9yLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIGVycm9yLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vSW5mb0Jhci5zaG93KGVycm9yLm1lc3NhZ2UsIEluZm9CYXJUeXBlLkVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGxvZyhvYmo6IGFueSkge1xyXG4gICAgICAgIEVycm9ySW5mby5yZXBvcnQobmV3IEdlbmVyYWxFcnJvcihvYmopKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGluZm8ob2JqOiBhbnkpIHtcclxuICAgICAgICBFcnJvckluZm8ucmVwb3J0KG5ldyBHZW5lcmFsRXJyb3Iob2JqKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBlcnJvcihvYmo6IGFueSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG9iaik7XHJcbiAgICAgICAgRXJyb3JJbmZvLnJlcG9ydChuZXcgR2VuZXJhbEVycm9yKG9iaikpO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBjbGFzcz1cXFwiY2VudGVyXFxcIj5cXHJcXG4gICAgVGhlIHN0b2NrIG1hcmtldCBpcyBjdXJyZW50bHkgY2xvc2VkLjxici8+XFxyXFxuSXQgaXMgdXN1YWxseSBvcGVuIG1vbmRheSB0byBmcmlkYXkgYmV0d2VlbiA5OjMwIEFNIGFuZCA0OjAwIFBNIEVTVCAoOTozMCAtIDE2OjAwIEVTVCkuXFxyXFxuICAgIDxici8+PGJyLz5cXHJcXG5Ub2RheSBpcyB7e2RheU9mV2Vla319XFxyXFxuPGJyIC8+PGJyLz5cXHJcXG5Zb3VyIGN1cnJlbnQgdGltZSBpcyB7e2N1cnJlbnRUaW1lfX0gKHt7R01UfX0pXFxyXFxuICAgIDxici8+PGJyLz5cXHJcXG5UaGF0IG1lYW5zIHRoZSBtYXJrZXQgaXMgb3BlbiB5b3VyIHRpbWUgYmV0d2Vlblxcclxcbnt7b3BlbkZyb219fSAtIHt7b3BlblRvfX1cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0ZUhlbHBlciB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBpc09sZGVyVGhlbihkYXRlIDogRGF0ZSwgbWludXRlcyA6IG51bWJlcikge1xyXG4gICAgICAgIGxldCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHJldHVybiAoY3VycmVudFRpbWUgPiAoZGF0ZS5nZXRUaW1lKCkgKyBtaW51dGVzICogNjAgKiAxMDAwKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0V2Vla2RheSgpIHtcclxuICAgICAgICBjb25zdCB3ZWVrZGF5ID0gW1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl07XHJcblxyXG4gICAgICAgIGNvbnN0IGQgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB3ZWVrZGF5W2QuZ2V0RGF5KCldO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0T3BlbkFuZENsb3NlSG91cnMoKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgIGxldCBvcGVuSG91ciA9IDkgKyA0ICsgKC0xICogKGQuZ2V0VGltZXpvbmVPZmZzZXQoKS82MCkpO1xyXG4gICAgICAgIGxldCBjbG9zZUhvdXIgPSAxNiArIDQgKyAoLTEgKiAoZC5nZXRUaW1lem9uZU9mZnNldCgpLzYwKSk7XHJcbiAgICAgICAgcmV0dXJuIFtvcGVuSG91ciArICc6MzAnLCBjbG9zZUhvdXIgKyAnOjAwJ11cclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgR2VuZXJhbEVycm9yIGZyb20gXCIuL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL3VpL21vZGFscy9Nb2RhbFwiO1xyXG5pbXBvcnQgTWFya2V0SXNDbG9zZWRIdG1sIGZyb20gXCIuLi9odG1sL21vZGFsL01hcmtldElzQ2xvc2VkLmh0bWxcIjtcclxuaW1wb3J0IERhdGVIZWxwZXIgZnJvbSBcIi4uL3V0aWwvRGF0ZUhlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmxvY2tjaGFpbkVycm9yIGV4dGVuZHMgR2VuZXJhbEVycm9yIHtcclxuICAgIHN0YXRpYyBFcnJvckZyb21Db250cmFjdCA9IC0xO1xyXG4gICAgc3RhdGljIFVzZXJDYW5jZWxsZWQgPSAxO1xyXG4gICAgc3RhdGljIEFkZHJlc3NJc05vdFZhbGlkS1lDID0gMjtcclxuICAgIHN0YXRpYyBNYXJrZXRJc0Nsb3NlZCA9IDM7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZSA6IGFueSkge1xyXG4gICAgICAgIHN1cGVyKGUpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGUudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMudXNlckRlbmllZFRyYW5zYWN0aW9uU2lnbmF0dXJlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2RlID0gQmxvY2tjaGFpbkVycm9yLlVzZXJDYW5jZWxsZWQ7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFkZHJlc3NJc05vdFZhbGlkS1lDKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2RlID0gQmxvY2tjaGFpbkVycm9yLkFkZHJlc3NJc05vdFZhbGlkS1lDO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc01hcmtldENsb3NlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29kZSA9IEJsb2NrY2hhaW5FcnJvci5NYXJrZXRJc0Nsb3NlZDtcclxuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IHRoaXMubWFya2V0SXNDbG9zZWRNb2RhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlLmRhdGEgJiYgZS5kYXRhLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgbGV0IG1zZyA6IHN0cmluZyA9IGUuZGF0YS5tZXNzYWdlO1xyXG4gICAgICAgICAgICBsZXQgc2VhcmNoU3RyID0gJ3JldmVydGVkIHdpdGggcmVhc29uIHN0cmluZyc7XHJcbiAgICAgICAgICAgIGxldCBpZHggPSBtc2cuaW5kZXhPZihzZWFyY2hTdHIpICsgc2VhcmNoU3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGlkeCAhPSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gbXNnLnN1YnN0cmluZyhpZHgpLnRyaW0oKS5yZXBsYWNlKC8nL2csICcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29kZSA9IEJsb2NrY2hhaW5FcnJvci5FcnJvckZyb21Db250cmFjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXNlckRlbmllZFRyYW5zYWN0aW9uU2lnbmF0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2UuaW5kZXhPZignZGVuaWVkIHRyYW5zYWN0aW9uIHNpZ25hdHVyZScpICE9PSAtMTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkcmVzc0lzTm90VmFsaWRLWUMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZS5pbmRleE9mKCdhZGRyZXNzIGlzIG5vdCBreWMgdmFsaWQnKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGlzTWFya2V0Q2xvc2VkKCkge1xyXG4gICAgICAgIGxldCBzZWFyY2hTdHIgPSAnTWFya2V0IGlzIGNsb3NlZCc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZS5pbmRleE9mKHNlYXJjaFN0cikgIT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtYXJrZXRJc0Nsb3NlZE1vZGFsKCkge1xyXG4gICAgICAgIGxldCBbb3BlbkhvdXIsIGNsb3NlSG91cl0gPSBEYXRlSGVscGVyLmdldE9wZW5BbmRDbG9zZUhvdXJzKCk7XHJcbiAgICAgICAgbGV0IHRpbWUgPSBuZXcgRGF0ZSgpLnRvVGltZVN0cmluZygpLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICAgICAgY3VycmVudFRpbWU6IHRpbWVbMF0sXHJcbiAgICAgICAgICAgIEdNVDogdGltZVsxXSxcclxuICAgICAgICAgICAgZGF5T2ZXZWVrIDogRGF0ZUhlbHBlci5nZXRXZWVrZGF5KCksXHJcbiAgICAgICAgICAgIG9wZW5Gcm9tIDogb3BlbkhvdXIsXHJcbiAgICAgICAgICAgIG9wZW5UbyA6IGNsb3NlSG91clxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKE1hcmtldElzQ2xvc2VkSHRtbCk7XHJcbiAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdNYXJrZXQgaXMgY2xvc2VkJywgdGVtcGxhdGUob2JqKSlcclxuICAgIH1cclxufSIsImltcG9ydCBFcnJvckluZm8gZnJvbSBcIi4uLy4uL2Vycm9ycy9FcnJvckluZm9cIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi4vLi4vZXJyb3JzL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBBdXRoZW50aWNhdGVTZXJ2aWNlIGZyb20gXCIuLi9iYWNrZW5kL0F1dGhlbnRpY2F0ZVNlcnZpY2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb2NrY2hhaW5TZXJ2aWNlIHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZXhlY3V0ZUZ1bmN0aW9uKG9wdGlvbnM6IGFueSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXRoZXJldW0gIT0gJ3VuZGVmaW5lZCcgJiYgZXRoZXJldW0gJiYgZXRoZXJldW0uY2hhaW5JZCkge1xyXG4gICAgICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBOZXR3b3JrSW5mby5nZXROZXR3b3JrSW5mb0J5Q2hhaW5JZChldGhlcmV1bS5jaGFpbklkKTtcclxuICAgICAgICAgICAgaWYgKCFuZXR3b3JrSW5mbykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcignY2hhaW4gbm90IHN1cHBvcnRlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLmV4ZWN1dGVGdW5jdGlvbihvcHRpb25zKVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IENvbnRyYWN0SW5mbyBmcm9tIFwiLi4vLi4vY29udHJhY3RzL0NvbnRyYWN0SW5mb1wiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBCbG9ja2NoYWluRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9CbG9ja2NoYWluRXJyb3JcIjtcclxuaW1wb3J0IEJsb2NrY2hhaW5TZXJ2aWNlIGZyb20gXCIuL0Jsb2NrY2hhaW5TZXJ2aWNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW1pbmFsTWFya2V0U2VydmljZSBleHRlbmRzIEJsb2NrY2hhaW5TZXJ2aWNlIHtcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBMaW1pbmFsTWFya2V0SW5mbzogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgc3VwZXIobW9yYWxpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2w6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0T3B0aW9ucyhcImdldFNlY3VyaXR5VG9rZW5cIiwge1xyXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbFxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBibG9ja2NoYWluRXJyb3IgPSBuZXcgQmxvY2tjaGFpbkVycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvckluZm8ucmVwb3J0KGJsb2NrY2hhaW5FcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgZ2V0T3B0aW9ucyhmdW5jdGlvbk5hbWU6IHN0cmluZywgcGFyYW1zOiBhbnkpIHtcclxuICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbygpO1xyXG4gICAgICAgIGxldCBhYmkgPSBhd2FpdCB0aGlzLmdldExpbWluYWxNYXJrZXRBYmkoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdEluZm8uTElNSU5BTF9NQVJLRVRfQUREUkVTUyxcclxuICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXHJcbiAgICAgICAgICAgIGFiaTogYWJpLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRMaW1pbmFsTWFya2V0QWJpKCkge1xyXG4gICAgICAgIGlmIChMaW1pbmFsTWFya2V0U2VydmljZS5MaW1pbmFsTWFya2V0SW5mbykgcmV0dXJuIExpbWluYWxNYXJrZXRTZXJ2aWNlLkxpbWluYWxNYXJrZXRJbmZvLmFiaTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy4uL2FiaS9MaW1pbmFsTWFya2V0Lmpzb24nKTtcclxuICAgICAgICBMaW1pbmFsTWFya2V0U2VydmljZS5MaW1pbmFsTWFya2V0SW5mbyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgICByZXR1cm4gTGltaW5hbE1hcmtldFNlcnZpY2UuTGltaW5hbE1hcmtldEluZm8uYWJpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBjcmVhdGVUb2tlbihzeW1ib2w6IHN0cmluZywgY3JlYXRpbmdUb2tlbiA6ICgpID0+IHZvaWQpOiBQcm9taXNlPHN0cmluZyB8IEJsb2NrY2hhaW5FcnJvcj4ge1xyXG4gICAgICAgIGxldCBzYWx0ID0gKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApKS50b1N0cmluZygpO1xyXG4gICAgICAgIHNhbHQgPSBzYWx0LnN1YnN0cmluZygwLCBzYWx0LmluZGV4T2YoJy4nKSk7XHJcbiAgICAgICAgY29uc3QgbGltaW5hbE9wdGlvbnMgPSBhd2FpdCB0aGlzLmdldE9wdGlvbnMoXCJjcmVhdGVUb2tlblwiLCB7XHJcbiAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sLFxyXG4gICAgICAgICAgICBzYWx0IDogc2FsdFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlRnVuY3Rpb24obGltaW5hbE9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0IGFzIHR5cGVvZiBFeGVjdXRlRnVuY3Rpb25DYWxsUmVzdWx0O1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrY2hhaW5FcnJvciA9IG5ldyBCbG9ja2NoYWluRXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIGlmIChibG9ja2NoYWluRXJyb3IudXNlckRlbmllZFRyYW5zYWN0aW9uU2lnbmF0dXJlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tjaGFpbkVycm9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3JJbmZvLnJlcG9ydChibG9ja2NoYWluRXJyb3IpO1xyXG5cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBCbG9ja2NoYWluRXJyb3IpIHJldHVybiByZXN1bHQ7XHJcblxyXG4gICAgICAgIGNyZWF0aW5nVG9rZW4oKTtcclxuICAgICAgICBhd2FpdCAocmVzdWx0IGFzIHR5cGVvZiBFeGVjdXRlRnVuY3Rpb25DYWxsUmVzdWx0KS53YWl0KCk7XHJcblxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG4gICAgfVxyXG5cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmlndXJlPlxcclxcbiAgICA8dGFibGUgaWQ9XFxcImxpbWluYWxfbWFya2V0X3NlY3VyaXRpZXNfdGFibGVcXFwiIHJvbGU9XFxcImdyaWRcXFwiPlxcclxcbiAgICA8dGhlYWQ+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0aCBjb2xzcGFuPVxcXCIyXFxcIj48aW5wdXQgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIHR5cGU9XFxcInNlYXJjaFxcXCIgaWQ9XFxcInNlYXJjaF9mb3Jfc3ltYm9sXFxcIiBwbGFjZWhvbGRlcj1cXFwiU2VhcmNoIGZvciBuYW1lIG9yIHN5bWJvbCBpbiB7e3NlY3VyaXRpZXNDb3VudH19IHN0b2Nrc1xcXCI+PC90aD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAgPC90aGVhZD5cXHJcXG4gICAgPHRib2R5IGlkPVxcXCJ7e3Rib2R5SWR9fVxcXCI+XFxyXFxuICAgIHt7PnNlY3VyaXRpZXN9fVxcclxcbiAgICA8L3Rib2R5PlxcclxcbjwvdGFibGU+XFxyXFxuPHNwYW4gaWQ9XFxcImxpbWluYWxfbWFya2V0X2xvYWRfbW9yZVxcXCI+PC9zcGFuPlxcclxcbjwvZmlndXJlPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJ7eyNlYWNoIHNlY3VyaXRpZXN9fVxcclxcbjx0ciBkYXRhLXN5bWJvbD1cXFwie3t7U3ltYm9sfX19XFxcIiBkYXRhLWxvZ289XFxcInt7TG9nb1BhdGh9fXt7TG9nb319XFxcIiBkYXRhLW5hbWU9XFxcInt7TmFtZX19XFxcIj5cXHJcXG4gICAgPHRkIGNsYXNzPVxcXCJzeW1ib2xfbG9nb1xcXCI+PGltZyBzcmM9XFxcInt7TG9nb1BhdGh9fXt7TG9nb319XFxcIi8+PC90ZD5cXHJcXG4gICAgPHRkIGNsYXNzPVxcXCJzZWN1cml0eV9pbmZvcm1hdGlvblxcXCI+XFxyXFxuICAgICAgICA8c3Ryb25nPnt7TmFtZX19PC9zdHJvbmc+PGJyLz5cXHJcXG4gICAgICAgIDxuYXYgY2xhc3M9XFxcInNlY3VyaXR5X2V4dHJhXFxcIj5cXHJcXG4gICAgICAgICAgICA8dWw+XFxyXFxuICAgICAgICAgICAgICAgIDxsaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcImh0dHBzOi8vc3RyaWtlLm1hcmtldC9zdG9ja3Mve3tTeW1ib2x9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPnt7U3ltYm9sfX08L2E+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGk+XFxyXFxuICAgICAgICAgICAgPC91bD5cXHJcXG4gICAgICAgICAgICA8dWw+XFxyXFxuICAgICAgICAgICAgICAgIDxsaT5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImdldEFkZHJlc3NcXFwiIGRhdGEtc3ltYm9sPVxcXCJ7e1N5bWJvbH19XFxcIj5HZXQgYWRkcmVzczwvYT5cXHJcXG4gICAgICAgICAgICAgICAgPC9saT5cXHJcXG4gICAgICAgICAgICA8L3VsPlxcclxcbiAgICAgICAgICAgIDx1bD5cXHJcXG4gICAgICAgICAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiXFxcIiBjbGFzcz1cXFwiYWRkVG9XYWxsZXRcXFwiIGRhdGEtc3ltYm9sPVxcXCJ7e1N5bWJvbH19XFxcIj5BZGQgdG8gd2FsbGV0PC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgICAgIDwvdWw+XFxyXFxuICAgICAgICA8L25hdj5cXHJcXG4gICAgPC90ZD5cXHJcXG48L3RyPlxcclxcbnt7L2VhY2h9fVwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBDb3B5SGVscGVyIHtcclxuXHJcbiAgICBwdWJsaWMgZmFsbGJhY2tDb3B5VGV4dFRvQ2xpcGJvYXJkKHRleHQgOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XHJcbiAgICAgICAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0O1xyXG5cclxuICAgICAgICAvLyBBdm9pZCBzY3JvbGxpbmcgdG8gYm90dG9tXHJcbiAgICAgICAgdGV4dEFyZWEuc3R5bGUudG9wID0gXCIwXCI7XHJcbiAgICAgICAgdGV4dEFyZWEuc3R5bGUubGVmdCA9IFwiMFwiO1xyXG4gICAgICAgIHRleHRBcmVhLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRBcmVhKTtcclxuICAgICAgICB0ZXh0QXJlYS5mb2N1cygpO1xyXG4gICAgICAgIHRleHRBcmVhLnNlbGVjdCgpO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgc3VjY2Vzc2Z1bCA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzZnVsO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRleHRBcmVhKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY29weVRleHRUb0NsaXBib2FyZCh0ZXh0IDogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZhbGxiYWNrQ29weVRleHRUb0NsaXBib2FyZCh0ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKGJsZSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdibGUnLCBibGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgICAgIH0pLlxyXG4gICAgICAgIGNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmluZm8oZXJyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YXJ0aWNsZSBpZD1cXFwic3ltYm9sSW5mb1RvQ29weVxcXCI+XFxyXFxuICAgIFRoaXMgaXMgdGhlIGFkZHJlc3MgZm9yIHRoZSBzeW1ib2wge3tzeW1ib2x9fS5cXHJcXG4gICAgPGJyLz5cXHJcXG4gICAgPGlucHV0IHZhbHVlPVxcXCJ7e2FkZHJlc3N9fVxcXCIvPlxcclxcbjwvYXJ0aWNsZT5cXHJcXG5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPHRyIGlkPVxcXCJzeW1ib2xJbmZvVG9Db3B5XFxcIj5cXHJcXG4gICAgPHRkIGNvbHNwYW49XFxcIjRcXFwiPlxcclxcbiAgICAgICAgPGFydGljbGU+XFxyXFxuICAgICAgICBUaGlzIHN5bWJvbCBoYXMgbmV2ZXIgYmVlbiBib3VnaHQgYW5kIGRvZXMgbm90IGV4aXN0LiBCdXkgdGhpcyBzeW1ib2wgYW5kIGFkZHJlc3Mgd2lsbCBiZWNvbWUgYXZhaWxhYmxlLlxcclxcbiAgICAgICAgPC9hcnRpY2xlPlxcclxcbiAgICA8L3RkPlxcclxcbjwvdHI+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjEuMFxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxudmFyXHJcbiAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuXHJcbiAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgQkFTRSA9IDFlMTQsXHJcbiAgTE9HX0JBU0UgPSAxNCxcclxuICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gIC8vIE1BWF9JTlQzMiA9IDB4N2ZmZmZmZmYsICAgICAgICAgICAgICAgICAgIC8vIDJeMzEgLSAxXHJcbiAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gIC8vIEVESVRBQkxFXHJcbiAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gIE1BWCA9IDFFOTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYX0lOVDMyXHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBCaWdOdW1iZXIsIHRvU3RyaW5nOiBudWxsLCB2YWx1ZU9mOiBudWxsIH0sXHJcbiAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgREVDSU1BTF9QTEFDRVMgPSAyMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAvLyBVUCAgICAgICAgIDAgQXdheSBmcm9tIHplcm8uXHJcbiAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgLy8gRkxPT1IgICAgICAzIFRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgIC8vIEhBTEZfRVZFTiAgNiBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyBldmVuIG5laWdoYm91ci5cclxuICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgUk9VTkRJTkdfTU9ERSA9IDQsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDhcclxuXHJcbiAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIE51bWJlciB0eXBlOiAtN1xyXG4gICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAvLyBOdW1iZXIgdHlwZTogMjFcclxuICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICBNQVhfRVhQID0gMWU3LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEgdG8gTUFYXHJcblxyXG4gICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgLy8gVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgIC8vXHJcbiAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgLy8gICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgLy8gSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgIC8vXHJcbiAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgIC8vIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgLy8gSWYgUE9XX1BSRUNJU0lPTiBpcyAwLCB0aGVyZSB3aWxsIGJlIHVubGltaXRlZCBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgRk9STUFUID0ge1xyXG4gICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICBzdWZmaXg6ICcnXHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgIC8vICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJ1xyXG4gICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuXHJcbiAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gIC8qXHJcbiAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogdiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIEJpZ051bWJlcih2LCBiKSB7XHJcbiAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgIC8vIEVuYWJsZSBjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgYG5ld2AuXHJcbiAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgaWYgKHYgJiYgdi5faXNCaWdOdW1iZXIgPT09IHRydWUpIHtcclxuICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpICYmIHYgKiAwID09IDApIHtcclxuXHJcbiAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLCB3aGVyZSBuIDwgMjE0NzQ4MzY0OCAoMioqMzEpLlxyXG4gICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgIGlmIChlID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG5cclxuICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgaWYgKGIgPT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgIC8vIEF2b2lkIHBvdGVudGlhbCBpbnRlcnByZXRhdGlvbiBvZiBJbmZpbml0eSBhbmQgTmFOIGFzIGJhc2UgNDQrIHZhbHVlcy5cclxuICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAodG9vTWFueURpZ2l0cyArIHYpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICBlID0gaSA9IDA7XHJcblxyXG4gICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmICcuJyBpcyBub3QgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXQgaGFzIG5vdCBiZSBmb3VuZCBiZWZvcmUuXHJcbiAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBBbGxvdyBlLmcuIGhleGFkZWNpbWFsICdGRicgYXMgd2VsbCBhcyAnZmYnLlxyXG4gICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgY2FzZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiBwYXJzZU51bWVyaWMoeCwgU3RyaW5nKHYpLCBpc051bSwgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmV2ZW50IGxhdGVyIGNoZWNrIGZvciBsZW5ndGggb24gY29udmVydGVkIG51bWJlci5cclxuICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgIGxlbiAtPSBpO1xyXG5cclxuICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgIGxlbiA+IDE1ICYmICh2ID4gTUFYX1NBRkVfSU5URUdFUiB8fCB2ICE9PSBtYXRoZmxvb3IodikpKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICBpZiAoaSkgeC5jLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBsZW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICB4LmMucHVzaCgrc3RyKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgQmlnTnVtYmVyLlJPVU5EX1VQID0gMDtcclxuICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gIEJpZ051bWJlci5ST1VORF9GTE9PUiA9IDM7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0VWRU4gPSA2O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICBCaWdOdW1iZXIuRVVDTElEID0gOTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICpcclxuICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgKlxyXG4gICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAqICAgRVhQT05FTlRJQUxfQVQgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggIG9yICBbLU1BWCB0byAwLCAwIHRvIE1BWF1cclxuICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICogICBNT0RVTE9fTU9ERSAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIDlcclxuICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3QgY29udGFpbiAnLicuXHJcbiAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAqICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAqICAgICBzdWZmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICpcclxuICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAqXHJcbiAgICogRS5nLlxyXG4gICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAqXHJcbiAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHByb3BlcnRpZXMgY3VycmVudCB2YWx1ZXMuXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICB2YXIgcCwgdjtcclxuXHJcbiAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgIC8vIERFQ0lNQUxfUExBQ0VTIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JPVU5ESU5HX01PREUnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgUk9VTkRJTkdfTU9ERSA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgIC8vIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRVhQT05FTlRJQUxfQVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIDAsIHApO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgVE9fRVhQX1BPUyA9IHZbMV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBUT19FWFBfTkVHID0gLShUT19FWFBfUE9TID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUkFOR0Uge251bWJlcnxudW1iZXJbXX0gTm9uLXplcm8gaW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdSQU5HRScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgLTEsIHApO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBDUllQVE8gbm90IHRydWUgb3IgZmFsc2U6IHt2fSdcclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ01PRFVMT19NT0RFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgIE1PRFVMT19NT0RFID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBQT1dfUFJFQ0lTSU9OIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRk9STUFUIHtvYmplY3R9XHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCBhbiBvYmplY3Q6ICcgKyB2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEFMUEhBQkVUIGludmFsaWQ6IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAvLyBEaXNhbGxvdyBpZiBsZXNzIHRoYW4gdHdvIGNoYXJhY3RlcnMsXHJcbiAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMgPSB2LnNsaWNlKDAsIDEwKSA9PSAnMDEyMzQ1Njc4OSc7XHJcbiAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAqXHJcbiAgICogdiB7YW55fVxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHZhciBpLCBuLFxyXG4gICAgICBjID0gdi5jLFxyXG4gICAgICBlID0gdi5lLFxyXG4gICAgICBzID0gdi5zO1xyXG5cclxuICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBFcnJvclxyXG4gICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAqL1xyXG4gIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgKi9cclxuICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBrID0gY1stLWldO1xyXG4gICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgIHJldHVybiByYW5kO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgIC8qXHJcbiAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgcmV0dXJuIHN1bTtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgLypcclxuICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgdmFyIGosXHJcbiAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgIGFyckwsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgLS1lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICB4YyA9IHguYztcclxuICAgICAgICByID0geC5yO1xyXG4gICAgICAgIGUgPSB4LmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgIHlMLCB5eixcclxuICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICpcclxuICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICBjMCA9IG4uY1swXTtcclxuICAgIG5lID0gbi5lO1xyXG5cclxuICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgIHZhciBuLFxyXG4gICAgICBpID0gMSxcclxuICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgbSA9IG47XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICBtID0gbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgdmFyIGkgPSAxLFxyXG4gICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAvLyBPdmVyZmxvdz9cclxuICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgIC8vIFVuZGVyZmxvdz9cclxuICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4uZSA9IGU7XHJcbiAgICAgIG4uYyA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG47XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBOYU5cclxuICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICBuaS0tO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAqL1xyXG4gIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5cclxuICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAqL1xyXG4gIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICpcclxuICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICB2YXIgYywgbiwgdixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuIC8gMCA9IElcclxuICAgKiAgbiAvIE4gPSBOXHJcbiAgICogIG4gLyBJID0gMFxyXG4gICAqICAwIC8gbiA9IDBcclxuICAgKiAgMCAvIDAgPSBOXHJcbiAgICogIDAgLyBOID0gTlxyXG4gICAqICAwIC8gSSA9IDBcclxuICAgKiAgTiAvIG4gPSBOXHJcbiAgICogIE4gLyAwID0gTlxyXG4gICAqICBOIC8gTiA9IE5cclxuICAgKiAgTiAvIEkgPSBOXHJcbiAgICogIEkgLyBuID0gSVxyXG4gICAqICBJIC8gMCA9IElcclxuICAgKiAgSSAvIE4gPSBOXHJcbiAgICogIEkgLyBJID0gTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAqL1xyXG4gIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgKlxyXG4gICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAqXHJcbiAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAqXHJcbiAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAqL1xyXG4gIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gMiAtIGlzT2RkKG4pIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICB9XHJcblxyXG4gICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICBpZiAobSkge1xyXG5cclxuICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgIH1cclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgaWYgKGspIHtcclxuICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgKi9cclxuICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiAtIDAgPSBuXHJcbiAgICogIG4gLSBOID0gTlxyXG4gICAqICBuIC0gSSA9IC1JXHJcbiAgICogIDAgLSBuID0gLW5cclxuICAgKiAgMCAtIDAgPSAwXHJcbiAgICogIDAgLSBOID0gTlxyXG4gICAqICAwIC0gSSA9IC1JXHJcbiAgICogIE4gLSBuID0gTlxyXG4gICAqICBOIC0gMCA9IE5cclxuICAgKiAgTiAtIE4gPSBOXHJcbiAgICogIE4gLSBJID0gTlxyXG4gICAqICBJIC0gbiA9IElcclxuICAgKiAgSSAtIDAgPSBJXHJcbiAgICogIEkgLSBOID0gTlxyXG4gICAqICBJIC0gSSA9IE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYSA9IHgucztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgIGIgPSB5LnM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgIHkucyA9IC1iO1xyXG4gICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgfVxyXG5cclxuICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICB0LnJldmVyc2UoKTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgIGlmICh4TFR5KSB0ID0geGMsIHhjID0geWMsIHljID0gdCwgeS5zID0gLXkucztcclxuXHJcbiAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAvLyBaZXJvP1xyXG4gICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBxLCBzLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgIHMgPSB5LnM7XHJcbiAgICAgIHkucyA9IDE7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgIHkucyA9IHM7XHJcbiAgICAgIHEucyAqPSBzO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICB9XHJcblxyXG4gICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgKi9cclxuICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeS5zICo9IHgucztcclxuICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICBpZiAoeGNMIDwgeWNMKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgYmFzZSA9IEJBU0U7XHJcbiAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICBjID0gMDtcclxuICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB6Y1tqXSA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGMpIHtcclxuICAgICAgKytlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAqL1xyXG4gIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICsgMCA9IG5cclxuICAgKiAgbiArIE4gPSBOXHJcbiAgICogIG4gKyBJID0gSVxyXG4gICAqICAwICsgbiA9IG5cclxuICAgKiAgMCArIDAgPSAwXHJcbiAgICogIDAgKyBOID0gTlxyXG4gICAqICAwICsgSSA9IElcclxuICAgKiAgTiArIG4gPSBOXHJcbiAgICogIE4gKyAwID0gTlxyXG4gICAqICBOICsgTiA9IE5cclxuICAgKiAgTiArIEkgPSBOXHJcbiAgICogIEkgKyBuID0gSVxyXG4gICAqICBJICsgMCA9IElcclxuICAgKiAgSSArIE4gPSBOXHJcbiAgICogIEkgKyBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYSA9IHgucztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgIGIgPSB5LnM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYztcclxuXHJcbiAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgfVxyXG5cclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYSkge1xyXG4gICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICArK3llO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAqXHJcbiAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgKi9cclxuICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICB2YXIgYywgbiwgdixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICByZXR1cm4gbjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAqXHJcbiAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICovXHJcbiAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICogIHNxcnQoTikgPSAgTlxyXG4gICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAqICBzcXJ0KDApID0gIDBcclxuICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAqL1xyXG4gIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBjID0geC5jLFxyXG4gICAgICBzID0geC5zLFxyXG4gICAgICBlID0geC5lLFxyXG4gICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgaWYgKHIuY1swXSkge1xyXG4gICAgICBlID0gci5lO1xyXG4gICAgICBzID0gZSArIGRwO1xyXG4gICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgIHQgPSByO1xyXG4gICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0+IDAuMDAxIChlLTMpLCBzbyBhZGp1c3QgcyBzbyB0aGUgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UocyAtIDMsIHMgKyAxKTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIGlmICh0LnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgcyArPSA0O1xyXG4gICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDEsIFJPVU5ESU5HX01PREUsIG0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFuZFxyXG4gICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKi9cclxuICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgZHArKztcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICBkcCA9IGRwICsgdGhpcy5lICsgMTtcclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgKlxyXG4gICAqIFRoZSBmb3JtYXR0aW5nIG9iamVjdCBtYXkgY29udGFpbiBzb21lIG9yIGFsbCBvZiB0aGUgcHJvcGVydGllcyBzaG93biBiZWxvdy5cclxuICAgKlxyXG4gICAqIEZPUk1BVCA9IHtcclxuICAgKiAgIHByZWZpeDogJycsXHJcbiAgICogICBncm91cFNpemU6IDMsXHJcbiAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICogICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICogICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAqICAgc3VmZml4OiAnJ1xyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqIFtmb3JtYXRdIHtvYmplY3R9IEZvcm1hdHRpbmcgb3B0aW9ucy4gU2VlIEZPUk1BVCBwYmplY3QgYWJvdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQgbm90IGFuIG9iamVjdDoge2Zvcm1hdH0nXHJcbiAgICovXHJcbiAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsICYmIHJtICYmIHR5cGVvZiBybSA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgfSBlbHNlIGlmIChkcCAmJiB0eXBlb2YgZHAgPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvcm1hdCAhPSAnb2JqZWN0Jykge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgIH1cclxuXHJcbiAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICBpZiAoeC5jKSB7XHJcbiAgICAgIHZhciBpLFxyXG4gICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgZzIgPSArZm9ybWF0LnNlY29uZGFyeUdyb3VwU2l6ZSxcclxuICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgIGZyYWN0aW9uUGFydCA9IGFyclsxXSxcclxuICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICBsZW4gPSBpbnREaWdpdHMubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKGcyKSBpID0gZzEsIGcxID0gZzIsIGcyID0gaSwgbGVuIC09IGk7XHJcblxyXG4gICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgaW50UGFydCA9IGludERpZ2l0cy5zdWJzdHIoMCwgaSk7XHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgPyBpbnRQYXJ0ICsgKGZvcm1hdC5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnKSArICgoZzIgPSArZm9ybWF0LmZyYWN0aW9uR3JvdXBTaXplKVxyXG4gICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgIDogZnJhY3Rpb25QYXJ0KVxyXG4gICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoZm9ybWF0LnByZWZpeCB8fCAnJykgKyBzdHIgKyAoZm9ybWF0LnN1ZmZpeCB8fCAnJyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHR3byBCaWdOdW1iZXJzIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGVcclxuICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgKiBtYXhpbXVtIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmVcclxuICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAqXHJcbiAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSwgb3IgSW5maW5pdHkuIFRoZSBtYXhpbXVtIGRlbm9taW5hdG9yLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgKi9cclxuICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhjID0geC5jO1xyXG5cclxuICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG1kKTtcclxuXHJcbiAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICBkID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgZXhwID0gTUFYX0VYUDtcclxuICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgIC8vIG4wID0gZDEgPSAwXHJcbiAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICBmb3IgKDsgOykgIHtcclxuICAgICAgcSA9IGRpdihuLCBkLCAwLCAxKTtcclxuICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICBkMCA9IGQxO1xyXG4gICAgICBkMSA9IGQyO1xyXG4gICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgIG4wID0gZDI7XHJcbiAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgIG4gPSBkMjtcclxuICAgIH1cclxuXHJcbiAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgZDAgPSBkMC5wbHVzKGQyLnRpbWVzKGQxKSk7XHJcbiAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggZnJhY3Rpb24gaXMgY2xvc2VyIHRvIHgsIG4wL2QwIG9yIG4xL2QxXHJcbiAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICBNQVhfRVhQID0gZXhwO1xyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgKi9cclxuICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgKi9cclxuICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgaWYgKHNkICE9IG51bGwpIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgKiBST1VORElOR19NT0RFLiBJZiBhIGJhc2UgaXMgbm90IHNwZWNpZmllZCwgYW5kIHRoaXMgQmlnTnVtYmVyIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAqL1xyXG4gIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgbiA9IHRoaXMsXHJcbiAgICAgIHMgPSBuLnMsXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgaWYgKHMpIHtcclxuICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoY29lZmZUb1N0cmluZyhuLmMpLCBlKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICogbmVnYXRpdmUgemVyby5cclxuICAgKi9cclxuICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gIFBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdCaWdOdW1iZXInO1xyXG5cclxuICAvLyBOb2RlLmpzIHYxMC4xMi4wK1xyXG4gIFBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnZhbHVlT2Y7XHJcblxyXG4gIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICByZXR1cm4gQmlnTnVtYmVyO1xyXG59XHJcblxyXG5cclxuLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4vLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4vLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gIHZhciBpID0gbiB8IDA7XHJcbiAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbn1cclxuXHJcblxyXG4vLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgdmFyIHMsIHosXHJcbiAgICBpID0gMSxcclxuICAgIGogPSBhLmxlbmd0aCxcclxuICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gIGZvciAoOyBpIDwgajspIHtcclxuICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgciArPSBzO1xyXG4gIH1cclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbn1cclxuXHJcblxyXG4vLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbmZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gIHZhciBhLCBiLFxyXG4gICAgeGMgPSB4LmMsXHJcbiAgICB5YyA9IHkuYyxcclxuICAgIGkgPSB4LnMsXHJcbiAgICBqID0geS5zLFxyXG4gICAgayA9IHguZSxcclxuICAgIGwgPSB5LmU7XHJcblxyXG4gIC8vIEVpdGhlciBOYU4/XHJcbiAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgYSA9IHhjICYmICF4Y1swXTtcclxuICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAvLyBFaXRoZXIgemVybz9cclxuICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAvLyBTaWducyBkaWZmZXI/XHJcbiAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gIGEgPSBpIDwgMDtcclxuICBiID0gayA9PSBsO1xyXG5cclxuICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICovXHJcbmZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgIHRocm93IEVycm9yXHJcbiAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbmZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICB2YXIgbGVuLCB6cztcclxuXHJcbiAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgfSBlbHNlIHtcclxuICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciArPSB6cztcclxuICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59XHJcblxyXG5cclxuLy8gRVhQT1JUXHJcblxyXG5cclxuZXhwb3J0IHZhciBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQmlnTnVtYmVyO1xyXG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBzaG93Q29udGFpbmVyID0gZnVuY3Rpb24oaWQgOiBzdHJpbmcpIHtcclxuICAgIGxldCBjb250YWluZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbnRhaW5lcicpO1xyXG4gICAgZm9yIChsZXQgaT0wO2k8Y29udGFpbmVycy5sZW5ndGg7aSsrKSB7XHJcblx0XHRsZXQgZWxlbWVudCA9IGNvbnRhaW5lcnNbaV0gYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQuaWQgPT0gaWQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuXHRcdFx0ZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB9IGVsc2Uge1xyXG5cdFx0XHRlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbmV4cG9ydCBjb25zdCByb3VuZE51bWJlciA9IGZ1bmN0aW9uKG51bWJlciA6IG51bWJlcikge1xyXG5cdHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAqIDEwMCkgLyAxMDA7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCByb3VuZE51bWJlckRlY2ltYWwgPSBmdW5jdGlvbihudW1iZXIgOiBudW1iZXIsIGRlY2ltYWwgOiBudW1iZXIpIHtcclxuXHRsZXQgaHVuZHJlZCA9IHBhcnNlSW50KCcxJysgJzAnLnJlcGVhdChkZWNpbWFsKSk7XHJcblx0cmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogaHVuZHJlZCkgLyBodW5kcmVkO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgcm91bmRCaWdOdW1iZXIgPSBmdW5jdGlvbihudW1iZXIgOiBCaWdOdW1iZXIpIDogQmlnTnVtYmVyIHtcclxuXHRyZXR1cm4gbmV3IEJpZ051bWJlcihNYXRoLnJvdW5kKG51bWJlci50b051bWJlcigpICogMTAwKSAvIDEwMCk7XHJcbn1cclxuZXhwb3J0IGNvbnN0IHJvdW5kQmlnTnVtYmVyRGVjaW1hbCA9IGZ1bmN0aW9uKG51bWJlciA6IEJpZ051bWJlciwgZGVjaW1hbCA6IG51bWJlcikgOiBCaWdOdW1iZXIge1xyXG5cdGxldCBodW5kcmVkID0gcGFyc2VJbnQoJzEnKyAnMCcucmVwZWF0KGRlY2ltYWwpKTtcclxuXHRyZXR1cm4gbmV3IEJpZ051bWJlcihNYXRoLnJvdW5kKG51bWJlci50b051bWJlcigpICogaHVuZHJlZCkgLyBodW5kcmVkKTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEFkZHJlc3NaZXJvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBpc0pTT04gPSBmdW5jdGlvbihzdHIgOiBzdHJpbmcpIHtcclxuXHR0cnkge1xyXG5cdFx0SlNPTi5wYXJzZShzdHIpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGV0aGVyZXVtSW5zdGFsbGVkID0gZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHRyZXR1cm4gKHR5cGVvZiBldGhlcmV1bSAhPT0gJ3VuZGVmaW5lZCcpO1xyXG5cdH0gY2F0Y2ggKGU6IGFueSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG5leHBvcnQgY29uc3Qgc2hvcnRFdGggPSBmdW5jdGlvbiAoZXRoQWRkcmVzczogc3RyaW5nKSB7XHJcblx0aWYgKCFldGhBZGRyZXNzKSByZXR1cm4gJyc7XHJcblxyXG5cdHJldHVybiBldGhBZGRyZXNzLnN1YnN0cmluZygwLCA2KSArIFwiLi4uXCIgKyBldGhBZGRyZXNzLnN1YnN0cmluZyhldGhBZGRyZXNzLmxlbmd0aCAtIDQpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHVwcGVyRmlyc3RMZXR0ZXIgPSBmdW5jdGlvbiAodGV4dDogc3RyaW5nKSB7XHJcblx0cmV0dXJuIHRleHRbMF0udG9VcHBlckNhc2UoKSArIHRleHQuc3Vic3RyaW5nKDEpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3Qgc2hvd0JhciA9IGZ1bmN0aW9uICh0ZXh0OiBzdHJpbmcpIHtcclxuXHRsZXQgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJyk7XHJcblx0aWYgKCFoZWFkZXIpIHJldHVybjtcclxuXHRsZXQgd2FybmluZ0h0bWwgPSAnPGRpdiBjbGFzcz1cImVycm9yQmFyXCI+JyArIHRleHQgKyAnPC9kaXY+JztcclxuXHRoZWFkZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIHdhcm5pbmdIdG1sKTtcclxufVxyXG4iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YXJ0aWNsZT5cXHJcXG4gICAgU29tZSB3YWxsZXRzIGRldGVjdCBhdXRvbWF0aWNhbGx5IHRoZSBjb2lucyB0aGF0IGFyZSByZWdpc3RlcmVkIHRvIHlvdXIgYWRkcmVzcy5cXHJcXG4gICAgVGhvc2UgdGhhdCBkb24ndCBkbyBhdXRvbWF0aWMgZGV0ZWN0aW9uLCB5b3UgbmVlZCB0byBhZGQgdGhlbSBtYW51YWxseS5cXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICBUaGlzIGlzIHRoZSBhZGRyZXNzIGZvciB0aGUgc3ltYm9sIHt7c3ltYm9sfX0sXFxyXFxuICAgIHlvdSBuZWVkIHRvIGNvcHkgaXQgYW5kIGltcG9ydCB0aGUgdG9rZW4gaW4geW91ciB3YWxsZXRcXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICBDb250cmFjdCBhZGRyZXNzOjxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwie3thZGRyZXNzfX1cXFwiLz5cXHJcXG4gICAgU3ltYm9sOjxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwie3tzeW1ib2x9fVxcXCIvPlxcclxcbiAgICBEZWNpbWFsOjxici8+XFxyXFxuICAgIDxpbnB1dCB2YWx1ZT1cXFwiMThcXFwiLz5cXHJcXG48L2FydGljbGU+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBTZWN1cml0aWVzU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYnJva2VyL1NlY3VyaXRpZXNTZXJ2aWNlXCI7XHJcbmltcG9ydCBTZWN1cml0aWVzTGlzdEh0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9TZWN1cml0aWVzTGlzdC5odG1sJ1xyXG5pbXBvcnQgU2VjdXJpdHlIdG1sIGZyb20gJy4uLy4uL2h0bWwvZWxlbWVudHMvU2VjdXJpdGllcy5odG1sJztcclxuaW1wb3J0IFNlY3VyaXR5IGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9icm9rZXIvU2VjdXJpdHlcIjtcclxuaW1wb3J0IExpbWluYWxNYXJrZXRTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0xpbWluYWxNYXJrZXRTZXJ2aWNlXCI7XHJcbmltcG9ydCBDb3B5SGVscGVyIGZyb20gXCIuLi8uLi91dGlsL0NvcHlIZWxwZXJcIjtcclxuaW1wb3J0IEFkZHJlc3NJbmZvSHRtbCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL0FkZHJlc3NJbmZvLmh0bWwnO1xyXG5pbXBvcnQgQ29udHJhY3RBZGRyZXNzTm90Rm91bmQgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9Db250cmFjdEFkZHJlc3NOb3RGb3VuZC5odG1sJztcclxuaW1wb3J0IHtBZGRyZXNzWmVyb30gZnJvbSBcIi4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCBBZGRUb1dhbGxldEh0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9BZGRUb1dhbGxldC5odG1sJztcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBHZW5lcmFsRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9HZW5lcmFsRXJyb3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3VyaXRpZXNMaXN0IHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgcGFnZTogbnVtYmVyO1xyXG4gICAgdGJvZHlJZCA9ICdsaW1pbmFsX21hcmtldF9zZWN1cml0aWVzX2xpc3QnO1xyXG4gICAgbG9hZG1vcmU6IGJvb2xlYW47XHJcbiAgICBvblNlbGVjdFN5bWJvbD86IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2FkbW9yZSA9IHRydWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXIoKSB7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXNTZXJ2aWNlID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcclxuXHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXNDb3VudCA9IHNlY3VyaXRpZXNTZXJ2aWNlLnNlY3VyaXRpZXNBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXMgPSBhd2FpdCBzZWN1cml0aWVzU2VydmljZS5nZXRQYWdpbmF0aW5nU2VjdXJpdGllcyh0aGlzLnBhZ2UrKyk7XHJcblxyXG4gICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJQYXJ0aWFsKFxyXG4gICAgICAgICAgICBcInNlY3VyaXRpZXNcIixcclxuICAgICAgICAgICAgU2VjdXJpdHlIdG1sXHJcbiAgICAgICAgKVxyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU2VjdXJpdGllc0xpc3RIdG1sKTtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIHRib2R5SWQ6IHRoaXMudGJvZHlJZCxcclxuICAgICAgICAgICAgc2VjdXJpdGllczogc2VjdXJpdGllcyxcclxuICAgICAgICAgICAgc2VjdXJpdGllc0NvdW50OiBzZWN1cml0aWVzQ291bnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKG9iaik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGJpbmRFdmVudHMob25TZWxlY3RTeW1ib2w6IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICB0aGlzLmJpbmRPbkNsaWNrRXZlbnQob25TZWxlY3RTeW1ib2wpO1xyXG4gICAgICAgIGF3YWl0IHRoaXMuYmluZFNlYXJjaEV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5iaW5kTG9hZE1vcmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJpbmRPbkNsaWNrRXZlbnQob25TZWxlY3RTeW1ib2w6IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgdGFibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfc2VjdXJpdGllc190YWJsZScpO1xyXG5cclxuICAgICAgICBpZiAoIXRhYmxlKSB7XHJcbiAgICAgICAgICAgIEVycm9ySW5mby5yZXBvcnQobmV3IEdlbmVyYWxFcnJvcihcIlBhZ2UgY291bGQgbm90IGxvYWQgY29ycmVjdGx5LCB0cnkgcmVsb2FkaW5nXCIpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uU2VsZWN0U3ltYm9sID0gb25TZWxlY3RTeW1ib2w7XHJcblxyXG4gICAgICAgIHRhYmxlLm9uY2xpY2sgPSBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlQ2xpY2soZXZ0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGhhbmRsZUNsaWNrKGV2dDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gKGV2dC50YXJnZXQhIGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgPT09ICdhJykge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFkZFRvV2FsbGV0T3JHZXRBZGRyZXNzKGV2dCwgZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwYXJlbnRUciA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcclxuICAgICAgICBpZiAoIXBhcmVudFRyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmIChwYXJlbnRUci50YWdOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCkgIT09ICd0cicpIHtcclxuICAgICAgICAgICAgcGFyZW50VHIgPSBwYXJlbnRUci5wYXJlbnRFbGVtZW50ITtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzeW1ib2wgPSBwYXJlbnRUci5kYXRhc2V0LnN5bWJvbDtcclxuICAgICAgICBpZiAoIXN5bWJvbCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgbmFtZSA9IHBhcmVudFRyLmRhdGFzZXQubmFtZSFcclxuICAgICAgICBsZXQgbG9nbyA9IHBhcmVudFRyLmRhdGFzZXQubG9nbyE7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uU2VsZWN0U3ltYm9sKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3RTeW1ib2woc3ltYm9sLCBuYW1lLCBsb2dvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBiaW5kU2VhcmNoRXZlbnQoKSB7XHJcbiAgICAgICAgbGV0IHNlYXJjaEZvclN5bWJvbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZWFyY2hfZm9yX3N5bWJvbCcpO1xyXG4gICAgICAgIGlmICghc2VhcmNoRm9yU3ltYm9sKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0aWVzU2VydmljZSA9IGF3YWl0IFNlY3VyaXRpZXNTZXJ2aWNlLmdldEluc3RhbmNlKCk7XHJcblxyXG4gICAgICAgIGxldCB0aW1lb3V0OiBhbnkgPSBudWxsO1xyXG4gICAgICAgIHNlYXJjaEZvclN5bWJvbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzZWFyY2ggPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghc2VhcmNoIHx8IHNlYXJjaC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkbW9yZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zaG93VG9wU2VjdXJpdGllcyhzZWN1cml0aWVzU2VydmljZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkbW9yZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgc2VjdXJpdGllc1NlcnZpY2UuZmluZChzZWFyY2gpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkU2VjdXJpdGllc1RvRG9tKHNlY3VyaXRpZXMpO1xyXG4gICAgICAgICAgICB9LCA1MDApO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93VG9wU2VjdXJpdGllcyhzZWN1cml0aWVzU2VydmljZTogU2VjdXJpdGllc1NlcnZpY2UpIHtcclxuICAgICAgICBsZXQgc2VjdXJpdGllcyA9IGF3YWl0IHNlY3VyaXRpZXNTZXJ2aWNlLmdldFRvcFNlY3VyaXRpZXMoKTtcclxuICAgICAgICB0aGlzLmxvYWRTZWN1cml0aWVzVG9Eb20oc2VjdXJpdGllcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBsb2FkU2VjdXJpdGllc1RvRG9tKHNlY3VyaXRpZXM6IEFycmF5PFNlY3VyaXR5Pikge1xyXG4gICAgICAgIGxldCB0Ym9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMudGJvZHlJZCk7XHJcbiAgICAgICAgaWYgKCF0Ym9keSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU2VjdXJpdHlIdG1sKTtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIHNlY3VyaXRpZXM6IHNlY3VyaXRpZXNcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZShvYmopO1xyXG4gICAgICAgIHRib2R5LmlubmVySFRNTCA9IGNvbnRlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kTG9hZE1vcmUoKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpbWluYWxfbWFya2V0X2xvYWRfbW9yZScpITtcclxuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoYXN5bmMgKFtlbnRyeV0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRNb3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIHJvb3Q6IG51bGwsXHJcbiAgICAgICAgICAgIHRocmVzaG9sZDogMC4xLCAvLyBzZXQgb2Zmc2V0IDAuMSBtZWFucyB0cmlnZ2VyIGlmIGF0bGVhc3QgMTAlIG9mIGVsZW1lbnQgaW4gdmlld3BvcnRcclxuICAgICAgICB9KTtcclxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZE1vcmUodGhpczogU2VjdXJpdGllc0xpc3QpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBpZiAoIXRoaXMubG9hZG1vcmUpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHRib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy50Ym9keUlkKTtcclxuICAgICAgICBpZiAoIXRib2R5KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBzZWN1cml0aWVzU2VydmljZSA9IGF3YWl0IFNlY3VyaXRpZXNTZXJ2aWNlLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXMgPSBhd2FpdCBzZWN1cml0aWVzU2VydmljZS5nZXRQYWdpbmF0aW5nU2VjdXJpdGllcyh0aGlzLnBhZ2UrKyk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShTZWN1cml0eUh0bWwpO1xyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHtcclxuICAgICAgICAgICAgc2VjdXJpdGllczogc2VjdXJpdGllc1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKG9iaik7XHJcblxyXG4gICAgICAgIHRib2R5Lmluc2VydEFkamFjZW50SFRNTCgnYmVmb3JlZW5kJywgY29udGVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBhZGRUb1dhbGxldE9yR2V0QWRkcmVzcyhldmVudDogTW91c2VFdmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPSAnZ2V0QWRkcmVzcycgJiYgY2xhc3NOYW1lICE9ICdhZGRUb1dhbGxldCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgbGV0IHN5bWJvbCA9IGVsZW1lbnQuZGF0YXNldC5zeW1ib2w7XHJcbiAgICAgICAgaWYgKCFzeW1ib2wpIHJldHVybjtcclxuXHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5zZXRMb2FkaW5nKGVsZW1lbnQpO1xyXG5cclxuICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICBsZXQgYWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG5cclxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdnZXRBZGRyZXNzJykge1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNob3dHZXRBZGRyZXNzKGVsZW1lbnQsIHN5bWJvbCwgYWRkcmVzcyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zaG93QWRkVG9XYWxsZXQoZWxlbWVudCwgc3ltYm9sLCBhZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBzaG93R2V0QWRkcmVzcyhlbGVtZW50OiBIVE1MRWxlbWVudCwgc3ltYm9sOiBzdHJpbmcsIGFkZHJlc3M6IHN0cmluZykge1xyXG4gICAgICAgIGlmIChhZGRyZXNzICE9PSBBZGRyZXNzWmVybykge1xyXG4gICAgICAgICAgICBsZXQgY29weUhlbHBlciA9IG5ldyBDb3B5SGVscGVyKCk7XHJcbiAgICAgICAgICAgIGxldCBzdWNjZXNzID0gYXdhaXQgY29weUhlbHBlci5jb3B5VGV4dFRvQ2xpcGJvYXJkKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lclRleHQgPSAnQ29waWVkJztcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckNvbnRyYWN0SW5mb1RvU3RyaW5nKGVsZW1lbnQsIGFkZHJlc3MsIHN5bWJvbCwgQWRkcmVzc0luZm9IdG1sKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93QWRkVG9XYWxsZXQoZWxlbWVudDogSFRNTEVsZW1lbnQsIHN5bWJvbDogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoYWRkcmVzcyAhPT0gQWRkcmVzc1plcm8pIHtcclxuICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIodGhpcy5tb3JhbGlzKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhZGRlZCA9IGF3YWl0IHdhbGxldEhlbHBlci5hZGRUb2tlblRvV2FsbGV0KGFkZHJlc3MsIHN5bWJvbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNvbnRyYWN0SW5mb1RvU3RyaW5nKGVsZW1lbnQsIGFkZHJlc3MsIHN5bWJvbCwgQWRkVG9XYWxsZXRIdG1sKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChhZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlckNvbnRyYWN0SW5mb1RvU3RyaW5nKGVsZW1lbnQsIGFkZHJlc3MsIHN5bWJvbCwgQWRkVG9XYWxsZXRIdG1sKTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyQ29udHJhY3RJbmZvVG9TdHJpbmcoZWxlbWVudDogSFRNTEVsZW1lbnQsIGFkZHJlc3M6IHN0cmluZywgc3ltYm9sOiBzdHJpbmcsIHRlbXBsYXRlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgc3ltYm9sSW5mb1RvQ29weSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW1ib2xJbmZvVG9Db3B5Jyk7XHJcbiAgICAgICAgaWYgKHN5bWJvbEluZm9Ub0NvcHkpIHN5bWJvbEluZm9Ub0NvcHkucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIGxldCBjb250ZW50ID0gJyc7XHJcbiAgICAgICAgaWYgKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShDb250cmFjdEFkZHJlc3NOb3RGb3VuZCk7XHJcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0ZW1wbGF0ZShudWxsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoQWRkcmVzc0luZm9IdG1sKTtcclxuICAgICAgICAgICAgbGV0IG9iajogYW55ID0ge1xyXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBzeW1ib2wsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGVudCA9IHRlbXBsYXRlKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmVuZCcsIGNvbnRlbnQpO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBpZD1cXFwidXNlck1lbnVQYW5lbFxcXCI+XFxyXFxuICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJ1c2VySW5mb0FjdGlvblxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiPlxcclxcbiAgICAgICAgPGltZyBzcmM9XFxcImh0dHBzOi8vZWZmaWd5LmltL2Eve3tldGhBZGRyZXNzfX0ucG5nXFxcIiB3aWR0aD1cXFwiMjRcXFwiPlxcclxcbiAgICAgICAgPHNwYW4gaWQ9XFxcInVzZXJfaW5mb19ldGhBZGRyZXNzXFxcIj57e3Nob3J0RXRoQWRkcmVzc319PC9zcGFuPlxcclxcbiAgICA8L2E+XFxyXFxuXFxyXFxuICAgIDxkaXYgaWQ9XFxcInVzZXJJbmZvRHJvcGRvd25cXFwiIGNsYXNzPVxcXCJkLW5vbmVcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZCBhY2NvdW50X2luZm9cXFwiPlxcclxcbiAgICAgICAgICAgIDxoNj5BY2NvdW50PC9oNj5cXHJcXG4gICAgICAgICAgICA8YSBpZD1cXFwiZGlzY29ubmVjdEZyb21OZXR3b3JrXFxcIiBocmVmPVxcXCIjXFxcIj5EaXNjb25uZWN0PC9hPlxcclxcblxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJlZGl0X2FjY291bnRcXFwiPlxcclxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJlZGl0TmFtZVxcXCIgaHJlZj1cXFwiI1xcXCI+RWRpdCBuYW1lPC9hPjxici8+XFxyXFxuICAgICAgICAgICAgPGEgaWQ9XFxcImVkaXRDb250YWN0XFxcIiBocmVmPVxcXCIjXFxcIj5FZGl0IGNvbnRhY3QgaW5mbzwvYT48YnIvPlxcclxcbiAgICAgICAgICAgIDxhIGlkPVxcXCJlZGl0VHJ1c3RlZENvbnRhY3RcXFwiIGhyZWY9XFxcIiNcXFwiPkVkaXQgdHJ1c3RlZCBjb250YWN0PC9hPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8aHIvPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcImh0dHBzOi8vZWZmaWd5LmltL2Eve3tldGhBZGRyZXNzfX0ucG5nXFxcIj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVxcXCJkLWJsb2NrXFxcIj48YSBocmVmPVxcXCJ7e2Jsb2NrY2hhaW5FeHBsb3Jlcn19e3tldGhBZGRyZXNzfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57e3Nob3J0RXRoQWRkcmVzc319PC9hPjwvc3Ryb25nPlxcclxcbiAgICAgICAgICAgICAgICA8YnIvPlxcclxcbiAgICAgICAgICAgICAgICB7eyNpZiBpc01hZ2ljfX1cXHJcXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcIndhbGxldFxcXCI+T3BlbiBteSB3YWxsZXQ8L2E+XFxyXFxuICAgICAgICAgICAgICAgIHt7L2lmfX1cXHJcXG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9pbmZvLmxpbWluYWwubWFya2V0LyMvY2hhaW4ve3tjaGFpbklkfX0ve3tldGhBZGRyZXNzfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5WaWV3XFxyXFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM8L2E+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxoci8+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJoaWRkZW5cXFwiIGlkPVxcXCJ1c2VySW5mb0FVc2RCYWxhbmNlXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdj48aW1nIHNyYz1cXFwiaHR0cHM6Ly9hcHAubGltaW5hbC5tYXJrZXQvaW1nL2F1c2QucG5nXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmcgY2xhc3M9XFxcImQtYmxvY2tcXFwiPmFVU0QgPHNwYW4gaWQ9XFxcInVzZXJfaW5mb19hdXNkX2JhbGFuY2VcXFwiPjwvc3Bhbj48L3N0cm9uZz5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImFkZF9hVVNEX3RvX3dhbGxldFxcXCI+QWRkIGFVU0QgdG8gd2FsbGV0PC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2IGlkPVxcXCJmdW5kX2FjY291bnRfb3B0aW9uc1xcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxoNj5GdW5kIHlvdXIgYWNjb3VudDwvaDY+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcImZ1bmRfYWNjb3VudFxcXCI+RnVuZCBteSBhY2NvdW50PC9hPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcIndpdGhkcmF3X2Zyb21fYWNjb3VudFxcXCI+V2l0aGRyYXcgZnJvbSBhY2NvdW50PC9hPlxcclxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8aHIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8c3Ryb25nIGNsYXNzPVxcXCJkLWJsb2NrXFxcIj5OZXR3b3JrPC9zdHJvbmc+XFxyXFxuICAgICAgICAgICAgPHNtYWxsPnt7bmV0d29ya05hbWV9fTxici8+XFxyXFxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJzd2l0Y2hfbmV0d29ya1xcXCI+Q2hhbmdlIG5ldHdvcms8L2E+XFxyXFxuICAgICAgICAgICAgPC9zbWFsbD5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8L2Rpdj5cXHJcXG5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGlkPVxcXCJreWNFZGl0TmFtZVxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcIndhcm5pbmdCYXJcXFwiPlxcclxcbiAgICAgICAgPHN0cm9uZz5XYXJuaW5nPC9zdHJvbmc+PGJyLz5cXHJcXG4gICAgICAgIFlvdSBjYW4gb25seSBjaGFuZ2UgdGhlIG5hbWUgb25jZS4gQmUgY2FyZWZ1bCBvZiB3aGF0IHlvdSBjaGFuZ2UuXFxyXFxuICAgICAgICA8YnIvPjxici8+XFxyXFxuICAgICAgICBBZnRlciB5b3UgY2hhbmdlIHRoaXMgaW5mb3JtYXRpb24gYSBuZXcgS1lDIHByb2Nlc3Mgd2lsbCBiZSBzdGFydGVkLCBhbmQgeW91IHdpbGwgTk9UIGJlIGFibGUgdG8gZG8gYW55XFxyXFxuICAgICAgICB0cmFkZXNcXHJcXG4gICAgICAgIHVudGlsIGl0IGhhcyBiZWVuIGFwcHJvdmVkLlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImdpdmVuX25hbWVcXFwiPkxlZ2FsIEZpcnN0IG5hbWU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJnaXZlbl9uYW1lXFxcIiBuYW1lPVxcXCJnaXZlbl9uYW1lXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJSb25cXFwiXFxyXFxuICAgICAgICAgICAgICAgdmFsdWU9XFxcInt7Z2l2ZW5fbmFtZX19XFxcIiBhdXRvY29tcGxldGU9XFxcImdpdmVuLW5hbWVcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcIm1pZGRsZV9uYW1lXFxcIj5MZWdhbCBNaWRkbGUgbmFtZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcIm1pZGRsZV9uYW1lXFxcIiBuYW1lPVxcXCJtaWRkbGVfbmFtZVxcXCJcXHJcXG4gICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJ7e21pZGRsZV9uYW1lfX1cXFwiIGF1dG9jb21wbGV0ZT1cXFwiYWRkaXRpb25hbC1uYW1lXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJmYW1pbHlfbmFtZVxcXCI+TGVnYWwgTGFzdCBuYW1lPC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCByZXF1aXJlZCBpZD1cXFwiZmFtaWx5X25hbWVcXFwiIG5hbWU9XFxcImZhbWlseV9uYW1lXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJTd2Fuc29uXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJ7e2ZhbWlseV9uYW1lfX1cXFwiIGF1dG9jb21wbGV0ZT1cXFwiZmFtaWx5LW5hbWVcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIGlkPVxcXCJreWNFZGl0TmFtZUNvbmZpcm1cXFwiPkNvbmZpcm08L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cXHJcXG5cXHJcXG48ZmllbGRzZXQgY2xhc3M9XFxcImhpZGRlblxcXCIgaWQ9XFxcImNvbmZpcm1OYW1lRmllbGRzZXRcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJjb25maXJtX25hbWVcXFwiPlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29uZmlybV9uYW1lXFxcIiBpZD1cXFwibGFiZWxfY29uZmlybV9uYW1lXFxcIj5QbGVhc2UgdHlwZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiY29uZmlybV9uYW1lXFxcIiBpZD1cXFwiY29uZmlybV9uYW1lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcImt5Y0VkaXROYW1lRXJyb3JcXFwiPjwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b25zIGdyaWRcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiBpZD1cXFwia3ljRWRpdE5hbWVCYWNrXFxcIj5CYWNrPC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgaWQ9XFxcImt5Y0VkaXROYW1lU2F2ZVxcXCI+Q29uZmlybTwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdIZWxwZXIge1xyXG4gICAgcHVibGljIHN0YXRpYyBpc051bGxPckVtcHR5KHN0cjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuICFzdHIgfHwgc3RyLnRvU3RyaW5nKCkudHJpbSgpLmxlbmd0aCA9PSAwO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgS3ljRWRpdE5hbWVIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0VkaXROYW1lLmh0bWwnO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRWRpdE5hbWVGb3JtIHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IGt5Y0VkaXROYW1lRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljRWRpdE5hbWVFcnJvcicpO1xyXG4gICAgICAgIGlmIChreWNFZGl0TmFtZUVycm9yKSBreWNFZGl0TmFtZUVycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZShNb3JhbGlzKTtcclxuICAgICAgICBsZXQgYWNjb3VudCA9IGF3YWl0IHVzZXJTZXJ2aWNlLmdldEFjY291bnQoKVxyXG5cclxuICAgICAgICBsZXQgZ2l2ZW5fbmFtZSA9IGFjY291bnQuaWRlbnRpdHkuZ2l2ZW5fbmFtZSBhcyBzdHJpbmc7XHJcbiAgICAgICAgbGV0IG1pZGRsZV9uYW1lID0gYWNjb3VudC5pZGVudGl0eS5taWRkbGVfbmFtZSBhcyBzdHJpbmc7XHJcbiAgICAgICAgbGV0IGZhbWlseV9uYW1lID0gYWNjb3VudC5pZGVudGl0eS5mYW1pbHlfbmFtZTtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y0VkaXROYW1lSHRtbClcclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKHtnaXZlbl9uYW1lOiBnaXZlbl9uYW1lLCBtaWRkbGVfbmFtZTogbWlkZGxlX25hbWUsIGZhbWlseV9uYW1lOiBmYW1pbHlfbmFtZX0pO1xyXG5cclxuICAgICAgICB0aGlzLm1vZGFsLnNob3dNb2RhbCgnRWRpdCBuYW1lJywgY29udGVudCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYmluZEV2ZW50cygpIHtcclxuXHJcbiAgICAgICAgbGV0IGt5Y0VkaXROYW1lQ29uZmlybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0TmFtZUNvbmZpcm0nKTtcclxuICAgICAgICBreWNFZGl0TmFtZUNvbmZpcm0/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgbGV0IGdpdmVuX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2l2ZW5fbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVfbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaWRkbGVfbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBmYW1pbHlfbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmYW1pbHlfbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KGdpdmVuX25hbWUudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcignR2l2ZW4gbmFtZSBjYW5ub3QgYmUgZW1wdHknKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KGZhbWlseV9uYW1lLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoJ0ZhbWlseSBuYW1lIGNhbm5vdCBiZSBlbXB0eScpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBmdWxsX25hbWUgPSB0aGlzLmdldEZ1bGxOYW1lKCk7XHJcbiAgICAgICAgICAgIGxldCBsYWJlbF9jb25maXJtX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFiZWxfY29uZmlybV9uYW1lJyk7XHJcbiAgICAgICAgICAgIGlmICghbGFiZWxfY29uZmlybV9uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IHJlcG9ydCBlcnJvciBpbiBmb3JtXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhYmVsX2NvbmZpcm1fbmFtZS5pbm5lckhUTUwgPSAnUGxlYXNlIHR5cGUgaW4gdGhlIGZ1bGwgbmFtZSBcIicgKyBmdWxsX25hbWUgKyAnXCIgaW4gdGhlIGJveCBiZWxvdyB0byBjb25maXJtLiBZb3UgV0lMTCBOT1QgYmUgYWJsZSB0byBjaGFuZ2UgaXQgYWdhaW4uJztcclxuXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25maXJtTmFtZUZpZWxkc2V0Jyk/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0TmFtZScpPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBreWNFZGl0TmFtZUJhY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljRWRpdE5hbWVCYWNrJyk7XHJcbiAgICAgICAga3ljRWRpdE5hbWVCYWNrPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm1OYW1lRmllbGRzZXQnKT8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJylcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0VkaXROYW1lJyk/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IGNvbmZpcm1fbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25maXJtX25hbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICghY29uZmlybV9uYW1lKSB7XHJcbiAgICAgICAgICAgIC8vVE9ETzogcmVwb3J0IGVycm9yIGluIGZvcm1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGt5Y0VkaXROYW1lU2F2ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0TmFtZVNhdmUnKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcclxuICAgICAgICBreWNFZGl0TmFtZVNhdmUuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGNvbmZpcm1fbmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgY29uZmlybV9uYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29uZmlybV9uYW1lLnZhbHVlID09IHRoaXMuZ2V0RnVsbE5hbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlybV9uYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ2ZhbHNlJyk7XHJcbiAgICAgICAgICAgICAgICBreWNFZGl0TmFtZVNhdmUuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpcm1fbmFtZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgICAgICBreWNFZGl0TmFtZVNhdmUuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAga3ljRWRpdE5hbWVTYXZlPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvbmZpcm1fbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25maXJtX25hbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoY29uZmlybV9uYW1lICYmIGNvbmZpcm1fbmFtZS52YWx1ZSAhPSB0aGlzLmdldEZ1bGxOYW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGFsZXJ0KGNvbmZpcm1fbmFtZS52YWx1ZSArICcgaXMgbm90IHNhbWUgYXMgJyArIHRoaXMuZ2V0RnVsbE5hbWUoKSArICcuIEdvIG92ZXIgdGhlIG5hbWUgYW5kIG1ha2Ugc3VyZSBpdCBpcyBpZGVudGljYWwnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGdpdmVuX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2l2ZW5fbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBtaWRkbGVfbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaWRkbGVfbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCBmYW1pbHlfbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmYW1pbHlfbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyhreWNFZGl0TmFtZVNhdmUpO1xyXG4gICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UoTW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVzZXJTZXJ2aWNlLnVwZGF0ZU5hbWUoZ2l2ZW5fbmFtZS52YWx1ZSwgbWlkZGxlX25hbWUudmFsdWUsIGZhbWlseV9uYW1lLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IocmVzcG9uc2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RhbC5oaWRlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKEpTT04ucGFyc2UocmVhc29uLm1lc3NhZ2UpLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNob3dFcnJvcihtZXNzYWdlOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQga3ljRWRpdE5hbWVFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0TmFtZUVycm9yJyk7XHJcbiAgICAgICAgaWYgKCFreWNFZGl0TmFtZUVycm9yKSByZXR1cm47XHJcblxyXG4gICAgICAgIGt5Y0VkaXROYW1lRXJyb3IuaW5uZXJIVE1MID0gbWVzc2FnZTtcclxuICAgICAgICBreWNFZGl0TmFtZUVycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0RnVsbE5hbWUoKSB7XHJcbiAgICAgICAgbGV0IGdpdmVuX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2l2ZW5fbmFtZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IG1pZGRsZV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pZGRsZV9uYW1lJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBsZXQgZmFtaWx5X25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmFtaWx5X25hbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICByZXR1cm4gZ2l2ZW5fbmFtZS52YWx1ZSArICcgJyArICghU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkobWlkZGxlX25hbWUudmFsdWUpID8gbWlkZGxlX25hbWUudmFsdWUgKyAnICcgOiAnJykgKyBmYW1pbHlfbmFtZS52YWx1ZTtcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBpZD1cXFwia3ljRWRpdENvbnRhY3RGaWVsZHNldFxcXCI+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcIndhcm5pbmdCYXJcXFwiPlxcclxcbiAgICAgICAgPHN0cm9uZz5XYXJuaW5nPC9zdHJvbmc+PGJyLz5cXHJcXG4gICAgICAgIEFmdGVyIHlvdSBjaGFuZ2UgdGhpcyBpbmZvcm1hdGlvbiBhIG5ldyBLWUMgcHJvY2VzcyB3aWxsIGJlIHN0YXJ0ZWQsIGFuZCB5b3Ugd2lsbCBOT1QgYmUgYWJsZSB0byBkbyBhbnlcXHJcXG4gICAgICAgIHRyYWRlcyB1bnRpbCBpdCBoYXMgYmVlbiBhcHByb3ZlZC5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxmb3JtIGlkPVxcXCJreWNFZGl0Q29udGFjdEZvcm1cXFwiPlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbWFpbF9hZGRyZXNzXFxcIj5FbWFpbDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImVtYWlsXFxcIiByZXF1aXJlZCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBpZD1cXFwiZW1haWxfYWRkcmVzc1xcXCIgbmFtZT1cXFwiZW1haWxfYWRkcmVzc1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIm5hbWVAZXhhbXBsZS5jb21cXFwiIGF1dG9jb21wbGV0ZT1cXFwiZW1haWxcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInBob25lX251bWJlclxcXCI+UGhvbmU8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZWxcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJwaG9uZV9udW1iZXJcXFwiIG5hbWU9XFxcInBob25lX251bWJlclxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIisxLTU1NS02NjYtNzc4OFxcXCIgYXV0b2NvbXBsZXRlPVxcXCJ0ZWxcXFwiIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInN0cmVldF9hZGRyZXNzXFxcIj5QZXJtYW5lbnQgUmVzaWRlbnRpYWwgQWRkcmVzczwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiZXhwbGFpblxcXCI+SXQgbXVzdCBiZSBhIHBoeXNpY2FsIGFkZHJlc3MsIG5vdCBhIFBPIGJveC48L2Rpdj5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcInN0cmVldF9hZGRyZXNzXFxcIiBuYW1lPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIjIwIE4gU2FuIE1hdGVvIERyXFxcIiB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZHJlc3MtbGluZTFcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInVuaXRcXFwiPlVuaXQgLyBBcHQgIzwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJ1bml0XFxcIiBuYW1lPVxcXCJ1bml0XFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjaXR5XFxcIj5DaXR5PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcImNpdHlcXFwiIG5hbWU9XFxcImNpdHlcXFwiIHBsYWNlaG9sZGVyPVxcXCJQYXduZWVcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiIGF1dG9jb21wbGV0ZT1cXFwiYWRkcmVzcy1sZXZlbDJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInBvc3RhbF9jb2RlXFxcIj5Qb3N0YWwgY29kZTwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJwb3N0YWxfY29kZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJwb3N0YWwtY29kZVxcXCIgbmFtZT1cXFwicG9zdGFsX2NvZGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCI5NDQwMVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgdmFsdWU9XFxcIlxcXCI+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIHt7I2lmIHVzYX19XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJzdGF0ZV9kaXZcXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInN0YXRlXFxcIj5TdGF0ZSAoMiBsZXR0ZXJzKTwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHJlcXVpcmVkIG1heGxlbmd0aD1cXFwiMlxcXCIgaWQ9XFxcInN0YXRlXFxcIiBuYW1lPVxcXCJzdGF0ZVxcXCIgcGxhY2Vob2xkZXI9XFxcIk5ZXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZHJlc3MtbGV2ZWwxXFxcIj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAge3svaWZ9fVxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJreWNFZGl0Q29udGFjdEVycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBpZD1cXFwia3ljRWRpdENvbnRhY3RTYXZlXFxcIj5TYXZlPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9mb3JtPlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSBcIi4vU3RyaW5nSGVscGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtSGVscGVyIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFBhcmFtcyhzZWxlY3Rvcjogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSBhcyBIVE1MRm9ybUVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFmb3JtKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBkYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZShkYXRhKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgc2VyaWFsaXplKGRhdGE6IGFueSkge1xyXG4gICAgICAgIGxldCBvYmo6IGFueSA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkYXRhKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBbb2JqW2tleV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZmlsbElucHV0cyhwcm9wZXJ0aWVzOiBzdHJpbmdbXSwgaXRlbTogYW55KSB7XHJcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xyXG5cclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT0nICsgdmFsdWUgKyAnXScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT0gJ3JhZGlvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGVja2JveCcsIGlucHV0LCBpdGVtW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBpdGVtW3ZhbHVlXVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGl0ZW1bdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2NoYW5nZScpKVxyXG5cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBzZWxlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzZWxlY3RbbmFtZT0nICsgdmFsdWUgKyAnXScpIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdC52YWx1ZSA9IGl0ZW1bdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHZhbGlkYXRlKHNlbGVjdG9yOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgaW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciArICcgaW5wdXRbcmVxdWlyZWRdLCAnICsgc2VsZWN0b3IgKyAnIHNlbGVjdFtyZXF1aXJlZF0nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaV0gYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKVxyXG4gICAgICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgS3ljRWRpdENvbnRhY3RGb3JtSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNFZGl0Q29udGFjdEZvcm0uaHRtbCdcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBGb3JtSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0Zvcm1IZWxwZXJcIjtcclxuaW1wb3J0IEt5Y1ZhbGlkYXRvckVycm9yIGZyb20gXCIuLi8uLi8uLi9lcnJvcnMvY2xvdWQvS3ljVmFsaWRhdG9yRXJyb3JcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IHtBY2NvdW50SW5mb30gZnJvbSBcIi4uLy4uLy4uL2R0by9hbHBhY2EvQWNjb3VudEluZm9cIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRWRpdENvbnRhY3RGb3JtIHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLm1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGFjY291bnQgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRBY2NvdW50KCk7XHJcbiAgICAgICAgbGV0IHVzYSA9IGFjY291bnQuaWRlbnRpdHkuY291bnRyeV9vZl90YXhfcmVzaWRlbmNlID09ICdVU0EnXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y0VkaXRDb250YWN0Rm9ybUh0bWwpO1xyXG4gICAgICAgIHRoaXMubW9kYWwuc2hvd01vZGFsKCdFZGl0IGNvbnRhY3QgaW5mb3JtYXRpb24nLCB0ZW1wbGF0ZSh7dXNhOiB1c2F9KSlcclxuXHJcbiAgICAgICAgbGV0IGNvbnRhY3RQcm9wZXJ0aWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWNjb3VudC5jb250YWN0KTtcclxuICAgICAgICBGb3JtSGVscGVyLmZpbGxJbnB1dHMoY29udGFjdFByb3BlcnRpZXMsIGFjY291bnQuY29udGFjdCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IGt5Y0VkaXRDb250YWN0U2F2ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNFZGl0Q29udGFjdFNhdmUnKTtcclxuICAgICAgICBreWNFZGl0Q29udGFjdFNhdmU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZSgpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcoa3ljRWRpdENvbnRhY3RTYXZlKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gRm9ybUhlbHBlci5nZXRQYXJhbXMoJyNreWNFZGl0Q29udGFjdEZvcm0nKTtcclxuICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKE1vcmFsaXMpO1xyXG4gICAgICAgICAgICBhd2FpdCB1c2VyU2VydmljZS51cGRhdGVDb250YWN0KGRhdGEpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IocmVzcG9uc2UubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IGFjY291bnRJbmZvID0gcmVzcG9uc2UgYXMgQWNjb3VudEluZm87XHJcbiAgICAgICAgICAgICAgICBsZXQgZW1haWxfYWRkcmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlbWFpbF9hZGRyZXNzJykgYXMgSFRNTElucHV0RWxlbWVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRJbmZvLmNvbnRhY3QuZW1haWxfYWRkcmVzcyAhPSBlbWFpbF9hZGRyZXNzPy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKCdFbWFpbCB3YXMgbm90IGNoYW5nZWQuIFRoZSBlbWFpbCAnICsgZW1haWxfYWRkcmVzcz8udmFsdWUgKyAnIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB1bmRlciBkaWZmZXJlbnQgYWNjb3VudC4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoSlNPTi5wYXJzZShyZWFzb24ubWVzc2FnZSkubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzaG93RXJyb3IobWVzc2FnZTogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGt5Y0VkaXROYW1lRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljRWRpdENvbnRhY3RFcnJvcicpO1xyXG4gICAgICAgIGlmICgha3ljRWRpdE5hbWVFcnJvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBreWNFZGl0TmFtZUVycm9yLmlubmVySFRNTCA9IG1lc3NhZ2U7XHJcbiAgICAgICAga3ljRWRpdE5hbWVFcnJvci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlKCkge1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcja3ljRWRpdENvbnRhY3RGaWVsZHNldCBpbnB1dFtyZXF1aXJlZF0nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaV0gYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KGlucHV0LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpXHJcbiAgICAgICAgICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAnZmFsc2UnKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBjbGFzcz1cXFwia3ljVHJ1c3RlZENvbnRhY3RcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJ3YXJuaW5nQmFyXFxcIj5cXHJcXG4gICAgICAgIDxzdHJvbmc+V2FybmluZzwvc3Ryb25nPjxici8+XFxyXFxuICAgICAgICBBZnRlciB5b3UgY2hhbmdlIHRoaXMgaW5mb3JtYXRpb24gYSBuZXcgS1lDIHByb2Nlc3Mgd2lsbCBiZSBzdGFydGVkLCBhbmQgeW91IHdpbGwgTk9UIGJlIGFibGUgdG8gZG8gYW55XFxyXFxuICAgICAgICB0cmFkZXMgdW50aWwgaXQgaGFzIGJlZW4gYXBwcm92ZWQuXFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8Zm9ybSBpZD1cXFwia3ljVHJ1c3RlZENvbnRhY3RGb3JtXFxcIiBtZXRob2Q9XFxcInBvc3RcXFwiPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZXhwbGFpblxcXCI+XFxyXFxuICAgICAgICAgICAgQSB0cnVzdGVkIGNvbnRhY3QgaXMgYSBwZXJzb24geW91IGF1dGhvcml6ZSB5b3VyIGZpbmFuY2lhbCBmaXJtIHRvIGNvbnRhY3QgaW4gbGltaXRlZCBjaXJjdW1zdGFuY2VzLFxcclxcbiAgICAgICAgICAgIHN1Y2ggYXMgaWYgdGhlcmUgaXMgYSBjb25jZXJuIGFib3V0IGFjdGl2aXR5IGluIHlvdXIgYWNjb3VudCBhbmQgdGhleSBoYXZlIGJlZW4gdW5hYmxlIHRvIGdldCBpbiB0b3VjaCB3aXRoXFxyXFxuICAgICAgICAgICAgeW91LlxcclxcbiAgICAgICAgICAgIDxici8+PGJyLz5cXHJcXG4gICAgICAgICAgICBBIHRydXN0ZWQgY29udGFjdCBtYXkgYmUgYSBmYW1pbHkgbWVtYmVyLCBhdHRvcm5leSwgYWNjb3VudGFudCBvciBhbm90aGVyIHRoaXJkLXBhcnR5IHdobyB5b3UgYmVsaWV2ZSB3b3VsZFxcclxcbiAgICAgICAgICAgIHJlc3BlY3QgeW91ciBwcml2YWN5IGFuZCBrbm93IGhvdyB0byBoYW5kbGUgdGhlIHJlc3BvbnNpYmlsaXR5LlxcclxcbiAgICAgICAgICAgIFRoZSB0cnVzdGVkIHBlcnNvbiBzaG91bGQgYmUgMTggeWVhcnMgb2xkIG9yIG9sZGVyLlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImdpdmVuX25hbWVcXFwiPkxlZ2FsIGdpdmVuIG5hbWUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcImdpdmVuX25hbWVcXFwiIG5hbWU9XFxcImdpdmVuX25hbWVcXFwiLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJmYW1pbHlfbmFtZVxcXCI+TGVnYWwgZmFtaWx5IG5hbWUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcImZhbWlseV9uYW1lXFxcIiBuYW1lPVxcXCJmYW1pbHlfbmFtZVxcXCIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIElmIHlvdSBmaWxsIGluIG5hbWUsIHlvdSBhcmUgcmVxdWlyZWQgdG8gZmlsbCBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZywgZW1haWwsIHBob25lIG9yIGFkZHJlc3NcXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJjb250YWN0X21pc3NpbmdfaW5mb1xcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImVtYWlsX2FkZHJlc3NcXFwiPkVtYWlsIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJlbWFpbF9hZGRyZXNzXFxcIiB0eXBlPVxcXCJlbWFpbFxcXCIgbmFtZT1cXFwiZW1haWxfYWRkcmVzc1xcXCIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInBob25lX251bWJlclxcXCI+UGhvbmUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XFxcInBob25lX251bWJlclxcXCIgdHlwZT1cXFwidGVsXFxcIiBuYW1lPVxcXCJwaG9uZV9udW1iZXJcXFwiLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCI+QWRkcmVzcyBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwic3RyZWV0X2FkZHJlc3NcXFwiIG5hbWU9XFxcInN0cmVldF9hZGRyZXNzXFxcIi8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiY2l0eVxcXCI+Q2l0eSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwiY2l0eVxcXCIgbmFtZT1cXFwiY2l0eVxcXCIvPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcInN0YXRlXFxcIj5TdGF0ZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cXFwic3RhdGVcXFwiIG5hbWU9XFxcInN0YXRlXFxcIi8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwicG9zdGFsX2NvZGVcXFwiPlBvc3RhbCBjb2RlIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IGlkPVxcXCJwb3N0YWxfY29kZVxcXCIgbmFtZT1cXFwicG9zdGFsX2NvZGVcXFwiLz5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb3VudHJ5XFxcIj5Db3VudHJ5IG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiY291bnRyeVxcXCIgcmVxdWlyZWQgbmFtZT1cXFwiY291bnRyeVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwie3tjb2RlfX1cXFwiPnt7bmFtZX19PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcImt5Y0VkaXROYW1lRXJyb3JcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJzdWJtaXRcXFwiIGlkPVxcXCJ0cnVzdGVkQ29udGFjdFN1Ym1pdFxcXCI+U3VibWl0PC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9mb3JtPlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIENvdW50cnlIZWxwZXIge1xyXG4gICAgc3RhdGljIENvdW50cmllcyA9IFtcclxuICAgICAgICB7XCJuYW1lXCI6IFwiVW5pdGVkIFN0YXRlcyBvZiBBbWVyaWNhXCIsIFwiY29kZVwiOiBcIlVTQVwifSxcclxuICAgICAgICB7XCJuYW1lXCI6IFwiVW5pdGVkIEtpbmdkb21cIiwgXCJjb2RlXCI6IFwiR0JSXCJ9LFxyXG4gICAgICAgIHtcIm5hbWVcIjogXCJBZmdoYW5pc3RhblwiLCBcImNvZGVcIjogXCJBRkdcIn0sIHtcIm5hbWVcIjogXCJBbGJhbmlhXCIsIFwiY29kZVwiOiBcIkFMQlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBbGdlcmlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkRaQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkFtZXJpY2FuIFNhbW9hXCIsIFwiY29kZVwiOiBcIkFTTVwifSwge1wibmFtZVwiOiBcIkFuZG9ycmFcIiwgXCJjb2RlXCI6IFwiQU5EXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkFuZ29sYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJBR09cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJBbmd1aWxsYVwiLCBcImNvZGVcIjogXCJBSUFcIn0sIHtcIm5hbWVcIjogXCJBbnRhcmN0aWNhXCIsIFwiY29kZVwiOiBcIkFUQVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBbnRpZ3VhIGFuZCBCYXJidWRhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkFUR1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkFyZ2VudGluYVwiLCBcImNvZGVcIjogXCJBUkdcIn0sIHtcIm5hbWVcIjogXCJBcm1lbmlhXCIsIFwiY29kZVwiOiBcIkFSTVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJBcnViYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJBQldcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJBdXN0cmFsaWFcIiwgXCJjb2RlXCI6IFwiQVVTXCJ9LCB7XCJuYW1lXCI6IFwiQXVzdHJpYVwiLCBcImNvZGVcIjogXCJBVVRcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQXplcmJhaWphblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJBWkVcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCLDhWxhbmQgSXNsYW5kc1wiLCBcImNvZGVcIjogXCJBTEFcIn0sIHtcIm5hbWVcIjogXCJCYWhhbWFzXCIsIFwiY29kZVwiOiBcIkJIU1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCYWhyYWluXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkJIUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkJhbmdsYWRlc2hcIiwgXCJjb2RlXCI6IFwiQkdEXCJ9LCB7XCJuYW1lXCI6IFwiQmFyYmFkb3NcIiwgXCJjb2RlXCI6IFwiQlJCXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkJlbGFydXNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQkxSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQmVsZ2l1bVwiLCBcImNvZGVcIjogXCJCRUxcIn0sIHtcIm5hbWVcIjogXCJCZWxpemVcIiwgXCJjb2RlXCI6IFwiQkxaXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkJlbmluXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkJFTlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkJlcm11ZGFcIiwgXCJjb2RlXCI6IFwiQk1VXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkJodXRhblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJCVE5cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJCb2xpdmlhIChQbHVyaW5hdGlvbmFsIFN0YXRlIG9mKVwiLCBcImNvZGVcIjogXCJCT0xcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQm9uYWlyZSwgU2ludCBFdXN0YXRpdXMgYW5kIFNhYmFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQkVTXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQm9zbmlhIGFuZCBIZXJ6ZWdvdmluYVwiLCBcImNvZGVcIjogXCJCSUhcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQm90c3dhbmFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQldBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQm91dmV0IElzbGFuZFwiLCBcImNvZGVcIjogXCJCVlRcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQnJhemlsXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkJSQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkJyaXRpc2ggSW5kaWFuIE9jZWFuIFRlcnJpdG9yeVwiLCBcImNvZGVcIjogXCJJT1RcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQnJ1bmVpIERhcnVzc2FsYW1cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQlJOXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQnVsZ2FyaWFcIiwgXCJjb2RlXCI6IFwiQkdSXCJ9LCB7XCJuYW1lXCI6IFwiQnVya2luYSBGYXNvXCIsIFwiY29kZVwiOiBcIkJGQVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJCdXJ1bmRpXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkJESVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkNhYm8gVmVyZGVcIiwgXCJjb2RlXCI6IFwiQ1BWXCJ9LCB7XCJuYW1lXCI6IFwiQ2FtYm9kaWFcIiwgXCJjb2RlXCI6IFwiS0hNXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkNhbWVyb29uXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkNNUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkNhbmFkYVwiLCBcImNvZGVcIjogXCJDQU5cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ2F5bWFuIElzbGFuZHNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQ1lNXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ2VudHJhbCBBZnJpY2FuIFJlcHVibGljXCIsIFwiY29kZVwiOiBcIkNBRlwifSwge1wibmFtZVwiOiBcIkNoYWRcIiwgXCJjb2RlXCI6IFwiVENEXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkNoaWxlXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkNITFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkNoaW5hXCIsIFwiY29kZVwiOiBcIkNITlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJDaHJpc3RtYXMgSXNsYW5kXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkNYUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkNvY29zIChLZWVsaW5nKSBJc2xhbmRzXCIsIFwiY29kZVwiOiBcIkNDS1wifSwge1wibmFtZVwiOiBcIkNvbG9tYmlhXCIsIFwiY29kZVwiOiBcIkNPTFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJDb21vcm9zXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkNPTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkNvbmdvICh0aGUgRGVtb2NyYXRpYyBSZXB1YmxpYyBvZiB0aGUpXCIsIFwiY29kZVwiOiBcIkNPRFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJDb25nb1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJDT0dcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJDb29rIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiQ09LXCJ9LCB7XCJuYW1lXCI6IFwiQ29zdGEgUmljYVwiLCBcImNvZGVcIjogXCJDUklcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiQ3JvYXRpYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJIUlZcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJDdWJhXCIsIFwiY29kZVwiOiBcIkNVQlwifSwge1wibmFtZVwiOiBcIkN1cmHDp2FvXCIsIFwiY29kZVwiOiBcIkNVV1wifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJDeXBydXNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQ1lQXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiQ3plY2hpYVwiLCBcImNvZGVcIjogXCJDWkVcIn0sIHtcIm5hbWVcIjogXCJDw7R0ZSBkJ0l2b2lyZVwiLCBcImNvZGVcIjogXCJDSVZcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRGVubWFya1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJETktcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJEamlib3V0aVwiLCBcImNvZGVcIjogXCJESklcIn0sIHtcIm5hbWVcIjogXCJEb21pbmljYVwiLCBcImNvZGVcIjogXCJETUFcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRG9taW5pY2FuIFJlcHVibGljXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkRPTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkVjdWFkb3JcIiwgXCJjb2RlXCI6IFwiRUNVXCJ9LCB7XCJuYW1lXCI6IFwiRWd5cHRcIiwgXCJjb2RlXCI6IFwiRUdZXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkVsIFNhbHZhZG9yXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNMVlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkVxdWF0b3JpYWwgR3VpbmVhXCIsIFwiY29kZVwiOiBcIkdOUVwifSwge1wibmFtZVwiOiBcIkVyaXRyZWFcIiwgXCJjb2RlXCI6IFwiRVJJXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkVzdG9uaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiRVNUXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiRXN3YXRpbmlcIiwgXCJjb2RlXCI6IFwiU1daXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkV0aGlvcGlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkVUSFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkZhbGtsYW5kIElzbGFuZHMgW01hbHZpbmFzXVwiLCBcImNvZGVcIjogXCJGTEtcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiRmFyb2UgSXNsYW5kc1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJGUk9cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJGaWppXCIsIFwiY29kZVwiOiBcIkZKSVwifSwge1wibmFtZVwiOiBcIkZpbmxhbmRcIiwgXCJjb2RlXCI6IFwiRklOXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkZyYW5jZVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJGUkFcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJGcmVuY2ggR3VpYW5hXCIsIFwiY29kZVwiOiBcIkdVRlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJGcmVuY2ggUG9seW5lc2lhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlBZRlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkZyZW5jaCBTb3V0aGVybiBUZXJyaXRvcmllc1wiLCBcImNvZGVcIjogXCJBVEZcIn0sIHtcIm5hbWVcIjogXCJHYWJvblwiLCBcImNvZGVcIjogXCJHQUJcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2FtYmlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkdNQlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkdlb3JnaWFcIiwgXCJjb2RlXCI6IFwiR0VPXCJ9LCB7XCJuYW1lXCI6IFwiR2VybWFueVwiLCBcImNvZGVcIjogXCJERVVcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiR2hhbmFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiR0hBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiR2licmFsdGFyXCIsIFwiY29kZVwiOiBcIkdJQlwifSwge1wibmFtZVwiOiBcIkdyZWVjZVwiLCBcImNvZGVcIjogXCJHUkNcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiR3JlZW5sYW5kXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkdSTFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkdyZW5hZGFcIiwgXCJjb2RlXCI6IFwiR1JEXCJ9LCB7XCJuYW1lXCI6IFwiR3VhZGVsb3VwZVwiLCBcImNvZGVcIjogXCJHTFBcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiR3VhbVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJHVU1cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJHdWF0ZW1hbGFcIiwgXCJjb2RlXCI6IFwiR1RNXCJ9LCB7XCJuYW1lXCI6IFwiR3Vlcm5zZXlcIiwgXCJjb2RlXCI6IFwiR0dZXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkd1aW5lYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJHSU5cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJHdWluZWEtQmlzc2F1XCIsIFwiY29kZVwiOiBcIkdOQlwifSwge1wibmFtZVwiOiBcIkd1eWFuYVwiLCBcImNvZGVcIjogXCJHVVlcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiSGFpdGlcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiSFRJXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiSGVhcmQgSXNsYW5kIGFuZCBNY0RvbmFsZCBJc2xhbmRzXCIsIFwiY29kZVwiOiBcIkhNRFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJIb2x5IFNlZVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJWQVRcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJIb25kdXJhc1wiLCBcImNvZGVcIjogXCJITkRcIn0sIHtcIm5hbWVcIjogXCJIb25nIEtvbmdcIiwgXCJjb2RlXCI6IFwiSEtHXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIkh1bmdhcnlcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiSFVOXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiSWNlbGFuZFwiLCBcImNvZGVcIjogXCJJU0xcIn0sIHtcIm5hbWVcIjogXCJJbmRpYVwiLCBcImNvZGVcIjogXCJJTkRcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiSW5kb25lc2lhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIklETlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIklyYW4gKElzbGFtaWMgUmVwdWJsaWMgb2YpXCIsIFwiY29kZVwiOiBcIklSTlwifSwge1wibmFtZVwiOiBcIklyYXFcIiwgXCJjb2RlXCI6IFwiSVJRXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIklyZWxhbmRcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiSVJMXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiSXNsZSBvZiBNYW5cIiwgXCJjb2RlXCI6IFwiSU1OXCJ9LCB7XCJuYW1lXCI6IFwiSXNyYWVsXCIsIFwiY29kZVwiOiBcIklTUlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJJdGFseVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJJVEFcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJKYW1haWNhXCIsIFwiY29kZVwiOiBcIkpBTVwifSwge1wibmFtZVwiOiBcIkphcGFuXCIsIFwiY29kZVwiOiBcIkpQTlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJKZXJzZXlcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiSkVZXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiSm9yZGFuXCIsIFwiY29kZVwiOiBcIkpPUlwifSwge1wibmFtZVwiOiBcIkthemFraHN0YW5cIiwgXCJjb2RlXCI6IFwiS0FaXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIktlbnlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIktFTlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIktpcmliYXRpXCIsIFwiY29kZVwiOiBcIktJUlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJLb3JlYSAodGhlIERlbW9jcmF0aWMgUGVvcGxlJ3MgUmVwdWJsaWMgb2YpXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlBSS1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIktvcmVhICh0aGUgUmVwdWJsaWMgb2YpXCIsIFwiY29kZVwiOiBcIktPUlwifSwge1wibmFtZVwiOiBcIkt1d2FpdFwiLCBcImNvZGVcIjogXCJLV1RcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiS3lyZ3l6c3RhblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJLR1pcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJMYW8gUGVvcGxlJ3MgRGVtb2NyYXRpYyBSZXB1YmxpY1wiLCBcImNvZGVcIjogXCJMQU9cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTGF0dmlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIkxWQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIkxlYmFub25cIiwgXCJjb2RlXCI6IFwiTEJOXCJ9LCB7XCJuYW1lXCI6IFwiTGVzb3Rob1wiLCBcImNvZGVcIjogXCJMU09cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTGliZXJpYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJMQlJcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJMaWJ5YVwiLCBcImNvZGVcIjogXCJMQllcIn0sIHtcIm5hbWVcIjogXCJMaWVjaHRlbnN0ZWluXCIsIFwiY29kZVwiOiBcIkxJRVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJMaXRodWFuaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTFRVXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTHV4ZW1ib3VyZ1wiLCBcImNvZGVcIjogXCJMVVhcIn0sIHtcIm5hbWVcIjogXCJNYWNhb1wiLCBcImNvZGVcIjogXCJNQUNcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWFkYWdhc2NhclwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJNREdcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJNYWxhd2lcIiwgXCJjb2RlXCI6IFwiTVdJXCJ9LCB7XCJuYW1lXCI6IFwiTWFsYXlzaWFcIiwgXCJjb2RlXCI6IFwiTVlTXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk1hbGRpdmVzXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk1EVlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk1hbGlcIiwgXCJjb2RlXCI6IFwiTUxJXCJ9LCB7XCJuYW1lXCI6IFwiTWFsdGFcIiwgXCJjb2RlXCI6IFwiTUxUXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk1hcnNoYWxsIElzbGFuZHNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTUhMXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTWFydGluaXF1ZVwiLCBcImNvZGVcIjogXCJNVFFcIn0sIHtcIm5hbWVcIjogXCJNYXVyaXRhbmlhXCIsIFwiY29kZVwiOiBcIk1SVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJNYXVyaXRpdXNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTVVTXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTWF5b3R0ZVwiLCBcImNvZGVcIjogXCJNWVRcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTWV4aWNvXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk1FWFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk1pY3JvbmVzaWEgKEZlZGVyYXRlZCBTdGF0ZXMgb2YpXCIsIFwiY29kZVwiOiBcIkZTTVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJNb2xkb3ZhICh0aGUgUmVwdWJsaWMgb2YpXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk1EQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk1vbmFjb1wiLCBcImNvZGVcIjogXCJNQ09cIn0sIHtcIm5hbWVcIjogXCJNb25nb2xpYVwiLCBcImNvZGVcIjogXCJNTkdcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTW9udGVuZWdyb1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJNTkVcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJNb250c2VycmF0XCIsIFwiY29kZVwiOiBcIk1TUlwifSwge1wibmFtZVwiOiBcIk1vcm9jY29cIiwgXCJjb2RlXCI6IFwiTUFSXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk1vemFtYmlxdWVcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTU9aXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTXlhbm1hclwiLCBcImNvZGVcIjogXCJNTVJcIn0sIHtcIm5hbWVcIjogXCJOYW1pYmlhXCIsIFwiY29kZVwiOiBcIk5BTVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJOYXVydVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJOUlVcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJOZXBhbFwiLCBcImNvZGVcIjogXCJOUExcIn0sIHtcIm5hbWVcIjogXCJOZXRoZXJsYW5kc1wiLCBcImNvZGVcIjogXCJOTERcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTmV3IENhbGVkb25pYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJOQ0xcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJOZXcgWmVhbGFuZFwiLCBcImNvZGVcIjogXCJOWkxcIn0sIHtcIm5hbWVcIjogXCJOaWNhcmFndWFcIiwgXCJjb2RlXCI6IFwiTklDXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIk5pZ2VyXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIk5FUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIk5pZ2VyaWFcIiwgXCJjb2RlXCI6IFwiTkdBXCJ9LCB7XCJuYW1lXCI6IFwiTml1ZVwiLCBcImNvZGVcIjogXCJOSVVcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiTm9yZm9sayBJc2xhbmRcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTkZLXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiTm9ydGhlcm4gTWFyaWFuYSBJc2xhbmRzXCIsIFwiY29kZVwiOiBcIk1OUFwifSwge1wibmFtZVwiOiBcIk5vcndheVwiLCBcImNvZGVcIjogXCJOT1JcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiT21hblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJPTU5cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJQYWtpc3RhblwiLCBcImNvZGVcIjogXCJQQUtcIn0sIHtcIm5hbWVcIjogXCJQYWxhdVwiLCBcImNvZGVcIjogXCJQTFdcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiUGFsZXN0aW5lLCBTdGF0ZSBvZlwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJQU0VcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJQYW5hbWFcIiwgXCJjb2RlXCI6IFwiUEFOXCJ9LCB7XCJuYW1lXCI6IFwiUGFwdWEgTmV3IEd1aW5lYVwiLCBcImNvZGVcIjogXCJQTkdcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiUGFyYWd1YXlcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiUFJZXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiUGVydVwiLCBcImNvZGVcIjogXCJQRVJcIn0sIHtcIm5hbWVcIjogXCJQaGlsaXBwaW5lc1wiLCBcImNvZGVcIjogXCJQSExcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiUGl0Y2Fpcm5cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiUENOXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiUG9sYW5kXCIsIFwiY29kZVwiOiBcIlBPTFwifSwge1wibmFtZVwiOiBcIlBvcnR1Z2FsXCIsIFwiY29kZVwiOiBcIlBSVFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJQdWVydG8gUmljb1wiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJQUklcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJRYXRhclwiLCBcImNvZGVcIjogXCJRQVRcIn0sIHtcIm5hbWVcIjogXCJSZXB1YmxpYyBvZiBOb3J0aCBNYWNlZG9uaWFcIiwgXCJjb2RlXCI6IFwiTUtEXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlJvbWFuaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiUk9VXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiUnVzc2lhbiBGZWRlcmF0aW9uXCIsIFwiY29kZVwiOiBcIlJVU1wifSwge1wibmFtZVwiOiBcIlJ3YW5kYVwiLCBcImNvZGVcIjogXCJSV0FcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiUsOpdW5pb25cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiUkVVXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2FpbnQgQmFydGjDqWxlbXlcIiwgXCJjb2RlXCI6IFwiQkxNXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNhaW50IEhlbGVuYSwgQXNjZW5zaW9uIGFuZCBUcmlzdGFuIGRhIEN1bmhhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNITlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlNhaW50IEtpdHRzIGFuZCBOZXZpc1wiLCBcImNvZGVcIjogXCJLTkFcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2FpbnQgTHVjaWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiTENBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2FpbnQgTWFydGluIChGcmVuY2ggcGFydClcIiwgXCJjb2RlXCI6IFwiTUFGXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNhaW50IFBpZXJyZSBhbmQgTWlxdWVsb25cIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU1BNXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2FpbnQgVmluY2VudCBhbmQgdGhlIEdyZW5hZGluZXNcIiwgXCJjb2RlXCI6IFwiVkNUXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNhbW9hXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIldTTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlNhbiBNYXJpbm9cIiwgXCJjb2RlXCI6IFwiU01SXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNhbyBUb21lIGFuZCBQcmluY2lwZVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJTVFBcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTYXVkaSBBcmFiaWFcIiwgXCJjb2RlXCI6IFwiU0FVXCJ9LCB7XCJuYW1lXCI6IFwiU2VuZWdhbFwiLCBcImNvZGVcIjogXCJTRU5cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2VyYmlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNSQlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlNleWNoZWxsZXNcIiwgXCJjb2RlXCI6IFwiU1lDXCJ9LCB7XCJuYW1lXCI6IFwiU2llcnJhIExlb25lXCIsIFwiY29kZVwiOiBcIlNMRVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTaW5nYXBvcmVcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU0dQXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2ludCBNYWFydGVuIChEdXRjaCBwYXJ0KVwiLCBcImNvZGVcIjogXCJTWE1cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU2xvdmFraWFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU1ZLXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU2xvdmVuaWFcIiwgXCJjb2RlXCI6IFwiU1ZOXCJ9LCB7XCJuYW1lXCI6IFwiU29sb21vbiBJc2xhbmRzXCIsIFwiY29kZVwiOiBcIlNMQlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJTb21hbGlhXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNPTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlNvdXRoIEFmcmljYVwiLCBcImNvZGVcIjogXCJaQUZcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU291dGggR2VvcmdpYSBhbmQgdGhlIFNvdXRoIFNhbmR3aWNoIElzbGFuZHNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiU0dTXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiU291dGggU3VkYW5cIiwgXCJjb2RlXCI6IFwiU1NEXCJ9LCB7XCJuYW1lXCI6IFwiU3BhaW5cIiwgXCJjb2RlXCI6IFwiRVNQXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlNyaSBMYW5rYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJMS0FcIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTdWRhblwiLCBcImNvZGVcIjogXCJTRE5cIn0sIHtcIm5hbWVcIjogXCJTdXJpbmFtZVwiLCBcImNvZGVcIjogXCJTVVJcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiU3ZhbGJhcmQgYW5kIEphbiBNYXllblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJTSk1cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJTd2VkZW5cIiwgXCJjb2RlXCI6IFwiU1dFXCJ9LCB7XCJuYW1lXCI6IFwiU3dpdHplcmxhbmRcIiwgXCJjb2RlXCI6IFwiQ0hFXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlN5cmlhbiBBcmFiIFJlcHVibGljXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlNZUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlRhaXdhbiAoUHJvdmluY2Ugb2YgQ2hpbmEpXCIsIFwiY29kZVwiOiBcIlRXTlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJUYWppa2lzdGFuXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlRKS1wiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlRhbnphbmlhLCBVbml0ZWQgUmVwdWJsaWMgb2ZcIiwgXCJjb2RlXCI6IFwiVFpBXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlRoYWlsYW5kXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlRIQVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlRpbW9yLUxlc3RlXCIsIFwiY29kZVwiOiBcIlRMU1wifSwge1wibmFtZVwiOiBcIlRvZ29cIiwgXCJjb2RlXCI6IFwiVEdPXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlRva2VsYXVcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVEtMXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVG9uZ2FcIiwgXCJjb2RlXCI6IFwiVE9OXCJ9LCB7XCJuYW1lXCI6IFwiVHJpbmlkYWQgYW5kIFRvYmFnb1wiLCBcImNvZGVcIjogXCJUVE9cIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVHVuaXNpYVwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJUVU5cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJUdXJrZXlcIiwgXCJjb2RlXCI6IFwiVFVSXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlR1cmttZW5pc3RhblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJUS01cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJUdXJrcyBhbmQgQ2FpY29zIElzbGFuZHNcIiwgXCJjb2RlXCI6IFwiVENBXCJ9LCB7XCJuYW1lXCI6IFwiVHV2YWx1XCIsIFwiY29kZVwiOiBcIlRVVlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJVZ2FuZGFcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVUdBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVWtyYWluZVwiLCBcImNvZGVcIjogXCJVS1JcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVW5pdGVkIEFyYWIgRW1pcmF0ZXNcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiQVJFXCJcclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlVuaXRlZCBLaW5nZG9tIG9mIEdyZWF0IEJyaXRhaW4gYW5kIE5vcnRoZXJuIElyZWxhbmRcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiR0JSXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVW5pdGVkIFN0YXRlcyBNaW5vciBPdXRseWluZyBJc2xhbmRzXCIsIFwiY29kZVwiOiBcIlVNSVwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJVbml0ZWQgU3RhdGVzIG9mIEFtZXJpY2FcIixcclxuICAgICAgICAgICAgXCJjb2RlXCI6IFwiVVNBXCJcclxuICAgICAgICB9LCB7XCJuYW1lXCI6IFwiVXJ1Z3VheVwiLCBcImNvZGVcIjogXCJVUllcIn0sIHtcIm5hbWVcIjogXCJVemJla2lzdGFuXCIsIFwiY29kZVwiOiBcIlVaQlwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJWYW51YXR1XCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlZVVFwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlZlbmV6dWVsYSAoQm9saXZhcmlhbiBSZXB1YmxpYyBvZilcIiwgXCJjb2RlXCI6IFwiVkVOXCJ9LCB7XHJcbiAgICAgICAgICAgIFwibmFtZVwiOiBcIlZpZXQgTmFtXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlZOTVwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIlZpcmdpbiBJc2xhbmRzIChCcml0aXNoKVwiLCBcImNvZGVcIjogXCJWR0JcIn0sIHtcclxuICAgICAgICAgICAgXCJuYW1lXCI6IFwiVmlyZ2luIElzbGFuZHMgKFUuUy4pXCIsXHJcbiAgICAgICAgICAgIFwiY29kZVwiOiBcIlZJUlwiXHJcbiAgICAgICAgfSwge1wibmFtZVwiOiBcIldhbGxpcyBhbmQgRnV0dW5hXCIsIFwiY29kZVwiOiBcIldMRlwifSwge1wibmFtZVwiOiBcIldlc3Rlcm4gU2FoYXJhXCIsIFwiY29kZVwiOiBcIkVTSFwifSwge1xyXG4gICAgICAgICAgICBcIm5hbWVcIjogXCJZZW1lblwiLFxyXG4gICAgICAgICAgICBcImNvZGVcIjogXCJZRU1cIlxyXG4gICAgICAgIH0sIHtcIm5hbWVcIjogXCJaYW1iaWFcIiwgXCJjb2RlXCI6IFwiWk1CXCJ9LCB7XCJuYW1lXCI6IFwiWmltYmFid2VcIiwgXCJjb2RlXCI6IFwiWldFXCJ9XHJcbiAgICBdO1xyXG59IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgS3ljRWRpdFRydXN0ZWRDb250YWN0SHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNFZGl0VHJ1c3RlZENvbnRhY3QuaHRtbCc7XHJcbmltcG9ydCBDb3VudHJ5SGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0NvdW50cnlIZWxwZXJcIjtcclxuaW1wb3J0IEZvcm1IZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvRm9ybUhlbHBlclwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRWRpdFRydXN0ZWRDb250YWN0IHtcclxuXHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93KCkge1xyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBhY2NvdW50ID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0QWNjb3VudCgpO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljRWRpdFRydXN0ZWRDb250YWN0SHRtbCk7XHJcbiAgICAgICAgdGhpcy5tb2RhbC5zaG93TW9kYWwoJ0VkaXQgdHJ1c3RlZCBjb250YWN0JywgdGVtcGxhdGUoe2NvdW50cmllczogQ291bnRyeUhlbHBlci5Db3VudHJpZXN9KSlcclxuXHJcbiAgICAgICAgaWYgKGFjY291bnQudHJ1c3RlZF9jb250YWN0KSB7XHJcbiAgICAgICAgICAgIGxldCBjb250YWN0UHJvcGVydGllcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFjY291bnQudHJ1c3RlZF9jb250YWN0KTtcclxuICAgICAgICAgICAgRm9ybUhlbHBlci5maWxsSW5wdXRzKGNvbnRhY3RQcm9wZXJ0aWVzLCBhY2NvdW50LnRydXN0ZWRfY29udGFjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG5cclxuXHJcbiAgICAgICAgbGV0IHRydXN0ZWRDb250YWN0U3VibWl0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRDb250YWN0U3VibWl0Jyk7XHJcbiAgICAgICAgdHJ1c3RlZENvbnRhY3RTdWJtaXQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghRm9ybUhlbHBlci52YWxpZGF0ZSgnI2t5Y1RydXN0ZWRDb250YWN0Rm9ybScpKSByZXR1cm47XHJcbiAgICAgICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyh0cnVzdGVkQ29udGFjdFN1Ym1pdCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gRm9ybUhlbHBlci5nZXRQYXJhbXMoJyNreWNUcnVzdGVkQ29udGFjdEZvcm0nKTtcclxuXHJcbiAgICAgICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZShNb3JhbGlzKTtcclxuICAgICAgICAgICAgYXdhaXQgdXNlclNlcnZpY2UudXBkYXRlVHJ1c3RlZENvbnRhY3QocGFyYW1zKS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dFcnJvcihyZXNwb25zZS5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYXNvbi5tZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IoSlNPTi5wYXJzZShyZWFzb24ubWVzc2FnZSkubWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Vycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2hvd0Vycm9yKG1lc3NhZ2U6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBreWNFZGl0TmFtZUVycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2t5Y0VkaXROYW1lRXJyb3InKTtcclxuICAgICAgICBpZiAoIWt5Y0VkaXROYW1lRXJyb3IpIHJldHVybjtcclxuXHJcbiAgICAgICAga3ljRWRpdE5hbWVFcnJvci5pbm5lckhUTUwgPSBtZXNzYWdlO1xyXG4gICAgICAgIGt5Y0VkaXROYW1lRXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IENvbnRyYWN0SW5mbyBmcm9tIFwiLi4vLi4vY29udHJhY3RzL0NvbnRyYWN0SW5mb1wiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xyXG5pbXBvcnQgQmxvY2tjaGFpbkVycm9yIGZyb20gXCIuLi8uLi9lcnJvcnMvQmxvY2tjaGFpbkVycm9yXCI7XHJcbmltcG9ydCBEYXRlSGVscGVyIGZyb20gJy4uLy4uL3V0aWwvRGF0ZUhlbHBlcic7XHJcbmltcG9ydCBCbG9ja2NoYWluU2VydmljZSBmcm9tIFwiLi9CbG9ja2NoYWluU2VydmljZVwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVVTRFNlcnZpY2UgZXh0ZW5kcyBCbG9ja2NoYWluU2VydmljZSB7XHJcbiAgICBwcml2YXRlIHN0YXRpYyBBVVNESW5mbzogYW55O1xyXG4gICAgcHVibGljIHN0YXRpYyBsYXN0VXBkYXRlPzogRGF0ZTtcclxuICAgIHByaXZhdGUgc3RhdGljIGFVU0RBbW91bnQ/OiBCaWdOdW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICBzdXBlcihtb3JhbGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRBVVNEQmFsYW5jZU9mKGV0aEFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8QmlnTnVtYmVyPiB7XHJcbiAgICAgICAgaWYgKEFVU0RTZXJ2aWNlLmxhc3RVcGRhdGUgJiYgQVVTRFNlcnZpY2UuYVVTREFtb3VudCAmJlxyXG4gICAgICAgICAgICAhRGF0ZUhlbHBlci5pc09sZGVyVGhlbihBVVNEU2VydmljZS5sYXN0VXBkYXRlLCA1KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQVVTRFNlcnZpY2UuYVVTREFtb3VudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBvcHRpb25zID0gYXdhaXQgdGhpcy5nZXRPcHRpb25zKFwiYmFsYW5jZU9mXCIsIHtcclxuICAgICAgICAgICAgYWNjb3VudDogZXRoQWRkcmVzc1xyXG4gICAgICAgIH0pO1xyXG5pZiAoIXRoaXMubW9yYWxpcy5pc1dlYjNFbmFibGVkKCkpIHtcclxuICAgIC8vYXdhaXQgdGhpcy5tb3JhbGlzLmVuYWJsZVdlYjMoKTtcclxufVxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVGdW5jdGlvbihvcHRpb25zKS50aGVuKGJhbGFuY2VPZiA9PiB7XHJcbiAgICAgICAgICAgIGxldCBhbW91bnQgPSB0aGlzLm1vcmFsaXMuVW5pdHMuRnJvbVdlaShiYWxhbmNlT2YudG9TdHJpbmcoKSwgMTgpO1xyXG4gICAgICAgICAgICBBVVNEU2VydmljZS5hVVNEQW1vdW50ID0gbmV3IEJpZ051bWJlcihhbW91bnQpO1xyXG4gICAgICAgICAgICBBVVNEU2VydmljZS5sYXN0VXBkYXRlID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBBVVNEU2VydmljZS5hVVNEQW1vdW50O1xyXG4gICAgICAgIH0pLmNhdGNoKChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgbGV0IGJsb2NrY2hhaW5FcnJvciA9IG5ldyBCbG9ja2NoYWluRXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgRXJyb3JJbmZvLnJlcG9ydChibG9ja2NoYWluRXJyb3IpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcigwKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgdHJhbnNmZXIoc3ltYm9sQWRkcmVzcyA6IHN0cmluZywgcXR5IDogQmlnTnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0T3B0aW9ucygndHJhbnNmZXInLCB7XHJcbiAgICAgICAgICAgIHRvOiBzeW1ib2xBZGRyZXNzLFxyXG4gICAgICAgICAgICBhbW91bnQ6IE1vcmFsaXMuVW5pdHMuVG9rZW4ocXR5LnRvU3RyaW5nKCksIDE4KVxyXG4gICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBibG9ja2NoYWluRXJyb3IgPSBuZXcgQmxvY2tjaGFpbkVycm9yKHJlYXNvbik7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvckluZm8ucmVwb3J0KGJsb2NrY2hhaW5FcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBBVVNEU2VydmljZS5hVVNEQW1vdW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIEFVU0RTZXJ2aWNlLmxhc3RVcGRhdGUgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldE9wdGlvbnMoZnVuY3Rpb25OYW1lIDogc3RyaW5nLCBwYXJhbXMgOiBhbnkpIHtcclxuICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbygpO1xyXG4gICAgICAgIGxldCBhYmkgPSBhd2FpdCB0aGlzLmdldEFVc2RBYmkoKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzOiBjb250cmFjdEluZm8uQVVTRF9BRERSRVNTLFxyXG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcclxuICAgICAgICAgICAgYWJpOiBhYmksXHJcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldEFVc2RBYmkoKSB7XHJcbiAgICAgICAgaWYgKEFVU0RTZXJ2aWNlLkFVU0RJbmZvKSByZXR1cm4gQVVTRFNlcnZpY2UuQVVTREluZm8uYWJpO1xyXG5cclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnLi4vYWJpL2FVU0QuanNvbicpO1xyXG4gICAgICAgIEFVU0RTZXJ2aWNlLkFVU0RJbmZvID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiBBVVNEU2VydmljZS5BVVNESW5mby5hYmk7XHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YXJ0aWNsZT5cXHJcXG4gICAgPGRpdiBpZD1cXFwiYmVmb3JlRnVuZGluZ1xcXCI+XFxyXFxuICAgICAgICBUbyB1c2UgbGltaW5hbC5tYXJrZXQgeW91IG5lZWQgc29tZSBhVVNELiBhVVNEIGlzIHRoZSBzYW1lIHZhbHVlIGFzIFVTRC5cXHJcXG4gICAgICAgIFdlIGNhbiBnaXZlIHlvdSBzb21lIGFVU0QgKHRoaXMgaXMgYWxsIGZha2UgbW9uZXkpLCBzbyB5b3UgY2FuIHBsYXkgd2l0aCB0aGUgc3lzdGVtLlxcclxcblxcclxcbiAgICAgICAgRmlyc3QsIHlvdSBuZWVkIHRvIGFkZCBhVVNEIHRvIHlvdSB3YWxsZXQuXFxyXFxuXFxyXFxuICAgICAgICA8YnV0dG9uIGlkPVxcXCJhZGRUb2tlblRvV2FsbGV0XFxcIj5BZGQgYVVTRCB0byB3YWxsZXQ8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxibG9ja3F1b3RlIGlkPVxcXCJuZWVkVG9Db3B5XFxcIiBjbGFzcz1cXFwiZC1ub25lXFxcIj5cXHJcXG4gICAgICAgICAgICBJZiB0aGUgYnV0dG9uIGRpZG4ndCB3b3JrLCB5b3UgY2FuIGNvcHkgdGhlIGFkZHJlc3MgaGVyZSBhbmQgaW1wb3J0IGl0IGludG8geW91ciB3YWxsZXRcXHJcXG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9XFxcInt7YVVTREFkZHJlc3N9fVxcXCIvPlxcclxcbiAgICAgICAgPC9ibG9ja3F1b3RlPlxcclxcbiAgICAgICAgV2hlbiB5b3UgaGF2ZSBhVVNEIHRvIHlvdSB3YWxsZXQsIHlvdSBjYW4gcmVxdWVzdCBzb21lIG1vbmV5IHRvIHRyYWRlIHdpdGguXFxyXFxuXFxyXFxuICAgICAgICA8YnV0dG9uIGlkPVxcXCJyZXF1ZXN0RmFrZUFVU0RcXFwiPlJlcXVlc3Qgc29tZSBhVVNEPC9idXR0b24+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ3YXJuaW5nQmFyIG5vdGlmaWNhdGlvbkJhciBkLW5vbmVcXFwiIGlkPVxcXCJmdW5kaW5nRXJyb3JcXFwiPjwvZGl2PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwiYWZ0ZXJGdW5kaW5nXFxcIiBjbGFzcz1cXFwiZC1ub25lIGNlbnRlclxcXCI+XFxyXFxuICAgICAgICBXZSBoYXZlIG5vdyBzZW5kaW5nIGFVU0QgdG8geW91ciB3YWxsZXQuIFRoaXMgdXN1YWxseSB0YWtlcyBmZXcgbWludXRlcywgc28gbGV0cyB3YWl0LlxcclxcbjxiciAvPjxiciAvPlxcclxcbiAgICAgICAgV2hlbiB5b3UgaGF2ZSB0aGUgYVVTRCBpbiB5b3Ugd2FsbGV0LCB3ZSB3aWxsIHRlbGwgeW91LlxcclxcbiAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICA8aDM+Q3VycmVudCBhVVNEIGJhbGFuY2U8L2gzPlxcclxcbiAgICAgICAgICAgIDxkaXYgaWQ9XFxcImN1cnJlbnRBVVNEQmFsYW5jZVxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgaWQ9XFxcImVycm9yQWZ0ZXJUcnlGdW5kaW5nXFxcIiBjbGFzcz1cXFwiZC1ub25lXFxcIj5cXHJcXG4gICAgICAgIFdlIGhhZCBhbiBlcnJvciB3aGlsZSB0cnlpbmcgdG8gZnVuZCB5b3UuIFdlJ2xsIGJlIGNyYWNraW5nIGF0IHRoZSBpc3N1ZSBzb29uIHRvIGZpeCBpdC5cXHJcXG4gICAgICAgIFRyeSBhZ2FpbiBpbiBmZXcgbWludXRlcy4gSWYgbm90LCB0cnkgYWdhaW4gaW4gZmV3IGhvdXJzLlxcclxcbiAgICA8L2Rpdj5cXHJcXG5cXHJcXG4gICAgPGEgaHJlZj1cXFwiI1xcXCIgaWQ9XFxcInJlZ2lzdGVyQmFua0luZm9cXFwiPlJlZ2lzdGVyIGJhbmsgaW5mb3JtYXRpb24gKG5vdCBuZWVkZWQgZm9yIFNhbmRib3gpPC9hPlxcclxcbjwvYXJ0aWNsZT5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVuZGluZ1NlcnZpY2Uge1xyXG4gICAgbW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHJlcXVlc3RGYWtlRnVuZGluZygpIHtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBOZXR3b3JrSW5mby5nZXRJbnN0YW5jZSgpO1xyXG5cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLkNsb3VkLnJ1bignZnVuZFVzZXInLCB7Y2hhaW5JZDpuZXR3b3JrSW5mby5DaGFpbklkfSk7XHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPHA+U2V0dXAgeW91ciBiYW5rIHJlbGF0aW9uc2hpcCB3aXRoIExpbWluYWwubWFya2V0LiBQbGVhc2UgY2hvb3NlIHRoZSB0eXBlIG9mIHRyYW5zZmVyIHlvdSB3YW50IHRvIG1ha2U8L3A+XFxyXFxuPHVsIGNsYXNzPVxcXCJmdW5kaW5nX3R5cGVcXFwiPlxcclxcbiAgICA8bGk+PGxhYmVsPjxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwiYmFua190cmFuc2ZlclxcXCIgaWQ9XFxcImFjaF90cmFuc2ZlclxcXCIgdmFsdWU9XFxcIjFcXFwiLz4gQUNIIGJhbmsgdHJhbnNmZXIgKFVTKTwvbGFiZWw+XFxyXFxuICAgIDwvbGk+XFxyXFxuICAgIDxsaT48bGFiZWw+PGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBuYW1lPVxcXCJiYW5rX3RyYW5zZmVyXFxcIiBpZD1cXFwid2lyZV90cmFuc2ZlclxcXCIgdmFsdWU9XFxcIjJcXFwiLz4gV2lyZSB0cmFuc2ZlclxcclxcbiAgICAgICAgKEludGVybmF0aW9uYWwpPC9sYWJlbD48L2xpPlxcclxcbjwvdWw+XFxyXFxuPGRpdiBpZD1cXFwic2VsZWN0RnVuZGluZ1R5cGVFcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG48YnV0dG9uIGlkPVxcXCJuZXh0X2JhbmtfaW5mb3JtYXRpb25cXFwiPk5leHQ6IEJhbmsgaW5mb3JtYXRpb248L2J1dHRvbj5cXHJcXG5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgU2VsZWN0RnVuZGluZ1R5cGVIdG1sIGZyb20gJy4uLy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9SZWxhdGlvbnNoaXAvU2VsZWN0RnVuZGluZ1R5cGUuaHRtbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWxlY3RGdW5kaW5nVHlwZSB7XHJcblxyXG4gICAgYVVzZEZ1bmQ6IEFVU0RGdW5kXHJcblxyXG4gICAgY29uc3RydWN0b3IoYVVzZEZ1bmQ6IEFVU0RGdW5kKSB7XHJcbiAgICAgICAgdGhpcy5hVXNkRnVuZCA9IGFVc2RGdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShTZWxlY3RGdW5kaW5nVHlwZUh0bWwpO1xyXG5cclxuICAgICAgICB0aGlzLmFVc2RGdW5kLm1vZGFsLnNob3dNb2RhbCgnU2VsZWN0IGZ1bmRpbmcgdHlwZScsIHRlbXBsYXRlKHt9KSk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kRXZlbnQoKSB7XHJcbiAgICAgICAgbGV0IG5leHRfYmFua19pbmZvcm1hdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0X2JhbmtfaW5mb3JtYXRpb24nKTtcclxuICAgICAgICBuZXh0X2JhbmtfaW5mb3JtYXRpb24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFVc2RGdW5kLmhpZGVFcnJvcignc2VsZWN0RnVuZGluZ1R5cGVFcnJvcicpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFjaF90cmFuc2ZlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY2hfdHJhbnNmZXInKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoYWNoX3RyYW5zZmVyPy5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFVc2RGdW5kLmFjaFJlbGF0aW9uc2hpcC5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHdpcmVfdHJhbnNmZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2lyZV90cmFuc2ZlcicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICh3aXJlX3RyYW5zZmVyPy5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFVc2RGdW5kLndpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcC5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuYVVzZEZ1bmQuc2hvd0Vycm9yKCdzZWxlY3RGdW5kaW5nVHlwZUVycm9yJywgJ1BsZWFzZSBzZWxlY3QgZnVuZGluZyB0eXBlJylcclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgPHA+QmVmb3JlIHlvdSBjYW4gdHJhbnNmZXIsIHlvdSBuZWVkIHRvIHNldCB1cCB5b3VyIGJhbmsgaW5mb3JtYXRpb248L3A+XFxyXFxuXFxyXFxuICAgIDxmb3JtIGlkPVxcXCJhY2hGb3JtXFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgQWNjb3VudCBvd25lciBuYW1lXFxyXFxuICAgICAgICAgICAgICAgIDxpbnB1dCBuYW1lPVxcXCJhY2NvdW50X293bmVyX25hbWVcXFwiIHJlcXVpcmVkIGlkPVxcXCJhY2NvdW50X293bmVyX25hbWVcXFwiLz5cXHJcXG4gICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5CYW5rIEFjY291bnQgVHlwZVxcclxcbiAgICAgICAgICAgICAgICA8c2VsZWN0IG5hbWU9XFxcImJhbmtfYWNjb3VudF90eXBlXFxcIiBpZD1cXFwiYmFua19hY2NvdW50X3R5cGVcXFwiIHJlcXVpcmVkPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj48L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNIRUNLSU5HXFxcIj5DaGVja2luZzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0FWSU5HU1xcXCI+U2F2aW5nczwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8bGFiZWw+XFxyXFxuICAgICAgICAgICAgICAgIEJhbmsgYWNjb3VudCBudW1iZXJcXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcImJhbmtfYWNjb3VudF9udW1iZXJcXFwiIGlkPVxcXCJiYW5rX2FjY291bnRfbnVtYmVyXFxcIiByZXF1aXJlZC8+XFxyXFxuICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8bGFiZWw+XFxyXFxuICAgICAgICAgICAgICAgIEJhbmsgcm91dGluZyBudW1iZXJcXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcImJhbmtfcm91dGluZ19udW1iZXJcXFwiIGlkPVxcXCJiYW5rX3JvdXRpbmdfbnVtYmVyXFxcIiByZXF1aXJlZC8+XFxyXFxuICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJyZWxhdGlvbnNoaXBFcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGlkPVxcXCJhY2hfcHJldmlvdXNcXFwiPlByZXZpb3VzOiBGdW5kaW5nIHR5cGU8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGlkPVxcXCJhY2hfbmV4dFxcXCI+TmV4dDogU2F2ZSBiYW5rIGluZm9ybWF0aW9uPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG5cXHJcXG4gICAgPC9mb3JtPlxcclxcblxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImV4cG9ydCBlbnVtIFRyYW5zZmVyRGlyZWN0aW9uRW51bSB7XHJcbiAgICBJbmNvbWluZyA9ICdJTkNPTUlORycsXHJcbiAgICBPdXRnb2luZyA9ICdPVVRHT0lORydcclxufSIsImltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vQVVTREZ1bmRcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCB7VHJhbnNmZXJEaXJlY3Rpb25FbnVtfSBmcm9tIFwiLi4vLi4vLi4vLi4vZW51bXMvVHJhbnNmZXJEaXJlY3Rpb25FbnVtXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBSZWxhdGlvbnNoaXBCYXNlIHtcclxuICAgIHByb3RlY3RlZCBhVXNkRnVuZDogQVVTREZ1bmRcclxuXHJcbiAgICBwcm90ZWN0ZWQgY29uc3RydWN0b3IoYVVzZEZ1bmQ6IEFVU0RGdW5kKSB7XHJcbiAgICAgICAgdGhpcy5hVXNkRnVuZCA9IGFVc2RGdW5kO1xyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IGJpbmRFdmVudHMoKTogdm9pZDtcclxuXHJcbiAgICBhYnN0cmFjdCB2YWxpZGF0ZSgpOiBib29sZWFuO1xyXG5cclxuICAgIHB1YmxpYyBzaG93KHRpdGxlOiBzdHJpbmcsIGh0bWw6IHN0cmluZywgcGFyYW0/OiBhbnkpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoaHRtbCk7XHJcblxyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQubW9kYWwuc2hvd01vZGFsKHRpdGxlLCB0ZW1wbGF0ZShwYXJhbSkpO1xyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBoYW5kbGVFcnJvclJlc3BvbnNlKHJlYXNvbjogYW55KSB7XHJcbiAgICAgICAgaWYgKCFyZWFzb24ubWVzc2FnZSkge1xyXG4gICAgICAgICAgICBhbGVydChyZWFzb24pXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKHJlYXNvbi5tZXNzYWdlKTtcclxuICAgICAgICBsZXQgZXJyb3JFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlbGF0aW9uc2hpcEVycm9yJyk7XHJcbiAgICAgICAgaWYgKCFlcnJvckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSAob2JqLnNlcnZlckVycm9yKSA/IG9iai5zZXJ2ZXJFcnJvci5tZXNzYWdlIDogcmVhc29uLm1lc3NhZ2VcclxuICAgICAgICAgICAgYWxlcnQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvYmouc2VydmVyRXJyb3IubWVzc2FnZS5pbmRleE9mKCdvbmx5IG9uZSBiYW5rIGFzc29jaWF0aW9uJykgIT0gLTEpIHtcclxuICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMuYVVzZEZ1bmQubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGxldCBiYW5rUmVsYXRpb25zaGlwID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0QmFua1JlbGF0aW9uc2hpcCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFiYW5rUmVsYXRpb25zaGlwKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvckVsZW1lbnQuaW5uZXJUZXh0ID0gJ1dlIGNhbm5vdCBjcmVhdGUgdGhlIGJhbmsgY29ubmVjdGlvbi4gU29tZXRoaW5nIGlzIG5vdCB3b3JraW5nIGFzIGl0IHNob3VsZC4gUGxlYXNlIGNvbnRhY3QgdXMgYXQgPGEgaHJlZj1cIm1haWx0bzppbmZvQGxpbWluYWwubWFya2V0XCI+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT4nO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNmZXJzID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0TGF0ZXN0VHJhbnNmZXJzKFRyYW5zZmVyRGlyZWN0aW9uRW51bS5JbmNvbWluZylcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYVVzZEZ1bmQudHJhbnNmZXJOb3RpZmljYXRpb24uc2hvdyhiYW5rUmVsYXRpb25zaGlwLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JFbGVtZW50LmlubmVyVGV4dCA9IG9iai5zZXJ2ZXJFcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICBlcnJvckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgQUNIUmVsYXRpb25zaGlwSHRtbCBmcm9tICcuLi8uLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvUmVsYXRpb25zaGlwL0FDSFJlbGF0aW9uc2hpcC5odG1sJztcclxuaW1wb3J0IEZvcm1IZWxwZXIgZnJvbSBcIi4uLy4uLy4uLy4uL3V0aWwvRm9ybUhlbHBlclwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgUmVsYXRpb25zaGlwQmFzZSBmcm9tIFwiLi9SZWxhdGlvbnNoaXBCYXNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBQ0hSZWxhdGlvbnNoaXAgZXh0ZW5kcyBSZWxhdGlvbnNoaXBCYXNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICBzdXBlcihhVXNkRnVuZClcclxuICAgIH1cclxuXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAgIHN1cGVyLnNob3coJ0JhbmsgaW5mb3JtYXRpb24nLCBBQ0hSZWxhdGlvbnNoaXBIdG1sKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYmluZEV2ZW50cygpIHtcclxuICAgICAgICBsZXQgYWNoX25leHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWNoX25leHQnKTtcclxuICAgICAgICBhY2hfbmV4dD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBGb3JtSGVscGVyLmdldFBhcmFtcygnI2FjaEZvcm0nKTtcclxuICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMuYVVzZEZ1bmQubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIHVzZXJTZXJ2aWNlLmNyZWF0ZUFjaFJlbGF0aW9uc2hpcChwYXJhbXMuYWNjb3VudF9vd25lcl9uYW1lLCBwYXJhbXMuYmFua19hY2NvdW50X3R5cGUsIHBhcmFtcy5iYW5rX2FjY291bnRfbnVtYmVyLCBwYXJhbXMuYmFua19yb3V0aW5nX251bWJlcilcclxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hVXNkRnVuZC5maXJzdFRyYW5zZmVyU2V0dXAuc2hvdyhyZXN1bHQpXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGFzeW5jIChyZWFzb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZUVycm9yUmVzcG9uc2UocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgYWNoX3ByZXZpb3VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjaF9wcmV2aW91cycpO1xyXG4gICAgICAgIGFjaF9wcmV2aW91cz8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5hVXNkRnVuZC5zZWxlY3RGdW5kaW5nVHlwZS5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgaWYgKCFGb3JtSGVscGVyLnZhbGlkYXRlKCcjYWNoRm9ybScpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcblxcclxcblxcclxcbiAgICA8cD5cXHJcXG4gICAgICAgIFRvIGZpbGwgdXAgeW91ciBicm9rZXIgYWNjb3VudCwgeW91IG5lZWQgdG8gbm90aWZ5IExpbWluYWwubWFya2V0IGZpcnN0IGFib3V0IHlvdXIgdHJhbnNmZXIsXFxyXFxuICAgICAgICB3ZSBjYW4gdGhlbiBtYXRjaCBpdCB3aXRoIHlvdXIgYWNjb3VudC5cXHJcXG4gICAgICAgIDxhIGhyZWY9XFxcIiNcXFwiIGlkPVxcXCJmaXJzdF90cmFuc2Zlcl9zZXR1cFxcXCI+TmVlZCBiYW5rIGluZm9ybWF0aW9uPyBDbGljayBoZXJlPC9hPlxcclxcbiAgICA8L3A+XFxyXFxuICAgIDxici8+XFxyXFxuXFxyXFxuICAgIHt7e21vbmV5VHJhbnNmZXJyZWR9fX1cXHJcXG5cXHJcXG4gICAge3t7dHJhbnNmZXJzfX19XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGhyLz5cXHJcXG48aDM+e3tEaXJlY3Rpb259fSB0cmFuc2ZlcnM8L2gzPlxcclxcbnt7I2lmIHRyYW5zZmVycy5sZW5ndGh9fVxcclxcbjxwPkJlbG93IGlzIGEgbGlzdCBvZiB0cmFuc2ZlcnMsIGNvbmZpcm1lZCBhbmQgbm90IGNvbmZpcm1lZC48L3A+XFxyXFxuPHRhYmxlPlxcclxcbiAgICA8dGhlYWQ+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0aD5BbW91bnQ8L3RoPlxcclxcbiAgICAgICAgPHRoPlN0YXR1czwvdGg+XFxyXFxuICAgICAgICA8dGg+Q3JlYXRlZDwvdGg+XFxyXFxuICAgICAgICA8dGg+RXhwaXJlczwvdGg+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIDwvdGhlYWQ+XFxyXFxuICAgIDx0Ym9keT5cXHJcXG4gICAge3sjZWFjaCB0cmFuc2ZlcnN9fVxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+JHt7YW1vdW50fX08L3RkPlxcclxcbiAgICAgICAgPHRkIGlkPVxcXCJzdGF0dXNfe3tpZH19XFxcIj57e3N0YXR1c319PC90ZD5cXHJcXG4gICAgICAgIDx0ZD57e2RhdGVUaW1lRm9ybWF0IGNyZWF0ZWRfYXR9fTwvdGQ+XFxyXFxuICAgICAgICA8dGQ+e3tkYXRlVGltZUZvcm1hdCBleHBpcmVzX2F0fX08L3RkPlxcclxcbiAgICAgICAgPHRkIGlkPVxcXCJkZWxldGVfe3tpZH19XFxcIiBjbGFzcz1cXFwie3tjbGFzc0J5U3RhdHVzIHN0YXR1c319XFxcIj48YSBocmVmPVxcXCIjXFxcIiBjbGFzcz1cXFwiZGVsZXRlVHJhbnNmZXJcXFwiIGRhdGEtaWQ9XFxcInt7aWR9fVxcXCI+Q2FuY2VsPC9hPlxcclxcbiAgICAgICAgPC90ZD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAge3svZWFjaH19XFxyXFxuICAgIDwvdGJvZHk+XFxyXFxuPC90YWJsZT5cXHJcXG57e2Vsc2V9fVxcclxcbjxwPk5vIHRyYW5zZmVycyByZWdpc3RlcmVkPC9wPlxcclxcbnt7L2lmfX1cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGFuZGxlYmFySGVscGVycyB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWdpc3RlckhlbHBlcnMoKSB7XHJcbiAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcigncGVyYycsIGZ1bmN0aW9uIChudW1iZXI6IHN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KG51bWJlcikgKiAxMDAwMCkgLyAxMDAgKyAnJSc7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcigncm91bmQnLCBmdW5jdGlvbiAobnVtYmVyOiBzdHJpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQocGFyc2VGbG9hdChudW1iZXIpICogMTAwKSAvIDEwMDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcigncm91bmQyJywgZnVuY3Rpb24gKG51bWJlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobnVtYmVyKSAqIDEwMDAwKSAvIDEwMDAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoJ2NsYXNzQ29sb3InLCBmdW5jdGlvbiAobnVtYmVyOiBudW1iZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChudW1iZXIgPiAwKSA/IFwiZ3JlZW5cIiA6IFwicmVkXCI7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgSGFuZGxlYmFycy5yZWdpc3RlckhlbHBlcignZGF0ZVRpbWVGb3JtYXQnLCBmdW5jdGlvbiAoc3RyRGF0ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGxldCBkYXRlID0gbmV3IERhdGUoc3RyRGF0ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLnRvTG9jYWxlU3RyaW5nKClcclxuICAgICAgICB9KTtcclxuICAgICAgICBIYW5kbGViYXJzLnJlZ2lzdGVySGVscGVyKCdjbGFzc0J5U3RhdHVzJywgZnVuY3Rpb24gKHN0YXR1czogc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoc3RhdHVzID09ICdRVUVVRUQnIHx8IHN0YXR1cyA9PSAnQVBQUk9WQUxfUEVORElORycpID8gJycgOiAnaGlkZGVuJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IFRyYW5zZmVyc0xpc3RIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9UcmFuc2ZlcnNMaXN0Lmh0bWwnXHJcbmltcG9ydCBIYW5kbGViYXJIZWxwZXJzIGZyb20gXCIuLi8uLi8uLi91dGlsL0hhbmRsZWJhckhlbHBlcnNcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBNb3JhbGlzIGZyb20gXCJtb3JhbGlzXCI7XHJcbmltcG9ydCB7VHJhbnNmZXJEaXJlY3Rpb25FbnVtfSBmcm9tIFwiLi4vLi4vLi4vZW51bXMvVHJhbnNmZXJEaXJlY3Rpb25FbnVtXCI7XHJcbmltcG9ydCB7VHJhbnNmZXJ9IGZyb20gXCIuLi8uLi8uLi9kdG8vYWxwYWNhL1RyYW5zZmVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2ZlcnNMaXN0IHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgcHJpdmF0ZSB1c2VyU2VydmljZTogVXNlclNlcnZpY2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgICAgIHRoaXMudXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIHJlbmRlcihkaXJlY3Rpb246IFRyYW5zZmVyRGlyZWN0aW9uRW51bSwgdHJhbnNmZXJzOiBUcmFuc2ZlcltdKSB7XHJcblxyXG4gICAgICAgIEhhbmRsZWJhckhlbHBlcnMucmVnaXN0ZXJIZWxwZXJzKCk7XHJcblxyXG4gICAgICAgIGxldCB0cmFuc2ZlcnNUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShUcmFuc2ZlcnNMaXN0SHRtbCk7XHJcblxyXG4gICAgICAgIHJldHVybiB0cmFuc2ZlcnNUZW1wbGF0ZSh7RGlyZWN0aW9uOiBkaXJlY3Rpb24sIHRyYW5zZmVyczogdHJhbnNmZXJzfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYmluZEV2ZW50cygpIHtcclxuICAgICAgICBsZXQgZGVsZXRlVHJhbnNmZXJzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRlbGV0ZVRyYW5zZmVyJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxldGVUcmFuc2ZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVsZXRlVHJhbnNmZXJzW2ldPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghY29uZmlybSgnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGNhbmNlbCB0aGlzIHdpdGhkcmF3IHJlcXVlc3Q/JykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGlkID0gKGRlbGV0ZVRyYW5zZmVyc1tpXSBhcyBIVE1MRWxlbWVudCkuZGF0YXNldFsnaWQnXTtcclxuICAgICAgICAgICAgICAgIGlmICghaWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHVzZXJTZXJ2aWNlLmRlbGV0ZVRyYW5zZmVyKGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXR1c1RkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXR1c18nICsgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzVGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RkLmlubmVyVGV4dCA9ICdDQU5DRUxFRCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGV0ZVRkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbGV0ZV8nICsgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVUZD8ucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uLy4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4uL0FVU0RGdW5kXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBGaXJzdFRyYW5zZmVyU2V0dXBCYXNlIHtcclxuICAgIGJhbmtSZWxhdGlvbnNoaXA6IEJhbmtSZWxhdGlvbnNoaXA7XHJcbiAgICBhVXNkRnVuZDogQVVTREZ1bmQ7XHJcblxyXG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCwgYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCkge1xyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQgPSBhVXNkRnVuZDtcclxuICAgICAgICB0aGlzLmJhbmtSZWxhdGlvbnNoaXAgPSBiYW5rUmVsYXRpb25zaGlwO1xyXG4gICAgfVxyXG5cclxuICAgIGFic3RyYWN0IHNob3coKTogdm9pZDtcclxuXHJcbiAgICBhYnN0cmFjdCBiaW5kRXZlbnRzKCk6IHZvaWQ7XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlbmRlcihodG1sOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdodG1sX3RvX2ZpbGwnKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgfVxyXG5cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmb3JtPlxcclxcbiAgICA8bGFiZWw+VHlwZSBpbiB0aGUgYW1vdW50IGluIFVTIERvbGxhcnMgKCQpIHRoYXQgeW91IHRyYW5zZmVycmVkXFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYW1vdW50XFxcIiBjbGFzcz1cXFwiYW1vdW50XFxcIiB0eXBlPVxcXCJ0ZWxcXFwiIGlkPVxcXCJhbW91bnRcXFwiIG1pbmxlbmd0aD1cXFwiMVxcXCIgcmVxdWlyZWQvPlxcclxcbiAgICA8L2xhYmVsPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcInRyYW5zZmVyRXJyb3JcXFwiPjwvZGl2PlxcclxcbiAgICA8YnV0dG9uIGlkPVxcXCJub3RpZnlUcmFuc2ZlclxcXCI+Tm90aWZ5IExpbWluYWwubWFya2V0IG9mIGluY29taW5nIHRyYW5zZmVyPC9idXR0b24+XFxyXFxuXFxyXFxuICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcInRyYW5zZmVyX3R5cGVcXFwiIGlkPVxcXCJ0cmFuc2Zlcl90eXBlXFxcIiB2YWx1ZT1cXFwie3t0cmFuc2Zlcl90eXBlfX1cXFwiLz5cXHJcXG4gICAgPGlucHV0IHR5cGU9XFxcImhpZGRlblxcXCIgbmFtZT1cXFwicmVsYXRpb25zaGlwX2lkXFxcIiBpZD1cXFwicmVsYXRpb25zaGlwX2lkXFxcIiB2YWx1ZT1cXFwie3tyZWxhdGlvbnNoaXBJZH19XFxcIi8+XFxyXFxuICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcImRpcmVjdGlvblxcXCIgaWQ9XFxcImRpcmVjdGlvblxcXCIgdmFsdWU9XFxcIklOQ09NSU5HXFxcIi8+XFxyXFxuPC9mb3JtPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgRmlyc3RUcmFuc2ZlclNldHVwUGFnZSBmcm9tIFwiLi9GaXJzdFRyYW5zZmVyU2V0dXBCYXNlXCI7XHJcbmltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uLy4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgTW9uZXlUcmFuc2ZlcnJlZEh0bWwgZnJvbSBcIi4uLy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvTW9uZXlUcmFuc2ZlcnJlZC5odG1sXCI7XHJcbmltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vQVVTREZ1bmRcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vbmV5VHJhbnNmZXJyZWQgZXh0ZW5kcyBGaXJzdFRyYW5zZmVyU2V0dXBQYWdlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQsIGJhbmtSZWxhdGlvbnNoaXA6IEJhbmtSZWxhdGlvbnNoaXApIHtcclxuICAgICAgICBzdXBlcihhVXNkRnVuZCwgYmFua1JlbGF0aW9uc2hpcCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2hvdygpOiB2b2lkIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoTW9uZXlUcmFuc2ZlcnJlZEh0bWwpO1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcih0ZW1wbGF0ZSh7fSkpO1xyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpOiBzdHJpbmcge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShNb25leVRyYW5zZmVycmVkSHRtbCk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHtcclxuICAgICAgICAgICAgdHJhbnNmZXJfdHlwZTogdGhpcy5iYW5rUmVsYXRpb25zaGlwLnRyYW5zZmVyX3R5cGUsXHJcbiAgICAgICAgICAgIHJlbGF0aW9uc2hpcElkOiB0aGlzLmJhbmtSZWxhdGlvbnNoaXAuaWRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBiaW5kRXZlbnRzKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBsZXQgbm90aWZ5VHJhbnNmZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm90aWZ5VHJhbnNmZXInKTtcclxuICAgICAgICBub3RpZnlUcmFuc2Zlcj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmFVc2RGdW5kLmhpZGVFcnJvcigndHJhbnNmZXJFcnJvcicpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFtb3VudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbW91bnQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkoYW1vdW50LnZhbHVlKSB8fCBwYXJzZUZsb2F0KGFtb3VudC52YWx1ZSkgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hVXNkRnVuZC5zaG93RXJyb3IoJ2Ftb3VudEVycm9yJywgJ0Ftb3VudCBjYW5ub3QgYmUgZW1wdHkgb3IgYmVsb3cgJDEwJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcobm90aWZ5VHJhbnNmZXIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMuYVVzZEZ1bmQubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHVzZXJTZXJ2aWNlLmNyZWF0ZVRyYW5zZmVyKGFtb3VudC52YWx1ZSwgJ0lOQ09NSU5HJylcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFVc2RGdW5kLnRyYW5zZmVyTm90aWZpZWQuc2hvdyh0aGlzLmJhbmtSZWxhdGlvbnNoaXAhLCBhbW91bnQudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBodHRwRXJyb3IgPSBKU09OLnBhcnNlKHJlYXNvbi5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFVc2RGdW5kLnNob3dFcnJvcigndHJhbnNmZXJFcnJvcicsIGh0dHBFcnJvci5zZXJ2ZXJFcnJvci5tZXNzYWdlKVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBMb2FkaW5nSGVscGVyLnJlbW92ZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4vQVVTREZ1bmRcIjtcclxuaW1wb3J0IFRyYW5zZmVyTm90aWZpY2F0aW9uSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvVHJhbnNmZXJOb3RpZmljYXRpb24uaHRtbCdcclxuaW1wb3J0IE1vbmV5VHJhbnNmZXJyZWRIdG1sIGZyb20gXCIuLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL01vbmV5VHJhbnNmZXJyZWQuaHRtbFwiO1xyXG5pbXBvcnQge0JhbmtSZWxhdGlvbnNoaXB9IGZyb20gXCIuLi8uLi8uLi9kdG8vYWxwYWNhL0JhbmtSZWxhdGlvbnNoaXBcIjtcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuaW1wb3J0IFRyYW5zZmVyc0xpc3QgZnJvbSBcIi4vVHJhbnNmZXJzTGlzdFwiO1xyXG5pbXBvcnQge1RyYW5zZmVyfSBmcm9tIFwiLi4vLi4vLi4vZHRvL2FscGFjYS9UcmFuc2ZlclwiO1xyXG5pbXBvcnQgTW9uZXlUcmFuc2ZlcnJlZCBmcm9tIFwiLi9GaXJzdFRyYW5zZmVyU2V0dXAvTW9uZXlUcmFuc2ZlcnJlZFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNmZXJOb3RpZmljYXRpb24ge1xyXG5cclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgYVVzZEZ1bmQ6IEFVU0RGdW5kXHJcbiAgICBiYW5rUmVsYXRpb25zaGlwPzogQmFua1JlbGF0aW9uc2hpcDtcclxuICAgIHByaXZhdGUgdHJhbnNmZXJzTGlzdDogVHJhbnNmZXJzTGlzdDtcclxuICAgIG1vbmV5VHJhbnNmZXJyZWQ/OiBNb25leVRyYW5zZmVycmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzLCBhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQgPSBhVXNkRnVuZDtcclxuICAgICAgICB0aGlzLnRyYW5zZmVyc0xpc3QgPSBuZXcgVHJhbnNmZXJzTGlzdCh0aGlzLm1vcmFsaXMpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvdyhiYW5rUmVsYXRpb25zaGlwOiBCYW5rUmVsYXRpb25zaGlwLCB0cmFuc2ZlcnM6IFRyYW5zZmVyW10pIHtcclxuICAgICAgICB0aGlzLmJhbmtSZWxhdGlvbnNoaXAgPSBiYW5rUmVsYXRpb25zaGlwO1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVHJhbnNmZXJOb3RpZmljYXRpb25IdG1sKVxyXG4gICAgICAgIGxldCB0cmFuc2ZlcnNMaXN0SHRtbCA9IGF3YWl0IHRoaXMudHJhbnNmZXJzTGlzdC5yZW5kZXIoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLkluY29taW5nLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgIHRoaXMubW9uZXlUcmFuc2ZlcnJlZCA9IG5ldyBNb25leVRyYW5zZmVycmVkKHRoaXMuYVVzZEZ1bmQsIHRoaXMuYmFua1JlbGF0aW9uc2hpcCk7XHJcblxyXG4gICAgICAgIHRoaXMuYVVzZEZ1bmQubW9kYWwuc2hvd01vZGFsKCdDcmVhdGUgdHJhbnNmZXIgbm90aWZpY2F0aW9uJywgdGVtcGxhdGUoe1xyXG4gICAgICAgICAgICBtb25leVRyYW5zZmVycmVkOiB0aGlzLm1vbmV5VHJhbnNmZXJyZWQucmVuZGVyKCksXHJcbiAgICAgICAgICAgIHRyYW5zZmVyczogdHJhbnNmZXJzTGlzdEh0bWxcclxuICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMubW9uZXlUcmFuc2ZlcnJlZD8uYmluZEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJzTGlzdC5iaW5kRXZlbnRzKCk7XHJcblxyXG4gICAgICAgIGxldCBmaXJzdF90cmFuc2Zlcl9zZXR1cCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaXJzdF90cmFuc2Zlcl9zZXR1cCcpO1xyXG4gICAgICAgIGZpcnN0X3RyYW5zZmVyX3NldHVwPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmFVc2RGdW5kLmZpcnN0VHJhbnNmZXJTZXR1cC5zaG93KHRoaXMuYmFua1JlbGF0aW9uc2hpcCEpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICA8cD5CZWZvcmUgeW91IGNhbiB0cmFuc2ZlciwgeW91IG5lZWQgdG8gc2V0IHVwIHlvdXIgYmFuayBpbmZvcm1hdGlvbjwvcD5cXHJcXG4gICAgPGZvcm0gaWQ9XFxcIndpcmVUcmFuc2ZlckZvcm1cXFwiPlxcclxcbiAgICAgICAgPGxhYmVsPkJhbmsgbmFtZVxcclxcbiAgICAgICAgICAgIDxpbnB1dCBuYW1lPVxcXCJuYW1lXFxcIiByZXF1aXJlZCBpZD1cXFwibmFtZVxcXCIvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwic3dpZnRfZXJyb3JcXFwiPkJJQy9TV0lGVCBjb2RlIHNob3VsZCBiZSA4IG9yIDExIGNoYXJhY3RlcnM8L2Rpdj5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBCYW5rIGNvZGUgKEJJQy9TV0lGVClcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYmFua19jb2RlXFxcIiBtYXhsZW5ndGg9XFxcIjExXFxcIiBpZD1cXFwiYmFua19jb2RlXFxcIiByZXF1aXJlZC8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgPGxhYmVsPlxcclxcbiAgICAgICAgICAgIEJhbmsgU3RyZWV0IGFkZHJlc3NcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwic3RyZWV0X2FkZHJlc3NcXFwiIGlkPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCIgcmVxdWlyZWQvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBCYW5rIFBvc3RhbCBjb2RlXFxyXFxuICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcInBvc3RhbF9jb2RlXFxcIiBpZD1cXFwicG9zdGFsX2NvZGVcXFwiIHJlcXVpcmVkLz5cXHJcXG4gICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8bGFiZWw+XFxyXFxuICAgICAgICAgICAgQmFuayBDaXR5XFxyXFxuICAgICAgICAgICAgPGlucHV0IG5hbWU9XFxcImNpdHlcXFwiIGlkPVxcXCJjaXR5XFxcIiByZXF1aXJlZC8+XFxyXFxuICAgICAgICA8L2xhYmVsPlxcclxcblxcclxcbiAgICAgICAgPGxhYmVsPkJhbmsgU3RhdGVcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwic3RhdGVfcHJvdmluY2VcXFwiIGlkPVxcXCJzdGF0ZV9wcm92aW5jZVxcXCIgcmVxdWlyZWQvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBDb3VudHJ5IHdoZXJlIGJhbmsgYWNjb3VudCBpcyBsb2NhdGVkXFxyXFxuICAgICAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiY291bnRyeVxcXCIgcmVxdWlyZWQgbmFtZT1cXFwiY291bnRyeVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwie3tjb2RlfX1cXFwiPnt7bmFtZX19PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICBBY2NvdW50IG51bWJlciAoSUJBTilcXHJcXG4gICAgICAgICAgICA8aW5wdXQgbmFtZT1cXFwiYWNjb3VudF9udW1iZXJcXFwiIGlkPVxcXCJhY2NvdW50X251bWJlclxcXCIgcmVxdWlyZWQvPlxcclxcbiAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCB0eXBlPVxcXCJoaWRkZW5cXFwiIG5hbWU9XFxcImJhbmtfY29kZV90eXBlXFxcIiB2YWx1ZT1cXFwiQklDXFxcIi8+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJyZWxhdGlvbnNoaXBFcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gaWQ9XFxcIndpcmVfdHJhbnNmZXJfcHJldmlvdXNcXFwiPlByZXZpb3VzOiBGdW5kaW5nIHR5cGU8L2J1dHRvbj5cXHJcXG4gICAgICAgICAgICA8YnV0dG9uIGlkPVxcXCJzYXZlX2ludGVybmF0aW9uYWxfYmFua19pbmZvcm1hdGlvblxcXCI+TmV4dDogVHJhbnNmZXI8L2J1dHRvbj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICA8L2Zvcm0+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgV2lyZVRyYW5zZmVySHRtbCBmcm9tIFwiLi4vLi4vLi4vLi4vaHRtbC9tb2RhbC9GdW5kaW5nL1JlbGF0aW9uc2hpcC9XaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAuaHRtbFwiO1xyXG5pbXBvcnQgRm9ybUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Gb3JtSGVscGVyXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgQ291bnRyeUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vLi4vdXRpbC9Db3VudHJ5SGVscGVyXCI7XHJcbmltcG9ydCBSZWxhdGlvbnNoaXBCYXNlIGZyb20gXCIuL1JlbGF0aW9uc2hpcEJhc2VcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi8uLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAgZXh0ZW5kcyBSZWxhdGlvbnNoaXBCYXNlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICBzdXBlcihhVXNkRnVuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgc3VwZXIuc2hvdygnQ3JlYXRlIGJhbmsgaW5mb3JtYXRpb24nLCBXaXJlVHJhbnNmZXJIdG1sLCB7Y291bnRyaWVzOiBDb3VudHJ5SGVscGVyLkNvdW50cmllc30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCB3aXJlX3RyYW5zZmVyX3ByZXZpb3VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpcmVfdHJhbnNmZXJfcHJldmlvdXMnKTtcclxuICAgICAgICB3aXJlX3RyYW5zZmVyX3ByZXZpb3VzPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hVXNkRnVuZC5zZWxlY3RGdW5kaW5nVHlwZS5zaG93KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBzYXZlX2ludGVybmF0aW9uYWxfYmFua19pbmZvcm1hdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzYXZlX2ludGVybmF0aW9uYWxfYmFua19pbmZvcm1hdGlvbicpO1xyXG4gICAgICAgIHNhdmVfaW50ZXJuYXRpb25hbF9iYW5rX2luZm9ybWF0aW9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IEZvcm1IZWxwZXIuZ2V0UGFyYW1zKCcjd2lyZVRyYW5zZmVyRm9ybScpO1xyXG4gICAgICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UodGhpcy5hVXNkRnVuZC5tb3JhbGlzKTtcclxuICAgICAgICAgICAgYXdhaXQgdXNlclNlcnZpY2UucmVnaXN0ZXJXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAocGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKGJhbmtSZWxhdGlvbnNoaXA6IEJhbmtSZWxhdGlvbnNoaXApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmZXJzID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0TGF0ZXN0VHJhbnNmZXJzKFRyYW5zZmVyRGlyZWN0aW9uRW51bS5JbmNvbWluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hVXNkRnVuZC50cmFuc2Zlck5vdGlmaWNhdGlvbi5zaG93KGJhbmtSZWxhdGlvbnNoaXAsIHRyYW5zZmVycylcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAuY2F0Y2goYXN5bmMgKHJlYXNvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXJyb3JSZXNwb25zZShyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgbGV0IHN3aWZ0X2Vycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N3aWZ0X2Vycm9yJyk7XHJcbiAgICAgICAgaWYgKHN3aWZ0X2Vycm9yKSBzd2lmdF9lcnJvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGxldCB3cml0ZVRyYW5zZmVyRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd3JpdGVUcmFuc2ZlckVycm9yJyk7XHJcbiAgICAgICAgaWYgKHdyaXRlVHJhbnNmZXJFcnJvcikgd3JpdGVUcmFuc2ZlckVycm9yLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmICghRm9ybUhlbHBlci52YWxpZGF0ZSgnI3dpcmVUcmFuc2ZlckZvcm0nKSkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgICAgICBsZXQgYmFua19jb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JhbmtfY29kZScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGJhbmtfY29kZS52YWx1ZS5sZW5ndGggIT0gOCAmJiBiYW5rX2NvZGUudmFsdWUubGVuZ3RoICE9IDExKSB7XHJcbiAgICAgICAgICAgIGJhbmtfY29kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgIGxldCBzd2lmdF9lcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2lmdF9lcnJvcicpO1xyXG4gICAgICAgICAgICBpZiAoc3dpZnRfZXJyb3IpIHN3aWZ0X2Vycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxoMj5Zb3UgbmVlZCB0byB0cmFuc2ZlciB5b3VyIG1vbmV5IG5vdzwvaDI+XFxyXFxuPHVsPlxcclxcbiAgICA8bGk+QW1vdW50OiB7e2Ftb3VudH19PC9saT5cXHJcXG4gICAgPGxpPkFjY291bnQ6IHt7YWNjb3VudF9udW1iZXJ9fTwvbGk+XFxyXFxuPC91bD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuL0FVU0RGdW5kXCI7XHJcbmltcG9ydCBUcmFuc2ZlckluZm9IdG1sIGZyb20gXCIuLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvVHJhbnNmZXJJbmZvLmh0bWxcIlxyXG5pbXBvcnQge0JhbmtSZWxhdGlvbnNoaXB9IGZyb20gXCIuLi8uLi8uLi9kdG8vYWxwYWNhL0JhbmtSZWxhdGlvbnNoaXBcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZmVyTm90aWZpZWQge1xyXG5cclxuICAgIGFVc2RGdW5kOiBBVVNERnVuZDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihhVXNkRnVuZDogQVVTREZ1bmQpIHtcclxuICAgICAgICB0aGlzLmFVc2RGdW5kID0gYVVzZEZ1bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCwgYW1vdW50OiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVHJhbnNmZXJJbmZvSHRtbCk7XHJcbiAgICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICAgICAgYW1vdW50LFxyXG4gICAgICAgICAgICBhY2NvdW50X251bWJlcjogYmFua1JlbGF0aW9uc2hpcC5hbHBhY2FfYWNjb3VudF9udW1iZXIsXHJcbiAgICAgICAgICAgIHdpcmU6IChiYW5rUmVsYXRpb25zaGlwLnRyYW5zZmVyX3R5cGUgPT0gJ3dpcmUnKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hVXNkRnVuZC5tb2RhbC5zaG93TW9kYWwoJ1RyYW5zZmVyIGluZm9ybWF0aW9uJywgdGVtcGxhdGUob2JqKSk7XHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGl2IGlkPVxcXCJodG1sX3RvX2ZpbGxcXFwiPlxcclxcbiAgICB7e3todG1sfX19XFxyXFxuPC9kaXY+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIkNyZWF0ZSB0aGUgYmFuayBpbmZvcm1hdGlvbiB5b3UgbmVlZCBpbiB5b3VyIGludGVybmV0IGJhbmtcXHJcXG48dGFibGU+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5CYW5rIG5hbWU8L3RkPlxcclxcbiAgICAgICAgPHRkPkJNTyBIYXJyaXMgQmFuayBOQTwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5CYW5rIGFkZHJlc3M8L3RkPlxcclxcbiAgICAgICAgPHRkPkJNTyBIYXJyaXMgQmFua1xcclxcbiAgICAgICAgICAgIDExMS4gVy4gTW9ucm9lIFN0cmVldFxcclxcbiAgICAgICAgICAgIENoaWNhZ28sIElMIDYwNjAzLCBVU0FcXHJcXG4gICAgICAgIDwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5SZWNpcGllbnQgLSBBY2NvdW50IG5hbWU8L3RkPlxcclxcbiAgICAgICAgPHRkPkFscGFjYSBTZWN1cml0aWVzIExMQzwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5BbHBhY2EgYWRkcmVzczwvdGQ+XFxyXFxuICAgICAgICA8dGQ+QWxwYWNhIFNlY3VyaXRpZXMgTExDXFxyXFxuICAgICAgICAgICAgMyBFYXN0IFRoaXJkIEF2ZSwgU3VpdGUgMjMzXFxyXFxuICAgICAgICAgICAgU2FuIE1hdGVvLCBDQSA5NDQwMSwgVVNBXFxyXFxuICAgICAgICA8L3RkPlxcclxcbiAgICA8L3RyPlxcclxcbiAgICA8dHI+XFxyXFxuICAgICAgICA8dGQ+QWNjb3VudCBudW1iZXIgLyBJQkFOPC90ZD5cXHJcXG4gICAgICAgIDx0ZD4xNjM2ODc3PC90ZD5cXHJcXG4gICAgPC90cj5cXHJcXG4gICAge3sjaWYgd2lyZX19XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5TV0lGVCBDT0RFPC90ZD5cXHJcXG4gICAgICAgIDx0ZD5IQVRSVVM0NDwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIHt7Xn19XFxyXFxuICAgIDx0cj5cXHJcXG4gICAgICAgIDx0ZD5BQkEgUk9VVElORyBOVU1CRVIgKEFDSCk8L3RkPlxcclxcbiAgICAgICAgPHRkPjA3MTAwMDI4ODwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuICAgIHt7L2lmfX1cXHJcXG4gICAgPHRyPlxcclxcbiAgICAgICAgPHRkPlBsZWFzZSBzcGVjaWZ5IHRoZSBmb2xsb3dpbmcgaW4gdGhlIHJlZmVyZW5jZSBvZiB0aGUgd2lyZTo8L3RkPlxcclxcbiAgICAgICAgPHRkPkZGQyBMTUtULXt7YWNjb3VudF9udW1iZXJ9fTwvdGQ+XFxyXFxuICAgIDwvdHI+XFxyXFxuPC90YWJsZT5cXHJcXG48YnV0dG9uIGlkPVxcXCJiYW5rX2luZm9fbmV4dFxcXCI+TmV4dDogSSBzZXQgdXAgdGhlIGluZm9ybWF0aW9uIGluIG15IGJhbms8L2J1dHRvbj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGgzPlRyYW5zZmVyIG1vbmV5PC9oMz5cXHJcXG5Zb3UgY2FuIG5vdyBsb2cgaW4gdG8geW91ciBpbnRlcm5ldCBiYW5rIGFuZCB0cmFuc2ZlciB0aGUgbW9uZXkgdG8gQWxwYWNhLlxcclxcbjxici8+PGJyLz5cXHJcXG5BZnRlciB5b3UgaGF2ZSB0cmFuc2ZlcnJlZCB0aGUgbW9uZXksIHlvdSBuZWVkIHRvIGxldCB1cyBrbm93IHRoZSBhbW91bnQgdGhhdCB5b3UgdHJhbnNmZXJyZWQuXFxyXFxuXFxyXFxuPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgIDxidXR0b24gaWQ9XFxcInByZXZfd2lyZV90cmFuc2Zlcl9tb25leVxcXCI+UHJldmlvdXM6IFNlZSBiYW5rIGluZm9ybWF0aW9uPC9idXR0b24+XFxyXFxuICAgIDxidXR0b24gaWQ9XFxcIm5leHRfd2lyZV90cmFuc2Zlcl9tb25leVxcXCI+TmV4dDogSSBoYXZlIHRyYW5zZmVycmVkIHRoZSBtb25leTwvYnV0dG9uPlxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgV2lyZVRyYW5zZmVyTW9uZXlIdG1sIGZyb20gJy4uLy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvV2lyZVRyYW5zZmVyTW9uZXkuaHRtbCc7XHJcbmltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXBCYXNlIGZyb20gXCIuL0ZpcnN0VHJhbnNmZXJTZXR1cEJhc2VcIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBNb25leVRyYW5zZmVycmVkIGZyb20gXCIuL01vbmV5VHJhbnNmZXJyZWRcIjtcclxuaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5pbXBvcnQgZG9jID0gTW9jaGEucmVwb3J0ZXJzLmRvYztcclxuaW1wb3J0IEZpcnN0VHJhbnNmZXJTZXR1cCBmcm9tIFwiLi9GaXJzdFRyYW5zZmVyU2V0dXBcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXJlVHJhbnNmZXJNb25leSBleHRlbmRzIEZpcnN0VHJhbnNmZXJTZXR1cEJhc2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGFVc2RGdW5kOiBBVVNERnVuZCwgYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCkge1xyXG4gICAgICAgIHN1cGVyKGFVc2RGdW5kLCBiYW5rUmVsYXRpb25zaGlwKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoV2lyZVRyYW5zZmVyTW9uZXlIdG1sKTtcclxuICAgICAgICB0aGlzLnJlbmRlcih0ZW1wbGF0ZSh7fSkpO1xyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBuZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25leHRfd2lyZV90cmFuc2Zlcl9tb25leScpO1xyXG4gICAgICAgIG5leHQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtb25leVRyYW5zZmVycmVkID0gbmV3IE1vbmV5VHJhbnNmZXJyZWQodGhpcy5hVXNkRnVuZCwgdGhpcy5iYW5rUmVsYXRpb25zaGlwKVxyXG4gICAgICAgICAgICBtb25leVRyYW5zZmVycmVkLnNob3coKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgcHJldiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmV2X3dpcmVfdHJhbnNmZXJfbW9uZXknKTtcclxuICAgICAgICBwcmV2Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdHJhbnNmZXJTZXR1cCA9IG5ldyBGaXJzdFRyYW5zZmVyU2V0dXAoTW9yYWxpcywgdGhpcy5hVXNkRnVuZCk7XHJcbiAgICAgICAgICAgIHRyYW5zZmVyU2V0dXAuc2hvdyh0aGlzLmJhbmtSZWxhdGlvbnNoaXApXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIlRoZSBtb25leSBzaG91bGQgY29tZSBmcm9tIGJhbmsgYWNjb3VudCBudW1iZXIgPHN0cm9uZz57e2JhbmtfYWNjb3VudF9udW1iZXJ9fTwvc3Ryb25nPlxcclxcbjxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICA8YnV0dG9uIGlkPVxcXCJuZXh0X2FjaF9hY2NvdW50X251bWJlclxcXCI+WWVzLCBpdCdzIGNvbWluZyBmcm9tIHt7YmFua19hY2NvdW50X251bWJlcn19PC9idXR0b24+XFxyXFxuPC9kaXY+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBBQ0hUcmFuc2ZlckFjY291bnROdW1iZXJIdG1sXHJcbiAgICBmcm9tICcuLi8uLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0FDSFRyYW5zZmVyQWNjb3VudE51bWJlci5odG1sJztcclxuaW1wb3J0IEZpcnN0VHJhbnNmZXJTZXR1cEJhc2UgZnJvbSBcIi4vRmlyc3RUcmFuc2ZlclNldHVwQmFzZVwiO1xyXG5pbXBvcnQge0JhbmtSZWxhdGlvbnNoaXB9IGZyb20gXCIuLi8uLi8uLi8uLi9kdG8vYWxwYWNhL0JhbmtSZWxhdGlvbnNoaXBcIjtcclxuaW1wb3J0IE1vbmV5VHJhbnNmZXJyZWQgZnJvbSBcIi4vTW9uZXlUcmFuc2ZlcnJlZFwiO1xyXG5pbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4uL0FVU0RGdW5kXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUNIVHJhbnNmZXJBY2NvdW50TnVtYmVyIGV4dGVuZHMgRmlyc3RUcmFuc2ZlclNldHVwQmFzZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoYVVzZEZ1bmQ6IEFVU0RGdW5kLCBiYW5rUmVsYXRpb25zaGlwOiBCYW5rUmVsYXRpb25zaGlwKSB7XHJcbiAgICAgICAgc3VwZXIoYVVzZEZ1bmQsIGJhbmtSZWxhdGlvbnNoaXApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShBQ0hUcmFuc2ZlckFjY291bnROdW1iZXJIdG1sKTtcclxuICAgICAgICB0aGlzLnJlbmRlcih0ZW1wbGF0ZSh7YmFua19hY2NvdW50X251bWJlcjogdGhpcy5iYW5rUmVsYXRpb25zaGlwLmFscGFjYV9hY2NvdW50X251bWJlcn0pKTtcclxuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYmluZEV2ZW50cygpIHtcclxuICAgICAgICBsZXQgbmV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduZXh0X2FjaF9hY2NvdW50X251bWJlcicpO1xyXG4gICAgICAgIG5leHQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtb25leVRyYW5zZmVycmVkID0gbmV3IE1vbmV5VHJhbnNmZXJyZWQodGhpcy5hVXNkRnVuZCwgdGhpcy5iYW5rUmVsYXRpb25zaGlwKVxyXG4gICAgICAgICAgICBtb25leVRyYW5zZmVycmVkLnNob3coKTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IEJhbmtJbmZvSHRtbCBmcm9tICcuLi8uLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvRmlyc3RUcmFuc2ZlclNldHVwL0JhbmtJbmZvLmh0bWwnXHJcbmltcG9ydCB7QmFua1JlbGF0aW9uc2hpcH0gZnJvbSBcIi4uLy4uLy4uLy4uL2R0by9hbHBhY2EvQmFua1JlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgV2lyZVRyYW5zZmVyTW9uZXkgZnJvbSBcIi4vV2lyZVRyYW5zZmVyTW9uZXlcIjtcclxuaW1wb3J0IEFDSFRyYW5zZmVyQWNjb3VudE51bWJlciBmcm9tICcuL0FDSFRyYW5zZmVyQWNjb3VudE51bWJlcic7XHJcbmltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXBCYXNlIGZyb20gXCIuL0ZpcnN0VHJhbnNmZXJTZXR1cEJhc2VcIjtcclxuaW1wb3J0IEFVU0RGdW5kIGZyb20gXCIuLi9BVVNERnVuZFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFua0luZm8gZXh0ZW5kcyBGaXJzdFRyYW5zZmVyU2V0dXBCYXNlIHtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoYVVzZEZ1bmQ6IEFVU0RGdW5kLCBiYW5rUmVsYXRpb25zaGlwOiBCYW5rUmVsYXRpb25zaGlwKSB7XHJcbiAgICAgICAgc3VwZXIoYVVzZEZ1bmQsIGJhbmtSZWxhdGlvbnNoaXApO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIGxldCBiYW5rSW5mb1RlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEJhbmtJbmZvSHRtbCk7XHJcbiAgICAgICAgbGV0IGJhbmtJbmZvSHRtbCA9IGJhbmtJbmZvVGVtcGxhdGUoe1xyXG4gICAgICAgICAgICB3aXJlOiB0aGlzLmJhbmtSZWxhdGlvbnNoaXAudHJhbnNmZXJfdHlwZSA9PSAnd2lyZScsXHJcbiAgICAgICAgICAgIGFjY291bnRfbnVtYmVyOiB0aGlzLmJhbmtSZWxhdGlvbnNoaXAuYWxwYWNhX2FjY291bnRfbnVtYmVyXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMucmVuZGVyKGJhbmtJbmZvSHRtbCk7XHJcbiAgICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IG5leHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYmFua19pbmZvX25leHQnKTtcclxuICAgICAgICBuZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5iYW5rUmVsYXRpb25zaGlwLnRyYW5zZmVyX3R5cGUgPT0gJ3dpcmUnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgd2lyZVRyYW5zZmVyTW9uZXkgPSBuZXcgV2lyZVRyYW5zZmVyTW9uZXkodGhpcy5hVXNkRnVuZCwgdGhpcy5iYW5rUmVsYXRpb25zaGlwKTtcclxuICAgICAgICAgICAgICAgIHdpcmVUcmFuc2Zlck1vbmV5LnNob3coKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBhY2ggPSBuZXcgQUNIVHJhbnNmZXJBY2NvdW50TnVtYmVyKHRoaXMuYVVzZEZ1bmQsIHRoaXMuYmFua1JlbGF0aW9uc2hpcCk7XHJcbiAgICAgICAgICAgICAgICBhY2guc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsImltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vQVVTREZ1bmRcIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBGaXJzdFRyYW5zZmVyU2V0dXBIdG1sIGZyb20gJy4uLy4uLy4uLy4uL2h0bWwvbW9kYWwvRnVuZGluZy9GaXJzdFRyYW5zZmVyU2V0dXAvRmlyc3RUcmFuc2ZlclNldHVwLmh0bWwnXHJcbmltcG9ydCBCYW5rSW5mbyBmcm9tIFwiLi4vRmlyc3RUcmFuc2ZlclNldHVwL0JhbmtJbmZvXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaXJzdFRyYW5zZmVyU2V0dXAge1xyXG5cclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgYVVzZEZ1bmQ6IEFVU0RGdW5kXHJcbiAgICBiYW5rUmVsYXRpb25zaGlwPzogQmFua1JlbGF0aW9uc2hpcDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcywgYVVzZEZ1bmQ6IEFVU0RGdW5kKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLmFVc2RGdW5kID0gYVVzZEZ1bmQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coYmFua1JlbGF0aW9uc2hpcDogQmFua1JlbGF0aW9uc2hpcCkge1xyXG4gICAgICAgIHRoaXMuYmFua1JlbGF0aW9uc2hpcCA9IGJhbmtSZWxhdGlvbnNoaXA7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShGaXJzdFRyYW5zZmVyU2V0dXBIdG1sKTtcclxuICAgICAgICB0aGlzLmFVc2RGdW5kLm1vZGFsLnNob3dNb2RhbCgnU2V0dXAgdHJhbnNmZXInLCB0ZW1wbGF0ZSh7fSkpO1xyXG5cclxuICAgICAgICBsZXQgYmFua0luZm8gPSBuZXcgQmFua0luZm8odGhpcy5hVXNkRnVuZCwgYmFua1JlbGF0aW9uc2hpcCk7XHJcbiAgICAgICAgYmFua0luZm8uc2hvdygpO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBNb2RhbCBmcm9tIFwiLi4vTW9kYWxcIjtcclxuaW1wb3J0IFNlbGVjdEZ1bmRpbmdUeXBlIGZyb20gXCIuL1JlbGF0aW9uc2hpcC9TZWxlY3RGdW5kaW5nVHlwZVwiO1xyXG5pbXBvcnQgQUNIUmVsYXRpb25zaGlwIGZyb20gXCIuL1JlbGF0aW9uc2hpcC9BQ0hSZWxhdGlvbnNoaXBcIjtcclxuaW1wb3J0IFRyYW5zZmVyTm90aWZpY2F0aW9uIGZyb20gXCIuL1RyYW5zZmVyTm90aWZpY2F0aW9uXCI7XHJcbmltcG9ydCBXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAgZnJvbSBcIi4vUmVsYXRpb25zaGlwL1dpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcFwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IFRyYW5zZmVyTm90aWZpZWQgZnJvbSBcIi4vVHJhbnNmZXJOb3RpZmllZFwiO1xyXG5pbXBvcnQge1RyYW5zZmVyRGlyZWN0aW9uRW51bX0gZnJvbSBcIi4uLy4uLy4uL2VudW1zL1RyYW5zZmVyRGlyZWN0aW9uRW51bVwiO1xyXG5pbXBvcnQgRmlyc3RUcmFuc2ZlclNldHVwIGZyb20gXCIuL0ZpcnN0VHJhbnNmZXJTZXR1cC9GaXJzdFRyYW5zZmVyU2V0dXBcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFVU0RGdW5kIHtcclxuXHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuICAgIG1vZGFsOiBNb2RhbDtcclxuXHJcbiAgICBzZWxlY3RGdW5kaW5nVHlwZTogU2VsZWN0RnVuZGluZ1R5cGU7XHJcbiAgICBhY2hSZWxhdGlvbnNoaXA6IEFDSFJlbGF0aW9uc2hpcDtcclxuICAgIHdpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcDogV2lyZVRyYW5zZmVyUmVsYXRpb25zaGlwO1xyXG5cclxuICAgIGZpcnN0VHJhbnNmZXJTZXR1cDogRmlyc3RUcmFuc2ZlclNldHVwO1xyXG4gICAgdHJhbnNmZXJOb3RpZmljYXRpb246IFRyYW5zZmVyTm90aWZpY2F0aW9uO1xyXG4gICAgdHJhbnNmZXJOb3RpZmllZDogVHJhbnNmZXJOb3RpZmllZDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdEZ1bmRpbmdUeXBlID0gbmV3IFNlbGVjdEZ1bmRpbmdUeXBlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYWNoUmVsYXRpb25zaGlwID0gbmV3IEFDSFJlbGF0aW9uc2hpcCh0aGlzKTtcclxuICAgICAgICB0aGlzLndpcmVUcmFuc2ZlclJlbGF0aW9uc2hpcCA9IG5ldyBXaXJlVHJhbnNmZXJSZWxhdGlvbnNoaXAodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuZmlyc3RUcmFuc2ZlclNldHVwID0gbmV3IEZpcnN0VHJhbnNmZXJTZXR1cChtb3JhbGlzLCB0aGlzKTtcclxuICAgICAgICB0aGlzLnRyYW5zZmVyTm90aWZpY2F0aW9uID0gbmV3IFRyYW5zZmVyTm90aWZpY2F0aW9uKG1vcmFsaXMsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJOb3RpZmllZCA9IG5ldyBUcmFuc2Zlck5vdGlmaWVkKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93KCkge1xyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBiYW5rUmVsYXRpb25zaGlwID0gYXdhaXQgdXNlclNlcnZpY2UuZ2V0QmFua1JlbGF0aW9uc2hpcCgpO1xyXG4gICAgICAgIGlmIChiYW5rUmVsYXRpb25zaGlwKSB7XHJcbiAgICAgICAgICAgIGxldCB0cmFuc2ZlcnMgPSBhd2FpdCB1c2VyU2VydmljZS5nZXRMYXRlc3RUcmFuc2ZlcnMoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLkluY29taW5nKTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnRyYW5zZmVyTm90aWZpY2F0aW9uLnNob3coYmFua1JlbGF0aW9uc2hpcCwgdHJhbnNmZXJzKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RUcmFuc2ZlclNldHVwLnNob3coYmFua1JlbGF0aW9uc2hpcCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdEZ1bmRpbmdUeXBlLnNob3coKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93RXJyb3IoZWxlbWVudElkOiBzdHJpbmcsIHJlYXNvbjogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJUZXh0ID0gcmVhc29uO1xyXG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGlkZUVycm9yKGVsZW1lbnRJZDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgRmFrZUZ1bmRpbmdIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvZnVuZGluZy9GYWtlRnVuZGluZy5odG1sJztcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9Nb2RhbFwiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5pbXBvcnQgQ29udHJhY3RJbmZvIGZyb20gXCIuLi8uLi8uLi9jb250cmFjdHMvQ29udHJhY3RJbmZvXCI7XHJcbmltcG9ydCBGdW5kaW5nU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYnJva2VyL0Z1bmRpbmdTZXJ2aWNlXCI7XHJcbmltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IHtyb3VuZEJpZ051bWJlcn0gZnJvbSBcIi4uLy4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xyXG5pbXBvcnQgQVVTREZ1bmQgZnJvbSBcIi4vQVVTREZ1bmRcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWtlQVVTREZ1bmQge1xyXG4gICAgbW9yYWxpczogdHlwZW9mIE1vcmFsaXM7XHJcbiAgICBjdXJyZW50QmFsYW5jZTogQmlnTnVtYmVyO1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLmN1cnJlbnRCYWxhbmNlID0gbmV3IEJpZ051bWJlcigtMSk7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93QVVTREZ1bmQoY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuXHJcbiAgICAgICAgLy90aGlzIGlzIHJlYWwgaW5zdHJ1Y3Rpb24gaG93IHRvIHRyYW5zZmVyIHRvIGJyb2tlclxyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3dBVVNERmFrZUZ1bmQoY2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoRmFrZUZ1bmRpbmdIdG1sKTtcclxuXHJcbiAgICAgICAgbGV0IGNvbnRyYWN0SW5mbyA9IENvbnRyYWN0SW5mby5nZXRDb250cmFjdEluZm8oKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKHthVVNEQWRkcmVzczogY29udHJhY3RJbmZvLkFVU0RfQUREUkVTU30pO1xyXG5cclxuXHJcbiAgICAgICAgdGhpcy5tb2RhbC5zaG93TW9kYWwoJ0Z1bmQgbXkgYWNjb3VudCAoRmFrZSBtb25leSknLCBjb250ZW50KTtcclxuXHJcbiAgICAgICAgbGV0IGFkZFRvV2FsbGV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZFRva2VuVG9XYWxsZXQnKTtcclxuICAgICAgICBpZiAoIWFkZFRvV2FsbGV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGFkZFRvV2FsbGV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbygpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdhbGxldEhlbHBlci5hZGRUb2tlblRvV2FsbGV0KGNvbnRyYWN0SW5mby5BVVNEX0FERFJFU1MsICdhVVNEJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Q29weUZpZWxkKCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB0aGlzLnNob3dDb3B5RmllbGQoKTtcclxuXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IHJlZ2lzdGVyQmFua0luZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVnaXN0ZXJCYW5rSW5mbycpO1xyXG4gICAgICAgIHJlZ2lzdGVyQmFua0luZm8/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGFVc2RGdW5kID0gbmV3IEFVU0RGdW5kKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGFVc2RGdW5kLnNob3coKTtcclxuICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgbGV0IHJlcXVlc3RGYWtlQVVTRCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXF1ZXN0RmFrZUFVU0QnKTtcclxuICAgICAgICByZXF1ZXN0RmFrZUFVU0Q/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICByZXF1ZXN0RmFrZUFVU0QhLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBmdW5kaW5nU2VydmljZSA9IG5ldyBGdW5kaW5nU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZnVuZGluZ1NlcnZpY2UucmVxdWVzdEZha2VGdW5kaW5nKClcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcldoaWxlRnVuZGluZyh7fSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc3VjY2VzcycsIHJlc3VsdC5zdWNjZXNzKTtcclxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIGxldCBmdW5kaW5nRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnVuZGluZ0Vycm9yJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnVuZGluZ0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEZha2VBVVNEIS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmRpbmdFcnJvci5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICBmdW5kaW5nRXJyb3IuaW5uZXJIVE1MID0gcmVzdWx0Lm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmRpbmdFcnJvciEuY2xhc3NMaXN0LmFkZCgnZC1ub25lJylcclxuICAgICAgICAgICAgICAgICAgICB9LCAxMCAqIDEwMDApXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgIGxldCBiZWZvcmVGdW5kaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JlZm9yZUZ1bmRpbmcnKTtcclxuICAgICAgICAgICAgICAgIGxldCBhZnRlckZ1bmRpbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWZ0ZXJGdW5kaW5nJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJlZm9yZUZ1bmRpbmcgfHwgIWFmdGVyRnVuZGluZykgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZEFVU0RCYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVGdW5kaW5nLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICAgICAgYWZ0ZXJGdW5kaW5nLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcldoaWxlRnVuZGluZyhyZXN1bHQpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NhbGxiYWNrKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGxvYWRBVVNEQmFsYW5jZSgpIHtcclxuICAgICAgICBsZXQgY3VycmVudEFVU0RCYWxhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnJlbnRBVVNEQmFsYW5jZScpXHJcbiAgICAgICAgaWYgKCFjdXJyZW50QVVTREJhbGFuY2UpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGFVU0RTZXJ2aWNlID0gbmV3IEFVU0RTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSB1c2VyU2VydmljZS5nZXRFdGhBZGRyZXNzKCk7XHJcblxyXG4gICAgICAgIGxldCBhbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApO1xyXG4gICAgICAgIGlmIChldGhBZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIGFtb3VudCA9IGF3YWl0IGFVU0RTZXJ2aWNlLmdldEFVU0RCYWxhbmNlT2YoZXRoQWRkcmVzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRBVVNEQmFsYW5jZS5pbm5lckhUTUwgPSAnJCcgKyByb3VuZEJpZ051bWJlcihhbW91bnQpLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRCYWxhbmNlLmVxKC0xKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCYWxhbmNlID0gYW1vdW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhbGFuY2UuZXEoYW1vdW50KSkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZEFVU0RCYWxhbmNlKCk7XHJcbiAgICAgICAgICAgIH0sIDUgKiAxMDAwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2hvd0NvcHlGaWVsZCgpIHtcclxuXHJcbiAgICAgICAgbGV0IG5lZWRUb0NvcHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmVlZFRvQ29weScpO1xyXG4gICAgICAgIGlmICghbmVlZFRvQ29weSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBuZWVkVG9Db3B5LmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZXJyb3JXaGlsZUZ1bmRpbmcocmVzdWx0OiBhbnkpIHtcclxuICAgICAgICBsZXQgYmVmb3JlRnVuZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiZWZvcmVGdW5kaW5nJyk7XHJcbiAgICAgICAgbGV0IGVycm9yQWZ0ZXJGdW5kaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yQWZ0ZXJUcnlGdW5kaW5nJyk7XHJcbiAgICAgICAgaWYgKCFiZWZvcmVGdW5kaW5nIHx8ICFlcnJvckFmdGVyRnVuZGluZykgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAocmVzdWx0Lm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgZXJyb3JBZnRlckZ1bmRpbmcuaW5uZXJIVE1MID0gcmVzdWx0Lm1lc3NhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJlZm9yZUZ1bmRpbmcuY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XHJcbiAgICAgICAgZXJyb3JBZnRlckZ1bmRpbmcuY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQgaWQ9XFxcIndpdGhkcmF3SW5wdXRcXFwiPlxcclxcblxcclxcbiAgICB7eyNpZiBiYW5rLmJhbmtfY29kZV90eXBlfX1cXHJcXG4gICAgWW91ciBtb25leSB3aWxsIGJlIHNlbnQgdG8ge3tiYW5rLm5hbWV9fSB0byBhY2NvdW50IG51bWJlciB7e2JhbmsuYWNjb3VudF9udW1iZXJ9fS5cXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICBPdXRnb2luZyBJbnRlcm5hdGlvbmFsIFdpcmUgVHJhbnNmZXJzIGNvc3QgaXMgJHt7dHJhbnNmZXJDb3N0fX0uPGJyLz5cXHJcXG4gICAgRmVlcyB3aWxsIGJlIGRlZHVjdGVkIGZyb20gdGhlIGFtb3VudC5cXHJcXG4gICAge3svaWZ9fVxcclxcbiAgICB7eyN1bmxlc3MgYmFuay5iYW5rX2NvZGVfdHlwZX19XFxyXFxuICAgIFlvdXIgbW9uZXkgd2lsbCBiZSBzZW50IHRvIGFjY291bnQgbnVtYmVyIHt7YmFuay5iYW5rX2FjY291bnRfbnVtYmVyfX0uXFxyXFxuICAgIDxici8+PGJyLz5cXHJcXG4gICAgQUNIIHRyYW5zZmVyIGNvc3RzIGlzICR7e3RyYW5zZmVyQ29zdH19LiBGZWVzIHdpbGwgYmUgZGVkdWN0ZWQgZnJvbSB0aGUgYW1vdW50LlxcclxcbiAgICB7ey91bmxlc3N9fVxcclxcbiAgICA8Zm9ybSBpZD1cXFwid2l0aGRyYXdGb3JtXFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbD5BbW91bnQgdG8gd2l0aGRyYXdcXHJcXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwidGVsXFxcIiBuYW1lPVxcXCJhbW91bnRcXFwiIGlkPVxcXCJhbW91bnRcXFwiLz5cXHJcXG4gICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCIgaWQ9XFxcIndpdGhkcmF3QW1vdW50RXJyb3JcXFwiPlRoZSBhbW91bnQgaXMgbG93ZXIgdGhhbiB0aGUgY29zdCBvZiB0cmFuc2ZlcjwvZGl2PlxcclxcbiAgICAgICAgPGJ1dHRvbiBpZD1cXFwiY29uZmlybVdpdGhkcmF3XFxcIj5Db25maXJtIHdpdGhkcmF3PC9idXR0b24+XFxyXFxuICAgIDwvZm9ybT5cXHJcXG4gICAge3t7VHJhbnNmZXJzfX19XFxyXFxuPC9maWVsZHNldD5cXHJcXG5cXHJcXG48ZmllbGRzZXQgaWQ9XFxcIndpdGhkcmF3Q29uZmlybVxcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxyXFxuICAgIFlvdSBhcmUgYWJvdXQgdG8gd2l0aGRyYXcgJDxzcGFuIGlkPVxcXCJ3aXRoZHJhd0Ftb3VudFRleHRcXFwiPjwvc3Bhbj4gZnJvbSB5b3VyIGFjY291bnRcXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwid2FybmluZ0JhclxcXCI+XFxyXFxuICAgICAgICBXYXJuaW5nOiBUaGUgZmVlIG9mIHRoaXMgdHJhbnNhY3Rpb24gd2lsbCBiZSAkPHNwYW4gaWQ9XFxcImZlZVdhcm5pbmdcXFwiPjwvc3Bhbj5cXHJcXG4gICAgICAgIGFuZCBpcyA8c3BhbiBpZD1cXFwiZmVlUGVyY2VudGFnZVxcXCI+PC9zcGFuPiUgb2YgdGhlIGFtb3VudC5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwid2l0aGRyYXdFcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgIDxidXR0b24gaWQ9XFxcImNvbmZpcm1XaXRoZHJhd0J1dHRvblxcXCI+RXhlY3V0ZSB0cmFuc2ZlcjwvYnV0dG9uPlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBXaXRoZHJhd01vZGFsSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0Z1bmRpbmcvV2l0aGRyYXdNb2RhbC5odG1sJ1xyXG5pbXBvcnQgTW9yYWxpcyBmcm9tIFwibW9yYWxpc1wiO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4uL01vZGFsXCI7XHJcbmltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IHtCYW5rUmVsYXRpb25zaGlwfSBmcm9tIFwiLi4vLi4vLi4vZHRvL2FscGFjYS9CYW5rUmVsYXRpb25zaGlwXCI7XHJcbmltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvU3RyaW5nSGVscGVyXCI7XHJcbmltcG9ydCB7aXNKU09OLCByb3VuZE51bWJlcn0gZnJvbSBcIi4uLy4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBUcmFuc2ZlcnNMaXN0IGZyb20gXCIuL1RyYW5zZmVyc0xpc3RcIjtcclxuaW1wb3J0IHtUcmFuc2ZlckRpcmVjdGlvbkVudW19IGZyb20gXCIuLi8uLi8uLi9lbnVtcy9UcmFuc2ZlckRpcmVjdGlvbkVudW1cIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXRoZHJhd01vZGFsIHtcclxuXHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuICAgIHByaXZhdGUgdXNlclNlcnZpY2U6IFVzZXJTZXJ2aWNlO1xyXG4gICAgcHJpdmF0ZSBiYW5rSW5mbz86IEJhbmtSZWxhdGlvbnNoaXA7XHJcbiAgICBwcml2YXRlIHdpcmVUcmFuc2ZlckNvc3QgPSA1MDtcclxuICAgIHByaXZhdGUgYWNoVHJhbnNmZXJDb3N0ID0gMjU7XHJcbiAgICBwcml2YXRlIHRyYW5zZmVyQ29zdDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBjdXJyZW50QmFsYW5jZT86IEJpZ051bWJlcjtcclxuICAgIHByaXZhdGUgdHJhbnNmZXJzTGlzdDogVHJhbnNmZXJzTGlzdDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICAgICAgdGhpcy51c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmZXJDb3N0ID0gdGhpcy53aXJlVHJhbnNmZXJDb3N0O1xyXG5cclxuICAgICAgICB0aGlzLnRyYW5zZmVyc0xpc3QgPSBuZXcgVHJhbnNmZXJzTGlzdCh0aGlzLm1vcmFsaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgbGV0IGJhbmtSZWxhdGlvbnNoaXBzID0gYXdhaXQgdGhpcy51c2VyU2VydmljZS5nZXRCYW5rUmVsYXRpb25zaGlwKCk7XHJcbiAgICAgICAgaWYgKCFiYW5rUmVsYXRpb25zaGlwcykge1xyXG4gICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ1dpdGhkcmF3IGluZm9ybWF0aW9uJywgXCJZb3UgaGF2ZW4ndCBzZXR1cCBiYW5rIGNvbm5lY3Rpb24uIFlvdSBjYW5ub3Qgd2l0aGRyYXcgZnJvbSB3aXRob3V0IGJhbmsgY29ubmVjdGlvblwiKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHRyYW5zZmVycyA9IGF3YWl0IHRoaXMudXNlclNlcnZpY2UuZ2V0TGF0ZXN0VHJhbnNmZXJzKFRyYW5zZmVyRGlyZWN0aW9uRW51bS5PdXRnb2luZylcclxuICAgICAgICBsZXQgdHJhbnNmZXJzSHRtbCA9IGF3YWl0IHRoaXMudHJhbnNmZXJzTGlzdC5yZW5kZXIoVHJhbnNmZXJEaXJlY3Rpb25FbnVtLk91dGdvaW5nLCB0cmFuc2ZlcnMpO1xyXG4gICAgICAgIGxldCBldGhBZGRyZXNzID0gdGhpcy51c2VyU2VydmljZS5nZXRFdGhBZGRyZXNzKCk7XHJcblxyXG4gICAgICAgIGxldCBhdXNkU2VydmljZSA9IG5ldyBBVVNEU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEJhbGFuY2UgPSBuZXcgQmlnTnVtYmVyKDApO1xyXG4gICAgICAgIGlmIChldGhBZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhbGFuY2UgPSBhd2FpdCBhdXNkU2VydmljZS5nZXRBVVNEQmFsYW5jZU9mKGV0aEFkZHJlc3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEJhbGFuY2UuZXEoMCkpIHtcclxuICAgICAgICAgICAgbGV0IHRtcCA9IEhhbmRsZWJhcnMuY29tcGlsZShcIllvdXIgY3VycmVudCBiYWxhbmNlIGlzICQwLiBUaGVyZSBpcyBub3RoaW5nIHRvIHdpdGhkcmF3LiB7e3t0cmFuc2ZlcnN9fX1cIik7XHJcbiAgICAgICAgICAgIG1vZGFsLnNob3dNb2RhbCgnV2l0aGRyYXcgaW5mb3JtYXRpb24nLCB0bXAoe3RyYW5zZmVyczogdHJhbnNmZXJzSHRtbH0pKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgd2l0aGRyYXdUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShXaXRoZHJhd01vZGFsSHRtbCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmFua0luZm8gPSBiYW5rUmVsYXRpb25zaGlwcztcclxuICAgICAgICB0aGlzLnRyYW5zZmVyQ29zdCA9ICh0aGlzLmJhbmtJbmZvLmJhbmtfY29kZV90eXBlKSA/IHRoaXMud2lyZVRyYW5zZmVyQ29zdCA6IHRoaXMuYWNoVHJhbnNmZXJDb3N0O1xyXG5cclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIGFtb3VudDogdGhpcy5jdXJyZW50QmFsYW5jZSxcclxuICAgICAgICAgICAgdHJhbnNmZXJDb3N0OiB0aGlzLnRyYW5zZmVyQ29zdCxcclxuICAgICAgICAgICAgVHJhbnNmZXJzOiB0cmFuc2ZlcnNIdG1sLFxyXG4gICAgICAgICAgICBiYW5rOiB0aGlzLmJhbmtJbmZvIVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIG1vZGFsLnNob3dNb2RhbCgnV2l0aGRyYXcgaW5mb3JtYXRpb24nLCB3aXRoZHJhd1RlbXBsYXRlKG9iaikpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuICAgICAgICB0aGlzLnRyYW5zZmVyc0xpc3QuYmluZEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYmluZEV2ZW50cygpIHtcclxuICAgICAgICBsZXQgY29uZmlybVdpdGhkcmF3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm1XaXRoZHJhdycpO1xyXG4gICAgICAgIGNvbmZpcm1XaXRoZHJhdz8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFua0luZm8pIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBhbW91bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW1vdW50JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KGFtb3VudC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGFtb3VudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyc2VGbG9hdChhbW91bnQudmFsdWUpIDw9IHRoaXMudHJhbnNmZXJDb3N0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgd2l0aGRyYXdBbW91bnRFcnJvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aXRoZHJhd0Ftb3VudEVycm9yJyk7XHJcbiAgICAgICAgICAgICAgICB3aXRoZHJhd0Ftb3VudEVycm9yIS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgICAgICAgIGFtb3VudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYW1vdW50LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ2ZhbHNlJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1dpdGhkcmF3Q29uZmlybWF0aW9uKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHNob3dXaXRoZHJhd0NvbmZpcm1hdGlvbigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYmFua0luZm8pIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGFtb3VudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbW91bnQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBsZXQgd2l0aGRyYXdJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3aXRoZHJhd0lucHV0Jyk7XHJcbiAgICAgICAgd2l0aGRyYXdJbnB1dD8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcblxyXG4gICAgICAgIGxldCB3aXRoZHJhd0NvbmZpcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2l0aGRyYXdDb25maXJtJyk7XHJcbiAgICAgICAgd2l0aGRyYXdDb25maXJtPy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKVxyXG5cclxuICAgICAgICBsZXQgd2l0aGRyYXdBbW91bnRUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpdGhkcmF3QW1vdW50VGV4dCcpO1xyXG4gICAgICAgIGxldCBmZWVXYXJuaW5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZlZVdhcm5pbmcnKTtcclxuICAgICAgICBsZXQgZmVlUGVyY2VudGFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmZWVQZXJjZW50YWdlJyk7XHJcblxyXG4gICAgICAgIHdpdGhkcmF3QW1vdW50VGV4dCEuaW5uZXJUZXh0ID0gYW1vdW50LnZhbHVlO1xyXG4gICAgICAgIGZlZVdhcm5pbmchLmlubmVyVGV4dCA9IHRoaXMudHJhbnNmZXJDb3N0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgZmVlUGVyY2VudGFnZSEuaW5uZXJUZXh0ID0gcm91bmROdW1iZXIoKHRoaXMudHJhbnNmZXJDb3N0IC8gcGFyc2VGbG9hdChhbW91bnQudmFsdWUpKSAqIDEwMCkudG9TdHJpbmcoKTtcclxuXHJcblxyXG4gICAgICAgIGxldCBjb25maXJtV2l0aGRyYXdCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZmlybVdpdGhkcmF3QnV0dG9uJyk7XHJcbiAgICAgICAgY29uZmlybVdpdGhkcmF3QnV0dG9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnVzZXJTZXJ2aWNlLmNyZWF0ZVRyYW5zZmVyKGFtb3VudC52YWx1ZSwgVHJhbnNmZXJEaXJlY3Rpb25FbnVtLk91dGdvaW5nKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRyYW5zZmVycyA9IGF3YWl0IHRoaXMudXNlclNlcnZpY2UuZ2V0TGF0ZXN0VHJhbnNmZXJzKFRyYW5zZmVyRGlyZWN0aW9uRW51bS5PdXRnb2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2l0aGRyYXdDb25maXJtIS5pbm5lckhUTUwgPSBhd2FpdCB0aGlzLnRyYW5zZmVyc0xpc3QucmVuZGVyKFRyYW5zZmVyRGlyZWN0aW9uRW51bS5PdXRnb2luZywgdHJhbnNmZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZmVyc0xpc3QuYmluZEV2ZW50cygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXRoZHJhd0Vycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpdGhkcmF3RXJyb3InKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXdpdGhkcmF3RXJyb3IpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpdGhkcmF3RXJyb3IgJiYgaXNKU09OKHJlYXNvbi5tZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBKU09OLnBhcnNlKHJlYXNvbi5tZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aGRyYXdFcnJvci5pbm5lclRleHQgPSBlcnJvci5zZXJ2ZXJFcnJvci5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhkcmF3RXJyb3IuaW5uZXJUZXh0ID0gcmVhc29uLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aXRoZHJhd0Vycm9yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQVVTRFNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2Jsb2NrY2hhaW4vQVVTRFNlcnZpY2VcIjtcclxuaW1wb3J0IHtyb3VuZEJpZ051bWJlcn0gZnJvbSBcIi4uLy4uL3V0aWwvSGVscGVyXCI7XHJcbmltcG9ydCBOZXR3b3JrSW5mbyBmcm9tIFwiLi4vLi4vbmV0d29ya3MvTmV0d29ya0luZm9cIjtcclxuaW1wb3J0IEZha2VBVVNERnVuZCBmcm9tIFwiLi4vbW9kYWxzL0Z1bmRpbmcvRmFrZUFVU0RGdW5kXCI7XHJcbmltcG9ydCBBVVNERnVuZCBmcm9tIFwiLi4vbW9kYWxzL0Z1bmRpbmcvQVVTREZ1bmRcIjtcclxuaW1wb3J0IFdpdGhkcmF3TW9kYWwgZnJvbSBcIi4uL21vZGFscy9GdW5kaW5nL1dpdGhkcmF3TW9kYWxcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCBDb250cmFjdEluZm8gZnJvbSBcIi4uLy4uL2NvbnRyYWN0cy9Db250cmFjdEluZm9cIjtcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9tb2RhbHMvTW9kYWxcIjtcclxuaW1wb3J0IEFkZFRvV2FsbGV0SHRtbCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL0FkZFRvV2FsbGV0Lmh0bWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQVVzZEJhbGFuY2Uge1xyXG4gICAgdXNlcjogYW55O1xyXG4gICAgbW9yYWxpczogdHlwZW9mIE1vcmFsaXM7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMsIHVzZXI6IGFueSkge1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGZvcmNlTG9hZEFVU0RCYWxhbmNlVUkobW9yYWxpczogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICBsZXQgdXNlclNlcnZpY2UgPSBuZXcgVXNlclNlcnZpY2UobW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IHVzZXIgPSB1c2VyU2VydmljZS5nZXRVc2VyKCk7XHJcbiAgICAgICAgbGV0IHVpID0gbmV3IEFVc2RCYWxhbmNlKG1vcmFsaXMsIHVzZXIpXHJcbiAgICAgICAgQVVTRFNlcnZpY2UubGFzdFVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBhd2FpdCB1aS5sb2FkQVVTREJhbGFuY2VVSSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBsb2FkQVVTREJhbGFuY2VVSSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgdXNlckluZm9BVXNkQmFsYW5jZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VySW5mb0FVc2RCYWxhbmNlJyk7XHJcbiAgICAgICAgbGV0IGZyb250cGFnZUFVc2RCYWxhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Zyb250cGFnZUFVc2RCYWxhbmNlJyk7XHJcblxyXG4gICAgICAgIGlmICghdXNlckluZm9BVXNkQmFsYW5jZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMudXNlci5nZXQoJ2FscGFjYUlkJykpIHtcclxuICAgICAgICAgICAgZnJvbnRwYWdlQVVzZEJhbGFuY2U/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB1c2VySW5mb0FVc2RCYWxhbmNlPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGZyb250cGFnZUFVc2RCYWxhbmNlPy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgdXNlckluZm9BVXNkQmFsYW5jZT8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgYVVTRFNlcnZpY2UgPSBuZXcgQVVTRFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICBsZXQgYVVzZFZhbHVlV2VpID0gYXdhaXQgYVVTRFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZih0aGlzLnVzZXIuZ2V0KCdldGhBZGRyZXNzJykpO1xyXG4gICAgICAgIGxldCBhVXNkVmFsdWUgPSByb3VuZEJpZ051bWJlcihhVXNkVmFsdWVXZWkpO1xyXG5cclxuICAgICAgICBsZXQgZnJvbnRwYWdlQVVTREJhbGFuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJvbnRfcGFnZV9hVVNEX2JhbGFuY2UnKTtcclxuICAgICAgICBpZiAoZnJvbnRwYWdlQVVTREJhbGFuY2UpIGZyb250cGFnZUFVU0RCYWxhbmNlLmlubmVySFRNTCA9ICckJyArIGFVc2RWYWx1ZTtcclxuXHJcbiAgICAgICAgbGV0IHVzZXJfaW5mb19hdXNkX2JhbGFuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlcl9pbmZvX2F1c2RfYmFsYW5jZScpXHJcbiAgICAgICAgaWYgKHVzZXJfaW5mb19hdXNkX2JhbGFuY2UpIHVzZXJfaW5mb19hdXNkX2JhbGFuY2UuaW5uZXJIVE1MID0gJyQnICsgYVVzZFZhbHVlO1xyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG5cclxuICAgICAgICBsZXQgYmFsYW5jZV92YWx1ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5iYWxhbmNlX3ZhbHVlJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGJhbGFuY2VfdmFsdWUpIHtcclxuICAgICAgICAgICAgYmFsYW5jZV92YWx1ZS5pbm5lckhUTUwgPSAnJCcgKyBhVXNkVmFsdWUudG9GaXhlZCgpO1xyXG4gICAgICAgICAgICBiYWxhbmNlX3ZhbHVlLnRpdGxlID0gYVVzZFZhbHVlV2VpLnRvRml4ZWQoKTtcclxuICAgICAgICAgICAgYmFsYW5jZV92YWx1ZS5kYXRhc2V0Wyd0b29sdGlwJ10gPSBhVXNkVmFsdWVXZWkudG9GaXhlZCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFVc2RWYWx1ZS5pc0xlc3NUaGFuKDEwKSkge1xyXG4gICAgICAgICAgICBsZXQgZnJvbnRwYWdlX2Z1bmRfYWNjb3VudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcm9udHBhZ2VfZnVuZF9hY2NvdW50Jyk7XHJcbiAgICAgICAgICAgIGZyb250cGFnZV9mdW5kX2FjY291bnQ/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBsZXQgYWRkX2FVU0RfdG9fd2FsbGV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmFkZF9hVVNEX3RvX3dhbGxldCcpO1xyXG4gICAgICAgIGFkZF9hVVNEX3RvX3dhbGxldC5mb3JFYWNoKGVsZW1lbnQgPT4ge1xyXG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRyYWN0SW5mbyA9IENvbnRyYWN0SW5mby5nZXRDb250cmFjdEluZm8obmV0d29ya0luZm8uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0SGVscGVyLmFkZFRva2VuVG9XYWxsZXQoY29udHJhY3RJbmZvLkFVU0RfQUREUkVTUywgJ2FVU0QnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEFkZFRvV2FsbGV0SHRtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9iaiA9IHtzeW1ib2w6ICdhVVNEJywgYWRkcmVzczogY29udHJhY3RJbmZvLkFVU0RfQUREUkVTU307XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdBZGQgYVVTRCB0b2tlbicsIHRlbXBsYXRlKG9iaikpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGxldCBmdW5kX2FjY291bnRCdXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZ1bmRfYWNjb3VudCcpO1xyXG4gICAgICAgIGZ1bmRfYWNjb3VudEJ1dHRvbnMuZm9yRWFjaChlbGVtZW50ID0+IHtcclxuICAgICAgICAgICAgbGV0IGFVU0RGdW5kaW5nTW9kYWwgPSBuZXcgRmFrZUFVU0RGdW5kKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGlmIChuZXR3b3JrSW5mby5UZXN0TmV0d29yaykge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSAnQ2xpY2sgZm9yIHNvbWUgYVVTRCc7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGFVU0RGdW5kaW5nTW9kYWwuc2hvd0FVU0RGYWtlRnVuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFVc2RGdW5kID0gbmV3IEFVU0RGdW5kKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYVVzZEZ1bmQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCB3aXRoZHJhd19mcm9tX2FjY291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2l0aGRyYXdfZnJvbV9hY2NvdW50Jyk7XHJcbiAgICAgICAgd2l0aGRyYXdfZnJvbV9hY2NvdW50Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgd2l0aGRyYXdNb2RhbCA9IG5ldyBXaXRoZHJhd01vZGFsKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHdpdGhkcmF3TW9kYWwuc2hvdygpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxkaXYgY2xhc3M9XFxcImVycm9yQmFyXFxcIj5Zb3UgYXJlIHJ1bm5pbmcgb24gdGVzdG5ldC4gTm8gcmVhbCB0cmFkZXMgd2lsbCBiZSBleGVjdXRlZC4gPGEgaHJlZj1cXFwiI1xcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVxcXCJzd2l0Y2hfZnJvbV90ZXN0X25ldHdvcmtcXFwiPlN3aXRjaFxcclxcbiAgICB0byBtYWlubmV0PC9hPjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IE1vcmFsaXMgZnJvbSBcIk1vcmFsaXNcIjtcclxuaW1wb3J0IFVzZXJJbmZvRWxlbWVudCBmcm9tICcuLi8uLi9odG1sL2VsZW1lbnRzL1VzZXJJbmZvLmh0bWwnXHJcbmltcG9ydCB7c2hvcnRFdGh9IGZyb20gXCIuLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBQcm92aWRlckluZm8gZnJvbSBcIi4uLy4uL3dhbGxldC9Qcm92aWRlckluZm9cIjtcclxuaW1wb3J0IEt5Y0VkaXROYW1lRm9ybSBmcm9tIFwiLi4vbW9kYWxzL0tZQy9LeWNFZGl0TmFtZUZvcm1cIjtcclxuaW1wb3J0IEt5Y0VkaXRDb250YWN0Rm9ybSBmcm9tIFwiLi4vbW9kYWxzL0tZQy9LeWNFZGl0Q29udGFjdEZvcm1cIjtcclxuaW1wb3J0IEt5Y0VkaXRUcnVzdGVkQ29udGFjdCBmcm9tIFwiLi4vbW9kYWxzL0tZQy9LeWNFZGl0VHJ1c3RlZENvbnRhY3RcIjtcclxuaW1wb3J0IEFVc2RCYWxhbmNlIGZyb20gXCIuL0FVc2RCYWxhbmNlXCI7XHJcbmltcG9ydCBUZXN0TmV0d29ya0Jhbm5lckh0bWwgZnJvbSBcIi4uLy4uL2h0bWwvZWxlbWVudHMvVGVzdE5ldHdvcmtCYW5uZXIuaHRtbFwiO1xyXG5pbXBvcnQgU3dpdGNoTmV0d29ya01vZGFsIGZyb20gXCIuLi9tb2RhbHMvU3dpdGNoTmV0d29ya01vZGFsXCI7XHJcbmltcG9ydCBFeGVjdXRlVHJhZGVCdXR0b24gZnJvbSBcIi4vdHJhZGVwYW5lbC9FeGVjdXRlVHJhZGVCdXR0b25cIjtcclxuaW1wb3J0IExvYWRpbmdIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvTG9hZGluZ0hlbHBlclwiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi8uLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlckluZm8ge1xyXG4gICAgbW9yYWxpczogdHlwZW9mIE1vcmFsaXM7XHJcbiAgICB1c2VyPzogTW9yYWxpcy5BdHRyaWJ1dGVzO1xyXG4gICAgdXNlclNlcnZpY2U6IFVzZXJTZXJ2aWNlO1xyXG4gICAgcHJvdmlkZXJJbmZvOiBQcm92aWRlckluZm87XHJcbiAgICB3YWxsZXRIZWxwZXI6IFdhbGxldEhlbHBlcjtcclxuICAgIHdhbGxldExvYWRlZCA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcywgcHJvdmlkZXJJbmZvOiBQcm92aWRlckluZm8sIHVzZXI/OiBNb3JhbGlzLkF0dHJpYnV0ZXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgICAgIHRoaXMudXNlciA9IHVzZXI7XHJcbiAgICAgICAgdGhpcy51c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJbmZvID0gcHJvdmlkZXJJbmZvO1xyXG4gICAgICAgIHRoaXMud2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih0aGlzLm1vcmFsaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXIoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoIXRoaXMudXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbkZvcldhbGxldENoYW5nZXMoKTtcclxuICAgICAgICB0aGlzLmxvYWRVc2VyTWVudVVJKGVsZW1lbnRJZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkSWZUZXN0TmV0d29yaygpO1xyXG4gICAgICAgIHRoaXMuaWZUcmFkZVBhZ2UoKTtcclxuXHJcbiAgICAgICAgbGV0IGFVc2RCYWxhbmNlID0gbmV3IEFVc2RCYWxhbmNlKHRoaXMubW9yYWxpcywgdGhpcy51c2VyKTtcclxuICAgICAgICBhd2FpdCBhVXNkQmFsYW5jZS5sb2FkQVVTREJhbGFuY2VVSSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxpc3RlbkZvcldhbGxldENoYW5nZXMoKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzLm9uQ2hhaW5DaGFuZ2VkKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzLm9uQWNjb3VudENoYW5nZWQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1vcmFsaXMub25EaXNjb25uZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzLm9uQ29ubmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgbG9hZFVzZXJNZW51VUkoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoIXRoaXMudXNlcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgdXNlckluZm9EaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgICAgIGlmICghdXNlckluZm9EaXYpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIGV0aEFkZHJlc3M6IHRoaXMudXNlci5nZXQoJ2V0aEFkZHJlc3MnKSxcclxuICAgICAgICAgICAgc2hvcnRFdGhBZGRyZXNzOiBzaG9ydEV0aCh0aGlzLnVzZXIuZ2V0KCdldGhBZGRyZXNzJykpLFxyXG4gICAgICAgICAgICB3YWxsZXROYW1lOiB0aGlzLnByb3ZpZGVySW5mby5XYWxsZXROYW1lLFxyXG4gICAgICAgICAgICBuZXR3b3JrTmFtZTogbmV0d29ya0luZm8uQ2hhaW5OYW1lICsgKChuZXR3b3JrSW5mby5UZXN0TmV0d29yaykgPyAnIC0gKFRlc3QgbmV0d29yayknIDogJycpLFxyXG4gICAgICAgICAgICBibG9ja2NoYWluRXhwbG9yZXI6IG5ldHdvcmtJbmZvLkJsb2NrRXhwbG9yZXIgKyAnL2FkZHJlc3MvJyxcclxuICAgICAgICAgICAgaXNNYWdpYzogYXdhaXQgdGhpcy53YWxsZXRIZWxwZXIuaXNNYWdpYygpLFxyXG4gICAgICAgICAgICBjaGFpbklkOiBuZXR3b3JrSW5mby5DaGFpbklkXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVXNlckluZm9FbGVtZW50KTtcclxuICAgICAgICBsZXQgaHRtbCA9IHRlbXBsYXRlKG9iaik7XHJcblxyXG4gICAgICAgIHVzZXJJbmZvRGl2LmlubmVySFRNTCA9IGh0bWw7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuYmluZFVzZXJBY3Rpb25FdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJpbmRVc2VyQWN0aW9uRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBlZGl0TmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0TmFtZScpO1xyXG4gICAgICAgIGVkaXROYW1lPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQga3ljTW9kYWwgPSBuZXcgS3ljRWRpdE5hbWVGb3JtKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGt5Y01vZGFsLnNob3coKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgZWRpdENvbnRhY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZWRpdENvbnRhY3QnKTtcclxuICAgICAgICBlZGl0Q29udGFjdD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBsZXQga3ljTW9kYWwgPSBuZXcgS3ljRWRpdENvbnRhY3RGb3JtKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGt5Y01vZGFsLnNob3coKTtcclxuXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IGVkaXRUcnVzdGVkQ29udGFjdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlZGl0VHJ1c3RlZENvbnRhY3QnKTtcclxuICAgICAgICBlZGl0VHJ1c3RlZENvbnRhY3Q/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgbGV0IGt5Y01vZGFsID0gbmV3IEt5Y0VkaXRUcnVzdGVkQ29udGFjdCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBhd2FpdCBreWNNb2RhbC5zaG93KCk7XHJcblxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCB1c2VySW5mb0Ryb3Bkb3duID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXJJbmZvRHJvcGRvd24nKTtcclxuICAgICAgICBpZiAoIXVzZXJJbmZvRHJvcGRvd24pIHJldHVybjtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHVzZXJJbmZvRHJvcGRvd24gJiYgIXVzZXJJbmZvRHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKCdkLW5vbmUnKSkge1xyXG4gICAgICAgICAgICAgICAgdXNlckluZm9Ecm9wZG93bi5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcclxuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGxldCB1c2VySW5mb0FjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VySW5mb0FjdGlvbicpO1xyXG4gICAgICAgIHVzZXJJbmZvQWN0aW9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIHVzZXJJbmZvRHJvcGRvd24/LmNsYXNzTGlzdC50b2dnbGUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICB1c2VySW5mb0Ryb3Bkb3duPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIFdhbGxldEhlbHBlci5oaWRlTWFnaWNXYWxsZXQoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGRpc2Nvbm5lY3RGcm9tTmV0d29yayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXNjb25uZWN0RnJvbU5ldHdvcmsnKTtcclxuICAgICAgICBkaXNjb25uZWN0RnJvbU5ldHdvcms/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBhd2FpdCB1c2VyU2VydmljZS5sb2dPdXQoKVxyXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCB3YWxsZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2FsbGV0Jyk7XHJcblxyXG4gICAgICAgIHdhbGxldD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcoZXZ0LnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy53YWxsZXRMb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtYWdpY0lmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWdpYy1pZnJhbWUnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmIChtYWdpY0lmcmFtZSkgbWFnaWNJZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgdXNlckluZm9Ecm9wZG93bj8uY2xhc3NMaXN0LmFkZCgnZC1ub25lJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMubW9yYWxpcy5jb25uZWN0b3IubWFnaWMuY29ubmVjdC5zaG93V2FsbGV0KClcclxuICAgICAgICAgICAgICAgIC5jYXRjaChhc3luYyAoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxsZXRMb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5tZXNzYWdlLmluZGV4T2YoJ1VzZXIgZGVuaWVkIGFjY291bnQgYWNjZXNzJykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy51c2VyU2VydmljZS5sb2dPdXQoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydCgnWW91IGhhdmUgYmVlbiBsb2dnZWQgb3V0IG9mIHlvdSB3YWxsZXQgYW5kIG5lZWQgdG8gbG9nIGJhY2sgaW4uIFdlIHdpbGwgbm93IHJlbG9hZCB0aGUgcGFnZSBhbmQgeW91IGNhbiBsb2cgaW4uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBjbG9zZU1lbnVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBtYWdpY0lmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWdpYy1pZnJhbWUnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghbWFnaWNJZnJhbWUpIGNsZWFySW50ZXJ2YWwoY2xvc2VNZW51SW50ZXJ2YWwpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChtYWdpY0lmcmFtZSAmJiBtYWdpY0lmcmFtZS5zdHlsZS5kaXNwbGF5ID09ICdibG9jaycpIHtcclxuICAgICAgICAgICAgICAgICAgICBMb2FkaW5nSGVscGVyLnJlbW92ZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICB1c2VySW5mb0Ryb3Bkb3duPy5jbGFzc0xpc3QuYWRkKCdkLW5vbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLndhbGxldExvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjbG9zZU1lbnVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwMDApO1xyXG5cclxuXHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIGxldCBzd2l0Y2hfbmV0d29yayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzd2l0Y2hfbmV0d29yaycpO1xyXG4gICAgICAgIHN3aXRjaF9uZXR3b3JrPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc3dpdGNoTmV0d29ya01vZGFsID0gbmV3IFN3aXRjaE5ldHdvcmtNb2RhbCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBzd2l0Y2hOZXR3b3JrTW9kYWwuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGxvYWRJZlRlc3ROZXR3b3JrKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tb3JhbGlzLmlzV2ViM0VuYWJsZWQoKSkgcmV0dXJuO1xyXG4gICAgICAgIGlmICghTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKS5UZXN0TmV0d29yaykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZGVyJyk7XHJcbiAgICAgICAgaWYgKCFoZWFkZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFRlc3ROZXR3b3JrQmFubmVySHRtbClcclxuICAgICAgICBoZWFkZXIuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIHRlbXBsYXRlKHt9KSk7XHJcblxyXG4gICAgICAgIGxldCBzd2l0Y2hfZnJvbV90ZXN0X25ldHdvcmsgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3dpdGNoX2Zyb21fdGVzdF9uZXR3b3JrJylcclxuICAgICAgICBzd2l0Y2hfZnJvbV90ZXN0X25ldHdvcms/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3dpdGNoTmV0d29ya01vZGFsID0gbmV3IFN3aXRjaE5ldHdvcmtNb2RhbCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBzd2l0Y2hOZXR3b3JrTW9kYWwuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpZlRyYWRlUGFnZSgpIHtcclxuICAgICAgICBsZXQgYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X2V4ZWN1dGVfdHJhZGUnKTtcclxuICAgICAgICBpZiAoIWJ0bikgcmV0dXJuO1xyXG5cclxuICAgICAgICBFeGVjdXRlVHJhZGVCdXR0b24uSW5zdGFuY2UucmVuZGVyQnV0dG9uKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGJ1dHRvbiBjbGFzcz1cXFwibGltaW5hbF9tYXJrZXRfY29ubmVjdF93YWxsZXQgb3V0bGluZVxcXCI+Q29ubmVjdCB3YWxsZXQ8L2J1dHRvbj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IFVzZXJJbmZvIGZyb20gXCIuLi9lbGVtZW50cy9Vc2VySW5mb1wiO1xyXG5pbXBvcnQgQXV0aGVudGljYXRlU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9BdXRoZW50aWNhdGVTZXJ2aWNlXCI7XHJcbmltcG9ydCB3YWxsZXRCdXR0b24gZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9Db25uZWN0V2FsbGV0QnV0dG9uLmh0bWwnO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4vTW9kYWxcIjtcclxuaW1wb3J0IFByb3ZpZGVySW5mbyBmcm9tIFwiLi4vLi4vd2FsbGV0L1Byb3ZpZGVySW5mb1wiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBUcmFkZVBhZ2UgZnJvbSBcIi4uL3BhZ2VzL1RyYWRlUGFnZVwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25uZWN0V2FsbGV0IHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgcHVibGljIHN0YXRpYyBQcm92aWRlcjogc3RyaW5nO1xyXG4gICAgcHJvdmlkZXJJbmZvOiBQcm92aWRlckluZm87XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLnByb3ZpZGVySW5mbyA9IG5ldyBQcm92aWRlckluZm8obnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlckJ1dHRvbihlbGVtZW50SWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpIS5pbm5lckhUTUwgPSB3YWxsZXRCdXR0b247XHJcblxyXG4gICAgICAgIGxldCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIubGltaW5hbF9tYXJrZXRfY29ubmVjdF93YWxsZXRcIik7XHJcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChhc3luYyAoZWwpID0+IHtcclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY29ubmVjdFdhbGxldChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGNvbm5lY3RXYWxsZXQoYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyhidXR0b24pO1xyXG5cclxuICAgICAgICBsZXQgYXV0aGVudGljYXRpb25TZXJ2aWNlID0gbmV3IEF1dGhlbnRpY2F0ZVNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuXHJcbiAgICAgICAgYXdhaXQgYXV0aGVudGljYXRpb25TZXJ2aWNlLmF1dGhlbnRpY2F0ZVVzZXIoXHJcbiAgICAgICAgICAgICh3YWxsZXRDb25uZWN0aW9uSW5mbzogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndlYjNFbmFibGVkUmVzdWx0KHdhbGxldENvbm5lY3Rpb25JbmZvKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXN5bmMgKHVzZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCB1c2VySW5mbyA9IG5ldyBVc2VySW5mbyh0aGlzLm1vcmFsaXMsIHRoaXMucHJvdmlkZXJJbmZvLCB1c2VyKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHVzZXJJbmZvLnJlbmRlcigndXNlcl9oZWFkZXJfaW5mbycpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2UgPSBuZXcgVHJhZGVQYWdlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcGFnZS5sb2FkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgocmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBFcnJvckluZm8ucmVwb3J0KHJlYXNvbik7XHJcbiAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgd2ViM0VuYWJsZWRSZXN1bHQod2FsbGV0Q29ubmVjdGlvbkluZm86IGFueSkge1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJJbmZvID0gbmV3IFByb3ZpZGVySW5mbyh3YWxsZXRDb25uZWN0aW9uSW5mbyk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCBCbG9ja2NoYWluRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9CbG9ja2NoYWluRXJyb3JcIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi4vLi4vZXJyb3JzL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgS3ljU3RhdHVzIGZyb20gXCIuLi8uLi9kdG8vS3ljU3RhdHVzXCI7XHJcbmltcG9ydCBBVXNkQmFsYW5jZSBmcm9tIFwiLi4vLi4vdWkvZWxlbWVudHMvQVVzZEJhbGFuY2VcIjtcclxuaW1wb3J0IEJsb2NrY2hhaW5TZXJ2aWNlIGZyb20gXCIuL0Jsb2NrY2hhaW5TZXJ2aWNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLWUNTZXJ2aWNlIGV4dGVuZHMgQmxvY2tjaGFpblNlcnZpY2Uge1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgS1lDSW5mbzogYW55O1xyXG4gICAgcHJpdmF0ZSBzdGF0aWMgS3ljUmVzcG9uc2U6IEt5Y1N0YXR1cztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHN1cGVyKG1vcmFsaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldEtZQ0FiaSgpIHtcclxuICAgICAgICBpZiAoS1lDU2VydmljZS5LWUNJbmZvKSByZXR1cm4gS1lDU2VydmljZS5LWUNJbmZvLmFiaTtcclxuXHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcIi4uL2FiaS9LWUMuanNvblwiKTtcclxuICAgICAgICBLWUNTZXJ2aWNlLktZQ0luZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgcmV0dXJuIEtZQ1NlcnZpY2UuS1lDSW5mby5hYmk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBoYXNWYWxpZEtZQygpOiBQcm9taXNlPEt5Y1N0YXR1cz4ge1xyXG4gICAgICAgIGlmIChLWUNTZXJ2aWNlLkt5Y1Jlc3BvbnNlICYmIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2UuaXNWYWxpZEt5YykgcmV0dXJuIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2U7XHJcblxyXG4gICAgICAgIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCdpc1ZhbGlkS3ljJywge2NoYWluSWQ6IHRoaXMubW9yYWxpcy5jaGFpbklkfSlcclxuICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tjaGFpbkVycm9yID0gbmV3IEJsb2NrY2hhaW5FcnJvcihyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrY2hhaW5FcnJvci5hZGRyZXNzSXNOb3RWYWxpZEtZQygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRXJyb3JJbmZvLnJlcG9ydChibG9ja2NoYWluRXJyb3IpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pIGFzIEt5Y1N0YXR1cztcclxuXHJcbiAgICAgICAgaWYgKEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2UuYWxwYWNhSWQpIHtcclxuICAgICAgICAgICAgbGV0IHVzZXIgPSB0aGlzLm1vcmFsaXMuVXNlci5jdXJyZW50KCk7XHJcbiAgICAgICAgICAgIHVzZXI/LnNldCgnYWxwYWNhSWQnLCBLWUNTZXJ2aWNlLkt5Y1Jlc3BvbnNlLmFscGFjYUlkKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhVXNkQmFsYW5jZSA9IG5ldyBBVXNkQmFsYW5jZSh0aGlzLm1vcmFsaXMsIHVzZXIhKTtcclxuICAgICAgICAgICAgYXdhaXQgYVVzZEJhbGFuY2UubG9hZEFVU0RCYWxhbmNlVUkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEtZQ1NlcnZpY2UuS3ljUmVzcG9uc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNhdmVLWUNJbmZvKGRhdGE6IGFueSk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAgICAgbGV0IHVzZXIgPSB0aGlzLm1vcmFsaXMuVXNlci5jdXJyZW50KCk7XHJcbiAgICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFwiWW91IG5lZWQgdG8gYmUgbG9nZ2VkIGluIHRvIGRvIEtZQy4gUGxlYXNlIGxvZ2luIGFnYWluLlwiKVxyXG5cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLkNsb3VkLnJ1bihcImt5Y1JlZ2lzdHJhdGlvblwiLCBkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgdXBkYXRlS1lDSW5mbyhkYXRhOiBhbnkpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgICAgIGxldCB1c2VyID0gdGhpcy5tb3JhbGlzLlVzZXIuY3VycmVudCgpO1xyXG4gICAgICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihcIllvdSBuZWVkIHRvIGJlIGxvZ2dlZCBpbiB0byBkbyBLWUMuIFBsZWFzZSBsb2dpbiBhZ2Fpbi5cIilcclxuXHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oXCJ1cGRhdGVBY2NvdW50XCIsIGRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc1ZhbGlkQWNjb3VudElkKHN0cjogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKCdeWzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzAtNV1bMC05YS1mXXszfS1bMDg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9JCcpO1xyXG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KHN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgdXBkYXRlRG9jdW1lbnRzKHBhcmFtczogYW55KSB7XHJcbiAgICAgICAgbGV0IHVzZXIgPSB0aGlzLm1vcmFsaXMuVXNlci5jdXJyZW50KCk7XHJcbiAgICAgICAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFwiWW91IG5lZWQgdG8gYmUgbG9nZ2VkIGluIHRvIGRvIEtZQy4gUGxlYXNlIGxvZ2luIGFnYWluLlwiKVxyXG5cclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5tb3JhbGlzLkNsb3VkLnJ1bihcImt5Y0FjdGlvblJlcXVpcmVkVXBkYXRlXCIsIHBhcmFtcyk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgQ29udHJhY3RJbmZvIGZyb20gXCIuLi8uLi9jb250cmFjdHMvQ29udHJhY3RJbmZvXCI7XHJcbmltcG9ydCBMaW1pbmFsTWFya2V0U2VydmljZSBmcm9tIFwiLi9MaW1pbmFsTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi8uLi9lcnJvcnMvRXJyb3JJbmZvXCI7XHJcbmltcG9ydCB7QWRkcmVzc1plcm99IGZyb20gXCIuLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcclxuaW1wb3J0IEJsb2NrY2hhaW5FcnJvciBmcm9tIFwiLi4vLi4vZXJyb3JzL0Jsb2NrY2hhaW5FcnJvclwiO1xyXG5pbXBvcnQgQmxvY2tjaGFpblNlcnZpY2UgZnJvbSBcIi4vQmxvY2tjaGFpblNlcnZpY2VcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlY3VyaXR5VG9rZW5TZXJ2aWNlIGV4dGVuZHMgQmxvY2tjaGFpblNlcnZpY2Uge1xyXG5cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBTZWN1cml0eVRva2VuSW5mbzogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgc3VwZXIobW9yYWxpcyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRRdWFudGl0eUJ5QWRkcmVzcyhzeW1ib2w6IHN0cmluZywgZXRoQWRkcmVzczogc3RyaW5nKTogUHJvbWlzZTxCaWdOdW1iZXI+IHtcclxuICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICBsZXQgc3ltYm9sQWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG4gICAgICAgIGlmIChzeW1ib2xBZGRyZXNzID09PSBBZGRyZXNzWmVybykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XHJcblxyXG4gICAgICAgIGxldCBvcHRpb25zID0gYXdhaXQgdGhpcy5nZXRPcHRpb25zKCdiYWxhbmNlT2YnLCBzeW1ib2xBZGRyZXNzLCB7XHJcbiAgICAgICAgICAgIGFjY291bnQ6IGV0aEFkZHJlc3NcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKGJhbGFuY2VPZiA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYW1vdW50ID0gdGhpcy5tb3JhbGlzLlVuaXRzLkZyb21XZWkoYmFsYW5jZU9mLnRvU3RyaW5nKCksIDE4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tjaGFpbkVycm9yID0gbmV3IEJsb2NrY2hhaW5FcnJvcihyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgRXJyb3JJbmZvLnJlcG9ydChibG9ja2NoYWluRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB0cmFuc2ZlcihzeW1ib2xBZGRyZXNzOiBzdHJpbmcsIHF0eTogQmlnTnVtYmVyKSB7XHJcbiAgICAgICAgbGV0IGNvbnRyYWN0SW5mbyA9IENvbnRyYWN0SW5mby5nZXRDb250cmFjdEluZm8oKTtcclxuICAgICAgICBsZXQgb3B0aW9ucyA9IGF3YWl0IHRoaXMuZ2V0T3B0aW9ucygndHJhbnNmZXInLCBzeW1ib2xBZGRyZXNzLCB7XHJcbiAgICAgICAgICAgIHJlY2lwaWVudDogY29udHJhY3RJbmZvLkFVU0RfQUREUkVTUyxcclxuICAgICAgICAgICAgYW1vdW50OiBNb3JhbGlzLlVuaXRzLlRva2VuKHF0eS50b1N0cmluZygpLCAxOClcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZUZ1bmN0aW9uKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaChyZWFzb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrY2hhaW5FcnJvciA9IG5ldyBCbG9ja2NoYWluRXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9ySW5mby5yZXBvcnQoYmxvY2tjaGFpbkVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGdldE9wdGlvbnMoZnVuY3Rpb25OYW1lOiBzdHJpbmcsIHN5bWJvbEFkZHJlc3M6IHN0cmluZywgcGFyYW1zOiBhbnkpIHtcclxuICAgICAgICBsZXQgc2VjdXJpdHlTeW1ib2xBYmkgPSBhd2FpdCB0aGlzLmdldFNlY3VyaXR5VG9rZW5BYmkoKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHN5bWJvbEFkZHJlc3MsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxyXG4gICAgICAgICAgICBhYmk6IHNlY3VyaXR5U3ltYm9sQWJpLFxyXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFNlY3VyaXR5VG9rZW5BYmkoKSB7XHJcbiAgICAgICAgaWYgKFNlY3VyaXR5VG9rZW5TZXJ2aWNlLlNlY3VyaXR5VG9rZW5JbmZvKSByZXR1cm4gU2VjdXJpdHlUb2tlblNlcnZpY2UuU2VjdXJpdHlUb2tlbkluZm8uYWJpO1xyXG5cclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnLi4vYWJpL1NlY3VyaXR5VG9rZW4uanNvbicpO1xyXG4gICAgICAgIFNlY3VyaXR5VG9rZW5TZXJ2aWNlLlNlY3VyaXR5VG9rZW5JbmZvID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xyXG4gICAgICAgIHJldHVybiBTZWN1cml0eVRva2VuU2VydmljZS5TZWN1cml0eVRva2VuSW5mby5hYmk7XHJcbiAgICB9XHJcbn0iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzcyB7XHJcblxyXG4gICAgcHVibGljIHNob3cobWVzc2FnZSA6IHN0cmluZywgcGVyY2VudGFnZSA6IG51bWJlciwgd2FybmluZz8gOiBib29sZWFuLCBoaWRlRWxlbWVudHM/IDogc3RyaW5nW10pIHtcclxuXHJcbiAgICAgICAgbGV0IHByb2dyZXNzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyZXNzJyk7XHJcbiAgICAgICAgaWYgKCFwcm9ncmVzcykgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoaGlkZUVsZW1lbnRzKSB7XHJcbiAgICAgICAgICAgIGhpZGVFbGVtZW50cy5mb3JFYWNoKChlbDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKTtcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvZ3Jlc3Muc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgcHJvZ3Jlc3MuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJwcm9ncmVzc190ZXh0XCI+JyArIG1lc3NhZ2UgKyAnPC9kaXY+JztcclxuICAgICAgICBwcm9ncmVzcy5zdHlsZS53aWR0aCA9IHBlcmNlbnRhZ2UgKyAnJSc7XHJcblxyXG4gICAgICAgIHByb2dyZXNzLmNsYXNzTGlzdC50b2dnbGUoJ3Byb2dyZXNzLWJhci1zdHJpcGVkJywgKHBlcmNlbnRhZ2UgIT0gMTAwKSk7XHJcbiAgICAgICAgcHJvZ3Jlc3MuY2xhc3NMaXN0LnRvZ2dsZSgncHJvZ3Jlc3MtYmFyLWFuaW1hdGVkJywgKHBlcmNlbnRhZ2UgIT0gMTAwKSk7XHJcbiAgICAgICAgaWYgKHdhcm5pbmcpIHtcclxuICAgICAgICAgICAgcHJvZ3Jlc3MuY2xhc3NMaXN0LmFkZCgnYmctd2FybmluZycpO1xyXG4gICAgICAgICAgICBwcm9ncmVzcy5jbGFzc0xpc3QuYWRkKCdwcm9ncmVzc190ZXh0X2F0dG4nKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9ncmVzcy5jbGFzc0xpc3QucmVtb3ZlKCdiZy13YXJuaW5nJyk7XHJcbiAgICAgICAgICAgIHByb2dyZXNzLmNsYXNzTGlzdC5yZW1vdmUoJ3Byb2dyZXNzX3RleHRfYXR0bicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBQcm9ncmVzcyBmcm9tIFwiLi4vLi4vdWkvZWxlbWVudHMvUHJvZ3Jlc3NcIjtcclxuaW1wb3J0IHtUcmFkZVR5cGV9IGZyb20gXCIuLi8uLi9lbnVtcy9UcmFkZVR5cGVcIjtcclxuaW1wb3J0IHt1cHBlckZpcnN0TGV0dGVyfSBmcm9tIFwiLi4vLi4vdXRpbC9IZWxwZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN1YnNjcmlwdGlvbiB7XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0T3JkZXJCdXlUYWJsZVByZWZpeCgpIHtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBOZXR3b3JrSW5mby5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHJldHVybiBuZXR3b3JrSW5mby5OYW1lO1xyXG4gICAgfTtcclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc3Vic2NyaWJlVG9UYWJsZSh0cmFkZVR5cGUgOiBUcmFkZVR5cGUsIG9uVXBkYXRlQ2FsbGJhY2sgOiAob2JqZWN0IDogYW55KSA9PiB2b2lkKSB7XHJcbiAgICAgICAgbGV0IHRhYmxlTmFtZSA9IHRoaXMuZ2V0T3JkZXJCdXlUYWJsZVByZWZpeCgpICsgJ09yZGVyJyArIHRyYWRlVHlwZTtcclxuICAgICAgICBjb25zb2xlLmxvZygnc3Vic2NyaWJlIHRvIHRhYmxlOicgKyB0YWJsZU5hbWUpO1xyXG5cclxuICAgICAgICBsZXQgcXVlcnkgPSBuZXcgdGhpcy5tb3JhbGlzLlF1ZXJ5KHRhYmxlTmFtZSk7XHJcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IHF1ZXJ5LnN1YnNjcmliZSgpO1xyXG5cclxuICAgICAgICBzdWJzY3JpcHRpb24ub24oJ3VwZGF0ZScsIChyZXNwb25zZSA6IGFueSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSByZXNwb25zZS50b0pTT04oKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ29iamVjdCB1cGRhdGVkJywgSlNPTi5zdHJpbmdpZnkob2JqZWN0KSwgb2JqZWN0KTtcclxuICAgICAgICAgICAgbGV0IGV0aExpbmsgPSAnIDxhIGNsYXNzPVwid2hpdGUtbGlua1wiIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL211bWJhaS5wb2x5Z29uc2Nhbi5jb20vdHgvJyArIG9iamVjdC50cmFuc2FjdGlvbl9oYXNoICsgJ1wiPlZpZXcgdHJhbnNhY3Rpb248L2E+JztcclxuXHJcbiAgICAgICAgICAgIG9uVXBkYXRlQ2FsbGJhY2sob2JqZWN0KTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3N0YXR1czonLCBvYmplY3Quc3RhdHVzKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IG5ldyBQcm9ncmVzcygpO1xyXG4gICAgICAgICAgICBpZiAoKCFvYmplY3Quc3RhdHVzICYmIG9iamVjdC5jb25maXJtZWQpIHx8IG9iamVjdC5zdGF0dXMgPT0gJ21vbmV5X3NlbnQnKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcy5zaG93KCdCbG9ja2NoYWluIGhhcyBjb25maXJtZWQsIG1vbmV5IGhhcyBiZWVuIHNlbnQgdG8gYnJva2VyLicgKyBldGhMaW5rLCA1NilcclxuICAgICAgICAgICAgICAgIC8vYmxvY2tjaGFpbiBoYXMgY29uZmlybWVkLCBtb25leSB3aWxsIGFycml2ZSBzb29uIHRvIGJyb2tlclxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5zdGF0dXMgPT0gJ21vbmV5X2Fycml2ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcy5zaG93KCdNb25leSBoYXMgYXJyaXZlZCwgd2lsbCBub3cgZXhlY3V0ZSB5b3VyIGJ1eSBvcmRlci4nICsgZXRoTGluaywgNzApXHJcbiAgICAgICAgICAgICAgICAvL21vbmV5IGhhcyBhcnJpdmVkIHRvIGJyb2tlciwgd2Ugd2lsbCBub3cgZXhlY3V0ZSB5b3VyIG9yZGVyXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0LnN0YXR1cyA9PSAnb3JkZXJfcmVxdWVzdGVkJykge1xyXG4gICAgICAgICAgICAgICAgLy9vcmRlciBoYXMgYmVlbiBleGVjdXRlZCwgd2UgYXJlIHdhaXRpbmcgb24gcmVzcG9uc2UgZnJvbSB0aGUgc3RvY2sgZXhjaGFuZ2VcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzLnNob3coJ0J1eSBvcmRlciBoYXMgYmVlbiBleGVjdXRlZC4gV2Ugd2lsbCB1cGRhdGUgeW91IHdoZW4gaXQgaGFzIGJlZW4gZmlsbGVkLicgKyBldGhMaW5rLCA4NClcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3Quc3RhdHVzID09ICdvcmRlcl9maWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvL29yZGVyIGhhcyBiZWVuIGZpbGxlZCwgeW91IGdvdCBvYmplY3QuZmlsbGVkUXR5IG9mIHNoYXJlcy4gWW91IHdpbGwgc2VlIGl0IHNvb24gaW4geW91ciB3YWxsZXRcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzLnNob3coJ09yZGVyIGhhcyBiZWVuIGZpbGxlZCwgeW91IHdpbGwgcmVjZWl2ZSAnICsgb2JqZWN0LmZpbGxlZFF0eSArICcgJyArIFN5bWJvbCArICcgc29vbiBpbnRvIHlvdXIgd2FsbGV0LicgKyBldGhMaW5rLCAxMDApO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3Muc2hvdygnV2FpdGluZyBmb3IgYmxvY2tjaGFpbiB0byBjb25maXJtIHRyYW5zYWN0aW9uLicsIDk5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbn0iLCJleHBvcnQgZW51bSBUcmFkZVR5cGUge1xyXG4gICAgU2VsbCA9ICdTZWxsJyxcclxuICAgIEJ1eSA9ICdCdXknXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YnV0dG9uIGlkPVxcXCJsaW1pbmFsX21hcmtldF9leGVjdXRlX3RyYWRlXFxcIj48L2J1dHRvbj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiXFxyXFxuPGFydGljbGUgY2xhc3M9XFxcInRyYWRlX2V4ZWN1dGVkXFxcIj5cXHJcXG4gICAgPG5hdj5cXHJcXG4gICAgPHVsPlxcclxcbiAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCJ7e3NlbGxpbmdMb2dvfX1cXFwiPjxiciAvPlxcclxcbiAgICAgICAgICAgIHt7c2VsbGluZ1N5bWJvbH19PGJyIC8+XFxyXFxuICAgICAgICAgICAge3tzZWxsaW5nQW1vdW50fX1cXHJcXG4gICAgICAgIDwvbGk+XFxyXFxuICAgIDwvdWw+XFxyXFxuICAgIDx1bD5cXHJcXG4gICAgICAgIDxsaT4gLS0tLT4gPC9saT5cXHJcXG4gICAgPC91bD5cXHJcXG4gICAgPHVsPlxcclxcbiAgICAgICAgPGxpPlxcclxcbiAgICAgICAgICAgIDxpbWcgc3JjPVxcXCJ7e2J1eWluZ0xvZ299fVxcXCIgLz48YnIgLz5cXHJcXG4gICAgICAgICAgICB7e2J1eWluZ1N5bWJvbH19PGJyIC8+XFxyXFxuICAgICAgICAgICAgPGFiYnIgdGl0bGU9XFxcInt7YnV5aW5nUXVhbnRpdHl9fVxcXCIgZGF0YS10b29sdGlwPVxcXCJ7e2J1eWluZ1F1YW50aXR5fX1cXFwiPnt7YnV5aW5nUm91bmRRdWFudGl0eX19PC9hYmJyPlxcclxcbiAgICAgICAgPC9saT5cXHJcXG4gICAgPC91bD5cXHJcXG4gICAgPC9uYXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICBJZiB5b3UgaGF2ZW4ndCBhbHJlYWR5LCBhZGQgdGhlIHt7YnV5aW5nU3ltYm9sfX0gdG8geW91ciB3YWxsZXQuXFxyXFxuICAgICAgICA8YnIgLz48YnIgLz5cXHJcXG4gICAgICAgIDxidXR0b24gaWQ9XFxcImFkZFRva2VuVG9XYWxsZXRcXFwiIGRhdGEtYWRkcmVzcz1cXFwie3t0b2tlbkFkZHJlc3N9fVxcXCI+QWRkIHt7YnV5aW5nU3ltYm9sfX0gdG8gd2FsbGV0PC9idXR0b24+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJhZGRUb2tlblRvV2FsbGV0RmFpbGVkXFxcIiBjbGFzcz1cXFwiZC1ub25lXFxcIj5cXHJcXG4gICAgICAgICAgICBZb3UgY2FuIGNvcHkgdGhlIGFkZHJlc3MsIHRvIGltcG9ydCB0aGUgdG9rZW5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgdmFsdWU9XFxcInt7dG9rZW5BZGRyZXNzfX1cXFwiIC8+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxiciAvPlxcclxcbiAgICAgICAgU2hvdWxkIGJlIHZpc2libGUgaW4geW91ciB7e3dhbGxldE5hbWV9fSBvbiBhZGRyZXNzIHt7c2hvcnRFdGhBZGRyZXNzfX0uXFxyXFxuICAgICAgICA8YnIgLz48YnIgLz5cXHJcXG4gICAgICAgIDxzbWFsbD5Zb3UgY2FuIHZpZXcgdGhlIDxhIGhyZWY9XFxcInt7YmxvY2tFeHBsb3Jlckxpbmt9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPmJsb2NrIHRyYW5zYWN0aW9uIGhlcmU8L2E+PC9zbWFsbD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9hcnRpY2xlPlxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJZb3UgbmVlZCB0byBoYXZlIHt7c3ltYm9sfX0gY3VycmVuY3kgaW4geW91ciB3YWxsZXQuIFlvdSB1c2Uge3tzeW1ib2x9fSB0byBwYXkgZm9yIHVzaW5nIHRoZSBibG9ja2NoYWluLlxcclxcblxcclxcblRvIGdldCBzb21lIHt7c3ltYm9sfX0gY3VycmVuY3lcXHJcXG48b2w+XFxyXFxuICAgIDxsaT5Db3B5IHlvdXIgYWRkcmVzcyBzaG93biBiZWxvd1xcclxcbiAgICAgICAgPGlucHV0IHZhbHVlPVxcXCJ7e2V0aEFkZHJlc3N9fVxcXCIgLz5cXHJcXG4gICAgPC9saT5cXHJcXG4gICAgPGxpPk9wZW4gPGEgaHJlZj1cXFwie3tmYXVjZXRVcmx9fVxcXCIgaWQ9XFxcImdldE5hdGl2ZVRva2Vuc1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPnt7ZmF1Y2V0VXJsfX08L2E+PC9saT5cXHJcXG4gICAgPGxpPlBhc3RlIGluIHlvdXIgYWRkcmVzcyB5b3UganVzdCBjb3BpZWQgYW5kIGNsaWNrIHRoZSBzdWJtaXQgYnV0dG9uPC9saT5cXHJcXG48L29sPlxcclxcblxcclxcbjxkaXYgY2xhc3M9XFxcImluZm9CYXIgZC1ub25lXFxcIiBpZD1cXFwid2FpdGluZ0Zvck5hdGl2ZVRva2VuXFxcIj5XYWl0aW5nIGZvciB7e3N5bWJvbH19LiBXaW5kb3cgd2lsbCBjbG9zZSB3aGVuIHlvdSBoYXZlIHNvbWUgaW5cXHJcXG4gICAgeW91IHdhbGxldC5cXHJcXG4gICAgSXQgbWlnaHQgdGFrZSBmZXcgbWludXRlcyBhZnRlciB5b3UgcmVxdWVzdGVkIGl0LlxcclxcbiAgICA8cHJvZ3Jlc3M+PC9wcm9ncmVzcz5cXHJcXG48L2Rpdj5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiWW91IG5lZWQgdG8gaGF2ZSB7e3N5bWJvbH19IGN1cnJlbmN5IGluIHlvdXIgd2FsbGV0LiBZb3UgdXNlIHt7c3ltYm9sfX0gdG8gcGF5IGZvciB1c2luZyB0aGUgYmxvY2tjaGFpbi5cXHJcXG5cXHJcXG5UbyBnZXQgc29tZSB7e3N5bWJvbH19IGN1cnJlbmN5XFxyXFxuPG9sPlxcclxcbiAgICA8bGk+Q29weSB5b3VyIGFkZHJlc3Mgc2hvd24gYmVsb3dcXHJcXG4gICAgICAgIDxpbnB1dCB2YWx1ZT1cXFwie3tldGhBZGRyZXNzfX1cXFwiIC8+XFxyXFxuICAgIDwvbGk+XFxyXFxuICAgIDxsaT5PcGVuIDxhIGhyZWY9XFxcInt7YnV5VXJsfX1cXFwiIHRhcmdldD1cXFwiX2JsYW5rXFxcIj57e2J1eVVybH19PC9hPjwvbGk+XFxyXFxuICAgIDxsaT5QYXN0ZSBpbiB5b3VyIGFkZHJlc3MgeW91IGp1c3QgY29waWVkIGFuZCBjbGljayB0aGUgc3VibWl0IGJ1dHRvbjwvbGk+XFxyXFxuPC9vbD5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cXHJcXG5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgRmFrZU5hdGl2ZVRva2VuTmVlZGVkSHRtbCBmcm9tICcuLi8uLi9odG1sL21vZGFsL0Zha2VOYXRpdmVUb2tlbk5lZWRlZC5odG1sJztcclxuaW1wb3J0IE5hdGl2ZVRva2VuTmVlZGVkSHRtbCBmcm9tICcuLi8uLi9odG1sL21vZGFsL05hdGl2ZVRva2VuTmVlZGVkLmh0bWwnO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4vTW9kYWxcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOYXRpdmVUb2tlbk5lZWRlZCB7XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcbiAgICBvbk5hdGl2ZVRva2VuQXJyaXZlZCA6ICgpID0+IHZvaWQ7XHJcbiAgICB0aW1lT3V0PzogYW55ID0gdW5kZWZpbmVkO1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcywgb25OYXRpdmVUb2tlbkFycml2ZWQgOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLm9uTmF0aXZlVG9rZW5BcnJpdmVkID0gb25OYXRpdmVUb2tlbkFycml2ZWQ7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IE5ldHdvcmtJbmZvLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSB1c2VyU2VydmljZS5nZXRFdGhBZGRyZXNzKCk7XHJcblxyXG4gICAgICAgIGlmIChuZXR3b3JrSW5mby5UZXN0TmV0d29yaykge1xyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoRmFrZU5hdGl2ZVRva2VuTmVlZGVkSHRtbCk7XHJcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGUoe3N5bWJvbDpuZXR3b3JrSW5mby5OYXRpdmVTeW1ib2wsIGZhdWNldFVybDpuZXR3b3JrSW5mby5GYXVjZXRVcmwsIGV0aEFkZHJlc3M6ZXRoQWRkcmVzc30pXHJcbiAgICAgICAgICAgIHRoaXMubW9kYWwuc2hvd01vZGFsKCdHZXQgc29tZSAnICsgbmV0d29ya0luZm8uTmF0aXZlU3ltYm9sLCBjb250ZW50LCBmYWxzZSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxUaW1lcigpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShOYXRpdmVUb2tlbk5lZWRlZEh0bWwpO1xyXG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKHtzeW1ib2w6bmV0d29ya0luZm8uTmF0aXZlU3ltYm9sLCBidXlVcmw6bmV0d29ya0luZm8uQnV5VXJsLCBldGhBZGRyZXNzOmV0aEFkZHJlc3N9KVxyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLnNob3dNb2RhbCgnR2V0IHNvbWUgJyArIG5ldHdvcmtJbmZvLk5hdGl2ZVN5bWJvbCwgY29udGVudCwgZmFsc2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsVGltZXIoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBsaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dldE5hdGl2ZVRva2VucycpO1xyXG4gICAgICAgIGlmICghbGluaykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgd2FpdGluZ0Zvck5hdGl2ZVRva2VuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRpbmdGb3JOYXRpdmVUb2tlbicpO1xyXG4gICAgICAgICAgICB3YWl0aW5nRm9yTmF0aXZlVG9rZW4/LmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG5cclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0Zvck5hdGl2ZVRva2VucygpO1xyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjYW5jZWxUaW1lcigpIHtcclxuICAgICAgICBpZiAodGhpcy50aW1lT3V0KSBjbGVhclRpbWVvdXQodGhpcy50aW1lT3V0KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgY2hlY2tGb3JOYXRpdmVUb2tlbnMoKSB7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBsZXQgaGFzRW5vdWdoTmF0aXZlVG9rZW5zID0gYXdhaXQgbmV0d29ya0luZm8uaGFzRW5vdWdoTmF0aXZlVG9rZW5zKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgaWYgKGhhc0Vub3VnaE5hdGl2ZVRva2Vucykge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uTmF0aXZlVG9rZW5BcnJpdmVkKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lT3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmNoZWNrRm9yTmF0aXZlVG9rZW5zKCksIDUgKiAxMDAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGl2IGlkPVxcXCJreWNBY3Rpb25SZXF1aXJlZERpdlxcXCI+XFxyXFxuXFxyXFxuICAgIHt7I2lmIE90aGVyfX1cXHJcXG4gICAgPHN0cm9uZz5UaGlzIGlzIHRoZSBtZXNzYWdlIGZyb20gS1lDIHByb2Nlc3NvciB3ZSByZWNlaXZlZDwvc3Ryb25nPlxcclxcbiAgICA8YmxvY2txdW90ZT5cXHJcXG4gICAgICAgIHt7T3RoZXJ9fVxcclxcbiAgICA8L2Jsb2NrcXVvdGU+XFxyXFxuICAgIHt7L2lmfX1cXHJcXG4gICAgPGZvcm0gbm92YWxpZGF0ZSBpZD1cXFwia3ljQWN0aW9uUmVxdWlyZWRGb3JtXFxcIiBuYW1lPVxcXCJreWNBY3Rpb25SZXF1aXJlZEZvcm1cXFwiIG9uc3VibWl0PVxcXCJyZXR1cm4gZmFsc2U7XFxcIj5cXHJcXG4gICAgICAgIHt7e0t5Y0luZm99fX1cXHJcXG4gICAgICAgIHt7I2lmIFN1Ym1pdERhdGF9fVxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJreWNBY3Rpb25SZXF1aXJlZEVycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBpZD1cXFwia3ljQWN0aW9uUmVxdWlyZWRTdWJtaXRcXFwiPlNlbmQgbmV3IGluZm9ybWF0aW9uPC9idXR0b24+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIHt7L2lmfX1cXHJcXG4gICAgPC9mb3JtPlxcclxcbjwvZGl2PlxcclxcblxcclxcbjxkaXYgaWQ9XFxcImt5Y0FjdGlvblJlcXVpcmVkU3VibWl0dGVkRGl2XFxcIiBjbGFzcz1cXFwiaGlkZGVuIGNlbnRlclxcXCI+XFxyXFxuICAgIDxoMz5Zb3UgZG9jdW1lbnRzIGhhdmUgYmVlbiBzdWJtaXR0ZWQuPGJyLz5XZSB3aWxsIGVtYWlsIHlvdSB3aGVuIHlvdXIgYWNjb3VudCBpcyByZWFkeS48L2gzPlxcclxcbiAgICBZb3UgY2FuIGNsb3NlIHRoaXMgd2luZG93LlxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIFlvdXIgYXBwbGljYXRpb24gaGFzIGJlZW4gcmVqZWN0ZWQgZHVyaW5nIEtZQyBwcm9jZXNzLjxici8+PGJyLz5cXHJcXG4gICAgV2UgZG9uJ3QgaGF2ZSB0aGUgaW5mb3JtYXRpb24gb24gd2h5IHRoYXQgaGFwcGVuZWQsIGJ1dCB5b3UgY2FuIGVtYWlsIHVzIGF0XFxyXFxuICAgIDxhIGhyZWY9J21haWx0bzppbmZvQGxpbWluYWwubWFya2V0P3N1YmplY3Q9TXkgYXBwbGljYXRpb24gd2FzIHJlamVjdGVkJmJvZHk9SGksIGNhbiB5b3UgaGVscCBtZSB0byBmaW5kIG91dCB3aGF0IHRoZSBwcm9ibGVtIGlzPyBNeSBuYW1lIGlzIF9fX19fX18gYW5kIEkgdXNlZCB0aGUgZW1haWwgX19fX19fXyB0byByZWdpc3RlciBhdCBsaW1pbmFsLm1hcmtldCc+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT5cXHJcXG4gICAgYW5kIHdlIGNhbiBmaW5kIG91dCwgYW5kIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNvbHZlIGl0IHRvZ2V0aGVyLlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgPHA+XFxyXFxuICAgICAgICBJZGVudGl0eSBuZWVkcyB0byBiZSB2ZXJpZmllZC5cXHJcXG4gICAgICAgIFRoaXMgbWVhbnMgeW91IG5lZWQgdG8gdXBsb2FkXFxyXFxuICAgICAgICBhIG5ldyBwaG90byBvZiB5b3VyIGlkLiBZb3UgbWlnaHQgdHJ5IGFub3RoZXIgdHlwZSBvZiBJRCwgc3VjaCBhc1xcclxcbiAgICAgICAgZHJpdmVyJ3MgbGljZW5zZSBpZiB5b3UgdHJpZWQgcGFzc3BvcnQgYmVmb3JlXFxyXFxuICAgIDwvcD5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJpZGVudGl0eV92ZXJpZmljYXRpb25cXFwiIFxcXCJQaG90byBJRCBGcm9udCAoRnJvbnQgb2YgcGFzc3BvcnQpXFxcIn19fVxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJpZGVudGl0eV92ZXJpZmljYXRpb25fMlxcXCIgXFxcIlBob3RvIElEIEJhY2sgKFBhc3Nwb3J0IHBpY3R1cmUgb2YgSUQpIFxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICA8cD5cXHJcXG4gICAgICAgIEFkZHJlc3MgbmVlZHMgdG8gYmUgdmVyaWZpZWQuIFBsZWFzZSB1cGxvYWQgZG9jdW1lbnQgdGhhdCBjb25maXJtcyB5b3VyIGFkZHJlc3MuXFxyXFxuICAgICAgICBBIGJpbGwgZnJvbSB0aGUgZ292ZXJubWVudCBvciB1dGlsaXR5IGNvbXBhbnkgaW4gdGhhdCBsYXN0IDMwIGRheXMgd2l0aCB5b3VyIG5hbWUgaXQgc2hvdWxkIHdvcmsuXFxyXFxuICAgIDwvcD5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJhZGRyZXNzX3ZlcmlmaWNhdGlvblxcXCIgXFxcIlBpY3R1cmUgb2YgYWRkcmVzcyB2ZXJpZmljYXRpb25cXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgRnVydGhlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBzdWJtaXR0ZWQgaWYgYWNjb3VudCBvd25lciBpcyBhZmZpbGlhdGVkIHRvIGZpbnJhIG9yIGFuIGV4Y2hhbmdlXFxyXFxuICAgIDxici8+XFxyXFxuICAgIFBsZWFzZSBjb250YWN0IHVzIGF0IDxhIGhyZWY9XFxcIm1haWx0bzppbmZvQGxpbWluYWwubWFya2V0XFxcIj5pbmZvQGxpbWluYWwubWFya2V0PC9hPiBmb3IgZnVydGhlciBpbmZvcm1hdGlvblxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgRnVydGhlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBzdWJtaXR0ZWQgaWYgYWNjb3VudCBvd25lciBpcyBhIGNvbnRyb2wgcGVyc29uXFxyXFxuICAgIDxici8+XFxyXFxuICAgIFBsZWFzZSBjb250YWN0IHVzIGF0IDxhIGhyZWY9XFxcIm1haWx0bzppbmZvQGxpbWluYWwubWFya2V0XFxcIj5pbmZvQGxpbWluYWwubWFya2V0PC9hPiBmb3IgZnVydGhlciBpbmZvcm1hdGlvblxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgVGhlIGFjY291bnQgb3duZXLigJlzIGNvdW50cnkgb2YgdGF4IHJlc2lkZW5jZSBpcyBub3Qgc3VwcG9ydGVkIGJ5IG91ciBLWUMgcHJvdmlkZXJzLlxcclxcbiAgICBJbiB0aGlzIGNhc2UsIHdl4oCZbGwgbWFudWFsbHkgcGVyZm9ybSBLWUMgb24gdGhlIHVzZXJcXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIERhdGUgb2YgYmlydGggbmVlZHMgdG8gYmUgdmVyaWZpZWQuIFBsZWFzZSB1cGxvYWQgZG9jdW1lbnQgdGhhdCBjb25maXJtcyB5b3VyIGRhdGUgb2YgYmlydGguXFxyXFxuXFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiZGF0ZV9vZl9iaXJ0aF92ZXJpZmljYXRpb25cXFwiIFxcXCJEYXRlIG9mIGJpcnRoIHZlcmlmaWNhdGlvblxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICBGdXJ0aGVyIGluZm9ybWF0aW9uIG5lZWRzIHRvIGJlIHN1Ym1pdHRlZCBpZiBmYW1pbHkgbWVtYmVyIGlzIGEgcG9saXRpY2FsbHkgZXhwb3NlZCBwZXJzb25cXHJcXG4gICAgPGJyLz5cXHJcXG4gICAgUGxlYXNlIGNvbnRhY3QgdXMgYXQgPGEgaHJlZj1cXFwibWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXRcXFwiPmluZm9AbGltaW5hbC5tYXJrZXQ8L2E+IGZvciBmdXJ0aGVyIGluZm9ybWF0aW9uXFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICBJZGVudGl0eSBuZWVkcyB0byBiZSB2ZXJpZmllZCB2aWEgYSBnb3Zlcm5tZW50IGlzc3VlZCBJRC5cXHJcXG5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJpZGVudGl0eV92ZXJpZmljYXRpb25cXFwiIFxcXCJQaG90byBJRCBGcm9udCAoRnJvbnQgb2YgcGFzc3BvcnQpXFxcIn19fVxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJpZGVudGl0eV92ZXJpZmljYXRpb25fMlxcXCIgXFxcIlBob3RvIElEIEJhY2sgKFBhc3Nwb3J0IHBpY3R1cmUgb2YgSUQpIFxcXCJ9fX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0PlxcclxcbiAgICBGdXJ0aGVyIGluZm9ybWF0aW9uIG5lZWRzIHRvIGJlIHN1Ym1pdHRlZCBpZiBhY2NvdW50IG93bmVyIGlzIHBvbGl0aWNhbGx5IGV4cG9zZWQgcGVyc29uXFxyXFxuICAgIDxici8+XFxyXFxuICAgIFBsZWFzZSBjb250YWN0IHVzIGF0IDxhIGhyZWY9XFxcIm1haWx0bzppbmZvQGxpbWluYWwubWFya2V0XFxcIj5pbmZvQGxpbWluYWwubWFya2V0PC9hPiBmb3IgZnVydGhlciBpbmZvcm1hdGlvblxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgSWRlbnRpdHkgbmVlZHMgdG8gYmUgdmVyaWZpZWQgdmlhIGEgbGl2ZSBzZWxmaWUgb2YgdGhlIGFjY291bnQgb3duZXJcXHJcXG5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJpZGVudGl0eV92ZXJpZmljYXRpb25cXFwiIFxcXCJMaXZlIHNlbGZpZSB2ZXJpZmljYXRpb25cXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgVGF4IElEIG51bWJlciBuZWVkcyB0byBiZSB2ZXJpZmllZC4gUGxlYXNlIHVwbG9hZCBkb2N1bWVudCB0aGF0IGNvbmZpcm1zIHlvdXIgVGF4IElkXFxyXFxuXFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwidGF4X2lkX3ZlcmlmaWNhdGlvblxcXCIgXFxcIlRheCBpZCB2ZXJpZmljYXRpb25cXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldD5cXHJcXG4gICAgRnVydGhlciBpbmZvcm1hdGlvbiBuZWVkcyB0byBiZSBzdWJtaXR0ZWQgYWJvdXQgYWNjb3VudCBvd25lcuKAmXMgdmlzYVxcclxcbiAgICA8YnIvPlxcclxcbiAgICBQbGVhc2UgY29udGFjdCB1cyBhdCA8YSBocmVmPVxcXCJtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldFxcXCI+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT4gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb25cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQ+XFxyXFxuICAgIElkZW50aWZ5aW5nIGluZm9ybWF0aW9uIHN1Ym1pdHRlZCBieSB0aGUgdXNlciB3YXMgaW5jb3JyZWN0IHNvIGEgbmV3LCBjb3JyZWN0ZWQsIFc4QkVOIG5lZWRzIHRvIGJlIHN1Ym1pdHRlZFxcclxcbiAgICA8YnIvPlxcclxcbiAgICBQbGVhc2UgY29udGFjdCB1cyBhdCA8YSBocmVmPVxcXCJtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldFxcXCI+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT4gZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb25cXHJcXG48L2ZpZWxkc2V0PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGl2PlxcclxcbiAgICA8bGFiZWwgZm9yPVxcXCJ7e2lucHV0SWR9fVxcXCI+e3tsYWJlbH19PC9sYWJlbD5cXHJcXG4gICAgPGlucHV0IHR5cGU9XFxcImZpbGVcXFwiIHJlcXVpcmVkIGlkPVxcXCJ7e2lucHV0SWR9fVxcXCIgYWNjZXB0PVxcXCJ7e2FjY2VwdH19XFxcIiBjYXB0dXJlPVxcXCJ7e2NhcHR1cmV9fVxcXCIvPlxcclxcbiAgICA8aW5wdXQgdHlwZT1cXFwiaGlkZGVuXFxcIiBpZD1cXFwie3tpbnB1dElkfX1fYmFzZTY0XFxcIiBuYW1lPVxcXCJ7e2lucHV0SWR9fV9iYXNlNjRcXFwiLz5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZXJyb3IgaGlkZGVuXFxcIiBpZD1cXFwie3tpbnB1dElkfX1fZXJyb3JcXFwiPjwvZGl2PlxcclxcbjwvZGl2PlxcclxcbjxkaXYgaWQ9XFxcInt7aW5wdXRJZH19X3ByZXZpZXdcXFwiPlxcclxcblxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgRmlsZVVwbG9hZEh0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9GaWxlVXBsb2FkLmh0bWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsZVVwbG9hZCB7XHJcblxyXG4gICAgcHJpdmF0ZSBtYXhGaWxlU2l6ZTogbnVtYmVyID0gOCAqIDEwMjQgKiAxMDI0ICogMTA7IC8vMTBNQlxyXG4gICAgaW5wdXRJZDogc3RyaW5nO1xyXG4gICAgbGFiZWw6IHN0cmluZztcclxuICAgIGFjY2VwdCA9IFwiaW1hZ2UvKiwucGRmXCI7XHJcbiAgICBjYXB0dXJlID0gJ2Vudmlyb25tZW50JztcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpbnB1dElkOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIGFjY2VwdCA9IFwiaW1hZ2UvcG5nLGltYWdlL2pwZWcsLnBkZlwiLCBjYXB0dXJlID0gJ2Vudmlyb25tZW50Jykge1xyXG4gICAgICAgIHRoaXMuaW5wdXRJZCA9IGlucHV0SWQ7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIHRoaXMuYWNjZXB0ID0gYWNjZXB0O1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZSA9IGNhcHR1cmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcigpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoRmlsZVVwbG9hZEh0bWwpO1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSh0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBmaWxlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlucHV0SWQpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgZmlsZUlucHV0Py5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ZpbGUoZmlsZUlucHV0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NGaWxlKGVsZW1lbnQ6IEhUTUxJbnB1dEVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmhpZGVGaWxlUmVsYXRlZEluZm8oZWxlbWVudC5pZCk7XHJcblxyXG4gICAgICAgIGxldCBmaWxlcyA9IGVsZW1lbnQuZmlsZXM7XHJcbiAgICAgICAgaWYgKCFmaWxlcykgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgZmlsZSA9IGZpbGVzWzBdO1xyXG4gICAgICAgIGlmICghZmlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dGaWxlUmVsYXRlZEluZm8oZWxlbWVudC5pZCwgJ05vIGZpbGUgc2VsZWN0ZWQuIFBsZWFzZSBzZWxlY3QgZmlsZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRCYXNlNjRJbnB1dChlbGVtZW50LmlkLCAnJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChmaWxlLnNpemUgPiB0aGlzLm1heEZpbGVTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0ZpbGVSZWxhdGVkSW5mbyhlbGVtZW50LmlkLCAnRmlsZSAnICsgZmlsZS5uYW1lICsgJyBpcyB0byBsYXJnZS4gRmlsZXMgY2Fubm90IGJlIGxhcmdlciB0aGVuIDEwTUIuIFlvdSBuZWVkIHRvIG1ha2UgaXQgc21hbGxlciBiZWZvcmUgc3VibWl0dGluZyB5b3VyIGFwcGxpY2F0aW9uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZTY0SW5wdXQoZWxlbWVudC5pZCwgJycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRCYXNlNjRJbnB1dChlbGVtZW50LmlkLCByZWFkZXIucmVzdWx0IGFzIHN0cmluZyk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zaG93RmlsZVJlbGF0ZWRJbmZvKGVsZW1lbnQuaWQsICdDb3VsZCBub3QgcmVhZCBmaWxlICcgKyBmaWxlLm5hbWUgKyAnLiBFaXRoZXIgdGhlIGZpbGUgaXMgY29ycnVwdCBvciB5b3VyIGJyb3dzZXIgZG9lcyBub3QgYWxsb3cgdXMgdG8gcmVhZCBpdCcpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzZXRCYXNlNjRJbnB1dChlbGVtZW50SWQ6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBiYXNlNjRJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCArICdfYmFzZTY0JykhIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgYmFzZTY0SW5wdXQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICBsZXQgcHJldmlld0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQgKyAnX3ByZXZpZXcnKTtcclxuICAgICAgICBpZiAoIXByZXZpZXdFbGVtZW50KSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdkYXRhOmltYWdlJykgIT0gLTEpIHtcclxuICAgICAgICAgICAgcHJldmlld0VsZW1lbnQuaW5uZXJIVE1MID0gJzxpbWcgc3JjPVwiJyArIGJhc2U2NElucHV0LnZhbHVlICsgJ1wiIC8+J1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByZXZpZXdFbGVtZW50LmlubmVySFRNTCA9ICcnXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2hvd0ZpbGVSZWxhdGVkSW5mbyhlbGVtZW50SWQ6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGZpbGVSZWxhdGVkSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCArICdfZXJyb3InKSEgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFmaWxlUmVsYXRlZEluZm8pIHJldHVybjtcclxuXHJcbiAgICAgICAgZmlsZVJlbGF0ZWRJbmZvLmlubmVySFRNTCA9IHRleHQ7XHJcbiAgICAgICAgZmlsZVJlbGF0ZWRJbmZvLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIGhpZGVGaWxlUmVsYXRlZEluZm8oZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgZmlsZVJlbGF0ZWRJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkICsgJ19lcnJvcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghZmlsZVJlbGF0ZWRJbmZvKSByZXR1cm47XHJcblxyXG4gICAgICAgIGZpbGVSZWxhdGVkSW5mby5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgZmlsZVVwbG9hZHM6IEZpbGVVcGxvYWRbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVnaXN0ZXJIYW5kbGVyKCkge1xyXG4gICAgICAgIEhhbmRsZWJhcnMucmVnaXN0ZXJIZWxwZXIoJ2ZpbGVVcGxvYWQnLCAoaWQsIGxhYmVsKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBmaWxlVXBsb2FkID0gbmV3IEZpbGVVcGxvYWQoaWQsIGxhYmVsKTtcclxuICAgICAgICAgICAgRmlsZVVwbG9hZC5maWxlVXBsb2Fkcy5wdXNoKGZpbGVVcGxvYWQpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZpbGVVcGxvYWQucmVuZGVyKCk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxufSIsImltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSBcIi4vU3RyaW5nSGVscGVyXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtVmFsaWRhdG9yIHtcclxuICAgIHNlbGVjdG9yOiBzdHJpbmc7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCkge1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IgKyAnIGlucHV0W3JlcXVpcmVkXSwgJyArIHRoaXMuc2VsZWN0b3IgKyAnIHNlbGVjdFtyZXF1aXJlZF0nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBpbnB1dHNbaV0gYXMgSFRNTElucHV0RWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWlzc2luZ0lucHV0RnJvbVVzZXIoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgbXVzdCBmaWxsIGludG8gdGhpcyBmaWVsZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lOiBpbnB1dC5pZCxcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbFRleHQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsW2Zvcj0nICsgaW5wdXQuaWQgKyAnXScpIS5pbm5lckhUTUwsXHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogaW5wdXQucGF0dGVyblxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlKG9iaik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IGlucHV0LnBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGlucHV0LnZhbHVlLm1hdGNoKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIG5vdCB2YWxpZCBkYXRlIGZvcm1hdCwgcGxlYXNlIHVzZSBZWVlZLU1NLUREICh5ZWFyLW1vbnRoLWRhdGUpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lOiBpbnB1dC5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9JyArIGlucHV0LmlkICsgJ10nKSEuaW5uZXJIVE1MLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBpbnB1dC5wYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBpc01pc3NpbmdJbnB1dEZyb21Vc2VyKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICgoaW5wdXQudHlwZSA9PSAnY2hlY2tib3gnICYmICFpbnB1dC5jaGVja2VkKSB8fCBTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZW1vdmVNaXNzaW5nSW5mbyhlcnJvckRpdklkOiBzdHJpbmcsIGZvY3VzRWxlbWVudElkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlcnJvckRpdklkKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmICghZm9jdXNFbGVtZW50SWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGZvY3VzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvY3VzRWxlbWVudElkKTtcclxuICAgICAgICBpZiAoZm9jdXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0TWlzc2luZ0luZm8oZXJyb3JEaXZJZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcsIGZvY3VzRWxlbWVudElkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlcnJvckRpdklkKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0ZXh0O1xyXG4gICAgICAgIGlmICh0ZXh0ID09ICcnKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgICAgICAgICAgaWYgKGZvY3VzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk/LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk/LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhhbmRsZShvYmo6IHsgbGFiZWxUZXh0OiBzdHJpbmc7IG1lc3NhZ2U6IHN0cmluZzsgcGF0dGVybjogc3RyaW5nOyBpbnB1dE5hbWU6IHN0cmluZyB9KSB7XHJcbiAgICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob2JqLmlucHV0TmFtZSk7XHJcbiAgICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgaW5wdXRFcnJvciA9IGlucHV0LnBhcmVudEVsZW1lbnQhLnF1ZXJ5U2VsZWN0b3IoJy5pbnB1dF9lcnJvcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmIChpbnB1dEVycm9yKSB7XHJcbiAgICAgICAgICAgIGlucHV0RXJyb3Iuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiAnY2VudGVyJ30pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICBpbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCAnPGRpdiBjbGFzcz1cImlucHV0X2Vycm9yXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9ja1wiIGlkPVwiaW5wdXRfZXJyb3JfJyArIG9iai5pbnB1dE5hbWUgKyAnXCI+JyArIG9iai5tZXNzYWdlICsgJzwvZGl2PicpO1xyXG4gICAgICAgIGlucHV0LmZvY3VzKCk7XHJcbiAgICAgICAgaWYgKG9iai5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgncGF0dGVybicsIG9iai5wYXR0ZXJuKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBpbnB1dCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChwYXR0ZXJuICYmIGlucHV0LnZhbHVlLm1hdGNoKHBhdHRlcm4pKSB8fCAoaW5wdXQucmVxdWlyZWQgJiYgaW5wdXQudmFsdWUpIHx8IGlucHV0LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRfZXJyb3JfJyArIG9iai5pbnB1dE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIGVycm9yTWVzc2FnZS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgODAwKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxufSIsImltcG9ydCBNb2RhbCBmcm9tIFwiLi4vTW9kYWxcIjtcclxuaW1wb3J0IFVzZXJTZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1VzZXJTZXJ2aWNlXCI7XHJcbmltcG9ydCBLeWNBY3Rpb25SZXF1aXJlZEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljQWN0aW9uUmVxdWlyZWQuaHRtbCc7XHJcbmltcG9ydCBXZURvbnRLbm93V2h5SHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9XZURvbnRLbm93V2h5Lmh0bWwnXHJcbmltcG9ydCBLeWNSZXN1bHRNZXNzYWdlIGZyb20gXCIuLi8uLi8uLi9kdG8vS3ljUmVzdWx0TWVzc2FnZVwiO1xyXG5cclxuXHJcbmltcG9ydCBJREVOVElUWV9WRVJJRklDQVRJT04gZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvSURFTlRJVFlfVkVSSUZJQ0FUSU9OLmh0bWwnXHJcbmltcG9ydCBBRERSRVNTX1ZFUklGSUNBVElPTiBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9BRERSRVNTX1ZFUklGSUNBVElPTi5odG1sJ1xyXG5pbXBvcnQgQUZGSUxJQVRFRCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9BRkZJTElBVEVELmh0bWwnXHJcbmltcG9ydCBDT05UUk9MX1BFUlNPTiBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9DT05UUk9MX1BFUlNPTi5odG1sJ1xyXG5pbXBvcnQgQ09VTlRSWV9OT1RfU1VQUE9SVEVEIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL0NPVU5UUllfTk9UX1NVUFBPUlRFRC5odG1sJ1xyXG5pbXBvcnQgREFURV9PRl9CSVJUSCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9EQVRFX09GX0JJUlRILmh0bWwnXHJcbmltcG9ydCBGQU1JTFlfTUVNQkVSX1BFUCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9GQU1JTFlfTUVNQkVSX1BFUC5odG1sJ1xyXG5pbXBvcnQgSU5WQUxJRF9JREVOVElUWV9QQVNTUE9SVCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9JTlZBTElEX0lERU5USVRZX1BBU1NQT1JULmh0bWwnXHJcbmltcG9ydCBQRVAgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvUEVQLmh0bWwnXHJcbmltcG9ydCBTRUxGSUVfVkVSSUZJQ0FUSU9OIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0FjdGlvblJlcXVpcmVkL1NFTEZJRV9WRVJJRklDQVRJT04uaHRtbCdcclxuaW1wb3J0IFRBWF9JREVOVElGSUNBVElPTiBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9UQVhfSURFTlRJRklDQVRJT04uaHRtbCdcclxuaW1wb3J0IFZJU0FfVFlQRV9PVEhFUiBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9BY3Rpb25SZXF1aXJlZC9WSVNBX1RZUEVfT1RIRVIuaHRtbCdcclxuaW1wb3J0IFc4QkVOX0NPUlJFQ1RJT04gZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvQWN0aW9uUmVxdWlyZWQvVzhCRU5fQ09SUkVDVElPTi5odG1sJ1xyXG5pbXBvcnQgRm9ybUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Gb3JtSGVscGVyXCI7XHJcbmltcG9ydCBGaWxlVXBsb2FkIGZyb20gXCIuLi8uLi9lbGVtZW50cy9GaWxlVXBsb2FkXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBGb3JtVmFsaWRhdG9yIGZyb20gXCIuLi8uLi8uLi91dGlsL0Zvcm1WYWxpZGF0b3JcIjtcclxuaW1wb3J0IEtZQ1NlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2Jsb2NrY2hhaW4vS1lDU2VydmljZVwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcbmltcG9ydCBFeGVjdXRlVHJhZGVCdXR0b24gZnJvbSBcIi4uLy4uL2VsZW1lbnRzL3RyYWRlcGFuZWwvRXhlY3V0ZVRyYWRlQnV0dG9uXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljQWN0aW9uUmVxdWlyZWQge1xyXG5cclxuICAgIG1vZGFsOiBNb2RhbDtcclxuICAgIHRlbXBsYXRlczogTWFwPHN0cmluZywgc3RyaW5nPjtcclxuICAgIGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZVRyYWRlQnV0dG9uO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZVRyYWRlQnV0dG9uKSB7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZVRyYWRlQnV0dG9uID0gZXhlY3V0ZVRyYWRlQnV0dG9uO1xyXG5cclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ1dlRG9udEtub3dXaHlIdG1sJywgV2VEb250S25vd1doeUh0bWwpO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzLnNldCgnQUREUkVTU19WRVJJRklDQVRJT04nLCBBRERSRVNTX1ZFUklGSUNBVElPTik7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdBRkZJTElBVEVEJywgQUZGSUxJQVRFRCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdDT05UUk9MX1BFUlNPTicsIENPTlRST0xfUEVSU09OKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ0NPVU5UUllfTk9UX1NVUFBPUlRFRCcsIENPVU5UUllfTk9UX1NVUFBPUlRFRCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdEQVRFX09GX0JJUlRIJywgREFURV9PRl9CSVJUSCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdGQU1JTFlfTUVNQkVSX1BFUCcsIEZBTUlMWV9NRU1CRVJfUEVQKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ0lERU5USVRZX1ZFUklGSUNBVElPTicsIElERU5USVRZX1ZFUklGSUNBVElPTik7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdJTlZBTElEX0lERU5USVRZX1BBU1NQT1JUJywgSU5WQUxJRF9JREVOVElUWV9QQVNTUE9SVCk7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdQRVAnLCBQRVApO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzLnNldCgnU0VMRklFX1ZFUklGSUNBVElPTicsIFNFTEZJRV9WRVJJRklDQVRJT04pO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGVzLnNldCgnVEFYX0lERU5USUZJQ0FUSU9OJywgVEFYX0lERU5USUZJQ0FUSU9OKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlcy5zZXQoJ1ZJU0FfVFlQRV9PVEhFUicsIFZJU0FfVFlQRV9PVEhFUik7XHJcbiAgICAgICAgdGhpcy50ZW1wbGF0ZXMuc2V0KCdXOEJFTl9DT1JSRUNUSU9OJywgVzhCRU5fQ09SUkVDVElPTik7XHJcblxyXG4gICAgICAgIEZpbGVVcGxvYWQucmVnaXN0ZXJIYW5kbGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHNob3coKSB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKE1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBreWNSZXN1bHQgPSBhd2FpdCB1c2VyU2VydmljZS5reWNBY3Rpb25SZXF1aXJlZCgpXHJcbiAgICAgICAgaWYgKCFreWNSZXN1bHQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGt5Y0luZm8gPSB0aGlzLmdldEt5Y01lc3NhZ2VzKGt5Y1Jlc3VsdC5tZXNzYWdlcyk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNBY3Rpb25SZXF1aXJlZEh0bWwpO1xyXG4gICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGUoe1xyXG4gICAgICAgICAgICBqc29uOiBKU09OLnN0cmluZ2lmeShreWNSZXN1bHQpLFxyXG4gICAgICAgICAgICBLeWNJbmZvOiBreWNJbmZvLFxyXG4gICAgICAgICAgICBPdGhlcjoga3ljUmVzdWx0LmFkZGl0aW9uYWxfaW5mb3JtYXRpb24sXHJcbiAgICAgICAgICAgIFN1Ym1pdERhdGE6IGt5Y0luZm8uaW5kZXhPZignPGlucHV0JykgIT0gLTFcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLm1vZGFsLnNob3dNb2RhbCgnQWN0aW9uIHJlcXVpcmVkJywgY29udGVudCwgZmFsc2UsICgpID0+IHtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGxldCBreWNBY3Rpb25SZXF1aXJlZEZvcm0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWRGb3JtJyk7XHJcbiAgICAgICAga3ljQWN0aW9uUmVxdWlyZWRGb3JtPy5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVFcnJvcigpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHN1Ym1pdEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNBY3Rpb25SZXF1aXJlZFN1Ym1pdCcpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcoc3VibWl0QnRuKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBmb3JtVmFsaWRhdG9yID0gbmV3IEZvcm1WYWxpZGF0b3IoJyNreWNBY3Rpb25SZXF1aXJlZEZvcm0nKVxyXG4gICAgICAgICAgICBpZiAoIWZvcm1WYWxpZGF0b3IudmFsaWRhdGVSZXF1aXJlZEZpZWxkcygpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gRm9ybUhlbHBlci5nZXRQYXJhbXMoJyNreWNBY3Rpb25SZXF1aXJlZEZvcm0nKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBreWNTZXJ2aWNlID0gbmV3IEtZQ1NlcnZpY2UoTW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGt5Y1NlcnZpY2UudXBkYXRlRG9jdW1lbnRzKHBhcmFtcylcclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQga3ljQWN0aW9uUmVxdWlyZWREaXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWREaXYnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBreWNBY3Rpb25SZXF1aXJlZERpdj8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBreWNBY3Rpb25SZXF1aXJlZFN1Ym1pdHRlZERpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNBY3Rpb25SZXF1aXJlZFN1Ym1pdHRlZERpdicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGt5Y0FjdGlvblJlcXVpcmVkU3VibWl0dGVkRGl2Py5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVUcmFkZUJ1dHRvbi5jaGVja0t5Y0lzRG9uZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leGVjdXRlVHJhZGVCdXR0b24ucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RXJyb3IocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgRmlsZVVwbG9hZC5maWxlVXBsb2Fkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBGaWxlVXBsb2FkLmZpbGVVcGxvYWRzW2ldLmJpbmRFdmVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0S3ljTWVzc2FnZXMobWVzc2FnZXM6IEt5Y1Jlc3VsdE1lc3NhZ2VbXSkge1xyXG4gICAgICAgIGxldCBreWNJbmZvID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgaHRtbFRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZXMuZ2V0KG1lc3NhZ2VzW2ldLmtleSk7XHJcbiAgICAgICAgICAgIGlmICghaHRtbFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE86IEhlcmUgd2Ugc2hvdWxkIHRvIGxvZ2dlciwgY3JpdGljYWwgdGhhdCB3ZSBkb250IGtub3cgd2h5XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoaHRtbFRlbXBsYXRlKVxyXG4gICAgICAgICAgICBreWNJbmZvICs9IHRlbXBsYXRlKHttZXNzYWdlOiBtZXNzYWdlc1tpXS5tZXNzYWdlfSlcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAoa3ljSW5mbyA9PSAnJykge1xyXG4gICAgICAgICAgICBsZXQgaHRtbCA9IHRoaXMudGVtcGxhdGVzLmdldCgnV2VEb250S25vd1doeUh0bWwnKTtcclxuICAgICAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKGh0bWwpO1xyXG4gICAgICAgICAgICBreWNJbmZvID0gdGVtcGxhdGUoe30pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGt5Y0luZm87XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoaWRlRXJyb3IoKSB7XHJcbiAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWRFcnJvcicpO1xyXG4gICAgICAgIGlmICgha3ljQWN0aW9uUmVxdWlyZWRFcnJvcikgcmV0dXJuO1xyXG4gICAgICAgIGt5Y0FjdGlvblJlcXVpcmVkRXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2hvd0Vycm9yKHJlYXNvbjogYW55KSB7XHJcbiAgICAgICAgbGV0IGt5Y0FjdGlvblJlcXVpcmVkRXJyb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQWN0aW9uUmVxdWlyZWRFcnJvcicpO1xyXG4gICAgICAgIGlmICgha3ljQWN0aW9uUmVxdWlyZWRFcnJvcikgcmV0dXJuO1xyXG5cclxuICAgICAgICBreWNBY3Rpb25SZXF1aXJlZEVycm9yLmlubmVySFRNTCA9ICdFcnJvciBvY2N1cnJlZCB3aGlsZSBzYXZpbmcgeW91ciBkb2N1bWVudHMuIFJlYXNvbjonICsgcmVhc29uO1xyXG4gICAgICAgIGt5Y0FjdGlvblJlcXVpcmVkRXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxkaXYgaWQ9XFxcImt5Y19yZWdcXFwiPlxcclxcblxcclxcbiAgICA8Zm9ybSBpZD1cXFwia3ljX3dpemFyZF9mb3JtXFxcIiBuYW1lPVxcXCJreWNfd2l6YXJkX2Zvcm1cXFwiIG5vdmFsaWRhdGUgb25zdWJtaXQ9XFxcInJldHVybiBmYWxzZVxcXCI+XFxyXFxuICAgICAgICB7e3tLeWNDb250YWN0SHRtbH19fVxcclxcbiAgICAgICAge3t7S3ljSWRlbnRpdHlIdG1sfX19XFxyXFxuICAgICAgICB7e3tLeWNUcnVzdGVkQ29udGFjdEh0bWx9fX1cXHJcXG4gICAgICAgIHt7e0t5Y0Rpc2Nsb3N1cmVIdG1sfX19XFxyXFxuICAgICAgICB7e3tLeWNVcGxvYWRIdG1sfX19XFxyXFxuICAgICAgICB7e3tLeWNBY2NvdW50QWdyZWVtZW50SHRtbH19fVxcclxcbiAgICA8L2Zvcm0+XFxyXFxuPC9kaXY+XFxyXFxuXFxyXFxuPGRpdiBpZD1cXFwid2FpdGluZ19mb3Jfa3ljX3JlZ1xcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxyXFxuICAgIEtZQyBpcyBiZWluZyBwcm9jZXNzZWQuIFRoaXMgbWF5IHRha2UgYWJvdXQgNC01IG1pbnV0ZXMuIFdpbmRvdyB3aWxsIGNsb3NlIHdoZW4gaXQncyBkb25lLlxcclxcbiAgICA8YnIvPjxici8+XFxyXFxuICAgIFlvdSBjYW4gY2xvc2UgdGhlIHdpbmRvdywgd2Ugd2lsbCBlbWFpbCB5b3Ugd2hlbiBLWUMgaXMgZmluaXNoZWQuXFxyXFxuXFxyXFxuICAgIDxwcm9ncmVzcz48L3Byb2dyZXNzPlxcclxcblxcclxcbjwvZGl2PlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQgY2xhc3M9XFxcImt5Y0NvbnRhY3QgaGlkZGVuXFxcIiBkYXRhLWZvcm09XFxcIjFcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJleHBsYWluXFxcIj5cXHJcXG4gICAgICAgIFRvIGJlIGFibGUgdG8gdHJhZGUgb24gdGhlIHN0b2NrIG1hcmtldCwgd2UgbmVlZCB0byBnZXQgeW91ciBpbmZvcm1hdGlvbi5cXHJcXG4gICAgICAgIFRoaXMgaXMgYSByZXF1aXJlbWVudCBmcm9tIHRoZSBmaW5hbmNpYWwgcmVndWxhdG9ycy5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbWFpbF9hZGRyZXNzXFxcIj5FbWFpbDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZW1haWxcXFwiIHJlcXVpcmVkIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGlkPVxcXCJlbWFpbF9hZGRyZXNzXFxcIiBuYW1lPVxcXCJlbWFpbF9hZGRyZXNzXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJuYW1lQGV4YW1wbGUuY29tXFxcIiBhdXRvY29tcGxldGU9XFxcImVtYWlsXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInBob25lX251bWJlclxcXCI+UGhvbmU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRlbFxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgaWQ9XFxcInBob25lX251bWJlclxcXCIgbmFtZT1cXFwicGhvbmVfbnVtYmVyXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCIrMS01NTUtNjY2LTc3ODhcXFwiIGF1dG9jb21wbGV0ZT1cXFwidGVsXFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJzdHJlZXRfYWRkcmVzc1xcXCI+UGVybWFuZW50IFJlc2lkZW50aWFsIEFkZHJlc3M8L2xhYmVsPlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZXhwbGFpblxcXCI+SXQgbXVzdCBiZSBhIHBoeXNpY2FsIGFkZHJlc3MsIG5vdCBhIFBPIGJveC48L2Rpdj5cXHJcXG4gICAgICAgIDxpbnB1dCByZXF1aXJlZCBpZD1cXFwic3RyZWV0X2FkZHJlc3NcXFwiIG5hbWU9XFxcInN0cmVldF9hZGRyZXNzXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCIyMCBOIFNhbiBNYXRlbyBEclxcXCIgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJhZGRyZXNzLWxpbmUxXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ1bml0XFxcIj5Vbml0IC8gQXB0ICM8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ1bml0XFxcIiBuYW1lPVxcXCJ1bml0XFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJjaXR5XFxcIj5DaXR5PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwiY2l0eVxcXCIgbmFtZT1cXFwiY2l0eVxcXCIgcGxhY2Vob2xkZXI9XFxcIlBhd25lZVxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZHJlc3MtbGV2ZWwyXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJwb3N0YWxfY29kZVxcXCI+UG9zdGFsIGNvZGU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJwb3N0YWxfY29kZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJwb3N0YWwtY29kZVxcXCIgbmFtZT1cXFwicG9zdGFsX2NvZGVcXFwiXFxyXFxuICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIjk0NDAxXFxcIlxcclxcbiAgICAgICAgICAgICAgIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwic3RhdGVfZGl2XFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInN0YXRlXFxcIj5TdGF0ZSAoMiBsZXR0ZXJzKTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbWF4bGVuZ3RoPVxcXCIyXFxcIiBpZD1cXFwic3RhdGVcXFwiIG5hbWU9XFxcInN0YXRlXFxcIiBwbGFjZWhvbGRlcj1cXFwiTllcXFwiXFxyXFxuICAgICAgICAgICAgICAgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJhZGRyZXNzLWxldmVsMVxcXCI+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY291bnRyeV9vZl90YXhfcmVzaWRlbmNlXFxcIj5Db3VudHJ5IG9mIHRheCByZXNpZGVuY2U8L2xhYmVsPlxcclxcbiAgICAgICAge3sjaWYgZWRpdH19XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiY291bnRyeV9vZl90YXhfcmVzaWRlbmNlXFxcIiByZWFkb25seSBpZD1cXFwiY291bnRyeV9vZl90YXhfcmVzaWRlbmNlXFxcIi8+XFxyXFxuICAgICAgICB7ey9pZn19XFxyXFxuICAgICAgICB7eyN1bmxlc3MgZWRpdH19XFxyXFxuICAgICAgICA8c2VsZWN0IHJlcXVpcmVkIGlkPVxcXCJjb3VudHJ5X29mX3RheF9yZXNpZGVuY2VcXFwiIG5hbWU9XFxcImNvdW50cnlfb2ZfdGF4X3Jlc2lkZW5jZVxcXCIgYXV0b2NvbXBsZXRlPVxcXCJjb3VudHJ5XFxcIj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2NvZGV9fVxcXCI+e3tuYW1lfX08L29wdGlvbj5cXHJcXG4gICAgICAgICAgICB7ey9lYWNofX1cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICAgICAge3svdW5sZXNzfX1cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJjb250YWN0X25leHRcXFwiPk5leHQ6IElkZW50aXR5PC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi8uLi91aS9tb2RhbHMvS1lDRm9ybVwiO1xyXG5pbXBvcnQgU3RyaW5nSGVscGVyIGZyb20gXCIuLi8uLi91dGlsL1N0cmluZ0hlbHBlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljVmFsaWRhdG9yRXJyb3Ige1xyXG4gICAgdmFsaWRWYWx1ZXM6IHN0cmluZyB8IHN0cmluZ1tdID0gJyc7XHJcbiAgICBpbnB1dE5hbWU6IHN0cmluZyA9ICcnO1xyXG4gICAgbGFiZWxUZXh0OiBzdHJpbmcgPSAnJztcclxuICAgIG1lc3NhZ2U6IHN0cmluZztcclxuICAgIHBhdHRlcm46IHN0cmluZyA9ICcnO1xyXG4gICAgb25zaG93OiBhbnk7XHJcbiAgICBreWNGb3JtOiBLWUNGb3JtO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGVycm9yOiBhbnksIGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBsZXQgb2JqOiBhbnkgPSB7fTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAoIWVycm9yLmlucHV0TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShlcnJvcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmogPSBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gb2JqLm1lc3NhZ2U/LnJlcGxhY2UoL18vZywgJyAnKTtcclxuICAgICAgICAgICAgdGhpcy52YWxpZFZhbHVlcyA9IG9iai52YWxpZFZhbHVlcz8ucmVwbGFjZSgvXy9nLCAnICcpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0TmFtZSA9IG9iai5pbnB1dE5hbWU7XHJcbiAgICAgICAgICAgIHRoaXMubGFiZWxUZXh0ID0gb2JqLmxhYmVsVGV4dDtcclxuICAgICAgICAgICAgdGhpcy5wYXR0ZXJuID0gb2JqLnBhdHRlcm47XHJcbiAgICAgICAgICAgIHRoaXMub25zaG93ID0gb2JqLm9uc2hvdztcclxuICAgICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc3NhZ2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmt5Y0Zvcm0gPSBreWNGb3JtO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAoU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodGhpcy5pbnB1dE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGxldCBhY3RpdmVGaWVsZHNldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5reWNGb3JtLmFjdGl2ZUZpZWxkc2V0U2VsZWN0b3IpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgaW5wdXRFcnJvciA9IGFjdGl2ZUZpZWxkc2V0LnF1ZXJ5U2VsZWN0b3IoJy5pbnB1dF9lcnJvcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEVycm9yLmlubmVySFRNTCA9IHRoaXMudmFsaWRWYWx1ZXMudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWVzc2FnZSAmJiB0aGlzLm1lc3NhZ2UuaW5kZXhPZignSW52YWxpZCBmdW5jdGlvbicpICE9IC0xIHx8IHRoaXMubWVzc2FnZS5pbmRleE9mKCdVbmFibGUgdG8gY29ubmVjdCB0byB0aGUgUGFyc2UgQVBJJykgIT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRFcnJvci5pbm5lckhUTUwgPSAnV2UganVzdCBkZXBsb3llZCBuZXcgdmVyc2lvbiBvZiBvdXIgd2Vic2l0ZS4gVGhpcyBjYW4gY2F1c2UgaW50ZXJydXB0aW9uLiBQbGVhc2Ugd2FpdCAzMCBzZWNvbmRzIGFuZCBzdWJtaXQgYWdhaW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0RXJyb3IuaW5uZXJIVE1MID0gdGhpcy5tZXNzYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlucHV0RXJyb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgICAgICBpbnB1dEVycm9yLnNjcm9sbEludG9WaWV3KClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaW5wdXROYW1lKTtcclxuICAgICAgICBpZiAoIWlucHV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBpbnB1dEVycm9yID0gaW5wdXQucGFyZW50RWxlbWVudCEucXVlcnlTZWxlY3RvcignLmlucHV0X2Vycm9yJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGlucHV0RXJyb3IpIHtcclxuICAgICAgICAgICAgaW5wdXRFcnJvci5zY3JvbGxJbnRvVmlldyh7YmxvY2s6ICdjZW50ZXInfSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xyXG4gICAgICAgIGxldCBlcnJvcklucHV0ID0gJzxkaXYgY2xhc3M9XCJpbnB1dF9lcnJvclwiIHN0eWxlPVwiZGlzcGxheTogYmxvY2tcIiBpZD1cImlucHV0X2Vycm9yXycgKyB0aGlzLmlucHV0TmFtZSArICdcIj4nICsgdGhpcy5tZXNzYWdlICsgJzwvZGl2Pic7XHJcbiAgICAgICAgaWYgKGlucHV0LmNsaWVudFdpZHRoIDwgMzAwKSB7XHJcbiAgICAgICAgICAgIGxldCBkaXYgPSB0aGlzLmdldERpdlRvRGlzcGxheUVycm9yTWVzc2FnZShpbnB1dCk7XHJcbiAgICAgICAgICAgIGRpdi5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBlcnJvcklucHV0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpbnB1dC5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCBlcnJvcklucHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcclxuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgncGF0dGVybicsIHRoaXMucGF0dGVybik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IGlucHV0LmdldEF0dHJpYnV0ZSgncGF0dGVybicpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgocGF0dGVybiAmJiBpbnB1dC52YWx1ZS5tYXRjaChwYXR0ZXJuKSkgfHwgKGlucHV0LnR5cGUgIT0gJ2NoZWNrYm94JyAmJiBpbnB1dC50eXBlICE9ICdyYWRpbycgJiYgaW5wdXQucmVxdWlyZWQgJiYgaW5wdXQudmFsdWUpIHx8IGlucHV0LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRfZXJyb3JfJyArIHRoaXMuaW5wdXROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSBlcnJvck1lc3NhZ2UucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDgwMCk7XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbGV0IGZpZWxkc2V0RWxlbWVudCA9IGlucHV0LmNsb3Nlc3QoJ2ZpZWxkc2V0W2RhdGEtZm9ybT1cIjFcIl0nKTtcclxuICAgICAgICBpZiAoZmllbGRzZXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGxldCBjbGFzc05hbWUgPSBmaWVsZHNldEVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoJ2hpZGRlbicsICcnKS50cmltKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5zaG93KGNsYXNzTmFtZSk7XHJcblxyXG4gICAgICAgICAgICBpbnB1dC5zY3JvbGxJbnRvVmlldyhmYWxzZSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9uc2hvdykge1xyXG4gICAgICAgICAgICBsZXQgbGluayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMub25zaG93LmlkKTtcclxuICAgICAgICAgICAgaWYgKCFsaW5rKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBNb3JhbGlzLkNsb3VkLnJ1bih0aGlzLm9uc2hvdy5mdW5jdGlvbk5hbWUsIHRoaXMub25zaG93LnBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lucHV0X2Vycm9yXycgKyB0aGlzLmlucHV0TmFtZSkhLmlubmVySFRNTCA9ICdFbWFpbCBoYXMgYmVlbiBzZW50IHRvICcgKyB0aGlzLm9uc2hvdy5wYXJhbXMuZW1haWw7XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHByaXZhdGUgZ2V0RGl2VG9EaXNwbGF5RXJyb3JNZXNzYWdlKGlucHV0OiBIVE1MRWxlbWVudCwgY291bnRlciA9IDEpOiBIVE1MRWxlbWVudCB7XHJcblxyXG4gICAgICAgIGxldCBkaXYgPSBpbnB1dC5wYXJlbnRFbGVtZW50IS5jbG9zZXN0KCdkaXYnKTtcclxuICAgICAgICBpZiAoIWRpdikgcmV0dXJuIGlucHV0O1xyXG5cclxuICAgICAgICBpZiAoZGl2LmNsaWVudFdpZHRoID4gMzAwIHx8IGNvdW50ZXIgPiA1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXREaXZUb0Rpc3BsYXlFcnJvck1lc3NhZ2UoZGl2LCArK2NvdW50ZXIpO1xyXG5cclxuICAgIH1cclxufSIsImltcG9ydCBTdHJpbmdIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvU3RyaW5nSGVscGVyXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcbmltcG9ydCBGaWxlVXBsb2FkIGZyb20gXCIuLi8uLi9lbGVtZW50cy9GaWxlVXBsb2FkXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljQmFzZSB7XHJcbiAgICBreWNGb3JtOiBLWUNGb3JtO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICB0aGlzLmt5Y0Zvcm0gPSBreWNGb3JtO1xyXG5cclxuICAgICAgICBGaWxlVXBsb2FkLnJlZ2lzdGVySGFuZGxlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93RmllbGRzZXQoc2VsZWN0b3I6IHN0cmluZywgaGVhZGVyOiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLmhpZGVGaWVsZHNldHMoKTtcclxuXHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNsaW1pbmFsX21hcmtldF9tb2RhbF9kaXYgPiBhcnRpY2xlID4gaGVhZGVyID4gc3BhbicpIS5pbm5lckhUTUwgPSBoZWFkZXJcclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjbGltaW5hbF9tYXJrZXRfbW9kYWxfZGl2ID4gYXJ0aWNsZScpIS5zY3JvbGxUb3AgPSAwXHJcbiAgICAgICAgdGhpcy5reWNGb3JtLmFjdGl2ZUZpZWxkc2V0U2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvd1JlcXVpcmVkTWFya2VyKCkge1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgc2VsZWN0Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gaW5wdXRzW2ldIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICghaW5wdXQuaWQpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBsZXQgbGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9JyArIGlucHV0LmlkICsgJ10nKTtcclxuICAgICAgICAgICAgaWYgKCFsYWJlbCkgY29udGludWU7XHJcblxyXG4gICAgICAgICAgICBpZiAoaW5wdXQucmVxdWlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbC5pbm5lckhUTUwuaW5kZXhPZignKicpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MICs9ICcqJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYWJlbC5pbm5lckhUTUwuaW5kZXhPZignKicpICE9IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gbGFiZWwuaW5uZXJIVE1MLnJlcGxhY2UoJyonLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFJlcXVpcmVkKGlucHV0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0SWQpPy5zZXRBdHRyaWJ1dGUoJ3JlcXVpcmVkJywgJ3JlcXVpcmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbW92ZVJlcXVpcmVkKGlucHV0SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlucHV0SWQpPy5yZW1vdmVBdHRyaWJ1dGUoJ3JlcXVpcmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmQoc2VsZWN0b3I6IHN0cmluZywgZXZlbnROYW1lOiBzdHJpbmcsIGFjdGlvbjogKGV2dDogRXZlbnQpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRzW2ldLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBhY3Rpb24oZXZ0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRmlsZVVwbG9hZHMoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBGaWxlVXBsb2FkLmZpbGVVcGxvYWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEZpbGVVcGxvYWQuZmlsZVVwbG9hZHNbaV0uYmluZEV2ZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGlkZUZpZWxkc2V0cygpIHtcclxuICAgICAgICBsZXQgZmllbGRzZXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2t5Y193aXphcmRfZm9ybSA+IGZpZWxkc2V0Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHNldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZmllbGRzZXRzW2ldLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHZhbGlkYXRlUmVxdWlyZWRGaWVsZHMoc2VsZWN0b3I6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yICsgJyBpbnB1dFtyZXF1aXJlZF0sICcgKyBzZWxlY3RvciArICcgc2VsZWN0W3JlcXVpcmVkXScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGlucHV0c1tpXSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNaXNzaW5nSW5wdXRGcm9tVXNlcihpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1lvdSBtdXN0IGZpbGwgaW50byB0aGlzIGZpZWxkJyxcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dE5hbWU6IGlucHV0LmlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGFiZWxbZm9yPScgKyBpbnB1dC5pZCArICddJykhLmlubmVySFRNTCxcclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBpbnB1dC5wYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGt5Y1ZhbGlkYXRpb25FcnJvciA9IG5ldyBLeWNWYWxpZGF0b3JFcnJvcihvYmosIHRoaXMua3ljRm9ybSk7XHJcbiAgICAgICAgICAgICAgICBreWNWYWxpZGF0aW9uRXJyb3IuaGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGF0dGVybiA9IGlucHV0LnBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlcyA9IGlucHV0LnZhbHVlLm1hdGNoKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGlzIGlzIG5vdCB2YWxpZCBkYXRlIGZvcm1hdCwgcGxlYXNlIHVzZSBZWVlZLU1NLUREICh5ZWFyLW1vbnRoLWRhdGUpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXROYW1lOiBpbnB1dC5pZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxUZXh0OiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYWJlbFtmb3I9JyArIGlucHV0LmlkICsgJ10nKSEuaW5uZXJIVE1MLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBpbnB1dC5wYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQga3ljVmFsaWRhdGlvbkVycm9yID0gbmV3IEt5Y1ZhbGlkYXRvckVycm9yKG9iaiwgdGhpcy5reWNGb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICBreWNWYWxpZGF0aW9uRXJyb3IuaGFuZGxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc2hvd0VsZW1lbnQoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpPy5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGlkZUVsZW1lbnQoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0TGFiZWwoZWxlbWVudElkOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RheF9pZF9sYWJlbCcpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpc01pc3NpbmdJbnB1dEZyb21Vc2VyKGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICgoaW5wdXQudHlwZSA9PSAnY2hlY2tib3gnICYmICFpbnB1dC5jaGVja2VkKSB8fCBTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eShpbnB1dC52YWx1ZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCByZW1vdmVNaXNzaW5nSW5mbyhlcnJvckRpdklkOiBzdHJpbmcsIGZvY3VzRWxlbWVudElkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlcnJvckRpdklkKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgIGlmICghZm9jdXNFbGVtZW50SWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGZvY3VzRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZvY3VzRWxlbWVudElkKTtcclxuICAgICAgICBpZiAoZm9jdXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc2V0TWlzc2luZ0luZm8oZXJyb3JEaXZJZDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcsIGZvY3VzRWxlbWVudElkPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlcnJvckRpdklkKTtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVybjtcclxuXHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB0ZXh0O1xyXG4gICAgICAgIGlmICh0ZXh0ID09ICcnKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcclxuICAgICAgICAgICAgaWYgKGZvY3VzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk/LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChmb2N1c0VsZW1lbnRJZCk/LnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IEt5Y0NvbnRhY3RIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0NvbnRhY3QuaHRtbCc7XHJcbmltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEtZQ0Zvcm0gZnJvbSBcIi4uL0tZQ0Zvcm1cIjtcclxuaW1wb3J0IENvdW50cnlIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvQ291bnRyeUhlbHBlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0NvbnRhY3QgZXh0ZW5kcyBLeWNCYXNlIHtcclxuXHJcbiAgICB1c1RheFJlc2lkZW5jZSA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljQ29udGFjdEh0bWwpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXQsIGNvdW50cmllczogQ291bnRyeUhlbHBlci5Db3VudHJpZXN9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICB0aGlzLnNob3dGaWVsZHNldCgnLmt5Y0NvbnRhY3QnLCAnQ29udGFjdCBpbmZvcm1hdGlvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuYmluZCgnI2NvdW50cnlfb2ZfdGF4X3Jlc2lkZW5jZScsICdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy51c1RheFJlc2lkZW5jZSA9IChpbnB1dC52YWx1ZS50b1VwcGVyQ2FzZSgpID09ICdVU0EnKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGVfZGl2Jyk/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0uc2V0U3RlcHMoNSlcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ3N0YXRlJylcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0uc2V0U3RlcHMoNilcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVxdWlyZWQoJ3N0YXRlJyk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RhdGVfZGl2Jyk/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHNob3dJZGVudGl0eUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWN0X25leHQnKTtcclxuICAgICAgICBpZiAoc2hvd0lkZW50aXR5QnV0dG9uKSB7XHJcbiAgICAgICAgICAgIHNob3dJZGVudGl0eUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCcua3ljQ29udGFjdCcpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y0lkZW50aXR5LnNob3coKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZmllbGRzZXQgY2xhc3M9XFxcImt5Y0lkZW50aXR5IGhpZGRlblxcXCIgZGF0YS1mb3JtPVxcXCIxXFxcIj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImdpdmVuX25hbWVcXFwiPkxlZ2FsIEZpcnN0IG5hbWU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHJlcXVpcmVkIGlkPVxcXCJnaXZlbl9uYW1lXFxcIiBuYW1lPVxcXCJnaXZlbl9uYW1lXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCJSb25cXFwiXFxyXFxuICAgICAgICAgICAgICAgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJnaXZlbi1uYW1lXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJtaWRkbGVfbmFtZVxcXCI+TGVnYWwgTWlkZGxlIG5hbWU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJtaWRkbGVfbmFtZVxcXCIgbmFtZT1cXFwibWlkZGxlX25hbWVcXFwiXFxyXFxuICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XFxcIlxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImFkZGl0aW9uYWwtbmFtZVxcXCI+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZmFtaWx5X25hbWVcXFwiPkxlZ2FsIExhc3QgbmFtZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcImZhbWlseV9uYW1lXFxcIiBuYW1lPVxcXCJmYW1pbHlfbmFtZVxcXCJcXHJcXG4gICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cXFwiU3dhbnNvblxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIiBhdXRvY29tcGxldGU9XFxcImZhbWlseS1uYW1lXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIHt7I3VubGVzcyBlZGl0fX1cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImRhdGVfb2ZfYmlydGhcXFwiPkRhdGUgb2YgYmlydGg8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcImRhdGVcXFwiIHJlcXVpcmVkIGlkPVxcXCJkYXRlX29mX2JpcnRoXFxcIiBuYW1lPVxcXCJkYXRlX29mX2JpcnRoXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCIxOTc4LTExLTI0XFxcIiBwYXR0ZXJuPVxcXCJcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfVxcXCIgdmFsdWU9XFxcIlxcXCIgYXV0b2NvbXBsZXRlPVxcXCJiZGF5XFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxkaXYgaWQ9XFxcImNpdGl6ZW5fb2ZfdXNhX3F1ZXN0aW9uXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNpdGl6ZW5feWVzXFxcIj5BcmUgeW91IGEgY2l0aXplbiBvZiB0aGUgVW5pdGVkIFN0YXRlcz88L2xhYmVsPlxcclxcbiAgICAgICAgPGZpZWxkc2V0PlxcclxcbiAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIiBpZD1cXFwiY2l0aXplbl95ZXNcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJjaXRpemVuXFxcIiB2YWx1ZT1cXFwiMVxcXCI+IFllc1xcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGxhYmVsPlxcclxcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwicmFkaW9cXFwiIGlkPVxcXCJjaXRpemVuX25vXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cXFwiY2l0aXplblxcXCIgdmFsdWU9XFxcIjBcXFwiPiBOb1xcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGZpZWxkc2V0IGlkPVxcXCJjaXRpemVuX25vX3R5cGVfb3B0aW9uc1xcXCIgY2xhc3M9XFxcImhpZGRlblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwicGVybWFuZW50X3Jlc2lkZW50XFxcIiBpZD1cXFwiY2l0aXplbl9ub190eXBlX29wdGlvbnNfMVxcXCIgdmFsdWU9XFxcIjFcXFwiLz4gR3JlZW4gQ2FyZFxcclxcbiAgICAgICAgICAgICAgICAgICAgLyBQZXJtYW5lbnQgUmVzaWRlbnRcXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCB0eXBlPVxcXCJyYWRpb1xcXCIgbmFtZT1cXFwicGVybWFuZW50X3Jlc2lkZW50XFxcIiBpZD1cXFwiY2l0aXplbl9ub190eXBlX29wdGlvbnNfMlxcXCIgdmFsdWU9XFxcIjBcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgICAgIFZpc2E8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZmllbGRzZXQ+XFxyXFxuICAgICAgICA8L2ZpZWxkc2V0PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBpZD1cXFwidGF4X2lkX3R5cGVfb3B0aW9uc1xcXCI+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0YXhfaWRfdHlwZVxcXCI+VGF4IElkIFR5cGU8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwidGF4X2lkX3R5cGVcXFwiIG5hbWU9XFxcInRheF9pZF90eXBlXFxcIiBwbGFjZWhvbGRlcj1cXFwiVVNBX1NTTlxcXCI+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVVNBX1NTTlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVJHX0FSX0NVSVRcXFwiPkFyZ2VudGluYSBDVUlUPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQVVTX1RGTlxcXCI+QXVzdHJhbGlhbiBUYXggRmlsZSBOdW1iZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJBVVNfQUJOXFxcIj5BdXN0cmFsaWFuIEJ1c2luZXNzIE51bWJlcjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkJPTF9OSVRcXFwiPkJvbGl2aWEgTklUPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiQlJBX0NQRlxcXCI+QnJhemlsIENQRjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNITF9SVVRcXFwiPkNoaWxlIFJVVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNPTF9OSVRcXFwiPkNvbG9tYmlhIE5JVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkNSSV9OSVRFXFxcIj5Db3N0YSBSaWNhIE5JVEU8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJERVVfVEFYX0lEXFxcIj5HZXJtYW55IFRheCBJRCAoSWRlbnRpZmlrYXRpb25zbnVtbWVyKTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkRPTV9STkNcXFwiPkRvbWluaWNhbiBSZXB1YmxpYyBSTkM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJFQ1VfUlVDXFxcIj5FY3VhZG9yIFJVQzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkZSQV9TUElcXFwiPkZyYW5jZSBTUEkgKFJlZmVyZW5jZSBUYXggTnVtYmVyKTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkdCUl9VVFJcXFwiPlVLIFVUUiAoVW5pcXVlIFRheHBheWVyIFJlZmVyZW5jZSk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHQlJfTklOT1xcXCI+VUsgTklOTyAoTmF0aW9uYWwgSW5zdXJhbmNlIE51bWJlcik8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJHVE1fTklUXFxcIj5HdWF0ZW1hbGEgTklUPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSE5EX1JUTlxcXCI+SG9uZHVyYXMgUlROPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSFVOX1RJTlxcXCI+SHVuZ2FyeSBUSU4gTnVtYmVyPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSUROX0tUUFxcXCI+SW5kb25lc2lhIEtUUDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIklORF9QQU5cXFwiPkluZGlhIFBBTiBOdW1iZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJJU1JfVEFYX0lEXFxcIj5Jc3JhZWwgVGF4IElEIChUZXVkYXQgWmVodXQpPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSVRBX1RBWF9JRFxcXCI+SXRhbHkgVGF4IElEIChDb2RpY2UgRmlzY2FsZSk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJKUE5fVEFYX0lEXFxcIj5KYXBhbiBUYXggSUQgKEtvaWppbiBCYW5nbyk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJNRVhfUkZDXFxcIj5NZXhpY28gUkZDPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTklDX1JVQ1xcXCI+TmljYXJhZ3VhIFJVQzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk5MRF9USU5cXFwiPk5ldGhlcmxhbmRzIFRJTiBOdW1iZXI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQQU5fUlVDXFxcIj5QYW5hbWEgUlVDPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiUEVSX1JVQ1xcXCI+UGVydSBSVUM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJQUllfUlVDXFxcIj5QYXJhZ3VheSBSVUM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTR1BfTlJJQ1xcXCI+U2luZ2Fwb3JlIE5SSUM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJTR1BfRklOXFxcIj5TaW5nYXBvcmUgRklOPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0dQX0FTR0RcXFwiPlNpbmdhcG9yZSBBU0dEPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiU0dQX0lUUlxcXCI+U2luZ2Fwb3JlIElUUjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNMVl9OSVRcXFwiPkVsIFNhbHZhZG9yIE5JVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlNXRV9UQVhfSURcXFwiPlN3ZWRlbiBUYXggSUQgKFBlcnNvbm51bW1lcik8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJVUllfUlVUXFxcIj5VcnVndWF5IFJVVDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlZFTl9SSUZcXFwiPlZlbmV6dWVsYSBSSUY8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJOT1RfU1BFQ0lGSUVEXFxcIj5PdGhlciBUYXggSURzPC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgaWQ9XFxcInRheF9pZF9sYWJlbFxcXCIgZm9yPVxcXCJ0YXhfaWRcXFwiPlRheCBJZCAoU1NOKTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgcmVxdWlyZWQgaWQ9XFxcInRheF9pZFxcXCIgbmFtZT1cXFwidGF4X2lkXFxcIlxcclxcbiAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVxcXCI2NjYtNTUtNDMyMVxcXCJcXHJcXG4gICAgICAgICAgICAgICB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgaWQ9XFxcImNvdW50cnlfb2ZfYmlydGhfb3B0aW9uXFxcIj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvdW50cnlfb2ZfYmlydGhcXFwiPkNvdW50cnkgb2YgYmlydGg8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCBpZD1cXFwiY291bnRyeV9vZl9iaXJ0aFxcXCIgbmFtZT1cXFwiY291bnRyeV9vZl9iaXJ0aFxcXCI+XFxyXFxuICAgICAgICAgICAge3sjZWFjaCBjb3VudHJpZXN9fVxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7Y29kZX19XFxcIj57e25hbWV9fTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGlkPVxcXCJjb3VudHJ5X29mX2NpdGl6ZW5zaGlwX29wdGlvblxcXCI+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb3VudHJ5X29mX2NpdGl6ZW5zaGlwXFxcIj5Db3VudHJ5IG9mIGNpdGl6ZW5zaGlwPC9sYWJlbD5cXHJcXG4gICAgICAgIDxzZWxlY3QgcmVxdWlyZWQgaWQ9XFxcImNvdW50cnlfb2ZfY2l0aXplbnNoaXBcXFwiIG5hbWU9XFxcImNvdW50cnlfb2ZfY2l0aXplbnNoaXBcXFwiPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAge3sjZWFjaCBjb3VudHJpZXN9fVxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInt7Y29kZX19XFxcIj57e25hbWV9fTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7L2VhY2h9fVxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2IGlkPVxcXCJ2aXNhX3R5cGVfb3B0aW9uXFxcIiBjbGFzcz1cXFwiaGlkZGVuXFxcIj5cXHJcXG4gICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidmlzYV90eXBlXFxcIj5WaXNhIHR5cGUgLSA8YVxcclxcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cXFwiaHR0cHM6Ly90cmF2ZWwuc3RhdGUuZ292L2NvbnRlbnQvdHJhdmVsL2VuL3VzLXZpc2FzL3Zpc2EtaW5mb3JtYXRpb24tcmVzb3VyY2VzL2FsbC12aXNhLWNhdGVnb3JpZXMuaHRtbFxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldD1cXFwiX2JsYW5rXFxcIj5WaXNhXFxyXFxuICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uPC9hPjwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cXFwidmlzYV90eXBlXFxcIiBuYW1lPVxcXCJ2aXNhX3R5cGVcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJCMVxcXCIgc2VsZWN0ZWQ+VVNBIFZpc2EgQ2F0ZWdvcnkgQi0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkIyXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBCLTI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiREFDQVxcXCI+VVNBIFZpc2EgQ2F0ZWdvcnkgREFDQTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJFMVxcXCI+VVNBIFZpc2EgQ2F0ZWdvcnkgRS0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkUyXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBFLTI8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiRTNcXFwiPlVTQSBWaXNhIENhdGVnb3J5IEUtMzwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJGMVxcXCI+VVNBIFZpc2EgQ2F0ZWdvcnkgRi0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkc0XFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBHLTQ8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiSDFCXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBILTFCPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIkoxXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBKLTE8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiTDFcXFwiPlVTQSBWaXNhIENhdGVnb3J5IEwtMTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJPVEhFUlxcXCI+QW55IG90aGVyIFVTQSBWaXNhIENhdGVnb3J5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIk8xXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBPLTE8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiVE4xXFxcIj5VU0EgVmlzYSBDYXRlZ29yeSBUTi0xPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcInZpc2FfZXhwaXJhdGlvbl9kYXRlX29wdGlvblxcXCI+XFxyXFxuICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidmlzYV9leHBpcmF0aW9uX2RhdGVcXFwiPlZpc2EgZXhwaXJhdGlvbiBkYXRlPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiZGF0ZVxcXCIgaWQ9XFxcInZpc2FfZXhwaXJhdGlvbl9kYXRlXFxcIlxcclxcbiAgICAgICAgICAgICAgICAgICBuYW1lPVxcXCJ2aXNhX2V4cGlyYXRpb25fZGF0ZVxcXCIgcGxhY2Vob2xkZXI9XFxcIjIwMjgtMDUtMDFcXFwiIHZhbHVlPVxcXCJcXFwiPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYV9vcHRpb25cXFwiPlxcclxcbiAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImRhdGVfb2ZfZGVwYXJ0dXJlX2Zyb21fdXNhXFxcIj5EYXRlIG9mIGRlcGFydHVyZSBmcm9tIFVTQTwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImRhdGVcXFwiIGlkPVxcXCJkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgbmFtZT1cXFwiZGF0ZV9vZl9kZXBhcnR1cmVfZnJvbV91c2FcXFwiIHBsYWNlaG9sZGVyPVxcXCIyMDI4LTA1LTAxXFxcIiB2YWx1ZT1cXFwiXFxcIj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImFubnVhbF9pbmNvbWVcXFwiPkFubnVhbCBIb3VzZWhvbGQgSW5jb21lPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgICAgIEFubnVhbCBob3VzZWhvbGQgaW5jb21lIGluY2x1ZGVzIGluY29tZSBmcm9tIHNvdXJjZXMgc3VjaCBhcyBlbXBsb3ltZW50LCBhbGltb255LCBzb2NpYWwgc2VjdXJpdHksXFxyXFxuICAgICAgICAgICAgaW52ZXN0bWVudCBpbmNvbWUsIGV0Yy5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPHNlbGVjdCBuYW1lPVxcXCJhbm51YWxfaW5jb21lXFxcIiBpZD1cXFwiYW5udWFsX2luY29tZVxcXCI+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj48L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCIxXFxcIj4wIC0gJDIwLDAwMDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjJcXFwiPiQyMCwwMDAgLSAkNDksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiM1xcXCI+JDUwLDAwMCAtICQ5OSw5OTk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI0XFxcIj4kMTAwLDAwMCAtICQ0OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiNVxcXCI+JDUwMCwwMDAgLSAkOTk5LDk5OTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjZcXFwiPiQxLDAwMCwwMDAgLSAkOSw5OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJsaXF1aWRfbmV0X3dvcnRoXFxcIj5MaXF1aWQgQXNzZXRzPC9sYWJlbD5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPkxpcXVpZCBhc3NldHMgaXMgeW91ciBuZXQgd29ydGggbWludXMgYXNzZXRzIHRoYXQgY2Fubm90IGJlXFxyXFxuICAgICAgICAgICAgY29udmVydGVkIHF1aWNrbHkgYW5kIGVhc2lseSBpbnRvIGNhc2gsIHN1Y2ggYXMgcmVhbCBlc3RhdGUsIGJ1c2luZXNzIGVxdWl0eSxcXHJcXG4gICAgICAgICAgICBwZXJzb25hbCBwcm9wZXJ0eSBhbmQgYXV0b21vYmlsZXMsIGV4cGVjdGVkIGluaGVyaXRhbmNlcywgYXNzZXRzIGVhcm1hcmtlZCBmb3JcXHJcXG4gICAgICAgICAgICBvdGhlciBwdXJwb3NlcywgYW5kIGludmVzdG1lbnRzIG9yIGFjY291bnRzIHN1YmplY3QgdG8gc3Vic3RhbnRpYWwgcGVuYWx0aWVzXFxyXFxuICAgICAgICAgICAgaWYgdGhleSB3ZXJlIHNvbGQgb3IgaWYgYXNzZXRzIHdlcmUgd2l0aGRyYXduIGZyb20gdGhlbS5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPHNlbGVjdCBuYW1lPVxcXCJsaXF1aWRfbmV0X3dvcnRoXFxcIiByZXF1aXJlZCBpZD1cXFwibGlxdWlkX25ldF93b3J0aFxcXCI+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIj48L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCIxXFxcIj4wIC0gJDIwLDAwMDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjJcXFwiPiQyMCwwMDAgLSAkNDksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiM1xcXCI+JDUwLDAwMCAtICQ5OSw5OTk8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCI0XFxcIj4kMTAwLDAwMCAtICQ0OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiNVxcXCI+JDUwMCwwMDAgLSAkOTk5LDk5OTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIjFcXFwiPiQxLDAwMCwwMDAgLSAkOSw5OTksOTk5PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJmdW5kaW5nX3NvdXJjZVxcXCI+RnVuZGluZyBzb3VyY2U8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiZnVuZGluZ19zb3VyY2VcXFwiIG5hbWU9XFxcImZ1bmRpbmdfc291cmNlXFxcIlxcclxcbiAgICAgICAgICAgICAgICBtdWx0aXBsZSBzaXplPVxcXCI0XFxcIiBhcmlhLWxhYmVsPVxcXCJzaXplIDMgc2VsZWN0XFxcIj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJlbXBsb3ltZW50X2luY29tZVxcXCI+RW1wbG95bWVudCBpbmNvbWU8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJpbnZlc3RtZW50c1xcXCI+SW52ZXN0bWVudHM8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJpbmhlcml0YW5jZVxcXCI+SW5oZXJpdGFuY2U8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJidXNpbmVzc19pbmNvbWVcXFwiPkJ1c2luZXNzIGluY29tZTwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInNhdmluZ3NcXFwiPlNhdmluZ3M8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJmYW1pbHlcXFwiPkZhbWlseTwvb3B0aW9uPlxcclxcbiAgICAgICAgPC9zZWxlY3Q+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICB7ey91bmxlc3N9fVxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJpZGVudGl0eV9wcmV2XFxcIj5QcmV2aW91czogQ29udGFjdDwvYnV0dG9uPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJpZGVudGl0eV9uZXh0XFxcIj5OZXh0OiBUcnVzdGVkIGNvbnRhY3RzPC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcbmltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEt5Y0lkZW50aXR5SHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljSWRlbnRpdHkuaHRtbFwiO1xyXG5pbXBvcnQgQ291bnRyeUhlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9Db3VudHJ5SGVscGVyXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljSWRlbnRpdHkgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGVkaXQgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihreWNGb3JtOiBLWUNGb3JtKSB7XHJcbiAgICAgICAgc3VwZXIoa3ljRm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLmVkaXQgPSBlZGl0O1xyXG5cclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljSWRlbnRpdHlIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXQsIGNvdW50cmllczogQ291bnRyeUhlbHBlci5Db3VudHJpZXN9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5reWNDb250YWN0LnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd0VsZW1lbnQoJ2NpdGl6ZW5fb2ZfdXNhX3F1ZXN0aW9uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ3RheF9pZF90eXBlX29wdGlvbnMnKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRMYWJlbCgndGF4X2lkX2xhYmVsJywgJ1NTTicpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ2NpdGl6ZW5fb2ZfdXNhX3F1ZXN0aW9uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TGFiZWwoJ3RheF9pZF9sYWJlbCcsICdOYXRpb25hbCBUYXggSWQgKFNTTiknKTtcclxuICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgndGF4X2lkX3R5cGVfb3B0aW9ucycpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2hvd0ZpZWxkc2V0KCcua3ljSWRlbnRpdHknLCAnSWRlbnRpdHknKTtcclxuICAgICAgICB0aGlzLnNob3dFbGVtZW50KCdjb3VudHJ5X29mX2NpdGl6ZW5zaGlwX29wdGlvbicpO1xyXG4gICAgICAgIGxldCBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvdW50cnlfb2ZfY2l0aXplbnNoaXAnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICBpZiAoY291bnRyeV9vZl9jaXRpemVuc2hpcCkge1xyXG4gICAgICAgICAgICBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwLm9wdGlvbnNbMV0uZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgnI2NpdGl6ZW5feWVzJywgJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGF4SWRUeXBlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RheF9pZF90eXBlJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGF4SWRUeXBlKSB0YXhJZFR5cGUudmFsdWUgPSAnVVNBX1NTTic7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGNvdW50cnlfb2ZfY2l0aXplbnNoaXAgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY291bnRyeV9vZl9jaXRpemVuc2hpcCcpIGFzIEhUTUxTZWxlY3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgY291bnRyeV9vZl9jaXRpemVuc2hpcC5vcHRpb25zWzFdLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwLnZhbHVlID0gJ1VTQSc7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlRWxlbWVudCgnY2l0aXplbl9ub190eXBlX29wdGlvbnMnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ3Zpc2FfdHlwZV9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ2NvdW50cnlfb2ZfY2l0aXplbnNoaXBfb3B0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdjb3VudHJ5X29mX2JpcnRoJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCd2aXNhX3R5cGUnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVxdWlyZWQoJ3Zpc2FfZXhwaXJhdGlvbl9kYXRlJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYScpO1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RheF9pZF9sYWJlbCcpIS5pbm5lckhUTUwgPSAnU1NOJ1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlQ2l0aXplbkVycm9yTWVzc2FnZSgpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG5cclxuICAgICAgICB0aGlzLmJpbmQoJyNjaXRpemVuX25vJywgJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFbGVtZW50KCdjaXRpemVuX25vX3R5cGVfb3B0aW9ucycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgnY291bnRyeV9vZl9jaXRpemVuc2hpcF9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ2NvdW50cnlfb2ZfYmlydGgnKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0YXhfaWRfbGFiZWwnKSEuaW5uZXJIVE1MID0gJ1NTTidcclxuICAgICAgICAgICAgICAgIGxldCBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvdW50cnlfb2ZfY2l0aXplbnNoaXAnKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGNvdW50cnlfb2ZfY2l0aXplbnNoaXAub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjb3VudHJ5X29mX2NpdGl6ZW5zaGlwLm9wdGlvbnNbMV0uZGlzYWJsZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUNpdGl6ZW5FcnJvck1lc3NhZ2UoKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuXHJcbiAgICAgICAgdGhpcy5iaW5kKCcjY2l0aXplbl9ub190eXBlX29wdGlvbnNfMScsICdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGlucHV0ID0gZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgnY291bnRyeV9vZl9jaXRpemVuc2hpcF9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoJ3Zpc2FfdHlwZV9vcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ2NvdW50cnlfb2ZfYmlydGgnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUmVxdWlyZWQoJ3Zpc2FfdHlwZScpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCd2aXNhX2V4cGlyYXRpb25fZGF0ZScpXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYScpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLmJpbmQoJyNjaXRpemVuX25vX3R5cGVfb3B0aW9uc18yJywgJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSBldnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFbGVtZW50KCd2aXNhX3R5cGVfb3B0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dFbGVtZW50KCdjb3VudHJ5X29mX2NpdGl6ZW5zaGlwX29wdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1aXJlZCgnY291bnRyeV9vZl9iaXJ0aCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1aXJlZCgnY291bnRyeV9vZl9jaXRpemVuc2hpcCcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZXF1aXJlZCgndmlzYV90eXBlJylcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ3Zpc2FfZXhwaXJhdGlvbl9kYXRlJylcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVxdWlyZWQoJ2RhdGVfb2ZfZGVwYXJ0dXJlX2Zyb21fdXNhJylcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuYmluZCgnI3Zpc2FfdHlwZScsICdjaGFuZ2UnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IGV2dC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlID09ICdCMScgfHwgaW5wdXQudmFsdWUgPT0gJ0IyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93RWxlbWVudCgnZGF0ZV9vZl9kZXBhcnR1cmVfZnJvbV91c2Ffb3B0aW9uJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVFbGVtZW50KCdkYXRlX29mX2RlcGFydHVyZV9mcm9tX3VzYV9vcHRpb24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHRoaXMuYmluZEJ1dHRvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGhpZGVDaXRpemVuRXJyb3JNZXNzYWdlKCkge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaXRpemVuX3llcycpIS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xyXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5wdXRfZXJyb3JfY2l0aXplbl95ZXMnKTtcclxuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSBlcnJvck1lc3NhZ2UucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kQnV0dG9ucygpIHtcclxuICAgICAgICBsZXQgc2hvd0NvbnRhY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWRlbnRpdHlfcHJldicpO1xyXG4gICAgICAgIHNob3dDb250YWN0QnV0dG9uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y0NvbnRhY3Quc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBzaG93RGlzY2xvc3VyZXNCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaWRlbnRpdHlfbmV4dCcpO1xyXG4gICAgICAgIHNob3dEaXNjbG9zdXJlc0J1dHRvbj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZUlucHV0cygpKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCcua3ljSWRlbnRpdHknKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y1RydXN0ZWRDb250YWN0LnNob3coKTtcclxuXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlSW5wdXRzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVkaXQpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBsZXQgY2l0aXplbl95ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2l0aXplbl95ZXMnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBjaXRpemVuX25vID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NpdGl6ZW5fbm8nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMua3ljRm9ybS5reWNDb250YWN0LnVzVGF4UmVzaWRlbmNlKSB7XHJcbiAgICAgICAgICAgIGNpdGl6ZW5feWVzLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY2l0aXplbl9uby5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFjaXRpemVuX3llcy5jaGVja2VkICYmICFjaXRpemVuX25vLmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdZb3UgbXVzdCBzZWxlY3QgZWl0aGVyIG9wdGlvbicsXHJcbiAgICAgICAgICAgICAgICBpbnB1dE5hbWU6ICdjaXRpemVuX3llcycsXHJcbiAgICAgICAgICAgICAgICBsYWJlbFRleHQ6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xhYmVsW2Zvcj1jaXRpemVuX3llc10nKSEuaW5uZXJIVE1MXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBreWNWYWxpZGF0aW9uRXJyb3IgPSBuZXcgS3ljVmFsaWRhdG9yRXJyb3Iob2JqLCB0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgICAgICAgICBreWNWYWxpZGF0aW9uRXJyb3IuaGFuZGxlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBncmVlbkNhcmRPcHRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2l0aXplbl9ub190eXBlX29wdGlvbnNfMScpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IHZpc2FPcHRpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2l0aXplbl9ub190eXBlX29wdGlvbnNfMicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKGNpdGl6ZW5fbm8uY2hlY2tlZCAmJiAhZ3JlZW5DYXJkT3B0aW9uLmNoZWNrZWQgJiYgIXZpc2FPcHRpb24uY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBsZXQgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1lvdSBtdXN0IHNlbGVjdCBlaXRoZXIgb3B0aW9uLCBcIkdyZWVuIENhcmQgLyBQZXJtYW5lbnQgUmVzaWRlbnRcIiBvciBcIlZpc2FcIicsXHJcbiAgICAgICAgICAgICAgICBpbnB1dE5hbWU6ICdjaXRpemVuX25vJyxcclxuICAgICAgICAgICAgICAgIGxhYmVsVGV4dDogJydcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGt5Y1ZhbGlkYXRpb25FcnJvciA9IG5ldyBLeWNWYWxpZGF0b3JFcnJvcihvYmosIHRoaXMua3ljRm9ybSk7XHJcbiAgICAgICAgICAgIGt5Y1ZhbGlkYXRpb25FcnJvci5oYW5kbGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNEaXNjbG9zdXJlcyBoaWRkZW5cXFwiIGRhdGEtZm9ybT1cXFwiMVxcXCI+XFxyXFxuICAgIHt7I3VubGVzcyBlZGl0fX1cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImVtcGxveW1lbnRfc3RhdHVzXFxcIj5FbXBsb3ltZW50IHN0YXR1czwvbGFiZWw+XFxyXFxuICAgICAgICA8c2VsZWN0IGlkPVxcXCJlbXBsb3ltZW50X3N0YXR1c1xcXCIgcmVxdWlyZWQgbmFtZT1cXFwiZW1wbG95bWVudF9zdGF0dXNcXFwiPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcIlxcXCI+PC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiZW1wbG95ZWRcXFwiPkVtcGxveWVkPC9vcHRpb24+XFxyXFxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwidW5lbXBsb3llZFxcXCI+VW5lbXBsb3llZDwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XFxcInJldGlyZWRcXFwiPlJldGlyZWQ8L29wdGlvbj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJzdHVkZW50XFxcIj5TdHVkZW50PC9vcHRpb24+XFxyXFxuICAgICAgICA8L3NlbGVjdD5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJlbXBsb3llcl9uYW1lXFxcIj5FbXBsb3llciBuYW1lPC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBuYW1lPVxcXCJlbXBsb3llcl9uYW1lXFxcIiBpZD1cXFwiZW1wbG95ZXJfbmFtZVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImVtcGxveWVyX2FkZHJlc3NcXFwiPkVtcGxveWVyIGFkZHJlc3M8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImVtcGxveWVyX2FkZHJlc3NcXFwiIGlkPVxcXCJlbXBsb3llcl9hZGRyZXNzXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZW1wbG95bWVudF9wb3NpdGlvblxcXCI+T2NjdXBhdGlvbiAvIEpvYiB0aXRsZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiZW1wbG95bWVudF9wb3NpdGlvblxcXCIgaWQ9XFxcImVtcGxveW1lbnRfcG9zaXRpb25cXFwiIGF1dG9jb21wbGV0ZT1cXFwib3JnYW5pemF0aW9uLXRpdGxlXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICB7ey91bmxlc3N9fVxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJkaXNjbG9zdXJlX3NlbGVjdGlvbnNcXFwiPlxcclxcbiAgICAgICAgRG8gYW55IG9mIHRoZSBmb2xsb3dpbmcgYXBwbHkgdG8geW91IG9yIGEgbWVtYmVyIG9mIHlvdXIgaW1tZWRpYXRlIGZhbWlseT9cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImlzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmFcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIiBpZD1cXFwiaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYVxcXCIgbmFtZT1cXFwiaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlPVxcXCJzd2l0Y2hcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIEFmZmlsaWF0ZWQgb3Igd29yayB3aXRoIGEgVVMgcmVnaXN0ZXJlZCBicm9rZXItZGVhbGVyIG9yXFxyXFxuICAgICAgICAgICAgICAgIEZJTlJBLlxcclxcbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImV4cGxhaW5cXFwiPkFyZSB5b3Ugb3IgYW4gaW1tZWRpYXRlIGZhbWlseSBtZW1iZXIgYWZmaWxpYXRlZCB3aXRoIG9yIGVtcGxveWVkIGJ5IGEgc3RvY2tcXHJcXG4gICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlLCByZWd1bGF0b3J5IGJvZHksIG1lbWJlciBmaXJtIG9mIGFuIGV4Y2hhbmdlLCBGSU5SQSBvciBhIG11bmljaXBhbCBzZWN1cml0aWVzXFxyXFxuICAgICAgICAgICAgICAgICAgICBicm9rZXItZGVhbGVyPzwvc21hbGw+XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImlzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmFfZXh0cmFcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJpc19jb250cm9sX3BlcnNvblxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJpc19jb250cm9sX3BlcnNvblxcXCIgbmFtZT1cXFwiaXNfY29udHJvbF9wZXJzb25cXFwiIHJvbGU9XFxcInN3aXRjaFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgU2VuaW9yIGV4ZWN1dGl2ZSBhdCBvciBhIDEwJSBvciBncmVhdGVyIHNoYXJlaG9sZGVyIG9mIGEgcHVibGljbHkgdHJhZGVkIGNvbXBhbnkuXFxyXFxuICAgICAgICAgICAgICAgIDxzbWFsbCBjbGFzcz1cXFwiZXhwbGFpblxcXCI+QXJlIHlvdSBvciBhbiBpbW1lZGlhdGUgZmFtaWx5IG1lbWJlciBhbiBvZmZpY2VyIG9yIDEwJSBvciBncmVhdGVyIHNoYXJlaG9sZGVyIG9mXFxyXFxuICAgICAgICAgICAgICAgICAgICBhIHB1YmxpY2x5IHRyYWRlZCBjb21wYW55LCBzdWJqZWN0IHRvIHRoZSBVUyBTZWN1cml0aWVzIEV4Y2hhbmdlIEFjdCAxOTM0Pzwvc21hbGw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImlzX2NvbnRyb2xfcGVyc29uX2V4dHJhXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiaXNfcG9saXRpY2FsbHlfZXhwb3NlZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJpc19wb2xpdGljYWxseV9leHBvc2VkXFxcIiBuYW1lPVxcXCJpc19wb2xpdGljYWxseV9leHBvc2VkXFxcIiByb2xlPVxcXCJzd2l0Y2hcXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIEkgYW0gYSBzZW5pb3IgcG9saXRpY2FsIGZpZ3VyZS5cXHJcXG4gICAgICAgICAgICAgICAgPHNtYWxsIGNsYXNzPVxcXCJleHBsYWluXFxcIj5BcmUgeW91IGN1cnJlbnRseSBvciBmb3JtZXJseSBhIFBvbGl0aWNhbGx5IEV4cG9zZWQgUGVyc29uIG9yIFB1YmxpYyBPZmZpY2lhbFxcclxcbiAgICAgICAgICAgICAgICAgICAgKFBFUCk/IDxhIGhyZWY9XFxcImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vc2VhcmNoP3E9JUUyJTgwJTlDUG9saXRpY2FsbHkrRXhwb3NlZCtQZXJzb24lRTIlODAlOUQrKFBFUClcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPldoYXQgaXMgUEVQPzwvYT4gPC9hPjwvc21hbGw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9XFxcImlzX3BvbGl0aWNhbGx5X2V4cG9zZWRfZXh0cmFcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIGlkPVxcXCJpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWRcXFwiIG5hbWU9XFxcImltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZFxcXCIgcm9sZT1cXFwic3dpdGNoXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICBJIGFtIGEgZmFtaWx5IG1lbWJlciBvciByZWxhdGl2ZSBvZiBhIHNlbmlvciBwb2xpdGljYWwgZmlndXJlLlxcclxcbiAgICAgICAgICAgICAgICA8c21hbGwgY2xhc3M9XFxcImV4cGxhaW5cXFwiPkFyZSB5b3UgYW4gaW1tZWRpYXRlIGZhbWlseSBtZW1iZXIgY3VycmVudGx5IG9yIGZvcm1lcmx5IGEgUG9saXRpY2FsbHkgRXhwb3NlZFxcclxcbiAgICAgICAgICAgICAgICAgICAgUGVyc29uIG9yIFB1YmxpYyBPZmZpY2lhbCAoUEVQKT8gPGFcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZj1cXFwiaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g/cT0lRTIlODAlOUNQb2xpdGljYWxseStFeHBvc2VkK1BlcnNvbiVFMiU4MCU5RCsoUEVQKVxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPldoYXQgaXMgUEVQPzwvYT48L3NtYWxsPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVxcXCJpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWRfZXh0cmFcXFwiPjwvZGl2PlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJub25lX2Fib3ZlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJjaGVja2JveFxcXCIgaWQ9XFxcIm5vbmVfYWJvdmVcXFwiIG5hbWU9XFxcIm5vbmVfYWJvdmVcXFwiIHJvbGU9XFxcInN3aXRjaFxcXCI+PC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICBOb25lIG9mIHRoZSBhYm92ZSBhcHBseSB0byBtZSBvciBteSBmYW1pbHkuXFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIiBpZD1cXFwibm9uZV9hYm92ZV9lcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJkaXNjbG9zdXJlc19wcmV2XFxcIj5QcmV2aW91czogVHJ1c3RlZCBjb250YWN0PC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcImRpc2Nsb3N1cmVzX25leHRcXFwiPk5leHQ6IEFncmVlbWVudHM8L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGlkPVxcXCJhZmZpbGlhdGVfb3JfY29udHJvbGxlZFxcXCI+XFxyXFxuICAgIDxkaXY+WW91IG5lZWQgdG8gZmlsbCBpbiB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJjb21wYW55X25hbWVcXFwiPkNvbXBhbnkgbmFtZTwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiY29tcGFueV9uYW1lXFxcIiByZXF1aXJlZCBpZD1cXFwiY29tcGFueV9uYW1lXFxcIiBhdXRvY29tcGxldGU9XFxcIm9yZ2FuaXphdGlvblxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlfc3RyZWV0X2FkZHJlc3NcXFwiPkNvbXBhbnkgc3RyZWV0IGFkZHJlc3M8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfc3RyZWV0X2FkZHJlc3NcXFwiIHJlcXVpcmVkIGlkPVxcXCJjb21wYW55X3N0cmVldF9hZGRyZXNzXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29tcGFueV9jaXR5XFxcIj5Db21wYW55IGNpdHk8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfY2l0eVxcXCIgcmVxdWlyZWQgaWQ9XFxcImNvbXBhbnlfY2l0eVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlfc3RhdGVcXFwiPkNvbXBhbnkgc3RhdGU8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfc3RhdGVcXFwiIHJlcXVpcmVkIGlkPVxcXCJjb21wYW55X3N0YXRlXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiY29tcGFueV9jb3VudHJ5XFxcIj5Db21wYW55IGNvdW50cnk8L2xhYmVsPlxcclxcbiAgICAgICAgPHNlbGVjdCByZXF1aXJlZCBpZD1cXFwiY29tcGFueV9jb3VudHJ5XFxcIiByZXF1aXJlZCBuYW1lPVxcXCJjb21wYW55X2NvdW50cnlcXFwiPlxcclxcbiAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2NvZGV9fVxcXCI+e3tuYW1lfX08L29wdGlvbj5cXHJcXG4gICAgICAgICAgICB7ey9lYWNofX1cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcImNvbXBhbnlfY29tcGxpYW5jZV9lbWFpbFxcXCI+Q29tcGFueSBjb21wbGlhbmNlIG9mZmljZXIgZW1haWw8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IG5hbWU9XFxcImNvbXBhbnlfY29tcGxpYW5jZV9lbWFpbFxcXCIgcmVxdWlyZWQgaWQ9XFxcImNvbXBhbnlfY29tcGxpYW5jZV9lbWFpbFxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgICAgIEluIGFjY29yZGFuY2Ugd2l0aCBhcHBsaWNhYmxlIEZJTlJBIHJ1bGVzLCB1c2VyIHdpbGwgbmVlZCB0byBvYnRhaW4gYSBsZXR0ZXIgd3JpdHRlblxcclxcbiAgICAgICAgICAgIGFuZCBzaWduZWQgYnkgYSBjb21wbGlhbmNlIG9mZmljZXIgb24gY29tcGFueSBsZXR0ZXJoZWFkIGV4cGxpY2l0bHkgZ3JhbnRpbmcgcGVybWlzc2lvbiBmb3JcXHJcXG4gICAgICAgICAgICB0aGUgYXBwbGljYW50IHRvIGNhcnJ5IHRoZSBhY2NvdW50IGFuZCBleHBsaWNpdGx5IHN0YXRpbmcgd2hldGhlciBvciBub3QgdGhlIGZpcm0gcmVxdWlyZXNcXHJcXG4gICAgICAgICAgICBhY2Nlc3MgdG8gZHVwbGljYXRlIGFjY291bnQgc3RhdGVtZW50cyBhbmQvb3IgdHJhZGUgY29uZmlybWF0aW9ucy5cXHJcXG5cXHJcXG4gICAgICAgICAgICBJZiB0aGUgZmlybSB3b3VsZCBsaWtlIG9ubGluZSBhY2Nlc3MgeW91ciBkdXBsaWNhdGUgYWNjb3VudCBzdGF0ZW1lbnRzIGFuZC9vciB0cmFkZSBjb25maXJtYXRpb25zLFxcclxcbiAgICAgICAgICAgIGluY2x1ZGUgaW4gdGhlIGxldHRlciB0aGUgYXBwbGljYW50J3MgZnVsbCBuYW1lIGFuZCB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGZvciB0aGUgaW50ZXJlc3RlZFxcclxcbiAgICAgICAgICAgIHBhcnR5OiBGaXJzdCBhbmQgbGFzdCBuYW1lLCB0aXRsZSwgZW1haWwgYWRkcmVzcywgdGVsZXBob25lIG51bWJlci5cXHJcXG5cXHJcXG4gICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAge3t7ZmlsZVVwbG9hZCBcXFwiYWNjb3VudF9hcHByb3ZhbF9sZXR0ZXJcXFwiIFxcXCJBY2NvdW50IGFwcHJvdmFsIGxldHRlclxcXCJ9fX1cXHJcXG5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cXHJcXG5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5pbXBvcnQgS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkSHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkLmh0bWxcIjtcclxuaW1wb3J0IENvdW50cnlIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvQ291bnRyeUhlbHBlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZCBleHRlbmRzIEt5Y0Jhc2Uge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCBreWNBZmZpbGlhdGVPckNvbnRyb2xsZWRUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNBZmZpbGlhdGVPckNvbnRyb2xsZWRIdG1sKVxyXG4gICAgICAgIHJldHVybiBreWNBZmZpbGlhdGVPckNvbnRyb2xsZWRUZW1wbGF0ZSh7Y291bnRyaWVzOiBDb3VudHJ5SGVscGVyLkNvdW50cmllc30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuYmluZEZpbGVVcGxvYWRzKCk7XHJcblxyXG4gICAgICAgIGxldCBjb21wYW55X2NvdW50cnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29tcGFueV9jb3VudHJ5JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBjb21wYW55X2NvdW50cnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChldnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdCA9IGV2dC50YXJnZXQgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3QudmFsdWUgPT09ICdVU0EnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlcXVpcmVkKCdjb21wYW55X3N0YXRlJyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJlcXVpcmVkKCdjb21wYW55X3N0YXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB2YWxpZGF0ZSgpIHtcclxuICAgICAgICBsZXQgY29tcGFueV9uYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbXBhbnlfbmFtZScpO1xyXG4gICAgICAgIGlmICghY29tcGFueV9uYW1lKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVSZXF1aXJlZEZpZWxkcygnI2FmZmlsaWF0ZV9vcl9jb250cm9sbGVkJylcclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBpZD1cXFwiaW1tZWRpYXRlX2ZhbWlseVxcXCI+XFxyXFxuICAgIDxkaXY+U2luY2UgeW91IGNob3NlIHRoYXQgeW91ciBpbW1lZGlhdGUgZmFtaWx5IG1lbWJlciwgeW91IG5lZWQgdG8gZmlsbCBpbiB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJkaXNjbG9zdXJlX2dpdmVuX25hbWVcXFwiPkdpdmVuIG5hbWUgb2YgcG9saXRpY2FsIHBlcnNvbjwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiZGlzY2xvc3VyZV9naXZlbl9uYW1lXFxcIiBpZD1cXFwiZGlzY2xvc3VyZV9naXZlbl9uYW1lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwiZGlzY2xvc3VyZV9mYW1pbHlfbmFtZVxcXCI+RmFtaWx5IG5hbWUgb2YgcG9saXRpY2FsIHBlcnNvbjwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgbmFtZT1cXFwiZGlzY2xvc3VyZV9mYW1pbHlfbmFtZVxcXCIgaWQ9XFxcImRpc2Nsb3N1cmVfZmFtaWx5X25hbWVcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuPC9maWVsZHNldD5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5pbXBvcnQgS3ljSW1tZWRpYXRlRmFtaWx5SHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljSW1tZWRpYXRlRmFtaWx5Lmh0bWxcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLeWNJbW1lZGlhdGVGYW1pbHkgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xyXG4gICAgICAgIGxldCBreWNJbW1lZGlhdGVGYW1pbHlUZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLeWNJbW1lZGlhdGVGYW1pbHlIdG1sKTtcclxuICAgICAgICByZXR1cm4ga3ljSW1tZWRpYXRlRmFtaWx5VGVtcGxhdGUoe30pXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhbGlkYXRlKCkge1xyXG4gICAgICAgIGxldCBkaXNjbG9zdXJlX2dpdmVuX25hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlzY2xvc3VyZV9naXZlbl9uYW1lJylcclxuICAgICAgICBpZiAoIWRpc2Nsb3N1cmVfZ2l2ZW5fbmFtZSkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlUmVxdWlyZWRGaWVsZHMoJyNpbW1lZGlhdGVfZmFtaWx5JylcclxuICAgIH1cclxufSIsImltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEtZQ0Zvcm0gZnJvbSBcIi4uL0tZQ0Zvcm1cIjtcclxuaW1wb3J0IEt5Y0Rpc2Nsb3N1cmVIdG1sIGZyb20gXCIuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNEaXNjbG9zdXJlcy5odG1sXCI7XHJcbmltcG9ydCBLeWNBZmZpbGlhdGVPckNvbnRyb2xsZWQgZnJvbSBcIi4vS3ljQWZmaWxpYXRlT3JDb250cm9sbGVkXCI7XHJcbmltcG9ydCBLeWNJbW1lZGlhdGVGYW1pbHkgZnJvbSBcIi4vS3ljSW1tZWRpYXRlRmFtaWx5XCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS3ljRGlzY2xvc3VyZXMgZXh0ZW5kcyBLeWNCYXNlIHtcclxuICAgIGt5Y0FmZmlsaWF0ZWRPckNvbnRyb2xsZWQ6IEt5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZDtcclxuICAgIGt5Y0ltbWVkaWF0ZUZhbWlseTogS3ljSW1tZWRpYXRlRmFtaWx5O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y0Zvcm06IEtZQ0Zvcm0pIHtcclxuICAgICAgICBzdXBlcihreWNGb3JtKTtcclxuXHJcbiAgICAgICAgdGhpcy5reWNBZmZpbGlhdGVkT3JDb250cm9sbGVkID0gbmV3IEt5Y0FmZmlsaWF0ZU9yQ29udHJvbGxlZCh0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgICAgIHRoaXMua3ljSW1tZWRpYXRlRmFtaWx5ID0gbmV3IEt5Y0ltbWVkaWF0ZUZhbWlseSh0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW5kZXIoZWRpdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y0Rpc2Nsb3N1cmVIdG1sKTtcclxuICAgICAgICByZXR1cm4gdGVtcGxhdGUoe2VkaXQ6IGVkaXR9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICBpZiAodGhpcy5reWNGb3JtLnN0ZXBzID09IDUpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc2Nsb3N1cmVzX25leHQnKSEuaW5uZXJUZXh0ID0gJ05leHQ6IEFncmVlbWVudHMnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXNjbG9zdXJlc19uZXh0JykhLmlubmVyVGV4dCA9ICdOZXh0OiBVcGxvYWQgZG9jdW1lbnRzJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaG93RmllbGRzZXQoJy5reWNEaXNjbG9zdXJlcycsICdEaXNjbG9zdXJlcycpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG5cclxuICAgICAgICBsZXQgaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQWZmaWxpYXRlZE9yQ29udHJvbENvbXBvbmVudCgnaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYScpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgaXNfY29udHJvbF9wZXJzb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaXNfY29udHJvbF9wZXJzb24nKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlzX2NvbnRyb2xfcGVyc29uPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkQWZmaWxpYXRlZE9yQ29udHJvbENvbXBvbmVudCgnaXNfY29udHJvbF9wZXJzb24nKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFBlcCgnaW1tZWRpYXRlX2ZhbWlseV9leHBvc2VkJylcclxuICAgICAgICB9KTtcclxuICAgICAgICBsZXQgaXNfcG9saXRpY2FsbHlfZXhwb3NlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpc19wb2xpdGljYWxseV9leHBvc2VkJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpc19wb2xpdGljYWxseV9leHBvc2VkPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51bmNoZWNrKCdpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWQnKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBub25lX2Fib3ZlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vbmVfYWJvdmUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIG5vbmVfYWJvdmU/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU1pc3NpbmdJbmZvKCdub25lX2Fib3ZlX2Vycm9yJyk7XHJcbiAgICAgICAgICAgIG5vbmVfYWJvdmUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBsZXQgcHJldiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXNjbG9zdXJlc19wcmV2Jyk7XHJcbiAgICAgICAgcHJldj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNUcnVzdGVkQ29udGFjdC5zaG93KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBuZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc2Nsb3N1cmVzX25leHQnKTtcclxuICAgICAgICBuZXh0Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlRmllbGRzKCkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5zdGVwcyA9PSA1KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljQWNjb3VudEFncmVlbWVudC5zaG93KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljVXBsb2FkLnNob3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZEFmZmlsaWF0ZWRPckNvbnRyb2xDb21wb25lbnQoZWxlbWVudElkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoZWxlbWVudElkID09ICdpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhJykge1xyXG4gICAgICAgICAgICB0aGlzLnVuY2hlY2soJ2lzX2NvbnRyb2xfcGVyc29uJylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVuY2hlY2soJ2lzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmEnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGV4dHJhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkICsgJ19leHRyYScpO1xyXG4gICAgICAgIGlmICghZXh0cmEpIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnQuY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBleHRyYS5pbm5lckhUTUwgPSB0aGlzLmt5Y0FmZmlsaWF0ZWRPckNvbnRyb2xsZWQucmVuZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljQWZmaWxpYXRlZE9yQ29udHJvbGxlZC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXh0cmEuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbG9hZFBlcChlbGVtZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGlmIChlbGVtZW50SWQgPT0gJ2ltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCcpIHtcclxuICAgICAgICAgICAgdGhpcy51bmNoZWNrKCdpc19wb2xpdGljYWxseV9leHBvc2VkJylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVuY2hlY2soJ2ltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCcpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCkgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBsZXQgZXh0cmEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQgKyAnX2V4dHJhJyk7XHJcbiAgICAgICAgaWYgKCFleHRyYSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudC5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIGV4dHJhLmlubmVySFRNTCA9IHRoaXMua3ljSW1tZWRpYXRlRmFtaWx5LnJlbmRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmt5Y0ltbWVkaWF0ZUZhbWlseS5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZXh0cmEuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdW5jaGVjayhlbGVtZW50SWQ6IHN0cmluZykge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudElkKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGVsZW1lbnQuY2hlY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBleHRyYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRJZCArICdfZXh0cmEnKSE7XHJcbiAgICAgICAgZXh0cmEuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUZpZWxkcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVSZXF1aXJlZEZpZWxkcygnLmt5Y0Rpc2Nsb3N1cmVzJykpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMua3ljSW1tZWRpYXRlRmFtaWx5LnZhbGlkYXRlKCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMua3ljQWZmaWxpYXRlZE9yQ29udHJvbGxlZC52YWxpZGF0ZSgpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgIGxldCBpc19hZmZpbGlhdGVkX2V4Y2hhbmdlX29yX2ZpbnJhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2lzX2FmZmlsaWF0ZWRfZXhjaGFuZ2Vfb3JfZmlucmEnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBpc19jb250cm9sX3BlcnNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpc19jb250cm9sX3BlcnNvbicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGlzX3BvbGl0aWNhbGx5X2V4cG9zZWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaXNfcG9saXRpY2FsbHlfZXhwb3NlZCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgbGV0IGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbW1lZGlhdGVfZmFtaWx5X2V4cG9zZWQnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGxldCBub25lX2Fib3ZlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vbmVfYWJvdmUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBpZiAoIW5vbmVfYWJvdmUuY2hlY2tlZCAmJiAhaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYS5jaGVja2VkICYmICFpc19jb250cm9sX3BlcnNvbi5jaGVja2VkXHJcbiAgICAgICAgICAgICYmICFpc19wb2xpdGljYWxseV9leHBvc2VkLmNoZWNrZWQgJiYgIWltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZC5jaGVja2VkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ25vbmVfYWJvdmVfZXJyb3InLCAnWW91IG11c3Qgc2VsZWN0LCBcIk5vbmUgb2YgdGhlIGFib3ZlIGFwcGx5IHRvIG1lIG9yIG15IGZhbWlseS5cIiBpZiBub3RoaW5nIGlzIHNlbGVjdGVkJywgJ25vbmVfYWJvdmUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5vbmVfYWJvdmUuY2hlY2tlZCAmJiAoaXNfYWZmaWxpYXRlZF9leGNoYW5nZV9vcl9maW5yYS5jaGVja2VkIHx8IGlzX2NvbnRyb2xfcGVyc29uLmNoZWNrZWRcclxuICAgICAgICAgICAgfHwgaXNfcG9saXRpY2FsbHlfZXhwb3NlZC5jaGVja2VkIHx8IGltbWVkaWF0ZV9mYW1pbHlfZXhwb3NlZC5jaGVja2VkXHJcbiAgICAgICAgKSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE1pc3NpbmdJbmZvKCdub25lX2Fib3ZlX2Vycm9yJywgJ1lvdSBjYW5ub3QgaGF2ZSBcIk5vbmUgb2YgdGhlIGFib3ZlIGFwcGx5IHRvIG1lIG9yIG15IGZhbWlseS5cIiBzZWxlY3RlZCBhbmQgb3RoZXIgb3B0aW9ucyBzZWxlY3RlZC4gUGxlYXNlIHNlbGVjdCBvbmx5IG9uZScsICdub25lX2Fib3ZlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNBY2NvdW50QWdyZWVtZW50IGhpZGRlblxcXCIgZGF0YS1mb3JtPVxcXCIxXFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwia3ljQWNjb3VudEFncmVlbWVudEdyaWRcXFwiPlxcclxcbiAgICAgICAgPGRpdiBpZD1cXFwiYWNjb3VudF9hZ3JlZW1lbnRfZXJyb3JcXFwiIGNsYXNzPVxcXCJpbnB1dF9lcnJvclxcXCI+PC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJhY2NvdW50X2FncmVlbWVudFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcImFjY291bnRfYWdyZWVtZW50XFxcIiBpZD1cXFwiYWNjb3VudF9hZ3JlZW1lbnRcXFwiIHZhbHVlPVxcXCIxXFxcIi8+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwiYWNjb3VudF9hZ3JlZW1lbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgSSBhZ3JlZSB0byA8YSBocmVmPVxcXCJodHRwczovL2ZpbGVzLmFscGFjYS5tYXJrZXRzL2Rpc2Nsb3N1cmVzL2xpYnJhcnkvQWNjdEFwcE1hcmdpbkFuZEN1c3RBZ210LnBkZlxcXCJcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPkFscGFjYSBDdXN0b21lciBBZ3JlZW1lbnQ8L2E+XFxyXFxuICAgICAgICAgICAgICAgIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgaWQ9XFxcImN1c3RvbWVyX2FncmVlbWVudF9lcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImN1c3RvbWVyX2FncmVlbWVudFxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgcmVxdWlyZWQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5hbWU9XFxcImN1c3RvbWVyX2FncmVlbWVudFxcXCIgaWQ9XFxcImN1c3RvbWVyX2FncmVlbWVudFxcXCIgdmFsdWU9XFxcIjFcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJjdXN0b21lcl9hZ3JlZW1lbnRcXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tZXIgQWdyZWVtZW50IEFja25vd2xlZGdlbWVudDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImV4cGxhaW5cXFwiPlxcclxcbiAgICAgICAgICAgICAgICAgICAgSSBoYXZlIHJlYWQsIHVuZGVyc3Rvb2QsIGFuZCBhZ3JlZSB0byBiZSBib3VuZCBieSBBbHBhY2EgU2VjdXJpdGllcyBMTEMgYW5kIExpbWluYWwubWFya2V0IEluYy5cXHJcXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRlcm1zLFxcclxcbiAgICAgICAgICAgICAgICAgICAgYW5kIGFsbCBvdGhlciB0ZXJtcywgZGlzY2xvc3VyZXMgYW5kIGRpc2NsYWltZXJzIGFwcGxpY2FibGUgdG8gbWUsIGFzIHJlZmVyZW5jZWQgaW4gdGhlIEFscGFjYVxcclxcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9tZXJcXHJcXG4gICAgICAgICAgICAgICAgICAgIEFncmVlbWVudC5cXHJcXG4gICAgICAgICAgICAgICAgICAgIEkgYWxzbyBhY2tub3dsZWRnZSB0aGF0IHRoZSBBbHBhY2EgQ3VzdG9tZXIgQWdyZWVtZW50IGNvbnRhaW5zIGEgcHJlLWRpc3B1dGUgYXJiaXRyYXRpb24gY2xhdXNlXFxyXFxuICAgICAgICAgICAgICAgICAgICBpblxcclxcbiAgICAgICAgICAgICAgICAgICAgU2VjdGlvblxcclxcbiAgICAgICAgICAgICAgICAgICAgNDMuXFxyXFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcblxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJkaWdpdGFsX3NpZ25hdHVyZV9lcnJvclxcXCIgY2xhc3M9XFxcImlucHV0X2Vycm9yXFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWRcXFwiPlxcclxcbiAgICAgICAgICAgIDxkaXY+XFxyXFxuICAgICAgICAgICAgICAgIDxsYWJlbCBmb3I9XFxcImRpZ2l0YWxfc2lnbmF0dXJlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwiZGlnaXRhbF9zaWduYXR1cmVcXFwiIGlkPVxcXCJkaWdpdGFsX3NpZ25hdHVyZVxcXCIgdmFsdWU9XFxcIjFcXFwiLz5cXHJcXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cXHJcXG4gICAgICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgICAgICA8ZGl2PlxcclxcbiAgICAgICAgICAgICAgICA8bGFiZWwgZm9yPVxcXCJkaWdpdGFsX3NpZ25hdHVyZVxcXCI+XFxyXFxuICAgICAgICAgICAgICAgICAgICBEaWdpdGFsIFNpZ25hdHVyZSBBY2tub3dsZWRnZW1lbnQ8L2xhYmVsPlxcclxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJleHBsYWluXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIEkgdW5kZXJzdGFuZCBJIGFtIHNpZ25pbmcgdGhpcyBhZ3JlZW1lbnQgZWxlY3Ryb25pY2FsbHksXFxyXFxuICAgICAgICAgICAgICAgICAgICBhbmQgdGhhdCBteSBlbGVjdHJvbmljIHNpZ25hdHVyZSB3aWxsIGhhdmUgdGhlIHNhbWUgZWZmZWN0IGFzIHBoeXNpY2FsbHkgc2lnbmluZyBhbmQgcmV0dXJuaW5nXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGVcXHJcXG4gICAgICAgICAgICAgICAgICAgIEFwcGxpY2F0aW9uIEFncmVlbWVudC5cXHJcXG4gICAgICAgICAgICAgICAgPC9kaXY+XFxyXFxuXFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgaGlkZGVuXFxcIiBpZD1cXFwidzhkaXNjbG9zdXJlX2RpdlxcXCI+XFxyXFxuICAgICAgICAgICAgPGRpdj5cXHJcXG4gICAgICAgICAgICAgICAgPGxhYmVsIGZvcj1cXFwidzhkaXNjbG9zdXJlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgICAgIDxpbnB1dCByZXF1aXJlZCB0eXBlPVxcXCJjaGVja2JveFxcXCIgbmFtZT1cXFwidzhkaXNjbG9zdXJlXFxcIiBpZD1cXFwidzhkaXNjbG9zdXJlXFxcIiB2YWx1ZT1cXFwiMVxcXCIvPlxcclxcbiAgICAgICAgICAgICAgICA8L2xhYmVsPlxcclxcbiAgICAgICAgICAgIDwvZGl2PlxcclxcbiAgICAgICAgICAgIDxkaXY+PGxhYmVsIGZvcj1cXFwidzhkaXNjbG9zdXJlXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgSSBjZXJ0aWZ5IHRoYXQgSSBhbSBub3QgYSBVUyBjaXRpemVuLCBVUyByZXNpZGVudCBhbGllbiBvciBvdGhlciBVUyBwZXJzb24gZm9yIFVTIHRheCBwdXJwb3NlcyxcXHJcXG4gICAgICAgICAgICAgICAgYW5kIEkgYW0gc3VibWl0dGluZyB0aGUgYXBwbGljYWJsZSBGb3JtIFctOCBCRU4gd2l0aCB0aGlzIGZvcm0gdG8gY2VydGlmeSBteSBmb3JlaWduIHN0YXR1cyBhbmQsXFxyXFxuICAgICAgICAgICAgICAgIGlmIGFwcGxpY2FibGUsIGNsYWltIHRheCB0cmVhdHkgYmVuZWZpdHMuIDwvbGFiZWw+XFxyXFxuICAgICAgICAgICAgPC9kaXY+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXYgY2xhc3M9XFxcImdyaWQgYnV0dG9uc1xcXCI+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcImFjY291bnRfYWdyZWVtZW50X3ByZXZcXFwiPlByZXZpb3VzOiBVcGxvYWQgZG9jdW1lbnRzPC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcInN1Ym1pdFxcXCIgaWQ9XFxcInN1Ym1pdEtZQ1xcXCI+Q29uZmlybSBpZGVudGl0eTwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiBpZD1cXFwia3ljRXJyb3JcXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj48L2Rpdj5cXHJcXG48L2ZpZWxkc2V0PlxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgS3ljQmFzZSBmcm9tIFwiLi9LeWNCYXNlXCI7XHJcbmltcG9ydCBLWUNGb3JtIGZyb20gXCIuLi9LWUNGb3JtXCI7XHJcbmltcG9ydCBLeWNBY2NvdW50QWdyZWVtZW50SHRtbCBmcm9tIFwiLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljQWNjb3VudEFncmVlbWVudC5odG1sXCI7XHJcbmltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgS1lDU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9LWUNTZXJ2aWNlXCI7XHJcbmltcG9ydCBLeWNWYWxpZGF0b3JFcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBGb3JtSGVscGVyIGZyb20gXCIuLi8uLi8uLi91dGlsL0Zvcm1IZWxwZXJcIjtcclxuaW1wb3J0IEV4ZWN1dGVUcmFkZUJ1dHRvbiBmcm9tIFwiLi4vLi4vZWxlbWVudHMvdHJhZGVwYW5lbC9FeGVjdXRlVHJhZGVCdXR0b25cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y0FjY291bnRBZ3JlZW1lbnQgZXh0ZW5kcyBLeWNCYXNlIHtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3Ioa3ljRm9ybTogS1lDRm9ybSkge1xyXG4gICAgICAgIHN1cGVyKGt5Y0Zvcm0pXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcihlZGl0ID0gZmFsc2UpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljQWNjb3VudEFncmVlbWVudEh0bWwpO1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZSh7ZWRpdDogZWRpdH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIHRoaXMuc2hvd0ZpZWxkc2V0KCcua3ljQWNjb3VudEFncmVlbWVudCcsICdBZ3JlZW1lbnRzJyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmt5Y0Zvcm0uc3RlcHMgPT0gNSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWNjb3VudF9hZ3JlZW1lbnRfcHJldicpIS5pbm5lclRleHQgPSAnUHJldmlvdXM6IERpc2Nsb3N1cmUnO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY2NvdW50X2FncmVlbWVudF9wcmV2JykhLmlubmVyVGV4dCA9ICdQcmV2aW91czogVXBsb2FkIGRvY3VtZW50cyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmt5Y0Zvcm0ua3ljQ29udGFjdC51c1RheFJlc2lkZW5jZSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndzhkaXNjbG9zdXJlX2RpdicpPy5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3OGRpc2Nsb3N1cmVfZGl2Jyk/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG5cclxuICAgICAgICBsZXQgYWNjb3VudF9hZ3JlZW1lbnRfcHJldiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY2NvdW50X2FncmVlbWVudF9wcmV2JylcclxuICAgICAgICBhY2NvdW50X2FncmVlbWVudF9wcmV2Py5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMua3ljRm9ybS5zdGVwcyA9PSA1KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljRGlzY2xvc3VyZXMuc2hvdygpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y1VwbG9hZC5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICB0aGlzLmJpbmRTdWJtaXRLeWMoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGJpbmRTdWJtaXRLeWMoZWRpdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IHN1Ym1pdEtZQyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdWJtaXRLWUMnKTtcclxuICAgICAgICBpZiAoIXN1Ym1pdEtZQykgcmV0dXJuO1xyXG5cclxuICAgICAgICBzdWJtaXRLWUMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlZGl0ICYmICF0aGlzLnZhbGlkYXRlKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGxldCBhY2NvdW50X2FncmVlbWVudF9wcmV2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjY291bnRfYWdyZWVtZW50X3ByZXYnKTtcclxuICAgICAgICAgICAgLy9pZiAoYWNjb3VudF9hZ3JlZW1lbnRfcHJldikgYWNjb3VudF9hZ3JlZW1lbnRfcHJldi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBsaW1pbmFsX21hcmtldF9tb2RhbF9jbG9zZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsaW1pbmFsX21hcmtldF9tb2RhbF9jbG9zZScpO1xyXG4gICAgICAgICAgICAvLyBpZiAobGltaW5hbF9tYXJrZXRfbW9kYWxfY2xvc2UpIGxpbWluYWxfbWFya2V0X21vZGFsX2Nsb3NlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcblxyXG4gICAgICAgICAgICBsZXQgc3VibWl0QnRuID0gKGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcoc3VibWl0QnRuKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBwYXJhbXMgPSBGb3JtSGVscGVyLmdldFBhcmFtcygnI2t5Y193aXphcmRfZm9ybScpO1xyXG5cclxuICAgICAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgcGFyYW1zLmNoYWluSWQgPSBuZXR3b3JrSW5mby5DaGFpbklkO1xyXG5cclxuICAgICAgICAgICAgbGV0IGt5Y1NlcnZpY2UgPSBuZXcgS1lDU2VydmljZShNb3JhbGlzKTtcclxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGt5Y1NlcnZpY2Uuc2F2ZUtZQ0luZm8ocGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKChyZWFzb246IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NvdW50X2FncmVlbWVudF9wcmV2KSBhY2NvdW50X2FncmVlbWVudF9wcmV2LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIExvYWRpbmdIZWxwZXIucmVtb3ZlTG9hZGluZygpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVhc29uLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGt5Y0Vycm9yID0gbmV3IEt5Y1ZhbGlkYXRvckVycm9yKHJlYXNvbi5tZXNzYWdlLCB0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBreWNFcnJvci5oYW5kbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5reWNGb3JtLmt5Y1dhaXRpbmcuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgRXhlY3V0ZVRyYWRlQnV0dG9uLkluc3RhbmNlLnJlbmRlckJ1dHRvbigpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjY291bnRfYWdyZWVtZW50X3ByZXYpIGFjY291bnRfYWdyZWVtZW50X3ByZXYuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICBMb2FkaW5nSGVscGVyLnJlbW92ZUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgbGV0IGFjY291bnRfYWdyZWVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjY291bnRfYWdyZWVtZW50JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoIWFjY291bnRfYWdyZWVtZW50Py5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ2FjY291bnRfYWdyZWVtZW50X2Vycm9yJywgJ1lvdSBuZWVkIHRvIGFncmVlIHRvIGFncmVlbWVudHMnLCAnYWNjb3VudF9hZ3JlZW1lbnQnKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVNaXNzaW5nSW5mbygnYWNjb3VudF9hZ3JlZW1lbnRfZXJyb3InLCAnYWNjb3VudF9hZ3JlZW1lbnQnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjdXN0b21lcl9hZ3JlZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VzdG9tZXJfYWdyZWVtZW50JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoIWN1c3RvbWVyX2FncmVlbWVudD8uY2hlY2tlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldE1pc3NpbmdJbmZvKCdjdXN0b21lcl9hZ3JlZW1lbnRfZXJyb3InLCAnWW91IG5lZWQgdG8gYWdyZWUgdG8gY3VzdG9tZXIgYWdyZW1lbnQnLCAnY3VzdG9tZXJfYWdyZWVtZW50JylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTWlzc2luZ0luZm8oJ2N1c3RvbWVyX2FncmVlbWVudF9lcnJvcicsICdjdXN0b21lcl9hZ3JlZW1lbnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRpZ2l0YWxfc2lnbmF0dXJlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpZ2l0YWxfc2lnbmF0dXJlJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoIWRpZ2l0YWxfc2lnbmF0dXJlPy5jaGVja2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ2RpZ2l0YWxfc2lnbmF0dXJlX2Vycm9yJywgJ1lvdSBuZWVkIHRvIHNpZ24nLCAnZGlnaXRhbF9zaWduYXR1cmUnKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVNaXNzaW5nSW5mbygnZGlnaXRhbF9zaWduYXR1cmVfZXJyb3InLCAnZGlnaXRhbF9zaWduYXR1cmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgfVxyXG5cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxmaWVsZHNldCBjbGFzcz1cXFwia3ljVHJ1c3RlZENvbnRhY3QgaGlkZGVuXFxcIiBkYXRhLWZvcm09XFxcIjFcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJleHBsYWluXFxcIj5cXHJcXG4gICAgICAgIEEgdHJ1c3RlZCBjb250YWN0IGlzIGEgcGVyc29uIHlvdSBhdXRob3JpemUgeW91ciBmaW5hbmNpYWwgZmlybSB0byBjb250YWN0IGluIGxpbWl0ZWQgY2lyY3Vtc3RhbmNlcyxcXHJcXG4gICAgICAgIHN1Y2ggYXMgaWYgdGhlcmUgaXMgYSBjb25jZXJuIGFib3V0IGFjdGl2aXR5IGluIHlvdXIgYWNjb3VudCBhbmQgdGhleSBoYXZlIGJlZW4gdW5hYmxlIHRvIGdldCBpbiB0b3VjaCB3aXRoIHlvdS5cXHJcXG4gICAgICAgIDxici8+PGJyLz5cXHJcXG4gICAgICAgIEEgdHJ1c3RlZCBjb250YWN0IG1heSBiZSBhIGZhbWlseSBtZW1iZXIsIGF0dG9ybmV5LCBhY2NvdW50YW50IG9yIGFub3RoZXIgdGhpcmQtcGFydHkgd2hvIHlvdSBiZWxpZXZlIHdvdWxkXFxyXFxuICAgICAgICByZXNwZWN0IHlvdXIgcHJpdmFjeSBhbmQga25vdyBob3cgdG8gaGFuZGxlIHRoZSByZXNwb25zaWJpbGl0eS5cXHJcXG4gICAgICAgIFRoZSB0cnVzdGVkIHBlcnNvbiBzaG91bGQgYmUgMTggeWVhcnMgb2xkIG9yIG9sZGVyLlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRydXN0ZWRfZmlyc3RfbmFtZVxcXCI+TGVnYWwgZmlyc3QgbmFtZSBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0cnVzdGVkX2ZpcnN0X25hbWVcXFwiIG5hbWU9XFxcInRydXN0ZWRfZmlyc3RfbmFtZVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRydXN0ZWRfbGFzdF9uYW1lXFxcIj5MZWdhbCBsYXN0IG5hbWUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidHJ1c3RlZF9sYXN0X25hbWVcXFwiIG5hbWU9XFxcInRydXN0ZWRfbGFzdF9uYW1lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgSWYgeW91IGZpbGwgaW4gbmFtZSwgeW91IGFyZSByZXF1aXJlZCB0byBmaWxsIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nLCBlbWFpbCwgcGhvbmUgb3IgYWRkcmVzc1xcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiaW5wdXRfZXJyb3JcXFwiIGlkPVxcXCJ0cnVzdGVkX2NvbnRhY3RfbWlzc2luZ19pbmZvXFxcIj48L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRydXN0ZWRfZW1haWxcXFwiPkVtYWlsIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcInRydXN0ZWRfZW1haWxcXFwiIHR5cGU9XFxcImVtYWlsXFxcIiBuYW1lPVxcXCJ0cnVzdGVkX2VtYWlsXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9waG9uZVxcXCI+UGhvbmUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidHJ1c3RlZF9waG9uZVxcXCIgdHlwZT1cXFwidGVsXFxcIiBuYW1lPVxcXCJ0cnVzdGVkX3Bob25lXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9zdHJlZXRfYWRkcmVzc1xcXCI+QWRkcmVzcyBvZiB0cnVzdGVkIGNvbnRhY3Q8L2xhYmVsPlxcclxcbiAgICAgICAgPGlucHV0IGlkPVxcXCJ0cnVzdGVkX3N0cmVldF9hZGRyZXNzXFxcIiBuYW1lPVxcXCJ0cnVzdGVkX3N0cmVldF9hZGRyZXNzXFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9jaXR5XFxcIj5DaXR5IG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcInRydXN0ZWRfY2l0eVxcXCIgbmFtZT1cXFwidHJ1c3RlZF9jaXR5XFxcIi8+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8ZGl2PlxcclxcbiAgICAgICAgPGxhYmVsIGZvcj1cXFwidHJ1c3RlZF9zdGF0ZVxcXCI+U3RhdGUgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxpbnB1dCBpZD1cXFwidHJ1c3RlZF9zdGF0ZVxcXCIgbmFtZT1cXFwidHJ1c3RlZF9zdGF0ZVxcXCIvPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdj5cXHJcXG4gICAgICAgIDxsYWJlbCBmb3I9XFxcInRydXN0ZWRfcG9zdGFsX2NvZGVcXFwiPlBvc3RhbCBjb2RlIG9mIHRydXN0ZWQgY29udGFjdDwvbGFiZWw+XFxyXFxuICAgICAgICA8aW5wdXQgaWQ9XFxcInRydXN0ZWRfcG9zdGFsX2NvZGVcXFwiIG5hbWU9XFxcInRydXN0ZWRfcG9zdGFsX2NvZGVcXFwiLz5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIDxkaXY+XFxyXFxuICAgICAgICA8bGFiZWwgZm9yPVxcXCJ0cnVzdGVkX2NvdW50cnlcXFwiPkNvdW50cnkgb2YgdHJ1c3RlZCBjb250YWN0PC9sYWJlbD5cXHJcXG4gICAgICAgIDxzZWxlY3QgcmVxdWlyZWQgaWQ9XFxcInRydXN0ZWRfY291bnRyeVxcXCIgcmVxdWlyZWQgbmFtZT1cXFwidHJ1c3RlZF9jb3VudHJ5XFxcIj5cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJcXFwiPjwvb3B0aW9uPlxcclxcbiAgICAgICAgICAgIHt7I2VhY2ggY291bnRyaWVzfX1cXHJcXG4gICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVxcXCJ7e2NvZGV9fVxcXCI+e3tuYW1lfX08L29wdGlvbj5cXHJcXG4gICAgICAgICAgICB7ey9lYWNofX1cXHJcXG4gICAgICAgIDwvc2VsZWN0PlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAge3sjdW5sZXNzIGVkaXR9fVxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJ0cnVzdGVkQ29udGFjdF9wcmV2XFxcIj5QcmV2aW91czogSWRlbnRpdHk8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBpZD1cXFwidHJ1c3RlZENvbnRhY3RfbmV4dFxcXCI+TmV4dDogRGlzY2xvc3VyZXM8L2J1dHRvbj5cXHJcXG4gICAgPC9kaXY+XFxyXFxuICAgIHt7L3VubGVzc319XFxyXFxuICAgIHt7I2lmIGVkaXR9fVxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJ0cnVzdGVkQ29udGFjdF9wcmV2XFxcIj5QcmV2aW91czogSWRlbnRpdHk8L2J1dHRvbj5cXHJcXG4gICAgICAgIDxidXR0b24gdHlwZT1cXFwic3VibWl0XFxcIiBpZD1cXFwic3VibWl0S1lDXFxcIj5VcGRhdGUgYWNjb3VudDwvYnV0dG9uPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiYWxlcnQgYWxlcnQtZGFuZ2VyXFxcIiBpZD1cXFwia3ljRXJyb3JcXFwiIHJvbGU9XFxcImFsZXJ0XFxcIj48L2Rpdj5cXHJcXG4gICAge3svaWZ9fVxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEtZQ0Zvcm0gZnJvbSBcIi4uL0tZQ0Zvcm1cIjtcclxuaW1wb3J0IEt5Y1RydXN0ZWRDb250YWN0SHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL21vZGFsL0t5Yy9LeWNUcnVzdGVkQ29udGFjdC5odG1sJztcclxuaW1wb3J0IFN0cmluZ0hlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9TdHJpbmdIZWxwZXJcIjtcclxuaW1wb3J0IENvdW50cnlIZWxwZXIgZnJvbSBcIi4uLy4uLy4uL3V0aWwvQ291bnRyeUhlbHBlclwiO1xyXG5cclxuaW1wb3J0IEt5Y0FjY291bnRBZ3JlZW1lbnQgZnJvbSBcIi4vS3ljQWNjb3VudEFncmVlbWVudFwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y1RydXN0ZWRDb250YWN0IGV4dGVuZHMgS3ljQmFzZSB7XHJcbiAgICBlZGl0ID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa3ljRm9ybTogS1lDRm9ybSkge1xyXG4gICAgICAgIHN1cGVyKGt5Y0Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW5kZXIoZWRpdCA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5lZGl0ID0gZWRpdDtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEt5Y1RydXN0ZWRDb250YWN0SHRtbCk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHtlZGl0OiBlZGl0LCBjb3VudHJpZXM6IENvdW50cnlIZWxwZXIuQ291bnRyaWVzfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coKSB7XHJcbiAgICAgICAgdGhpcy5zaG93RmllbGRzZXQoJy5reWNUcnVzdGVkQ29udGFjdCcsICdUcnVzdGVkIGNvbnRhY3QnKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKCkge1xyXG4gICAgICAgIGxldCBzaG93UHJldiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkQ29udGFjdF9wcmV2Jyk7XHJcbiAgICAgICAgc2hvd1ByZXY/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljSWRlbnRpdHkuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGxldCBzaG93TmV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkQ29udGFjdF9uZXh0Jyk7XHJcbiAgICAgICAgc2hvd05leHQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUoKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ua3ljRGlzY2xvc3VyZXMuc2hvdygpO1xyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmVkaXQpIHtcclxuICAgICAgICAgICAgbGV0IGt5Y0FjY291bnQgPSBuZXcgS3ljQWNjb3VudEFncmVlbWVudCh0aGlzLmt5Y0Zvcm0pO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGUoKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAga3ljQWNjb3VudC5iaW5kU3VibWl0S3ljKHRoaXMuZWRpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdmFsaWRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRNaXNzaW5nSW5mbygndHJ1c3RlZF9jb250YWN0X21pc3NpbmdfaW5mbycsICcnKTtcclxuXHJcbiAgICAgICAgbGV0IHRydXN0ZWRfZmlyc3RfbmFtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkX2ZpcnN0X25hbWUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICh0cnVzdGVkX2ZpcnN0X25hbWUgJiYgIVN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfZmlyc3RfbmFtZS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgbGV0IHRydXN0ZWRfZW1haWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJ1c3RlZF9lbWFpbCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGxldCB0cnVzdGVkX3Bob25lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RydXN0ZWRfcGhvbmUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgdHJ1c3RlZF9zdHJlZXRfYWRkcmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkX3N0cmVldF9hZGRyZXNzJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IHRydXN0ZWRfY2l0eSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkX2NpdHknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgdHJ1c3RlZF9wb3N0YWxfY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkX3Bvc3RhbF9jb2RlJykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICAgICAgbGV0IHRydXN0ZWRfY291bnRyeSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cnVzdGVkX2NvdW50cnknKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICAgICAgaWYgKFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfZW1haWwudmFsdWUpICYmIFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfcGhvbmUudmFsdWUpXHJcbiAgICAgICAgICAgICAgICAmJiBTdHJpbmdIZWxwZXIuaXNOdWxsT3JFbXB0eSh0cnVzdGVkX3N0cmVldF9hZGRyZXNzLnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRNaXNzaW5nSW5mbygndHJ1c3RlZF9jb250YWN0X21pc3NpbmdfaW5mbycsICdZb3UgbmVlZCB0byBmaWxsIGluIGVpdGhlciBlbWFpbCwgcGhvbmUgb3IgYWRkcmVzcycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIVN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfZW1haWwudmFsdWUpICYmIHRydXN0ZWRfZW1haWwudmFsdWUuaW5kZXhPZignQCcpID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1pc3NpbmdJbmZvKCd0cnVzdGVkX2NvbnRhY3RfbWlzc2luZ19pbmZvJywgJ0VtYWlsIGlzIG5vdCB2YWxpZC4gSXQgbXVzdCBjb250YWluIEAgc2lnbicpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIVN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfc3RyZWV0X2FkZHJlc3MudmFsdWUpICYmXHJcbiAgICAgICAgICAgICAgICAoXHJcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9jaXR5LnZhbHVlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIFN0cmluZ0hlbHBlci5pc051bGxPckVtcHR5KHRydXN0ZWRfcG9zdGFsX2NvZGUudmFsdWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nSGVscGVyLmlzTnVsbE9yRW1wdHkodHJ1c3RlZF9jb3VudHJ5LnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWlzc2luZ0luZm8oJ3RydXN0ZWRfY29udGFjdF9taXNzaW5nX2luZm8nLCAnWW91IG5lZWQgZmlsbCBpbm4gaW50byBDaXR5LCBQb3N0YWwgY29kZSBhbmQgQ291bnRyeSB3aGVuIGZpbGxpbmcgdGhlIHN0cmVldCBhZGRyZXNzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGZpZWxkc2V0IGNsYXNzPVxcXCJreWNVcGxvYWQgaGlkZGVuXFxcIiBkYXRhLWZvcm09XFxcIjFcXFwiPlxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgIHt7e2ZpbGVVcGxvYWQgXFxcImlkZW50aXR5X3ZlcmlmaWNhdGlvblxcXCIgXFxcIlBob3RvIElEIEZyb250IChGcm9udCBvZiBwYXNzcG9ydClcXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkXFxcIj5cXHJcXG4gICAgICAgIHt7e2ZpbGVVcGxvYWQgXFxcImlkZW50aXR5X3ZlcmlmaWNhdGlvbl8yXFxcIiBcXFwiUGhvdG8gSUQgQmFjayAoUGFzc3BvcnQgcGljdHVyZSBvZiBJRCkgXFxcIn19fVxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZFxcXCI+XFxyXFxuICAgICAgICB7e3tmaWxlVXBsb2FkIFxcXCJhZGRyZXNzX3ZlcmlmaWNhdGlvblxcXCIgXFxcIlBpY3R1cmUgb2YgYWRkcmVzcyB2ZXJpZmljYXRpb25cXFwifX19XFxyXFxuICAgIDwvZGl2PlxcclxcblxcclxcbiAgICA8ZGl2IGNsYXNzPVxcXCJncmlkIGJ1dHRvbnNcXFwiPlxcclxcbiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJ1cGxvYWRfcHJldlxcXCI+UHJldmlvdXM6IERpc2Nsb3N1cmVzPC9idXR0b24+XFxyXFxuICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgaWQ9XFxcInVwbG9hZF9uZXh0XFxcIj5OZXh0OiBBZ3JlZW1lbnRzPC9idXR0b24+XFxyXFxuICAgIDwvZGl2PlxcclxcbjwvZmllbGRzZXQ+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBLeWNCYXNlIGZyb20gXCIuL0t5Y0Jhc2VcIjtcclxuaW1wb3J0IEt5Y1VwbG9hZEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9tb2RhbC9LeWMvS3ljVXBsb2FkLmh0bWwnO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y1VwbG9hZCBleHRlbmRzIEt5Y0Jhc2Uge1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3RvcihreWNGb3JtOiBLWUNGb3JtKSB7XHJcbiAgICAgICAgc3VwZXIoa3ljRm9ybSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcigpIHtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljVXBsb2FkSHRtbCk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlKHt9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvdygpIHtcclxuICAgICAgICB0aGlzLnNob3dGaWVsZHNldCgnLmt5Y1VwbG9hZCcsICdVcGxvYWQgZG9jdW1lbnRzJylcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYmluZEV2ZW50cygpIHtcclxuICAgICAgICB0aGlzLmJpbmRGaWxlVXBsb2FkcygpO1xyXG5cclxuICAgICAgICBsZXQgdXBsb2FkX3ByZXYgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXBsb2FkX3ByZXYnKTtcclxuICAgICAgICB1cGxvYWRfcHJldj8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNEaXNjbG9zdXJlcy5zaG93KCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICBsZXQgdXBsb2FkX25leHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXBsb2FkX25leHQnKTtcclxuICAgICAgICB1cGxvYWRfbmV4dD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVJlcXVpcmVkRmllbGRzKCcua3ljVXBsb2FkJykpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMua3ljRm9ybS5reWNBY2NvdW50QWdyZWVtZW50LnNob3coKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IEt5Y0Jhc2UgZnJvbSBcIi4vS3ljQmFzZVwiO1xyXG5pbXBvcnQgS1lDRm9ybSBmcm9tIFwiLi4vS1lDRm9ybVwiO1xyXG5pbXBvcnQgS1lDU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9LWUNTZXJ2aWNlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLeWNXYWl0aW5nIGV4dGVuZHMgS3ljQmFzZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3Ioa3ljRm9ybTogS1lDRm9ybSkge1xyXG4gICAgICAgIHN1cGVyKGt5Y0Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzaG93KCkge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdreWNfcmVnJyk/LmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpXHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRpbmdfZm9yX2t5Y19yZWcnKT8uY2xhc3NMaXN0LnJlbW92ZSgnaGlkZGVuJyk7XHJcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpbWluYWxfbWFya2V0X21vZGFsX2RpdiA+IGFydGljbGUgPiBoZWFkZXIgPiBzcGFuJykhLmlubmVySFRNTCA9ICdXYWl0aW5nIGZvciBLWUMgdG8gYmUgYXBwcm92ZWQnXHJcbiAgICAgICAgdGhpcy5reWNGb3JtLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jaGVja0t5Y1N0YXR1cygpXHJcbiAgICAgICAgfSwgNSAqIDEwMDApXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGNoZWNrS3ljU3RhdHVzKCkge1xyXG4gICAgICAgIGxldCBreWNTZXJ2aWNlID0gbmV3IEtZQ1NlcnZpY2UoTW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGt5Y1Jlc3BvbnNlID0gYXdhaXQga3ljU2VydmljZS5oYXNWYWxpZEtZQygpXHJcblxyXG4gICAgICAgIGlmIChreWNSZXNwb25zZS5pc1ZhbGlkS3ljIHx8IGt5Y1Jlc3BvbnNlLnN0YXR1cyA9PSBcIkFDVElPTl9SRVFVSVJFRFwiKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmt5Y0Zvcm0udGltZW91dCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmt5Y0Zvcm0ubW9kYWwuaGlkZU1vZGFsKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5reWNGb3JtLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tLeWNTdGF0dXMoKVxyXG4gICAgICAgICAgICB9LCA1ICogMTAwMClcclxuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBLWUNGb3JtSHRtbCBmcm9tICcuLi8uLi9odG1sL21vZGFsL0tZQ01vZGFsLmh0bWwnO1xyXG5pbXBvcnQgTW9kYWwgZnJvbSBcIi4vTW9kYWxcIjtcclxuaW1wb3J0IEt5Y0NvbnRhY3QgZnJvbSBcIi4vS1lDL0t5Y0NvbnRhY3RcIjtcclxuaW1wb3J0IEt5Y0lkZW50aXR5IGZyb20gXCIuL0tZQy9LeWNJZGVudGl0eVwiO1xyXG5pbXBvcnQgS3ljRGlzY2xvc3VyZXMgZnJvbSBcIi4vS1lDL0t5Y0Rpc2Nsb3N1cmVzXCI7XHJcbmltcG9ydCBLeWNBY2NvdW50QWdyZWVtZW50IGZyb20gXCIuL0tZQy9LeWNBY2NvdW50QWdyZWVtZW50XCI7XHJcbmltcG9ydCBLeWNUcnVzdGVkQ29udGFjdCBmcm9tIFwiLi9LWUMvS3ljVHJ1c3RlZENvbnRhY3RcIjtcclxuaW1wb3J0IEt5Y1VwbG9hZCBmcm9tIFwiLi9LWUMvS3ljVXBsb2FkXCI7XHJcbmltcG9ydCBLeWNXYWl0aW5nIGZyb20gXCIuL0tZQy9LeWNXYWl0aW5nXCI7XHJcbmltcG9ydCBFeGVjdXRlVHJhZGVCdXR0b24gZnJvbSBcIi4uL2VsZW1lbnRzL3RyYWRlcGFuZWwvRXhlY3V0ZVRyYWRlQnV0dG9uXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtZQ0Zvcm0ge1xyXG4gICAgc3RlcHMgPSA1O1xyXG4gICAgbW9kYWw6IE1vZGFsO1xyXG4gICAgdGltZW91dD86IGFueSA9IHVuZGVmaW5lZDtcclxuICAgIG9uSGlkZTogKCkgPT4gdm9pZDtcclxuICAgIGFjdGl2ZUZpZWxkc2V0U2VsZWN0b3IgPSAnLmt5Y0NvbnRhY3QnO1xyXG5cclxuICAgIGt5Y0NvbnRhY3Q6IEt5Y0NvbnRhY3Q7XHJcbiAgICBreWNJZGVudGl0eTogS3ljSWRlbnRpdHk7XHJcbiAgICBreWNEaXNjbG9zdXJlczogS3ljRGlzY2xvc3VyZXNcclxuICAgIGt5Y0FjY291bnRBZ3JlZW1lbnQ6IEt5Y0FjY291bnRBZ3JlZW1lbnQ7XHJcbiAgICBreWNUcnVzdGVkQ29udGFjdDogS3ljVHJ1c3RlZENvbnRhY3Q7XHJcbiAgICBreWNVcGxvYWQ6IEt5Y1VwbG9hZDtcclxuICAgIGt5Y1dhaXRpbmc6IEt5Y1dhaXRpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob25IaWRlOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgIHRoaXMub25IaWRlID0gb25IaWRlO1xyXG5cclxuICAgICAgICB0aGlzLmt5Y0NvbnRhY3QgPSBuZXcgS3ljQ29udGFjdCh0aGlzKTtcclxuICAgICAgICB0aGlzLmt5Y0lkZW50aXR5ID0gbmV3IEt5Y0lkZW50aXR5KHRoaXMpO1xyXG4gICAgICAgIHRoaXMua3ljVHJ1c3RlZENvbnRhY3QgPSBuZXcgS3ljVHJ1c3RlZENvbnRhY3QodGhpcyk7XHJcbiAgICAgICAgdGhpcy5reWNEaXNjbG9zdXJlcyA9IG5ldyBLeWNEaXNjbG9zdXJlcyh0aGlzKTtcclxuICAgICAgICB0aGlzLmt5Y0FjY291bnRBZ3JlZW1lbnQgPSBuZXcgS3ljQWNjb3VudEFncmVlbWVudCh0aGlzKTtcclxuICAgICAgICB0aGlzLmt5Y1VwbG9hZCA9IG5ldyBLeWNVcGxvYWQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5reWNXYWl0aW5nID0gbmV3IEt5Y1dhaXRpbmcodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coY2xhc3NOYW1lOiBzdHJpbmcpIHtcclxuXHJcbiAgICAgICAgbGV0IGt5Y0Zvcm0gPSBuZXcgS1lDRm9ybSgoKSA9PiB7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdHlwZSBPYmplY3RLZXkgPSBrZXlvZiB0eXBlb2Yga3ljRm9ybTtcclxuICAgICAgICBjb25zdCBibGUgPSBjbGFzc05hbWUgYXMgT2JqZWN0S2V5O1xyXG4gICAgICAgICh0aGlzW2JsZV0gYXMgYW55KS5zaG93KCk7XHJcblxyXG4gICAgICAgIHRoaXMuYWN0aXZlRmllbGRzZXRTZWxlY3RvciA9IGNsYXNzTmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvd0tZQ0Zvcm0oZWRpdCA9IGZhbHNlKSB7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShLWUNGb3JtSHRtbCk7XHJcbiAgICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICAgICAgS3ljQ29udGFjdEh0bWw6IHRoaXMua3ljQ29udGFjdC5yZW5kZXIoKSxcclxuICAgICAgICAgICAgS3ljSWRlbnRpdHlIdG1sOiB0aGlzLmt5Y0lkZW50aXR5LnJlbmRlcigpLFxyXG4gICAgICAgICAgICBLeWNEaXNjbG9zdXJlSHRtbDogdGhpcy5reWNEaXNjbG9zdXJlcy5yZW5kZXIoKSxcclxuICAgICAgICAgICAgS3ljVHJ1c3RlZENvbnRhY3RIdG1sOiB0aGlzLmt5Y1RydXN0ZWRDb250YWN0LnJlbmRlcigpLFxyXG4gICAgICAgICAgICBLeWNBY2NvdW50QWdyZWVtZW50SHRtbDogdGhpcy5reWNBY2NvdW50QWdyZWVtZW50LnJlbmRlcigpLFxyXG4gICAgICAgICAgICBLeWNVcGxvYWRIdG1sOiB0aGlzLmt5Y1VwbG9hZC5yZW5kZXIoKVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKG9iaik7XHJcbiAgICAgICAgbGV0IG5ld01vZGFsID0gdGhpcy5tb2RhbC5zaG93TW9kYWwoJ0tZQyAmIEFNTCcsIGNvbnRlbnQsIHRydWUsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgdGhpcy5vbkhpZGUoKTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGxldCB0YXhSZXNpZGVuY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY291bnRyeV9vZl90YXhfcmVzaWRlbmNlJykgYXMgSFRNTFNlbGVjdEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHRheFJlc2lkZW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0ZXBzID0gKHRheFJlc2lkZW5jZS52YWx1ZSA9PSAnVVNBJykgPyA1IDogNjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdNb2RhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmt5Y0NvbnRhY3QuYmluZEV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLmt5Y0lkZW50aXR5LmJpbmRFdmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5reWNUcnVzdGVkQ29udGFjdC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljRGlzY2xvc3VyZXMuYmluZEV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLmt5Y1VwbG9hZC5iaW5kRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMua3ljQWNjb3VudEFncmVlbWVudC5iaW5kRXZlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljX3dpemFyZF9mb3JtJykhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2dC5rZXkgPT0gJ0VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5reWNDb250YWN0LnNob3coKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0U3RlcHMoc3RlcHM6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc3RlcHMgPSBzdGVwcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYXJUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCBLeWNTdGF0dXMgZnJvbSBcIi4uLy4uLy4uL2R0by9LeWNTdGF0dXNcIjtcclxuaW1wb3J0IEt5Y0FjdGlvblJlcXVpcmVkIGZyb20gXCIuL0t5Y0FjdGlvblJlcXVpcmVkXCI7XHJcbmltcG9ydCBFeGVjdXRlVHJhZGVCdXR0b24gZnJvbSBcIi4uLy4uL2VsZW1lbnRzL3RyYWRlcGFuZWwvRXhlY3V0ZVRyYWRlQnV0dG9uXCI7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vTW9kYWxcIjtcclxuaW1wb3J0IEtZQ0Zvcm0gZnJvbSBcIi4uL0tZQ0Zvcm1cIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEt5Y1N0YXR1c0hhbmRsZXIge1xyXG5cclxuICAgIC8qXHJcbiAgICBTVUJNSVRURURcdC9maXh0dXJlcy9zdGF0dXM9U1VCTUlUVEVEL2ZpeHR1cmVzL1xyXG5BQ1RJT05fUkVRVUlSRURcdC9maXh0dXJlcy9zdGF0dXM9QUNUSU9OX1JFUVVJUkVEL2ZpeHR1cmVzL1xyXG5BUFBST1ZBTF9QRU5ESU5HXHQvZml4dHVyZXMvc3RhdHVzPUFQUFJPVkFMX1BFTkRJTkcvZml4dHVyZXMvXHJcbkFQUFJPVkVEXHQvZml4dHVyZXMvc3RhdHVzPUFQUFJPVkVEL2ZpeHR1cmVzL1xyXG5SRUpFQ1RFRFx0L2ZpeHR1cmVzL3N0YXR1cz1SRUpFQ1RFRC9maXh0dXJlcy9cclxuQUNUSVZFXHQvZml4dHVyZXMvc3RhdHVzPUFDVElWRS9maXh0dXJlcy9cclxuRElTQUJMRURcdC9maXh0dXJlcy9zdGF0dXM9RElTQUJMRUQvZml4dHVyZXMvXHJcbkFDQ09VTlRfQ0xPU0VEXHQvZml4dHVyZXMvc3RhdHVzPUFDQ09VTlRfQ0xPU0VEL2ZpeHR1cmVzL1xyXG4gICAgICovXHJcblxyXG4gICAga3ljUmVzcG9uc2U6IEt5Y1N0YXR1cztcclxuICAgIGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZVRyYWRlQnV0dG9uO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGt5Y1Jlc3BvbnNlOiBLeWNTdGF0dXMsIGV4ZWN1dGVUcmFkZUJ1dHRvbjogRXhlY3V0ZVRyYWRlQnV0dG9uKSB7XHJcbiAgICAgICAgdGhpcy5reWNSZXNwb25zZSA9IGt5Y1Jlc3BvbnNlO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZVRyYWRlQnV0dG9uID0gZXhlY3V0ZVRyYWRlQnV0dG9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRCdXR0b25UZXh0KCkge1xyXG4gICAgICAgIGxldCB0eHQgPSAnRmluaXNoIEtZQyc7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmt5Y1Jlc3BvbnNlLnN0YXR1cykge1xyXG4gICAgICAgICAgICBjYXNlICdTVUJNSVRURUQnOlxyXG4gICAgICAgICAgICBjYXNlICdPTkJPQVJESU5HJzpcclxuICAgICAgICAgICAgY2FzZSAnSU5BQ1RJVkUnOlxyXG4gICAgICAgICAgICBjYXNlICdBUFBST1ZFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0VESVRFRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0FQUFJPVkFMX1BFTkRJTkcnOlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gJ1N1Ym1pdHRlZCB0byBLWUMgcHJvY2Vzc29yJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdBQ1RJT05fUkVRVUlSRUQnOlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gJ0FjdGlvbiByZXF1aXJlZC4gQ2xpY2sgdG8gY29udGludWUnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ1JFSkVDVEVEJzpcclxuICAgICAgICAgICAgICAgIHR4dCA9ICdZb3VyIGFwcGxpY2F0aW9uIHdhcyByZWplY3RlZCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnRElTQUJMRUQnOlxyXG4gICAgICAgICAgICAgICAgdHh0ID0gJ1lvdXIgYWNjb3VudCBoYXMgYmVlbiBkaXNhYmxlZCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnQUNUSVZFJzpcclxuICAgICAgICAgICAgY2FzZSAnQUNDT1VOVF9VUERBVEVEJzpcclxuICAgICAgICAgICAgICAgIHR4dCA9ICdZb3UgYXJlIGFwcHJvdmVkLiBLWUMgaXMgYmVpbmcgc2VudCB0byBibG9ja2NoYWluLiBHaXZlIGl0IGZldyBtaW51dGVzJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdBQ0NPVU5UX0NMT1NFRCc6XHJcbiAgICAgICAgICAgICAgICB0eHQgPSAnWW91ciBhY2NvdW50IGhhcyBiZWVuIGNsb3NlZCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR4dCArICc8c21hbGw+Q2xpY2sgZm9yIG1vcmUgaW5mbzwvc21hbGw+JztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QnV0dG9uQ2xpY2tFdmVudChleGVjdXRlVHJhZGVCdXR0b246IEV4ZWN1dGVUcmFkZUJ1dHRvbikge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5reWNSZXNwb25zZS5zdGF0dXMpIHtcclxuICAgICAgICAgICAgY2FzZSAnU1VCTUlUVEVEJzpcclxuICAgICAgICAgICAgY2FzZSAnT05CT0FSRElORyc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0lOQUNUSVZFJzpcclxuICAgICAgICAgICAgY2FzZSAnQVBQUk9WRUQnOlxyXG4gICAgICAgICAgICBjYXNlICdFRElURUQnOlxyXG4gICAgICAgICAgICBjYXNlICdBUFBST1ZBTF9QRU5ESU5HJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dNb2RhbCgnQXBwbGljYXRpb24gaXMgYmVpbmcgcHJvY2Vzc2VkJyxcclxuICAgICAgICAgICAgICAgICAgICBcIllvdSBuZWVkIHRvIHdhaXQgZm9yIEtZQyB0byBiZSBhcHByb3ZlZC4gVGhlbiB5b3UnbGwgYmUgYWJsZSB0byBkbyB0cmFkZXMuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgdXN1YWxseSB0YWtlcyBmZXcgbWludXRlcyBmb3IgdGhlIGZpcnN0IHN1Ym1pc3Npb24sIGJ1dCBjYW4gdGFrZSBsb25nZXIgZm9yIHNlY29uZCBzdWJtaXNzaW9uLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJXZSB3aWxsIGVtYWlsIHlvdSB3aGVuIHlvdSBhcmUgYXBwcm92ZWQgb3IgaWYgdGhlcmUgYXJlIHByb2JsZW1zPGJyIC8+PGJyIC8+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiSWYgdGhpcyBzdGF0dXMgaGFzIGJlZW4gZm9yIG1vcmUgdGhhbiAxIGRheSwgYW5kIHlvdSBoYXZlbid0IGdvdHRlbiBhbnkgZW1haWwgZnJvbSB1cy4gUGxlYXNlIGVtYWlsIHVzIGF0IFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxhIHRhcmdldD0nX2JsYW5rJyBocmVmPSdtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldD9zdWJqZWN0PU15IGFwcGxpY2F0aW9uIGlzIGJlaW5nIHByb2Nlc3NlZCBmb3IgdG8gbG9uZyZib2R5PUhpLCBjYW4geW91IGhlbHAgbWUgdG8gZmluZCBvdXQgd2hhdCB0aGUgcHJvYmxlbSBpcywgdGhlIEtZQyBwcm9jZXNzIGhhcyBub3QgY2hhbmdlZCBmb3Igc29tZSB0aW1lPyBNeSBuYW1lIGlzIF9fX19fX18gYW5kIEkgdXNlZCB0aGUgZW1haWwgX19fX19fXyB0byByZWdpc3RlciBhdCBsaW1pbmFsLm1hcmtldCc+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT5cIik7XHJcbiAgICAgICAgICAgIGNhc2UgJ0FDVElPTl9SRVFVSVJFRCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBreWNBY3Rpb25SZXF1aXJlZCA9IG5ldyBLeWNBY3Rpb25SZXF1aXJlZChleGVjdXRlVHJhZGVCdXR0b24pXHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQga3ljQWN0aW9uUmVxdWlyZWQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY2FzZSAnUkVKRUNURUQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd01vZGFsKCdBcHBsaWNhdGlvbiB3YXMgcmVqZWN0ZWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIFwiWW91ciBhcHBsaWNhdGlvbiBoYXMgYmVlbiByZWplY3RlZCBkdXJpbmcgS1lDIHByb2Nlc3MuPGJyIC8+PGJyIC8+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiV2UgZG9uJ3QgaGF2ZSB0aGUgaW5mb3JtYXRpb24gb24gd2h5IHRoYXQgaGFwcGVuZWQsIGJ1dCB5b3UgY2FuIGVtYWlsIHVzIGF0IFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIjxhIHRhcmdldD0nX2JsYW5rJyBocmVmPSdtYWlsdG86aW5mb0BsaW1pbmFsLm1hcmtldD9zdWJqZWN0PU15IGFwcGxpY2F0aW9uIHdhcyByZWplY3RlZCZib2R5PUhpLCBjYW4geW91IGhlbHAgbWUgdG8gZmluZCBvdXQgd2hhdCB0aGUgcHJvYmxlbSBpcz8gTXkgbmFtZSBpcyBfX19fX19fIGFuZCBJIHVzZWQgdGhlIGVtYWlsIF9fX19fX18gdG8gcmVnaXN0ZXIgYXQgbGltaW5hbC5tYXJrZXQnPmluZm9AbGltaW5hbC5tYXJrZXQ8L2E+XCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiIGFuZCB3ZSBjYW4gZmluZCBvdXQsIGFuZCB3ZSBzaG91bGQgYmUgYWJsZSB0byBzb2x2ZSBpdCB0b2dldGhlci5cIik7XHJcbiAgICAgICAgICAgIGNhc2UgJ0RJU0FCTEVEJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dNb2RhbCgnQXBwbGljYXRpb24gd2FzIGRpc2FibGVkJyxcclxuICAgICAgICAgICAgICAgICAgICBcIllvdXIgYWNjb3VudCBoYXMgYmVlbiBkaXNhYmxlZC48YnIgLz48YnIgLz5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJXZSBkb24ndCBoYXZlIHRoZSBpbmZvcm1hdGlvbiBvbiB3aHkgdGhhdCBoYXBwZW5lZCwgYnV0IHlvdSBjYW4gZW1haWwgdXMgYXQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiPGEgdGFyZ2V0PSdfYmxhbmsnIGhyZWY9J21haWx0bzppbmZvQGxpbWluYWwubWFya2V0P3N1YmplY3Q9TXkgYXBwbGljYXRpb24gd2FzIGRpc2FibGVkJmJvZHk9SGksIGNhbiB5b3UgaGVscCBtZSB0byBmaW5kIG91dCB3aGF0IHRoZSBwcm9ibGVtIGlzPyBNeSBuYW1lIGlzIF9fX19fX18gYW5kIEkgdXNlZCB0aGUgZW1haWwgX19fX19fXyB0byByZWdpc3RlciBhdCBsaW1pbmFsLm1hcmtldCc+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgYW5kIHdlIGNhbiBmaW5kIG91dCwgYW5kIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNvbHZlIGl0IHRvZ2V0aGVyLlwiKTtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ0FDQ09VTlRfQ0xPU0VEJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dNb2RhbCgnQXBwbGljYXRpb24gd2FzIGNsb3NlZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgXCJZb3VyIGFjY291bnQgaGFzIGJlZW4gY2xvc2VkLjxiciAvPjxiciAvPlwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIldlIGRvbid0IGhhdmUgdGhlIGluZm9ybWF0aW9uIG9uIHdoeSB0aGF0IGhhcHBlbmVkLCBidXQgeW91IGNhbiBlbWFpbCB1cyBhdCBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCI8YSB0YXJnZXQ9J19ibGFuaycgaHJlZj0nbWFpbHRvOmluZm9AbGltaW5hbC5tYXJrZXQ/c3ViamVjdD1NeSBhcHBsaWNhdGlvbiB3YXMgY2xvc2VkJmJvZHk9SGksIGNhbiB5b3UgaGVscCBtZSB0byBmaW5kIG91dCB3aGF0IHRoZSBwcm9ibGVtIGlzPyBNeSBuYW1lIGlzIF9fX19fX18gYW5kIEkgdXNlZCB0aGUgZW1haWwgX19fX19fXyB0byByZWdpc3RlciBhdCBsaW1pbmFsLm1hcmtldCc+aW5mb0BsaW1pbmFsLm1hcmtldDwvYT5cIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCIgYW5kIHdlIGNhbiBmaW5kIG91dCwgYW5kIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNvbHZlIGl0IHRvZ2V0aGVyLlwiKTtcclxuICAgICAgICAgICAgY2FzZSAnQUNDT1VOVF9VUERBVEVEJzpcclxuICAgICAgICAgICAgY2FzZSAnQUNUSVZFJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dNb2RhbCgnQWNjb3VudCBzb29uIHJlYWR5JywgJ1lvdXIgYWNjb3VudCBoYXMgYmVlbiBhcHByb3ZlZC4uLjxiciAvPjxici8+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJy4uYnV0LCBhZnRlciB3ZSBhcHByb3ZlIHlvdXIgYWNjb3VudCwgd2Ugd3JpdGUgdGhlIGluZm9ybWF0aW9uIHRvIHRoZSBibG9ja2NoYWluLicgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgVGhpcyB1c3VhbGx5IHRha2VzIGp1c3QgZmV3KDItMykgbWludXRlcy48YnIgLz48YnIvPiBJZiB0aGlzIGlzIHRha2luZyBsb25nZXIsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdwbGVhc2UgZW1haWwgdXMgYXQgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cIm1haWx0bzppbmZvQGxpbWluYWwubWFya2V0P3N1YmplY3Q9S1lDIGlzIGJlaW5nIHdyaXR0ZW4gdG8gYmxvY2tjaGFpbiZib2R5PUhpLCBjYW4geW91IGhlbHAgbWUgdG8gZmluZCBvdXQgd2hhdCB0aGUgcHJvYmxlbSBpcz8gTXkgbmFtZSBpcyBfX19fX19fIGFuZCBJIHVzZWQgdGhlIGVtYWlsIF9fX19fX18gdG8gcmVnaXN0ZXIgYXQgbGltaW5hbC5tYXJrZXRcIj5pbmZvQGxpbWluYWwubWFya2V0PC9hPicpO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBreWNGb3JtID0gbmV3IEtZQ0Zvcm0oYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlVHJhZGVCdXR0b24ucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBreWNGb3JtLnNob3dLWUNGb3JtKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2hvd01vZGFsKHRpdGxlOiBzdHJpbmcsIGNvbnRlbnQ6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwodGl0bGUsIGNvbnRlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxoMj5Zb3UgYXJlIGFjY291bnQgaGFzIGJlZW4gYXBwcm92ZWQ8L2gyPlxcclxcbjxwPldlIGhhdmUgYXBwcm92ZWQgeW91ciBhY2NvdW50LiBZb3UgY2FuIG5vdyBmdW5kIHlvdXIgYWNjb3VudCBhbmQgc3RhcnQgdG8gdHJhZGUuXFxyXFxuXFxyXFxuICAgIDxidXR0b24gaWQ9XFxcImt5Y0FwcHJvdmVkRnVuZFxcXCI+RnVuZCBhY2NvdW50PC9idXR0b24+XFxyXFxuPC9wPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgTW9yYWxpcyBmcm9tIFwiTW9yYWxpc1wiO1xyXG5pbXBvcnQgTmV0d29ya0luZm8gZnJvbSBcIi4uLy4uLy4uL25ldHdvcmtzL05ldHdvcmtJbmZvXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgQXV0aGVudGljYXRlU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmFja2VuZC9BdXRoZW50aWNhdGVTZXJ2aWNlXCI7XHJcbmltcG9ydCBDb25uZWN0V2FsbGV0IGZyb20gXCIuLi8uLi9tb2RhbHMvQ29ubmVjdFdhbGxldFwiO1xyXG5pbXBvcnQgS1lDU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9LWUNTZXJ2aWNlXCI7XHJcbmltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQgRmFrZUFVU0RGdW5kIGZyb20gXCIuLi8uLi9tb2RhbHMvRnVuZGluZy9GYWtlQVVTREZ1bmRcIjtcclxuaW1wb3J0IFNlY3VyaXR5VG9rZW5TZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL1NlY3VyaXR5VG9rZW5TZXJ2aWNlXCI7XHJcbmltcG9ydCBMaW1pbmFsTWFya2V0U2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9MaW1pbmFsTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQge0FkZHJlc3NaZXJvLCByb3VuZEJpZ051bWJlckRlY2ltYWwsIHJvdW5kTnVtYmVyRGVjaW1hbCwgc2hvcnRFdGh9IGZyb20gXCIuLi8uLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9iYWNrZW5kL1N1YnNjcmlwdGlvblwiO1xyXG5pbXBvcnQge1RyYWRlVHlwZX0gZnJvbSAnLi4vLi4vLi4vZW51bXMvVHJhZGVUeXBlJztcclxuaW1wb3J0IFRyYWRlUGFuZWxJbnB1dCBmcm9tIFwiLi9UcmFkZVBhbmVsSW5wdXRcIjtcclxuaW1wb3J0IEV4ZWN1dGVUcmFkZUJ1dHRvbkh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9lbGVtZW50cy90cmFkZXBhbmVsL0V4ZWN1dGVUcmFkZUJ1dHRvbi5odG1sJztcclxuaW1wb3J0IFByb3ZpZGVySW5mbyBmcm9tIFwiLi4vLi4vLi4vd2FsbGV0L1Byb3ZpZGVySW5mb1wiO1xyXG5pbXBvcnQgVHJhZGVFeGVjdXRlZEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9lbGVtZW50cy90cmFkZXBhbmVsL1RyYWRlRXhlY3V0ZWQuaHRtbCdcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi8uLi9tb2RhbHMvTW9kYWxcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi4vLi4vLi4vdXRpbC9XYWxsZXRIZWxwZXJcIjtcclxuaW1wb3J0IEJsb2NrY2hhaW5FcnJvciBmcm9tIFwiLi4vLi4vLi4vZXJyb3JzL0Jsb2NrY2hhaW5FcnJvclwiO1xyXG5pbXBvcnQgTmF0aXZlVG9rZW5OZWVkZWQgZnJvbSBcIi4uLy4uL21vZGFscy9OYXRpdmVUb2tlbk5lZWRlZFwiO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gXCJiaWdudW1iZXIuanNcIjtcclxuaW1wb3J0IEt5Y1N0YXR1c0hhbmRsZXIgZnJvbSBcIi4uLy4uL21vZGFscy9LWUMvS3ljU3RhdHVzSGFuZGxlclwiO1xyXG5pbXBvcnQgS3ljQXBwcm92ZWRIdG1sIGZyb20gJy4uLy4uLy4uL2h0bWwvbW9kYWwvS3ljL0t5Y0FwcHJvdmVkLmh0bWwnO1xyXG5pbXBvcnQgQVVzZEJhbGFuY2UgZnJvbSBcIi4uL0FVc2RCYWxhbmNlXCI7XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXhlY3V0ZVRyYWRlQnV0dG9uIHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgYXV0aGVudGljYXRlU2VydmljZTogQXV0aGVudGljYXRlU2VydmljZTtcclxuICAgIHNlbGxUcmFkZUlucHV0OiBUcmFkZVBhbmVsSW5wdXQ7XHJcbiAgICBidXlUcmFkZUlucHV0OiBUcmFkZVBhbmVsSW5wdXQ7XHJcbiAgICB0ZW1wbGF0ZTogYW55O1xyXG4gICAgYnV0dG9uOiBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgIHN0YXRpYyBJbnN0YW5jZTogRXhlY3V0ZVRyYWRlQnV0dG9uO1xyXG4gICAgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMsIHNlbGxUcmFkZUlucHV0OiBUcmFkZVBhbmVsSW5wdXQsIGJ1eVRyYWRlSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dCkge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICAgICAgdGhpcy5zZWxsVHJhZGVJbnB1dCA9IHNlbGxUcmFkZUlucHV0O1xyXG4gICAgICAgIHRoaXMuYnV5VHJhZGVJbnB1dCA9IGJ1eVRyYWRlSW5wdXQ7XHJcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlID0gbmV3IEF1dGhlbnRpY2F0ZVNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKEV4ZWN1dGVUcmFkZUJ1dHRvbkh0bWwpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X2V4ZWN1dGVfdHJhZGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICBFeGVjdXRlVHJhZGVCdXR0b24uSW5zdGFuY2UgPSB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXJCdXR0b24oKSB7XHJcbiAgICAgICAgdGhpcy5idXR0b24ub3V0ZXJIVE1MID0gdGhpcy5idXR0b24ub3V0ZXJIVE1MO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X2V4ZWN1dGVfdHJhZGUnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRpbmdCdXR0b24odGhpcy5idXR0b24pO1xyXG5cclxuICAgICAgICAvL3dhbGxldCBjb25uZWN0ZWRcclxuICAgICAgICBpZiAoIXRoaXMud2FsbGV0SXNDb25uZWN0ZWQodGhpcy5idXR0b24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy91c2VyIGxvZ2dlZCBpblxyXG4gICAgICAgIGlmICghdGhpcy51c2VySXNMb2dnZWRJbih0aGlzLmJ1dHRvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NoYWluIGlkIGNvcnJlY3RcclxuICAgICAgICBpZiAoIXRoaXMuY2hhaW5JZElzQ29ycmVjdCh0aGlzLmJ1dHRvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL25hdGl2ZSB0b2tlbiBpcyBhdmFpbGFibGVcclxuICAgICAgICBpZiAoIWF3YWl0IHRoaXMudXNlckhhc05hdGl2ZVRva2VuKHRoaXMuYnV0dG9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8va3ljIGlzIGRvbmVcclxuICAgICAgICBpZiAoIWF3YWl0IHRoaXMua3ljSXNEb25lKHRoaXMuYnV0dG9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vYXVzZCBpcyBzZXR1cFxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy51c2VySGFzQVVTRCh0aGlzLmJ1dHRvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9hdXNkID4gYnV5IGFtb3VudFxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy51c2VySGFzRW5vdWdoUXR5KHRoaXMuYnV0dG9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzUXVhbnRpdHlBbmRTeW1ib2wodGhpcy5idXR0b24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghYXdhaXQgdGhpcy5pc01hcmtldE9wZW4odGhpcy5idXR0b24pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZW5hYmxlRXhlY3V0ZVRyYWRlKHRoaXMuYnV0dG9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGVuYWJsZUV4ZWN1dGVUcmFkZShidXR0b246IEhUTUxFbGVtZW50KSB7XHJcblxyXG4gICAgICAgIC8vaWYgKHRoaXMuc2VsbFRyYWRlSW5wdXQucXVhbnRpdHkuZXEoMCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy9leGVjdXRlIHRyYWRlIGNhbiBiZSBkb25lXHJcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdFeGVjdXRlIHRyYWRlJztcclxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlcGxhY2UoJ2Rpc2FibGVkJywgJ2VuYWJsZWQnKTtcclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcblxyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgICAgIGxldCBwcm92aWRlckluZm8gPSBQcm92aWRlckluZm8uSW5zdGFuY2U7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnQ29uZmlybSB0cmFuc2FjdGlvbiBpbiB5b3VyICcgKyBwcm92aWRlckluZm8uV2FsbGV0TmFtZSArICcgd2FsbGV0JztcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGxUcmFkZUlucHV0LnN5bWJvbCA9PSAnYVVTRCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBsaW1pbmFsTWFya2V0U2VydmljZSA9IG5ldyBMaW1pbmFsTWFya2V0U2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbEFkZHJlc3MgPSBhd2FpdCBsaW1pbmFsTWFya2V0U2VydmljZS5nZXRTeW1ib2xDb250cmFjdEFkZHJlc3ModGhpcy5idXlUcmFkZUlucHV0LnN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbEFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmNyZWF0ZVRva2VuKHRoaXMuYnV5VHJhZGVJbnB1dC5zeW1ib2wsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdDcmVhdGluZyB0b2tlbi4gR2l2ZSBpdCBmZXcgc2Vjb25kcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcExvYWRpbmdCdXR0b24oYnV0dG9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdFeGVjdXRlIHRyYWRlJztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQmxvY2tjaGFpbkVycm9yKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sQWRkcmVzcyA9IHJlc3VsdCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlVHJhbnNmZXIoc3ltYm9sQWRkcmVzcywgYnV0dG9uKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCBsaW1pbmFsTWFya2V0U2VydmljZSA9IG5ldyBMaW1pbmFsTWFya2V0U2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbEFkZHJlc3MgPSBhd2FpdCBsaW1pbmFsTWFya2V0U2VydmljZS5nZXRTeW1ib2xDb250cmFjdEFkZHJlc3ModGhpcy5zZWxsVHJhZGVJbnB1dC5zeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzZWN1cml0eVRva2VuU2VydmljZSA9IG5ldyBTZWN1cml0eVRva2VuU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VjdXJpdHlUb2tlblNlcnZpY2UudHJhbnNmZXIoc3ltYm9sQWRkcmVzcywgdGhpcy5zZWxsVHJhZGVJbnB1dC5xdWFudGl0eSlcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NBVENIIC0gc2VjdXJpdHlUb2tlblNlcnZpY2UudHJhbnNmZXInLCByZWFzb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odHJhbnNhY3Rpb24gPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVEhFTiAtIHNlY3VyaXR5VG9rZW5TZXJ2aWNlLnRyYW5zZmVyJywgdHJhbnNhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3JFeGVjdXRlVHJhZGUodHJhbnNhY3Rpb24gYXMgTW9yYWxpcy5FeGVjdXRlRnVuY3Rpb25SZXN1bHQsIFRyYWRlVHlwZS5TZWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0V4ZWN1dGUgdHJhZGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGV4ZWN1dGVUcmFuc2ZlcihzeW1ib2xBZGRyZXNzOiBzdHJpbmcsIGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBsZXQgYVVzZFNlcnZpY2UgPSBuZXcgQVVTRFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICBhd2FpdCBhVXNkU2VydmljZS50cmFuc2ZlcihzeW1ib2xBZGRyZXNzLCB0aGlzLnNlbGxUcmFkZUlucHV0LnF1YW50aXR5KVxyXG4gICAgICAgICAgICAuY2F0Y2gocmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDQVRDSCAtIGFVc2RTZXJ2aWNlLnRyYW5zZmVyJywgcmVhc29uKTtcclxuICAgICAgICAgICAgfSkudGhlbih0cmFuc2FjdGlvbiA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yRXhlY3V0ZVRyYWRlKHRyYW5zYWN0aW9uIGFzIE1vcmFsaXMuRXhlY3V0ZUZ1bmN0aW9uUmVzdWx0LCBUcmFkZVR5cGUuQnV5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvZ3Jlc3NUZXh0KCdTZW5kaW5nIHRvIGJsb2NrY2hhaW4nLCB0cmFuc2FjdGlvbi5oYXNoKVxyXG5cclxuICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0V4ZWN1dGUgdHJhZGUnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0QnV5aW5nU2hhcmVzT2JqKG9iamVjdDogYW55KTogYW55IHtcclxuICAgICAgICBsZXQgZXRoQWRkcmVzcyA9IG9iamVjdC53YWxsZXRBZGRyZXNzO1xyXG4gICAgICAgIGxldCB0b2tlbkFkZHJlc3MgPSBvYmplY3QudG9rZW5BZGRyZXNzO1xyXG4gICAgICAgIGxldCBidXlpbmdRdWFudGl0eSA9IG9iamVjdC5maWxsZWRfcXR5O1xyXG4gICAgICAgIGxldCBzZWxsaW5nQW1vdW50ID0gJyQnICsgbmV3IEJpZ051bWJlcihvYmplY3QuYW1vdW50KS5kaXYoMTAgKiogMTgpLnRvRml4ZWQoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsbGluZ0xvZ286ICcvaW1nL2xvZ29zL2FVU0QucG5nJyxcclxuICAgICAgICAgICAgc2VsbGluZ1N5bWJvbDogJ2FVU0QnLFxyXG4gICAgICAgICAgICBzZWxsaW5nQW1vdW50OiBzZWxsaW5nQW1vdW50LFxyXG4gICAgICAgICAgICBidXlpbmdMb2dvOiAnL2ltZy9sb2dvcy8nICsgb2JqZWN0LnN5bWJvbCArICcucG5nJyxcclxuICAgICAgICAgICAgYnV5aW5nU3ltYm9sOiBvYmplY3Quc3ltYm9sLFxyXG4gICAgICAgICAgICBidXlpbmdRdWFudGl0eTogYnV5aW5nUXVhbnRpdHksXHJcbiAgICAgICAgICAgIGJ1eWluZ1JvdW5kUXVhbnRpdHk6IHJvdW5kTnVtYmVyRGVjaW1hbChidXlpbmdRdWFudGl0eSwgNikgKyAnIHNoYXJlcycsXHJcbiAgICAgICAgICAgIHNob3J0RXRoQWRkcmVzczogc2hvcnRFdGgoZXRoQWRkcmVzcyksXHJcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogdG9rZW5BZGRyZXNzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRTZWxsU2hhcmVzT2JqKG9iamVjdDogYW55KTogYW55IHtcclxuICAgICAgICBsZXQgZXRoQWRkcmVzcyA9IG9iamVjdC5zZW5kZXI7XHJcbiAgICAgICAgbGV0IHRva2VuQWRkcmVzcyA9IG9iamVjdC5yZWNpcGllbnQ7XHJcbiAgICAgICAgbGV0IGJ1eWluZ1F1YW50aXR5ID0gbmV3IEJpZ051bWJlcihvYmplY3QuZmlsbGVkX2F2Z19wcmljZSkubXVsdGlwbGllZEJ5KG5ldyBCaWdOdW1iZXIob2JqZWN0LmZpbGxlZF9xdHkpKVxyXG4gICAgICAgIGxldCBzZWxsaW5nQW1vdW50ID0gb2JqZWN0LmZpbGxlZF9xdHk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHNlbGxpbmdMb2dvOiAnL2ltZy9sb2dvcy8nICsgb2JqZWN0LnN5bWJvbCArICcucG5nJyxcclxuICAgICAgICAgICAgc2VsbGluZ1N5bWJvbDogb2JqZWN0LnN5bWJvbCxcclxuICAgICAgICAgICAgc2VsbGluZ0Ftb3VudDogc2VsbGluZ0Ftb3VudCArICcgc2hhcmVzJyxcclxuICAgICAgICAgICAgYnV5aW5nTG9nbzogJy9pbWcvbG9nb3MvYVVTRC5wbmcnLFxyXG4gICAgICAgICAgICBidXlpbmdTeW1ib2w6ICdhVVNEJyxcclxuICAgICAgICAgICAgYnV5aW5nUXVhbnRpdHk6IGJ1eWluZ1F1YW50aXR5LnRvRml4ZWQoKSxcclxuICAgICAgICAgICAgYnV5aW5nUm91bmRRdWFudGl0eTogJyQnICsgcm91bmRCaWdOdW1iZXJEZWNpbWFsKGJ1eWluZ1F1YW50aXR5LCA2KS50b0ZpeGVkKCksXHJcbiAgICAgICAgICAgIHNob3J0RXRoQWRkcmVzczogc2hvcnRFdGgoZXRoQWRkcmVzcyksXHJcbiAgICAgICAgICAgIHRva2VuQWRkcmVzczogdG9rZW5BZGRyZXNzXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93VHJhZGVFeGVjdXRlZChvYmplY3Q6IGFueSkge1xyXG4gICAgICAgIGxldCBwcm92aWRlckluZm8gPSBQcm92aWRlckluZm8uSW5zdGFuY2U7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBsZXQgaXNCdXkgPSAob2JqZWN0LnNpZGUgPT0gJ2J1eScpO1xyXG5cclxuICAgICAgICBsZXQgb2JqID0gKGlzQnV5KSA/IHRoaXMuZ2V0QnV5aW5nU2hhcmVzT2JqKG9iamVjdCkgOiB0aGlzLmdldFNlbGxTaGFyZXNPYmoob2JqZWN0KTtcclxuICAgICAgICBvYmoud2FsbGV0TmFtZSA9IHByb3ZpZGVySW5mby5XYWxsZXROYW1lO1xyXG4gICAgICAgIG9iai5ibG9ja0V4cGxvcmVyTGluayA9IG5ldHdvcmtJbmZvLkJsb2NrRXhwbG9yZXIgKyAnL3R4LycgKyBvYmplY3QudHJhbnNhY3Rpb25faGFzaDtcclxuXHJcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFRyYWRlRXhlY3V0ZWRIdG1sKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKG9iaik7XHJcbiAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcbiAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdUcmFkZSBleGVjdXRlZCcsIGNvbnRlbnQpO1xyXG5cclxuICAgICAgICBsZXQgYWRkVG9rZW5Ub1dhbGxldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGRUb2tlblRvV2FsbGV0Jyk7XHJcbiAgICAgICAgaWYgKCFhZGRUb2tlblRvV2FsbGV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGFkZFRva2VuVG9XYWxsZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICBsZXQgYWRkcmVzcyA9IChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5kYXRhc2V0LmFkZHJlc3MgYXMgc3RyaW5nO1xyXG4gICAgICAgICAgICBsZXQgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICB3YWxsZXRIZWxwZXIuYWRkVG9rZW5Ub1dhbGxldChhZGRyZXNzLCB0aGlzLmJ1eVRyYWRlSW5wdXQuc3ltYm9sLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYWRkVG9rZW5Ub1dhbGxldEZhaWxlZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGRUb2tlblRvV2FsbGV0RmFpbGVkJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWFkZFRva2VuVG9XYWxsZXRGYWlsZWQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBhZGRUb2tlblRvV2FsbGV0RmFpbGVkLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG1vbml0b3JFeGVjdXRlVHJhZGUodHJhbnNhY3Rpb246IE1vcmFsaXMuRXhlY3V0ZUZ1bmN0aW9uUmVzdWx0LCB0cmFkZVR5cGU6IFRyYWRlVHlwZSkge1xyXG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMubW9yYWxpcyk7XHJcblxyXG4gICAgICAgIGF3YWl0IHN1YnNjcmlwdGlvbi5zdWJzY3JpYmVUb1RhYmxlKHRyYWRlVHlwZSwgYXN5bmMgKG9iamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdXNlciA9IHRoaXMubW9yYWxpcy5Vc2VyLmN1cnJlbnQoKTtcclxuICAgICAgICAgICAgaWYgKCF1c2VyKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChvYmplY3Qud2FsbGV0QWRkcmVzcyAhPSB1c2VyLmdldCgnZXRoQWRkcmVzcycpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChvYmplY3Quc3RhdHVzID09ICdvcmRlcl9maWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNob3dUcmFkZUV4ZWN1dGVkKG9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBBVXNkQmFsYW5jZS5mb3JjZUxvYWRBVVNEQmFsYW5jZVVJKHRoaXMubW9yYWxpcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGV4ZWN1dGluZ1RyYWRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4ZWN1dGluZy10cmFkZS1wcm9ncmVzcycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFleGVjdXRpbmdUcmFkZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGV4ZWN1dGluZ1RyYWRlLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5zdGF0dXMgPT0gJ29yZGVyX2ZhaWxlZCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdPcmRlciBmYWlsZWQnLCAnV2UgY291bGQgbm90IGZpbmlzaCB5b3VyIG9yZGVyLicpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9iamVjdC5zdGF0dXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvZ3Jlc3NUZXh0KCdSZWNlaXZlZCBvcmRlciBzZW5kaW5nIHRvIHN0b2NrIGV4Y2hhbmdlJywgb2JqZWN0LnRyYW5zYWN0aW9uX2hhc2gpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0LnN0YXR1cyA9PSAnb3JkZXJfcmVxdWVzdGVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcm9ncmVzc1RleHQoJ1NlbnQgdG8gc3RvY2sgZXhjaGFuZ2UnLCBvYmplY3QudHJhbnNhY3Rpb25faGFzaCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBBVXNkQmFsYW5jZS5mb3JjZUxvYWRBVVNEQmFsYW5jZVVJKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IGV4ZWN1dGluZ1RyYWRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4ZWN1dGluZy10cmFkZS1wcm9ncmVzcycpO1xyXG4gICAgICAgIGlmICghZXhlY3V0aW5nVHJhZGUpIHJldHVybjtcclxuXHJcbiAgICAgICAgZXhlY3V0aW5nVHJhZGUuY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBsb2FkaW5nQnV0dG9uKGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWJ1c3knLCAndHJ1ZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc3RvcExvYWRpbmdCdXR0b24oYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGJ1dHRvbi5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgd2FsbGV0SXNDb25uZWN0ZWQoYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGxldCB3YWxsZXRDb25uZWN0ZWQgPSB0aGlzLmF1dGhlbnRpY2F0ZVNlcnZpY2UuaXNXYWxsZXRDb25uZWN0ZWQoKTtcclxuICAgICAgICBpZiAod2FsbGV0Q29ubmVjdGVkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdDb25uZWN0IHdhbGxldCc7XHJcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgY29ubmVjdFdhbGxldCA9IG5ldyBDb25uZWN0V2FsbGV0KHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3RXYWxsZXQuY29ubmVjdFdhbGxldChldnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc3RvcExvYWRpbmdCdXR0b24oYnV0dG9uKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSB1c2VySXNMb2dnZWRJbihidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IHVzZXJMb2dnZWRJbiA9IHRoaXMuYXV0aGVudGljYXRlU2VydmljZS5pc1VzZXJMb2dnZWRJbigpO1xyXG4gICAgICAgIGlmICh1c2VyTG9nZ2VkSW4pIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ0xvZ2luJztcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aGVudGljYXRlU2VydmljZS5hdXRoZW50aWNhdGVVc2VyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNoYWluSWRJc0NvcnJlY3QoYnV0dG9uOiBIVE1MRWxlbWVudCkge1xyXG4gICAgICAgIGxldCBjaGFpbklkID0gdGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlLmdldENoYWluSWQoKTtcclxuICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBOZXR3b3JrSW5mby5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmIChjaGFpbklkID09PSBuZXR3b3JrSW5mby5DaGFpbklkKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgbGV0IHVzZXJzV2FsbGV0TmV0d29yayA9IE5ldHdvcmtJbmZvLmdldE5ldHdvcmtJbmZvQnlDaGFpbklkKGNoYWluSWQpO1xyXG4gICAgICAgIGlmICh1c2Vyc1dhbGxldE5ldHdvcmspIHtcclxuICAgICAgICAgICAgTmV0d29ya0luZm8uc2V0TmV0d29ya0J5Q2hhaW5JZChjaGFpbklkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1N3aXRjaCBOZXR3b3JrJztcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IG5ldHdvcmtJbmZvLmFkZE5ldHdvcmtUb1dhbGxldCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyB1c2VySGFzTmF0aXZlVG9rZW4oYnV0dG9uOiBIVE1MRWxlbWVudCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IE5ldHdvcmtJbmZvLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgbGV0IGhhc0Vub3VnaE5hdGl2ZVRva2VucyA9IGF3YWl0IG5ldHdvcmtJbmZvLmhhc0Vub3VnaE5hdGl2ZVRva2Vucyh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGlmIChoYXNFbm91Z2hOYXRpdmVUb2tlbnMpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlcGxhY2UoJ2VuYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdZb3UgbmVlZCAnICsgbmV0d29ya0luZm8uTmF0aXZlQ3VycmVuY3lOYW1lICsgJyB0b2tlbnMuIENsaWNrIG1lIGZvciBzb21lIHRva2Vucyc7XHJcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmF0aXZlVG9rZW5OZWVkZWRNb2RhbCA9IG5ldyBOYXRpdmVUb2tlbk5lZWRlZCh0aGlzLm1vcmFsaXMsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBuYXRpdmVUb2tlbk5lZWRlZE1vZGFsLnNob3coKVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBreWNJZERvbmVUaW1lb3V0OiBhbnk7XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBreWNJc0RvbmUoYnV0dG9uOiBIVE1MRWxlbWVudCwgaW50ZXJ2YWxDaGVjayA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGt5Y1NlcnZpY2UgPSBuZXcgS1lDU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBldGhBZGRyZXNzID0gdGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlLmdldEV0aEFkZHJlc3MoKTtcclxuICAgICAgICBpZiAoZXRoQWRkcmVzcyA9PT0gJycpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ25vIEVUSCBhZGRyZXNzLCBreWMgY2hlY2sgZmFpbGVkJylcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGt5Y1Jlc3BvbnNlID0gYXdhaXQga3ljU2VydmljZS5oYXNWYWxpZEtZQygpO1xyXG4gICAgICAgIGlmICgha3ljUmVzcG9uc2UuaXNWYWxpZEt5YyAmJiBreWNSZXNwb25zZS5zdGF0dXMgPT0gJ0FDVElWRScpIHtcclxuICAgICAgICAgICAgdGhpcy5reWNJZERvbmVUaW1lb3V0ID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcblxyXG4gICAgICAgICAgICAgICAga3ljUmVzcG9uc2UgPSBhd2FpdCBreWNTZXJ2aWNlLmhhc1ZhbGlkS1lDKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoa3ljUmVzcG9uc2UuaXNWYWxpZEt5Yykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQnV5aW5nUG93ZXIgPSBreWNSZXNwb25zZS5oYXNCdXlpbmdQb3dlcjtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua3ljSWREb25lVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJCdXR0b24oKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAxMCAqIDEwMDApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoa3ljUmVzcG9uc2UuaXNWYWxpZEt5Yykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGludGVydmFsQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5reWNJZERvbmVUaW1lb3V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoS3ljQXBwcm92ZWRIdG1sKTtcclxuICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgbW9kYWwuc2hvd01vZGFsKCdBY2NvdW50IGFwcHJvdmVkJywgdGVtcGxhdGUoe30pKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZnVuZEFjY291bnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgna3ljQXBwcm92ZWRGdW5kJyk7XHJcbiAgICAgICAgICAgICAgICBmdW5kQWNjb3VudD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwuaGlkZU1vZGFsKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdXNkRnVuZCA9IG5ldyBGYWtlQVVTREZ1bmQodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBhdXNkRnVuZC5zaG93QVVTREZha2VGdW5kKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBreWNTdGF0dXNIYW5kbGVyID0gbmV3IEt5Y1N0YXR1c0hhbmRsZXIoa3ljUmVzcG9uc2UsIHRoaXMpO1xyXG5cclxuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0ga3ljU3RhdHVzSGFuZGxlci5nZXRCdXR0b25UZXh0KCk7XHJcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywga3ljU3RhdHVzSGFuZGxlci5nZXRCdXR0b25DbGlja0V2ZW50KHRoaXMpKTtcclxuICAgICAgICB0aGlzLnN0b3BMb2FkaW5nQnV0dG9uKGJ1dHRvbik7XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2hlY2tLeWNJc0RvbmUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMua3ljSWREb25lVGltZW91dCkgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLmt5Y0lkRG9uZVRpbWVvdXQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMua3ljSXNEb25lKHRoaXMuYnV0dG9uLCB0cnVlKTtcclxuICAgICAgICB9LCAxMCAqIDEwMDApO1xyXG4gICAgfVxyXG5cclxuICAgIGNoZWNrQmFsYW5jZUludGVydmFsOiBhbnk7XHJcbiAgICBoYXNCdXlpbmdQb3dlciA9IGZhbHNlO1xyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgdXNlckhhc0FVU0QoYnV0dG9uOiBIVE1MRWxlbWVudCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgICAgIGxldCBhdXNkU2VydmljZSA9IG5ldyBBVVNEU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBiYWxhbmNlID0gYXdhaXQgYXVzZFNlcnZpY2UuZ2V0QVVTREJhbGFuY2VPZih0aGlzLmF1dGhlbnRpY2F0ZVNlcnZpY2UuZ2V0RXRoQWRkcmVzcygpKTtcclxuICAgICAgICBpZiAoYmFsYW5jZS5pc0dyZWF0ZXJUaGFuKDApKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQnV5aW5nUG93ZXIpIHtcclxuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdXZSBhcmUgZnVuZGluZyB5b3VyIGFVU0QgdG9rZW4nO1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrQmFsYW5jZUludGVydmFsID0gc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgQVVTRFNlcnZpY2UubGFzdFVwZGF0ZSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IGF1c2RTZXJ2aWNlLmdldEFVU0RCYWxhbmNlT2YodGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlLmdldEV0aEFkZHJlc3MoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc0dyZWF0ZXJUaGFuKDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgQVVzZEJhbGFuY2UuZm9yY2VMb2FkQVVTREJhbGFuY2VVSSh0aGlzLm1vcmFsaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tCYWxhbmNlSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIDEwICogMTAwMCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXR3b3JrSW5mbyA9IE5ldHdvcmtJbmZvLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKG5ldHdvcmtJbmZvLlRlc3ROZXR3b3JrKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnWW91IG5lZWQgYVVTRC4gQ2xpY2sgaGVyZSB0byBnZXQgc29tZSc7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBhdXNkRnVuZCA9IG5ldyBGYWtlQVVTREZ1bmQodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIGF1c2RGdW5kLnNob3dBVVNERmFrZUZ1bmQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQnV0dG9uKCk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJ1lvdSBuZWVkIGFVU0QuIENsaWNrIGhlcmUgZm9yIGluc3RydWN0aW9ucyc7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGxldCBhdXNkRnVuZCA9IG5ldyBGYWtlQVVTREZ1bmQodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIGF1c2RGdW5kLnNob3dBVVNERnVuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyB1c2VySGFzRW5vdWdoUXR5KGJ1dHRvbjogSFRNTEVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgbGV0IGF1c2RTZXJ2aWNlID0gbmV3IEFVU0RTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsbFRyYWRlSW5wdXQuc3ltYm9sID09ICdhVVNEJykge1xyXG4gICAgICAgICAgICBsZXQgYmFsYW5jZSA9IGF3YWl0IGF1c2RTZXJ2aWNlLmdldEFVU0RCYWxhbmNlT2YodGhpcy5hdXRoZW50aWNhdGVTZXJ2aWNlLmdldEV0aEFkZHJlc3MoKSk7XHJcbiAgICAgICAgICAgIGlmIChiYWxhbmNlLmlzR3JlYXRlclRoYW5PckVxdWFsVG8odGhpcy5zZWxsVHJhZGVJbnB1dC5xdWFudGl0eSkpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IFwiWW91IGRvbid0IGhhdmUgZW5vdWdoIGFVU0QuIENsaWNrIGZvciBtb3JlIGZ1bmRpbmdcIjtcclxuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBhdXNkRnVuZCA9IG5ldyBGYWtlQVVTREZ1bmQodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrSW5mby5UZXN0TmV0d29yaykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBhdXNkRnVuZC5zaG93QVVTREZha2VGdW5kKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXVzZEZ1bmQuc2hvd0FVU0RGdW5kKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBzZWN1cml0eVRva2VuU2VydmljZSA9IG5ldyBTZWN1cml0eVRva2VuU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBsZXQgYXV0aGVudGljYXRlU2VydmljZSA9IG5ldyBBdXRoZW50aWNhdGVTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGxldCBldGhBZGRyZXNzID0gYXV0aGVudGljYXRlU2VydmljZS5nZXRFdGhBZGRyZXNzKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdXNlclF1YW50aXR5ID0gYXdhaXQgc2VjdXJpdHlUb2tlblNlcnZpY2UuZ2V0UXVhbnRpdHlCeUFkZHJlc3ModGhpcy5zZWxsVHJhZGVJbnB1dC5zeW1ib2wsIGV0aEFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxsVHJhZGVJbnB1dC5xdWFudGl0eSA8PSB1c2VyUXVhbnRpdHkpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9IFwiWW91IGRvbid0IGhhdmUgZW5vdWdoIFwiICsgdGhpcy5zZWxsVHJhZGVJbnB1dC5zeW1ib2w7XHJcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVwbGFjZSgnZGlzYWJsZScsICdlbmFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIGlzTWFya2V0T3BlbihidXR0b246IEhUTUxFbGVtZW50KTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICAgICAgbGV0IHVzZXJTZXJ2aWNlID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGlzTWFya2V0T3BlbiA9IGF3YWl0IHVzZXJTZXJ2aWNlLmlzTWFya2V0T3Blbk9yVXNlck9mZkhvdXJzKCk7XHJcbiAgICAgICAgaWYgKGlzTWFya2V0T3BlbikgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnTWFya2V0IGlzIGNsb3NlZCdcclxuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlcGxhY2UoJ2VuYWJsZWQnLCAnZGlzYWJsZWQnKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBoYXNRdWFudGl0eUFuZFN5bWJvbChidXR0b246IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsbFRyYWRlSW5wdXQucXVhbnRpdHkuZXEoMCkpIHtcclxuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdUeXBlIGluIHF1YW50aXR5JztcclxuICAgICAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5idXlUcmFkZUlucHV0Lm5hbWUgPT0gJycpIHtcclxuICAgICAgICAgICAgYnV0dG9uLmlubmVySFRNTCA9ICdTZWxlY3Qgc3RvY2sgdG8gYnV5JztcclxuICAgICAgICAgICAgdGhpcy5zdG9wTG9hZGluZ0J1dHRvbihidXR0b24pO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2V0UHJvZ3Jlc3NUZXh0KHRleHQ6IHN0cmluZywgaGFzaDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IHByb2dyZXNzVGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmVzcy10ZXh0Jyk7XHJcbiAgICAgICAgaWYgKHByb2dyZXNzVGV4dCkge1xyXG4gICAgICAgICAgICBsZXQgbmV0d29ya0luZm8gPSBOZXR3b3JrSW5mby5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBwcm9ncmVzc1RleHQuaW5uZXJIVE1MID0gdGV4dCArICc8YnIgLz48YSBocmVmPVwiJyArIG5ldHdvcmtJbmZvLkJsb2NrRXhwbG9yZXIgKyAnL3R4LycgKyBoYXNoICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiIHN0eWxlPVwiZm9udC1zaXplOjEwcHhcIj5WaWV3PC9hPic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufSIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxhcnRpY2xlIGNsYXNzPVxcXCJ7e3RyYWRlVHlwZX19SW5wdXRzIHRyYWRlSW5wdXRBcnRpY2xlXFxcIj5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZ3JpZCB0cmFkZUlucHV0XFxcIj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInNlbGVjdF90b2tlblxcXCI+XFxyXFxuICAgICAgICAgICAgPGEgaWQ9XFxcInt7dHJhZGVUeXBlfX1TZWxlY3RTdG9ja1xcXCIgaHJlZj1cXFwiI1xcXCIgcm9sZT1cXFwiYnV0dG9uXFxcIj5cXHJcXG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XFxcInt7bG9nb319XFxcIi8+XFxyXFxuICAgICAgICAgICAgICAgIHt7c3ltYm9sfX1cXHJcXG4gICAgICAgICAgICA8L2E+XFxyXFxuICAgICAgICA8L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInRyYWRlX2lucHV0XFxcIj48aW5wdXQgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIHR5cGU9XFxcInRlbFxcXCIgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPVxcXCJ7e3N0clF1YW50aXR5fX1cXFwiIHBsYWNlaG9sZGVyPVxcXCIwLjBcXFwiLz48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcImJhbGFuY2VcXFwiPkJhbGFuY2UgOiA8YWJiciB0aXRsZT1cXFwie3tiYWxhbmNlfX1cXFwiIGRhdGEtdG9vbHRpcD1cXFwie3tiYWxhbmNlfX1cXFwiIGNsYXNzPVxcXCJiYWxhbmNlX3ZhbHVlXFxcIj57e2FiYnJCYWxhbmNlfX08L2FiYnI+XFxyXFxuICAgICAgICAgICAgPGEgaHJlZj1cXFwiXFxcIiBjbGFzcz1cXFwiYmFsYW5jZV9tYXhcXFwiPk1heDwvYT48L2Rpdj5cXHJcXG4gICAgICAgIDxkaXYgY2xhc3M9XFxcInByaWNlX3Blcl9zaGFyZVxcXCI+PC9kaXY+XFxyXFxuICAgIDwvZGl2PlxcclxcbiAgICA8cHJvZ3Jlc3MgY2xhc3M9XFxcInByb2dyZXNzIGQtbm9uZVxcXCIgdmFsdWU9XFxcIjBcXFwiIG1heD1cXFwiMVxcXCI+PC9wcm9ncmVzcz5cXHJcXG4gICAgPGRpdiBjbGFzcz1cXFwiZXhjZWVkc193YWxsZXRfYmFsYW5jZSBkLW5vbmVcXFwiPkV4Y2VlZHMgd2FsbGV0IGJhbGFuY2U8L2Rpdj5cXHJcXG48L2FydGljbGU+XFxyXFxuXCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBNb2RhbCBmcm9tIFwiLi9Nb2RhbFwiO1xyXG5pbXBvcnQgU2VjdXJpdGllc0xpc3QgZnJvbSBcIi4uL2VsZW1lbnRzL1NlY3VyaXRpZXNMaXN0XCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWN1cml0aWVzTGlzdE1vZGFsIHtcclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG4gICAgcGFnZTogbnVtYmVyO1xyXG4gICAgdGJvZHlJZCA9ICdsaW1pbmFsX21hcmtldF9zZWN1cml0aWVzX2xpc3QnO1xyXG4gICAgbG9hZG1vcmU6IGJvb2xlYW47XHJcbiAgICBtb2RhbDogTW9kYWw7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpczogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2FkbW9yZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5tb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93TW9kYWwob25TZWxlY3RTeW1ib2w6IChzeW1ib2w6IHN0cmluZywgbmFtZTogc3RyaW5nLCBsb2dvOiBzdHJpbmcpID0+IHZvaWQpIHtcclxuICAgICAgICBsZXQgc2VjdXJpdGllc0xpc3QgPSBuZXcgU2VjdXJpdGllc0xpc3QodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICBsZXQgY29udGVudCA9IGF3YWl0IHNlY3VyaXRpZXNMaXN0LnJlbmRlcigpO1xyXG5cclxuICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSB0aGlzLm1vZGFsLnNob3dNb2RhbCgnU2VsZWN0IHN0b2NrIHRvIGJ1eScsIGNvbnRlbnQsXHJcbiAgICAgICAgICAgIHRydWUpO1xyXG4gICAgICAgIC8vaWYgKG5ld0luc3RhbmNlKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgYXdhaXQgc2VjdXJpdGllc0xpc3QuYmluZEV2ZW50cyhvblNlbGVjdFN5bWJvbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGhpZGVNb2RhbCgpIHtcclxuICAgICAgICB0aGlzLm1vZGFsLmhpZGVNb2RhbCgpO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhZGVJbmZvIHtcclxuICAgIHByaWNlIDogbnVtYmVyO1xyXG4gICAgbGFzdFRyYWRlIDogRGF0ZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwcmljZSA6IG51bWJlciwgbGFzdFRyYWRlIDogRGF0ZSkge1xyXG4gICAgICAgIHRoaXMucHJpY2UgPSBwcmljZTtcclxuICAgICAgICB0aGlzLmxhc3RUcmFkZSA9IGxhc3RUcmFkZTtcclxuICAgIH1cclxufSIsImltcG9ydCBJQ2xvdWRFcnJvciBmcm9tIFwiLi9JQ2xvdWRFcnJvclwiO1xyXG5pbXBvcnQgRXJyb3JJbmZvIGZyb20gXCIuLi9FcnJvckluZm9cIjtcclxuaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi4vR2VuZXJhbEVycm9yXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIdHRwRXJyb3IgaW1wbGVtZW50cyBJQ2xvdWRFcnJvciB7XHJcbiAgICBtZXRob2QgOiBzdHJpbmc7XHJcbiAgICB1cmwgOiBzdHJpbmc7XHJcbiAgICBib2R5IDogc3RyaW5nO1xyXG4gICAgc2VydmVyRXJyb3IgOiBhbnk7XHJcblxyXG4gICAgY29uc3RydWN0b3Iob2JqIDogYW55KSB7XHJcbiAgICAgICAgdGhpcy5tZXRob2QgPSBvYmoubWV0aG9kO1xyXG4gICAgICAgIHRoaXMudXJsID0gb2JqLnVybDtcclxuICAgICAgICB0aGlzLmJvZHkgPSBvYmouYm9keTtcclxuICAgICAgICB0aGlzLnNlcnZlckVycm9yID0gb2JqLnNlcnZlckVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIGhhbmRsZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzKTtcclxuICAgICAgICBFcnJvckluZm8ucmVwb3J0KG5ldyBHZW5lcmFsRXJyb3IoJ0Vycm9yIGRvaW5nIHJlcXVlc3QuIFNlcnZlciByZXNwb25zZSB3YXM6JyArIHRoaXMuc2VydmVyRXJyb3IuZGF0YS5tZXNzYWdlKSlcclxuXHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IEdlbmVyYWxFcnJvciBmcm9tIFwiLi9HZW5lcmFsRXJyb3JcIjtcclxuaW1wb3J0IEVycm9ySW5mbyBmcm9tIFwiLi9FcnJvckluZm9cIjtcclxuaW1wb3J0IEt5Y1ZhbGlkYXRvckVycm9yIGZyb20gXCIuL2Nsb3VkL0t5Y1ZhbGlkYXRvckVycm9yXCI7XHJcbmltcG9ydCBJQ2xvdWRFcnJvciBmcm9tIFwiLi9jbG91ZC9JQ2xvdWRFcnJvclwiO1xyXG5pbXBvcnQgSHR0cEVycm9yIGZyb20gXCIuL2Nsb3VkL0h0dHBFcnJvclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2xvdWRFcnJvciBleHRlbmRzIEdlbmVyYWxFcnJvciB7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGU6IGFueSkge1xyXG4gICAgICAgIHN1cGVyKGUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKGUubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChvYmoubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVycm9ySGFuZGxlciA9IENsb3VkRXJyb3IuZ2V0QWN0aW9uSW5zdGFuY2Uob2JqLm5hbWUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyLmhhbmRsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRXJyb3JJbmZvLmVycm9yKG9iaik7XHJcbiAgICAgICAgfSBjYXRjaCAoanNvbkVycm9yKSB7XHJcbiAgICAgICAgICAgIEVycm9ySW5mby5lcnJvcihlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRBY3Rpb25JbnN0YW5jZShhY3Rpb246IHN0cmluZywgb2JqOiBhbnkpOiBJQ2xvdWRFcnJvciB7XHJcbiAgICAgICAgbGV0IHRtcDogYW55ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAobGV0IGk9MDtpPENsb3VkRXJyb3IuRXJyb3JzLmxlbmd0aDtpKyspIHtcclxuICAgICAgICAgICAgaWYgKENsb3VkRXJyb3IuRXJyb3JzW2ldLm5hbWUgPT09IGFjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IGVycm9ySGFuZGxlciA9IENsb3VkRXJyb3IuRXJyb3JzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBlcnJvckhhbmRsZXIob2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRtcDtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgRXJyb3JzID0gW1xyXG4gICAgICAgIEh0dHBFcnJvclxyXG4gICAgXVxyXG59IiwiaW1wb3J0IFRyYWRlSW5mbyBmcm9tIFwiLi9UcmFkZUluZm9cIjtcclxuaW1wb3J0IENsb3VkRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9DbG91ZEVycm9yXCI7XHJcbmltcG9ydCB7VHJhZGVUeXBlfSBmcm9tIFwiLi4vLi4vZW51bXMvVHJhZGVUeXBlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9ja1ByaWNlU2VydmljZSB7XHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGdldFN5bWJvbFByaWNlKHN5bWJvbDogc3RyaW5nLCB0cmFkZVR5cGU6IFRyYWRlVHlwZSk6IFByb21pc2U8VHJhZGVJbmZvPiB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xyXG4gICAgICAgICAgICBzeW1ib2w6IHN5bWJvbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oXCJnZXRTeW1ib2xQcmljZVwiLCBwYXJhbXMpXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZTogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2xvdWRFcnJvcihlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHF1b3RlID0gcmVzdWx0LnF1b3RlO1xyXG4gICAgICAgIGxldCBwcmljZSA9ICh0cmFkZVR5cGUgPT0gVHJhZGVUeXBlLlNlbGwpID8gcXVvdGUuYXAgOiBxdW90ZS5icDtcclxuICAgICAgICBsZXQgdHJhZGVJbmZvID0gbmV3IFRyYWRlSW5mbyhwcmljZSwgcXVvdGUudCk7XHJcbiAgICAgICAgcmV0dXJuIHRyYWRlSW5mbztcclxuXHJcbiAgICB9XHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YWJiciB0aXRsZT1cXFwiTGFzdCB0cmFkZSB3YXMge3tsYXN0VHJhZGVkfX1cXFwiIGRhdGEtdG9vbHRpcD1cXFwiTGFzdCB0cmFkZSB3YXMge3tsYXN0VHJhZGVkfX1cXFwiPnt7dGV4dH19PC9hYmJyPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgVHJhZGVJbnB1dEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9lbGVtZW50cy90cmFkZXBhbmVsL1RyYWRlSW5wdXQuaHRtbCc7XHJcbmltcG9ydCB7VHJhZGVUeXBlfSBmcm9tIFwiLi4vLi4vLi4vZW51bXMvVHJhZGVUeXBlXCI7XHJcbmltcG9ydCBTZWN1cml0aWVzTGlzdE1vZGFsIGZyb20gXCIuLi8uLi9tb2RhbHMvU2VjdXJpdGllc0xpc3RNb2RhbFwiO1xyXG5pbXBvcnQgTGltaW5hbE1hcmtldFNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2Jsb2NrY2hhaW4vTGltaW5hbE1hcmtldFNlcnZpY2VcIjtcclxuaW1wb3J0IFNlY3VyaXR5VG9rZW5TZXJ2aWNlIGZyb20gXCIuLi8uLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL1NlY3VyaXR5VG9rZW5TZXJ2aWNlXCI7XHJcbmltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IHtyb3VuZEJpZ051bWJlciwgcm91bmRCaWdOdW1iZXJEZWNpbWFsLCByb3VuZE51bWJlckRlY2ltYWx9IGZyb20gXCIuLi8uLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgU3RvY2tQcmljZVNlcnZpY2UgZnJvbSBcIi4uLy4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvU3RvY2tQcmljZVNlcnZpY2VcIjtcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XHJcbmltcG9ydCBQcmljZVBlclNoYXJlSHRtbCBmcm9tICcuLi8uLi8uLi9odG1sL2VsZW1lbnRzL3RyYWRlcGFuZWwvUHJpY2VQZXJTaGFyZS5odG1sJ1xyXG5pbXBvcnQgTW9yYWxpcyBmcm9tIFwibW9yYWxpc1wiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYWRlUGFuZWxJbnB1dCB7XHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuICAgIHN5bWJvbDogc3RyaW5nO1xyXG4gICAgbmFtZTogc3RyaW5nO1xyXG4gICAgbG9nbzogc3RyaW5nO1xyXG4gICAgYWRkcmVzczogc3RyaW5nO1xyXG4gICAgcmVhZG9ubHkgdHJhZGVUeXBlOiBUcmFkZVR5cGU7XHJcbiAgICBxdWFudGl0eTogQmlnTnVtYmVyO1xyXG4gICAgc3RyUXVhbnRpdHkgOiBzdHJpbmc7XHJcbiAgICBiYWxhbmNlOiBCaWdOdW1iZXI7XHJcbiAgICBsYXN0UHJpY2U6IG51bWJlcjtcclxuICAgIGxhc3RUcmFkZWQ6IHN0cmluZztcclxuICAgIHF0eVBlckRvbGxhcjogbnVtYmVyO1xyXG4gICAgdGVtcGxhdGU6IGFueTtcclxuICAgIHByaWNlUGVyU2hhcmVUZW1wbGF0ZTogYW55O1xyXG4gICAgb3RoZXJUcmFkZVBhbmVsSW5wdXQ6IFRyYWRlUGFuZWxJbnB1dCB8IHVuZGVmaW5lZDtcclxuICAgIG9uVXBkYXRlIDogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xyXG4gICAgaXNEaXJ0eSA6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcywgc3ltYm9sOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbG9nbzogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcsIHRyYWRlVHlwZTogVHJhZGVUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLnN5bWJvbCA9IHN5bWJvbDtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMubG9nbyA9IGxvZ287XHJcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcclxuICAgICAgICB0aGlzLnRyYWRlVHlwZSA9IHRyYWRlVHlwZTtcclxuICAgICAgICB0aGlzLnF1YW50aXR5ID0gbmV3IEJpZ051bWJlcigwKTtcclxuICAgICAgICB0aGlzLnN0clF1YW50aXR5ID0gJyc7XHJcbiAgICAgICAgdGhpcy5iYWxhbmNlID0gbmV3IEJpZ051bWJlcigwKTtcclxuICAgICAgICB0aGlzLmxhc3RQcmljZSA9IDA7XHJcbiAgICAgICAgdGhpcy5xdHlQZXJEb2xsYXIgPSAwO1xyXG4gICAgICAgIHRoaXMubGFzdFRyYWRlZCA9ICcnO1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVHJhZGVJbnB1dEh0bWwpO1xyXG4gICAgICAgIHRoaXMucHJpY2VQZXJTaGFyZVRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFByaWNlUGVyU2hhcmVIdG1sKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldE90aGVyVHJhZGVQYW5lbElucHV0KHRyYWRlUGFuZWxJbnB1dDogVHJhZGVQYW5lbElucHV0KSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dCA9IHRyYWRlUGFuZWxJbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyVG9TdHJpbmcoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVuZGVyKGJpbmRFdmVudHMgOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xyXG4gICAgICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLnRyYWRlVHlwZSArICdJbnB1dHMnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBlbGVtZW50Lm91dGVySFRNTCA9IHRoaXMucmVuZGVyVG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoYmluZEV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJpbmRFdmVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kUXVhbnRpdHlMaXN0ZW5lcigpO1xyXG4gICAgICAgIHRoaXMuYmluZFNlbGVjdFN0b2NrQnV0dG9uKCk7XHJcbiAgICAgICAgdGhpcy5iaW5kTWF4TGluaygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRTeW1ib2woc3ltYm9sOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbG9nbzogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmxvZ28gPSBsb2dvO1xyXG5cclxuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYmluZFNlbGVjdFN0b2NrQnV0dG9uKCkge1xyXG4gICAgICAgIGxldCBzZWxlY3RTdG9jayA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy50cmFkZVR5cGUgKyAnU2VsZWN0U3RvY2snKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xyXG4gICAgICAgIGlmICghc2VsZWN0U3RvY2spIHJldHVybjtcclxuXHJcbiAgICAgICAgc2VsZWN0U3RvY2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNlY3VyaXR5TGlzdCA9IG5ldyBTZWN1cml0aWVzTGlzdE1vZGFsKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNlY3VyaXR5TGlzdC5zaG93TW9kYWwoYXN5bmMgKHN5bWJvbDogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIGxvZ286IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlMaXN0LmhpZGVNb2RhbCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0ICYmIHRoaXMuc3ltYm9sID09ICdhVVNEJyAmJiBzeW1ib2wgIT0gdGhpcy5zeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnNldFN5bWJvbCh0aGlzLnN5bWJvbCwgdGhpcy5uYW1lLCB0aGlzLmxvZ28pXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy5zeW1ib2wgPSBzeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dvID0gbG9nbztcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlKCkudGhlbigpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkTGFzdFRyYWRlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25VcGRhdGUpIHRoaXMub25VcGRhdGUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIHByaXZhdGUgYmluZFF1YW50aXR5TGlzdGVuZXIoKSB7XHJcbiAgICAgICAgbGV0IHF0eUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLnRyYWRlVHlwZSArICdJbnB1dHMgLnRyYWRlX2lucHV0IGlucHV0JykgYXMgSFRNTElucHV0RWxlbWVudDtcclxuICAgICAgICBpZiAoIXF0eUlucHV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBpbnB1dFRpbWVyIDogYW55O1xyXG4gICAgICAgIHF0eUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5wdXRUaW1lcikgY2xlYXJUaW1lb3V0KGlucHV0VGltZXIpO1xyXG5cclxuICAgICAgICAgICAgaW5wdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0VmFsdWUgPSAoZXZ0LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UXVhbnRpdHkoaW5wdXRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRQcm9ncmVzc2JhcigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0KSB0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnVwZGF0ZVF1YW50aXR5KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vblVwZGF0ZSkgdGhpcy5vblVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9LCAzMDApO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBiaW5kTWF4TGluaygpIHtcclxuICAgICAgICBsZXQgbWF4QmFsYW5jZURvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC5iYWxhbmNlX21heCcpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghbWF4QmFsYW5jZURvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBtYXhCYWxhbmNlRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBxdHlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC50cmFkZV9pbnB1dCBpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICghcXR5SW5wdXQpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIHF0eUlucHV0LnZhbHVlID0gdGhpcy5iYWxhbmNlLnRvRml4ZWQoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRRdWFudGl0eShxdHlJbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZFByb2dyZXNzYmFyKCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dCkgdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC51cGRhdGVRdWFudGl0eSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vblVwZGF0ZSkgdGhpcy5vblVwZGF0ZSgpO1xyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWRCYWxhbmNlKCkge1xyXG4gICAgICAgIHRoaXMuYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcblxyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBldGhBZGRyZXNzID0gdXNlclNlcnZpY2UuZ2V0RXRoQWRkcmVzcygpO1xyXG5cclxuICAgICAgICBsZXQgYmFsYW5jZURvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC5iYWxhbmNlX3ZhbHVlJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFiYWxhbmNlRG9tKSByZXR1cm47XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbCA9PT0gJ2FVU0QnKSB7XHJcbiAgICAgICAgICAgIGlmIChldGhBZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgYVVzZFNlcnZpY2UgPSBuZXcgQVVTRFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFsYW5jZSA9IGF3YWl0IGFVc2RTZXJ2aWNlLmdldEFVU0RCYWxhbmNlT2YoZXRoQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFsYW5jZURvbS5pbm5lckhUTUwgPSAnJCcgKyByb3VuZEJpZ051bWJlcih0aGlzLmJhbGFuY2UpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5hbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFsYW5jZSA9IG5ldyBCaWdOdW1iZXIoMCk7XHJcbiAgICAgICAgICAgIGlmIChldGhBZGRyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdXJpdHlUb2tlblNlcnZpY2UgPSBuZXcgU2VjdXJpdHlUb2tlblNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmFsYW5jZSA9IGF3YWl0IHNlY3VyaXR5VG9rZW5TZXJ2aWNlLmdldFF1YW50aXR5QnlBZGRyZXNzKHRoaXMuc3ltYm9sLCBldGhBZGRyZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBiYWxhbmNlRG9tLmlubmVySFRNTCA9IHJvdW5kQmlnTnVtYmVyRGVjaW1hbCh0aGlzLmJhbGFuY2UsIDYpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJhbGFuY2VEb20uZGF0YXNldC50b29sdGlwID0gdGhpcy5iYWxhbmNlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgYmFsYW5jZURvbS50aXRsZSA9IHRoaXMuYmFsYW5jZS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRQcm9ncmVzc2JhcigpO1xyXG4gICAgICAgIHRoaXMudG9nZ2xlTWF4QmFsYW5jZUxpbmsoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZExhc3RUcmFkZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zeW1ib2wgPT09ICdhVVNEJykge1xyXG4gICAgICAgICAgICB0aGlzLmxhc3RQcmljZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMucXR5UGVyRG9sbGFyID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMub3RoZXJUcmFkZVBhbmVsSW5wdXQgfHwgdGhpcy5uYW1lID09ICcnKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBhVXNkUHJpY2VQZXJTaGFyZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC50cmFkZVR5cGUgKyAnSW5wdXRzIC5wcmljZV9wZXJfc2hhcmUnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAoIWFVc2RQcmljZVBlclNoYXJlKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBwcmljZVBlclNoYXJlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLicgKyB0aGlzLnRyYWRlVHlwZSArICdJbnB1dHMgLnByaWNlX3Blcl9zaGFyZScpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghcHJpY2VQZXJTaGFyZSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBhVXNkUHJpY2VQZXJTaGFyZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XHJcbiAgICAgICAgcHJpY2VQZXJTaGFyZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtYnVzeScsICd0cnVlJyk7XHJcblxyXG4gICAgICAgIGxldCBzdG9ja1ByaWNlU2VydmljZSA9IG5ldyBTdG9ja1ByaWNlU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCB0cmFkZUluZm8gPSBhd2FpdCBzdG9ja1ByaWNlU2VydmljZS5nZXRTeW1ib2xQcmljZSh0aGlzLnN5bWJvbCwgdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC50cmFkZVR5cGUpO1xyXG5cclxuICAgICAgICB0aGlzLmxhc3RQcmljZSA9IHRyYWRlSW5mby5wcmljZTtcclxuICAgICAgICB0aGlzLmxhc3RUcmFkZWQgPSB0cmFkZUluZm8ubGFzdFRyYWRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5xdHlQZXJEb2xsYXIgPSAxIC8gdGhpcy5sYXN0UHJpY2U7XHJcblxyXG4gICAgICAgIGxldCBwcmljZVBlclNoYXJlSHRtbDogYW55ID0ge1xyXG4gICAgICAgICAgICBsYXN0VHJhZGVkOiB0aGlzLmxhc3RUcmFkZWQsXHJcbiAgICAgICAgICAgIHRleHQ6ICfiiYggJCcgKyB0aGlzLmxhc3RQcmljZSArICcgcGVyIHNoYXJlJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcHJpY2VQZXJTaGFyZS5pbm5lckhUTUwgPSB0aGlzLnByaWNlUGVyU2hhcmVUZW1wbGF0ZShwcmljZVBlclNoYXJlSHRtbCk7XHJcblxyXG4gICAgICAgIGxldCBwcmljZVBlckFVc2RIdG1sOiBhbnkgPSB7XHJcbiAgICAgICAgICAgIGxhc3RUcmFkZWQ6IHRoaXMubGFzdFRyYWRlZCxcclxuICAgICAgICAgICAgdGV4dDogJzEgYVVTRCDiiYggJyArIHJvdW5kTnVtYmVyRGVjaW1hbCh0aGlzLnF0eVBlckRvbGxhciwgNikgKyAnICcgKyB0aGlzLnN5bWJvbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYVVzZFByaWNlUGVyU2hhcmUuaW5uZXJIVE1MID0gdGhpcy5wcmljZVBlclNoYXJlVGVtcGxhdGUocHJpY2VQZXJBVXNkSHRtbCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVRdWFudGl0eSgpO1xyXG5cclxuICAgICAgICBhVXNkUHJpY2VQZXJTaGFyZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xyXG4gICAgICAgIHByaWNlUGVyU2hhcmUucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWJ1c3knKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlUXVhbnRpdHkoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0KSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCBxdHlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy50cmFkZVR5cGUgKyAnSW5wdXRzIC50cmFkZV9pbnB1dCBpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFxdHlJbnB1dCkgcmV0dXJuO1xyXG4gICAgICAgIGlmICh0aGlzLnN5bWJvbCA9PT0gJ2FVU0QnKSB7XHJcbiAgICAgICAgICAgIHF0eUlucHV0LnZhbHVlID0gdGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC5xdWFudGl0eS5kaXYodGhpcy5vdGhlclRyYWRlUGFuZWxJbnB1dC5xdHlQZXJEb2xsYXIpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcXR5SW5wdXQudmFsdWUgPSB0aGlzLm90aGVyVHJhZGVQYW5lbElucHV0LnF1YW50aXR5Lm11bHRpcGxpZWRCeSh0aGlzLnF0eVBlckRvbGxhcikudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRRdWFudGl0eShxdHlJbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5sb2FkUHJvZ3Jlc3NiYXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGxvYWRQcm9ncmVzc2JhcigpIHtcclxuICAgICAgICBpZiAodGhpcy5xdWFudGl0eS5lcSgwKSB8fCB0aGlzLmJhbGFuY2UuZXEoMCkgfHwgdGhpcy50cmFkZVR5cGUgPT0gVHJhZGVUeXBlLkJ1eSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgcHJvZ3Jlc3NEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAucHJvZ3Jlc3MnKSBhcyBIVE1MUHJvZ3Jlc3NFbGVtZW50O1xyXG4gICAgICAgIGlmICghcHJvZ3Jlc3NEb20pIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IHBlcmNlbnRhZ2UgPSB0aGlzLnF1YW50aXR5LmRpdih0aGlzLmJhbGFuY2UpLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgcHJvZ3Jlc3NEb20udmFsdWUgPSBwZXJjZW50YWdlO1xyXG4gICAgICAgIHByb2dyZXNzRG9tLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG5cclxuICAgICAgICBsZXQgZXhjZWVkc0JhbGFuY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAuZXhjZWVkc193YWxsZXRfYmFsYW5jZScpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmIChwZXJjZW50YWdlID4gMSkge1xyXG4gICAgICAgICAgICBleGNlZWRzQmFsYW5jZS5jbGFzc0xpc3QucmVtb3ZlKCdkLW5vbmUnKTtcclxuICAgICAgICAgICAgcHJvZ3Jlc3NEb20uc2V0QXR0cmlidXRlKCdhcmlhLWludmFsaWQnLCAndHJ1ZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGV4Y2VlZHNCYWxhbmNlLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHN3aXRjaFBhbmVscyhzZWxsVHJhZGVQYW5lbElucHV0OiBUcmFkZVBhbmVsSW5wdXQsIGJ1eVRyYWRlUGFuZWxJbnB1dDogVHJhZGVQYW5lbElucHV0KTogUHJvbWlzZTxbVHJhZGVQYW5lbElucHV0LCBUcmFkZVBhbmVsSW5wdXRdPiB7XHJcbiAgICAgICAgbGV0IHNlbGxTeW1ib2wgPSBzZWxsVHJhZGVQYW5lbElucHV0LnN5bWJvbDtcclxuICAgICAgICBsZXQgc2VsbE5hbWUgPSBzZWxsVHJhZGVQYW5lbElucHV0Lm5hbWU7XHJcbiAgICAgICAgbGV0IHNlbGxMb2dvID0gc2VsbFRyYWRlUGFuZWxJbnB1dC5sb2dvO1xyXG4gICAgICAgIGxldCBzZWxsUXVhbnRpdHkgPSBzZWxsVHJhZGVQYW5lbElucHV0LnF1YW50aXR5O1xyXG4gICAgICAgIHNlbGxUcmFkZVBhbmVsSW5wdXQuc2V0U3ltYm9sKGJ1eVRyYWRlUGFuZWxJbnB1dC5zeW1ib2wsIGJ1eVRyYWRlUGFuZWxJbnB1dC5uYW1lLCBidXlUcmFkZVBhbmVsSW5wdXQubG9nbylcclxuICAgICAgICBzZWxsVHJhZGVQYW5lbElucHV0LnF1YW50aXR5ID0gYnV5VHJhZGVQYW5lbElucHV0LnF1YW50aXR5O1xyXG4gICAgICAgIGJ1eVRyYWRlUGFuZWxJbnB1dC5zZXRTeW1ib2woc2VsbFN5bWJvbCwgc2VsbE5hbWUsIHNlbGxMb2dvKVxyXG4gICAgICAgIGJ1eVRyYWRlUGFuZWxJbnB1dC5xdWFudGl0eSA9IHNlbGxRdWFudGl0eTtcclxuXHJcbiAgICAgICAgYXdhaXQgc2VsbFRyYWRlUGFuZWxJbnB1dC51cGRhdGVQYW5lbCgpO1xyXG4gICAgICAgIGF3YWl0IGJ1eVRyYWRlUGFuZWxJbnB1dC51cGRhdGVQYW5lbCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gW3NlbGxUcmFkZVBhbmVsSW5wdXQsIGJ1eVRyYWRlUGFuZWxJbnB1dF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNldFF1YW50aXR5KHZhbHVlIDogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09ICcnIHx8IHZhbHVlID09ICcwJykgcmV0dXJuO1xyXG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSBuZXcgQmlnTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB0aGlzLnN0clF1YW50aXR5ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgcXVhbnRpdHlGb3JtYXR0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN5bWJvbCA9PT0gJ2FVU0QnKSA/ICckJyArIHRoaXMucXVhbnRpdHkgOiB0aGlzLnF1YW50aXR5O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyB1cGRhdGVQYW5lbCgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVF1YW50aXR5KCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodHJ1ZSk7XHJcblxyXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZEJhbGFuY2UoKTtcclxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRMYXN0VHJhZGUoKTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgdG9nZ2xlTWF4QmFsYW5jZUxpbmsoKSB7XHJcbiAgICAgICAgbGV0IG1heEJhbGFuY2VEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMudHJhZGVUeXBlICsgJ0lucHV0cyAuYmFsYW5jZV9tYXgnKSBhcyBIVE1MRWxlbWVudDtcclxuICAgICAgICBpZiAoIW1heEJhbGFuY2VEb20pIHJldHVybjtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYmFsYW5jZS5lcSgwKSkge1xyXG4gICAgICAgICAgICBtYXhCYWxhbmNlRG9tLmNsYXNzTGlzdC5hZGQoJ2Qtbm9uZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1heEJhbGFuY2VEb20uY2xhc3NMaXN0LnJlbW92ZSgnZC1ub25lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGRpdiBjbGFzcz1cXFwiZ3JpZCB0cmFkZVN3aXRjaFxcXCI+XFxyXFxuICAgIDxhIHRpdGxlPVxcXCJTd2l0Y2ggdGhlIHRyYWRlXFxcIiBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJzd2l0Y2hCdG5cXFwiIGNsYXNzPVxcXCJvdXRsaW5lXFxcIj48L2E+XFxyXFxuPC9kaXY+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBUcmFkZVN3aXRjaEh0bWwgZnJvbSAnLi4vLi4vLi4vaHRtbC9lbGVtZW50cy90cmFkZXBhbmVsL1RyYWRlU3dpdGNoLmh0bWwnO1xyXG5pbXBvcnQgVHJhZGVQYW5lbElucHV0IGZyb20gXCIuL1RyYWRlUGFuZWxJbnB1dFwiO1xyXG5pbXBvcnQgRXhlY3V0ZVRyYWRlQnV0dG9uIGZyb20gXCIuL0V4ZWN1dGVUcmFkZUJ1dHRvblwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhZGVTd2l0Y2gge1xyXG5cclxuICAgIHRlbXBsYXRlIDogYW55ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoVHJhZGVTd2l0Y2hIdG1sKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHJlbmRlclRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbmRlcigpIHtcclxuICAgICAgICBsZXQgZG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRyYWRlU3dpdGNoJyk7XHJcbiAgICAgICAgaWYgKCFkb20pIHJldHVybjtcclxuXHJcbiAgICAgICAgZG9tLm91dGVySFRNTCA9IHRoaXMucmVuZGVyVG9TdHJpbmcoKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBiaW5kRXZlbnRzKHNlbGxUcmFkZVBhbmVsSW5wdXQgOiBUcmFkZVBhbmVsSW5wdXQsIGJ1eVRyYWRlUGFuZWxJbnB1dCA6IFRyYWRlUGFuZWxJbnB1dCwgZXhlY3V0ZVRyYWRlQnV0dG9uIDogRXhlY3V0ZVRyYWRlQnV0dG9uKSB7XHJcbiAgICAgICAgbGV0IGRvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zd2l0Y2hCdG4nKTtcclxuICAgICAgICBpZiAoIWRvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgW3NlbGxUcmFkZVBhbmVsSW5wdXQsIGJ1eVRyYWRlUGFuZWxJbnB1dF0gPSBhd2FpdCBUcmFkZVBhbmVsSW5wdXQuc3dpdGNoUGFuZWxzKHNlbGxUcmFkZVBhbmVsSW5wdXQsIGJ1eVRyYWRlUGFuZWxJbnB1dCk7XHJcblxyXG5cclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IEV4ZWN1dGVUcmFkZUJ1dHRvbiBmcm9tIFwiLi90cmFkZXBhbmVsL0V4ZWN1dGVUcmFkZUJ1dHRvblwiO1xyXG5pbXBvcnQgU3RvY2tQcmljZVNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvU3RvY2tQcmljZVNlcnZpY2VcIjtcclxuaW1wb3J0IHtUcmFkZVR5cGV9IGZyb20gXCIuLi8uLi9lbnVtcy9UcmFkZVR5cGVcIjtcclxuaW1wb3J0IFRyYWRlUGFuZWxJbnB1dCBmcm9tIFwiLi90cmFkZXBhbmVsL1RyYWRlUGFuZWxJbnB1dFwiO1xyXG5pbXBvcnQgQ29udHJhY3RJbmZvIGZyb20gXCIuLi8uLi9jb250cmFjdHMvQ29udHJhY3RJbmZvXCI7XHJcbmltcG9ydCBUcmFkZVN3aXRjaCBmcm9tIFwiLi90cmFkZXBhbmVsL1RyYWRlU3dpdGNoXCI7XHJcbmltcG9ydCBTZWN1cml0aWVzTGlzdE1vZGFsIGZyb20gXCIuLi9tb2RhbHMvU2VjdXJpdGllc0xpc3RNb2RhbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhZGVQYW5lbCB7XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcbiAgICBxdWFudGl0eSA6IG51bWJlcjtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgICAgIHRoaXMucXVhbnRpdHkgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXIoZWxlbWVudElkIDogc3RyaW5nLCBzeW1ib2w/IDogc3RyaW5nLCBuYW1lPyA6IHN0cmluZywgbG9nbz8gOiBzdHJpbmcsIGFkZHJlc3M/IDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50SWQpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuO1xyXG5cclxuICAgICAgICBsZXQgY29udHJhY3RJbmZvID0gQ29udHJhY3RJbmZvLmdldENvbnRyYWN0SW5mbygpO1xyXG5cclxuICAgICAgICBsZXQgc2VsbFRyYWRlSW5wdXQgPSBuZXcgVHJhZGVQYW5lbElucHV0KHRoaXMubW9yYWxpcywgXCJhVVNEXCIsIFwiYVVTRCBhdCBCcm9rZXJcIiwgXCIvaW1nL2F1c2QucG5nXCIsIGNvbnRyYWN0SW5mby5BVVNEX0FERFJFU1MsIFRyYWRlVHlwZS5TZWxsKTtcclxuICAgICAgICBsZXQgYnV5VHJhZGVJbnB1dCA6IFRyYWRlUGFuZWxJbnB1dDtcclxuICAgICAgICBpZiAoIXN5bWJvbCkge1xyXG4gICAgICAgICAgICBidXlUcmFkZUlucHV0ID0gbmV3IFRyYWRlUGFuZWxJbnB1dCh0aGlzLm1vcmFsaXMsIFwiU2VsZWN0IHN0b2NrXCIsIFwiXCIsIFwiXCIsIFwiXCIsIFRyYWRlVHlwZS5CdXkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1eVRyYWRlSW5wdXQgPSBuZXcgVHJhZGVQYW5lbElucHV0KHRoaXMubW9yYWxpcywgc3ltYm9sIGFzIHN0cmluZywgbmFtZSBhcyBzdHJpbmcsbG9nbyBhcyBzdHJpbmcsYWRkcmVzcyBhcyBzdHJpbmcsIFRyYWRlVHlwZS5CdXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc2VsbFRyYWRlSW5wdXQuc2V0T3RoZXJUcmFkZVBhbmVsSW5wdXQoYnV5VHJhZGVJbnB1dCk7XHJcbiAgICAgICAgYnV5VHJhZGVJbnB1dC5zZXRPdGhlclRyYWRlUGFuZWxJbnB1dChzZWxsVHJhZGVJbnB1dCk7XHJcblxyXG5cclxuICAgICAgICBsZXQgdHJhZGVTd2l0Y2ggPSBuZXcgVHJhZGVTd2l0Y2goKTtcclxuXHJcbiAgICAgICAgbGV0IHNlbGxJbnB1dCA9IHNlbGxUcmFkZUlucHV0LnJlbmRlclRvU3RyaW5nKCk7XHJcbiAgICAgICAgbGV0IGJ1eUlucHV0ID0gYnV5VHJhZGVJbnB1dC5yZW5kZXJUb1N0cmluZygpO1xyXG4gICAgICAgIGxldCBzd2l0Y2hIdG1sID0gdHJhZGVTd2l0Y2gucmVuZGVyVG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBzZWxsSW5wdXQgKyBzd2l0Y2hIdG1sICsgYnV5SW5wdXQ7XHJcblxyXG4gICAgICAgIGF3YWl0IHNlbGxUcmFkZUlucHV0LmxvYWRCYWxhbmNlKCk7XHJcbiAgICAgICAgYXdhaXQgYnV5VHJhZGVJbnB1dC5sb2FkQmFsYW5jZSgpO1xyXG4gICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgYXdhaXQgYnV5VHJhZGVJbnB1dC5sb2FkTGFzdFRyYWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGxUcmFkZUlucHV0LmJpbmRFdmVudHMoKTtcclxuICAgICAgICBidXlUcmFkZUlucHV0LmJpbmRFdmVudHMoKTtcclxuXHJcbiAgICAgICAgbGV0IGV4ZWN1dGVUcmFkZUJ1dHRvbiA9IG5ldyBFeGVjdXRlVHJhZGVCdXR0b24odGhpcy5tb3JhbGlzLCBzZWxsVHJhZGVJbnB1dCwgYnV5VHJhZGVJbnB1dCk7XHJcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVRyYWRlQnV0dG9uLnJlbmRlckJ1dHRvbigpO1xyXG5cclxuICAgICAgICB0cmFkZVN3aXRjaC5iaW5kRXZlbnRzKHNlbGxUcmFkZUlucHV0LCBidXlUcmFkZUlucHV0LCBleGVjdXRlVHJhZGVCdXR0b24pO1xyXG4gICAgICAgIHNlbGxUcmFkZUlucHV0Lm9uVXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYnV5VHJhZGVJbnB1dC5pc0RpcnR5KSBidXlUcmFkZUlucHV0LnVwZGF0ZVBhbmVsKCk7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVUcmFkZUJ1dHRvbi5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnV5VHJhZGVJbnB1dC5vblVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNlbGxUcmFkZUlucHV0LmlzRGlydHkpIHNlbGxUcmFkZUlucHV0LnVwZGF0ZVBhbmVsKCk7XHJcbiAgICAgICAgICAgIGV4ZWN1dGVUcmFkZUJ1dHRvbi5yZW5kZXJCdXR0b24oKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuICAgIHB1YmxpYyBmb3JtYXRCdXlQYW5lbChzeW1ib2wgOiBzdHJpbmcsIG5hbWUgOiBzdHJpbmcsIGxvZ28gOiBzdHJpbmcsIHRyYWRlVHlwZSA6IFRyYWRlVHlwZSwgY29udHJhY3RBZGRyZXNzIDogc3RyaW5nKSB7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpbWluYWxfbWFya2V0X3NlbGVjdF9zeW1ib2wnKSEuaW5uZXJIVE1MID0gc3ltYm9sO1xyXG4gICAgfVxyXG5cclxuXHJcbn0iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8ZGl2IGlkPVxcXCJ0cmFkaW5nUGFuZWxcXFwiPlxcclxcbiAgICA8YSBocmVmPVxcXCIjdXNlX3dhbGxldF9mb3Jfb3JkZXJzXFxcIiBpZD1cXFwidXNlX3dhbGxldF9mb3Jfb3JkZXJzX2xpbmtcXFwiIGNsYXNzPVxcXCJub3RfdmlzaWJsZVxcXCI+VHJhZGUgaW4geW91ciB3YWxsZXQgaW5zdGVhZCBvZlxcclxcbiAgICAgICAgaGVyZTwvYT5cXHJcXG4gICAgPGFydGljbGUgaWQ9XFxcImxpbWluYWxfbWFya2V0X3RyYWRlX3BhbmVsXFxcIj48L2FydGljbGU+XFxyXFxuICAgIDxkaXYgaWQ9XFxcImV4ZWN1dGluZy10cmFkZS1wcm9ncmVzc1xcXCIgY2xhc3M9XFxcImQtbm9uZVxcXCI+XFxyXFxuICAgICAgICA8ZGl2IGlkPVxcXCJwcm9ncmVzcy10ZXh0XFxcIj48L2Rpdj5cXHJcXG4gICAgICAgIDxwcm9ncmVzcz48L3Byb2dyZXNzPlxcclxcbiAgICA8L2Rpdj5cXHJcXG4gICAgPGJ1dHRvbiBpZD1cXFwibGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZVxcXCI+PC9idXR0b24+XFxyXFxuXFxyXFxuICAgIDxhcnRpY2xlIGlkPVxcXCJ1c2Vfd2FsbGV0X2Zvcl9vcmRlcnNcXFwiPlxcclxcblxcclxcbiAgICAgICAgPGgzPkhvdyB0byBidXkgaW4gd2FsbGV0PC9oMz5cXHJcXG4gICAgICAgIDx1bD5cXHJcXG4gICAgICAgICAgICA8bGk+SWYgeW91IGhhdmVuJ3QgYWRkZWQgYVVTRCB0byB5b3VyIHdhbGxldCwgbm93IGlzIHRoZSB0aW1lIC0gPHNtYWxsPjxhIGhyZWY9XFxcIlxcXCIgaWQ9XFxcImFkZEFVU0RUb1dhbGxldFxcXCI+Q2xpY2tcXHJcXG4gICAgICAgICAgICAgICAgaGVyZSB0byBhZGQgYVVTRCB0byB3YWxsZXQ8L2E+PC9zbWFsbD48L2xpPlxcclxcbiAgICAgICAgICAgIDxsaT48YSBocmVmPVxcXCJcXFwiIGNsYXNzPVxcXCJmaW5kU3ltYm9sXFxcIj5GaW5kIHN5bWJvbDwvYT4geW91IHdhbnQgdG8gYnV5ICYgY2xpY2sgXFxcIkdldCBhZGRyZXNzXFxcIjwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPkdvIHRvIHlvdXIgd2FsbGV0IGFuZCBmaW5kIHRoZSBhVVNEIHRva2VuLCBjbGljayBcXFwiU2VuZFxcXCI8L2xpPlxcclxcbiAgICAgICAgICAgIDxsaT5QYXN0ZSBpbiB0aGUgYWRkcmVzcyB5b3UganVzdCBjb3BpZWQgZm9yIHRoZSBSZWNlaXZlci5cXHJcXG4gICAgICAgICAgICAgICAgPHVsPlxcclxcbiAgICAgICAgICAgICAgICAgICAgPGxpPjxlbT5Ob3RlOiBJZiB5b3UgY2FuLCBzYXZlIHRoZSBhZGRyZXNzIHRvIHlvdXIgY29udGFjdCBsaXN0IGZvciBlYXN5IGFjY2VzcyBuZXh0IHRpbWU8L2VtPjwvbGk+XFxyXFxuICAgICAgICAgICAgICAgIDwvdWw+XFxyXFxuICAgICAgICAgICAgPC9saT5cXHJcXG5cXHJcXG4gICAgICAgICAgICA8bGk+VHlwZSBpbiB0aGUgYW1vdW50ICYgY2xpY2sgQ29uZmlybTwvbGk+XFxyXFxuICAgICAgICAgICAgPGxpPllvdSBoYXZlIG5vdyBib3VnaHQgdGhlIHNoYXJlcywgZG9uJ3QgZm9yZ2V0IHRvIDxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImZpbmRTeW1ib2xcXFwiPmFkZCB0aGUgdG9rZW4gdG8gd2FsbGV0PC9hPi4gJiMxMjc4ODE7PC9saT5cXHJcXG4gICAgICAgIDwvdWw+XFxyXFxuICAgICAgICA8ZGl2IHN0eWxlPVxcXCJ0ZXh0LWFsaWduOiBjZW50ZXI7XFxcIj5cXHJcXG4gICAgICAgICAgICA8IS0tXFxyXFxuICAgICAgICAgICAgICAgICAgICAgICAgPGlmcmFtZSB3aWR0aD1cXFwiMzgwXFxcIiBoZWlnaHQ9XFxcIjUwMFxcXCIgc3JjPVxcXCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9tMWlOb3RnYWljND9hdXRvcGxheT0xJmNjX2xvYWRfcG9saWN5PTEmcGxheWxpc3Q9bTFpTm90Z2FpYzQmbG9vcD0xXFxcIiB0aXRsZT1cXFwiWW91VHViZSB2aWRlbyBwbGF5ZXJcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiBhbGxvdz1cXFwiYWNjZWxlcm9tZXRlcjsgYXV0b3BsYXk7IGNsaXBib2FyZC13cml0ZTsgZW5jcnlwdGVkLW1lZGlhOyBneXJvc2NvcGU7IHBpY3R1cmUtaW4tcGljdHVyZVxcXCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPlxcclxcbiAgICAgICAgICAgIC0tPlxcclxcbiAgICAgICAgPC9kaXY+XFxyXFxuXFxyXFxuXFxyXFxuICAgICAgICA8aDM+U2VsbCB5b3VyIHNlY3VyaXRpZXM8L2gzPlxcclxcblxcclxcbiAgICAgICAgPHVsPlxcclxcbiAgICAgICAgICAgIDxsaT5GaW5kIHRoZSB0b2tlbiB5b3Ugd2FudCBzbyBzZWxsIGluIHlvdSB3YWxsZXQgYW5kIGNsaWNrIFNlbmQ8L2xpPlxcclxcbiAgICAgICAgICAgIDxsaT5QdXQgdGhlIGluIHRoZSBhVVNEIGFkZHJlc3M8YnIvPjxpbnB1dCBpZD1cXFwiYVVzZEFkZHJlc3NcXFwiIHZhbHVlPVxcXCJ7e0FVU0RBZGRyZXNzfX1cXFwiPlxcclxcbiAgICAgICAgICAgICAgICA8dWw+XFxyXFxuICAgICAgICAgICAgICAgICAgICA8bGk+PGVtPk5vdGU6IElmIHlvdSBjYW4sIHNhdmUgdGhlIGFkZHJlc3MgdG8geW91ciBjb250YWN0IGxpc3QgZm9yIGVhc3kgYWNjZXNzIG5leHQgdGltZTwvZW0+PC9saT5cXHJcXG4gICAgICAgICAgICAgICAgPC91bD5cXHJcXG4gICAgICAgICAgICA8L2xpPlxcclxcbiAgICAgICAgICAgIDxsaT5UeXBlIGluIHRoZSBxdWFudGl0eSBvZiBzaGFyZXMgeW91IHdhbnQgdG8gc2VsbCAmIGNsaWNrIENvbmZpcm08L2xpPlxcclxcbiAgICAgICAgICAgIDxsaT5Zb3UgaGF2ZSBub3cgc29sZCB0aGUgc2hhcmVzICYjMTI3ODgxOzwvbGk+XFxyXFxuICAgICAgICA8L3VsPlxcclxcblxcclxcbiAgICA8L2FydGljbGU+XFxyXFxuPC9kaXY+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIlxcclxcblxcclxcbiAgICBZb3UgY2FuIGNvcHkgdGhlIGFkZHJlc3Mgb2Yge3tzeW1ib2x9fSBhbmQgaW1wb3J0IGl0IGludG8geW91ciB3YWxsZXRcXHJcXG4gICAgPGlucHV0IGlkPVxcXCJ0b2tlbkFkZHJlc3NcXFwiIHZhbHVlPVxcXCJ7e3Rva2VuQWRkcmVzc319XFxcIiAvPlxcclxcblxcclxcblwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJpbXBvcnQgVHJhZGVQYW5lbCBmcm9tIFwiLi4vZWxlbWVudHMvVHJhZGVQYW5lbFwiO1xyXG5pbXBvcnQgVHJhZGVQYWdlSHRtbCBmcm9tIFwiLi4vLi4vaHRtbC9wYWdlcy90cmFkZS5odG1sXCI7XHJcbmltcG9ydCBDb250cmFjdEluZm8gZnJvbSBcIi4uLy4uL2NvbnRyYWN0cy9Db250cmFjdEluZm9cIjtcclxuaW1wb3J0IFNlY3VyaXRpZXNMaXN0TW9kYWwgZnJvbSBcIi4uL21vZGFscy9TZWN1cml0aWVzTGlzdE1vZGFsXCI7XHJcbmltcG9ydCBBVVNEU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9BVVNEU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlclNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvVXNlclNlcnZpY2VcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9XYWxsZXRIZWxwZXJcIjtcclxuaW1wb3J0IE1vZGFsIGZyb20gXCIuLi9tb2RhbHMvTW9kYWxcIjtcclxuaW1wb3J0IENvcHlUb2tlbkFkZHJlc3NUb0FkZFRvV2FsbGV0IGZyb20gJy4uLy4uL2h0bWwvbW9kYWwvQ29weVRva2VuQWRkcmVzc1RvQWRkVG9XYWxsZXQuaHRtbCc7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSBcImJpZ251bWJlci5qc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhZGVQYWdlIHtcclxuXHJcbiAgICBtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIGxvYWQoc3ltYm9sPzogc3RyaW5nLCBuYW1lPzogc3RyaW5nLCBsb2dvPzogc3RyaW5nLCBhZGRyZXNzPzogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbl9jb250YWluZXInKTtcclxuICAgICAgICBpZiAoIW1haW5Db250YWluZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGNvbnRyYWN0SW5mbyA9IENvbnRyYWN0SW5mby5nZXRDb250cmFjdEluZm8oKTtcclxuXHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShUcmFkZVBhZ2VIdG1sKTtcclxuICAgICAgICBtYWluQ29udGFpbmVyLmlubmVySFRNTCA9IHRlbXBsYXRlKHtBVVNEQWRkcmVzczogY29udHJhY3RJbmZvLkFVU0RfQUREUkVTU30pO1xyXG5cclxuICAgICAgICBsZXQgdHJhZGVQYW5lbCA9IG5ldyBUcmFkZVBhbmVsKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgYXdhaXQgdHJhZGVQYW5lbC5yZW5kZXIoJ2xpbWluYWxfbWFya2V0X3RyYWRlX3BhbmVsJyk7XHJcblxyXG4gICAgICAgIGlmIChzeW1ib2wpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZWxlY3RTeW1ib2woc3ltYm9sLCBuYW1lISwgbG9nbyEsIGFkZHJlc3MhKVxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB1c2VyID0gbmV3IFVzZXJTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGV0aEFkZHJlc3MgPSB1c2VyLmdldEV0aEFkZHJlc3MoKTtcclxuXHJcbiAgICAgICAgbGV0IGFVU0RTZXJ2aWNlID0gbmV3IEFVU0RTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IGF1c2RBbW91bnQgPSBuZXcgQmlnTnVtYmVyKDApO1xyXG4gICAgICAgIGlmIChldGhBZGRyZXNzKSB7XHJcbiAgICAgICAgICAgIGF1c2RBbW91bnQgPSBhd2FpdCBhVVNEU2VydmljZS5nZXRBVVNEQmFsYW5jZU9mKGV0aEFkZHJlc3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHVzZXJXYWxsZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndXNlX3dhbGxldF9mb3Jfb3JkZXJzJyk7XHJcbiAgICAgICAgbGV0IHVzZXJXYWxsZXRMaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZV93YWxsZXRfZm9yX29yZGVyc19saW5rJyk7XHJcbiAgICAgICAgaWYgKGF1c2RBbW91bnQuZXEoMCkpIHtcclxuICAgICAgICAgICAgdXNlcldhbGxldD8uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIHVzZXJXYWxsZXRMaW5rPy5jbGFzc0xpc3QuYWRkKCdub3RfdmlzaWJsZScpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHVzZXJXYWxsZXQ/LmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICB1c2VyV2FsbGV0TGluaz8uY2xhc3NMaXN0LnJlbW92ZSgnbm90X3Zpc2libGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBmaW5kU3ltYm9scyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maW5kU3ltYm9sJyk7XHJcbiAgICAgICAgZmluZFN5bWJvbHM/LmZvckVhY2goZmluZFN5bWJvbCA9PiB7XHJcbiAgICAgICAgICAgIGZpbmRTeW1ib2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc2VjdXJpdGllc01vZGFsID0gbmV3IFNlY3VyaXRpZXNMaXN0TW9kYWwodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgICAgIHNlY3VyaXRpZXNNb2RhbC5zaG93TW9kYWwoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3VyaXRpZXNNb2RhbC5oaWRlTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBsZXQgYWRkQVVTRFRvV2FsbGV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FkZEFVU0RUb1dhbGxldCcpO1xyXG4gICAgICAgIGFkZEFVU0RUb1dhbGxldD8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHdhbGxldEhlbHBlciA9IG5ldyBXYWxsZXRIZWxwZXIodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgd2FsbGV0SGVscGVyLmFkZFRva2VuVG9XYWxsZXQoY29udHJhY3RJbmZvLkFVU0RfQUREUkVTUywgJ2FVU0QnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbW9kYWwgPSBuZXcgTW9kYWwoKTtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShDb3B5VG9rZW5BZGRyZXNzVG9BZGRUb1dhbGxldCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlKHtzeW1ib2w6ICdhVVNEJywgdG9rZW5BZGRyZXNzOiBjb250cmFjdEluZm8uQVVTRF9BRERSRVNTfSk7XHJcbiAgICAgICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ0FkZCBhVVNEIHRvIHdhbGxldCcsIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICB9O1xyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzZWxlY3RTeW1ib2woc3ltYm9sOiBzdHJpbmcsIG5hbWU6IHN0cmluZywgbG9nbzogc3RyaW5nLCBhZGRyZXNzOiBzdHJpbmcpIHtcclxuICAgICAgICBsZXQgdHJhZGVQYW5lbCA9IG5ldyBUcmFkZVBhbmVsKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgYXdhaXQgdHJhZGVQYW5lbC5yZW5kZXIoJ2xpbWluYWxfbWFya2V0X3RyYWRlX3BhbmVsJywgc3ltYm9sLCBuYW1lLCBsb2dvLCBhZGRyZXNzKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG4iLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCJcXHJcXG48YXJ0aWNsZSBpZD1cXFwic3RvY2tMaXN0XFxcIj5cXHJcXG4gPGRpdiBpZD1cXFwidWFcXFwiPjwvZGl2PlxcclxcbiA8ZGl2IGlkPVxcXCJsaXN0X29mX3NlY3VyaXRpZXNcXFwiPnt7e3NlY3VyaXRpZXN9fX08L2Rpdj5cXHJcXG5cXHJcXG48L2FydGljbGU+XCI7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBjb2RlOyIsImltcG9ydCBMaW1pbmFsTWFya2V0U2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmxvY2tjaGFpbi9MaW1pbmFsTWFya2V0U2VydmljZVwiO1xyXG5pbXBvcnQgU2VjdXJpdGllc0xpc3QgZnJvbSBcIi4uLy4uL3VpL2VsZW1lbnRzL1NlY3VyaXRpZXNMaXN0XCI7XHJcbmltcG9ydCBUcmFkZVBhZ2UgZnJvbSBcIi4uL3BhZ2VzL1RyYWRlUGFnZVwiO1xyXG5pbXBvcnQgU3RvY2tzUGFnZUh0bWwgZnJvbSAnLi4vLi4vaHRtbC9wYWdlcy9zdG9ja3NwYWdlLmh0bWwnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvY2tzUGFnZSB7XHJcblx0bW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzO1xyXG5cdGNvbnN0cnVjdG9yKG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcykge1xyXG5cdFx0dGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBhc3luYyBsb2FkKCkge1xyXG5cdFx0bGV0IG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbl9jb250YWluZXInKTtcclxuXHRcdGlmICghbWFpbkNvbnRhaW5lcikgcmV0dXJuO1xyXG5cclxuXHRcdGxldCBzZWN1cml0aWVzTGlzdCA9IG5ldyBTZWN1cml0aWVzTGlzdCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBzZWN1cml0aWVzID0gYXdhaXQgc2VjdXJpdGllc0xpc3QucmVuZGVyKCk7XHJcblxyXG5cdFx0bGV0IHRlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKFN0b2Nrc1BhZ2VIdG1sKTtcclxuXHRcdG1haW5Db250YWluZXIuaW5uZXJIVE1MID0gdGVtcGxhdGUoe3NlY3VyaXRpZXM6c2VjdXJpdGllc30pO1xyXG5cclxuXHRcdGF3YWl0IHNlY3VyaXRpZXNMaXN0LmxvYWRNb3JlKCk7XHJcblxyXG5cdFx0YXdhaXQgc2VjdXJpdGllc0xpc3QuYmluZEV2ZW50cyhhc3luYyAoc3ltYm9sLCBuYW1lLCBsb2dvKSA9PiB7XHJcblx0XHRcdGxldCBsaW1pbmFsTWFya2V0U2VydmljZSA9IG5ldyBMaW1pbmFsTWFya2V0U2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG5cdFx0XHRsZXQgYWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG5cclxuXHRcdFx0bGV0IHRyYWRlUGFnZSA9IG5ldyBUcmFkZVBhZ2UodGhpcy5tb3JhbGlzKTtcclxuXHRcdFx0d2luZG93LnNjcm9sbFRvKDAsIDApO1xyXG5cdFx0XHRoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnQnV5IHN0b2NrcycsICcjL3RyYWRlJyk7XHJcblx0XHRcdGF3YWl0IHRyYWRlUGFnZS5sb2FkKHN5bWJvbCwgbmFtZSwgbG9nbywgYWRkcmVzcyk7XHJcblx0XHR9KVxyXG5cdH07XHJcblxyXG59XHJcbiIsIi8vIE1vZHVsZVxudmFyIGNvZGUgPSBcIjxoMz5Eb2N1bWVudHM8L2gzPlxcclxcbjxwPlRoZXNlIGFyZSB5b3VyIGRvY3VtZW50cyBmb3IgeW91ciB0cmFkZXMsIGdlbmVyYXRlZCBieSB0aGUgYnJva2VyLiBUaGVzZSBkb2N1bWVudHMgYXJlIHRyYWRlIGNvbmZpcm1hdGlvbiAmIG1vbnRobHkgc3RhdGVtZW50cy5cXHJcXG5cXHRUaGV5IGFyZSBnZW5lcmF0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgZGF5LCBiZXR3ZWVuIDA2OjMwUE0tMDc6MzBQTSBFU1QuXFxyXFxuPC9wPlxcclxcbnt7I2lmIHJlc3VsdH19XFxyXFxuPHRhYmxlIGNsYXNzPVxcXCJ0YWJsZSB0YWJsZS1ob3ZlclxcXCI+XFxyXFxuXFx0PHRoZWFkPlxcclxcblxcdFxcdDx0cj5cXHJcXG5cXHRcXHRcXHQ8dGg+VHlwZTwvdGg+XFxyXFxuXFx0XFx0XFx0PHRoPkRhdGU8L3RoPlxcclxcblxcdFxcdFxcdDx0aD5Eb3dubG9hZDwvdGg+XFxyXFxuXFx0XFx0PC90cj5cXHJcXG5cXHQ8L3RoZWFkPlxcclxcblxcdDx0Ym9keT5cXHJcXG5cXHRcXHR7eyNlYWNoIHJlc3VsdH19XFxyXFxuXFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdDx0ZCB0aXRsZT1cXFwie3tpZH19XFxcIj57e3R5cGV9fTwvYT48L3RkPlxcclxcblxcdFxcdFxcdDx0ZD57e2RhdGV9fTwvdGQ+XFxyXFxuXFx0XFx0XFx0PHRkPjxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImRvd25sb2FkRG9jXFxcIiBkYXRhLWRvY2lkPVxcXCJ7e2lkfX1cXFwiPkRvd25sb2FkPC9hPjwvdGQ+XFxyXFxuXFx0XFx0PC90cj5cXHJcXG5cXHRcXHR7ey9lYWNofX1cXHJcXG5cXHQ8L3Rib2R5PlxcclxcbjwvdGFibGU+XFxyXFxue3svaWZ9fVwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCJcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvY3VtZW50U2VydmljZSB7XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnRzKCkge1xyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLm1vcmFsaXMuQ2xvdWQucnVuKCdkb2N1bWVudHMnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0RG9jdW1lbnQoZG9jdW1lbnRJZCA6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcclxuICAgICAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oXCJkb3dubG9hZFwiLCBwYXJhbXMpO1xyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiVG9rZW4gZm9yIHt7c3ltYm9sfX0gZG9lcyBub3QgZXhpc3QuIFlvdSBjYW4gY2xpY2sgdGhlIGJ1dHRvbiBiZWxvdyB0byBjcmVhdGUgdGhlIHRva2VuLiBUaGlzIHdpbGwgY29zdCBhIGJpdCBvZiBnYXMuXFxyXFxuPGJyIC8+PGJyIC8+XFxyXFxuQWZ0ZXIgdGhlIHRva2VuIGhhcyBiZWVuIGNyZWF0ZWQgd2Ugd2lsbCB0cnkgdG8gYWRkIGl0IHRvIHlvdXIgd2FsbGV0LlxcclxcbjxiciAvPjxiciAvPlxcclxcbjxidXR0b24gaWQ9XFxcImNyZWF0ZVRva2VuQnRuXFxcIj5DcmVhdGUgdG9rZW48L2J1dHRvbj5cXHJcXG5cXHJcXG48ZGl2IGNsYXNzPVxcXCJkLW5vbmVcXFwiIGlkPVxcXCJjb3B5QWRkcmVzc0luZm9cXFwiPlxcclxcbiAgICBZb3UgY2FuIGNvcHkgdGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIGFuZCBpbXBvcnQgaXQgaW50byB5b3VyIHdhbGxldFxcclxcbiAgICA8aW5wdXQgaWQ9XFxcInRva2VuQWRkcmVzc1xcXCIgLz5cXHJcXG5cXHJcXG48L2Rpdj5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiaW1wb3J0IE1vZGFsIGZyb20gXCIuL01vZGFsXCI7XHJcbmltcG9ydCBDcmVhdGVUb2tlbkh0bWwgZnJvbSAnLi4vLi4vaHRtbC9tb2RhbC9DcmVhdGVUb2tlbi5odG1sJztcclxuaW1wb3J0IExpbWluYWxNYXJrZXRTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9ibG9ja2NoYWluL0xpbWluYWxNYXJrZXRTZXJ2aWNlXCI7XHJcbmltcG9ydCBXYWxsZXRIZWxwZXIgZnJvbSBcIi4uLy4uL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCB7QWRkcmVzc1plcm99IGZyb20gXCIuLi8uLi91dGlsL0hlbHBlclwiO1xyXG5pbXBvcnQgTG9hZGluZ0hlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9Mb2FkaW5nSGVscGVyXCI7XHJcbmltcG9ydCBCbG9ja2NoYWluRXJyb3IgZnJvbSBcIi4uLy4uL2Vycm9ycy9CbG9ja2NoYWluRXJyb3JcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyZWF0ZVRva2VuIHtcclxuICAgIG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcztcclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcykge1xyXG4gICAgICAgIHRoaXMubW9yYWxpcyA9IG1vcmFsaXM7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHNob3coc3ltYm9sIDogc3RyaW5nKSB7XHJcbiAgICAgICAgbGV0IG1vZGFsID0gbmV3IE1vZGFsKCk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShDcmVhdGVUb2tlbkh0bWwpO1xyXG5cclxuXHJcbiAgICAgICAgbW9kYWwuc2hvd01vZGFsKFwiVG9rZW4gXCIgKyBzeW1ib2wgKyBcIiBkb2Vzbid0IGV4aXN0XCIsIHRlbXBsYXRlKHtzeW1ib2w6c3ltYm9sfSkpO1xyXG5cclxuICAgICAgICBsZXQgYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NyZWF0ZVRva2VuQnRuJykgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKCFidG4pIHJldHVybjtcclxuXHJcbiAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKCkgPT4ge1xyXG4gICAgICAgICAgICBMb2FkaW5nSGVscGVyLnNldExvYWRpbmcoYnRuISk7XHJcblxyXG4gICAgICAgICAgICBsZXQgbGltaW5hbE1hcmtldFNlcnZpY2UgPSBuZXcgTGltaW5hbE1hcmtldFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSBhd2FpdCBsaW1pbmFsTWFya2V0U2VydmljZS5nZXRTeW1ib2xDb250cmFjdEFkZHJlc3Moc3ltYm9sKTtcclxuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT09IEFkZHJlc3NaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgbGltaW5hbE1hcmtldFNlcnZpY2UuY3JlYXRlVG9rZW4oc3ltYm9sLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnRuLmlubmVySFRNTCA9ICdDcmVhdGluZyB0b2tlbi4gR2l2ZSBpdCBmZXcgc2Vjb25kcyc7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgQmxvY2tjaGFpbkVycm9yICYmIHJlc3VsdC5jb2RlID09IEJsb2NrY2hhaW5FcnJvci5Vc2VyQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IHJlc3VsdCBhcyBzdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICAgICAgICAgIGJ0bi5pbm5lckhUTUwgPSAnQWRkIHRva2VuIHRvIHdhbGxldCc7XHJcbiAgICAgICAgICAgIGxldCB3YWxsZXRIZWxwZXIgPSBuZXcgV2FsbGV0SGVscGVyKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgIGF3YWl0IHdhbGxldEhlbHBlci5hZGRUb2tlblRvV2FsbGV0KGFkZHJlc3MsIHN5bWJvbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRva2VuQWRkcmVzc0lucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rva2VuQWRkcmVzcycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkFkZHJlc3NJbnB1dCkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIHRva2VuQWRkcmVzc0lucHV0LmlubmVySFRNTCA9IGFkZHJlc3M7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29weUFkZHJlc3NJbmZvJykhLmNsYXNzTGlzdC5yZW1vdmUoJ2Qtbm9uZScpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG59IiwiLy8gTW9kdWxlXG52YXIgY29kZSA9IFwiPGFydGljbGUgY2xhc3M9XFxcImxvYWRlZC1jb250ZW50MlxcXCI+XFxyXFxuXFx0PGgzPlBvc2l0aW9uczwhLS0gPGEgaHJlZj1cXFwiXFxcIiByb2xlPVxcXCJidXR0b25cXFwiIGlkPVxcXCJzeW5jV2FsbGV0XFxcIj5TeW5jIHdhbGxldDwvYT4tLT48L2gzPlxcclxcblxcdDxmaWd1cmU+XFxyXFxuXFx0PHRhYmxlPlxcclxcblxcdFxcdDx0aGVhZD5cXHJcXG5cXHRcXHRcXHQ8dHI+XFxyXFxuXFx0XFx0XFx0XFx0PHRoPjwvdGg+XFxyXFxuXFx0XFx0XFx0XFx0PHRoPlN5bWJvbDwvdGg+XFxyXFxuXFx0XFx0XFx0XFx0PHRoPkN1cnJlbnQgcHJpY2U8L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5BdmcuIGVudHJ5IHZhbHVlPC90aD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGg+UXVhbnRpdHk8L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5NYXJrZXQgdmFsdWU8L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5VbnJlYWxpemUgUEw8L3RoPlxcclxcblxcdFxcdFxcdFxcdDx0aD5UcmFkZTwvdGg+XFxyXFxuXFx0XFx0XFx0XFx0PHRoPkFkZCB0byB3YWxsZXQ8L3RoPlxcclxcblxcdFxcdFxcdDwvdHI+XFxyXFxuXFx0XFx0PC90aGVhZD5cXHJcXG5cXHRcXHQ8dGJvZHk+XFxyXFxuXFx0XFx0XFx0e3sjaWYgcmVzdWx0fX1cXHJcXG5cXHRcXHRcXHR7eyNlYWNoIHJlc3VsdH19XFxyXFxuXFx0XFx0XFx0PHRyPlxcclxcblxcdFxcdFxcdFxcdDx0ZCBjbGFzcz1cXFwic3ltYm9sX2xvZ29cXFwiPjxpbWcgaWQ9XFxcInN5bWJvbF9sb2dvX3t7c3ltYm9sfX1cXFwiIHNyYz1cXFwiL2ltZy9sb2dvcy9kZWZhdWx0X2xvZ28ucG5nXFxcIiAvPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0PHRkPjxhIGhyZWY9XFxcImh0dHBzOi8vc3RyaWtlLm1hcmtldC9zdG9ja3Mve3tzeW1ib2x9fVxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiPnt7c3ltYm9sfX08L2E+PC90ZD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGQ+e3tjdXJyZW50X3ByaWNlfX08L3RkPlxcclxcblxcdFxcdFxcdFxcdDx0ZD57e3JvdW5kMiBhdmdfZW50cnlfcHJpY2V9fTwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0PHRkPnt7cm91bmQyIHF0eX19PC90ZD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGQ+JHt7cm91bmQgbWFya2V0X3ZhbHVlfX08L3RkPlxcclxcblxcdFxcdFxcdFxcdDx0ZCBjbGFzcz1cXFwie3tjbGFzc0NvbG9yIHVucmVhbGl6ZWRfcGx9fVxcXCI+JHt7cm91bmQgdW5yZWFsaXplZF9wbH19ICh7e3BlcmMgdW5yZWFsaXplZF9wbHBjfX0pPC90ZD5cXHJcXG5cXHRcXHRcXHRcXHQ8dGQ+PGEgaHJlZj1cXFwiI1xcXCIgY2xhc3M9XFxcInRyYWRlU2VjdXJpdHlcXFwiIGRhdGEtc3ltYm9sPVxcXCJ7e3N5bWJvbH19XFxcIiBkYXRhLXF0eT17e3F0eX19PlRyYWRlPC9hPjwvdGQ+XFxyXFxuXFx0XFx0XFx0XFx0PHRkPjxhIGhyZWY9XFxcIlxcXCIgY2xhc3M9XFxcImFkZFRvV2FsbGV0XFxcIiBkYXRhLXN5bWJvbD1cXFwie3tzeW1ib2x9fVxcXCI+QWRkPC9hPjwvdGQ+XFxyXFxuXFx0XFx0XFx0PC90cj5cXHJcXG5cXHRcXHRcXHR7ey9lYWNofX1cXHJcXG5cXHRcXHRcXHR7ey9pZn19XFxyXFxuXFx0XFx0PC90Ym9keT5cXHJcXG5cXHQ8L3RhYmxlPlxcclxcblxcdDwvZmlndXJlPlxcclxcblxcdDxkaXYgaWQ9XFxcImRvY3VtZW50c1xcXCI+PC9kaXY+XFxyXFxuXFxyXFxuPC9hcnRpY2xlPlwiO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgY29kZTsiLCIvLyBNb2R1bGVcbnZhciBjb2RlID0gXCI8YXJ0aWNsZT5cXHJcXG4gICAgSWYgeW91ciB3YWxsZXQgaXMgb3V0IG9mIHN5bmMgd2l0aCB5b3VyIHBvc2l0aW9uIHlvdSBjYW4gc3luYyBpdCBoZXJlLiBUaGlzIGhhcHBlbnMgd2hlbiB5b3UgbW92ZSBmcm9tXFxyXFxuICAgIG9uZSBjaGFpbiB0byBhbm90aGVyLiBJZiB5b3UgbGlrZSB0byBzd2l0Y2ggdG8gbmV3IGNoYWluIGNsaWNrIHRoZSBidXR0b24gYmVsb3cuXFxyXFxuICAgIDxici8+PGJyLz5cXHJcXG4gICAgWW91IHdpbGwgYmUgYXNrZWQgdG8gY29uZmlybSBhIHRyYW5zYWN0aW9uIG9mIHt7dG90YWxDb3N0fX0ge3tOYXRpdmVTeW1ib2x9fSAoJHt7cHJpY2VJbk5hdGl2ZVRva2VufX0pLlxcclxcbiAgICBFYWNoIHN0b2NrIGNvc3RzIHt7Y29zdFBlclNoYXJlfX0ge3tOYXRpdmVTeW1ib2x9fSB0byBzeW5jLiBZb3UgaGF2ZSB0b3RhbCBvZiB7e3NoYXJlQ291bnR9fSBzaGFyZS5cXHJcXG4gICAgPGJyLz48YnIvPlxcclxcbiAgICA8YnV0dG9uIGlkPVxcXCJzeW5jQWxsUG9zaXRpb25zXFxcIj5TeW5jIHN0b2NrIHRvIG15IHdhbGxldDwvYnV0dG9uPlxcclxcbjwvYXJ0aWNsZT5cIjtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IGNvZGU7IiwiXHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NpdGlvbnNTZXJ2aWNlIHtcclxuICAgIG1vcmFsaXMgOiB0eXBlb2YgTW9yYWxpcztcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXMpIHtcclxuICAgICAgICB0aGlzLm1vcmFsaXMgPSBtb3JhbGlzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZXRQb3NpdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oJ3Bvc2l0aW9ucycpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHtBZGRyZXNzWmVyb30gZnJvbSAnLi4vLi4vdXRpbC9IZWxwZXInO1xyXG5pbXBvcnQgTGltaW5hbE1hcmtldFNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2Jsb2NrY2hhaW4vTGltaW5hbE1hcmtldFNlcnZpY2VcIjtcclxuaW1wb3J0IFNlY3VyaXRpZXNTZXJ2aWNlIGZyb20gXCIuLi8uLi9zZXJ2aWNlcy9icm9rZXIvU2VjdXJpdGllc1NlcnZpY2VcIjtcclxuaW1wb3J0IFdhbGxldEhlbHBlciBmcm9tIFwiLi4vLi4vdXRpbC9XYWxsZXRIZWxwZXJcIjtcclxuaW1wb3J0IERvY3VtZW50c0h0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9kb2N1bWVudHMuaHRtbCc7XHJcbmltcG9ydCBEb2N1bWVudFNlcnZpY2UgZnJvbSBcIi4uLy4uL3NlcnZpY2VzL2JhY2tlbmQvRG9jdW1lbnRTZXJ2aWNlXCI7XHJcbmltcG9ydCBNb2RhbCBmcm9tIFwiLi4vLi4vdWkvbW9kYWxzL01vZGFsXCI7XHJcbmltcG9ydCBDcmVhdGVUb2tlbiBmcm9tIFwiLi4vLi4vdWkvbW9kYWxzL0NyZWF0ZVRva2VuXCI7XHJcbmltcG9ydCBBZGRyZXNzSW5mb0h0bWwgZnJvbSAnLi4vLi4vaHRtbC9lbGVtZW50cy9BZGRyZXNzSW5mby5odG1sJztcclxuaW1wb3J0IFBvc2l0aW9uUGFnZUh0bWwgZnJvbSAnLi4vLi4vaHRtbC9wYWdlcy9wb3NpdGlvbnMuaHRtbCc7XHJcbmltcG9ydCBTeW5jU3RvY2tIdG1sIGZyb20gJy4uLy4uL2h0bWwvbW9kYWwvU3luY1N0b2NrLmh0bWwnO1xyXG5pbXBvcnQgUG9zaXRpb25zU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Qb3NpdGlvbnNTZXJ2aWNlXCI7XHJcbmltcG9ydCBIYW5kbGViYXJIZWxwZXJzIGZyb20gXCIuLi8uLi91dGlsL0hhbmRsZWJhckhlbHBlcnNcIjtcclxuaW1wb3J0IFRyYWRlUGFnZSBmcm9tIFwiLi9UcmFkZVBhZ2VcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi8uLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9zaXRpb25zUGFnZSB7XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcbiAgICBkb2N1bWVudFNlcnZpY2UgOiBEb2N1bWVudFNlcnZpY2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgICAgICB0aGlzLmRvY3VtZW50U2VydmljZSA9IG5ldyBEb2N1bWVudFNlcnZpY2UodGhpcy5tb3JhbGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZCgpIHtcclxuXHJcbiAgICAgICAgbGV0IG1haW5Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFpbl9jb250YWluZXInKTtcclxuICAgICAgICBpZiAoIW1haW5Db250YWluZXIpIHJldHVybjtcclxuXHJcblxyXG4gICAgICAgIGxldCBwb3NpdGlvblNlcnZpY2UgPSBuZXcgUG9zaXRpb25zU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCBwb3NpdGlvbnMgPSBhd2FpdCBwb3NpdGlvblNlcnZpY2UuZ2V0UG9zaXRpb25zKCk7XHJcblxyXG4gICAgICAgIEhhbmRsZWJhckhlbHBlcnMucmVnaXN0ZXJIZWxwZXJzKCk7XHJcblxyXG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShQb3NpdGlvblBhZ2VIdG1sKTtcclxuICAgICAgICBtYWluQ29udGFpbmVyLmlubmVySFRNTCA9IHRlbXBsYXRlKHtyZXN1bHQ6cG9zaXRpb25zfSk7XHJcblxyXG4gICAgICAgIGxldCBzeW5jV2FsbGV0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNXYWxsZXQnKTtcclxuICAgICAgICBpZiAoc3luY1dhbGxldEJ0bikge1xyXG4gICAgICAgICAgICBzeW5jV2FsbGV0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNBbGxUb2tlbnMoKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBsZXQgc3ltYm9scyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XHJcbiAgICAgICAgY29uc3Qgc2VsbExpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndHJhZGVTZWN1cml0eScpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsbExpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gc2VsbExpbmtzW2ldIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICBsZXQgc3ltYm9sID0gZWxlbWVudC5kYXRhc2V0LnN5bWJvbDtcclxuICAgICAgICAgICAgaWYgKCFzeW1ib2wpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgc3ltYm9scy5wdXNoKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICBzZWxsTGlua3NbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgZWxlbWVudCA9IGV2dC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sID0gZWxlbWVudC5kYXRhc2V0LnN5bWJvbDtcclxuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxpbWluYWxNYXJrZXRTZXJ2aWNlID0gbmV3IExpbWluYWxNYXJrZXRTZXJ2aWNlKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgY29udHJhY3RBZGRyZXNzID0gYXdhaXQgbGltaW5hbE1hcmtldFNlcnZpY2UuZ2V0U3ltYm9sQ29udHJhY3RBZGRyZXNzKHN5bWJvbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHNlY3VyaXRpZXNTZXJ2aWNlID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBzZWN1cml0eSA9IGF3YWl0IHNlY3VyaXRpZXNTZXJ2aWNlLmdldFNlY3VyaXR5QnlTeW1ib2woc3ltYm9sKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdHJhZGVQYWdlID0gbmV3IFRyYWRlUGFnZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdHJhZGVQYWdlLmxvYWQoc3ltYm9sLCBzZWN1cml0eS5OYW1lLCBzZWN1cml0eS5Mb2dvUGF0aCArIHNlY3VyaXR5LkxvZ28sIGNvbnRyYWN0QWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYWRkVG9XYWxsZXRMaW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2FkZFRvV2FsbGV0Jyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRUb1dhbGxldExpbmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFkZFRvV2FsbGV0TGlua3NbaV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2dC50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBhZGRUb1dhbGxldExpbmtzW2ldIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbCA9IGVsZW1lbnQuZGF0YXNldC5zeW1ib2whO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBsaW1pbmFsTWFya2V0U2VydmljZSA9IG5ldyBMaW1pbmFsTWFya2V0U2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRyYWN0QWRkcmVzcyA9IGF3YWl0IGxpbWluYWxNYXJrZXRTZXJ2aWNlLmdldFN5bWJvbENvbnRyYWN0QWRkcmVzcyhzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0QWRkcmVzcy50b1N0cmluZygpID09IEFkZHJlc3NaZXJvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNyZWF0ZVRva2VuID0gbmV3IENyZWF0ZVRva2VuKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVG9rZW4uc2hvdyhzeW1ib2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcih0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgd2FsbGV0SGVscGVyLmFkZFRva2VuVG9XYWxsZXQoY29udHJhY3RBZGRyZXNzLnRvU3RyaW5nKCksIHN5bWJvbCwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wbGF0ZSA9IEhhbmRsZWJhcnMuY29tcGlsZShBZGRyZXNzSW5mb0h0bWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGUoe3N5bWJvbDogc3ltYm9sLCBhZGRyZXNzOiBjb250cmFjdEFkZHJlc3N9KTtcclxuICAgICAgICAgICAgICAgICAgICBtb2RhbC5zaG93TW9kYWwoJ0ltcG9ydCB0b2tlbiB0byB3YWxsZXQnLCBjb250ZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJTeW1ib2xMb2dvcyhzeW1ib2xzKTtcclxuXHJcbiAgICAgICAgbGV0IGRvY1RlbXBsYXRlID0gSGFuZGxlYmFycy5jb21waWxlKERvY3VtZW50c0h0bWwpO1xyXG4gICAgICAgIGxldCBkb2N1bWVudHMgPSBhd2FpdCB0aGlzLmRvY3VtZW50U2VydmljZS5nZXREb2N1bWVudHMoKTtcclxuICAgICAgICBsZXQgZG9jdW1lbnREb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG9jdW1lbnRzJyk7XHJcbiAgICAgICAgaWYgKCFkb2N1bWVudERvbSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBkb2N1bWVudERvbS5pbm5lckhUTUwgPSBkb2NUZW1wbGF0ZSh7cmVzdWx0OiBkb2N1bWVudHN9KTtcclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0RG9jdW1lbnRzKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyByZW5kZXJTeW1ib2xMb2dvcyhzeW1ib2xzOiBBcnJheTxzdHJpbmc+KSB7XHJcbiAgICAgICAgbGV0IHNlY3VyaXRpZXNTZXJ2aWNlID0gYXdhaXQgU2VjdXJpdGllc1NlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBjb25zdCBhc3NldHMgPSBhd2FpdCBzZWN1cml0aWVzU2VydmljZS5nZXRTZWN1cml0aWVzKCk7XHJcbiAgICAgICAgbGV0IGFzc2V0O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhc3NldCA9IGFzc2V0cy5nZXQoc3ltYm9sc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChhc3NldCkge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bWJvbF9sb2dvXycgKyBzeW1ib2xzW2ldKSEuc2V0QXR0cmlidXRlKCdzcmMnLCAnL2ltZy9sb2dvcy8nICsgYXNzZXQuTG9nbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHN5bmNBbGxUb2tlbnMoKSB7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBsZXQgY29zdE9mU3luYyA9IGF3YWl0IHRoaXMubW9yYWxpcy5DbG91ZC5ydW4oJ2Nvc3RPZlN5bmMnKTtcclxuICAgICAgICBsZXQgdGVtcGxhdGUgPSBIYW5kbGViYXJzLmNvbXBpbGUoU3luY1N0b2NrSHRtbCk7XHJcbiAgICAgICAgbGV0IGNvbnRlbnQgPSB0ZW1wbGF0ZSh7XHJcbiAgICAgICAgICAgIHNoYXJlQ291bnQ6IGNvc3RPZlN5bmMuc2hhcmVDb3VudCxcclxuICAgICAgICAgICAgY29zdFBlclNoYXJlOiBNb3JhbGlzLlVuaXRzLkZyb21XZWkoY29zdE9mU3luYy5jb3N0UGVyU2hhcmUsIDE4KSxcclxuICAgICAgICAgICAgcHJpY2VJbk5hdGl2ZVRva2VuOiBjb3N0T2ZTeW5jLnByaWNlSW5OYXRpdmVUb2tlbixcclxuICAgICAgICAgICAgdG90YWxDb3N0OiBNb3JhbGlzLlVuaXRzLkZyb21XZWkoY29zdE9mU3luYy5jb3N0LCAxOCksXHJcbiAgICAgICAgICAgIE5hdGl2ZVN5bWJvbDogbmV0d29ya0luZm8uTmF0aXZlU3ltYm9sXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBtb2RhbCA9IG5ldyBNb2RhbCgpO1xyXG4gICAgICAgIG1vZGFsLnNob3dNb2RhbCgnU3luYyBhbGwgc3RvY2sgdG8gd2FsbGV0JywgY29udGVudClcclxuXHJcbiAgICAgICAgbGV0IHN5bmNBbGxQb3NpdGlvbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY0FsbFBvc2l0aW9ucycpO1xyXG4gICAgICAgIGlmIChzeW5jQWxsUG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgIHN5bmNBbGxQb3NpdGlvbnMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBpbml0RG9jdW1lbnRzKCkge1xyXG5cclxuICAgICAgICBjb25zdCBsaW5rcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Rvd25sb2FkRG9jJyk7XHJcbiAgICAgICAgY29uc3QgdXNlciA9IHRoaXMubW9yYWxpcy5Vc2VyLmN1cnJlbnQoKTtcclxuICAgICAgICBpZiAoIXVzZXIpIHJldHVybjtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaW5rc1tpXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBkb2N1bWVudElkID0gKGxpbmtzW2ldIGFzIEhUTUxFbGVtZW50KS5kYXRhc2V0LmRvY2lkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudElkKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxvY2F0aW9uVXJsID0gYXdhaXQgdGhpcy5kb2N1bWVudFNlcnZpY2UuZ2V0RG9jdW1lbnQoZG9jdW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYXRpb25VcmwgPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGVydCgnQ291bGQgbm90IGZpbmQgZG9jdW1lbnQuIFBsZWFzZSBjb250YWN0IHVzIGlmIHlvdSBzaG91bGQgaGF2ZSBnb3R0ZW4gYSBkb2N1bWVudCcpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uID0gbG9jYXRpb25Vcmw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufSIsImltcG9ydCBTdG9ja3NQYWdlIGZyb20gXCIuLi91aS9wYWdlcy9TdG9ja3NQYWdlXCI7XHJcbmltcG9ydCBUcmFkZVBhZ2UgZnJvbSBcIi4uL3VpL3BhZ2VzL1RyYWRlUGFnZVwiO1xyXG5pbXBvcnQgUG9zaXRpb25zUGFnZSBmcm9tIFwiLi4vdWkvcGFnZXMvUG9zaXRpb25zUGFnZVwiO1xyXG5pbXBvcnQgRmFrZUFVU0RGdW5kIGZyb20gXCIuLi91aS9tb2RhbHMvRnVuZGluZy9GYWtlQVVTREZ1bmRcIjtcclxuaW1wb3J0IE5ldHdvcmtJbmZvIGZyb20gXCIuLi9uZXR3b3Jrcy9OZXR3b3JrSW5mb1wiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuLi91dGlsL1dhbGxldEhlbHBlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRpbmcge1xyXG5cclxuICAgIHNldHRpbmdzOiBhbnkgPSB7XHJcbiAgICAgICAgc2hvd190cmFkZTogdGhpcy5zaG93VHJhZGUsXHJcbiAgICAgICAgc2hvd19wb3NpdGlvbnM6IHRoaXMuc2hvd1Bvc2l0aW9ucyxcclxuICAgICAgICBzaG93X3N0b2NrczogdGhpcy5zaG93U3RvY2tzLFxyXG4gICAgICAgIHNob3dfa3ljX2FjdGlvbl9yZXF1aXJlZDogdGhpcy5zaG93S3ljQWN0aW9uUmVxdWlyZWQsXHJcbiAgICAgICAgc2hvd19mdW5kaW5nOiB0aGlzLnNob3dGdW5kaW5nLFxyXG4gICAgICAgIHNob3dfa3ljOiB0aGlzLnNob3dLeWNcclxuICAgIH07XHJcbiAgICBtb3JhbGlzIDogdHlwZW9mIE1vcmFsaXM7XHJcblxyXG4gICAgY29uc3RydWN0b3IobW9yYWxpcyA6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgbG9hZFJvdXRlcygpIHtcclxuICAgICAgICBsZXQgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoJyMnLCAnJykucmVwbGFjZSgnLycsICcnKTtcclxuICAgICAgICBpZiAocGF0aCA9PT0gJycpIHBhdGggPSAnc3RvY2tzJztcclxuXHJcbiAgICAgICAgdGhpcy5hdHRhY2hOYXZMaW5rcygpO1xyXG5cclxuICAgICAgICBsZXQgZm4gPSB0aGlzLnNldHRpbmdzWydzaG93XycgKyBwYXRoXSA/PyB0aGlzLnNldHRpbmdzWydzaG93X3N0b2NrcyddO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZuKHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGZuKHRoaXMuc2V0dGluZ3NbJ3Nob3dfc3RvY2tzJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd0t5Y0FjdGlvblJlcXVpcmVkKHJvdXRpbmc6IFJvdXRpbmcsIGV2dDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGlmIChldnQpIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBsZXQgcGFnZSA9IG5ldyBUcmFkZVBhZ2Uocm91dGluZy5tb3JhbGlzKTtcclxuICAgICAgICBhd2FpdCBwYWdlLmxvYWQoKTtcclxuXHJcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJ0J1eSBzdG9ja3MnLCAnIy9reWNfYWN0aW9uX3JlcXVpcmVkJyk7XHJcblxyXG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZScpXHJcbiAgICAgICAgYnV0dG9uPy5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd0t5Yyhyb3V0aW5nOiBSb3V0aW5nLCBldnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZ0KSBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHBhZ2UgPSBuZXcgVHJhZGVQYWdlKHJvdXRpbmcubW9yYWxpcyk7XHJcbiAgICAgICAgYXdhaXQgcGFnZS5sb2FkKCk7XHJcblxyXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsICdCdXkgc3RvY2tzJywgJyMva3ljJyk7XHJcblxyXG4gICAgICAgIGxldCBidXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGltaW5hbF9tYXJrZXRfZXhlY3V0ZV90cmFkZScpXHJcbiAgICAgICAgYnV0dG9uPy5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KCdjbGljaycpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd0Z1bmRpbmcocm91dGluZzogUm91dGluZywgZXZ0OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2dCkgZXZ0LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIGxldCBwYWdlID0gbmV3IFRyYWRlUGFnZShyb3V0aW5nLm1vcmFsaXMpO1xyXG4gICAgICAgIGF3YWl0IHBhZ2UubG9hZCgpO1xyXG5cclxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnQnV5IHN0b2NrcycsICcjL2Z1bmRpbmcnKTtcclxuXHJcbiAgICAgICAgbGV0IGFVU0RGdW5kaW5nTW9kYWwgPSBuZXcgRmFrZUFVU0RGdW5kKHRoaXMubW9yYWxpcyk7XHJcbiAgICAgICAgbGV0IG5ldHdvcmtJbmZvID0gTmV0d29ya0luZm8uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAobmV0d29ya0luZm8uVGVzdE5ldHdvcmspIHtcclxuICAgICAgICAgICAgYVVTREZ1bmRpbmdNb2RhbC5zaG93QVVTREZha2VGdW5kKCgpID0+IHtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhVVNERnVuZGluZ01vZGFsLnNob3dBVVNERnVuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc2hvd1RyYWRlKHJvdXRpbmc6IFJvdXRpbmcsIGV2dDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGlmIChldnQpIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBsZXQgcGFnZSA9IG5ldyBUcmFkZVBhZ2Uocm91dGluZy5tb3JhbGlzKTtcclxuICAgICAgICBhd2FpdCBwYWdlLmxvYWQoKTtcclxuXHJcbiAgICAgICAgaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgJ0J1eSBzdG9ja3MnLCAnIy90cmFkZScpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzaG93U3RvY2tzKHJvdXRpbmcgOiBSb3V0aW5nLGV2dCA6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZ0KSBldnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgbGV0IHBhZ2UgPSBuZXcgU3RvY2tzUGFnZShyb3V0aW5nLm1vcmFsaXMpO1xyXG4gICAgICAgIGF3YWl0IHBhZ2UubG9hZCgpO1xyXG5cclxuICAgICAgICBoaXN0b3J5LnB1c2hTdGF0ZShudWxsLCAnU3RvY2tzJywgJyMvc3RvY2tzJyk7XHJcblxyXG4gICAgfVxyXG4gICAgcHVibGljIGFzeW5jIHNob3dQb3NpdGlvbnMocm91dGluZyA6IFJvdXRpbmcsZXZ0IDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIGlmIChldnQpIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICBsZXQgcGFnZSA9IG5ldyBQb3NpdGlvbnNQYWdlKHJvdXRpbmcubW9yYWxpcyk7XHJcbiAgICAgICAgYXdhaXQgcGFnZS5sb2FkKCk7XHJcblxyXG4gICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKG51bGwsICdQb3NpdGlvbnMnLCAnIy9wb3NpdGlvbnMnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXR0YWNoTmF2TGlua3MoKSB7XHJcbiAgICAgICAgbGV0IHJvdXRlciA9IHRoaXM7XHJcblxyXG5cclxuICAgICAgICBsZXQgdHJhZGVOYXZMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50cmFkZU5hdkxpbmsnKTtcclxuICAgICAgICB0cmFkZU5hdkxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIChsaW5rIGFzIEhUTUxFbGVtZW50KS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jIChldnQgKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBXYWxsZXRIZWxwZXIuaGlkZU1hZ2ljV2FsbGV0KCk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCByb3V0ZXIuc2hvd1RyYWRlKHJvdXRlciwgZXZ0KTtcclxuICAgICAgICAgICAgICAgIGxpbmsucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEucGFyZW50RWxlbWVudCEucmVtb3ZlQXR0cmlidXRlKCdvcGVuJyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBpbnZlc3RMaW5rcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5pbnZlc3ROYXZMaW5rJyk7XHJcbiAgICAgICAgaW52ZXN0TGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgKGxpbmsgYXMgSFRNTEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgV2FsbGV0SGVscGVyLmhpZGVNYWdpY1dhbGxldCgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcm91dGVyLnNob3dTdG9ja3Mocm91dGVyLCBldnQpO1xyXG4gICAgICAgICAgICAgICAgbGluay5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5yZW1vdmVBdHRyaWJ1dGUoJ29wZW4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBwb3NpdGlvbkxpbmtzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnBvc2l0aW9uTmF2TGluaycpO1xyXG4gICAgICAgIHBvc2l0aW9uTGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgKGxpbmsgYXMgSFRNTEVsZW1lbnQpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgYXN5bmMgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgV2FsbGV0SGVscGVyLmhpZGVNYWdpY1dhbGxldCgpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgcm91dGVyLnNob3dQb3NpdGlvbnMocm91dGVyLCBldnQpO1xyXG4gICAgICAgICAgICAgICAgbGluay5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5wYXJlbnRFbGVtZW50IS5yZW1vdmVBdHRyaWJ1dGUoJ29wZW4nKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG59IiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGVhZGVyIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGxvYWRJbWFnZSgpIHtcclxuICAgICAgICBsZXQgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keSA+IGhlYWRlcicpIGFzIEhUTUxFbGVtZW50O1xyXG4gICAgICAgIGlmICghaGVhZGVyKSByZXR1cm47XHJcblxyXG4gICAgICAgIGxldCByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCk7XHJcblxyXG4gICAgICAgIGhlYWRlci5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBcInVybCgvaW1nL2hlYWRlci9cIiArIHJhbmRvbSArIFwiLmpwZylcIjtcclxuICAgIH1cclxufSIsImltcG9ydCBNb3JhbGlzIGZyb20gXCJtb3JhbGlzXCI7XHJcbmltcG9ydCBVc2VyU2VydmljZSBmcm9tIFwiLi4vLi4vc2VydmljZXMvYmFja2VuZC9Vc2VyU2VydmljZVwiO1xyXG5pbXBvcnQgVXNlckluZm8gZnJvbSBcIi4vVXNlckluZm9cIjtcclxuaW1wb3J0IENvbm5lY3RXYWxsZXQgZnJvbSBcIi4uL21vZGFscy9Db25uZWN0V2FsbGV0XCI7XHJcbmltcG9ydCBMb2FkaW5nSGVscGVyIGZyb20gXCIuLi8uLi91dGlsL0xvYWRpbmdIZWxwZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1dGhlbnRpY2F0ZVVzZXIge1xyXG5cclxuICAgIG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKG1vcmFsaXM6IHR5cGVvZiBNb3JhbGlzKSB7XHJcbiAgICAgICAgdGhpcy5tb3JhbGlzID0gbW9yYWxpcztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgYXV0aGVudGljYXRlKCkge1xyXG4gICAgICAgIGxldCB1c2VyU2VydmljZSA9IG5ldyBVc2VyU2VydmljZSh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgIGxldCB1c2VyID0gdXNlclNlcnZpY2UuZ2V0VXNlcigpO1xyXG5cclxuICAgICAgICBpZiAoIXVzZXIpIHtcclxuICAgICAgICAgICAgbGV0IGNvbm5lY3RXYWxsZXQgPSBuZXcgQ29ubmVjdFdhbGxldCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBjb25uZWN0V2FsbGV0LnJlbmRlckJ1dHRvbigndXNlcl9oZWFkZXJfaW5mbycpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdXNlcl9oZWFkZXJfaW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1c2VyX2hlYWRlcl9pbmZvJyk7XHJcbiAgICAgICAgaWYgKHVzZXJfaGVhZGVyX2luZm8pIHVzZXJfaGVhZGVyX2luZm8uaW5uZXJIVE1MID0gJ0xvYWRpbmcgd2FsbGV0Li4nO1xyXG4gICAgICAgIExvYWRpbmdIZWxwZXIuc2V0TG9hZGluZyh1c2VyX2hlYWRlcl9pbmZvKTtcclxuXHJcbiAgICAgICAgdXNlciA9IGF3YWl0IHVzZXJTZXJ2aWNlLmlzTG9nZ2VkSW4oKTtcclxuICAgICAgICBpZiAodXNlcikge1xyXG4gICAgICAgICAgICBsZXQgdXNlckluZm8gPSBuZXcgVXNlckluZm8odGhpcy5tb3JhbGlzLCAodXNlciBhcyBhbnkpLnByb3ZpZGVySW5mbywgdXNlcik7XHJcbiAgICAgICAgICAgIGF3YWl0IHVzZXJJbmZvLnJlbmRlcigndXNlcl9oZWFkZXJfaW5mbycpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vc2hvdyBDb25uZWN0IFdhbGxldCBidXR0b25cclxuICAgICAgICAgICAgbGV0IGNvbm5lY3RXYWxsZXQgPSBuZXcgQ29ubmVjdFdhbGxldCh0aGlzLm1vcmFsaXMpO1xyXG4gICAgICAgICAgICBjb25uZWN0V2FsbGV0LnJlbmRlckJ1dHRvbigndXNlcl9oZWFkZXJfaW5mbycpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgTG9hZGluZ0hlbHBlci5yZW1vdmVMb2FkaW5nKCk7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IENvbm5lY3Rpb25TZXJ2aWNlIGZyb20gXCIuL3NlcnZpY2VzL2JhY2tlbmQvQ29ubmVjdGlvblNlcnZpY2VcIjtcclxuaW1wb3J0IFJvdXRpbmcgZnJvbSBcIi4vcm91dGluZy9Sb3V0aW5nXCI7XHJcbmltcG9ydCBFcnJvckluZm8gZnJvbSBcIi4vZXJyb3JzL0Vycm9ySW5mb1wiO1xyXG5pbXBvcnQgV2FsbGV0SGVscGVyIGZyb20gXCIuL3V0aWwvV2FsbGV0SGVscGVyXCI7XHJcbmltcG9ydCBHZW5lcmFsRXJyb3IgZnJvbSBcIi4vZXJyb3JzL0dlbmVyYWxFcnJvclwiO1xyXG5pbXBvcnQgSGVhZGVyIGZyb20gXCIuL3VpL2VsZW1lbnRzL0hlYWRlclwiO1xyXG5pbXBvcnQgQXV0aGVudGljYXRlVXNlciBmcm9tIFwiLi91aS9lbGVtZW50cy9BdXRoZW50aWNhdGVVc2VyXCI7XHJcblxyXG5cclxuY29uc3Qgc3RhcnQgPSBhc3luYyBmdW5jdGlvbiAoKSB7XHJcbiAgICBsZXQgc2xvd1NlcnZlclRpbWVyID0gc2V0VGltZW91dChzbG93U2VydmVyLCAxMCAqIDEwMDApO1xyXG4gICAgbGV0IG1vcmFsaXMgPSBNb3JhbGlzO1xyXG4gICAgbGV0IGNvbm5lY3Rpb25TZXJ2aWNlID0gbmV3IENvbm5lY3Rpb25TZXJ2aWNlKG1vcmFsaXMpO1xyXG4gICAgY29ubmVjdGlvblNlcnZpY2Uuc3RhcnQoKS50aGVuKGFzeW5jICgpID0+IHtcclxuICAgICAgICBjbGVhclRpbWVvdXQoc2xvd1NlcnZlclRpbWVyKTtcclxuXHJcbiAgICAgICAgbGV0IHJvdXRpbmcgPSBuZXcgUm91dGluZyhtb3JhbGlzKTtcclxuICAgICAgICBhd2FpdCByb3V0aW5nLmxvYWRSb3V0ZXMoKTtcclxuXHJcbiAgICAgICAgbGV0IGF1dGhvcml6ZVVzZXIgPSBuZXcgQXV0aGVudGljYXRlVXNlcihtb3JhbGlzKTtcclxuICAgICAgICBhdXRob3JpemVVc2VyLmF1dGhlbnRpY2F0ZSgpO1xyXG4gICAgfSkuY2F0Y2goKHJlYXNvbikgPT4ge1xyXG4gICAgICAgIEVycm9ySW5mby5yZXBvcnQobmV3IEdlbmVyYWxFcnJvcihcIlNlcnZlciBpcyBkb3duLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLjxiciAvPjxiciAvPlwiICsgcmVhc29uKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgd2FsbGV0SGVscGVyID0gbmV3IFdhbGxldEhlbHBlcihtb3JhbGlzKTtcclxuICAgIGlmICh3YWxsZXRIZWxwZXIuaXNXZWJ2aWV3KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSlcclxuICAgIHtcclxuICAgICAgICAvL2NvbnNvbGUgPSBFcnJvckluZm8gYXMgYW55O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBzbG93U2VydmVyKCkge1xyXG4gICAgICAgIGxldCBsb2FkaW5nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmxvYWRpbmcnKTtcclxuICAgICAgICBpZiAoIWxvYWRpbmcpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNsb3dTZXJ2ZXJUaW1lcik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxvYWRpbmcuaW5uZXJIVE1MID0gJ0htbW0uLi4uIG91ciBzZXJ2ZXJzIGFyZSBzbG93LiBHaXZlIGl0IGZldyBzZWNvbmRzLidcclxuXHJcbiAgICB9XHJcbiAgICBIZWFkZXIubG9hZEltYWdlKCk7XHJcblxyXG59XHJcblxyXG5zdGFydCgpLnRoZW4oKTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.ts\n");

            /***/
        }),

        /***/
        "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js":
        /*!***************************************************************************!*\
          !*** ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js ***!
          \***************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

            "use strict";
            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WebSocketClient)\n/* harmony export */ });\n/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log.js */ \"./node_modules/webpack-dev-server/client/utils/log.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\n\n\nvar WebSocketClient = /*#__PURE__*/function () {\n  /**\n   * @param {string} url\n   */\n  function WebSocketClient(url) {\n    _classCallCheck(this, WebSocketClient);\n\n    this.client = new WebSocket(url);\n\n    this.client.onerror = function (error) {\n      _utils_log_js__WEBPACK_IMPORTED_MODULE_0__.log.error(error);\n    };\n  }\n  /**\n   * @param {(...args: any[]) => void} f\n   */\n\n\n  _createClass(WebSocketClient, [{\n    key: \"onOpen\",\n    value: function onOpen(f) {\n      this.client.onopen = f;\n    }\n    /**\n     * @param {(...args: any[]) => void} f\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(f) {\n      this.client.onclose = f;\n    } // call f with the message string as the first argument\n\n    /**\n     * @param {(...args: any[]) => void} f\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(f) {\n      this.client.onmessage = function (e) {\n        f(e.data);\n      };\n    }\n  }]);\n\n  return WebSocketClient;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL1dlYlNvY2tldENsaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtEQUFrRCwwQ0FBMEM7O0FBRTVGLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVEOztBQUUvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7O0FBRWxPOztBQUV0QztBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU0sb0RBQVM7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxlQUFlLDBCQUEwQjtBQUN6Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2NsaWVudHMvV2ViU29ja2V0Q2xpZW50LmpzPzYyNmIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi4vdXRpbHMvbG9nLmpzXCI7XG5cbnZhciBXZWJTb2NrZXRDbGllbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgZnVuY3Rpb24gV2ViU29ja2V0Q2xpZW50KHVybCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJTb2NrZXRDbGllbnQpO1xuXG4gICAgdGhpcy5jbGllbnQgPSBuZXcgV2ViU29ja2V0KHVybCk7XG5cbiAgICB0aGlzLmNsaWVudC5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBmXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFdlYlNvY2tldENsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLmNsaWVudC5vbm9wZW4gPSBmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuY2xpZW50Lm9uY2xvc2UgPSBmO1xuICAgIH0gLy8gY2FsbCBmIHdpdGggdGhlIG1lc3NhZ2Ugc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGZcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5jbGllbnQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZihlLmRhdGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViU29ja2V0Q2xpZW50O1xufSgpO1xuXG5leHBvcnQgeyBXZWJTb2NrZXRDbGllbnQgYXMgZGVmYXVsdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\n");

            /***/
        }),

        /***/
        "./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info&reconnect=10":
        /*!********************************************************************************************************************************************************!*\
          !*** ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info&reconnect=10 + 8 modules ***!
          \********************************************************************************************************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

            "use strict";
            eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/webpack/hot/log.js\nvar log = __webpack_require__(\"./node_modules/webpack/hot/log.js\");\nvar log_default = /*#__PURE__*/__webpack_require__.n(log);\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/utils/stripAnsi.js\nvar ansiRegex = new RegExp([\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\", \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))\"].join(\"|\"), \"g\");\n/**\n *\n * Strip [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from a string.\n * Adapted from code originally released by Sindre Sorhus\n * Licensed the MIT License\n *\n * @param {string} string\n * @return {string}\n */\n\nfunction stripAnsi(string) {\n  if (typeof string !== \"string\") {\n    throw new TypeError(\"Expected a `string`, got `\".concat(typeof string, \"`\"));\n  }\n\n  return string.replace(ansiRegex, \"\");\n}\n\n/* harmony default export */ const utils_stripAnsi = (stripAnsi);\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js\n/**\n * @returns {string}\n */\nfunction getCurrentScriptSource() {\n  // `document.currentScript` is the most accurate way to find the current script,\n  // but is not supported in all browsers.\n  if (document.currentScript) {\n    return document.currentScript.getAttribute(\"src\");\n  } // Fallback to getting all scripts running in the document.\n\n\n  var scriptElements = document.scripts || [];\n  var scriptElementsWithSrc = Array.prototype.filter.call(scriptElements, function (element) {\n    return element.getAttribute(\"src\");\n  });\n\n  if (scriptElementsWithSrc.length > 0) {\n    var currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];\n    return currentScript.getAttribute(\"src\");\n  } // Fail as there was no script to use.\n\n\n  throw new Error(\"[webpack-dev-server] Failed to get current script source.\");\n}\n\n/* harmony default export */ const utils_getCurrentScriptSource = (getCurrentScriptSource);\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/utils/parseURL.js\n\n/**\n * @param {string} resourceQuery\n * @returns {{ [key: string]: string | boolean }}\n */\n\nfunction parseURL(resourceQuery) {\n  /** @type {{ [key: string]: string }} */\n  var options = {};\n\n  if (typeof resourceQuery === \"string\" && resourceQuery !== \"\") {\n    var searchParams = resourceQuery.slice(1).split(\"&\");\n\n    for (var i = 0; i < searchParams.length; i++) {\n      var pair = searchParams[i].split(\"=\");\n      options[pair[0]] = decodeURIComponent(pair[1]);\n    }\n  } else {\n    // Else, get the url from the <script> this file was called with.\n    var scriptSource = utils_getCurrentScriptSource();\n    var scriptSourceURL;\n\n    try {\n      // The placeholder `baseURL` with `window.location.href`,\n      // is to allow parsing of path-relative or protocol-relative URLs,\n      // and will have no effect if `scriptSource` is a fully valid URL.\n      scriptSourceURL = new URL(scriptSource, self.location.href);\n    } catch (error) {// URL parsing failed, do nothing.\n      // We will still proceed to see if we can recover using `resourceQuery`\n    }\n\n    if (scriptSourceURL) {\n      options = scriptSourceURL;\n      options.fromCurrentScript = true;\n    }\n  }\n\n  return options;\n}\n\n/* harmony default export */ const utils_parseURL = (parseURL);\n// EXTERNAL MODULE: ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\nvar WebSocketClient = __webpack_require__(\"./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\");\n// EXTERNAL MODULE: ./node_modules/webpack-dev-server/client/utils/log.js\nvar utils_log = __webpack_require__(\"./node_modules/webpack-dev-server/client/utils/log.js\");\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/socket.js\n/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js */ \"./node_modules/webpack-dev-server/client/clients/WebSocketClient.js\");\n/* global __webpack_dev_server_client__ */\n\n // this WebsocketClient is here as a default fallback, in case the client is not injected\n\n/* eslint-disable camelcase */\n\nvar Client = // eslint-disable-next-line no-nested-ternary\ntypeof __webpack_dev_server_client__ !== \"undefined\" ? typeof __webpack_dev_server_client__.default !== \"undefined\" ? __webpack_dev_server_client__.default : __webpack_dev_server_client__ : WebSocketClient[\"default\"];\n/* eslint-enable camelcase */\n\nvar retries = 0;\nvar maxRetries = 10; // Initialized client is exported so external consumers can utilize the same instance\n// It is mutable to enforce singleton\n// eslint-disable-next-line import/no-mutable-exports\n\nvar client = null;\n/**\n * @param {string} url\n * @param {{ [handler: string]: (data?: any, params?: any) => any }} handlers\n * @param {number} [reconnect]\n */\n\nvar socket = function initSocket(url, handlers, reconnect) {\n  client = new Client(url);\n  client.onOpen(function () {\n    retries = 0;\n\n    if (typeof reconnect !== \"undefined\") {\n      maxRetries = reconnect;\n    }\n  });\n  client.onClose(function () {\n    if (retries === 0) {\n      handlers.close();\n    } // Try to reconnect.\n\n\n    client = null; // After 10 retries stop trying, to prevent logspam.\n\n    if (retries < maxRetries) {\n      // Exponentially increase timeout to reconnect.\n      // Respectfully copied from the package `got`.\n      // eslint-disable-next-line no-restricted-properties\n      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;\n      retries += 1;\n      utils_log.log.info(\"Trying to reconnect...\");\n      setTimeout(function () {\n        socket(url, handlers, reconnect);\n      }, retryInMs);\n    }\n  });\n  client.onMessage(\n  /**\n   * @param {any} data\n   */\n  function (data) {\n    var message = JSON.parse(data);\n\n    if (handlers[message.type]) {\n      handlers[message.type](message.data, message.params);\n    }\n  });\n};\n\n/* harmony default export */ const client_socket = (socket);\n// EXTERNAL MODULE: ./node_modules/ansi-html-community/index.js\nvar ansi_html_community = __webpack_require__(\"./node_modules/ansi-html-community/index.js\");\nvar ansi_html_community_default = /*#__PURE__*/__webpack_require__.n(ansi_html_community);\n// EXTERNAL MODULE: ./node_modules/html-entities/lib/index.js\nvar lib = __webpack_require__(\"./node_modules/html-entities/lib/index.js\");\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/overlay.js\n// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)\n// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).\n\n\nvar colors = {\n  reset: [\"transparent\", \"transparent\"],\n  black: \"181818\",\n  red: \"E36049\",\n  green: \"B3CB74\",\n  yellow: \"FFD080\",\n  blue: \"7CAFC2\",\n  magenta: \"7FACCA\",\n  cyan: \"C3C2EF\",\n  lightgrey: \"EBE7E3\",\n  darkgrey: \"6D7891\"\n};\n/** @type {HTMLIFrameElement | null | undefined} */\n\nvar iframeContainerElement;\n/** @type {HTMLDivElement | null | undefined} */\n\nvar containerElement;\n/** @type {Array<(element: HTMLDivElement) => void>} */\n\nvar onLoadQueue = [];\n/** @type {TrustedTypePolicy | undefined} */\n\nvar overlayTrustedTypesPolicy;\nansi_html_community_default().setColors(colors);\n/**\n * @param {string | null} trustedTypesPolicyName\n */\n\nfunction createContainer(trustedTypesPolicyName) {\n  // Enable Trusted Types if they are available in the current browser.\n  if (window.trustedTypes) {\n    overlayTrustedTypesPolicy = window.trustedTypes.createPolicy(trustedTypesPolicyName || \"webpack-dev-server#overlay\", {\n      createHTML: function createHTML(value) {\n        return value;\n      }\n    });\n  }\n\n  iframeContainerElement = document.createElement(\"iframe\");\n  iframeContainerElement.id = \"webpack-dev-server-client-overlay\";\n  iframeContainerElement.src = \"about:blank\";\n  iframeContainerElement.style.position = \"fixed\";\n  iframeContainerElement.style.left = 0;\n  iframeContainerElement.style.top = 0;\n  iframeContainerElement.style.right = 0;\n  iframeContainerElement.style.bottom = 0;\n  iframeContainerElement.style.width = \"100vw\";\n  iframeContainerElement.style.height = \"100vh\";\n  iframeContainerElement.style.border = \"none\";\n  iframeContainerElement.style.zIndex = 9999999999;\n\n  iframeContainerElement.onload = function () {\n    containerElement =\n    /** @type {Document} */\n\n    /** @type {HTMLIFrameElement} */\n    iframeContainerElement.contentDocument.createElement(\"div\");\n    containerElement.id = \"webpack-dev-server-client-overlay-div\";\n    containerElement.style.position = \"fixed\";\n    containerElement.style.boxSizing = \"border-box\";\n    containerElement.style.left = 0;\n    containerElement.style.top = 0;\n    containerElement.style.right = 0;\n    containerElement.style.bottom = 0;\n    containerElement.style.width = \"100vw\";\n    containerElement.style.height = \"100vh\";\n    containerElement.style.backgroundColor = \"rgba(0, 0, 0, 0.85)\";\n    containerElement.style.color = \"#E8E8E8\";\n    containerElement.style.fontFamily = \"Menlo, Consolas, monospace\";\n    containerElement.style.fontSize = \"large\";\n    containerElement.style.padding = \"2rem\";\n    containerElement.style.lineHeight = \"1.2\";\n    containerElement.style.whiteSpace = \"pre-wrap\";\n    containerElement.style.overflow = \"auto\";\n    var headerElement = document.createElement(\"span\");\n    headerElement.innerText = \"Compiled with problems:\";\n    var closeButtonElement = document.createElement(\"button\");\n    closeButtonElement.innerText = \"X\";\n    closeButtonElement.style.background = \"transparent\";\n    closeButtonElement.style.border = \"none\";\n    closeButtonElement.style.fontSize = \"20px\";\n    closeButtonElement.style.fontWeight = \"bold\";\n    closeButtonElement.style.color = \"white\";\n    closeButtonElement.style.cursor = \"pointer\";\n    closeButtonElement.style.cssFloat = \"right\"; // @ts-ignore\n\n    closeButtonElement.style.styleFloat = \"right\";\n    closeButtonElement.addEventListener(\"click\", function () {\n      hide();\n    });\n    containerElement.appendChild(headerElement);\n    containerElement.appendChild(closeButtonElement);\n    containerElement.appendChild(document.createElement(\"br\"));\n    containerElement.appendChild(document.createElement(\"br\"));\n    /** @type {Document} */\n\n    /** @type {HTMLIFrameElement} */\n    iframeContainerElement.contentDocument.body.appendChild(containerElement);\n    onLoadQueue.forEach(function (onLoad) {\n      onLoad(\n      /** @type {HTMLDivElement} */\n      containerElement);\n    });\n    onLoadQueue = [];\n    /** @type {HTMLIFrameElement} */\n\n    iframeContainerElement.onload = null;\n  };\n\n  document.body.appendChild(iframeContainerElement);\n}\n/**\n * @param {(element: HTMLDivElement) => void} callback\n * @param {string | null} trustedTypesPolicyName\n */\n\n\nfunction ensureOverlayExists(callback, trustedTypesPolicyName) {\n  if (containerElement) {\n    // Everything is ready, call the callback right away.\n    callback(containerElement);\n    return;\n  }\n\n  onLoadQueue.push(callback);\n\n  if (iframeContainerElement) {\n    return;\n  }\n\n  createContainer(trustedTypesPolicyName);\n} // Successful compilation.\n\n\nfunction hide() {\n  if (!iframeContainerElement) {\n    return;\n  } // Clean up and reset internal state.\n\n\n  document.body.removeChild(iframeContainerElement);\n  iframeContainerElement = null;\n  containerElement = null;\n}\n/**\n * @param {string} type\n * @param {string  | { file?: string, moduleName?: string, loc?: string, message?: string }} item\n * @returns {{ header: string, body: string }}\n */\n\n\nfunction formatProblem(type, item) {\n  var header = type === \"warning\" ? \"WARNING\" : \"ERROR\";\n  var body = \"\";\n\n  if (typeof item === \"string\") {\n    body += item;\n  } else {\n    var file = item.file || \"\"; // eslint-disable-next-line no-nested-ternary\n\n    var moduleName = item.moduleName ? item.moduleName.indexOf(\"!\") !== -1 ? \"\".concat(item.moduleName.replace(/^(\\s|\\S)*!/, \"\"), \" (\").concat(item.moduleName, \")\") : \"\".concat(item.moduleName) : \"\";\n    var loc = item.loc;\n    header += \"\".concat(moduleName || file ? \" in \".concat(moduleName ? \"\".concat(moduleName).concat(file ? \" (\".concat(file, \")\") : \"\") : file).concat(loc ? \" \".concat(loc) : \"\") : \"\");\n    body += item.message || \"\";\n  }\n\n  return {\n    header: header,\n    body: body\n  };\n} // Compilation with errors (e.g. syntax error or missing modules).\n\n/**\n * @param {string} type\n * @param {Array<string  | { file?: string, moduleName?: string, loc?: string, message?: string }>} messages\n * @param {string | null} trustedTypesPolicyName\n */\n\n\nfunction show(type, messages, trustedTypesPolicyName) {\n  ensureOverlayExists(function () {\n    messages.forEach(function (message) {\n      var entryElement = document.createElement(\"div\");\n      var typeElement = document.createElement(\"span\");\n\n      var _formatProblem = formatProblem(type, message),\n          header = _formatProblem.header,\n          body = _formatProblem.body;\n\n      typeElement.innerText = header;\n      typeElement.style.color = \"#\".concat(colors.red); // Make it look similar to our terminal.\n\n      var text = ansi_html_community_default()((0,lib.encode)(body));\n      var messageTextNode = document.createElement(\"div\");\n      messageTextNode.innerHTML = overlayTrustedTypesPolicy ? overlayTrustedTypesPolicy.createHTML(text) : text;\n      entryElement.appendChild(typeElement);\n      entryElement.appendChild(document.createElement(\"br\"));\n      entryElement.appendChild(document.createElement(\"br\"));\n      entryElement.appendChild(messageTextNode);\n      entryElement.appendChild(document.createElement(\"br\"));\n      entryElement.appendChild(document.createElement(\"br\"));\n      /** @type {HTMLDivElement} */\n\n      containerElement.appendChild(entryElement);\n    });\n  }, trustedTypesPolicyName);\n}\n\n\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/utils/sendMessage.js\n/* global __resourceQuery WorkerGlobalScope */\n// Send messages to the outside, so plugins can consume it.\n\n/**\n * @param {string} type\n * @param {any} [data]\n */\nfunction sendMsg(type, data) {\n  if (typeof self !== \"undefined\" && (typeof WorkerGlobalScope === \"undefined\" || !(self instanceof WorkerGlobalScope))) {\n    self.postMessage({\n      type: \"webpack\".concat(type),\n      data: data\n    }, \"*\");\n  }\n}\n\n/* harmony default export */ const sendMessage = (sendMsg);\n// EXTERNAL MODULE: ./node_modules/webpack/hot/emitter.js\nvar emitter = __webpack_require__(\"./node_modules/webpack/hot/emitter.js\");\nvar emitter_default = /*#__PURE__*/__webpack_require__.n(emitter);\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/utils/reloadApp.js\n\n\n/** @typedef {import(\"../index\").Options} Options\n/** @typedef {import(\"../index\").Status} Status\n\n/**\n * @param {Options} options\n * @param {Status} status\n */\n\nfunction reloadApp(_ref, status) {\n  var hot = _ref.hot,\n      liveReload = _ref.liveReload;\n\n  if (status.isUnloading) {\n    return;\n  }\n\n  var currentHash = status.currentHash,\n      previousHash = status.previousHash;\n  var isInitial = currentHash.indexOf(\n  /** @type {string} */\n  previousHash) >= 0;\n\n  if (isInitial) {\n    return;\n  }\n  /**\n   * @param {Window} rootWindow\n   * @param {number} intervalId\n   */\n\n\n  function applyReload(rootWindow, intervalId) {\n    clearInterval(intervalId);\n    utils_log.log.info(\"App updated. Reloading...\");\n    rootWindow.location.reload();\n  }\n\n  var search = self.location.search.toLowerCase();\n  var allowToHot = search.indexOf(\"webpack-dev-server-hot=false\") === -1;\n  var allowToLiveReload = search.indexOf(\"webpack-dev-server-live-reload=false\") === -1;\n\n  if (hot && allowToHot) {\n    utils_log.log.info(\"App hot update...\");\n    emitter_default().emit(\"webpackHotUpdate\", status.currentHash);\n\n    if (typeof self !== \"undefined\" && self.window) {\n      // broadcast update to window\n      self.postMessage(\"webpackHotUpdate\".concat(status.currentHash), \"*\");\n    }\n  } // allow refreshing the page only if liveReload isn't disabled\n  else if (liveReload && allowToLiveReload) {\n    var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)\n\n    var intervalId = self.setInterval(function () {\n      if (rootWindow.location.protocol !== \"about:\") {\n        // reload immediately if protocol is valid\n        applyReload(rootWindow, intervalId);\n      } else {\n        rootWindow = rootWindow.parent;\n\n        if (rootWindow.parent === rootWindow) {\n          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways\n          applyReload(rootWindow, intervalId);\n        }\n      }\n    });\n  }\n}\n\n/* harmony default export */ const utils_reloadApp = (reloadApp);\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/utils/createSocketURL.js\n/**\n * @param {{ protocol?: string, auth?: string, hostname?: string, port?: string, pathname?: string, search?: string, hash?: string, slashes?: boolean }} objURL\n * @returns {string}\n */\nfunction format(objURL) {\n  var protocol = objURL.protocol || \"\";\n\n  if (protocol && protocol.substr(-1) !== \":\") {\n    protocol += \":\";\n  }\n\n  var auth = objURL.auth || \"\";\n\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \":\");\n    auth += \"@\";\n  }\n\n  var host = \"\";\n\n  if (objURL.hostname) {\n    host = auth + (objURL.hostname.indexOf(\":\") === -1 ? objURL.hostname : \"[\".concat(objURL.hostname, \"]\"));\n\n    if (objURL.port) {\n      host += \":\".concat(objURL.port);\n    }\n  }\n\n  var pathname = objURL.pathname || \"\";\n\n  if (objURL.slashes) {\n    host = \"//\".concat(host || \"\");\n\n    if (pathname && pathname.charAt(0) !== \"/\") {\n      pathname = \"/\".concat(pathname);\n    }\n  } else if (!host) {\n    host = \"\";\n  }\n\n  var search = objURL.search || \"\";\n\n  if (search && search.charAt(0) !== \"?\") {\n    search = \"?\".concat(search);\n  }\n\n  var hash = objURL.hash || \"\";\n\n  if (hash && hash.charAt(0) !== \"#\") {\n    hash = \"#\".concat(hash);\n  }\n\n  pathname = pathname.replace(/[?#]/g,\n  /**\n   * @param {string} match\n   * @returns {string}\n   */\n  function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\"#\", \"%23\");\n  return \"\".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);\n}\n/**\n * @param {URL & { fromCurrentScript?: boolean }} parsedURL\n * @returns {string}\n */\n\n\nfunction createSocketURL(parsedURL) {\n  var hostname = parsedURL.hostname; // Node.js module parses it as `::`\n  // `new URL(urlString, [baseURLString])` parses it as '[::]'\n\n  var isInAddrAny = hostname === \"0.0.0.0\" || hostname === \"::\" || hostname === \"[::]\"; // why do we need this check?\n  // hostname n/a for file protocol (example, when using electron, ionic)\n  // see: https://github.com/webpack/webpack-dev-server/pull/384\n\n  if (isInAddrAny && self.location.hostname && self.location.protocol.indexOf(\"http\") === 0) {\n    hostname = self.location.hostname;\n  }\n\n  var socketURLProtocol = parsedURL.protocol || self.location.protocol; // When https is used in the app, secure web sockets are always necessary because the browser doesn't accept non-secure web sockets.\n\n  if (socketURLProtocol === \"auto:\" || hostname && isInAddrAny && self.location.protocol === \"https:\") {\n    socketURLProtocol = self.location.protocol;\n  }\n\n  socketURLProtocol = socketURLProtocol.replace(/^(?:http|.+-extension|file)/i, \"ws\");\n  var socketURLAuth = \"\"; // `new URL(urlString, [baseURLstring])` doesn't have `auth` property\n  // Parse authentication credentials in case we need them\n\n  if (parsedURL.username) {\n    socketURLAuth = parsedURL.username; // Since HTTP basic authentication does not allow empty username,\n    // we only include password if the username is not empty.\n\n    if (parsedURL.password) {\n      // Result: <username>:<password>\n      socketURLAuth = socketURLAuth.concat(\":\", parsedURL.password);\n    }\n  } // In case the host is a raw IPv6 address, it can be enclosed in\n  // the brackets as the brackets are needed in the final URL string.\n  // Need to remove those as url.format blindly adds its own set of brackets\n  // if the host string contains colons. That would lead to non-working\n  // double brackets (e.g. [[::]]) host\n  //\n  // All of these web socket url params are optionally passed in through resourceQuery,\n  // so we need to fall back to the default if they are not provided\n\n\n  var socketURLHostname = (hostname || self.location.hostname || \"localhost\").replace(/^\\[(.*)\\]$/, \"$1\");\n  var socketURLPort = parsedURL.port;\n\n  if (!socketURLPort || socketURLPort === \"0\") {\n    socketURLPort = self.location.port;\n  } // If path is provided it'll be passed in via the resourceQuery as a\n  // query param so it has to be parsed out of the querystring in order for the\n  // client to open the socket to the correct location.\n\n\n  var socketURLPathname = \"/ws\";\n\n  if (parsedURL.pathname && !parsedURL.fromCurrentScript) {\n    socketURLPathname = parsedURL.pathname;\n  }\n\n  return format({\n    protocol: socketURLProtocol,\n    auth: socketURLAuth,\n    hostname: socketURLHostname,\n    port: socketURLPort,\n    pathname: socketURLPathname,\n    slashes: true\n  });\n}\n\n/* harmony default export */ const utils_createSocketURL = (createSocketURL);\n;// CONCATENATED MODULE: ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info&reconnect=10\nvar __resourceQuery = \"?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info&reconnect=10\";\n/* global __resourceQuery, __webpack_hash__ */\n/// <reference types=\"webpack/module\" />\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} Options\n * @property {boolean} hot\n * @property {boolean} liveReload\n * @property {boolean} progress\n * @property {boolean | { warnings?: boolean, errors?: boolean, trustedTypesPolicyName?: string }} overlay\n * @property {string} [logging]\n * @property {number} [reconnect]\n */\n\n/**\n * @typedef {Object} Status\n * @property {boolean} isUnloading\n * @property {string} currentHash\n * @property {string} [previousHash]\n */\n\n/**\n * @type {Status}\n */\n\nvar clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status = {\n  isUnloading: false,\n  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement\n  // eslint-disable-next-line camelcase\n  currentHash:  true ? __webpack_require__.h() : 0\n};\n/** @type {Options} */\n\nvar options = {\n  hot: false,\n  liveReload: false,\n  progress: false,\n  overlay: false\n};\nvar parsedResourceQuery = utils_parseURL(__resourceQuery);\n\nif (parsedResourceQuery.hot === \"true\") {\n  options.hot = true;\n  utils_log.log.info(\"Hot Module Replacement enabled.\");\n}\n\nif (parsedResourceQuery[\"live-reload\"] === \"true\") {\n  options.liveReload = true;\n  utils_log.log.info(\"Live Reloading enabled.\");\n}\n\nif (parsedResourceQuery.logging) {\n  options.logging = parsedResourceQuery.logging;\n}\n\nif (typeof parsedResourceQuery.reconnect !== \"undefined\") {\n  options.reconnect = Number(parsedResourceQuery.reconnect);\n}\n/**\n * @param {string} level\n */\n\n\nfunction setAllLogLevel(level) {\n  // This is needed because the HMR logger operate separately from dev server logger\n  log_default().setLogLevel(level === \"verbose\" || level === \"log\" ? \"info\" : level);\n  (0,utils_log.setLogLevel)(level);\n}\n\nif (options.logging) {\n  setAllLogLevel(options.logging);\n}\n\nself.addEventListener(\"beforeunload\", function () {\n  clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status.isUnloading = true;\n});\nvar onSocketMessage = {\n  hot: function hot() {\n    if (parsedResourceQuery.hot === \"false\") {\n      return;\n    }\n\n    options.hot = true;\n    utils_log.log.info(\"Hot Module Replacement enabled.\");\n  },\n  liveReload: function liveReload() {\n    if (parsedResourceQuery[\"live-reload\"] === \"false\") {\n      return;\n    }\n\n    options.liveReload = true;\n    utils_log.log.info(\"Live Reloading enabled.\");\n  },\n  invalid: function invalid() {\n    utils_log.log.info(\"App updated. Recompiling...\"); // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.\n\n    if (options.overlay) {\n      hide();\n    }\n\n    sendMessage(\"Invalid\");\n  },\n\n  /**\n   * @param {string} hash\n   */\n  hash: function hash(_hash) {\n    clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status.previousHash = clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status.currentHash;\n    clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status.currentHash = _hash;\n  },\n  logging: setAllLogLevel,\n\n  /**\n   * @param {boolean} value\n   */\n  overlay: function overlay(value) {\n    if (typeof document === \"undefined\") {\n      return;\n    }\n\n    options.overlay = value;\n  },\n\n  /**\n   * @param {number} value\n   */\n  reconnect: function reconnect(value) {\n    if (parsedResourceQuery.reconnect === \"false\") {\n      return;\n    }\n\n    options.reconnect = value;\n  },\n\n  /**\n   * @param {boolean} value\n   */\n  progress: function progress(value) {\n    options.progress = value;\n  },\n\n  /**\n   * @param {{ pluginName?: string, percent: number, msg: string }} data\n   */\n  \"progress-update\": function progressUpdate(data) {\n    if (options.progress) {\n      utils_log.log.info(\"\".concat(data.pluginName ? \"[\".concat(data.pluginName, \"] \") : \"\").concat(data.percent, \"% - \").concat(data.msg, \".\"));\n    }\n\n    sendMessage(\"Progress\", data);\n  },\n  \"still-ok\": function stillOk() {\n    utils_log.log.info(\"Nothing changed.\");\n\n    if (options.overlay) {\n      hide();\n    }\n\n    sendMessage(\"StillOk\");\n  },\n  ok: function ok() {\n    sendMessage(\"Ok\");\n\n    if (options.overlay) {\n      hide();\n    }\n\n    utils_reloadApp(options, clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status);\n  },\n  // TODO: remove in v5 in favor of 'static-changed'\n\n  /**\n   * @param {string} file\n   */\n  \"content-changed\": function contentChanged(file) {\n    utils_log.log.info(\"\".concat(file ? \"\\\"\".concat(file, \"\\\"\") : \"Content\", \" from static directory was changed. Reloading...\"));\n    self.location.reload();\n  },\n\n  /**\n   * @param {string} file\n   */\n  \"static-changed\": function staticChanged(file) {\n    utils_log.log.info(\"\".concat(file ? \"\\\"\".concat(file, \"\\\"\") : \"Content\", \" from static directory was changed. Reloading...\"));\n    self.location.reload();\n  },\n\n  /**\n   * @param {Error[]} warnings\n   * @param {any} params\n   */\n  warnings: function warnings(_warnings, params) {\n    utils_log.log.warn(\"Warnings while compiling.\");\n\n    var printableWarnings = _warnings.map(function (error) {\n      var _formatProblem = formatProblem(\"warning\", error),\n          header = _formatProblem.header,\n          body = _formatProblem.body;\n\n      return \"\".concat(header, \"\\n\").concat(utils_stripAnsi(body));\n    });\n\n    sendMessage(\"Warnings\", printableWarnings);\n\n    for (var i = 0; i < printableWarnings.length; i++) {\n      utils_log.log.warn(printableWarnings[i]);\n    }\n\n    var needShowOverlayForWarnings = typeof options.overlay === \"boolean\" ? options.overlay : options.overlay && options.overlay.warnings;\n\n    if (needShowOverlayForWarnings) {\n      var trustedTypesPolicyName = typeof options.overlay === \"object\" && options.overlay.trustedTypesPolicyName;\n      show(\"warning\", _warnings, trustedTypesPolicyName || null);\n    }\n\n    if (params && params.preventReloading) {\n      return;\n    }\n\n    utils_reloadApp(options, clientprotocol_ws_3A_hostname_0_0_0_0_port_8080_pathname_2Fws_logging_info_reconnect_10_status);\n  },\n\n  /**\n   * @param {Error[]} errors\n   */\n  errors: function errors(_errors) {\n    utils_log.log.error(\"Errors while compiling. Reload prevented.\");\n\n    var printableErrors = _errors.map(function (error) {\n      var _formatProblem2 = formatProblem(\"error\", error),\n          header = _formatProblem2.header,\n          body = _formatProblem2.body;\n\n      return \"\".concat(header, \"\\n\").concat(utils_stripAnsi(body));\n    });\n\n    sendMessage(\"Errors\", printableErrors);\n\n    for (var i = 0; i < printableErrors.length; i++) {\n      utils_log.log.error(printableErrors[i]);\n    }\n\n    var needShowOverlayForErrors = typeof options.overlay === \"boolean\" ? options.overlay : options.overlay && options.overlay.errors;\n\n    if (needShowOverlayForErrors) {\n      var trustedTypesPolicyName = typeof options.overlay === \"object\" && options.overlay.trustedTypesPolicyName;\n      show(\"error\", _errors, trustedTypesPolicyName || null);\n    }\n  },\n\n  /**\n   * @param {Error} error\n   */\n  error: function error(_error) {\n    utils_log.log.error(_error);\n  },\n  close: function close() {\n    utils_log.log.info(\"Disconnected!\");\n\n    if (options.overlay) {\n      hide();\n    }\n\n    sendMessage(\"Close\");\n  }\n};\nvar socketURL = utils_createSocketURL(parsedResourceQuery);\nclient_socket(socketURL, onSocketMessage, options.reconnect);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9pbmRleC5qcz9wcm90b2NvbD13cyUzQSZob3N0bmFtZT0wLjAuMC4wJnBvcnQ9ODA4MCZwYXRobmFtZT0lMkZ3cyZsb2dnaW5nPWluZm8mcmVjb25uZWN0PTEwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxzREFBc0QsZ0JBQWdCLDZDQUE2QyxvREFBb0QsSUFBSSxJQUFJLElBQUksSUFBSTtBQUN2TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0RBQWUsU0FBUyxFOztBQ25CeEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBLG1FQUFlLHNCQUFzQixFOztBQ3pCNEI7QUFDakU7QUFDQSxXQUFXLFFBQVE7QUFDbkIsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZUFBZSx5QkFBeUI7QUFDeEM7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHVCQUF1Qiw0QkFBc0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZUFBZTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxREFBZSxRQUFRLEU7Ozs7Ozs7QUN4Q3ZCO0FBQzJEO0FBQ3RCLENBQUM7O0FBRXRDOztBQUVBO0FBQ0EsT0FBTyw2QkFBNkIsMEJBQTBCLDZCQUE2QiwyQkFBMkIsNkJBQTZCLFdBQVcsNkJBQTZCLEdBQUcsMEJBQWU7QUFDN007O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7QUFD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O0FBRUEsNENBQTRDLGVBQVM7QUFDckQsS0FBSzs7QUFFTCxJQUFJLFdBQVc7O0FBRWYsb0JBQW9CLDhCQUE4QjtBQUNsRCxNQUFNLGtCQUFRO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGVBQVMsVUFBVSw4RkFBTTtBQUM3QixHQUFHOztBQUVIO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJLG1CQUFTOztBQUViO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTs7QUFFQSw0Q0FBNEMsZUFBUztBQUNyRCxLQUFLOztBQUVMLElBQUksV0FBVzs7QUFFZixvQkFBb0IsNEJBQTRCO0FBQ2hELE1BQU0sbUJBQVM7QUFDZjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJLG1CQUFTO0FBQ2IsR0FBRztBQUNIO0FBQ0EsSUFBSSxrQkFBUTs7QUFFWjtBQUNBLE1BQU0sSUFBSTtBQUNWOztBQUVBLElBQUksV0FBVztBQUNmO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQWU7QUFDL0IsYUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc3RyaXBBbnNpLmpzPzcwYWEiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzPzllMGMiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9wYXJzZVVSTC5qcz83ZGEyIiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzPzQ3YTIiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzP2ZhMDciLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcz9hNWU3Iiwid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvcmVsb2FkQXBwLmpzPzE1NjkiLCJ3ZWJwYWNrOi8vbGltaW5hbC1hcHAvLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9jcmVhdGVTb2NrZXRVUkwuanM/MmMwZSIsIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L2luZGV4LmpzPzE0OTEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFuc2lSZWdleCA9IG5ldyBSZWdFeHAoW1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLCBcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnEtdXk9Pjx+XSkpXCJdLmpvaW4oXCJ8XCIpLCBcImdcIik7XG4vKipcbiAqXG4gKiBTdHJpcCBbQU5TSSBlc2NhcGUgY29kZXNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUpIGZyb20gYSBzdHJpbmcuXG4gKiBBZGFwdGVkIGZyb20gY29kZSBvcmlnaW5hbGx5IHJlbGVhc2VkIGJ5IFNpbmRyZSBTb3JodXNcbiAqIExpY2Vuc2VkIHRoZSBNSVQgTGljZW5zZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBzdHJpcEFuc2koc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgYHN0cmluZ2AsIGdvdCBgXCIuY29uY2F0KHR5cGVvZiBzdHJpbmcsIFwiYFwiKSk7XG4gIH1cblxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4LCBcIlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaXBBbnNpOyIsIi8qKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShcInNyY1wiKTtcbiAgfSAvLyBGYWxsYmFjayB0byBnZXR0aW5nIGFsbCBzY3JpcHRzIHJ1bm5pbmcgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIHNjcmlwdEVsZW1lbnRzV2l0aFNyYyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChzY3JpcHRFbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gIH0pO1xuXG4gIGlmIChzY3JpcHRFbGVtZW50c1dpdGhTcmMubGVuZ3RoID4gMCkge1xuICAgIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNXaXRoU3JjW3NjcmlwdEVsZW1lbnRzV2l0aFNyYy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcihcIlt3ZWJwYWNrLWRldi1zZXJ2ZXJdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLlwiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCJpbXBvcnQgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSBmcm9tIFwiLi9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzXCI7XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNvdXJjZVF1ZXJ5XG4gKiBAcmV0dXJucyB7eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBib29sZWFuIH19XG4gKi9cblxuZnVuY3Rpb24gcGFyc2VVUkwocmVzb3VyY2VRdWVyeSkge1xuICAvKiogQHR5cGUge3sgW2tleTogc3RyaW5nXTogc3RyaW5nIH19ICovXG4gIHZhciBvcHRpb25zID0ge307XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSBcInN0cmluZ1wiICYmIHJlc291cmNlUXVlcnkgIT09IFwiXCIpIHtcbiAgICB2YXIgc2VhcmNoUGFyYW1zID0gcmVzb3VyY2VRdWVyeS5zbGljZSgxKS5zcGxpdChcIiZcIik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlYXJjaFBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhaXIgPSBzZWFyY2hQYXJhbXNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgb3B0aW9uc1twYWlyWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICB2YXIgc2NyaXB0U291cmNlID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAgIHZhciBzY3JpcHRTb3VyY2VVUkw7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVGhlIHBsYWNlaG9sZGVyIGBiYXNlVVJMYCB3aXRoIGB3aW5kb3cubG9jYXRpb24uaHJlZmAsXG4gICAgICAvLyBpcyB0byBhbGxvdyBwYXJzaW5nIG9mIHBhdGgtcmVsYXRpdmUgb3IgcHJvdG9jb2wtcmVsYXRpdmUgVVJMcyxcbiAgICAgIC8vIGFuZCB3aWxsIGhhdmUgbm8gZWZmZWN0IGlmIGBzY3JpcHRTb3VyY2VgIGlzIGEgZnVsbHkgdmFsaWQgVVJMLlxuICAgICAgc2NyaXB0U291cmNlVVJMID0gbmV3IFVSTChzY3JpcHRTb3VyY2UsIHNlbGYubG9jYXRpb24uaHJlZik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBVUkwgcGFyc2luZyBmYWlsZWQsIGRvIG5vdGhpbmcuXG4gICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb2NlZWQgdG8gc2VlIGlmIHdlIGNhbiByZWNvdmVyIHVzaW5nIGByZXNvdXJjZVF1ZXJ5YFxuICAgIH1cblxuICAgIGlmIChzY3JpcHRTb3VyY2VVUkwpIHtcbiAgICAgIG9wdGlvbnMgPSBzY3JpcHRTb3VyY2VVUkw7XG4gICAgICBvcHRpb25zLmZyb21DdXJyZW50U2NyaXB0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2VVUkw7IiwiLyogZ2xvYmFsIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICovXG5pbXBvcnQgV2ViU29ja2V0Q2xpZW50IGZyb20gXCIuL2NsaWVudHMvV2ViU29ja2V0Q2xpZW50LmpzXCI7XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi91dGlscy9sb2cuanNcIjsgLy8gdGhpcyBXZWJzb2NrZXRDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgdGhlIGNsaWVudCBpcyBub3QgaW5qZWN0ZWRcblxuLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5cbnZhciBDbGllbnQgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbnR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXy5kZWZhdWx0ICE9PSBcInVuZGVmaW5lZFwiID8gX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18uZGVmYXVsdCA6IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogV2ViU29ja2V0Q2xpZW50O1xuLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cblxudmFyIHJldHJpZXMgPSAwO1xudmFyIG1heFJldHJpZXMgPSAxMDsgLy8gSW5pdGlhbGl6ZWQgY2xpZW50IGlzIGV4cG9ydGVkIHNvIGV4dGVybmFsIGNvbnN1bWVycyBjYW4gdXRpbGl6ZSB0aGUgc2FtZSBpbnN0YW5jZVxuLy8gSXQgaXMgbXV0YWJsZSB0byBlbmZvcmNlIHNpbmdsZXRvblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcblxuZXhwb3J0IHZhciBjbGllbnQgPSBudWxsO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge3sgW2hhbmRsZXI6IHN0cmluZ106IChkYXRhPzogYW55LCBwYXJhbXM/OiBhbnkpID0+IGFueSB9fSBoYW5kbGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtyZWNvbm5lY3RdXG4gKi9cblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycywgcmVjb25uZWN0KSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG5cbiAgICBpZiAodHlwZW9mIHJlY29ubmVjdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgbWF4UmV0cmllcyA9IHJlY29ubmVjdDtcbiAgICB9XG4gIH0pO1xuICBjbGllbnQub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG5cbiAgICBjbGllbnQgPSBudWxsOyAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG5cbiAgICBpZiAocmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIGxvZy5pbmZvKFwiVHJ5aW5nIHRvIHJlY29ubmVjdC4uLlwiKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycywgcmVjb25uZWN0KTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShcbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttZXNzYWdlLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttZXNzYWdlLnR5cGVdKG1lc3NhZ2UuZGF0YSwgbWVzc2FnZS5wYXJhbXMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzb2NrZXQ7IiwiLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5pbXBvcnQgYW5zaUhUTUwgZnJvbSBcImFuc2ktaHRtbC1jb21tdW5pdHlcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCJodG1sLWVudGl0aWVzXCI7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogW1widHJhbnNwYXJlbnRcIiwgXCJ0cmFuc3BhcmVudFwiXSxcbiAgYmxhY2s6IFwiMTgxODE4XCIsXG4gIHJlZDogXCJFMzYwNDlcIixcbiAgZ3JlZW46IFwiQjNDQjc0XCIsXG4gIHllbGxvdzogXCJGRkQwODBcIixcbiAgYmx1ZTogXCI3Q0FGQzJcIixcbiAgbWFnZW50YTogXCI3RkFDQ0FcIixcbiAgY3lhbjogXCJDM0MyRUZcIixcbiAgbGlnaHRncmV5OiBcIkVCRTdFM1wiLFxuICBkYXJrZ3JleTogXCI2RDc4OTFcIlxufTtcbi8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xuXG52YXIgaWZyYW1lQ29udGFpbmVyRWxlbWVudDtcbi8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkfSAqL1xuXG52YXIgY29udGFpbmVyRWxlbWVudDtcbi8qKiBAdHlwZSB7QXJyYXk8KGVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50KSA9PiB2b2lkPn0gKi9cblxudmFyIG9uTG9hZFF1ZXVlID0gW107XG4vKiogQHR5cGUge1RydXN0ZWRUeXBlUG9saWN5IHwgdW5kZWZpbmVkfSAqL1xuXG52YXIgb3ZlcmxheVRydXN0ZWRUeXBlc1BvbGljeTtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHRydXN0ZWRUeXBlc1BvbGljeU5hbWVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIodHJ1c3RlZFR5cGVzUG9saWN5TmFtZSkge1xuICAvLyBFbmFibGUgVHJ1c3RlZCBUeXBlcyBpZiB0aGV5IGFyZSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAgaWYgKHdpbmRvdy50cnVzdGVkVHlwZXMpIHtcbiAgICBvdmVybGF5VHJ1c3RlZFR5cGVzUG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kodHJ1c3RlZFR5cGVzUG9saWN5TmFtZSB8fCBcIndlYnBhY2stZGV2LXNlcnZlciNvdmVybGF5XCIsIHtcbiAgICAgIGNyZWF0ZUhUTUw6IGZ1bmN0aW9uIGNyZWF0ZUhUTUwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuaWQgPSBcIndlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheVwiO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnNyYyA9IFwiYWJvdXQ6YmxhbmtcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDB2d1wiO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIjtcbiAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuXG4gIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRhaW5lckVsZW1lbnQgPVxuICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG5cbiAgICAvKiogQHR5cGUge0hUTUxJRnJhbWVFbGVtZW50fSAqL1xuICAgIGlmcmFtZUNvbnRhaW5lckVsZW1lbnQuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29udGFpbmVyRWxlbWVudC5pZCA9IFwid2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdlwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmxlZnQgPSAwO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUudG9wID0gMDtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLnJpZ2h0ID0gMDtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmJvdHRvbSA9IDA7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMTAwdndcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmhlaWdodCA9IFwiMTAwdmhcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYSgwLCAwLCAwLCAwLjg1KVwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuY29sb3IgPSBcIiNFOEU4RThcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmZvbnRGYW1pbHkgPSBcIk1lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlXCI7XG4gICAgY29udGFpbmVyRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IFwibGFyZ2VcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLnBhZGRpbmcgPSBcIjJyZW1cIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLmxpbmVIZWlnaHQgPSBcIjEuMlwiO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlLXdyYXBcIjtcbiAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJhdXRvXCI7XG4gICAgdmFyIGhlYWRlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXJFbGVtZW50LmlubmVyVGV4dCA9IFwiQ29tcGlsZWQgd2l0aCBwcm9ibGVtczpcIjtcbiAgICB2YXIgY2xvc2VCdXR0b25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuaW5uZXJUZXh0ID0gXCJYXCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmJhY2tncm91bmQgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmJvcmRlciA9IFwibm9uZVwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IFwiMjBweFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgY2xvc2VCdXR0b25FbGVtZW50LnN0eWxlLmNvbG9yID0gXCJ3aGl0ZVwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICBjbG9zZUJ1dHRvbkVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPSBcInJpZ2h0XCI7IC8vIEB0cy1pZ25vcmVcblxuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5zdHlsZS5zdHlsZUZsb2F0ID0gXCJyaWdodFwiO1xuICAgIGNsb3NlQnV0dG9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaGlkZSgpO1xuICAgIH0pO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoaGVhZGVyRWxlbWVudCk7XG4gICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbkVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cblxuICAgIC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovXG4gICAgaWZyYW1lQ29udGFpbmVyRWxlbWVudC5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXJFbGVtZW50KTtcbiAgICBvbkxvYWRRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChvbkxvYWQpIHtcbiAgICAgIG9uTG9hZChcbiAgICAgIC8qKiBAdHlwZSB7SFRNTERpdkVsZW1lbnR9ICovXG4gICAgICBjb250YWluZXJFbGVtZW50KTtcbiAgICB9KTtcbiAgICBvbkxvYWRRdWV1ZSA9IFtdO1xuICAgIC8qKiBAdHlwZSB7SFRNTElGcmFtZUVsZW1lbnR9ICovXG5cbiAgICBpZnJhbWVDb250YWluZXJFbGVtZW50Lm9ubG9hZCA9IG51bGw7XG4gIH07XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWVDb250YWluZXJFbGVtZW50KTtcbn1cbi8qKlxuICogQHBhcmFtIHsoZWxlbWVudDogSFRNTERpdkVsZW1lbnQpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHRydXN0ZWRUeXBlc1BvbGljeU5hbWVcbiAqL1xuXG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlFeGlzdHMoY2FsbGJhY2ssIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUpIHtcbiAgaWYgKGNvbnRhaW5lckVsZW1lbnQpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIGNhbGxiYWNrKGNvbnRhaW5lckVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG9uTG9hZFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuXG4gIGlmIChpZnJhbWVDb250YWluZXJFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3JlYXRlQ29udGFpbmVyKHRydXN0ZWRUeXBlc1BvbGljeU5hbWUpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5cbmZ1bmN0aW9uIGhpZGUoKSB7XG4gIGlmICghaWZyYW1lQ29udGFpbmVyRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG5cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZUNvbnRhaW5lckVsZW1lbnQpO1xuICBpZnJhbWVDb250YWluZXJFbGVtZW50ID0gbnVsbDtcbiAgY29udGFpbmVyRWxlbWVudCA9IG51bGw7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZyAgfCB7IGZpbGU/OiBzdHJpbmcsIG1vZHVsZU5hbWU/OiBzdHJpbmcsIGxvYz86IHN0cmluZywgbWVzc2FnZT86IHN0cmluZyB9fSBpdGVtXG4gKiBAcmV0dXJucyB7eyBoZWFkZXI6IHN0cmluZywgYm9keTogc3RyaW5nIH19XG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9ibGVtKHR5cGUsIGl0ZW0pIHtcbiAgdmFyIGhlYWRlciA9IHR5cGUgPT09IFwid2FybmluZ1wiID8gXCJXQVJOSU5HXCIgOiBcIkVSUk9SXCI7XG4gIHZhciBib2R5ID0gXCJcIjtcblxuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICBib2R5ICs9IGl0ZW07XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpbGUgPSBpdGVtLmZpbGUgfHwgXCJcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG5cbiAgICB2YXIgbW9kdWxlTmFtZSA9IGl0ZW0ubW9kdWxlTmFtZSA/IGl0ZW0ubW9kdWxlTmFtZS5pbmRleE9mKFwiIVwiKSAhPT0gLTEgPyBcIlwiLmNvbmNhdChpdGVtLm1vZHVsZU5hbWUucmVwbGFjZSgvXihcXHN8XFxTKSohLywgXCJcIiksIFwiIChcIikuY29uY2F0KGl0ZW0ubW9kdWxlTmFtZSwgXCIpXCIpIDogXCJcIi5jb25jYXQoaXRlbS5tb2R1bGVOYW1lKSA6IFwiXCI7XG4gICAgdmFyIGxvYyA9IGl0ZW0ubG9jO1xuICAgIGhlYWRlciArPSBcIlwiLmNvbmNhdChtb2R1bGVOYW1lIHx8IGZpbGUgPyBcIiBpbiBcIi5jb25jYXQobW9kdWxlTmFtZSA/IFwiXCIuY29uY2F0KG1vZHVsZU5hbWUpLmNvbmNhdChmaWxlID8gXCIgKFwiLmNvbmNhdChmaWxlLCBcIilcIikgOiBcIlwiKSA6IGZpbGUpLmNvbmNhdChsb2MgPyBcIiBcIi5jb25jYXQobG9jKSA6IFwiXCIpIDogXCJcIik7XG4gICAgYm9keSArPSBpdGVtLm1lc3NhZ2UgfHwgXCJcIjtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgYm9keTogYm9keVxuICB9O1xufSAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtBcnJheTxzdHJpbmcgIHwgeyBmaWxlPzogc3RyaW5nLCBtb2R1bGVOYW1lPzogc3RyaW5nLCBsb2M/OiBzdHJpbmcsIG1lc3NhZ2U/OiBzdHJpbmcgfT59IG1lc3NhZ2VzXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHRydXN0ZWRUeXBlc1BvbGljeU5hbWVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNob3codHlwZSwgbWVzc2FnZXMsIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUpIHtcbiAgZW5zdXJlT3ZlcmxheUV4aXN0cyhmdW5jdGlvbiAoKSB7XG4gICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgdmFyIGVudHJ5RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB2YXIgdHlwZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgdmFyIF9mb3JtYXRQcm9ibGVtID0gZm9ybWF0UHJvYmxlbSh0eXBlLCBtZXNzYWdlKSxcbiAgICAgICAgICBoZWFkZXIgPSBfZm9ybWF0UHJvYmxlbS5oZWFkZXIsXG4gICAgICAgICAgYm9keSA9IF9mb3JtYXRQcm9ibGVtLmJvZHk7XG5cbiAgICAgIHR5cGVFbGVtZW50LmlubmVyVGV4dCA9IGhlYWRlcjtcbiAgICAgIHR5cGVFbGVtZW50LnN0eWxlLmNvbG9yID0gXCIjXCIuY29uY2F0KGNvbG9ycy5yZWQpOyAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXG5cbiAgICAgIHZhciB0ZXh0ID0gYW5zaUhUTUwoZW5jb2RlKGJvZHkpKTtcbiAgICAgIHZhciBtZXNzYWdlVGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgbWVzc2FnZVRleHROb2RlLmlubmVySFRNTCA9IG92ZXJsYXlUcnVzdGVkVHlwZXNQb2xpY3kgPyBvdmVybGF5VHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwodGV4dCkgOiB0ZXh0O1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKHR5cGVFbGVtZW50KTtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICBlbnRyeUVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZVRleHROb2RlKTtcbiAgICAgIGVudHJ5RWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgZW50cnlFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50fSAqL1xuXG4gICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGVudHJ5RWxlbWVudCk7XG4gICAgfSk7XG4gIH0sIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUpO1xufVxuXG5leHBvcnQgeyBmb3JtYXRQcm9ibGVtLCBzaG93LCBoaWRlIH07IiwiLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSAqL1xuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHthbnl9IFtkYXRhXVxuICovXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09IFwidW5kZWZpbmVkXCIgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sIFwiKlwiKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzZW5kTXNnOyIsImltcG9ydCBob3RFbWl0dGVyIGZyb20gXCJ3ZWJwYWNrL2hvdC9lbWl0dGVyLmpzXCI7XG5pbXBvcnQgeyBsb2cgfSBmcm9tIFwiLi9sb2cuanNcIjtcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vaW5kZXhcIikuT3B0aW9uc30gT3B0aW9uc1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoXCIuLi9pbmRleFwiKS5TdGF0dXN9IFN0YXR1c1xuXG4vKipcbiAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9uc1xuICogQHBhcmFtIHtTdGF0dXN9IHN0YXR1c1xuICovXG5cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBzdGF0dXMpIHtcbiAgdmFyIGhvdCA9IF9yZWYuaG90LFxuICAgICAgbGl2ZVJlbG9hZCA9IF9yZWYubGl2ZVJlbG9hZDtcblxuICBpZiAoc3RhdHVzLmlzVW5sb2FkaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRIYXNoID0gc3RhdHVzLmN1cnJlbnRIYXNoLFxuICAgICAgcHJldmlvdXNIYXNoID0gc3RhdHVzLnByZXZpb3VzSGFzaDtcbiAgdmFyIGlzSW5pdGlhbCA9IGN1cnJlbnRIYXNoLmluZGV4T2YoXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICBwcmV2aW91c0hhc2gpID49IDA7XG5cbiAgaWYgKGlzSW5pdGlhbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtXaW5kb3d9IHJvb3RXaW5kb3dcbiAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsSWRcbiAgICovXG5cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbyhcIkFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi5cIik7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSBzZWxmLmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWxsb3dUb0hvdCA9IHNlYXJjaC5pbmRleE9mKFwid2VicGFjay1kZXYtc2VydmVyLWhvdD1mYWxzZVwiKSA9PT0gLTE7XG4gIHZhciBhbGxvd1RvTGl2ZVJlbG9hZCA9IHNlYXJjaC5pbmRleE9mKFwid2VicGFjay1kZXYtc2VydmVyLWxpdmUtcmVsb2FkPWZhbHNlXCIpID09PSAtMTtcblxuICBpZiAoaG90ICYmIGFsbG93VG9Ib3QpIHtcbiAgICBsb2cuaW5mbyhcIkFwcCBob3QgdXBkYXRlLi4uXCIpO1xuICAgIGhvdEVtaXR0ZXIuZW1pdChcIndlYnBhY2tIb3RVcGRhdGVcIiwgc3RhdHVzLmN1cnJlbnRIYXNoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXCJ3ZWJwYWNrSG90VXBkYXRlXCIuY29uY2F0KHN0YXR1cy5jdXJyZW50SGFzaCksIFwiKlwiKTtcbiAgICB9XG4gIH0gLy8gYWxsb3cgcmVmcmVzaGluZyB0aGUgcGFnZSBvbmx5IGlmIGxpdmVSZWxvYWQgaXNuJ3QgZGlzYWJsZWRcbiAgZWxzZSBpZiAobGl2ZVJlbG9hZCAmJiBhbGxvd1RvTGl2ZVJlbG9hZCkge1xuICAgIHZhciByb290V2luZG93ID0gc2VsZjsgLy8gdXNlIHBhcmVudCB3aW5kb3cgZm9yIHJlbG9hZCAoaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUgd2l0aCBubyB2YWxpZCBzcmMpXG5cbiAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09IFwiYWJvdXQ6XCIpIHtcbiAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXG4gICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xuXG4gICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlbG9hZEFwcDsiLCIvKipcbiAqIEBwYXJhbSB7eyBwcm90b2NvbD86IHN0cmluZywgYXV0aD86IHN0cmluZywgaG9zdG5hbWU/OiBzdHJpbmcsIHBvcnQ/OiBzdHJpbmcsIHBhdGhuYW1lPzogc3RyaW5nLCBzZWFyY2g/OiBzdHJpbmcsIGhhc2g/OiBzdHJpbmcsIHNsYXNoZXM/OiBib29sZWFuIH19IG9ialVSTFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KG9ialVSTCkge1xuICB2YXIgcHJvdG9jb2wgPSBvYmpVUkwucHJvdG9jb2wgfHwgXCJcIjtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gXCI6XCIpIHtcbiAgICBwcm90b2NvbCArPSBcIjpcIjtcbiAgfVxuXG4gIHZhciBhdXRoID0gb2JqVVJMLmF1dGggfHwgXCJcIjtcblxuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksIFwiOlwiKTtcbiAgICBhdXRoICs9IFwiQFwiO1xuICB9XG5cbiAgdmFyIGhvc3QgPSBcIlwiO1xuXG4gIGlmIChvYmpVUkwuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArIChvYmpVUkwuaG9zdG5hbWUuaW5kZXhPZihcIjpcIikgPT09IC0xID8gb2JqVVJMLmhvc3RuYW1lIDogXCJbXCIuY29uY2F0KG9ialVSTC5ob3N0bmFtZSwgXCJdXCIpKTtcblxuICAgIGlmIChvYmpVUkwucG9ydCkge1xuICAgICAgaG9zdCArPSBcIjpcIi5jb25jYXQob2JqVVJMLnBvcnQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwYXRobmFtZSA9IG9ialVSTC5wYXRobmFtZSB8fCBcIlwiO1xuXG4gIGlmIChvYmpVUkwuc2xhc2hlcykge1xuICAgIGhvc3QgPSBcIi8vXCIuY29uY2F0KGhvc3QgfHwgXCJcIik7XG5cbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIi5jb25jYXQocGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSBcIlwiO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IG9ialVSTC5zZWFyY2ggfHwgXCJcIjtcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09IFwiP1wiKSB7XG4gICAgc2VhcmNoID0gXCI/XCIuY29uY2F0KHNlYXJjaCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG9ialVSTC5oYXNoIHx8IFwiXCI7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09IFwiI1wiKSB7XG4gICAgaGFzaCA9IFwiI1wiLmNvbmNhdChoYXNoKTtcbiAgfVxuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKFwiI1wiLCBcIiUyM1wiKTtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHByb3RvY29sKS5jb25jYXQoaG9zdCkuY29uY2F0KHBhdGhuYW1lKS5jb25jYXQoc2VhcmNoKS5jb25jYXQoaGFzaCk7XG59XG4vKipcbiAqIEBwYXJhbSB7VVJMICYgeyBmcm9tQ3VycmVudFNjcmlwdD86IGJvb2xlYW4gfX0gcGFyc2VkVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VVJMKHBhcnNlZFVSTCkge1xuICB2YXIgaG9zdG5hbWUgPSBwYXJzZWRVUkwuaG9zdG5hbWU7IC8vIE5vZGUuanMgbW9kdWxlIHBhcnNlcyBpdCBhcyBgOjpgXG4gIC8vIGBuZXcgVVJMKHVybFN0cmluZywgW2Jhc2VVUkxTdHJpbmddKWAgcGFyc2VzIGl0IGFzICdbOjpdJ1xuXG4gIHZhciBpc0luQWRkckFueSA9IGhvc3RuYW1lID09PSBcIjAuMC4wLjBcIiB8fCBob3N0bmFtZSA9PT0gXCI6OlwiIHx8IGhvc3RuYW1lID09PSBcIls6Ol1cIjsgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcblxuICBpZiAoaXNJbkFkZHJBbnkgJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAmJiBzZWxmLmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoXCJodHRwXCIpID09PSAwKSB7XG4gICAgaG9zdG5hbWUgPSBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG5cbiAgdmFyIHNvY2tldFVSTFByb3RvY29sID0gcGFyc2VkVVJMLnByb3RvY29sIHx8IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7IC8vIFdoZW4gaHR0cHMgaXMgdXNlZCBpbiB0aGUgYXBwLCBzZWN1cmUgd2ViIHNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYiBzb2NrZXRzLlxuXG4gIGlmIChzb2NrZXRVUkxQcm90b2NvbCA9PT0gXCJhdXRvOlwiIHx8IGhvc3RuYW1lICYmIGlzSW5BZGRyQW55ICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIpIHtcbiAgICBzb2NrZXRVUkxQcm90b2NvbCA9IHNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG4gIH1cblxuICBzb2NrZXRVUkxQcm90b2NvbCA9IHNvY2tldFVSTFByb3RvY29sLnJlcGxhY2UoL14oPzpodHRwfC4rLWV4dGVuc2lvbnxmaWxlKS9pLCBcIndzXCIpO1xuICB2YXIgc29ja2V0VVJMQXV0aCA9IFwiXCI7IC8vIGBuZXcgVVJMKHVybFN0cmluZywgW2Jhc2VVUkxzdHJpbmddKWAgZG9lc24ndCBoYXZlIGBhdXRoYCBwcm9wZXJ0eVxuICAvLyBQYXJzZSBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFscyBpbiBjYXNlIHdlIG5lZWQgdGhlbVxuXG4gIGlmIChwYXJzZWRVUkwudXNlcm5hbWUpIHtcbiAgICBzb2NrZXRVUkxBdXRoID0gcGFyc2VkVVJMLnVzZXJuYW1lOyAvLyBTaW5jZSBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uIGRvZXMgbm90IGFsbG93IGVtcHR5IHVzZXJuYW1lLFxuICAgIC8vIHdlIG9ubHkgaW5jbHVkZSBwYXNzd29yZCBpZiB0aGUgdXNlcm5hbWUgaXMgbm90IGVtcHR5LlxuXG4gICAgaWYgKHBhcnNlZFVSTC5wYXNzd29yZCkge1xuICAgICAgLy8gUmVzdWx0OiA8dXNlcm5hbWU+OjxwYXNzd29yZD5cbiAgICAgIHNvY2tldFVSTEF1dGggPSBzb2NrZXRVUkxBdXRoLmNvbmNhdChcIjpcIiwgcGFyc2VkVVJMLnBhc3N3b3JkKTtcbiAgICB9XG4gIH0gLy8gSW4gY2FzZSB0aGUgaG9zdCBpcyBhIHJhdyBJUHY2IGFkZHJlc3MsIGl0IGNhbiBiZSBlbmNsb3NlZCBpblxuICAvLyB0aGUgYnJhY2tldHMgYXMgdGhlIGJyYWNrZXRzIGFyZSBuZWVkZWQgaW4gdGhlIGZpbmFsIFVSTCBzdHJpbmcuXG4gIC8vIE5lZWQgdG8gcmVtb3ZlIHRob3NlIGFzIHVybC5mb3JtYXQgYmxpbmRseSBhZGRzIGl0cyBvd24gc2V0IG9mIGJyYWNrZXRzXG4gIC8vIGlmIHRoZSBob3N0IHN0cmluZyBjb250YWlucyBjb2xvbnMuIFRoYXQgd291bGQgbGVhZCB0byBub24td29ya2luZ1xuICAvLyBkb3VibGUgYnJhY2tldHMgKGUuZy4gW1s6Ol1dKSBob3N0XG4gIC8vXG4gIC8vIEFsbCBvZiB0aGVzZSB3ZWIgc29ja2V0IHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2ggcmVzb3VyY2VRdWVyeSxcbiAgLy8gc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja2V0VVJMSG9zdG5hbWUgPSAoaG9zdG5hbWUgfHwgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSB8fCBcImxvY2FsaG9zdFwiKS5yZXBsYWNlKC9eXFxbKC4qKVxcXSQvLCBcIiQxXCIpO1xuICB2YXIgc29ja2V0VVJMUG9ydCA9IHBhcnNlZFVSTC5wb3J0O1xuXG4gIGlmICghc29ja2V0VVJMUG9ydCB8fCBzb2NrZXRVUkxQb3J0ID09PSBcIjBcIikge1xuICAgIHNvY2tldFVSTFBvcnQgPSBzZWxmLmxvY2F0aW9uLnBvcnQ7XG4gIH0gLy8gSWYgcGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgLy8gY2xpZW50IHRvIG9wZW4gdGhlIHNvY2tldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cblxuXG4gIHZhciBzb2NrZXRVUkxQYXRobmFtZSA9IFwiL3dzXCI7XG5cbiAgaWYgKHBhcnNlZFVSTC5wYXRobmFtZSAmJiAhcGFyc2VkVVJMLmZyb21DdXJyZW50U2NyaXB0KSB7XG4gICAgc29ja2V0VVJMUGF0aG5hbWUgPSBwYXJzZWRVUkwucGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4gZm9ybWF0KHtcbiAgICBwcm90b2NvbDogc29ja2V0VVJMUHJvdG9jb2wsXG4gICAgYXV0aDogc29ja2V0VVJMQXV0aCxcbiAgICBob3N0bmFtZTogc29ja2V0VVJMSG9zdG5hbWUsXG4gICAgcG9ydDogc29ja2V0VVJMUG9ydCxcbiAgICBwYXRobmFtZTogc29ja2V0VVJMUGF0aG5hbWUsXG4gICAgc2xhc2hlczogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU29ja2V0VVJMOyIsIi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnksIF9fd2VicGFja19oYXNoX18gKi9cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwid2VicGFjay9tb2R1bGVcIiAvPlxuaW1wb3J0IHdlYnBhY2tIb3RMb2cgZnJvbSBcIndlYnBhY2svaG90L2xvZy5qc1wiO1xuaW1wb3J0IHN0cmlwQW5zaSBmcm9tIFwiLi91dGlscy9zdHJpcEFuc2kuanNcIjtcbmltcG9ydCBwYXJzZVVSTCBmcm9tIFwiLi91dGlscy9wYXJzZVVSTC5qc1wiO1xuaW1wb3J0IHNvY2tldCBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbmltcG9ydCB7IGZvcm1hdFByb2JsZW0sIHNob3csIGhpZGUgfSBmcm9tIFwiLi9vdmVybGF5LmpzXCI7XG5pbXBvcnQgeyBsb2csIHNldExvZ0xldmVsIH0gZnJvbSBcIi4vdXRpbHMvbG9nLmpzXCI7XG5pbXBvcnQgc2VuZE1lc3NhZ2UgZnJvbSBcIi4vdXRpbHMvc2VuZE1lc3NhZ2UuanNcIjtcbmltcG9ydCByZWxvYWRBcHAgZnJvbSBcIi4vdXRpbHMvcmVsb2FkQXBwLmpzXCI7XG5pbXBvcnQgY3JlYXRlU29ja2V0VVJMIGZyb20gXCIuL3V0aWxzL2NyZWF0ZVNvY2tldFVSTC5qc1wiO1xuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhvdFxuICogQHByb3BlcnR5IHtib29sZWFufSBsaXZlUmVsb2FkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHByb2dyZXNzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCB7IHdhcm5pbmdzPzogYm9vbGVhbiwgZXJyb3JzPzogYm9vbGVhbiwgdHJ1c3RlZFR5cGVzUG9saWN5TmFtZT86IHN0cmluZyB9fSBvdmVybGF5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xvZ2dpbmddXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JlY29ubmVjdF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXR1c1xuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VubG9hZGluZ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGN1cnJlbnRIYXNoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3ByZXZpb3VzSGFzaF1cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtTdGF0dXN9XG4gKi9cblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICAvLyBUT0RPIFdvcmthcm91bmQgZm9yIHdlYnBhY2sgdjQsIGBfX3dlYnBhY2tfaGFzaF9fYCBpcyBub3QgcmVwbGFjZWQgd2l0aG91dCBIb3RNb2R1bGVSZXBsYWNlbWVudFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gIGN1cnJlbnRIYXNoOiB0eXBlb2YgX193ZWJwYWNrX2hhc2hfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19oYXNoX18gOiBcIlwiXG59O1xuLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xuXG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgbGl2ZVJlbG9hZDogZmFsc2UsXG4gIHByb2dyZXNzOiBmYWxzZSxcbiAgb3ZlcmxheTogZmFsc2Vcbn07XG52YXIgcGFyc2VkUmVzb3VyY2VRdWVyeSA9IHBhcnNlVVJMKF9fcmVzb3VyY2VRdWVyeSk7XG5cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmhvdCA9PT0gXCJ0cnVlXCIpIHtcbiAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICBsb2cuaW5mbyhcIkhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC5cIik7XG59XG5cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5W1wibGl2ZS1yZWxvYWRcIl0gPT09IFwidHJ1ZVwiKSB7XG4gIG9wdGlvbnMubGl2ZVJlbG9hZCA9IHRydWU7XG4gIGxvZy5pbmZvKFwiTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC5cIik7XG59XG5cbmlmIChwYXJzZWRSZXNvdXJjZVF1ZXJ5LmxvZ2dpbmcpIHtcbiAgb3B0aW9ucy5sb2dnaW5nID0gcGFyc2VkUmVzb3VyY2VRdWVyeS5sb2dnaW5nO1xufVxuXG5pZiAodHlwZW9mIHBhcnNlZFJlc291cmNlUXVlcnkucmVjb25uZWN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIG9wdGlvbnMucmVjb25uZWN0ID0gTnVtYmVyKHBhcnNlZFJlc291cmNlUXVlcnkucmVjb25uZWN0KTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGxldmVsXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRBbGxMb2dMZXZlbChsZXZlbCkge1xuICAvLyBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBITVIgbG9nZ2VyIG9wZXJhdGUgc2VwYXJhdGVseSBmcm9tIGRldiBzZXJ2ZXIgbG9nZ2VyXG4gIHdlYnBhY2tIb3RMb2cuc2V0TG9nTGV2ZWwobGV2ZWwgPT09IFwidmVyYm9zZVwiIHx8IGxldmVsID09PSBcImxvZ1wiID8gXCJpbmZvXCIgOiBsZXZlbCk7XG4gIHNldExvZ0xldmVsKGxldmVsKTtcbn1cblxuaWYgKG9wdGlvbnMubG9nZ2luZykge1xuICBzZXRBbGxMb2dMZXZlbChvcHRpb25zLmxvZ2dpbmcpO1xufVxuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG52YXIgb25Tb2NrZXRNZXNzYWdlID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBpZiAocGFyc2VkUmVzb3VyY2VRdWVyeS5ob3QgPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaG90ID0gdHJ1ZTtcbiAgICBsb2cuaW5mbyhcIkhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC5cIik7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgaWYgKHBhcnNlZFJlc291cmNlUXVlcnlbXCJsaXZlLXJlbG9hZFwiXSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbyhcIkxpdmUgUmVsb2FkaW5nIGVuYWJsZWQuXCIpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKFwiQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uXCIpOyAvLyBGaXhlcyAjMTA0Mi4gb3ZlcmxheSBkb2Vzbid0IGNsZWFyIGlmIGVycm9ycyBhcmUgZml4ZWQgYnV0IHdhcm5pbmdzIHJlbWFpbi5cblxuICAgIGlmIChvcHRpb25zLm92ZXJsYXkpIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShcIkludmFsaWRcIik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoXG4gICAqL1xuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLnByZXZpb3VzSGFzaCA9IHN0YXR1cy5jdXJyZW50SGFzaDtcbiAgICBzdGF0dXMuY3VycmVudEhhc2ggPSBfaGFzaDtcbiAgfSxcbiAgbG9nZ2luZzogc2V0QWxsTG9nTGV2ZWwsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucy5vdmVybGF5ID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVjb25uZWN0OiBmdW5jdGlvbiByZWNvbm5lY3QodmFsdWUpIHtcbiAgICBpZiAocGFyc2VkUmVzb3VyY2VRdWVyeS5yZWNvbm5lY3QgPT09IFwiZmFsc2VcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMucmVjb25uZWN0ID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSkge1xuICAgIG9wdGlvbnMucHJvZ3Jlc3MgPSB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHt7IHBsdWdpbk5hbWU/OiBzdHJpbmcsIHBlcmNlbnQ6IG51bWJlciwgbXNnOiBzdHJpbmcgfX0gZGF0YVxuICAgKi9cbiAgXCJwcm9ncmVzcy11cGRhdGVcIjogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmIChvcHRpb25zLnByb2dyZXNzKSB7XG4gICAgICBsb2cuaW5mbyhcIlwiLmNvbmNhdChkYXRhLnBsdWdpbk5hbWUgPyBcIltcIi5jb25jYXQoZGF0YS5wbHVnaW5OYW1lLCBcIl0gXCIpIDogXCJcIikuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZShcIlByb2dyZXNzXCIsIGRhdGEpO1xuICB9LFxuICBcInN0aWxsLW9rXCI6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oXCJOb3RoaW5nIGNoYW5nZWQuXCIpO1xuXG4gICAgaWYgKG9wdGlvbnMub3ZlcmxheSkge1xuICAgICAgaGlkZSgpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKFwiU3RpbGxPa1wiKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKFwiT2tcIik7XG5cbiAgICBpZiAob3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICBoaWRlKCk7XG4gICAgfVxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIC8vIFRPRE86IHJlbW92ZSBpbiB2NSBpbiBmYXZvciBvZiAnc3RhdGljLWNoYW5nZWQnXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlXG4gICAqL1xuICBcImNvbnRlbnQtY2hhbmdlZFwiOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZChmaWxlKSB7XG4gICAgbG9nLmluZm8oXCJcIi5jb25jYXQoZmlsZSA/IFwiXFxcIlwiLmNvbmNhdChmaWxlLCBcIlxcXCJcIikgOiBcIkNvbnRlbnRcIiwgXCIgZnJvbSBzdGF0aWMgZGlyZWN0b3J5IHdhcyBjaGFuZ2VkLiBSZWxvYWRpbmcuLi5cIikpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlXG4gICAqL1xuICBcInN0YXRpYy1jaGFuZ2VkXCI6IGZ1bmN0aW9uIHN0YXRpY0NoYW5nZWQoZmlsZSkge1xuICAgIGxvZy5pbmZvKFwiXCIuY29uY2F0KGZpbGUgPyBcIlxcXCJcIi5jb25jYXQoZmlsZSwgXCJcXFwiXCIpIDogXCJDb250ZW50XCIsIFwiIGZyb20gc3RhdGljIGRpcmVjdG9yeSB3YXMgY2hhbmdlZC4gUmVsb2FkaW5nLi4uXCIpKTtcbiAgICBzZWxmLmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yW119IHdhcm5pbmdzXG4gICAqIEBwYXJhbSB7YW55fSBwYXJhbXNcbiAgICovXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MsIHBhcmFtcykge1xuICAgIGxvZy53YXJuKFwiV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLlwiKTtcblxuICAgIHZhciBwcmludGFibGVXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICB2YXIgX2Zvcm1hdFByb2JsZW0gPSBmb3JtYXRQcm9ibGVtKFwid2FybmluZ1wiLCBlcnJvciksXG4gICAgICAgICAgaGVhZGVyID0gX2Zvcm1hdFByb2JsZW0uaGVhZGVyLFxuICAgICAgICAgIGJvZHkgPSBfZm9ybWF0UHJvYmxlbS5ib2R5O1xuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZGVyLCBcIlxcblwiKS5jb25jYXQoc3RyaXBBbnNpKGJvZHkpKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKFwiV2FybmluZ3NcIiwgcHJpbnRhYmxlV2FybmluZ3MpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmludGFibGVXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4ocHJpbnRhYmxlV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIHZhciBuZWVkU2hvd092ZXJsYXlGb3JXYXJuaW5ncyA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5vdmVybGF5IDogb3B0aW9ucy5vdmVybGF5ICYmIG9wdGlvbnMub3ZlcmxheS53YXJuaW5ncztcblxuICAgIGlmIChuZWVkU2hvd092ZXJsYXlGb3JXYXJuaW5ncykge1xuICAgICAgdmFyIHRydXN0ZWRUeXBlc1BvbGljeU5hbWUgPSB0eXBlb2Ygb3B0aW9ucy5vdmVybGF5ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMub3ZlcmxheS50cnVzdGVkVHlwZXNQb2xpY3lOYW1lO1xuICAgICAgc2hvdyhcIndhcm5pbmdcIiwgX3dhcm5pbmdzLCB0cnVzdGVkVHlwZXNQb2xpY3lOYW1lIHx8IG51bGwpO1xuICAgIH1cblxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLnByZXZlbnRSZWxvYWRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcltdfSBlcnJvcnNcbiAgICovXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoXCJFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLlwiKTtcblxuICAgIHZhciBwcmludGFibGVFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHZhciBfZm9ybWF0UHJvYmxlbTIgPSBmb3JtYXRQcm9ibGVtKFwiZXJyb3JcIiwgZXJyb3IpLFxuICAgICAgICAgIGhlYWRlciA9IF9mb3JtYXRQcm9ibGVtMi5oZWFkZXIsXG4gICAgICAgICAgYm9keSA9IF9mb3JtYXRQcm9ibGVtMi5ib2R5O1xuXG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoaGVhZGVyLCBcIlxcblwiKS5jb25jYXQoc3RyaXBBbnNpKGJvZHkpKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKFwiRXJyb3JzXCIsIHByaW50YWJsZUVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW50YWJsZUVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHByaW50YWJsZUVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRTaG93T3ZlcmxheUZvckVycm9ycyA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwiYm9vbGVhblwiID8gb3B0aW9ucy5vdmVybGF5IDogb3B0aW9ucy5vdmVybGF5ICYmIG9wdGlvbnMub3ZlcmxheS5lcnJvcnM7XG5cbiAgICBpZiAobmVlZFNob3dPdmVybGF5Rm9yRXJyb3JzKSB7XG4gICAgICB2YXIgdHJ1c3RlZFR5cGVzUG9saWN5TmFtZSA9IHR5cGVvZiBvcHRpb25zLm92ZXJsYXkgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5vdmVybGF5LnRydXN0ZWRUeXBlc1BvbGljeU5hbWU7XG4gICAgICBzaG93KFwiZXJyb3JcIiwgX2Vycm9ycywgdHJ1c3RlZFR5cGVzUG9saWN5TmFtZSB8fCBudWxsKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gICAqL1xuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgbG9nLmVycm9yKF9lcnJvcik7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBsb2cuaW5mbyhcIkRpc2Nvbm5lY3RlZCFcIik7XG5cbiAgICBpZiAob3B0aW9ucy5vdmVybGF5KSB7XG4gICAgICBoaWRlKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoXCJDbG9zZVwiKTtcbiAgfVxufTtcbnZhciBzb2NrZXRVUkwgPSBjcmVhdGVTb2NrZXRVUkwocGFyc2VkUmVzb3VyY2VRdWVyeSk7XG5zb2NrZXQoc29ja2V0VVJMLCBvblNvY2tldE1lc3NhZ2UsIG9wdGlvbnMucmVjb25uZWN0KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info&reconnect=10\n");

            /***/
        }),

        /***/
        "./node_modules/webpack-dev-server/client/modules/logger/index.js":
        /*!************************************************************************!*\
          !*** ./node_modules/webpack-dev-server/client/modules/logger/index.js ***!
          \************************************************************************/
        /***/ ((__unused_webpack_module, exports) => {

            eval("/******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./client-src/modules/logger/SyncBailHookFake.js\":\n/*!*******************************************************!*\\\n  !*** ./client-src/modules/logger/SyncBailHookFake.js ***!\n  \\*******************************************************/\n/***/ (function(module) {\n\n\n/**\n * Client stub for tapable SyncBailHook\n */\n\nmodule.exports = function clientTapableSyncBailHook() {\n  return {\n    call: function call() {}\n  };\n};\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/lib/logging/Logger.js\":\n/*!****************************************************!*\\\n  !*** ./node_modules/webpack/lib/logging/Logger.js ***!\n  \\****************************************************/\n/***/ (function(__unused_webpack_module, exports) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; }) !== \"undefined\" && iter[(typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; }).iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar LogType = Object.freeze({\n  error:\n  /** @type {\"error\"} */\n  \"error\",\n  // message, c style arguments\n  warn:\n  /** @type {\"warn\"} */\n  \"warn\",\n  // message, c style arguments\n  info:\n  /** @type {\"info\"} */\n  \"info\",\n  // message, c style arguments\n  log:\n  /** @type {\"log\"} */\n  \"log\",\n  // message, c style arguments\n  debug:\n  /** @type {\"debug\"} */\n  \"debug\",\n  // message, c style arguments\n  trace:\n  /** @type {\"trace\"} */\n  \"trace\",\n  // no arguments\n  group:\n  /** @type {\"group\"} */\n  \"group\",\n  // [label]\n  groupCollapsed:\n  /** @type {\"groupCollapsed\"} */\n  \"groupCollapsed\",\n  // [label]\n  groupEnd:\n  /** @type {\"groupEnd\"} */\n  \"groupEnd\",\n  // [label]\n  profile:\n  /** @type {\"profile\"} */\n  \"profile\",\n  // [profileName]\n  profileEnd:\n  /** @type {\"profileEnd\"} */\n  \"profileEnd\",\n  // [profileName]\n  time:\n  /** @type {\"time\"} */\n  \"time\",\n  // name, time as [seconds, nanoseconds]\n  clear:\n  /** @type {\"clear\"} */\n  \"clear\",\n  // no arguments\n  status:\n  /** @type {\"status\"} */\n  \"status\" // message, arguments\n\n});\nexports.LogType = LogType;\n/** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */\n\nvar LOG_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; })(\"webpack logger raw log method\");\nvar TIMERS_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; })(\"webpack logger times\");\nvar TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; })(\"webpack logger aggregated times\");\n\nvar WebpackLogger = /*#__PURE__*/function () {\n  /**\n   * @param {function(LogTypeEnum, any[]=): void} log log function\n   * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger\n   */\n  function WebpackLogger(log, getChildLogger) {\n    _classCallCheck(this, WebpackLogger);\n\n    this[LOG_SYMBOL] = log;\n    this.getChildLogger = getChildLogger;\n  }\n\n  _createClass(WebpackLogger, [{\n    key: \"error\",\n    value: function error() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      this[LOG_SYMBOL](LogType.error, args);\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      this[LOG_SYMBOL](LogType.warn, args);\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      this[LOG_SYMBOL](LogType.info, args);\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      this[LOG_SYMBOL](LogType.log, args);\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n\n      this[LOG_SYMBOL](LogType.debug, args);\n    }\n  }, {\n    key: \"assert\",\n    value: function assert(assertion) {\n      if (!assertion) {\n        for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          args[_key6 - 1] = arguments[_key6];\n        }\n\n        this[LOG_SYMBOL](LogType.error, args);\n      }\n    }\n  }, {\n    key: \"trace\",\n    value: function trace() {\n      this[LOG_SYMBOL](LogType.trace, [\"Trace\"]);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this[LOG_SYMBOL](LogType.clear);\n    }\n  }, {\n    key: \"status\",\n    value: function status() {\n      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        args[_key7] = arguments[_key7];\n      }\n\n      this[LOG_SYMBOL](LogType.status, args);\n    }\n  }, {\n    key: \"group\",\n    value: function group() {\n      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n        args[_key8] = arguments[_key8];\n      }\n\n      this[LOG_SYMBOL](LogType.group, args);\n    }\n  }, {\n    key: \"groupCollapsed\",\n    value: function groupCollapsed() {\n      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n        args[_key9] = arguments[_key9];\n      }\n\n      this[LOG_SYMBOL](LogType.groupCollapsed, args);\n    }\n  }, {\n    key: \"groupEnd\",\n    value: function groupEnd() {\n      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n        args[_key10] = arguments[_key10];\n      }\n\n      this[LOG_SYMBOL](LogType.groupEnd, args);\n    }\n  }, {\n    key: \"profile\",\n    value: function profile(label) {\n      this[LOG_SYMBOL](LogType.profile, [label]);\n    }\n  }, {\n    key: \"profileEnd\",\n    value: function profileEnd(label) {\n      this[LOG_SYMBOL](LogType.profileEnd, [label]);\n    }\n  }, {\n    key: \"time\",\n    value: function time(label) {\n      this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();\n      this[TIMERS_SYMBOL].set(label, process.hrtime());\n    }\n  }, {\n    key: \"timeLog\",\n    value: function timeLog(label) {\n      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n\n      if (!prev) {\n        throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeLog()\"));\n      }\n\n      var time = process.hrtime(prev);\n      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n    }\n  }, {\n    key: \"timeEnd\",\n    value: function timeEnd(label) {\n      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n\n      if (!prev) {\n        throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeEnd()\"));\n      }\n\n      var time = process.hrtime(prev);\n      this[TIMERS_SYMBOL].delete(label);\n      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n    }\n  }, {\n    key: \"timeAggregate\",\n    value: function timeAggregate(label) {\n      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n\n      if (!prev) {\n        throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeAggregate()\"));\n      }\n\n      var time = process.hrtime(prev);\n      this[TIMERS_SYMBOL].delete(label);\n      this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();\n      var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n\n      if (current !== undefined) {\n        if (time[1] + current[1] > 1e9) {\n          time[0] += current[0] + 1;\n          time[1] = time[1] - 1e9 + current[1];\n        } else {\n          time[0] += current[0];\n          time[1] += current[1];\n        }\n      }\n\n      this[TIMERS_AGGREGATES_SYMBOL].set(label, time);\n    }\n  }, {\n    key: \"timeAggregateEnd\",\n    value: function timeAggregateEnd(label) {\n      if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;\n      var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n      if (time === undefined) return;\n      this[TIMERS_AGGREGATES_SYMBOL].delete(label);\n      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n    }\n  }]);\n\n  return WebpackLogger;\n}();\n\nexports.Logger = WebpackLogger;\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/lib/logging/createConsoleLogger.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!\n  \\*****************************************************************/\n/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_10785__) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; }) !== \"undefined\" && iter[(typeof Symbol !== \"undefined\" ? Symbol : function (i) { return i; }).iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _require = __nested_webpack_require_10785__(/*! ./Logger */ \"./node_modules/webpack/lib/logging/Logger.js\"),\n    LogType = _require.LogType;\n/** @typedef {import(\"../../declarations/WebpackOptions\").FilterItemTypes} FilterItemTypes */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").FilterTypes} FilterTypes */\n\n/** @typedef {import(\"./Logger\").LogTypeEnum} LogTypeEnum */\n\n/** @typedef {function(string): boolean} FilterFunction */\n\n/**\n * @typedef {Object} LoggerConsole\n * @property {function(): void} clear\n * @property {function(): void} trace\n * @property {(...args: any[]) => void} info\n * @property {(...args: any[]) => void} log\n * @property {(...args: any[]) => void} warn\n * @property {(...args: any[]) => void} error\n * @property {(...args: any[]) => void=} debug\n * @property {(...args: any[]) => void=} group\n * @property {(...args: any[]) => void=} groupCollapsed\n * @property {(...args: any[]) => void=} groupEnd\n * @property {(...args: any[]) => void=} status\n * @property {(...args: any[]) => void=} profile\n * @property {(...args: any[]) => void=} profileEnd\n * @property {(...args: any[]) => void=} logTime\n */\n\n/**\n * @typedef {Object} LoggerOptions\n * @property {false|true|\"none\"|\"error\"|\"warn\"|\"info\"|\"log\"|\"verbose\"} level loglevel\n * @property {FilterTypes|boolean} debug filter for debug logging\n * @property {LoggerConsole} console the console to log to\n */\n\n/**\n * @param {FilterItemTypes} item an input item\n * @returns {FilterFunction} filter function\n */\n\n\nvar filterToFunction = function filterToFunction(item) {\n  if (typeof item === \"string\") {\n    var regExp = new RegExp(\"[\\\\\\\\/]\".concat(item.replace( // eslint-disable-next-line no-useless-escape\n    /[-[\\]{}()*+?.\\\\^$|]/g, \"\\\\$&\"), \"([\\\\\\\\/]|$|!|\\\\?)\"));\n    return function (ident) {\n      return regExp.test(ident);\n    };\n  }\n\n  if (item && typeof item === \"object\" && typeof item.test === \"function\") {\n    return function (ident) {\n      return item.test(ident);\n    };\n  }\n\n  if (typeof item === \"function\") {\n    return item;\n  }\n\n  if (typeof item === \"boolean\") {\n    return function () {\n      return item;\n    };\n  }\n};\n/**\n * @enum {number}\n */\n\n\nvar LogLevel = {\n  none: 6,\n  false: 6,\n  error: 5,\n  warn: 4,\n  info: 3,\n  log: 2,\n  true: 2,\n  verbose: 1\n};\n/**\n * @param {LoggerOptions} options options object\n * @returns {function(string, LogTypeEnum, any[]): void} logging function\n */\n\nmodule.exports = function (_ref) {\n  var _ref$level = _ref.level,\n      level = _ref$level === void 0 ? \"info\" : _ref$level,\n      _ref$debug = _ref.debug,\n      debug = _ref$debug === void 0 ? false : _ref$debug,\n      console = _ref.console;\n  var debugFilters = typeof debug === \"boolean\" ? [function () {\n    return debug;\n  }] :\n  /** @type {FilterItemTypes[]} */\n  [].concat(debug).map(filterToFunction);\n  /** @type {number} */\n\n  var loglevel = LogLevel[\"\".concat(level)] || 0;\n  /**\n   * @param {string} name name of the logger\n   * @param {LogTypeEnum} type type of the log entry\n   * @param {any[]} args arguments of the log entry\n   * @returns {void}\n   */\n\n  var logger = function logger(name, type, args) {\n    var labeledArgs = function labeledArgs() {\n      if (Array.isArray(args)) {\n        if (args.length > 0 && typeof args[0] === \"string\") {\n          return [\"[\".concat(name, \"] \").concat(args[0])].concat(_toConsumableArray(args.slice(1)));\n        } else {\n          return [\"[\".concat(name, \"]\")].concat(_toConsumableArray(args));\n        }\n      } else {\n        return [];\n      }\n    };\n\n    var debug = debugFilters.some(function (f) {\n      return f(name);\n    });\n\n    switch (type) {\n      case LogType.debug:\n        if (!debug) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins\n\n        if (typeof console.debug === \"function\") {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          console.debug.apply(console, _toConsumableArray(labeledArgs()));\n        } else {\n          console.log.apply(console, _toConsumableArray(labeledArgs()));\n        }\n\n        break;\n\n      case LogType.log:\n        if (!debug && loglevel > LogLevel.log) return;\n        console.log.apply(console, _toConsumableArray(labeledArgs()));\n        break;\n\n      case LogType.info:\n        if (!debug && loglevel > LogLevel.info) return;\n        console.info.apply(console, _toConsumableArray(labeledArgs()));\n        break;\n\n      case LogType.warn:\n        if (!debug && loglevel > LogLevel.warn) return;\n        console.warn.apply(console, _toConsumableArray(labeledArgs()));\n        break;\n\n      case LogType.error:\n        if (!debug && loglevel > LogLevel.error) return;\n        console.error.apply(console, _toConsumableArray(labeledArgs()));\n        break;\n\n      case LogType.trace:\n        if (!debug) return;\n        console.trace();\n        break;\n\n      case LogType.groupCollapsed:\n        if (!debug && loglevel > LogLevel.log) return;\n\n        if (!debug && loglevel > LogLevel.verbose) {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          if (typeof console.groupCollapsed === \"function\") {\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));\n          } else {\n            console.log.apply(console, _toConsumableArray(labeledArgs()));\n          }\n\n          break;\n        }\n\n      // falls through\n\n      case LogType.group:\n        if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins\n\n        if (typeof console.group === \"function\") {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          console.group.apply(console, _toConsumableArray(labeledArgs()));\n        } else {\n          console.log.apply(console, _toConsumableArray(labeledArgs()));\n        }\n\n        break;\n\n      case LogType.groupEnd:\n        if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins\n\n        if (typeof console.groupEnd === \"function\") {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          console.groupEnd();\n        }\n\n        break;\n\n      case LogType.time:\n        {\n          if (!debug && loglevel > LogLevel.log) return;\n          var ms = args[1] * 1000 + args[2] / 1000000;\n          var msg = \"[\".concat(name, \"] \").concat(args[0], \": \").concat(ms, \" ms\");\n\n          if (typeof console.logTime === \"function\") {\n            console.logTime(msg);\n          } else {\n            console.log(msg);\n          }\n\n          break;\n        }\n\n      case LogType.profile:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        if (typeof console.profile === \"function\") {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          console.profile.apply(console, _toConsumableArray(labeledArgs()));\n        }\n\n        break;\n\n      case LogType.profileEnd:\n        // eslint-disable-next-line node/no-unsupported-features/node-builtins\n        if (typeof console.profileEnd === \"function\") {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));\n        }\n\n        break;\n\n      case LogType.clear:\n        if (!debug && loglevel > LogLevel.log) return; // eslint-disable-next-line node/no-unsupported-features/node-builtins\n\n        if (typeof console.clear === \"function\") {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          console.clear();\n        }\n\n        break;\n\n      case LogType.status:\n        if (!debug && loglevel > LogLevel.info) return;\n\n        if (typeof console.status === \"function\") {\n          if (args.length === 0) {\n            console.status();\n          } else {\n            console.status.apply(console, _toConsumableArray(labeledArgs()));\n          }\n        } else {\n          if (args.length !== 0) {\n            console.info.apply(console, _toConsumableArray(labeledArgs()));\n          }\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unexpected LogType \".concat(type));\n    }\n  };\n\n  return logger;\n};\n\n/***/ }),\n\n/***/ \"./node_modules/webpack/lib/logging/runtime.js\":\n/*!*****************************************************!*\\\n  !*** ./node_modules/webpack/lib/logging/runtime.js ***!\n  \\*****************************************************/\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_20872__) {\n\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nvar SyncBailHook = __nested_webpack_require_20872__(/*! tapable/lib/SyncBailHook */ \"./client-src/modules/logger/SyncBailHookFake.js\");\n\nvar _require = __nested_webpack_require_20872__(/*! ./Logger */ \"./node_modules/webpack/lib/logging/Logger.js\"),\n    Logger = _require.Logger;\n\nvar createConsoleLogger = __nested_webpack_require_20872__(/*! ./createConsoleLogger */ \"./node_modules/webpack/lib/logging/createConsoleLogger.js\");\n/** @type {createConsoleLogger.LoggerOptions} */\n\n\nvar currentDefaultLoggerOptions = {\n  level: \"info\",\n  debug: false,\n  console: console\n};\nvar currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n/**\n * @param {string} name name of the logger\n * @returns {Logger} a logger\n */\n\nexports.getLogger = function (name) {\n  return new Logger(function (type, args) {\n    if (exports.hooks.log.call(name, type, args) === undefined) {\n      currentDefaultLogger(name, type, args);\n    }\n  }, function (childName) {\n    return exports.getLogger(\"\".concat(name, \"/\").concat(childName));\n  });\n};\n/**\n * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options\n * @returns {void}\n */\n\n\nexports.configureDefaultLogger = function (options) {\n  _extends(currentDefaultLoggerOptions, options);\n\n  currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n};\n\nexports.hooks = {\n  log: new SyncBailHook([\"origin\", \"type\", \"args\"])\n};\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_23009__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_23009__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_23009__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_23009__.o(definition, key) && !__nested_webpack_require_23009__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__nested_webpack_require_23009__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t!function() {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_23009__.r = function(exports) {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n!function() {\n/*!********************************************!*\\\n  !*** ./client-src/modules/logger/index.js ***!\n  \\********************************************/\n__nested_webpack_require_23009__.r(__webpack_exports__);\n/* harmony export */ __nested_webpack_require_23009__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default export from named module */ webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_23009__(/*! webpack/lib/logging/runtime.js */ \"./node_modules/webpack/lib/logging/runtime.js\");\n\n}();\nvar __webpack_export_target__ = exports;\nfor(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];\nif(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\n/******/ })()\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC9tb2R1bGVzL2xvZ2dlci9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSxXQUFXLG1GQUFtRixXQUFXO0FBQy9LOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGFBQWEs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O0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQ0FBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0NBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLGdDQUFtQix3QkFBd0IsZ0NBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CLDJCQUEyQjtBQUN6RCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFtQjtBQUM5QjtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQW1CO0FBQ25CLHFCQUFxQixnQ0FBbUI7QUFDeEMsK0NBQStDO0FBQy9DLHNCQUFzQjtBQUN0Qix1RkFBdUYsZ0NBQW1COztBQUUxRyxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9HQUFvRyxhQUFhO0FBQ2pILFVBQVU7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2stZGV2LXNlcnZlci9jbGllbnQvbW9kdWxlcy9sb2dnZXIvaW5kZXguanM/ZTJhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqLyAoZnVuY3Rpb24oKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gXCIuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvU3luY0JhaWxIb29rRmFrZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvU3luY0JhaWxIb29rRmFrZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuXG4vKipcbiAqIENsaWVudCBzdHViIGZvciB0YXBhYmxlIFN5bmNCYWlsSG9va1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY2xpZW50VGFwYWJsZVN5bmNCYWlsSG9vaygpIHtcbiAgcmV0dXJuIHtcbiAgICBjYWxsOiBmdW5jdGlvbiBjYWxsKCkge31cbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvTG9nZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBMb2dUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGVycm9yOlxuICAvKiogQHR5cGUge1wiZXJyb3JcIn0gKi9cbiAgXCJlcnJvclwiLFxuICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICB3YXJuOlxuICAvKiogQHR5cGUge1wid2FyblwifSAqL1xuICBcIndhcm5cIixcbiAgLy8gbWVzc2FnZSwgYyBzdHlsZSBhcmd1bWVudHNcbiAgaW5mbzpcbiAgLyoqIEB0eXBlIHtcImluZm9cIn0gKi9cbiAgXCJpbmZvXCIsXG4gIC8vIG1lc3NhZ2UsIGMgc3R5bGUgYXJndW1lbnRzXG4gIGxvZzpcbiAgLyoqIEB0eXBlIHtcImxvZ1wifSAqL1xuICBcImxvZ1wiLFxuICAvLyBtZXNzYWdlLCBjIHN0eWxlIGFyZ3VtZW50c1xuICBkZWJ1ZzpcbiAgLyoqIEB0eXBlIHtcImRlYnVnXCJ9ICovXG4gIFwiZGVidWdcIixcbiAgLy8gbWVzc2FnZSwgYyBzdHlsZSBhcmd1bWVudHNcbiAgdHJhY2U6XG4gIC8qKiBAdHlwZSB7XCJ0cmFjZVwifSAqL1xuICBcInRyYWNlXCIsXG4gIC8vIG5vIGFyZ3VtZW50c1xuICBncm91cDpcbiAgLyoqIEB0eXBlIHtcImdyb3VwXCJ9ICovXG4gIFwiZ3JvdXBcIixcbiAgLy8gW2xhYmVsXVxuICBncm91cENvbGxhcHNlZDpcbiAgLyoqIEB0eXBlIHtcImdyb3VwQ29sbGFwc2VkXCJ9ICovXG4gIFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgLy8gW2xhYmVsXVxuICBncm91cEVuZDpcbiAgLyoqIEB0eXBlIHtcImdyb3VwRW5kXCJ9ICovXG4gIFwiZ3JvdXBFbmRcIixcbiAgLy8gW2xhYmVsXVxuICBwcm9maWxlOlxuICAvKiogQHR5cGUge1wicHJvZmlsZVwifSAqL1xuICBcInByb2ZpbGVcIixcbiAgLy8gW3Byb2ZpbGVOYW1lXVxuICBwcm9maWxlRW5kOlxuICAvKiogQHR5cGUge1wicHJvZmlsZUVuZFwifSAqL1xuICBcInByb2ZpbGVFbmRcIixcbiAgLy8gW3Byb2ZpbGVOYW1lXVxuICB0aW1lOlxuICAvKiogQHR5cGUge1widGltZVwifSAqL1xuICBcInRpbWVcIixcbiAgLy8gbmFtZSwgdGltZSBhcyBbc2Vjb25kcywgbmFub3NlY29uZHNdXG4gIGNsZWFyOlxuICAvKiogQHR5cGUge1wiY2xlYXJcIn0gKi9cbiAgXCJjbGVhclwiLFxuICAvLyBubyBhcmd1bWVudHNcbiAgc3RhdHVzOlxuICAvKiogQHR5cGUge1wic3RhdHVzXCJ9ICovXG4gIFwic3RhdHVzXCIgLy8gbWVzc2FnZSwgYXJndW1lbnRzXG5cbn0pO1xuZXhwb3J0cy5Mb2dUeXBlID0gTG9nVHlwZTtcbi8qKiBAdHlwZWRlZiB7dHlwZW9mIExvZ1R5cGVba2V5b2YgdHlwZW9mIExvZ1R5cGVdfSBMb2dUeXBlRW51bSAqL1xuXG52YXIgTE9HX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pKFwid2VicGFjayBsb2dnZXIgcmF3IGxvZyBtZXRob2RcIik7XG52YXIgVElNRVJTX1NZTUJPTCA9ICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pKFwid2VicGFjayBsb2dnZXIgdGltZXNcIik7XG52YXIgVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MID0gKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkoXCJ3ZWJwYWNrIGxvZ2dlciBhZ2dyZWdhdGVkIHRpbWVzXCIpO1xuXG52YXIgV2VicGFja0xvZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKExvZ1R5cGVFbnVtLCBhbnlbXT0pOiB2b2lkfSBsb2cgbG9nIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nIHwgZnVuY3Rpb24oKTogc3RyaW5nKTogV2VicGFja0xvZ2dlcn0gZ2V0Q2hpbGRMb2dnZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGNoaWxkIGxvZ2dlclxuICAgKi9cbiAgZnVuY3Rpb24gV2VicGFja0xvZ2dlcihsb2csIGdldENoaWxkTG9nZ2VyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYnBhY2tMb2dnZXIpO1xuXG4gICAgdGhpc1tMT0dfU1lNQk9MXSA9IGxvZztcbiAgICB0aGlzLmdldENoaWxkTG9nZ2VyID0gZ2V0Q2hpbGRMb2dnZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2VicGFja0xvZ2dlciwgW3tcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmVycm9yLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2FyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YXJuKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLndhcm4sIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZm8oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgYXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuaW5mbywgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2coKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUubG9nLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVidWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZGVidWcsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhc3NlcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0KGFzc2VydGlvbikge1xuICAgICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW42ID4gMSA/IF9sZW42IC0gMSA6IDApLCBfa2V5NiA9IDE7IF9rZXk2IDwgX2xlbjY7IF9rZXk2KyspIHtcbiAgICAgICAgICBhcmdzW19rZXk2IC0gMV0gPSBhcmd1bWVudHNbX2tleTZdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmVycm9yLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhY2UoKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudHJhY2UsIFtcIlRyYWNlXCJdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuY2xlYXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0dXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdHVzKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjcgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW43KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW43OyBfa2V5NysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnN0YXR1cywgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdyb3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyb3VwKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW44KSwgX2tleTggPSAwOyBfa2V5OCA8IF9sZW44OyBfa2V5OCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleThdID0gYXJndW1lbnRzW19rZXk4XTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmdyb3VwLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JvdXBDb2xsYXBzZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXBDb2xsYXBzZWQoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuOSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjkpLCBfa2V5OSA9IDA7IF9rZXk5IDwgX2xlbjk7IF9rZXk5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5OV0gPSBhcmd1bWVudHNbX2tleTldO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUuZ3JvdXBDb2xsYXBzZWQsIGFyZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJncm91cEVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBncm91cEVuZCgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4xMCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjEwKSwgX2tleTEwID0gMDsgX2tleTEwIDwgX2xlbjEwOyBfa2V5MTArKykge1xuICAgICAgICBhcmdzW19rZXkxMF0gPSBhcmd1bWVudHNbX2tleTEwXTtcbiAgICAgIH1cblxuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLmdyb3VwRW5kLCBhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvZmlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9maWxlKGxhYmVsKSB7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUucHJvZmlsZSwgW2xhYmVsXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2ZpbGVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZmlsZUVuZChsYWJlbCkge1xuICAgICAgdGhpc1tMT0dfU1lNQk9MXShMb2dUeXBlLnByb2ZpbGVFbmQsIFtsYWJlbF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWUobGFiZWwpIHtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0gPSB0aGlzW1RJTUVSU19TWU1CT0xdIHx8IG5ldyBNYXAoKTtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uc2V0KGxhYmVsLCBwcm9jZXNzLmhydGltZSgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUxvZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lTG9nKGxhYmVsKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUxvZygpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50aW1lLCBbbGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGltZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lRW5kKGxhYmVsKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUVuZCgpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uZGVsZXRlKGxhYmVsKTtcbiAgICAgIHRoaXNbTE9HX1NZTUJPTF0oTG9nVHlwZS50aW1lLCBbbGFiZWxdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGltZSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGltZUFnZ3JlZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0aW1lQWdncmVnYXRlKGxhYmVsKSB7XG4gICAgICB2YXIgcHJldiA9IHRoaXNbVElNRVJTX1NZTUJPTF0gJiYgdGhpc1tUSU1FUlNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc3VjaCBsYWJlbCAnXCIuY29uY2F0KGxhYmVsLCBcIicgZm9yIFdlYnBhY2tMb2dnZXIudGltZUFnZ3JlZ2F0ZSgpXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZShwcmV2KTtcbiAgICAgIHRoaXNbVElNRVJTX1NZTUJPTF0uZGVsZXRlKGxhYmVsKTtcbiAgICAgIHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSB8fCBuZXcgTWFwKCk7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXS5nZXQobGFiZWwpO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aW1lWzFdICsgY3VycmVudFsxXSA+IDFlOSkge1xuICAgICAgICAgIHRpbWVbMF0gKz0gY3VycmVudFswXSArIDE7XG4gICAgICAgICAgdGltZVsxXSA9IHRpbWVbMV0gLSAxZTkgKyBjdXJyZW50WzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVbMF0gKz0gY3VycmVudFswXTtcbiAgICAgICAgICB0aW1lWzFdICs9IGN1cnJlbnRbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLnNldChsYWJlbCwgdGltZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRpbWVBZ2dyZWdhdGVFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZUFnZ3JlZ2F0ZUVuZChsYWJlbCkge1xuICAgICAgaWYgKHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICB2YXIgdGltZSA9IHRoaXNbVElNRVJTX0FHR1JFR0FURVNfU1lNQk9MXS5nZXQobGFiZWwpO1xuICAgICAgaWYgKHRpbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgdGhpc1tUSU1FUlNfQUdHUkVHQVRFU19TWU1CT0xdLmRlbGV0ZShsYWJlbCk7XG4gICAgICB0aGlzW0xPR19TWU1CT0xdKExvZ1R5cGUudGltZSwgW2xhYmVsXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRpbWUpKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFdlYnBhY2tMb2dnZXI7XG59KCk7XG5cbmV4cG9ydHMuTG9nZ2VyID0gV2VicGFja0xvZ2dlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9jcmVhdGVDb25zb2xlTG9nZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL2NyZWF0ZUNvbnNvbGVMb2dnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sIDogZnVuY3Rpb24gKGkpIHsgcmV0dXJuIGk7IH0pICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyBTeW1ib2wgOiBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaTsgfSkuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Mb2dnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL0xvZ2dlci5qc1wiKSxcbiAgICBMb2dUeXBlID0gX3JlcXVpcmUuTG9nVHlwZTtcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZGVjbGFyYXRpb25zL1dlYnBhY2tPcHRpb25zXCIpLkZpbHRlckl0ZW1UeXBlc30gRmlsdGVySXRlbVR5cGVzICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KFwiLi4vLi4vZGVjbGFyYXRpb25zL1dlYnBhY2tPcHRpb25zXCIpLkZpbHRlclR5cGVzfSBGaWx0ZXJUeXBlcyAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4vTG9nZ2VyXCIpLkxvZ1R5cGVFbnVtfSBMb2dUeXBlRW51bSAqL1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9uKHN0cmluZyk6IGJvb2xlYW59IEZpbHRlckZ1bmN0aW9uICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTG9nZ2VyQ29uc29sZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSBjbGVhclxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiB2b2lkfSB0cmFjZVxuICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWR9IGluZm9cbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSBsb2dcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkfSB3YXJuXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZH0gZXJyb3JcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZGVidWdcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBDb2xsYXBzZWRcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gZ3JvdXBFbmRcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gc3RhdHVzXG4gKiBAcHJvcGVydHkgeyguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD19IHByb2ZpbGVcbiAqIEBwcm9wZXJ0eSB7KC4uLmFyZ3M6IGFueVtdKSA9PiB2b2lkPX0gcHJvZmlsZUVuZFxuICogQHByb3BlcnR5IHsoLi4uYXJnczogYW55W10pID0+IHZvaWQ9fSBsb2dUaW1lXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBMb2dnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge2ZhbHNlfHRydWV8XCJub25lXCJ8XCJlcnJvclwifFwid2FyblwifFwiaW5mb1wifFwibG9nXCJ8XCJ2ZXJib3NlXCJ9IGxldmVsIGxvZ2xldmVsXG4gKiBAcHJvcGVydHkge0ZpbHRlclR5cGVzfGJvb2xlYW59IGRlYnVnIGZpbHRlciBmb3IgZGVidWcgbG9nZ2luZ1xuICogQHByb3BlcnR5IHtMb2dnZXJDb25zb2xlfSBjb25zb2xlIHRoZSBjb25zb2xlIHRvIGxvZyB0b1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtGaWx0ZXJJdGVtVHlwZXN9IGl0ZW0gYW4gaW5wdXQgaXRlbVxuICogQHJldHVybnMge0ZpbHRlckZ1bmN0aW9ufSBmaWx0ZXIgZnVuY3Rpb25cbiAqL1xuXG5cbnZhciBmaWx0ZXJUb0Z1bmN0aW9uID0gZnVuY3Rpb24gZmlsdGVyVG9GdW5jdGlvbihpdGVtKSB7XG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciByZWdFeHAgPSBuZXcgUmVnRXhwKFwiW1xcXFxcXFxcL11cIi5jb25jYXQoaXRlbS5yZXBsYWNlKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgICAvWy1bXFxde30oKSorPy5cXFxcXiR8XS9nLCBcIlxcXFwkJlwiKSwgXCIoW1xcXFxcXFxcL118JHwhfFxcXFw/KVwiKSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpZGVudCkge1xuICAgICAgcmV0dXJuIHJlZ0V4cC50ZXN0KGlkZW50KTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGl0ZW0udGVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpZGVudCkge1xuICAgICAgcmV0dXJuIGl0ZW0udGVzdChpZGVudCk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICBpZiAodHlwZW9mIGl0ZW0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gIH1cbn07XG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cblxuXG52YXIgTG9nTGV2ZWwgPSB7XG4gIG5vbmU6IDYsXG4gIGZhbHNlOiA2LFxuICBlcnJvcjogNSxcbiAgd2FybjogNCxcbiAgaW5mbzogMyxcbiAgbG9nOiAyLFxuICB0cnVlOiAyLFxuICB2ZXJib3NlOiAxXG59O1xuLyoqXG4gKiBAcGFyYW0ge0xvZ2dlck9wdGlvbnN9IG9wdGlvbnMgb3B0aW9ucyBvYmplY3RcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIExvZ1R5cGVFbnVtLCBhbnlbXSk6IHZvaWR9IGxvZ2dpbmcgZnVuY3Rpb25cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBfcmVmJGxldmVsID0gX3JlZi5sZXZlbCxcbiAgICAgIGxldmVsID0gX3JlZiRsZXZlbCA9PT0gdm9pZCAwID8gXCJpbmZvXCIgOiBfcmVmJGxldmVsLFxuICAgICAgX3JlZiRkZWJ1ZyA9IF9yZWYuZGVidWcsXG4gICAgICBkZWJ1ZyA9IF9yZWYkZGVidWcgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRkZWJ1ZyxcbiAgICAgIGNvbnNvbGUgPSBfcmVmLmNvbnNvbGU7XG4gIHZhciBkZWJ1Z0ZpbHRlcnMgPSB0eXBlb2YgZGVidWcgPT09IFwiYm9vbGVhblwiID8gW2Z1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1dIDpcbiAgLyoqIEB0eXBlIHtGaWx0ZXJJdGVtVHlwZXNbXX0gKi9cbiAgW10uY29uY2F0KGRlYnVnKS5tYXAoZmlsdGVyVG9GdW5jdGlvbik7XG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gIHZhciBsb2dsZXZlbCA9IExvZ0xldmVsW1wiXCIuY29uY2F0KGxldmVsKV0gfHwgMDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIGxvZ2dlclxuICAgKiBAcGFyYW0ge0xvZ1R5cGVFbnVtfSB0eXBlIHR5cGUgb2YgdGhlIGxvZyBlbnRyeVxuICAgKiBAcGFyYW0ge2FueVtdfSBhcmdzIGFyZ3VtZW50cyBvZiB0aGUgbG9nIGVudHJ5XG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuICB2YXIgbG9nZ2VyID0gZnVuY3Rpb24gbG9nZ2VyKG5hbWUsIHR5cGUsIGFyZ3MpIHtcbiAgICB2YXIgbGFiZWxlZEFyZ3MgPSBmdW5jdGlvbiBsYWJlbGVkQXJncygpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gW1wiW1wiLmNvbmNhdChuYW1lLCBcIl0gXCIpLmNvbmNhdChhcmdzWzBdKV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzLnNsaWNlKDEpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtcIltcIi5jb25jYXQobmFtZSwgXCJdXCIpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZGVidWcgPSBkZWJ1Z0ZpbHRlcnMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYobmFtZSk7XG4gICAgfSk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgTG9nVHlwZS5kZWJ1ZzpcbiAgICAgICAgaWYgKCFkZWJ1ZykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmRlYnVnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmxvZzpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmluZm86XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5pbmZvKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUuaW5mby5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLndhcm46XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC53YXJuKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmVycm9yOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwuZXJyb3IpIHJldHVybjtcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLnRyYWNlOlxuICAgICAgICBpZiAoIWRlYnVnKSByZXR1cm47XG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5ncm91cENvbGxhcHNlZDpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuXG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC52ZXJib3NlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5ncm91cENvbGxhcHNlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuXG4gICAgICBjYXNlIExvZ1R5cGUuZ3JvdXA6XG4gICAgICAgIGlmICghZGVidWcgJiYgbG9nbGV2ZWwgPiBMb2dMZXZlbC5sb2cpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5ncm91cCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUuZ3JvdXAuYXBwbHkoY29uc29sZSwgX3RvQ29uc3VtYWJsZUFycmF5KGxhYmVsZWRBcmdzKCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5ncm91cEVuZDpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmdyb3VwRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS50aW1lOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmxvZykgcmV0dXJuO1xuICAgICAgICAgIHZhciBtcyA9IGFyZ3NbMV0gKiAxMDAwICsgYXJnc1syXSAvIDEwMDAwMDA7XG4gICAgICAgICAgdmFyIG1zZyA9IFwiW1wiLmNvbmNhdChuYW1lLCBcIl0gXCIpLmNvbmNhdChhcmdzWzBdLCBcIjogXCIpLmNvbmNhdChtcywgXCIgbXNcIik7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUubG9nVGltZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZ1RpbWUobXNnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIExvZ1R5cGUucHJvZmlsZTpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUucHJvZmlsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGluc1xuICAgICAgICAgIGNvbnNvbGUucHJvZmlsZS5hcHBseShjb25zb2xlLCBfdG9Db25zdW1hYmxlQXJyYXkobGFiZWxlZEFyZ3MoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTG9nVHlwZS5wcm9maWxlRW5kOlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS5wcm9maWxlRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zXG4gICAgICAgICAgY29uc29sZS5wcm9maWxlRW5kLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLmNsZWFyOlxuICAgICAgICBpZiAoIWRlYnVnICYmIGxvZ2xldmVsID4gTG9nTGV2ZWwubG9nKSByZXR1cm47IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuY2xlYXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnNcbiAgICAgICAgICBjb25zb2xlLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMb2dUeXBlLnN0YXR1czpcbiAgICAgICAgaWYgKCFkZWJ1ZyAmJiBsb2dsZXZlbCA+IExvZ0xldmVsLmluZm8pIHJldHVybjtcblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUuc3RhdHVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuc3RhdHVzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuc3RhdHVzLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvLmFwcGx5KGNvbnNvbGUsIF90b0NvbnN1bWFibGVBcnJheShsYWJlbGVkQXJncygpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgTG9nVHlwZSBcIi5jb25jYXQodHlwZSkpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbG9nZ2VyO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy93ZWJwYWNrL2xpYi9sb2dnaW5nL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgU3luY0JhaWxIb29rID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdGFwYWJsZS9saWIvU3luY0JhaWxIb29rICovIFwiLi9jbGllbnQtc3JjL21vZHVsZXMvbG9nZ2VyL1N5bmNCYWlsSG9va0Zha2UuanNcIik7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vTG9nZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9Mb2dnZXIuanNcIiksXG4gICAgTG9nZ2VyID0gX3JlcXVpcmUuTG9nZ2VyO1xuXG52YXIgY3JlYXRlQ29uc29sZUxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlQ29uc29sZUxvZ2dlciAqLyBcIi4vbm9kZV9tb2R1bGVzL3dlYnBhY2svbGliL2xvZ2dpbmcvY3JlYXRlQ29uc29sZUxvZ2dlci5qc1wiKTtcbi8qKiBAdHlwZSB7Y3JlYXRlQ29uc29sZUxvZ2dlci5Mb2dnZXJPcHRpb25zfSAqL1xuXG5cbnZhciBjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMgPSB7XG4gIGxldmVsOiBcImluZm9cIixcbiAgZGVidWc6IGZhbHNlLFxuICBjb25zb2xlOiBjb25zb2xlXG59O1xudmFyIGN1cnJlbnREZWZhdWx0TG9nZ2VyID0gY3JlYXRlQ29uc29sZUxvZ2dlcihjdXJyZW50RGVmYXVsdExvZ2dlck9wdGlvbnMpO1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBsb2dnZXJcbiAqIEByZXR1cm5zIHtMb2dnZXJ9IGEgbG9nZ2VyXG4gKi9cblxuZXhwb3J0cy5nZXRMb2dnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gbmV3IExvZ2dlcihmdW5jdGlvbiAodHlwZSwgYXJncykge1xuICAgIGlmIChleHBvcnRzLmhvb2tzLmxvZy5jYWxsKG5hbWUsIHR5cGUsIGFyZ3MpID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnREZWZhdWx0TG9nZ2VyKG5hbWUsIHR5cGUsIGFyZ3MpO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgIHJldHVybiBleHBvcnRzLmdldExvZ2dlcihcIlwiLmNvbmNhdChuYW1lLCBcIi9cIikuY29uY2F0KGNoaWxkTmFtZSkpO1xuICB9KTtcbn07XG4vKipcbiAqIEBwYXJhbSB7Y3JlYXRlQ29uc29sZUxvZ2dlci5Mb2dnZXJPcHRpb25zfSBvcHRpb25zIG5ldyBvcHRpb25zLCBtZXJnZSB3aXRoIG9sZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuXG5cbmV4cG9ydHMuY29uZmlndXJlRGVmYXVsdExvZ2dlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIF9leHRlbmRzKGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgY3VycmVudERlZmF1bHRMb2dnZXIgPSBjcmVhdGVDb25zb2xlTG9nZ2VyKGN1cnJlbnREZWZhdWx0TG9nZ2VyT3B0aW9ucyk7XG59O1xuXG5leHBvcnRzLmhvb2tzID0ge1xuICBsb2c6IG5ldyBTeW5jQmFpbEhvb2soW1wib3JpZ2luXCIsIFwidHlwZVwiLCBcImFyZ3NcIl0pXG59O1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0IWZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0oKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4hZnVuY3Rpb24oKSB7XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NsaWVudC1zcmMvbW9kdWxlcy9sb2dnZXIvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogcmVleHBvcnQgZGVmYXVsdCBleHBvcnQgZnJvbSBuYW1lZCBtb2R1bGUgKi8gd2VicGFja19saWJfbG9nZ2luZ19ydW50aW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX187IH1cbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHdlYnBhY2tfbGliX2xvZ2dpbmdfcnVudGltZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzICovIFwiLi9ub2RlX21vZHVsZXMvd2VicGFjay9saWIvbG9nZ2luZy9ydW50aW1lLmpzXCIpO1xuXG59KCk7XG52YXIgX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfXyA9IGV4cG9ydHM7XG5mb3IodmFyIGkgaW4gX193ZWJwYWNrX2V4cG9ydHNfXykgX193ZWJwYWNrX2V4cG9ydF90YXJnZXRfX1tpXSA9IF9fd2VicGFja19leHBvcnRzX19baV07XG5pZihfX3dlYnBhY2tfZXhwb3J0c19fLl9fZXNNb2R1bGUpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfZXhwb3J0X3RhcmdldF9fLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIH0pKClcbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/modules/logger/index.js\n");

            /***/
        }),

        /***/
        "./node_modules/webpack-dev-server/client/utils/log.js":
        /*!*************************************************************!*\
          !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
          \*************************************************************/
        /***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

            "use strict";
            eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"setLogLevel\": () => (/* binding */ setLogLevel)\n/* harmony export */ });\n/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logger/index.js */ \"./node_modules/webpack-dev-server/client/modules/logger/index.js\");\n/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__);\n\nvar name = \"webpack-dev-server\"; // default level is set on the client side, so it does not need\n// to be set by the CLI or API\n\nvar defaultLevel = \"info\"; // options new options, merge with old options\n\n/**\n * @param {false | true | \"none\" | \"error\" | \"warn\" | \"info\" | \"log\" | \"verbose\"} level\n * @returns {void}\n */\n\nfunction setLogLevel(level) {\n  _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().configureDefaultLogger({\n    level: level\n  });\n}\n\nsetLogLevel(defaultLevel);\nvar log = _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().getLogger(name);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay1kZXYtc2VydmVyL2NsaWVudC91dGlscy9sb2cuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRDtBQUNoRCxpQ0FBaUM7QUFDakM7O0FBRUEsMkJBQTJCOztBQUUzQjtBQUNBLFdBQVcsdUVBQXVFO0FBQ2xGLGFBQWE7QUFDYjs7QUFFQTtBQUNBLEVBQUUsc0ZBQTZCO0FBQy9CO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsVUFBVSx5RUFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW1pbmFsLWFwcC8uL25vZGVfbW9kdWxlcy93ZWJwYWNrLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcz8wMzg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBsb2dnZXIgZnJvbSBcIi4uL21vZHVsZXMvbG9nZ2VyL2luZGV4LmpzXCI7XG52YXIgbmFtZSA9IFwid2VicGFjay1kZXYtc2VydmVyXCI7IC8vIGRlZmF1bHQgbGV2ZWwgaXMgc2V0IG9uIHRoZSBjbGllbnQgc2lkZSwgc28gaXQgZG9lcyBub3QgbmVlZFxuLy8gdG8gYmUgc2V0IGJ5IHRoZSBDTEkgb3IgQVBJXG5cbnZhciBkZWZhdWx0TGV2ZWwgPSBcImluZm9cIjsgLy8gb3B0aW9ucyBuZXcgb3B0aW9ucywgbWVyZ2Ugd2l0aCBvbGQgb3B0aW9uc1xuXG4vKipcbiAqIEBwYXJhbSB7ZmFsc2UgfCB0cnVlIHwgXCJub25lXCIgfCBcImVycm9yXCIgfCBcIndhcm5cIiB8IFwiaW5mb1wiIHwgXCJsb2dcIiB8IFwidmVyYm9zZVwifSBsZXZlbFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgbG9nZ2VyLmNvbmZpZ3VyZURlZmF1bHRMb2dnZXIoe1xuICAgIGxldmVsOiBsZXZlbFxuICB9KTtcbn1cblxuc2V0TG9nTGV2ZWwoZGVmYXVsdExldmVsKTtcbnZhciBsb2cgPSBsb2dnZXIuZ2V0TG9nZ2VyKG5hbWUpO1xuZXhwb3J0IHsgbG9nLCBzZXRMb2dMZXZlbCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack-dev-server/client/utils/log.js\n");

            /***/
        }),

        /***/
        "./node_modules/webpack/hot/emitter.js":
        /*!*********************************************!*\
          !*** ./node_modules/webpack/hot/emitter.js ***!
          \*********************************************/
        /***/ ((module, __unused_webpack_exports, __webpack_require__) => {

            eval("var EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nmodule.exports = new EventEmitter();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvZW1pdHRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQywrQ0FBUTtBQUNuQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2VtaXR0ZXIuanM/OTNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/emitter.js\n");

            /***/
        }),

        /***/
        "./node_modules/webpack/hot/log.js":
        /*!*****************************************!*\
          !*** ./node_modules/webpack/hot/log.js ***!
          \*****************************************/
        /***/ ((module) => {

            eval("var logLevel = \"info\";\n\nfunction dummy() {}\n\nfunction shouldLog(level) {\n\tvar shouldLog =\n\t\t(logLevel === \"info\" && level === \"info\") ||\n\t\t([\"info\", \"warning\"].indexOf(logLevel) >= 0 && level === \"warning\") ||\n\t\t([\"info\", \"warning\", \"error\"].indexOf(logLevel) >= 0 && level === \"error\");\n\treturn shouldLog;\n}\n\nfunction logGroup(logFn) {\n\treturn function (level, msg) {\n\t\tif (shouldLog(level)) {\n\t\t\tlogFn(msg);\n\t\t}\n\t};\n}\n\nmodule.exports = function (level, msg) {\n\tif (shouldLog(level)) {\n\t\tif (level === \"info\") {\n\t\t\tconsole.log(msg);\n\t\t} else if (level === \"warning\") {\n\t\t\tconsole.warn(msg);\n\t\t} else if (level === \"error\") {\n\t\t\tconsole.error(msg);\n\t\t}\n\t}\n};\n\n/* eslint-disable node/no-unsupported-features/node-builtins */\nvar group = console.group || dummy;\nvar groupCollapsed = console.groupCollapsed || dummy;\nvar groupEnd = console.groupEnd || dummy;\n/* eslint-enable node/no-unsupported-features/node-builtins */\n\nmodule.exports.group = logGroup(group);\n\nmodule.exports.groupCollapsed = logGroup(groupCollapsed);\n\nmodule.exports.groupEnd = logGroup(groupEnd);\n\nmodule.exports.setLogLevel = function (level) {\n\tlogLevel = level;\n};\n\nmodule.exports.formatError = function (err) {\n\tvar message = err.message;\n\tvar stack = err.stack;\n\tif (!stack) {\n\t\treturn message;\n\t} else if (stack.indexOf(message) < 0) {\n\t\treturn message + \"\\n\" + stack;\n\t} else {\n\t\treturn stack;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9ob3QvbG9nLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQiw2QkFBNkI7O0FBRTdCLHVCQUF1Qjs7QUFFdkIsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xpbWluYWwtYXBwLy4vbm9kZV9tb2R1bGVzL3dlYnBhY2svaG90L2xvZy5qcz83NTk2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdGxvZ0ZuKG1zZyk7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcblx0dmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblx0dmFyIHN0YWNrID0gZXJyLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH0gZWxzZSBpZiAoc3RhY2suaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcblx0XHRyZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gc3RhY2s7XG5cdH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/hot/log.js\n");

            /***/
        }),

        /***/
        "?8131":
        /*!************************!*\
          !*** buffer (ignored) ***!
          \************************/
        /***/ (() => {

            /* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/
    /******/ 	/* webpack/runtime/define property getters */
    /******/
    (() => {
        /******/ 		// define getter functions for harmony exports
        /******/
        __webpack_require__.d = (exports, definition) => {
            /******/
            for (var key in definition) {
                /******/
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    /******/
                    Object.defineProperty(exports, key, {enumerable: true, get: definition[key]});
                    /******/
                }
                /******/
            }
            /******/
        };
        /******/
    })();
    /******/
    /******/ 	/* webpack/runtime/getFullHash */
    /******/
    (() => {
        /******/
        __webpack_require__.h = () => ("f8f3bdd28a856460bc34")
        /******/
    })();
    /******/
    /******/ 	/* webpack/runtime/global */
    /******/
    (() => {
        /******/
        __webpack_require__.g = (function () {
            /******/
            if (typeof globalThis === 'object') return globalThis;
            /******/
            try {
                /******/
                return this || new Function('return this')();
                /******/
            } catch (e) {
                /******/
                if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
            /******/
            if (!module.children) module.children = [];
            /******/
            return module;
            /******/
        };
        /******/
    })();
    /******/
    /************************************************************************/
    /******/
    /******/ 	// startup
    /******/ 	// Load entry module and return exports
    /******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
    /******/
    __webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=8080&pathname=%2Fws&logging=info&reconnect=10");
    /******/
    var __webpack_exports__ = __webpack_require__("./src/main.ts");
    /******/
    /******/
})()
;